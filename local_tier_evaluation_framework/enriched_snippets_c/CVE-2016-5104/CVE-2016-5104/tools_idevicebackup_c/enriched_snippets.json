[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
    "lines": "680-1621",
    "snippet": "int main(int argc, char *argv[])\n{\n\tidevice_error_t ret = IDEVICE_E_UNKNOWN_ERROR;\n\tlockdownd_error_t ldret = LOCKDOWN_E_UNKNOWN_ERROR;\n\tint i;\n\tchar* udid = NULL;\n\tlockdownd_service_descriptor_t service = NULL;\n\tint cmd = -1;\n\tint is_full_backup = 0;\n\tchar *backup_directory = NULL;\n\tstruct stat st;\n\tplist_t node = NULL;\n\tplist_t node_tmp = NULL;\n\tplist_t manifest_plist = NULL;\n\tplist_t info_plist = NULL;\n\tchar *buffer = NULL;\n\tchar *file_path = NULL;\n\tuint64_t length = 0;\n\tuint64_t backup_total_size = 0;\n\tenum device_link_file_status_t file_status = DEVICE_LINK_FILE_STATUS_NONE;\n\tuint64_t c = 0;\n\n\t/* we need to exit cleanly on running backups and restores or we cause havok */\n\tsignal(SIGINT, clean_exit);\n\tsignal(SIGTERM, clean_exit);\n#ifndef WIN32\n\tsignal(SIGQUIT, clean_exit);\n\tsignal(SIGPIPE, SIG_IGN);\n#endif\n\n\t/* parse cmdline args */\n\tfor (i = 1; i < argc; i++) {\n\t\tif (!strcmp(argv[i], \"-d\") || !strcmp(argv[i], \"--debug\")) {\n\t\t\tidevice_set_debug_level(1);\n\t\t\tcontinue;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"-u\") || !strcmp(argv[i], \"--udid\")) {\n\t\t\ti++;\n\t\t\tif (!argv[i] || (strlen(argv[i]) != 40)) {\n\t\t\t\tprint_usage(argc, argv);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tudid = strdup(argv[i]);\n\t\t\tcontinue;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"-h\") || !strcmp(argv[i], \"--help\")) {\n\t\t\tprint_usage(argc, argv);\n\t\t\treturn 0;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"backup\")) {\n\t\t\tcmd = CMD_BACKUP;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"restore\")) {\n\t\t\tcmd = CMD_RESTORE;\n\t\t}\n\t\telse if (backup_directory == NULL) {\n\t\t\tbackup_directory = argv[i];\n\t\t}\n\t\telse {\n\t\t\tprint_usage(argc, argv);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* verify options */\n\tif (cmd == -1) {\n\t\tprintf(\"No command specified.\\n\");\n\t\tprint_usage(argc, argv);\n\t\treturn -1;\n\t}\n\n\tif (backup_directory == NULL) {\n\t\tprintf(\"No target backup directory specified.\\n\");\n\t\tprint_usage(argc, argv);\n\t\treturn -1;\n\t}\n\n\t/* verify if passed backup directory exists */\n\tif (stat(backup_directory, &st) != 0) {\n\t\tprintf(\"ERROR: Backup directory \\\"%s\\\" does not exist!\\n\", backup_directory);\n\t\treturn -1;\n\t}\n\n\t/* restore directory must contain an Info.plist */\n\tchar *info_path = mobilebackup_build_path(backup_directory, \"Info\", \".plist\");\n\tif (cmd == CMD_RESTORE) {\n\t\tif (stat(info_path, &st) != 0) {\n\t\t\tfree(info_path);\n\t\t\tprintf(\"ERROR: Backup directory \\\"%s\\\" is invalid. No Info.plist found.\\n\", backup_directory);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tprintf(\"Backup directory is \\\"%s\\\"\\n\", backup_directory);\n\n\tif (udid) {\n\t\tret = idevice_new(&device, udid);\n\t\tif (ret != IDEVICE_E_SUCCESS) {\n\t\t\tprintf(\"No device found with udid %s, is it plugged in?\\n\", udid);\n\t\t\treturn -1;\n\t\t}\n\t}\n\telse\n\t{\n\t\tret = idevice_new(&device, NULL);\n\t\tif (ret != IDEVICE_E_SUCCESS) {\n\t\t\tprintf(\"No device found, is it plugged in?\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS != (ldret = lockdownd_client_new_with_handshake(device, &client, \"idevicebackup\"))) {\n\t\tprintf(\"ERROR: Could not connect to lockdownd, error code %d\\n\", ldret);\n\t\tidevice_free(device);\n\t\treturn -1;\n\t}\n\n\tnode = NULL;\n\tlockdownd_get_value(client, NULL, \"ProductVersion\", &node);\n\tif (node) {\n\t\tchar* str = NULL;\n\t\tif (plist_get_node_type(node) == PLIST_STRING) {\n\t\t\tplist_get_string_val(node, &str);\n\t\t}\n\t\tplist_free(node);\n\t\tnode = NULL;\n\t\tif (str) {\n\t\t\tint maj = strtol(str, NULL, 10);\n\t\t\tfree(str);\n\t\t\tif (maj > 3) {\n\t\t\t\tprintf(\"ERROR: This tool is only compatible with iOS 3 or below. For newer iOS versions please use the idevicebackup2 tool.\\n\");\n\t\t\t\tlockdownd_client_free(client);\n\t\t\t\tidevice_free(device);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* start notification_proxy */\n\tnp_client_t np = NULL;\n\tldret = lockdownd_start_service(client, NP_SERVICE_NAME, &service);\n\tif ((ldret == LOCKDOWN_E_SUCCESS) && service && service->port) {\n\t\tnp_client_new(device, service, &np);\n\t\tnp_set_notify_callback(np, notify_cb, NULL);\n\t\tconst char *noties[5] = {\n\t\t\tNP_SYNC_CANCEL_REQUEST,\n\t\t\tNP_SYNC_SUSPEND_REQUEST,\n\t\t\tNP_SYNC_RESUME_REQUEST,\n\t\t\tNP_BACKUP_DOMAIN_CHANGED,\n\t\t\tNULL\n\t\t};\n\t\tnp_observe_notifications(np, noties);\n\t} else {\n\t\tprintf(\"ERROR: Could not start service %s.\\n\", NP_SERVICE_NAME);\n\t}\n\n\tafc_client_t afc = NULL;\n\tif (cmd == CMD_BACKUP) {\n\t\t/* start AFC, we need this for the lock file */\n\t\tservice->port = 0;\n\t\tservice->ssl_enabled = 0;\n\t\tldret = lockdownd_start_service(client, \"com.apple.afc\", &service);\n\t\tif ((ldret == LOCKDOWN_E_SUCCESS) && service->port) {\n\t\t\tafc_client_new(device, service, &afc);\n\t\t}\n\t}\n\n\tif (service) {\n\t\tlockdownd_service_descriptor_free(service);\n\t\tservice = NULL;\n\t}\n\n\t/* start mobilebackup service and retrieve port */\n\tldret = lockdownd_start_service(client, MOBILEBACKUP_SERVICE_NAME, &service);\n\tif ((ldret == LOCKDOWN_E_SUCCESS) && service && service->port) {\n\t\tprintf(\"Started \\\"%s\\\" service on port %d.\\n\", MOBILEBACKUP_SERVICE_NAME, service->port);\n\t\tmobilebackup_client_new(device, service, &mobilebackup);\n\n\t\tif (service) {\n\t\t\tlockdownd_service_descriptor_free(service);\n\t\t\tservice = NULL;\n\t\t}\n\n\t\t/* check abort conditions */\n\t\tif (quit_flag > 0) {\n\t\t\tprintf(\"Aborting backup. Cancelled by user.\\n\");\n\t\t\tcmd = CMD_LEAVE;\n\t\t}\n\n\t\t/* verify existing Info.plist */\n\t\tif (stat(info_path, &st) == 0) {\n\t\t\tprintf(\"Reading Info.plist from backup.\\n\");\n\t\t\tplist_read_from_filename(&info_plist, info_path);\n\n\t\t\tif (!info_plist) {\n\t\t\t\tprintf(\"Could not read Info.plist\\n\");\n\t\t\t\tis_full_backup = 1;\n\t\t\t}\n\t\t\tif (info_plist && (cmd == CMD_BACKUP)) {\n\t\t\t\tif (mobilebackup_info_is_current_device(info_plist)) {\n\t\t\t\t\t/* update the last backup time within Info.plist */\n\t\t\t\t\tmobilebackup_info_update_last_backup_date(info_plist);\n\t\t\t\t\tremove(info_path);\n\t\t\t\t\tplist_write_to_filename(info_plist, info_path, PLIST_FORMAT_XML);\n\t\t\t\t} else {\n\t\t\t\t\tprintf(\"Aborting backup. Backup is not compatible with the current device.\\n\");\n\t\t\t\t\tcmd = CMD_LEAVE;\n\t\t\t\t}\n\t\t\t} else if (info_plist && (cmd == CMD_RESTORE)) {\n\t\t\t\tif (!mobilebackup_info_is_current_device(info_plist)) {\n\t\t\t\t\tprintf(\"Aborting restore. Backup data is not compatible with the current device.\\n\");\n\t\t\t\t\tcmd = CMD_LEAVE;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (cmd == CMD_RESTORE) {\n\t\t\t\tprintf(\"Aborting restore. Info.plist is missing.\\n\");\n\t\t\t\tcmd = CMD_LEAVE;\n\t\t\t} else {\n\t\t\t\tis_full_backup = 1;\n\t\t\t}\n\t\t}\n\n\t\tuint64_t lockfile = 0;\n\t\tif (cmd == CMD_BACKUP) {\n\t\t\tdo_post_notification(NP_SYNC_WILL_START);\n\t\t\tafc_file_open(afc, \"/com.apple.itunes.lock_sync\", AFC_FOPEN_RW, &lockfile);\n\t\t}\n\t\tif (lockfile) {\n\t\t\tafc_error_t aerr;\n\t\t\tdo_post_notification(NP_SYNC_LOCK_REQUEST);\n\t\t\tfor (i = 0; i < LOCK_ATTEMPTS; i++) {\n\t\t\t\taerr = afc_file_lock(afc, lockfile, AFC_LOCK_EX);\n\t\t\t\tif (aerr == AFC_E_SUCCESS) {\n\t\t\t\t\tdo_post_notification(NP_SYNC_DID_START);\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (aerr == AFC_E_OP_WOULD_BLOCK) {\n\t\t\t\t\tusleep(LOCK_WAIT);\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"ERROR: could not lock file! error code: %d\\n\", aerr);\n\t\t\t\t\tafc_file_close(afc, lockfile);\n\t\t\t\t\tlockfile = 0;\n\t\t\t\t\tcmd = CMD_LEAVE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == LOCK_ATTEMPTS) {\n\t\t\t\tfprintf(stderr, \"ERROR: timeout while locking for sync\\n\");\n\t\t\t\tafc_file_close(afc, lockfile);\n\t\t\t\tlockfile = 0;\n\t\t\t\tcmd = CMD_LEAVE;\n\t\t\t}\n\t\t}\n\n\t\tmobilebackup_error_t err;\n\n\t\t/* Manifest.plist (backup manifest (backup state)) */\n\t\tchar *manifest_path = mobilebackup_build_path(backup_directory, \"Manifest\", \".plist\");\n\n\t\tswitch(cmd) {\n\t\t\tcase CMD_BACKUP:\n\t\t\tprintf(\"Starting backup...\\n\");\n\t\t\t/* TODO: check domain com.apple.mobile.backup key RequiresEncrypt and WillEncrypt with lockdown */\n\t\t\t/* TODO: verify battery on AC enough battery remaining */\n\n\t\t\t/* read the last Manifest.plist */\n\t\t\tif (!is_full_backup) {\n\t\t\t\tprintf(\"Reading existing Manifest.\\n\");\n\t\t\t\tplist_read_from_filename(&manifest_plist, manifest_path);\n\t\t\t\tif (!manifest_plist) {\n\t\t\t\t\tprintf(\"Could not read Manifest.plist, switching to full backup mode.\\n\");\n\t\t\t\t\tis_full_backup = 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Info.plist (Device infos, IC-Info.sidb, photos, app_ids, iTunesPrefs) */\n\n\t\t\t/* create new Info.plist on new backups */\n\t\t\tif (is_full_backup) {\n\t\t\t\tif (info_plist) {\n\t\t\t\t\tplist_free(info_plist);\n\t\t\t\t\tinfo_plist = NULL;\n\t\t\t\t}\n\t\t\t\tremove(info_path);\n\t\t\t\tprintf(\"Creating Info.plist for new backup.\\n\");\n\t\t\t\tinfo_plist = mobilebackup_factory_info_plist_new(udid);\n\t\t\t\tplist_write_to_filename(info_plist, info_path, PLIST_FORMAT_XML);\n\t\t\t}\n\t\t\tfree(info_path);\n\n\t\t\tplist_free(info_plist);\n\t\t\tinfo_plist = NULL;\n\n\t\t\t/* close down the lockdown connection as it is no longer needed */\n\t\t\tif (client) {\n\t\t\t\tlockdownd_client_free(client);\n\t\t\t\tclient = NULL;\n\t\t\t}\n\n\t\t\t/* create Status.plist with failed status for now */\n\t\t\tmobilebackup_write_status(backup_directory, 0);\n\n\t\t\t/* request backup from device with manifest from last backup */\n\t\t\tprintf(\"Requesting backup from device...\\n\");\n\n\t\t\terr = mobilebackup_request_backup(mobilebackup, manifest_plist, \"/\", \"1.6\");\n\t\t\tif (err == MOBILEBACKUP_E_SUCCESS) {\n\t\t\t\tif (is_full_backup)\n\t\t\t\t\tprintf(\"Full backup mode.\\n\");\n\t\t\t\telse\n\t\t\t\t\tprintf(\"Incremental backup mode.\\n\");\n\t\t\t\tprintf(\"Please wait. Device is preparing backup data...\\n\");\n\t\t\t} else {\n\t\t\t\tif (err == MOBILEBACKUP_E_BAD_VERSION) {\n\t\t\t\t\tprintf(\"ERROR: Could not start backup process: backup protocol version mismatch!\\n\");\n\t\t\t\t} else if (err == MOBILEBACKUP_E_REPLY_NOT_OK) {\n\t\t\t\t\tprintf(\"ERROR: Could not start backup process: device refused to start the backup process.\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tprintf(\"ERROR: Could not start backup process: unspecified error occured\\n\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* reset backup status */\n\t\t\tint backup_ok = 0;\n\t\t\tplist_t message = NULL;\n\n\t\t\t/* receive and save DLSendFile files and metadata, ACK each */\n\t\t\tuint64_t file_size = 0;\n\t\t\tuint64_t file_size_current = 0;\n\t\t\tint file_index = 0;\n\t\t\tint hunk_index = 0;\n\t\t\tuint64_t backup_real_size = 0;\n\t\t\tchar *file_ext = NULL;\n\t\t\tchar *filename_mdinfo = NULL;\n\t\t\tchar *filename_mddata = NULL;\n\t\t\tchar *filename_source = NULL;\n\t\t\tchar *format_size = NULL;\n\t\t\tint is_manifest = 0;\n\t\t\tuint8_t b = 0;\n\n\t\t\t/* process series of DLSendFile messages */\n\t\t\tdo {\n\t\t\t\tmobilebackup_receive(mobilebackup, &message);\n\t\t\t\tif (!message) {\n\t\t\t\t\tprintf(\"Device is not ready yet. Going to try again in 2 seconds...\\n\");\n\t\t\t\t\tsleep(2);\n\t\t\t\t\tgoto files_out;\n\t\t\t\t}\n\n\t\t\t\tnode = plist_array_get_item(message, 0);\n\n\t\t\t\t/* get out if we don't get a DLSendFile */\n\t\t\t\tif (plist_strcmp(node, \"DLSendFile\"))\n\t\t\t\t\tbreak;\n\n\t\t\t\tnode_tmp = plist_array_get_item(message, 2);\n\n\t\t\t\t/* first message hunk contains total backup size */\n\t\t\t\tif ((hunk_index == 0) && (file_index == 0)) {\n\t\t\t\t\tnode = plist_dict_get_item(node_tmp, \"BackupTotalSizeKey\");\n\t\t\t\t\tif (node) {\n\t\t\t\t\t\tplist_get_uint_val(node, &backup_total_size);\n\t\t\t\t\t\tformat_size = string_format_size(backup_total_size);\n\t\t\t\t\t\tprintf(\"Backup data requires %s on the disk.\\n\", format_size);\n\t\t\t\t\t\tfree(format_size);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* check DLFileStatusKey (codes: 1 = Hunk, 2 = Last Hunk) */\n\t\t\t\tnode = plist_dict_get_item(node_tmp, \"DLFileStatusKey\");\n\t\t\t\tplist_get_uint_val(node, &c);\n\t\t\t\tfile_status = c;\n\n\t\t\t\t/* get source filename */\n\t\t\t\tnode = plist_dict_get_item(node_tmp, \"BackupManifestKey\");\n\t\t\t\tb = 0;\n\t\t\t\tif (node) {\n\t\t\t\t\tplist_get_bool_val(node, &b);\n\t\t\t\t}\n\t\t\t\tis_manifest = (b == 1) ? 1 : 0;\n\n\t\t\t\tif ((hunk_index == 0) && (!is_manifest)) {\n\t\t\t\t\t/* get source filename */\n\t\t\t\t\tnode = plist_dict_get_item(node_tmp, \"DLFileSource\");\n\t\t\t\t\tplist_get_string_val(node, &filename_source);\n\n\t\t\t\t\t/* increase received size */\n\t\t\t\t\tnode = plist_dict_get_item(node_tmp, \"DLFileAttributesKey\");\n\t\t\t\t\tnode = plist_dict_get_item(node, \"FileSize\");\n\t\t\t\t\tplist_get_uint_val(node, &file_size);\n\t\t\t\t\tbackup_real_size += file_size;\n\n\t\t\t\t\tformat_size = string_format_size(backup_real_size);\n\t\t\t\t\tprintf(\"(%s\", format_size);\n\t\t\t\t\tfree(format_size);\n\n\t\t\t\t\tformat_size = string_format_size(backup_total_size);\n\t\t\t\t\tprintf(\"/%s): \", format_size);\n\t\t\t\t\tfree(format_size);\n\n\t\t\t\t\tformat_size = string_format_size(file_size);\n\t\t\t\t\tprintf(\"Receiving file %s (%s)... \\n\", filename_source, format_size);\n\t\t\t\t\tfree(format_size);\n\n\t\t\t\t\tif (filename_source)\n\t\t\t\t\t\tfree(filename_source);\n\t\t\t\t}\n\n\t\t\t\t/* check if we completed a file */\n\t\t\t\tif ((file_status == DEVICE_LINK_FILE_STATUS_LAST_HUNK) && (!is_manifest)) {\n\t\t\t\t\t/* save <hash>.mdinfo */\n\t\t\t\t\tnode = plist_dict_get_item(node_tmp, \"BackupFileInfo\");\n\t\t\t\t\tif (node) {\n\t\t\t\t\t\tnode = plist_dict_get_item(node_tmp, \"DLFileDest\");\n\t\t\t\t\t\tplist_get_string_val(node, &file_path);\n\n\t\t\t\t\t\tfilename_mdinfo = mobilebackup_build_path(backup_directory, file_path, \".mdinfo\");\n\n\t\t\t\t\t\t/* remove any existing file */\n\t\t\t\t\t\tif (stat(filename_mdinfo, &st) == 0)\n\t\t\t\t\t\t\tremove(filename_mdinfo);\n\n\t\t\t\t\t\tnode = plist_dict_get_item(node_tmp, \"BackupFileInfo\");\n\t\t\t\t\t\tplist_write_to_filename(node, filename_mdinfo, PLIST_FORMAT_BINARY);\n\n\t\t\t\t\t\tfree(filename_mdinfo);\n\t\t\t\t\t}\n\n\t\t\t\t\tfile_index++;\n\t\t\t\t}\n\n\t\t\t\t/* save <hash>.mddata */\n\t\t\t\tnode = plist_dict_get_item(node_tmp, \"BackupFileInfo\");\n\t\t\t\tif (node_tmp) {\n\t\t\t\t\tnode = plist_dict_get_item(node_tmp, \"DLFileDest\");\n\t\t\t\t\tplist_get_string_val(node, &file_path);\n\n\t\t\t\t\tfilename_mddata = mobilebackup_build_path(backup_directory, file_path, is_manifest ? NULL: \".mddata\");\n\n\t\t\t\t\t/* if this is the first hunk, remove any existing file */\n\t\t\t\t\tif ((hunk_index == 0) && (stat(filename_mddata, &st) == 0))\n\t\t\t\t\t\tremove(filename_mddata);\n\n\t\t\t\t\t/* get file data hunk */\n\t\t\t\t\tnode_tmp = plist_array_get_item(message, 1);\n\t\t\t\t\tplist_get_data_val(node_tmp, &buffer, &length);\n\n\t\t\t\t\tbuffer_write_to_filename(filename_mddata, buffer, length);\n\t\t\t\t\tif (!is_manifest)\n\t\t\t\t\t\tfile_size_current += length;\n\n\t\t\t\t\t/* activate currently sent manifest */\n\t\t\t\t\tif ((file_status == DEVICE_LINK_FILE_STATUS_LAST_HUNK) && (is_manifest)) {\n\t\t\t\t\t\trename(filename_mddata, manifest_path);\n\t\t\t\t\t}\n\n\t\t\t\t\tfree(buffer);\n\t\t\t\t\tbuffer = NULL;\n\n\t\t\t\t\tfree(filename_mddata);\n\t\t\t\t}\n\n\t\t\t\tif ((!is_manifest)) {\n\t\t\t\t\tif (hunk_index == 0 && file_status == DEVICE_LINK_FILE_STATUS_LAST_HUNK) {\n\t\t\t\t\t\t\tprint_progress(100);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (file_size > 0)\n\t\t\t\t\t\t\tprint_progress((double)((file_size_current*100)/file_size));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\thunk_index++;\n\n\t\t\t\tif (file_ext)\n\t\t\t\t\tfree(file_ext);\n\n\t\t\t\tif (message)\n\t\t\t\t\tplist_free(message);\n\t\t\t\tmessage = NULL;\n\n\t\t\t\tif (file_status == DEVICE_LINK_FILE_STATUS_LAST_HUNK) {\n\t\t\t\t\t/* acknowlegdge that we received the file */\n\t\t\t\t\tmobilebackup_send_backup_file_received(mobilebackup);\n\t\t\t\t\t/* reset hunk_index */\n\t\t\t\t\thunk_index = 0;\n\t\t\t\t\tif (!is_manifest) {\n\t\t\t\t\t\tfile_size_current = 0;\n\t\t\t\t\t\tfile_size = 0;\n\t\t\t\t\t}\n\t\t\t\t}\nfiles_out:\n\t\t\t\tif (quit_flag > 0) {\n\t\t\t\t\t/* need to cancel the backup here */\n\t\t\t\t\tmobilebackup_send_error(mobilebackup, \"Cancelling DLSendFile\");\n\n\t\t\t\t\t/* remove any atomic Manifest.plist.tmp */\n\t\t\t\t\tif (manifest_path)\n\t\t\t\t\t\tfree(manifest_path);\n\n\t\t\t\t\tmanifest_path = mobilebackup_build_path(backup_directory, \"Manifest\", \".plist.tmp\");\n\t\t\t\t\tif (stat(manifest_path, &st) == 0)\n\t\t\t\t\t\tremove(manifest_path);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (1);\n\n\t\t\tprintf(\"Received %d files from device.\\n\", file_index);\n\n\t\t\tif (!quit_flag && !plist_strcmp(node, \"DLMessageProcessMessage\")) {\n\t\t\t\tnode_tmp = plist_array_get_item(message, 1);\n\t\t\t\tnode = plist_dict_get_item(node_tmp, \"BackupMessageTypeKey\");\n\t\t\t\t/* check if we received the final \"backup finished\" message */\n\t\t\t\tif (node && !plist_strcmp(node, \"BackupMessageBackupFinished\")) {\n\t\t\t\t\t/* backup finished */\n\n\t\t\t\t\t/* process BackupFilesToDeleteKey */\n\t\t\t\t\tnode = plist_dict_get_item(node_tmp, \"BackupFilesToDeleteKey\");\n\t\t\t\t\tif (node) {\n\t\t\t\t\t\tlength = plist_array_get_size(node);\n\t\t\t\t\t\ti = 0;\n\t\t\t\t\t\twhile ((node_tmp = plist_array_get_item(node, i++)) != NULL) {\n\t\t\t\t\t\t\tplist_get_string_val(node_tmp, &file_path);\n\n\t\t\t\t\t\t\tif (mobilebackup_delete_backup_file_by_hash(backup_directory, file_path)) {\n\t\t\t\t\t\t\t\tprintf(\"DONE\\n\");\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\tprintf(\"FAILED\\n\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/* save last valid Manifest.plist */\n\t\t\t\t\tnode_tmp = plist_array_get_item(message, 1);\n\t\t\t\t\tmanifest_plist = plist_dict_get_item(node_tmp, \"BackupManifestKey\");\n\t\t\t\t\tif (manifest_plist) {\n\t\t\t\t\t\tremove(manifest_path);\n\t\t\t\t\t\tprintf(\"Storing Manifest.plist...\\n\");\n\t\t\t\t\t\tplist_write_to_filename(manifest_plist, manifest_path, PLIST_FORMAT_XML);\n\t\t\t\t\t}\n\n\t\t\t\t\tbackup_ok = 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (backup_ok) {\n\t\t\t\t/* Status.plist (Info on how the backup process turned out) */\n\t\t\t\tprintf(\"Backup Successful.\\n\");\n\t\t\t\tmobilebackup_write_status(backup_directory, 1);\n\t\t\t} else {\n\t\t\t\tprintf(\"Backup Failed.\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase CMD_RESTORE:\n\t\t\t/* close down the lockdown connection as it is no longer needed */\n\t\t\tif (client) {\n\t\t\t\tlockdownd_client_free(client);\n\t\t\t\tclient = NULL;\n\t\t\t}\n\n\t\t\t/* TODO: verify battery on AC enough battery remaining */\n\n\t\t\t/* verify if Status.plist says we read from an successful backup */\n\t\t\tif (mobilebackup_read_status(backup_directory) <= 0) {\n\t\t\t\tprintf(\"ERROR: Cannot ensure we restore from a successful backup. Aborting.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* now make sure backup integrity is ok! verify all files */\n\t\t\tprintf(\"Reading existing Manifest.\\n\");\n\t\t\tplist_read_from_filename(&manifest_plist, manifest_path);\n\t\t\tif (!manifest_plist) {\n\t\t\t\tprintf(\"Could not read Manifest.plist. Aborting.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tprintf(\"Verifying backup integrity, please wait.\\n\");\n\t\t\tchar *bin = NULL;\n\t\t\tuint64_t binsize = 0;\n\t\t\tnode = plist_dict_get_item(manifest_plist, \"Data\");\n\t\t\tif (!node || (plist_get_node_type(node) != PLIST_DATA)) {\n\t\t\t\tprintf(\"Could not read Data key from Manifest.plist!\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tplist_get_data_val(node, &bin, &binsize);\n\t\t\tplist_t backup_data = NULL;\n\t\t\tif (bin) {\n\t\t\t\tchar *auth_ver = NULL;\n\t\t\t\tunsigned char *auth_sig = NULL;\n\t\t\t\tuint64_t auth_sig_len = 0;\n\t\t\t\t/* verify AuthSignature */\n\t\t\t\tnode = plist_dict_get_item(manifest_plist, \"AuthVersion\");\n\t\t\t\tplist_get_string_val(node, &auth_ver);\n\t\t\t\tif (auth_ver && (strcmp(auth_ver, \"2.0\") == 0)) {\n\t\t\t\t\tnode = plist_dict_get_item(manifest_plist, \"AuthSignature\");\n\t\t\t\t\tif (node && (plist_get_node_type(node) == PLIST_DATA)) {\n\t\t\t\t\t\tplist_get_data_val(node, (char**)&auth_sig, &auth_sig_len);\n\t\t\t\t\t}\n\t\t\t\t\tif (auth_sig && (auth_sig_len == 20)) {\n\t\t\t\t\t\t/* calculate the sha1, then compare */\n\t\t\t\t\t\tunsigned char data_sha1[20];\n\t\t\t\t\t\tsha1_of_data(bin, binsize, data_sha1);\n\t\t\t\t\t\tif (compare_hash(auth_sig, data_sha1, 20)) {\n\t\t\t\t\t\t\tprintf(\"AuthSignature is valid\\n\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tprintf(\"ERROR: AuthSignature is NOT VALID\\n\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprintf(\"Could not get AuthSignature from manifest!\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tfree(auth_sig);\n\t\t\t\t} else if (auth_ver) {\n\t\t\t\t\tprintf(\"Unknown AuthVersion '%s', cannot verify AuthSignature\\n\", auth_ver);\n\t\t\t\t}\n\t\t\t\tplist_from_bin(bin, (uint32_t)binsize, &backup_data);\n\t\t\t\tfree(bin);\n\t\t\t}\n\t\t\tif (!backup_data) {\n\t\t\t\tprintf(\"Could not read plist from Manifest.plist Data key!\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tplist_t files = plist_dict_get_item(backup_data, \"Files\");\n\t\t\tif (files && (plist_get_node_type(files) == PLIST_DICT)) {\n\t\t\t\tplist_dict_iter iter = NULL;\n\t\t\t\tplist_dict_new_iter(files, &iter);\n\t\t\t\tif (iter) {\n\t\t\t\t\t/* loop over Files entries in Manifest data plist */\n\t\t\t\t\tchar *hash = NULL;\n\t\t\t\t\tint file_ok = 0;\n\t\t\t\t\tint total_files = plist_dict_get_size(files);\n\t\t\t\t\tint cur_file = 1;\n\t\t\t\t\tnode = NULL;\n\t\t\t\t\tplist_dict_next_item(files, iter, &hash, &node);\n\t\t\t\t\twhile (node) {\n\t\t\t\t\t\tprintf(\"Verifying file %d/%d (%d%%) \\r\", cur_file, total_files, (cur_file*100/total_files));\n\t\t\t\t\t\tcur_file++;\n\t\t\t\t\t\t/* make sure both .mddata/.mdinfo files are available for each entry */\n\t\t\t\t\t\tfile_ok = mobilebackup_check_file_integrity(backup_directory, hash, node);\n\t\t\t\t\t\tnode = NULL;\n\t\t\t\t\t\tfree(hash);\n\t\t\t\t\t\thash = NULL;\n\t\t\t\t\t\tif (!file_ok) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tplist_dict_next_item(files, iter, &hash, &node);\n\t\t\t\t\t}\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\t\tfree(iter);\n\t\t\t\t\tif (!file_ok) {\n\t\t\t\t\t\tplist_free(backup_data);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tprintf(\"All backup files appear to be valid\\n\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprintf(\"Requesting restore from device...\\n\");\n\n\t\t\t/* request restore from device with manifest (BackupMessageRestoreMigrate) */\n\t\t\tint restore_flags = MB_RESTORE_NOTIFY_SPRINGBOARD | MB_RESTORE_PRESERVE_SETTINGS | MB_RESTORE_PRESERVE_CAMERA_ROLL;\n\t\t\terr = mobilebackup_request_restore(mobilebackup, manifest_plist, restore_flags, \"1.6\");\n\t\t\tif (err != MOBILEBACKUP_E_SUCCESS) {\n\t\t\t\tif (err == MOBILEBACKUP_E_BAD_VERSION) {\n\t\t\t\t\tprintf(\"ERROR: Could not start restore process: backup protocol version mismatch!\\n\");\n\t\t\t\t} else if (err == MOBILEBACKUP_E_REPLY_NOT_OK) {\n\t\t\t\t\tprintf(\"ERROR: Could not start restore process: device refused to start the restore process.\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tprintf(\"ERROR: Could not start restore process: unspecified error occured (%d)\\n\", err);\n\t\t\t\t}\n\t\t\t\tplist_free(backup_data);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tprintf(\"Entered restore mode.\\n\");\n\n\t\t\tint restore_ok = 0;\n\n\t\t\tif (files && (plist_get_node_type(files) == PLIST_DICT)) {\n\t\t\t\tplist_dict_iter iter = NULL;\n\t\t\t\tplist_dict_new_iter(files, &iter);\n\t\t\t\tif (iter) {\n\t\t\t\t\t/* loop over Files entries in Manifest data plist */\n\t\t\t\t\tchar *hash = NULL;\n\t\t\t\t\tplist_t file_info = NULL;\n\t\t\t\t\tchar *file_info_path = NULL;\n\t\t\t\t\tint total_files = plist_dict_get_size(files);\n\t\t\t\t\tint cur_file = 0;\n\t\t\t\t\tuint64_t file_offset = 0;\n\t\t\t\t\tuint8_t is_encrypted = 0;\n\t\t\t\t\tplist_t tmp_node = NULL;\n\t\t\t\t\tplist_t file_path_node = NULL;\n\t\t\t\t\tplist_t send_file_node = NULL;\n\t\t\t\t\tnode = NULL;\n\t\t\t\t\tplist_dict_next_item(files, iter, &hash, &node);\n\t\t\t\t\twhile (node) {\n\t\t\t\t\t\t/* TODO: read mddata/mdinfo files and send to device using DLSendFile */\n\t\t\t\t\t\tfile_info_path = mobilebackup_build_path(backup_directory, hash, \".mdinfo\");\n\t\t\t\t\t\tplist_read_from_filename(&file_info, file_info_path);\n\n\t\t\t\t\t\t/* get encryption state */\n\t\t\t\t\t\ttmp_node = plist_dict_get_item(file_info, \"IsEncrypted\");\n\t\t\t\t\t\tplist_get_bool_val(tmp_node, &is_encrypted);\n\t\t\t\t\t\ttmp_node = NULL;\n\n\t\t\t\t\t\t/* get real file path from metadata */\n\t\t\t\t\t\ttmp_node = plist_dict_get_item(file_info, \"Metadata\");\n\t\t\t\t\t\tplist_get_data_val(tmp_node, &buffer, &length);\n\t\t\t\t\t\ttmp_node = NULL;\n\t\t\t\t\t\tplist_from_bin(buffer, length, &tmp_node);\n\t\t\t\t\t\tfile_path_node = plist_dict_get_item(tmp_node, \"Path\");\n\t\t\t\t\t\tplist_get_string_val(file_path_node, &file_path);\n\n\t\t\t\t\t\tprintf(\"Restoring file %s %d/%d (%d%%)... \", file_path, cur_file, total_files, (cur_file*100/total_files));\n\n\t\t\t\t\t\t/* add additional device link file information keys */\n\t\t\t\t\t\tplist_dict_set_item(file_info, \"DLFileAttributesKey\", plist_copy(node));\n\t\t\t\t\t\tplist_dict_set_item(file_info, \"DLFileSource\", plist_new_string(file_info_path));\n\t\t\t\t\t\tplist_dict_set_item(file_info, \"DLFileDest\", plist_new_string(\"/tmp/RestoreFile.plist\"));\n\t\t\t\t\t\tplist_dict_set_item(file_info, \"DLFileIsEncrypted\", plist_new_bool(is_encrypted));\n\t\t\t\t\t\tplist_dict_set_item(file_info, \"DLFileOffsetKey\", plist_new_uint(file_offset));\n\t\t\t\t\t\tplist_dict_set_item(file_info, \"DLFileStatusKey\", plist_new_uint(file_status));\n\n\t\t\t\t\t\t/* read data from file */\n\t\t\t\t\t\tfree(file_info_path);\n\t\t\t\t\t\tfile_info_path = mobilebackup_build_path(backup_directory, hash, \".mddata\");\n\n\t\t\t\t\t\t/* determine file size */\n#ifdef WIN32\n\t\t\t\t\t\tstruct _stati64 fst;\n\t\t\t\t\t\tif (_stati64(file_info_path, &fst) != 0)\n#else\n\t\t\t\t\t\tstruct stat fst;\n\t\t\t\t\t\tif (stat(file_info_path, &fst) != 0)\n#endif\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tprintf(\"ERROR: stat() failed for '%s': %s\\n\", file_info_path, strerror(errno));\n\t\t\t\t\t\t\tfree(file_info_path);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlength = fst.st_size;\n\n\t\t\t\t\t\tFILE *f = fopen(file_info_path, \"rb\");\n\t\t\t\t\t\tif (!f) {\n\t\t\t\t\t\t\tprintf(\"ERROR: could not open local file '%s': %s\\n\", file_info_path, strerror(errno));\n\t\t\t\t\t\t\tfree(file_info_path);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree(file_info_path);\n\n\t\t\t\t\t\t/* send DLSendFile messages */\n\t\t\t\t\t\tfile_offset = 0;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tchar buf[8192];\n\t\t\t\t\t\t\tsize_t len = fread(buf, 1, sizeof(buf), f);\n\n\t\t\t\t\t\t\tif ((length-file_offset) <= sizeof(buf))\n\t\t\t\t\t\t\t\tfile_status = DEVICE_LINK_FILE_STATUS_LAST_HUNK;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tfile_status = DEVICE_LINK_FILE_STATUS_HUNK;\n\n\t\t\t\t\t\t\tplist_dict_remove_item(file_info, \"DLFileOffsetKey\");\n\t\t\t\t\t\t\tplist_dict_set_item(file_info, \"DLFileOffsetKey\", plist_new_uint(file_offset));\n\n\t\t\t\t\t\t\tplist_dict_remove_item(file_info, \"DLFileStatusKey\");\n\t\t\t\t\t\t\tplist_dict_set_item(file_info, \"DLFileStatusKey\", plist_new_uint(file_status));\n\n\t\t\t\t\t\t\tsend_file_node = plist_new_array();\n\n\t\t\t\t\t\t\tplist_array_append_item(send_file_node, plist_new_string(\"DLSendFile\"));\n\n\t\t\t\t\t\t\tplist_array_append_item(send_file_node, plist_new_data(buf, len));\n\t\t\t\t\t\t\tplist_array_append_item(send_file_node, plist_copy(file_info));\n\n\t\t\t\t\t\t\terr = mobilebackup_send(mobilebackup, send_file_node);\n\t\t\t\t\t\t\tif (err != MOBILEBACKUP_E_SUCCESS) {\n\t\t\t\t\t\t\t\tprintf(\"ERROR: Unable to send file hunk due to error %d. Aborting...\\n\", err);\n\t\t\t\t\t\t\t\tfile_status = DEVICE_LINK_FILE_STATUS_NONE;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (file_status == DEVICE_LINK_FILE_STATUS_LAST_HUNK) {\n\t\t\t\t\t\t\t\t/* TODO: if all hunks of a file are sent, device must send ack */\n\t\t\t\t\t\t\t\terr = mobilebackup_receive_restore_file_received(mobilebackup, NULL);\n\t\t\t\t\t\t\t\tif (err != MOBILEBACKUP_E_SUCCESS) {\n\t\t\t\t\t\t\t\t\tprintf(\"ERROR: Did not receive an ack for the sent file due to error %d. Aborting...\\n\", err);\n\t\t\t\t\t\t\t\t\tfile_status = DEVICE_LINK_FILE_STATUS_NONE;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfile_offset += len;\n\n\t\t\t\t\t\t\tif (file_status == DEVICE_LINK_FILE_STATUS_LAST_HUNK)\n\t\t\t\t\t\t\t\tprintf(\"DONE\\n\");\n\n\t\t\t\t\t\t\tplist_free(send_file_node);\n\n\t\t\t\t\t\t\tif (file_status == DEVICE_LINK_FILE_STATUS_NONE)\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t} while((file_offset < length));\n\n\t\t\t\t\t\tfree(hash);\n\t\t\t\t\t\tnode = NULL;\n\t\t\t\t\t\thash = NULL;\n\n\t\t\t\t\t\trestore_ok = 1;\n\t\t\t\t\t\tif (file_status == DEVICE_LINK_FILE_STATUS_NONE) {\n\t\t\t\t\t\t\trestore_ok = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcur_file++;\n\t\t\t\t\t\tplist_dict_next_item(files, iter, &hash, &node);\n\t\t\t\t\t}\n\t\t\t\t\tfree(iter);\n\n\t\t\t\t\tprintf(\"Restored %d files on device.\\n\", cur_file);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* TODO: observe notification_proxy id com.apple.mobile.application_installed */\n\t\t\t/* TODO: loop over Applications entries in Manifest data plist */\n\t\t\tplist_t applications = plist_dict_get_item(backup_data, \"Applications\");\n\t\t\tif (applications && (plist_get_node_type(applications) == PLIST_DICT) && restore_ok) {\n\t\t\t\tplist_dict_iter iter = NULL;\n\t\t\t\tplist_dict_new_iter(applications, &iter);\n\t\t\t\tif (iter) {\n\t\t\t\t\t/* loop over Application entries in Manifest data plist */\n\t\t\t\t\tchar *hash = NULL;\n\t\t\t\t\tint total_files = plist_dict_get_size(applications);\n\t\t\t\t\tint cur_file = 1;\n\t\t\t\t\tplist_t tmp_node = NULL;\n\t\t\t\t\tplist_t dict = NULL;\n\t\t\t\t\tplist_t array = NULL;\n\t\t\t\t\tnode = NULL;\n\t\t\t\t\tplist_dict_next_item(applications, iter, &hash, &node);\n\t\t\t\t\twhile (node) {\n\t\t\t\t\t\tprintf(\"Restoring Application %s %d/%d (%d%%)...\", hash, cur_file, total_files, (cur_file*100/total_files));\n\t\t\t\t\t\t/* FIXME: receive com.apple.mobile.application_installed notification */\n\t\t\t\t\t\t/* send AppInfo entry */\n\t\t\t\t\t\ttmp_node = plist_dict_get_item(node, \"AppInfo\");\n\n\t\t\t\t\t\tdict = plist_new_dict();\n\t\t\t\t\t\tplist_dict_set_item(dict, \"AppInfo\", plist_copy(tmp_node));\n\t\t\t\t\t\tplist_dict_set_item(dict, \"BackupMessageTypeKey\", plist_new_string(\"BackupMessageRestoreApplicationSent\"));\n\n\t\t\t\t\t\tarray = plist_new_array();\n\t\t\t\t\t\tplist_array_append_item(array, plist_new_string(\"DLMessageProcessMessage\"));\n\t\t\t\t\t\tplist_array_append_item(array, dict);\n\n\t\t\t\t\t\terr = mobilebackup_send(mobilebackup, array);\n\t\t\t\t\t\tif (err != MOBILEBACKUP_E_SUCCESS) {\n\t\t\t\t\t\t\tprintf(\"ERROR: Unable to restore application %s due to error %d. Aborting...\\n\", hash, err);\n\t\t\t\t\t\t\trestore_ok = 0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tplist_free(array);\n\t\t\t\t\t\tarray = NULL;\n\t\t\t\t\t\tdict = NULL;\n\n\t\t\t\t\t\t/* receive BackupMessageRestoreApplicationReceived from device */\n\t\t\t\t\t\tif (restore_ok) {\n\t\t\t\t\t\t\terr = mobilebackup_receive_restore_application_received(mobilebackup, NULL);\n\t\t\t\t\t\t\tif (err != MOBILEBACKUP_E_SUCCESS) {\n\t\t\t\t\t\t\t\tprintf(\"ERROR: Failed to receive an ack from the device for this application due to error %d. Aborting...\\n\", err);\n\t\t\t\t\t\t\t\trestore_ok = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttmp_node = NULL;\n\t\t\t\t\t\tnode = NULL;\n\t\t\t\t\t\tfree(hash);\n\t\t\t\t\t\thash = NULL;\n\n\t\t\t\t\t\tif (restore_ok) {\n\t\t\t\t\t\t\tprintf(\"DONE\\n\");\n\t\t\t\t\t\t\tcur_file++;\n\t\t\t\t\t\t\tplist_dict_next_item(applications, iter, &hash, &node);\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfree(iter);\n\n\t\t\t\t\tif (restore_ok)\n\t\t\t\t\t\tprintf(\"All applications restored.\\n\");\n\t\t\t\t\telse\n\t\t\t\t\t\tprintf(\"Failed to restore applications.\\n\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tplist_free(backup_data);\n\n\t\t\t/* signal restore finished message to device; BackupMessageRestoreComplete */\n\t\t\tif (restore_ok) {\n\t\t\t\terr = mobilebackup_send_restore_complete(mobilebackup);\n\t\t\t\tif (err != MOBILEBACKUP_E_SUCCESS) {\n\t\t\t\t\tprintf(\"ERROR: Could not send BackupMessageRestoreComplete, error code %d\\n\", err);\n\t\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (restore_ok) {\n\t\t\t\tprintf(\"Restore Successful.\\n\");\n\t\t\t} else {\n\t\t\t\tprintf(\"Restore Failed.\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase CMD_LEAVE:\n\t\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (lockfile) {\n\t\t\tafc_file_lock(afc, lockfile, AFC_LOCK_UN);\n\t\t\tafc_file_close(afc, lockfile);\n\t\t\tlockfile = 0;\n\t\t\tdo_post_notification(NP_SYNC_DID_FINISH);\n\t\t}\n\t\tif (manifest_path)\n\t\t\tfree(manifest_path);\n\t} else {\n\t\tprintf(\"ERROR: Could not start service %s.\\n\", MOBILEBACKUP_SERVICE_NAME);\n\t\tlockdownd_client_free(client);\n\t\tclient = NULL;\n\t}\n\n\tif (client) {\n\t\tlockdownd_client_free(client);\n\t\tclient = NULL;\n\t}\n\n\tif (afc)\n\t\tafc_client_free(afc);\n\n\tif (np)\n\t\tnp_client_free(np);\n\n\tif (mobilebackup)\n\t\tmobilebackup_client_free(mobilebackup);\n\n\tidevice_free(device);\n\n\tif (udid) {\n\t\tfree(udid);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <windows.h>",
      "#include \"common/utils.h\"",
      "#include <libimobiledevice/afc.h>",
      "#include <libimobiledevice/notification_proxy.h>",
      "#include <libimobiledevice/mobilebackup.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <unistd.h>",
      "#include <gcrypt.h>",
      "#include <openssl/sha.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define LOCK_WAIT 200000",
      "#define LOCK_ATTEMPTS 50",
      "#define NP_SERVICE_NAME \"com.apple.mobile.notification_proxy\"",
      "#define MOBILEBACKUP_SERVICE_NAME \"com.apple.mobilebackup\""
    ],
    "globals_used": [
      "static mobilebackup_client_t mobilebackup = NULL;",
      "static lockdownd_client_t client = NULL;",
      "static idevice_t device = NULL;",
      "static int quit_flag = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "udid"
          ],
          "line": 1617
        },
        "resolved": true,
        "details": {
          "function_name": "thread_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "39-44",
          "snippet": "void thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nvoid thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "idevice_free",
          "args": [
            "device"
          ],
          "line": 1614
        },
        "resolved": true,
        "details": {
          "function_name": "idevice_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
          "lines": "247-265",
          "snippet": "LIBIMOBILEDEVICE_API idevice_error_t idevice_free(idevice_t device)\n{\n\tif (!device)\n\t\treturn IDEVICE_E_INVALID_ARG;\n\tidevice_error_t ret = IDEVICE_E_UNKNOWN_ERROR;\n\n\tret = IDEVICE_E_SUCCESS;\n\n\tfree(device->udid);\n\n\tif (device->conn_type == CONNECTION_USBMUXD) {\n\t\tdevice->conn_data = 0;\n\t}\n\tif (device->conn_data) {\n\t\tfree(device->conn_data);\n\t}\n\tfree(device);\n\treturn ret;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"common/thread.h\"",
            "#include \"common/userpref.h\"",
            "#include \"idevice.h\"",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <usbmuxd.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "LIBIMOBILEDEVICE_API idevice_error_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nLIBIMOBILEDEVICE_API idevice_error_t idevice_free(idevice_t device)\n{\n\tif (!device)\n\t\treturn IDEVICE_E_INVALID_ARG;\n\tidevice_error_t ret = IDEVICE_E_UNKNOWN_ERROR;\n\n\tret = IDEVICE_E_SUCCESS;\n\n\tfree(device->udid);\n\n\tif (device->conn_type == CONNECTION_USBMUXD) {\n\t\tdevice->conn_data = 0;\n\t}\n\tif (device->conn_data) {\n\t\tfree(device->conn_data);\n\t}\n\tfree(device);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mobilebackup_client_free",
          "args": [
            "mobilebackup"
          ],
          "line": 1612
        },
        "resolved": true,
        "details": {
          "function_name": "mobilebackup_client_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/mobilebackup.c",
          "lines": "97-108",
          "snippet": "LIBIMOBILEDEVICE_API mobilebackup_error_t mobilebackup_client_free(mobilebackup_client_t client)\n{\n\tif (!client)\n\t\treturn MOBILEBACKUP_E_INVALID_ARG;\n\tmobilebackup_error_t err = MOBILEBACKUP_E_SUCCESS;\n\tif (client->parent) {\n\t\tdevice_link_service_disconnect(client->parent, NULL);\n\t\terr = mobilebackup_error(device_link_service_client_free(client->parent));\n\t}\n\tfree(client);\n\treturn err;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"device_link_service.h\"",
            "#include \"mobilebackup.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <plist/plist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"device_link_service.h\"\n#include \"mobilebackup.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <plist/plist.h>\n\nLIBIMOBILEDEVICE_API mobilebackup_error_t mobilebackup_client_free(mobilebackup_client_t client)\n{\n\tif (!client)\n\t\treturn MOBILEBACKUP_E_INVALID_ARG;\n\tmobilebackup_error_t err = MOBILEBACKUP_E_SUCCESS;\n\tif (client->parent) {\n\t\tdevice_link_service_disconnect(client->parent, NULL);\n\t\terr = mobilebackup_error(device_link_service_client_free(client->parent));\n\t}\n\tfree(client);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "np_client_free",
          "args": [
            "np"
          ],
          "line": 1609
        },
        "resolved": true,
        "details": {
          "function_name": "np_client_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/notification_proxy.c",
          "lines": "114-166",
          "snippet": "LIBIMOBILEDEVICE_API np_error_t np_client_free(np_client_t client)\n{\n\tplist_t dict;\n\tproperty_list_service_client_t parent;\n\n\tif (!client)\n\t\treturn NP_E_INVALID_ARG;\n\n\tdict = plist_new_dict();\n\tplist_dict_set_item(dict,\"Command\", plist_new_string(\"Shutdown\"));\n\tproperty_list_service_send_xml_plist(client->parent, dict);\n\tplist_free(dict);\n\n\tparent = client->parent;\n\t/* notifies the client->notifier thread that it should terminate */\n\tclient->parent = NULL;\n\n\tif (client->notifier) {\n\t\tdebug_info(\"joining np callback\");\n\t\tthread_join(client->notifier);\n\t\tthread_free(client->notifier);\n\t\tclient->notifier = (thread_t)NULL;\n\t} else {\n\t\tdict = NULL;\n\t\tproperty_list_service_receive_plist(parent, &dict);\n\t\tif (dict) {\n#ifndef STRIP_DEBUG_CODE\n\t\t\tchar *cmd_value = NULL;\n\t\t\tplist_t cmd_value_node = plist_dict_get_item(dict, \"Command\");\n\t\t\tif (plist_get_node_type(cmd_value_node) == PLIST_STRING) {\n\t\t\t\tplist_get_string_val(cmd_value_node, &cmd_value);\n\t\t\t}\n\t\t\tif (cmd_value && !strcmp(cmd_value, \"ProxyDeath\")) {\n\t\t\t\t// this is the expected answer\n\t\t\t} else {\n\t\t\t\tdebug_info(\"Did not get ProxyDeath but:\");\n\t\t\t\tdebug_plist(dict);\n\t\t\t}\n\t\t\tif (cmd_value) {\n\t\t\t\tfree(cmd_value);\n\t\t\t}\n#endif\n\t\t\tplist_free(dict);\n\t\t}\n\t}\n\n\tproperty_list_service_client_free(parent);\n\n\tmutex_destroy(&client->mutex);\n\tfree(client);\n\n\treturn NP_E_SUCCESS;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"property_list_service.h\"",
            "#include \"notification_proxy.h\"",
            "#include <plist/plist.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"property_list_service.h\"\n#include \"notification_proxy.h\"\n#include <plist/plist.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n\nLIBIMOBILEDEVICE_API np_error_t np_client_free(np_client_t client)\n{\n\tplist_t dict;\n\tproperty_list_service_client_t parent;\n\n\tif (!client)\n\t\treturn NP_E_INVALID_ARG;\n\n\tdict = plist_new_dict();\n\tplist_dict_set_item(dict,\"Command\", plist_new_string(\"Shutdown\"));\n\tproperty_list_service_send_xml_plist(client->parent, dict);\n\tplist_free(dict);\n\n\tparent = client->parent;\n\t/* notifies the client->notifier thread that it should terminate */\n\tclient->parent = NULL;\n\n\tif (client->notifier) {\n\t\tdebug_info(\"joining np callback\");\n\t\tthread_join(client->notifier);\n\t\tthread_free(client->notifier);\n\t\tclient->notifier = (thread_t)NULL;\n\t} else {\n\t\tdict = NULL;\n\t\tproperty_list_service_receive_plist(parent, &dict);\n\t\tif (dict) {\n#ifndef STRIP_DEBUG_CODE\n\t\t\tchar *cmd_value = NULL;\n\t\t\tplist_t cmd_value_node = plist_dict_get_item(dict, \"Command\");\n\t\t\tif (plist_get_node_type(cmd_value_node) == PLIST_STRING) {\n\t\t\t\tplist_get_string_val(cmd_value_node, &cmd_value);\n\t\t\t}\n\t\t\tif (cmd_value && !strcmp(cmd_value, \"ProxyDeath\")) {\n\t\t\t\t// this is the expected answer\n\t\t\t} else {\n\t\t\t\tdebug_info(\"Did not get ProxyDeath but:\");\n\t\t\t\tdebug_plist(dict);\n\t\t\t}\n\t\t\tif (cmd_value) {\n\t\t\t\tfree(cmd_value);\n\t\t\t}\n#endif\n\t\t\tplist_free(dict);\n\t\t}\n\t}\n\n\tproperty_list_service_client_free(parent);\n\n\tmutex_destroy(&client->mutex);\n\tfree(client);\n\n\treturn NP_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afc_client_free",
          "args": [
            "afc"
          ],
          "line": 1606
        },
        "resolved": true,
        "details": {
          "function_name": "afc_client_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "125-138",
          "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_client_free(afc_client_t client)\n{\n\tif (!client || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tif (client->free_parent && client->parent) {\n\t\tservice_client_free(client->parent);\n\t\tclient->parent = NULL;\n\t}\n\tfree(client->afc_packet);\n\tmutex_destroy(&client->mutex);\n\tfree(client);\n\treturn AFC_E_SUCCESS;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_client_free(afc_client_t client)\n{\n\tif (!client || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tif (client->free_parent && client->parent) {\n\t\tservice_client_free(client->parent);\n\t\tclient->parent = NULL;\n\t}\n\tfree(client->afc_packet);\n\tmutex_destroy(&client->mutex);\n\tfree(client);\n\treturn AFC_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdownd_client_free",
          "args": [
            "client"
          ],
          "line": 1601
        },
        "resolved": true,
        "details": {
          "function_name": "lockdownd_client_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/lockdown.c",
          "lines": "322-336",
          "snippet": "LIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_client_free(lockdownd_client_t client)\n{\n\tif (!client)\n\t\treturn LOCKDOWN_E_INVALID_ARG;\n\n\tlockdownd_error_t ret = LOCKDOWN_E_UNKNOWN_ERROR;\n\n\tif (client->session_id) {\n\t\tlockdownd_stop_session(client, client->session_id);\n\t}\n\n\tret = lockdownd_client_free_simple(client);\n\n\treturn ret;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/userpref.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"lockdown.h\"",
            "#include \"property_list_service.h\"",
            "#include <plist/plist.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/x509.h>",
            "#include <libtasn1.h>",
            "#include <openssl/x509v3.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/pem.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/userpref.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"lockdown.h\"\n#include \"property_list_service.h\"\n#include <plist/plist.h>\n#include <gnutls/crypto.h>\n#include <gnutls/x509.h>\n#include <libtasn1.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/pem.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_client_free(lockdownd_client_t client)\n{\n\tif (!client)\n\t\treturn LOCKDOWN_E_INVALID_ARG;\n\n\tlockdownd_error_t ret = LOCKDOWN_E_UNKNOWN_ERROR;\n\n\tif (client->session_id) {\n\t\tlockdownd_stop_session(client, client->session_id);\n\t}\n\n\tret = lockdownd_client_free_simple(client);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ERROR: Could not start service %s.\\n\"",
            "MOBILEBACKUP_SERVICE_NAME"
          ],
          "line": 1595
        },
        "resolved": true,
        "details": {
          "function_name": "asprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/include/asprintf.h",
          "lines": "23-31",
          "snippet": "static inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}",
          "includes": [
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <config.h>\n\nstatic inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_post_notification",
          "args": [
            "NP_SYNC_DID_FINISH"
          ],
          "line": 1590
        },
        "resolved": true,
        "details": {
          "function_name": "do_post_notification",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
          "lines": "603-629",
          "snippet": "static void do_post_notification(const char *notification)\n{\n\tlockdownd_service_descriptor_t service = NULL;\n\tnp_client_t np;\n\n\tif (!client) {\n\t\tif (lockdownd_client_new_with_handshake(device, &client, \"idevicebackup\") != LOCKDOWN_E_SUCCESS) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlockdownd_start_service(client, NP_SERVICE_NAME, &service);\n\tif (service && service->port) {\n\t\tnp_client_new(device, service, &np);\n\t\tif (np) {\n\t\t\tnp_post_notification(np, notification);\n\t\t\tnp_client_free(np);\n\t\t}\n\t} else {\n\t\tprintf(\"Could not start %s\\n\", NP_SERVICE_NAME);\n\t}\n\n\tif (service) {\n\t\tlockdownd_service_descriptor_free(service);\n\t\tservice = NULL;\n\t}\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <unistd.h>",
            "#include <gcrypt.h>",
            "#include <openssl/sha.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define NP_SERVICE_NAME \"com.apple.mobile.notification_proxy\""
          ],
          "globals_used": [
            "static lockdownd_client_t client = NULL;",
            "static idevice_t device = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\n#define NP_SERVICE_NAME \"com.apple.mobile.notification_proxy\"\n\nstatic lockdownd_client_t client = NULL;\nstatic idevice_t device = NULL;\n\nstatic void do_post_notification(const char *notification)\n{\n\tlockdownd_service_descriptor_t service = NULL;\n\tnp_client_t np;\n\n\tif (!client) {\n\t\tif (lockdownd_client_new_with_handshake(device, &client, \"idevicebackup\") != LOCKDOWN_E_SUCCESS) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlockdownd_start_service(client, NP_SERVICE_NAME, &service);\n\tif (service && service->port) {\n\t\tnp_client_new(device, service, &np);\n\t\tif (np) {\n\t\t\tnp_post_notification(np, notification);\n\t\t\tnp_client_free(np);\n\t\t}\n\t} else {\n\t\tprintf(\"Could not start %s\\n\", NP_SERVICE_NAME);\n\t}\n\n\tif (service) {\n\t\tlockdownd_service_descriptor_free(service);\n\t\tservice = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "afc_file_close",
          "args": [
            "afc",
            "lockfile"
          ],
          "line": 1588
        },
        "resolved": true,
        "details": {
          "function_name": "afc_file_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "749-775",
          "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_file_close(afc_client_t client, uint64_t handle)\n{\n\tuint32_t bytes = 0;\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tif (!client || (handle == 0))\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_lock(client);\n\n\tdebug_info(\"File handle %i\", handle);\n\n\t/* Send command */\n\tret = afc_dispatch_packet(client, AFC_OP_FILE_CLOSE, (const char*)&handle, 8, NULL, 0, &bytes);\n\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_UNKNOWN_ERROR;\n\t}\n\n\t/* Receive the response */\n\tret = afc_receive_data(client, NULL, &bytes);\n\n\tafc_unlock(client);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_file_close(afc_client_t client, uint64_t handle)\n{\n\tuint32_t bytes = 0;\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tif (!client || (handle == 0))\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_lock(client);\n\n\tdebug_info(\"File handle %i\", handle);\n\n\t/* Send command */\n\tret = afc_dispatch_packet(client, AFC_OP_FILE_CLOSE, (const char*)&handle, 8, NULL, 0, &bytes);\n\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_UNKNOWN_ERROR;\n\t}\n\n\t/* Receive the response */\n\tret = afc_receive_data(client, NULL, &bytes);\n\n\tafc_unlock(client);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afc_file_lock",
          "args": [
            "afc",
            "lockfile",
            "AFC_LOCK_UN"
          ],
          "line": 1587
        },
        "resolved": true,
        "details": {
          "function_name": "afc_file_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "777-809",
          "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_file_lock(afc_client_t client, uint64_t handle, afc_lock_op_t operation)\n{\n\tuint32_t bytes = 0;\n\tstruct {\n\t\tuint64_t handle;\n\t\tuint64_t op;\n\t} lockinfo;\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tif (!client || (handle == 0))\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_lock(client);\n\n\tdebug_info(\"file handle %i\", handle);\n\n\t/* Send command */\n\tlockinfo.handle = handle;\n\tlockinfo.op = htole64(operation);\n\tret = afc_dispatch_packet(client, AFC_OP_FILE_LOCK, (const char*)&lockinfo, sizeof(lockinfo), NULL, 0, &bytes);\n\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\tdebug_info(\"could not send lock command\");\n\t\treturn AFC_E_UNKNOWN_ERROR;\n\t}\n\t/* Receive the response */\n\tret = afc_receive_data(client, NULL, &bytes);\n\n\tafc_unlock(client);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_file_lock(afc_client_t client, uint64_t handle, afc_lock_op_t operation)\n{\n\tuint32_t bytes = 0;\n\tstruct {\n\t\tuint64_t handle;\n\t\tuint64_t op;\n\t} lockinfo;\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tif (!client || (handle == 0))\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_lock(client);\n\n\tdebug_info(\"file handle %i\", handle);\n\n\t/* Send command */\n\tlockinfo.handle = handle;\n\tlockinfo.op = htole64(operation);\n\tret = afc_dispatch_packet(client, AFC_OP_FILE_LOCK, (const char*)&lockinfo, sizeof(lockinfo), NULL, 0, &bytes);\n\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\tdebug_info(\"could not send lock command\");\n\t\treturn AFC_E_UNKNOWN_ERROR;\n\t}\n\t/* Receive the response */\n\tret = afc_receive_data(client, NULL, &bytes);\n\n\tafc_unlock(client);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Restore Failed.\\n\""
          ],
          "line": 1579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Restore Successful.\\n\""
          ],
          "line": 1577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mobilebackup_send_restore_complete",
          "args": [
            "mobilebackup"
          ],
          "line": 1570
        },
        "resolved": true,
        "details": {
          "function_name": "mobilebackup_send_restore_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/mobilebackup.c",
          "lines": "364-407",
          "snippet": "LIBIMOBILEDEVICE_API mobilebackup_error_t mobilebackup_send_restore_complete(mobilebackup_client_t client)\n{\n\tmobilebackup_error_t err = mobilebackup_send_message(client, \"BackupMessageRestoreComplete\", NULL);\n\tif (err != MOBILEBACKUP_E_SUCCESS) {\n\t\treturn err;\n\t}\n\tplist_t dlmsg = NULL;\n\terr = mobilebackup_receive(client, &dlmsg);\n\tif ((err != MOBILEBACKUP_E_SUCCESS) || !dlmsg || (plist_get_node_type(dlmsg) != PLIST_ARRAY) || (plist_array_get_size(dlmsg) != 2)) {\n\t\tif (dlmsg) {\n\t\t\tdebug_info(\"ERROR: Did not receive DLMessageDisconnect:\");\n\t\t\tdebug_plist(dlmsg);\n\t\t\tplist_free(dlmsg);\n\t\t}\n\t\tif (err == MOBILEBACKUP_E_SUCCESS) {\n\t\t\terr = MOBILEBACKUP_E_PLIST_ERROR;\n\t\t}\n\t\treturn err;\n\t}\n\tplist_t node = plist_array_get_item (dlmsg, 0);\n\tchar *msg = NULL;\n\tif (node && (plist_get_node_type(node) == PLIST_STRING)) {\n\t\tplist_get_string_val(node, &msg);\n\t}\n\n\tif (msg && !strcmp(msg, \"DLMessageDisconnect\")) {\n\t\terr = MOBILEBACKUP_E_SUCCESS;\n\t\t/* we need to do this here, otherwise mobilebackup_client_free\n\t\t   will fail */\n\t\tdevice_link_service_client_free(client->parent);\n\t\tclient->parent = NULL;\n\t} else {\n\t\tdebug_info(\"ERROR: Malformed plist received:\");\n\t\tdebug_plist(dlmsg);\n\t\terr = MOBILEBACKUP_E_PLIST_ERROR;\n\t}\n\n\tplist_free(dlmsg);\n\n\tif (msg)\n\t\tfree(msg);\n\n\treturn err;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"device_link_service.h\"",
            "#include \"mobilebackup.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <plist/plist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"device_link_service.h\"\n#include \"mobilebackup.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <plist/plist.h>\n\nLIBIMOBILEDEVICE_API mobilebackup_error_t mobilebackup_send_restore_complete(mobilebackup_client_t client)\n{\n\tmobilebackup_error_t err = mobilebackup_send_message(client, \"BackupMessageRestoreComplete\", NULL);\n\tif (err != MOBILEBACKUP_E_SUCCESS) {\n\t\treturn err;\n\t}\n\tplist_t dlmsg = NULL;\n\terr = mobilebackup_receive(client, &dlmsg);\n\tif ((err != MOBILEBACKUP_E_SUCCESS) || !dlmsg || (plist_get_node_type(dlmsg) != PLIST_ARRAY) || (plist_array_get_size(dlmsg) != 2)) {\n\t\tif (dlmsg) {\n\t\t\tdebug_info(\"ERROR: Did not receive DLMessageDisconnect:\");\n\t\t\tdebug_plist(dlmsg);\n\t\t\tplist_free(dlmsg);\n\t\t}\n\t\tif (err == MOBILEBACKUP_E_SUCCESS) {\n\t\t\terr = MOBILEBACKUP_E_PLIST_ERROR;\n\t\t}\n\t\treturn err;\n\t}\n\tplist_t node = plist_array_get_item (dlmsg, 0);\n\tchar *msg = NULL;\n\tif (node && (plist_get_node_type(node) == PLIST_STRING)) {\n\t\tplist_get_string_val(node, &msg);\n\t}\n\n\tif (msg && !strcmp(msg, \"DLMessageDisconnect\")) {\n\t\terr = MOBILEBACKUP_E_SUCCESS;\n\t\t/* we need to do this here, otherwise mobilebackup_client_free\n\t\t   will fail */\n\t\tdevice_link_service_client_free(client->parent);\n\t\tclient->parent = NULL;\n\t} else {\n\t\tdebug_info(\"ERROR: Malformed plist received:\");\n\t\tdebug_plist(dlmsg);\n\t\terr = MOBILEBACKUP_E_PLIST_ERROR;\n\t}\n\n\tplist_free(dlmsg);\n\n\tif (msg)\n\t\tfree(msg);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_free",
          "args": [
            "backup_data"
          ],
          "line": 1566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Failed to restore applications.\\n\""
          ],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"All applications restored.\\n\""
          ],
          "line": 1560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_next_item",
          "args": [
            "applications",
            "iter",
            "&hash",
            "&node"
          ],
          "line": 1553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"DONE\\n\""
          ],
          "line": 1551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mobilebackup_receive_restore_application_received",
          "args": [
            "mobilebackup",
            "NULL"
          ],
          "line": 1538
        },
        "resolved": true,
        "details": {
          "function_name": "mobilebackup_receive_restore_application_received",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/mobilebackup.c",
          "lines": "359-362",
          "snippet": "LIBIMOBILEDEVICE_API mobilebackup_error_t mobilebackup_receive_restore_application_received(mobilebackup_client_t client, plist_t *result)\n{\n\treturn mobilebackup_receive_message(client, \"BackupMessageRestoreApplicationReceived\", result);\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"device_link_service.h\"",
            "#include \"mobilebackup.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <plist/plist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"device_link_service.h\"\n#include \"mobilebackup.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <plist/plist.h>\n\nLIBIMOBILEDEVICE_API mobilebackup_error_t mobilebackup_receive_restore_application_received(mobilebackup_client_t client, plist_t *result)\n{\n\treturn mobilebackup_receive_message(client, \"BackupMessageRestoreApplicationReceived\", result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_free",
          "args": [
            "array"
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mobilebackup_send",
          "args": [
            "mobilebackup",
            "array"
          ],
          "line": 1526
        },
        "resolved": true,
        "details": {
          "function_name": "mobilebackup_send_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/mobilebackup.c",
          "lines": "409-424",
          "snippet": "LIBIMOBILEDEVICE_API mobilebackup_error_t mobilebackup_send_error(mobilebackup_client_t client, const char *reason)\n{\n\tif (!client || !client->parent || !reason)\n\t\treturn MOBILEBACKUP_E_INVALID_ARG;\n\n\tmobilebackup_error_t err;\n\n\t/* construct error plist */\n\tplist_t dict = plist_new_dict();\n\tplist_dict_set_item(dict, \"BackupErrorReasonKey\", plist_new_string(reason));\n\n\terr = mobilebackup_send_message(client, \"BackupMessageError\", dict);\n\tplist_free(dict);\n\n\treturn err;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"device_link_service.h\"",
            "#include \"mobilebackup.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <plist/plist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"device_link_service.h\"\n#include \"mobilebackup.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <plist/plist.h>\n\nLIBIMOBILEDEVICE_API mobilebackup_error_t mobilebackup_send_error(mobilebackup_client_t client, const char *reason)\n{\n\tif (!client || !client->parent || !reason)\n\t\treturn MOBILEBACKUP_E_INVALID_ARG;\n\n\tmobilebackup_error_t err;\n\n\t/* construct error plist */\n\tplist_t dict = plist_new_dict();\n\tplist_dict_set_item(dict, \"BackupErrorReasonKey\", plist_new_string(reason));\n\n\terr = mobilebackup_send_message(client, \"BackupMessageError\", dict);\n\tplist_free(dict);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_array_append_item",
          "args": [
            "array",
            "dict"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_array_append_item",
          "args": [
            "array",
            "plist_new_string(\"DLMessageProcessMessage\")"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_string",
          "args": [
            "\"DLMessageProcessMessage\""
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_array",
          "args": [],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "dict",
            "\"BackupMessageTypeKey\"",
            "plist_new_string(\"BackupMessageRestoreApplicationSent\")"
          ],
          "line": 1520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_string",
          "args": [
            "\"BackupMessageRestoreApplicationSent\""
          ],
          "line": 1520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "dict",
            "\"AppInfo\"",
            "plist_copy(tmp_node)"
          ],
          "line": 1519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_copy",
          "args": [
            "tmp_node"
          ],
          "line": 1519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_dict",
          "args": [],
          "line": 1518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "node",
            "\"AppInfo\""
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_next_item",
          "args": [
            "applications",
            "iter",
            "&hash",
            "&node"
          ],
          "line": 1511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_size",
          "args": [
            "applications"
          ],
          "line": 1505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_new_iter",
          "args": [
            "applications",
            "&iter"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_node_type",
          "args": [
            "applications"
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "backup_data",
            "\"Applications\""
          ],
          "line": 1498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_next_item",
          "args": [
            "files",
            "iter",
            "&hash",
            "&node"
          ],
          "line": 1489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_free",
          "args": [
            "send_file_node"
          ],
          "line": 1471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"DONE\\n\""
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mobilebackup_receive_restore_file_received",
          "args": [
            "mobilebackup",
            "NULL"
          ],
          "line": 1459
        },
        "resolved": true,
        "details": {
          "function_name": "mobilebackup_receive_restore_file_received",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/mobilebackup.c",
          "lines": "354-357",
          "snippet": "LIBIMOBILEDEVICE_API mobilebackup_error_t mobilebackup_receive_restore_file_received(mobilebackup_client_t client, plist_t *result)\n{\n\treturn mobilebackup_receive_message(client, \"BackupMessageRestoreFileReceived\", result);\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"device_link_service.h\"",
            "#include \"mobilebackup.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <plist/plist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"device_link_service.h\"\n#include \"mobilebackup.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <plist/plist.h>\n\nLIBIMOBILEDEVICE_API mobilebackup_error_t mobilebackup_receive_restore_file_received(mobilebackup_client_t client, plist_t *result)\n{\n\treturn mobilebackup_receive_message(client, \"BackupMessageRestoreFileReceived\", result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_array_append_item",
          "args": [
            "send_file_node",
            "plist_copy(file_info)"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_copy",
          "args": [
            "file_info"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_array_append_item",
          "args": [
            "send_file_node",
            "plist_new_data(buf, len)"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_data",
          "args": [
            "buf",
            "len"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_array_append_item",
          "args": [
            "send_file_node",
            "plist_new_string(\"DLSendFile\")"
          ],
          "line": 1446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_string",
          "args": [
            "\"DLSendFile\""
          ],
          "line": 1446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_array",
          "args": [],
          "line": 1444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "file_info",
            "\"DLFileStatusKey\"",
            "plist_new_uint(file_status)"
          ],
          "line": 1442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_uint",
          "args": [
            "file_status"
          ],
          "line": 1442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_remove_item",
          "args": [
            "file_info",
            "\"DLFileStatusKey\""
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "file_info",
            "\"DLFileOffsetKey\"",
            "plist_new_uint(file_offset)"
          ],
          "line": 1439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_uint",
          "args": [
            "file_offset"
          ],
          "line": 1439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_remove_item",
          "args": [
            "file_info",
            "\"DLFileOffsetKey\""
          ],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fread",
          "args": [
            "buf",
            "1",
            "sizeof(buf)",
            "f"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "file_info_path",
            "\"rb\""
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "file_info_path",
            "&fst"
          ],
          "line": 1410
        },
        "resolved": true,
        "details": {
          "function_name": "mobilebackup_write_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
          "lines": "322-338",
          "snippet": "static void mobilebackup_write_status(const char *path, int status)\n{\n\tstruct stat st;\n\tplist_t status_plist = plist_new_dict();\n\tplist_dict_set_item(status_plist, \"Backup Success\", plist_new_bool(status));\n\tchar *file_path = mobilebackup_build_path(path, \"Status\", \".plist\");\n\n\tif (stat(file_path, &st) == 0)\n\t\tremove(file_path);\n\n\tplist_write_to_filename(status_plist, file_path, PLIST_FORMAT_XML);\n\n\tplist_free(status_plist);\n\tstatus_plist = NULL;\n\n\tfree(file_path);\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <unistd.h>",
            "#include <gcrypt.h>",
            "#include <openssl/sha.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void mobilebackup_write_status(const char *path, int status)\n{\n\tstruct stat st;\n\tplist_t status_plist = plist_new_dict();\n\tplist_dict_set_item(status_plist, \"Backup Success\", plist_new_bool(status));\n\tchar *file_path = mobilebackup_build_path(path, \"Status\", \".plist\");\n\n\tif (stat(file_path, &st) == 0)\n\t\tremove(file_path);\n\n\tplist_write_to_filename(status_plist, file_path, PLIST_FORMAT_XML);\n\n\tplist_free(status_plist);\n\tstatus_plist = NULL;\n\n\tfree(file_path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_stati64",
          "args": [
            "file_info_path",
            "&fst"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mobilebackup_build_path",
          "args": [
            "backup_directory",
            "hash",
            "\".mddata\""
          ],
          "line": 1402
        },
        "resolved": true,
        "details": {
          "function_name": "mobilebackup_build_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
          "lines": "311-320",
          "snippet": "static char *mobilebackup_build_path(const char *backup_directory, const char *name, const char *extension)\n{\n\tchar* filename = (char*)malloc(strlen(name)+(extension == NULL ? 0: strlen(extension))+1);\n\tstrcpy(filename, name);\n\tif (extension != NULL)\n\t\tstrcat(filename, extension);\n\tchar *path = string_build_path(backup_directory, filename, NULL);\n\tfree(filename);\n\treturn path;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <unistd.h>",
            "#include <gcrypt.h>",
            "#include <openssl/sha.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic char *mobilebackup_build_path(const char *backup_directory, const char *name, const char *extension)\n{\n\tchar* filename = (char*)malloc(strlen(name)+(extension == NULL ? 0: strlen(extension))+1);\n\tstrcpy(filename, name);\n\tif (extension != NULL)\n\t\tstrcat(filename, extension);\n\tchar *path = string_build_path(backup_directory, filename, NULL);\n\tfree(filename);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "file_info",
            "\"DLFileStatusKey\"",
            "plist_new_uint(file_status)"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_uint",
          "args": [
            "file_status"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "file_info",
            "\"DLFileOffsetKey\"",
            "plist_new_uint(file_offset)"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_uint",
          "args": [
            "file_offset"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "file_info",
            "\"DLFileIsEncrypted\"",
            "plist_new_bool(is_encrypted)"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_bool",
          "args": [
            "is_encrypted"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "file_info",
            "\"DLFileDest\"",
            "plist_new_string(\"/tmp/RestoreFile.plist\")"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_string",
          "args": [
            "\"/tmp/RestoreFile.plist\""
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "file_info",
            "\"DLFileSource\"",
            "plist_new_string(file_info_path)"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_string",
          "args": [
            "file_info_path"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "file_info",
            "\"DLFileAttributesKey\"",
            "plist_copy(node)"
          ],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_copy",
          "args": [
            "node"
          ],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_string_val",
          "args": [
            "file_path_node",
            "&file_path"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "tmp_node",
            "\"Path\""
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_from_bin",
          "args": [
            "buffer",
            "length",
            "&tmp_node"
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_data_val",
          "args": [
            "tmp_node",
            "&buffer",
            "&length"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "file_info",
            "\"Metadata\""
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_bool_val",
          "args": [
            "tmp_node",
            "&is_encrypted"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "file_info",
            "\"IsEncrypted\""
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_read_from_filename",
          "args": [
            "&file_info",
            "file_info_path"
          ],
          "line": 1375
        },
        "resolved": true,
        "details": {
          "function_name": "plist_read_from_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/utils.c",
          "lines": "245-268",
          "snippet": "int plist_read_from_filename(plist_t *plist, const char *filename)\n{\n\tchar *buffer = NULL;\n\tuint64_t length;\n\n\tif (!filename)\n\t\treturn 0;\n\n\tbuffer_read_from_filename(filename, &buffer, &length);\n\n\tif (!buffer) {\n\t\treturn 0;\n\t}\n\n\tif ((length > 8) && (memcmp(buffer, \"bplist00\", 8) == 0)) {\n\t\tplist_from_bin(buffer, length, plist);\n\t} else {\n\t\tplist_from_xml(buffer, length, plist);\n\t}\n\n\tfree(buffer);\n\n\treturn 1;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include <ctype.h>",
            "#include <inttypes.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include <ctype.h>\n#include <inttypes.h>\n#include <sys/time.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <config.h>\n\nint plist_read_from_filename(plist_t *plist, const char *filename)\n{\n\tchar *buffer = NULL;\n\tuint64_t length;\n\n\tif (!filename)\n\t\treturn 0;\n\n\tbuffer_read_from_filename(filename, &buffer, &length);\n\n\tif (!buffer) {\n\t\treturn 0;\n\t}\n\n\tif ((length > 8) && (memcmp(buffer, \"bplist00\", 8) == 0)) {\n\t\tplist_from_bin(buffer, length, plist);\n\t} else {\n\t\tplist_from_xml(buffer, length, plist);\n\t}\n\n\tfree(buffer);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_dict_next_item",
          "args": [
            "files",
            "iter",
            "&hash",
            "&node"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_size",
          "args": [
            "files"
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_new_iter",
          "args": [
            "files",
            "&iter"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_node_type",
          "args": [
            "files"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Entered restore mode.\\n\""
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_free",
          "args": [
            "backup_data"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ERROR: Could not start restore process: device refused to start the restore process.\\n\""
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ERROR: Could not start restore process: backup protocol version mismatch!\\n\""
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mobilebackup_request_restore",
          "args": [
            "mobilebackup",
            "manifest_plist",
            "restore_flags",
            "\"1.6\""
          ],
          "line": 1338
        },
        "resolved": true,
        "details": {
          "function_name": "mobilebackup_request_restore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/mobilebackup.c",
          "lines": "300-352",
          "snippet": "LIBIMOBILEDEVICE_API mobilebackup_error_t mobilebackup_request_restore(mobilebackup_client_t client, plist_t backup_manifest, mobilebackup_flags_t flags, const char *proto_version)\n{\n\tif (!client || !client->parent || !backup_manifest || !proto_version)\n\t\treturn MOBILEBACKUP_E_INVALID_ARG;\n\n\tif (backup_manifest && (plist_get_node_type(backup_manifest) != PLIST_DICT))\n\t\treturn MOBILEBACKUP_E_PLIST_ERROR;\n\n\tmobilebackup_error_t err;\n\n\t/* construct request plist */\n\tplist_t dict = plist_new_dict();\n\tplist_dict_set_item(dict, \"BackupManifestKey\", plist_copy(backup_manifest));\n\tplist_dict_set_item(dict, \"BackupMessageTypeKey\", plist_new_string(\"kBackupMessageRestoreRequest\"));\n\tplist_dict_set_item(dict, \"BackupProtocolVersion\", plist_new_string(proto_version));\n\t/* add flags */\n\tplist_dict_set_item(dict, \"BackupNotifySpringBoard\", plist_new_bool(IS_FLAG_SET(flags, MB_RESTORE_NOTIFY_SPRINGBOARD)));\n\tplist_dict_set_item(dict, \"BackupPreserveSettings\", plist_new_bool(IS_FLAG_SET(flags, MB_RESTORE_PRESERVE_SETTINGS)));\n\tplist_dict_set_item(dict, \"BackupPreserveCameraRoll\", plist_new_bool(IS_FLAG_SET(flags, MB_RESTORE_PRESERVE_CAMERA_ROLL)));\n\n\t/* send request */\n\terr = mobilebackup_send_message(client, NULL, dict);\n\tplist_free(dict);\n\tdict = NULL;\n\tif (err != MOBILEBACKUP_E_SUCCESS) {\n\t\tdebug_info(\"ERROR: Could not send restore request message (%d)!\", err);\n\t\tgoto leave;\n\t}\n\n\t/* now receive and hopefully get a BackupMessageRestoreReplyOK */\n\terr = mobilebackup_receive_message(client, \"BackupMessageRestoreReplyOK\", &dict);\n\tif (err != MOBILEBACKUP_E_SUCCESS) {\n\t\tdebug_info(\"ERROR: Could not receive RestoreReplyOK message (%d)!\", err);\n\t\tgoto leave;\n\t}\n\n\tplist_t node = plist_dict_get_item(dict, \"BackupProtocolVersion\");\n\tif (node) {\n\t\tchar *str = NULL;\n\t\tplist_get_string_val(node, &str);\n\t\tif (str) {\n\t\t\tif (strcmp(str, proto_version) != 0) {\n\t\t\t\terr = MOBILEBACKUP_E_BAD_VERSION;\n\t\t\t}\n\t\t\tfree(str);\n\t\t}\n\t}\n\nleave:\n\tif (dict)\n\t\tplist_free(dict);\n\treturn err;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"device_link_service.h\"",
            "#include \"mobilebackup.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <plist/plist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"device_link_service.h\"\n#include \"mobilebackup.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <plist/plist.h>\n\nLIBIMOBILEDEVICE_API mobilebackup_error_t mobilebackup_request_restore(mobilebackup_client_t client, plist_t backup_manifest, mobilebackup_flags_t flags, const char *proto_version)\n{\n\tif (!client || !client->parent || !backup_manifest || !proto_version)\n\t\treturn MOBILEBACKUP_E_INVALID_ARG;\n\n\tif (backup_manifest && (plist_get_node_type(backup_manifest) != PLIST_DICT))\n\t\treturn MOBILEBACKUP_E_PLIST_ERROR;\n\n\tmobilebackup_error_t err;\n\n\t/* construct request plist */\n\tplist_t dict = plist_new_dict();\n\tplist_dict_set_item(dict, \"BackupManifestKey\", plist_copy(backup_manifest));\n\tplist_dict_set_item(dict, \"BackupMessageTypeKey\", plist_new_string(\"kBackupMessageRestoreRequest\"));\n\tplist_dict_set_item(dict, \"BackupProtocolVersion\", plist_new_string(proto_version));\n\t/* add flags */\n\tplist_dict_set_item(dict, \"BackupNotifySpringBoard\", plist_new_bool(IS_FLAG_SET(flags, MB_RESTORE_NOTIFY_SPRINGBOARD)));\n\tplist_dict_set_item(dict, \"BackupPreserveSettings\", plist_new_bool(IS_FLAG_SET(flags, MB_RESTORE_PRESERVE_SETTINGS)));\n\tplist_dict_set_item(dict, \"BackupPreserveCameraRoll\", plist_new_bool(IS_FLAG_SET(flags, MB_RESTORE_PRESERVE_CAMERA_ROLL)));\n\n\t/* send request */\n\terr = mobilebackup_send_message(client, NULL, dict);\n\tplist_free(dict);\n\tdict = NULL;\n\tif (err != MOBILEBACKUP_E_SUCCESS) {\n\t\tdebug_info(\"ERROR: Could not send restore request message (%d)!\", err);\n\t\tgoto leave;\n\t}\n\n\t/* now receive and hopefully get a BackupMessageRestoreReplyOK */\n\terr = mobilebackup_receive_message(client, \"BackupMessageRestoreReplyOK\", &dict);\n\tif (err != MOBILEBACKUP_E_SUCCESS) {\n\t\tdebug_info(\"ERROR: Could not receive RestoreReplyOK message (%d)!\", err);\n\t\tgoto leave;\n\t}\n\n\tplist_t node = plist_dict_get_item(dict, \"BackupProtocolVersion\");\n\tif (node) {\n\t\tchar *str = NULL;\n\t\tplist_get_string_val(node, &str);\n\t\tif (str) {\n\t\t\tif (strcmp(str, proto_version) != 0) {\n\t\t\t\terr = MOBILEBACKUP_E_BAD_VERSION;\n\t\t\t}\n\t\t\tfree(str);\n\t\t}\n\t}\n\nleave:\n\tif (dict)\n\t\tplist_free(dict);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Requesting restore from device...\\n\""
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"All backup files appear to be valid\\n\""
          ],
          "line": 1330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_free",
          "args": [
            "backup_data"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_next_item",
          "args": [
            "files",
            "iter",
            "&hash",
            "&node"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mobilebackup_check_file_integrity",
          "args": [
            "backup_directory",
            "hash",
            "node"
          ],
          "line": 1315
        },
        "resolved": true,
        "details": {
          "function_name": "mobilebackup_check_file_integrity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
          "lines": "452-601",
          "snippet": "static int mobilebackup_check_file_integrity(const char *backup_directory, const char *hash, plist_t filedata)\n{\n\tchar *datapath;\n\tchar *infopath;\n\tplist_t mdinfo = NULL;\n\tstruct stat st;\n\tunsigned char file_hash[20];\n\n\tdatapath = mobilebackup_build_path(backup_directory, hash, \".mddata\");\n\tif (stat(datapath, &st) != 0) {\n\t\tprintf(\"\\r\\n\");\n\t\tprintf(\"ERROR: '%s.mddata' is missing!\\n\", hash);\n\t\tfree(datapath);\n\t\treturn 0;\n\t}\n\n\tinfopath = mobilebackup_build_path(backup_directory, hash, \".mdinfo\");\n\tplist_read_from_filename(&mdinfo, infopath);\n\tfree(infopath);\n\tif (!mdinfo) {\n\t\tprintf(\"\\r\\n\");\n\t\tprintf(\"ERROR: '%s.mdinfo' is missing or corrupted!\\n\", hash);\n\t\tfree(datapath);\n\t\treturn 0;\n\t}\n\n\t/* sha1 hash verification */\n\tplist_t node = plist_dict_get_item(filedata, \"DataHash\");\n\tif (!node || (plist_get_node_type(node) != PLIST_DATA)) {\n\t\tprintf(\"\\r\\n\");\n\t\tprintf(\"ERROR: Could not get DataHash for file entry '%s'\\n\", hash);\n\t\tplist_free(mdinfo);\n\t\tfree(datapath);\n\t\treturn 0;\n\t}\n\n\tnode = plist_dict_get_item(mdinfo, \"Metadata\");\n\tif (!node && (plist_get_node_type(node) != PLIST_DATA)) {\n\t\tprintf(\"\\r\\n\");\n\t\tprintf(\"ERROR: Could not find Metadata in plist '%s.mdinfo'\\n\", hash);\n\t\tplist_free(mdinfo);\n\t\tfree(datapath);\n\t\treturn 0;\n\t}\n\n\tchar *meta_bin = NULL;\n\tuint64_t meta_bin_size = 0;\n\tplist_get_data_val(node, &meta_bin, &meta_bin_size);\n\tplist_t metadata = NULL;\n\tif (meta_bin) {\n\t\tplist_from_bin(meta_bin, (uint32_t)meta_bin_size, &metadata);\n\t}\n\tif (!metadata) {\n\t\tprintf(\"\\r\\n\");\n\t\tprintf(\"ERROR: Could not get Metadata from plist '%s.mdinfo'\\n\", hash);\n\t\tplist_free(mdinfo);\n\t\tfree(datapath);\n\t\treturn 0;\n\t}\n\n\tchar *version = NULL;\n\tnode = plist_dict_get_item(metadata, \"Version\");\n\tif (node && (plist_get_node_type(node) == PLIST_STRING)) {\n\t\tplist_get_string_val(node, &version);\n\t}\n\n\tchar *destpath = NULL;\n\tnode = plist_dict_get_item(metadata, \"Path\");\n\tif (node && (plist_get_node_type(node) == PLIST_STRING)) {\n\t\tplist_get_string_val(node, &destpath);\n\t}\n\n\tuint8_t greylist = 0;\n\tnode = plist_dict_get_item(metadata, \"Greylist\");\n\tif (node && (plist_get_node_type(node) == PLIST_BOOLEAN)) {\n\t\tplist_get_bool_val(node, &greylist);\n\t}\n\n\tchar *domain = NULL;\n\tnode = plist_dict_get_item(metadata, \"Domain\");\n\tif (node && (plist_get_node_type(node) == PLIST_STRING)) {\n\t\tplist_get_string_val(node, &domain);\n\t}\n\n\tchar *fnstr = malloc(strlen(domain) + 1 + strlen(destpath) + 1);\n\tstrcpy(fnstr, domain);\n\tstrcat(fnstr, \"-\");\n\tstrcat(fnstr, destpath);\n\tunsigned char fnhash[20];\n\tchar fnamehash[41];\n\tchar *p = fnamehash;\n\tsha1_of_data(fnstr, strlen(fnstr), fnhash);\n\tfree(fnstr);\n\tint i;\n\tfor ( i = 0; i < 20; i++, p += 2 ) {\n\t\tsnprintf (p, 3, \"%02x\", (unsigned char)fnhash[i] );\n\t}\n\tif (strcmp(fnamehash, hash)) {\n\t\tprintf(\"\\r\\n\");\n\t\tprintf(\"WARNING: filename hash does not match for entry '%s'\\n\", hash);\n\t}\n\n\tchar *auth_version = NULL;\n\tnode = plist_dict_get_item(mdinfo, \"AuthVersion\");\n\tif (node && (plist_get_node_type(node) == PLIST_STRING)) {\n\t\tplist_get_string_val(node, &auth_version);\n\t}\n\n\tif (strcmp(auth_version, \"1.0\")) {\n\t\tprintf(\"\\r\\n\");\n\t\tprintf(\"WARNING: Unknown AuthVersion '%s', DataHash cannot be verified!\\n\", auth_version);\n\t}\n\n\tnode = plist_dict_get_item(filedata, \"DataHash\");\n\tif (!node || (plist_get_node_type(node) != PLIST_DATA)) {\n\t\tprintf(\"\\r\\n\");\n\t\tprintf(\"WARNING: Could not get DataHash key from file info data for entry '%s'\\n\", hash);\n\t}\n\n\tint res = 1;\n\tunsigned char *data_hash = NULL;\n\tuint64_t data_hash_len = 0;\n\tplist_get_data_val(node, (char**)&data_hash, &data_hash_len);\n\tint hash_ok = 0;\n\tif (data_hash && (data_hash_len == 20)) {\n\t\tcompute_datahash(datapath, destpath, greylist, domain, NULL, version, file_hash);\n\t\thash_ok = compare_hash(data_hash, file_hash, 20);\n\t} else if (data_hash_len == 0) {\n\t\t/* no datahash present */\n\t\thash_ok = 1;\n\t}\n\n\tfree(domain);\n\tfree(version);\n\tfree(destpath);\n\n\tif (!hash_ok) {\n\t\tprintf(\"\\r\\n\");\n\t\tprintf(\"ERROR: The hash for '%s.mddata' does not match DataHash entry in Manifest\\n\", hash);\n\t\tprintf(\"datahash: \");\n\t\tprint_hash(data_hash, 20);\n\t\tprintf(\"\\nfilehash: \");\n\t\tprint_hash(file_hash, 20);\n\t\tprintf(\"\\n\");\n\t\tres = 0;\n\t}\n\tfree(data_hash);\n\tplist_free(mdinfo);\n\treturn res;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <unistd.h>",
            "#include <gcrypt.h>",
            "#include <openssl/sha.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int mobilebackup_check_file_integrity(const char *backup_directory, const char *hash, plist_t filedata)\n{\n\tchar *datapath;\n\tchar *infopath;\n\tplist_t mdinfo = NULL;\n\tstruct stat st;\n\tunsigned char file_hash[20];\n\n\tdatapath = mobilebackup_build_path(backup_directory, hash, \".mddata\");\n\tif (stat(datapath, &st) != 0) {\n\t\tprintf(\"\\r\\n\");\n\t\tprintf(\"ERROR: '%s.mddata' is missing!\\n\", hash);\n\t\tfree(datapath);\n\t\treturn 0;\n\t}\n\n\tinfopath = mobilebackup_build_path(backup_directory, hash, \".mdinfo\");\n\tplist_read_from_filename(&mdinfo, infopath);\n\tfree(infopath);\n\tif (!mdinfo) {\n\t\tprintf(\"\\r\\n\");\n\t\tprintf(\"ERROR: '%s.mdinfo' is missing or corrupted!\\n\", hash);\n\t\tfree(datapath);\n\t\treturn 0;\n\t}\n\n\t/* sha1 hash verification */\n\tplist_t node = plist_dict_get_item(filedata, \"DataHash\");\n\tif (!node || (plist_get_node_type(node) != PLIST_DATA)) {\n\t\tprintf(\"\\r\\n\");\n\t\tprintf(\"ERROR: Could not get DataHash for file entry '%s'\\n\", hash);\n\t\tplist_free(mdinfo);\n\t\tfree(datapath);\n\t\treturn 0;\n\t}\n\n\tnode = plist_dict_get_item(mdinfo, \"Metadata\");\n\tif (!node && (plist_get_node_type(node) != PLIST_DATA)) {\n\t\tprintf(\"\\r\\n\");\n\t\tprintf(\"ERROR: Could not find Metadata in plist '%s.mdinfo'\\n\", hash);\n\t\tplist_free(mdinfo);\n\t\tfree(datapath);\n\t\treturn 0;\n\t}\n\n\tchar *meta_bin = NULL;\n\tuint64_t meta_bin_size = 0;\n\tplist_get_data_val(node, &meta_bin, &meta_bin_size);\n\tplist_t metadata = NULL;\n\tif (meta_bin) {\n\t\tplist_from_bin(meta_bin, (uint32_t)meta_bin_size, &metadata);\n\t}\n\tif (!metadata) {\n\t\tprintf(\"\\r\\n\");\n\t\tprintf(\"ERROR: Could not get Metadata from plist '%s.mdinfo'\\n\", hash);\n\t\tplist_free(mdinfo);\n\t\tfree(datapath);\n\t\treturn 0;\n\t}\n\n\tchar *version = NULL;\n\tnode = plist_dict_get_item(metadata, \"Version\");\n\tif (node && (plist_get_node_type(node) == PLIST_STRING)) {\n\t\tplist_get_string_val(node, &version);\n\t}\n\n\tchar *destpath = NULL;\n\tnode = plist_dict_get_item(metadata, \"Path\");\n\tif (node && (plist_get_node_type(node) == PLIST_STRING)) {\n\t\tplist_get_string_val(node, &destpath);\n\t}\n\n\tuint8_t greylist = 0;\n\tnode = plist_dict_get_item(metadata, \"Greylist\");\n\tif (node && (plist_get_node_type(node) == PLIST_BOOLEAN)) {\n\t\tplist_get_bool_val(node, &greylist);\n\t}\n\n\tchar *domain = NULL;\n\tnode = plist_dict_get_item(metadata, \"Domain\");\n\tif (node && (plist_get_node_type(node) == PLIST_STRING)) {\n\t\tplist_get_string_val(node, &domain);\n\t}\n\n\tchar *fnstr = malloc(strlen(domain) + 1 + strlen(destpath) + 1);\n\tstrcpy(fnstr, domain);\n\tstrcat(fnstr, \"-\");\n\tstrcat(fnstr, destpath);\n\tunsigned char fnhash[20];\n\tchar fnamehash[41];\n\tchar *p = fnamehash;\n\tsha1_of_data(fnstr, strlen(fnstr), fnhash);\n\tfree(fnstr);\n\tint i;\n\tfor ( i = 0; i < 20; i++, p += 2 ) {\n\t\tsnprintf (p, 3, \"%02x\", (unsigned char)fnhash[i] );\n\t}\n\tif (strcmp(fnamehash, hash)) {\n\t\tprintf(\"\\r\\n\");\n\t\tprintf(\"WARNING: filename hash does not match for entry '%s'\\n\", hash);\n\t}\n\n\tchar *auth_version = NULL;\n\tnode = plist_dict_get_item(mdinfo, \"AuthVersion\");\n\tif (node && (plist_get_node_type(node) == PLIST_STRING)) {\n\t\tplist_get_string_val(node, &auth_version);\n\t}\n\n\tif (strcmp(auth_version, \"1.0\")) {\n\t\tprintf(\"\\r\\n\");\n\t\tprintf(\"WARNING: Unknown AuthVersion '%s', DataHash cannot be verified!\\n\", auth_version);\n\t}\n\n\tnode = plist_dict_get_item(filedata, \"DataHash\");\n\tif (!node || (plist_get_node_type(node) != PLIST_DATA)) {\n\t\tprintf(\"\\r\\n\");\n\t\tprintf(\"WARNING: Could not get DataHash key from file info data for entry '%s'\\n\", hash);\n\t}\n\n\tint res = 1;\n\tunsigned char *data_hash = NULL;\n\tuint64_t data_hash_len = 0;\n\tplist_get_data_val(node, (char**)&data_hash, &data_hash_len);\n\tint hash_ok = 0;\n\tif (data_hash && (data_hash_len == 20)) {\n\t\tcompute_datahash(datapath, destpath, greylist, domain, NULL, version, file_hash);\n\t\thash_ok = compare_hash(data_hash, file_hash, 20);\n\t} else if (data_hash_len == 0) {\n\t\t/* no datahash present */\n\t\thash_ok = 1;\n\t}\n\n\tfree(domain);\n\tfree(version);\n\tfree(destpath);\n\n\tif (!hash_ok) {\n\t\tprintf(\"\\r\\n\");\n\t\tprintf(\"ERROR: The hash for '%s.mddata' does not match DataHash entry in Manifest\\n\", hash);\n\t\tprintf(\"datahash: \");\n\t\tprint_hash(data_hash, 20);\n\t\tprintf(\"\\nfilehash: \");\n\t\tprint_hash(file_hash, 20);\n\t\tprintf(\"\\n\");\n\t\tres = 0;\n\t}\n\tfree(data_hash);\n\tplist_free(mdinfo);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_dict_next_item",
          "args": [
            "files",
            "iter",
            "&hash",
            "&node"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_size",
          "args": [
            "files"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_new_iter",
          "args": [
            "files",
            "&iter"
          ],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_node_type",
          "args": [
            "files"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "backup_data",
            "\"Files\""
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Could not read plist from Manifest.plist Data key!\\n\""
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_from_bin",
          "args": [
            "bin",
            "(uint32_t)binsize",
            "&backup_data"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Could not get AuthSignature from manifest!\\n\""
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ERROR: AuthSignature is NOT VALID\\n\""
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"AuthSignature is valid\\n\""
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compare_hash",
          "args": [
            "auth_sig",
            "data_sha1",
            "20"
          ],
          "line": 1280
        },
        "resolved": true,
        "details": {
          "function_name": "compare_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
          "lines": "86-95",
          "snippet": "static int compare_hash(const unsigned char *hash1, const unsigned char *hash2, int hash_len)\n{\n\tint i;\n\tfor (i = 0; i < hash_len; i++) {\n\t\tif (hash1[i] != hash2[i]) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <unistd.h>",
            "#include <gcrypt.h>",
            "#include <openssl/sha.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int compare_hash(const unsigned char *hash1, const unsigned char *hash2, int hash_len)\n{\n\tint i;\n\tfor (i = 0; i < hash_len; i++) {\n\t\tif (hash1[i] != hash2[i]) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sha1_of_data",
          "args": [
            "bin",
            "binsize",
            "data_sha1"
          ],
          "line": 1279
        },
        "resolved": true,
        "details": {
          "function_name": "sha1_of_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
          "lines": "77-84",
          "snippet": "static void sha1_of_data(const char *input, uint32_t size, unsigned char *hash_out)\n{\n#ifdef HAVE_OPENSSL\n\tSHA1((const unsigned char*)input, size, hash_out);\n#else\n\tgcry_md_hash_buffer(GCRY_MD_SHA1, hash_out, input, size);\n#endif\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <unistd.h>",
            "#include <gcrypt.h>",
            "#include <openssl/sha.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void sha1_of_data(const char *input, uint32_t size, unsigned char *hash_out)\n{\n#ifdef HAVE_OPENSSL\n\tSHA1((const unsigned char*)input, size, hash_out);\n#else\n\tgcry_md_hash_buffer(GCRY_MD_SHA1, hash_out, input, size);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_get_data_val",
          "args": [
            "node",
            "(char**)&auth_sig",
            "&auth_sig_len"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_node_type",
          "args": [
            "node"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "manifest_plist",
            "\"AuthSignature\""
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "auth_ver",
            "\"2.0\""
          ],
          "line": 1271
        },
        "resolved": true,
        "details": {
          "function_name": "plist_strcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
          "lines": "296-309",
          "snippet": "static int plist_strcmp(plist_t node, const char *str)\n{\n\tchar *buffer = NULL;\n\tint ret = 0;\n\n\tif (plist_get_node_type(node) != PLIST_STRING)\n\t\treturn ret;\n\n\tplist_get_string_val(node, &buffer);\n\tret = strcmp(buffer, str);\n\tfree(buffer);\n\n\treturn ret;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <unistd.h>",
            "#include <gcrypt.h>",
            "#include <openssl/sha.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int plist_strcmp(plist_t node, const char *str)\n{\n\tchar *buffer = NULL;\n\tint ret = 0;\n\n\tif (plist_get_node_type(node) != PLIST_STRING)\n\t\treturn ret;\n\n\tplist_get_string_val(node, &buffer);\n\tret = strcmp(buffer, str);\n\tfree(buffer);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_get_string_val",
          "args": [
            "node",
            "&auth_ver"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "manifest_plist",
            "\"AuthVersion\""
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_data_val",
          "args": [
            "node",
            "&bin",
            "&binsize"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Could not read Data key from Manifest.plist!\\n\""
          ],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_node_type",
          "args": [
            "node"
          ],
          "line": 1258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "manifest_plist",
            "\"Data\""
          ],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Verifying backup integrity, please wait.\\n\""
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Could not read Manifest.plist. Aborting.\\n\""
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Reading existing Manifest.\\n\""
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ERROR: Cannot ensure we restore from a successful backup. Aborting.\\n\""
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mobilebackup_read_status",
          "args": [
            "backup_directory"
          ],
          "line": 1242
        },
        "resolved": true,
        "details": {
          "function_name": "mobilebackup_read_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
          "lines": "340-362",
          "snippet": "static int mobilebackup_read_status(const char *path)\n{\n\tint ret = -1;\n\tplist_t status_plist = NULL;\n\tchar *file_path = mobilebackup_build_path(path, \"Status\", \".plist\");\n\n\tplist_read_from_filename(&status_plist, file_path);\n\tfree(file_path);\n\tif (!status_plist) {\n\t\tprintf(\"Could not read Status.plist!\\n\");\n\t\treturn ret;\n\t}\n\tplist_t node = plist_dict_get_item(status_plist, \"Backup Success\");\n\tif (node && (plist_get_node_type(node) == PLIST_BOOLEAN)) {\n\t\tuint8_t bval = 0;\n\t\tplist_get_bool_val(node, &bval);\n\t\tret = bval;\n\t} else {\n\t\tprintf(\"%s: ERROR could not get Backup Success key from Status.plist!\\n\", __func__);\n\t}\n\tplist_free(status_plist);\n\treturn ret;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <unistd.h>",
            "#include <gcrypt.h>",
            "#include <openssl/sha.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int mobilebackup_read_status(const char *path)\n{\n\tint ret = -1;\n\tplist_t status_plist = NULL;\n\tchar *file_path = mobilebackup_build_path(path, \"Status\", \".plist\");\n\n\tplist_read_from_filename(&status_plist, file_path);\n\tfree(file_path);\n\tif (!status_plist) {\n\t\tprintf(\"Could not read Status.plist!\\n\");\n\t\treturn ret;\n\t}\n\tplist_t node = plist_dict_get_item(status_plist, \"Backup Success\");\n\tif (node && (plist_get_node_type(node) == PLIST_BOOLEAN)) {\n\t\tuint8_t bval = 0;\n\t\tplist_get_bool_val(node, &bval);\n\t\tret = bval;\n\t} else {\n\t\tprintf(\"%s: ERROR could not get Backup Success key from Status.plist!\\n\", __func__);\n\t}\n\tplist_free(status_plist);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Backup Failed.\\n\""
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Backup Successful.\\n\""
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_write_to_filename",
          "args": [
            "manifest_plist",
            "manifest_path",
            "PLIST_FORMAT_XML"
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "plist_write_to_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/utils.c",
          "lines": "270-290",
          "snippet": "int plist_write_to_filename(plist_t plist, const char *filename, enum plist_format_t format)\n{\n\tchar *buffer = NULL;\n\tuint32_t length;\n\n\tif (!plist || !filename)\n\t\treturn 0;\n\n\tif (format == PLIST_FORMAT_XML)\n\t\tplist_to_xml(plist, &buffer, &length);\n\telse if (format == PLIST_FORMAT_BINARY)\n\t\tplist_to_bin(plist, &buffer, &length);\n\telse\n\t\treturn 0;\n\n\tbuffer_write_to_filename(filename, buffer, length);\n\n\tfree(buffer);\n\n\treturn 1;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include <ctype.h>",
            "#include <inttypes.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include <ctype.h>\n#include <inttypes.h>\n#include <sys/time.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <config.h>\n\nint plist_write_to_filename(plist_t plist, const char *filename, enum plist_format_t format)\n{\n\tchar *buffer = NULL;\n\tuint32_t length;\n\n\tif (!plist || !filename)\n\t\treturn 0;\n\n\tif (format == PLIST_FORMAT_XML)\n\t\tplist_to_xml(plist, &buffer, &length);\n\telse if (format == PLIST_FORMAT_BINARY)\n\t\tplist_to_bin(plist, &buffer, &length);\n\telse\n\t\treturn 0;\n\n\tbuffer_write_to_filename(filename, buffer, length);\n\n\tfree(buffer);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Storing Manifest.plist...\\n\""
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove",
          "args": [
            "manifest_path"
          ],
          "line": 1215
        },
        "resolved": true,
        "details": {
          "function_name": "str_remove_spaces",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/lockdown.c",
          "lines": "1443-1453",
          "snippet": "static void str_remove_spaces(char *source)\n{\n\tchar *dest = source;\n\twhile (*source != 0) {\n\t\tif (!isspace(*source)) {\n\t\t\t*dest++ = *source; /* copy */\n\t\t}\n\t\tsource++;\n\t}\n\t*dest = 0;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/userpref.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"lockdown.h\"",
            "#include \"property_list_service.h\"",
            "#include <plist/plist.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/x509.h>",
            "#include <libtasn1.h>",
            "#include <openssl/x509v3.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/pem.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/userpref.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"lockdown.h\"\n#include \"property_list_service.h\"\n#include <plist/plist.h>\n#include <gnutls/crypto.h>\n#include <gnutls/x509.h>\n#include <libtasn1.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/pem.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nstatic void str_remove_spaces(char *source)\n{\n\tchar *dest = source;\n\twhile (*source != 0) {\n\t\tif (!isspace(*source)) {\n\t\t\t*dest++ = *source; /* copy */\n\t\t}\n\t\tsource++;\n\t}\n\t*dest = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "node_tmp",
            "\"BackupManifestKey\""
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_array_get_item",
          "args": [
            "message",
            "1"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"FAILED\\n\""
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"DONE\\n\""
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mobilebackup_delete_backup_file_by_hash",
          "args": [
            "backup_directory",
            "file_path"
          ],
          "line": 1204
        },
        "resolved": true,
        "details": {
          "function_name": "mobilebackup_delete_backup_file_by_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
          "lines": "425-450",
          "snippet": "static int mobilebackup_delete_backup_file_by_hash(const char *backup_directory, const char *hash)\n{\n\tint ret = 0;\n\tchar *path = mobilebackup_build_path(backup_directory, hash, \".mddata\");\n\tprintf(\"Removing \\\"%s\\\" \", path);\n\tif (!remove( path ))\n\t\tret = 1;\n\telse\n\t\tret = 0;\n\n\tfree(path);\n\n\tif (!ret)\n\t\treturn ret;\n\n\tpath = mobilebackup_build_path(backup_directory, hash, \".mdinfo\");\n\tprintf(\"and \\\"%s\\\"... \", path);\n\tif (!remove( path ))\n\t\tret = 1;\n\telse\n\t\tret = 0;\n\n\tfree(path);\n\n\treturn ret;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <unistd.h>",
            "#include <gcrypt.h>",
            "#include <openssl/sha.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int mobilebackup_delete_backup_file_by_hash(const char *backup_directory, const char *hash)\n{\n\tint ret = 0;\n\tchar *path = mobilebackup_build_path(backup_directory, hash, \".mddata\");\n\tprintf(\"Removing \\\"%s\\\" \", path);\n\tif (!remove( path ))\n\t\tret = 1;\n\telse\n\t\tret = 0;\n\n\tfree(path);\n\n\tif (!ret)\n\t\treturn ret;\n\n\tpath = mobilebackup_build_path(backup_directory, hash, \".mdinfo\");\n\tprintf(\"and \\\"%s\\\"... \", path);\n\tif (!remove( path ))\n\t\tret = 1;\n\telse\n\t\tret = 0;\n\n\tfree(path);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_get_string_val",
          "args": [
            "node_tmp",
            "&file_path"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_array_get_item",
          "args": [
            "node",
            "i++"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_array_get_size",
          "args": [
            "node"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "node_tmp",
            "\"BackupFilesToDeleteKey\""
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "node_tmp",
            "\"BackupMessageTypeKey\""
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_array_get_item",
          "args": [
            "message",
            "1"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mobilebackup_send_backup_file_received",
          "args": [
            "mobilebackup"
          ],
          "line": 1163
        },
        "resolved": true,
        "details": {
          "function_name": "mobilebackup_send_backup_file_received",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/mobilebackup.c",
          "lines": "295-298",
          "snippet": "LIBIMOBILEDEVICE_API mobilebackup_error_t mobilebackup_send_backup_file_received(mobilebackup_client_t client)\n{\n\treturn mobilebackup_send_message(client, \"kBackupMessageBackupFileReceived\", NULL);\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"device_link_service.h\"",
            "#include \"mobilebackup.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <plist/plist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"device_link_service.h\"\n#include \"mobilebackup.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <plist/plist.h>\n\nLIBIMOBILEDEVICE_API mobilebackup_error_t mobilebackup_send_backup_file_received(mobilebackup_client_t client)\n{\n\treturn mobilebackup_send_message(client, \"kBackupMessageBackupFileReceived\", NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_free",
          "args": [
            "message"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_progress",
          "args": [
            "(double)((file_size_current*100)/file_size)"
          ],
          "line": 1148
        },
        "resolved": true,
        "details": {
          "function_name": "print_progress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
          "lines": "631-652",
          "snippet": "static void print_progress(double progress)\n{\n\tint i = 0;\n\tif (progress < 0)\n\t\treturn;\n\n\tif (progress > 100)\n\t\tprogress = 100;\n\n\tprintf(\"\\r[\");\n\tfor(i = 0; i < 50; i++) {\n\t\tif(i < progress / 2) {\n\t\t\tprintf(\"=\");\n\t\t} else {\n\t\t\tprintf(\" \");\n\t\t}\n\t}\n\tprintf(\"] %3.0f%%\", progress);\n\tfflush(stdout);\n\tif (progress == 100)\n\t\tprintf(\"\\n\");\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <unistd.h>",
            "#include <gcrypt.h>",
            "#include <openssl/sha.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void print_progress(double progress)\n{\n\tint i = 0;\n\tif (progress < 0)\n\t\treturn;\n\n\tif (progress > 100)\n\t\tprogress = 100;\n\n\tprintf(\"\\r[\");\n\tfor(i = 0; i < 50; i++) {\n\t\tif(i < progress / 2) {\n\t\t\tprintf(\"=\");\n\t\t} else {\n\t\t\tprintf(\" \");\n\t\t}\n\t}\n\tprintf(\"] %3.0f%%\", progress);\n\tfflush(stdout);\n\tif (progress == 100)\n\t\tprintf(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "rename",
          "args": [
            "filename_mddata",
            "manifest_path"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_write_to_filename",
          "args": [
            "filename_mddata",
            "buffer",
            "length"
          ],
          "line": 1128
        },
        "resolved": true,
        "details": {
          "function_name": "buffer_write_to_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/utils.c",
          "lines": "234-243",
          "snippet": "void buffer_write_to_filename(const char *filename, const char *buffer, uint64_t length)\n{\n\tFILE *f;\n\n\tf = fopen(filename, \"wb\");\n\tif (f) {\n\t\tfwrite(buffer, sizeof(char), length, f);\n\t\tfclose(f);\n\t}\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include <ctype.h>",
            "#include <inttypes.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include <ctype.h>\n#include <inttypes.h>\n#include <sys/time.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <config.h>\n\nvoid buffer_write_to_filename(const char *filename, const char *buffer, uint64_t length)\n{\n\tFILE *f;\n\n\tf = fopen(filename, \"wb\");\n\tif (f) {\n\t\tfwrite(buffer, sizeof(char), length, f);\n\t\tfclose(f);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_get_data_val",
          "args": [
            "node_tmp",
            "&buffer",
            "&length"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_array_get_item",
          "args": [
            "message",
            "1"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_string_val",
          "args": [
            "node",
            "&file_path"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "node_tmp",
            "\"DLFileDest\""
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "node_tmp",
            "\"BackupFileInfo\""
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "node_tmp",
            "\"BackupFileInfo\""
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_string_val",
          "args": [
            "node",
            "&file_path"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "node_tmp",
            "\"DLFileDest\""
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "node_tmp",
            "\"BackupFileInfo\""
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "string_format_size",
          "args": [
            "file_size"
          ],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "string_format_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/utils.c",
          "lines": "142-162",
          "snippet": "char *string_format_size(uint64_t size)\n{\n\tchar buf[80];\n\tdouble sz;\n\tif (size >= 1000000000000LL) {\n\t\tsz = ((double)size / 1000000000000.0f);\n\t\tsprintf(buf, \"%0.1f TB\", sz);\n\t} else if (size >= 1000000000LL) {\n\t\tsz = ((double)size / 1000000000.0f);\n\t\tsprintf(buf, \"%0.1f GB\", sz);\n\t} else if (size >= 1000000LL) {\n\t\tsz = ((double)size / 1000000.0f);\n\t\tsprintf(buf, \"%0.1f MB\", sz);\n\t} else if (size >= 1000LL) {\n\t\tsz = ((double)size / 1000.0f);\n\t\tsprintf(buf, \"%0.1f KB\", sz);\n\t} else {\n\t\tsprintf(buf, \"%d Bytes\", (int)size);\n\t}\n\treturn strdup(buf);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include <ctype.h>",
            "#include <inttypes.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include <ctype.h>\n#include <inttypes.h>\n#include <sys/time.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <config.h>\n\nchar *string_format_size(uint64_t size)\n{\n\tchar buf[80];\n\tdouble sz;\n\tif (size >= 1000000000000LL) {\n\t\tsz = ((double)size / 1000000000000.0f);\n\t\tsprintf(buf, \"%0.1f TB\", sz);\n\t} else if (size >= 1000000000LL) {\n\t\tsz = ((double)size / 1000000000.0f);\n\t\tsprintf(buf, \"%0.1f GB\", sz);\n\t} else if (size >= 1000000LL) {\n\t\tsz = ((double)size / 1000000.0f);\n\t\tsprintf(buf, \"%0.1f MB\", sz);\n\t} else if (size >= 1000LL) {\n\t\tsz = ((double)size / 1000.0f);\n\t\tsprintf(buf, \"%0.1f KB\", sz);\n\t} else {\n\t\tsprintf(buf, \"%d Bytes\", (int)size);\n\t}\n\treturn strdup(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_get_uint_val",
          "args": [
            "node",
            "&file_size"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "node",
            "\"FileSize\""
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "node_tmp",
            "\"DLFileAttributesKey\""
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_string_val",
          "args": [
            "node",
            "&filename_source"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "node_tmp",
            "\"DLFileSource\""
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_bool_val",
          "args": [
            "node",
            "&b"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "node_tmp",
            "\"BackupManifestKey\""
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_uint_val",
          "args": [
            "node",
            "&c"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "node_tmp",
            "\"DLFileStatusKey\""
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_uint_val",
          "args": [
            "node",
            "&backup_total_size"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "node_tmp",
            "\"BackupTotalSizeKey\""
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_array_get_item",
          "args": [
            "message",
            "2"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_array_get_item",
          "args": [
            "message",
            "0"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sleep",
          "args": [
            "2"
          ],
          "line": 1026
        },
        "resolved": true,
        "details": {
          "function_name": "diagnostics_relay_sleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/diagnostics_relay.c",
          "lines": "199-229",
          "snippet": "LIBIMOBILEDEVICE_API diagnostics_relay_error_t diagnostics_relay_sleep(diagnostics_relay_client_t client)\n{\n\tif (!client)\n\t\treturn DIAGNOSTICS_RELAY_E_INVALID_ARG;\n\n\tdiagnostics_relay_error_t ret = DIAGNOSTICS_RELAY_E_UNKNOWN_ERROR;\n\n\tplist_t dict = plist_new_dict();\n\n\tplist_dict_set_item(dict,\"Request\", plist_new_string(\"Sleep\"));\n\tret = diagnostics_relay_send(client, dict);\n\tplist_free(dict);\n\tdict = NULL;\n\n\tret = diagnostics_relay_receive(client, &dict);\n\tif (!dict) {\n\t\treturn DIAGNOSTICS_RELAY_E_PLIST_ERROR;\n\t}\n\n\tint check = diagnostics_relay_check_result(dict);\n\tif (check == RESULT_SUCCESS) {\n\t\tret = DIAGNOSTICS_RELAY_E_SUCCESS;\n\t} else if (check == RESULT_UNKNOWN_REQUEST) {\n\t\tret = DIAGNOSTICS_RELAY_E_UNKNOWN_REQUEST;\n\t} else {\n\t\tret = DIAGNOSTICS_RELAY_E_UNKNOWN_ERROR;\n\t}\n\n\tplist_free(dict);\n\treturn ret;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"property_list_service.h\"",
            "#include \"diagnostics_relay.h\"",
            "#include <stdlib.h>",
            "#include <string.h>"
          ],
          "macros_used": [
            "#define RESULT_UNKNOWN_REQUEST 2",
            "#define RESULT_SUCCESS 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"property_list_service.h\"\n#include \"diagnostics_relay.h\"\n#include <stdlib.h>\n#include <string.h>\n\n#define RESULT_UNKNOWN_REQUEST 2\n#define RESULT_SUCCESS 0\n\nLIBIMOBILEDEVICE_API diagnostics_relay_error_t diagnostics_relay_sleep(diagnostics_relay_client_t client)\n{\n\tif (!client)\n\t\treturn DIAGNOSTICS_RELAY_E_INVALID_ARG;\n\n\tdiagnostics_relay_error_t ret = DIAGNOSTICS_RELAY_E_UNKNOWN_ERROR;\n\n\tplist_t dict = plist_new_dict();\n\n\tplist_dict_set_item(dict,\"Request\", plist_new_string(\"Sleep\"));\n\tret = diagnostics_relay_send(client, dict);\n\tplist_free(dict);\n\tdict = NULL;\n\n\tret = diagnostics_relay_receive(client, &dict);\n\tif (!dict) {\n\t\treturn DIAGNOSTICS_RELAY_E_PLIST_ERROR;\n\t}\n\n\tint check = diagnostics_relay_check_result(dict);\n\tif (check == RESULT_SUCCESS) {\n\t\tret = DIAGNOSTICS_RELAY_E_SUCCESS;\n\t} else if (check == RESULT_UNKNOWN_REQUEST) {\n\t\tret = DIAGNOSTICS_RELAY_E_UNKNOWN_REQUEST;\n\t} else {\n\t\tret = DIAGNOSTICS_RELAY_E_UNKNOWN_ERROR;\n\t}\n\n\tplist_free(dict);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Device is not ready yet. Going to try again in 2 seconds...\\n\""
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ERROR: Could not start backup process: unspecified error occured\\n\""
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ERROR: Could not start backup process: device refused to start the backup process.\\n\""
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ERROR: Could not start backup process: backup protocol version mismatch!\\n\""
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Please wait. Device is preparing backup data...\\n\""
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Incremental backup mode.\\n\""
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Full backup mode.\\n\""
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mobilebackup_request_backup",
          "args": [
            "mobilebackup",
            "manifest_plist",
            "\"/\"",
            "\"1.6\""
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "mobilebackup_request_backup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/mobilebackup.c",
          "lines": "235-293",
          "snippet": "LIBIMOBILEDEVICE_API mobilebackup_error_t mobilebackup_request_backup(mobilebackup_client_t client, plist_t backup_manifest, const char *base_path, const char *proto_version)\n{\n\tif (!client || !client->parent || !base_path || !proto_version)\n\t\treturn MOBILEBACKUP_E_INVALID_ARG;\n\n\tif (backup_manifest && (plist_get_node_type(backup_manifest) != PLIST_DICT))\n\t\treturn MOBILEBACKUP_E_PLIST_ERROR;\n\n\tmobilebackup_error_t err;\n\n\t/* construct request plist */\n\tplist_t dict = plist_new_dict();\n\tif (backup_manifest)\n\t\tplist_dict_set_item(dict, \"BackupManifestKey\", plist_copy(backup_manifest));\n\tplist_dict_set_item(dict, \"BackupComputerBasePathKey\", plist_new_string(base_path));\n\tplist_dict_set_item(dict, \"BackupMessageTypeKey\", plist_new_string(\"BackupMessageBackupRequest\"));\n\tplist_dict_set_item(dict, \"BackupProtocolVersion\", plist_new_string(proto_version));\n\n\t/* send request */\n\terr = mobilebackup_send_message(client, NULL, dict);\n\tplist_free(dict);\n\tdict = NULL;\n\tif (err != MOBILEBACKUP_E_SUCCESS) {\n\t\tdebug_info(\"ERROR: Could not send backup request message (%d)!\", err);\n\t\tgoto leave;\n\t}\n\n\t/* now receive and hopefully get a BackupMessageBackupReplyOK */\n\terr = mobilebackup_receive_message(client, \"BackupMessageBackupReplyOK\", &dict);\n\tif (err != MOBILEBACKUP_E_SUCCESS) {\n\t\tdebug_info(\"ERROR: Could not receive BackupReplyOK message (%d)!\", err);\n\t\tgoto leave;\n\t}\n\n\tplist_t node = plist_dict_get_item(dict, \"BackupProtocolVersion\");\n\tif (node) {\n\t\tchar *str = NULL;\n\t\tplist_get_string_val(node, &str);\n\t\tif (str) {\n\t\t\tif (strcmp(str, proto_version) != 0) {\n\t\t\t\terr = MOBILEBACKUP_E_BAD_VERSION;\n\t\t\t}\n\t\t\tfree(str);\n\t\t}\n\t}\n\tif (err != MOBILEBACKUP_E_SUCCESS)\n\t\tgoto leave;\n\n\t/* BackupMessageBackupReplyOK received, send it back */\n\terr = mobilebackup_send_message(client, NULL, dict);\n\tif (err != MOBILEBACKUP_E_SUCCESS) {\n\t\tdebug_info(\"ERROR: Could not send BackupReplyOK ACK (%d)\", err);\n\t}\n\nleave:\n\tif (dict)\n\t\tplist_free(dict);\n\treturn err;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"device_link_service.h\"",
            "#include \"mobilebackup.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <plist/plist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"device_link_service.h\"\n#include \"mobilebackup.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <plist/plist.h>\n\nLIBIMOBILEDEVICE_API mobilebackup_error_t mobilebackup_request_backup(mobilebackup_client_t client, plist_t backup_manifest, const char *base_path, const char *proto_version)\n{\n\tif (!client || !client->parent || !base_path || !proto_version)\n\t\treturn MOBILEBACKUP_E_INVALID_ARG;\n\n\tif (backup_manifest && (plist_get_node_type(backup_manifest) != PLIST_DICT))\n\t\treturn MOBILEBACKUP_E_PLIST_ERROR;\n\n\tmobilebackup_error_t err;\n\n\t/* construct request plist */\n\tplist_t dict = plist_new_dict();\n\tif (backup_manifest)\n\t\tplist_dict_set_item(dict, \"BackupManifestKey\", plist_copy(backup_manifest));\n\tplist_dict_set_item(dict, \"BackupComputerBasePathKey\", plist_new_string(base_path));\n\tplist_dict_set_item(dict, \"BackupMessageTypeKey\", plist_new_string(\"BackupMessageBackupRequest\"));\n\tplist_dict_set_item(dict, \"BackupProtocolVersion\", plist_new_string(proto_version));\n\n\t/* send request */\n\terr = mobilebackup_send_message(client, NULL, dict);\n\tplist_free(dict);\n\tdict = NULL;\n\tif (err != MOBILEBACKUP_E_SUCCESS) {\n\t\tdebug_info(\"ERROR: Could not send backup request message (%d)!\", err);\n\t\tgoto leave;\n\t}\n\n\t/* now receive and hopefully get a BackupMessageBackupReplyOK */\n\terr = mobilebackup_receive_message(client, \"BackupMessageBackupReplyOK\", &dict);\n\tif (err != MOBILEBACKUP_E_SUCCESS) {\n\t\tdebug_info(\"ERROR: Could not receive BackupReplyOK message (%d)!\", err);\n\t\tgoto leave;\n\t}\n\n\tplist_t node = plist_dict_get_item(dict, \"BackupProtocolVersion\");\n\tif (node) {\n\t\tchar *str = NULL;\n\t\tplist_get_string_val(node, &str);\n\t\tif (str) {\n\t\t\tif (strcmp(str, proto_version) != 0) {\n\t\t\t\terr = MOBILEBACKUP_E_BAD_VERSION;\n\t\t\t}\n\t\t\tfree(str);\n\t\t}\n\t}\n\tif (err != MOBILEBACKUP_E_SUCCESS)\n\t\tgoto leave;\n\n\t/* BackupMessageBackupReplyOK received, send it back */\n\terr = mobilebackup_send_message(client, NULL, dict);\n\tif (err != MOBILEBACKUP_E_SUCCESS) {\n\t\tdebug_info(\"ERROR: Could not send BackupReplyOK ACK (%d)\", err);\n\t}\n\nleave:\n\tif (dict)\n\t\tplist_free(dict);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Requesting backup from device...\\n\""
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_free",
          "args": [
            "info_plist"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mobilebackup_factory_info_plist_new",
          "args": [
            "udid"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "mobilebackup_factory_info_plist_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
          "lines": "227-281",
          "snippet": "static plist_t mobilebackup_factory_info_plist_new(const char* udid)\n{\n\t/* gather data from lockdown */\n\tplist_t value_node = NULL;\n\tplist_t root_node = NULL;\n\tchar *udid_uppercase = NULL;\n\n\tplist_t ret = plist_new_dict();\n\n\t/* get basic device information in one go */\n\tlockdownd_get_value(client, NULL, NULL, &root_node);\n\n\t/* set fields we understand */\n\tvalue_node = plist_dict_get_item(root_node, \"BuildVersion\");\n\tplist_dict_set_item(ret, \"Build Version\", plist_copy(value_node));\n\n\tvalue_node = plist_dict_get_item(root_node, \"DeviceName\");\n\tplist_dict_set_item(ret, \"Device Name\", plist_copy(value_node));\n\tplist_dict_set_item(ret, \"Display Name\", plist_copy(value_node));\n\n\t/* FIXME: How is the GUID generated? */\n\tplist_dict_set_item(ret, \"GUID\", plist_new_string(\"---\"));\n\n\tvalue_node = plist_dict_get_item(root_node, \"InternationalMobileEquipmentIdentity\");\n\tif (value_node)\n\t\tplist_dict_set_item(ret, \"IMEI\", plist_copy(value_node));\n\n\tplist_dict_set_item(ret, \"Last Backup Date\", plist_new_date(time(NULL), 0));\n\n\tvalue_node = plist_dict_get_item(root_node, \"ProductType\");\n\tplist_dict_set_item(ret, \"Product Type\", plist_copy(value_node));\n\n\tvalue_node = plist_dict_get_item(root_node, \"ProductVersion\");\n\tplist_dict_set_item(ret, \"Product Version\", plist_copy(value_node));\n\n\tvalue_node = plist_dict_get_item(root_node, \"SerialNumber\");\n\tplist_dict_set_item(ret, \"Serial Number\", plist_copy(value_node));\n\n\tvalue_node = plist_dict_get_item(root_node, \"UniqueDeviceID\");\n\tplist_dict_set_item(ret, \"Target Identifier\", plist_new_string(udid));\n\n\t/* uppercase */\n\tudid_uppercase = string_toupper((char*)udid);\n\tplist_dict_set_item(ret, \"Unique Identifier\", plist_new_string(udid_uppercase));\n\tfree(udid_uppercase);\n\n\t/* FIXME: Embed files as <data> nodes */\n\tplist_t files = plist_new_dict();\n\tplist_dict_set_item(ret, \"iTunes Files\", files);\n\tplist_dict_set_item(ret, \"iTunes Version\", plist_new_string(\"9.0.2\"));\n\n\tplist_free(root_node);\n\n\treturn ret;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <unistd.h>",
            "#include <gcrypt.h>",
            "#include <openssl/sha.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static lockdownd_client_t client = NULL;",
            "static idevice_t device = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic lockdownd_client_t client = NULL;\nstatic idevice_t device = NULL;\n\nstatic plist_t mobilebackup_factory_info_plist_new(const char* udid)\n{\n\t/* gather data from lockdown */\n\tplist_t value_node = NULL;\n\tplist_t root_node = NULL;\n\tchar *udid_uppercase = NULL;\n\n\tplist_t ret = plist_new_dict();\n\n\t/* get basic device information in one go */\n\tlockdownd_get_value(client, NULL, NULL, &root_node);\n\n\t/* set fields we understand */\n\tvalue_node = plist_dict_get_item(root_node, \"BuildVersion\");\n\tplist_dict_set_item(ret, \"Build Version\", plist_copy(value_node));\n\n\tvalue_node = plist_dict_get_item(root_node, \"DeviceName\");\n\tplist_dict_set_item(ret, \"Device Name\", plist_copy(value_node));\n\tplist_dict_set_item(ret, \"Display Name\", plist_copy(value_node));\n\n\t/* FIXME: How is the GUID generated? */\n\tplist_dict_set_item(ret, \"GUID\", plist_new_string(\"---\"));\n\n\tvalue_node = plist_dict_get_item(root_node, \"InternationalMobileEquipmentIdentity\");\n\tif (value_node)\n\t\tplist_dict_set_item(ret, \"IMEI\", plist_copy(value_node));\n\n\tplist_dict_set_item(ret, \"Last Backup Date\", plist_new_date(time(NULL), 0));\n\n\tvalue_node = plist_dict_get_item(root_node, \"ProductType\");\n\tplist_dict_set_item(ret, \"Product Type\", plist_copy(value_node));\n\n\tvalue_node = plist_dict_get_item(root_node, \"ProductVersion\");\n\tplist_dict_set_item(ret, \"Product Version\", plist_copy(value_node));\n\n\tvalue_node = plist_dict_get_item(root_node, \"SerialNumber\");\n\tplist_dict_set_item(ret, \"Serial Number\", plist_copy(value_node));\n\n\tvalue_node = plist_dict_get_item(root_node, \"UniqueDeviceID\");\n\tplist_dict_set_item(ret, \"Target Identifier\", plist_new_string(udid));\n\n\t/* uppercase */\n\tudid_uppercase = string_toupper((char*)udid);\n\tplist_dict_set_item(ret, \"Unique Identifier\", plist_new_string(udid_uppercase));\n\tfree(udid_uppercase);\n\n\t/* FIXME: Embed files as <data> nodes */\n\tplist_t files = plist_new_dict();\n\tplist_dict_set_item(ret, \"iTunes Files\", files);\n\tplist_dict_set_item(ret, \"iTunes Version\", plist_new_string(\"9.0.2\"));\n\n\tplist_free(root_node);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Creating Info.plist for new backup.\\n\""
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_free",
          "args": [
            "info_plist"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Could not read Manifest.plist, switching to full backup mode.\\n\""
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Reading existing Manifest.\\n\""
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Starting backup...\\n\""
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"ERROR: timeout while locking for sync\\n\""
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"ERROR: could not lock file! error code: %d\\n\"",
            "aerr"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "LOCK_WAIT"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afc_file_open",
          "args": [
            "afc",
            "\"/com.apple.itunes.lock_sync\"",
            "AFC_FOPEN_RW",
            "&lockfile"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "afc_file_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "616-662",
          "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_file_open(afc_client_t client, const char *filename, afc_file_mode_t file_mode, uint64_t *handle)\n{\n\tif (!client || !client->parent || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tuint64_t file_mode_loc = htole64(file_mode);\n\tuint32_t bytes = 0;\n\tchar *data = (char *) malloc(sizeof(char) * (8 + strlen(filename) + 1));\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\t/* set handle to 0 so in case an error occurs, the handle is invalid */\n\t*handle = 0;\n\n\tafc_lock(client);\n\n\t/* Send command */\n\tmemcpy(data, &file_mode_loc, 8);\n\tmemcpy(data + 8, filename, strlen(filename));\n\tdata[8 + strlen(filename)] = '\\0';\n\tret = afc_dispatch_packet(client, AFC_OP_FILE_OPEN, data, 8 + strlen(filename) + 1, NULL, 0, &bytes);\n\tfree(data);\n\n\tif (ret != AFC_E_SUCCESS) {\n\t\tdebug_info(\"Didn't receive a response to the command\");\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\t/* Receive the data */\n\tdata = NULL;\n\tret = afc_receive_data(client, &data, &bytes);\n\tif ((ret == AFC_E_SUCCESS) && (bytes > 0) && data) {\n\t\tafc_unlock(client);\n\n\t\t/* Get the file handle */\n\t\tmemcpy(handle, data, sizeof(uint64_t));\n\t\tfree(data);\n\t\treturn ret;\n\t}\n\t/* in case memory was allocated but no data received or an error occurred */\n\tfree(data);\n\n\tdebug_info(\"Didn't get any further data\");\n\n\tafc_unlock(client);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_file_open(afc_client_t client, const char *filename, afc_file_mode_t file_mode, uint64_t *handle)\n{\n\tif (!client || !client->parent || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tuint64_t file_mode_loc = htole64(file_mode);\n\tuint32_t bytes = 0;\n\tchar *data = (char *) malloc(sizeof(char) * (8 + strlen(filename) + 1));\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\t/* set handle to 0 so in case an error occurs, the handle is invalid */\n\t*handle = 0;\n\n\tafc_lock(client);\n\n\t/* Send command */\n\tmemcpy(data, &file_mode_loc, 8);\n\tmemcpy(data + 8, filename, strlen(filename));\n\tdata[8 + strlen(filename)] = '\\0';\n\tret = afc_dispatch_packet(client, AFC_OP_FILE_OPEN, data, 8 + strlen(filename) + 1, NULL, 0, &bytes);\n\tfree(data);\n\n\tif (ret != AFC_E_SUCCESS) {\n\t\tdebug_info(\"Didn't receive a response to the command\");\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\t/* Receive the data */\n\tdata = NULL;\n\tret = afc_receive_data(client, &data, &bytes);\n\tif ((ret == AFC_E_SUCCESS) && (bytes > 0) && data) {\n\t\tafc_unlock(client);\n\n\t\t/* Get the file handle */\n\t\tmemcpy(handle, data, sizeof(uint64_t));\n\t\tfree(data);\n\t\treturn ret;\n\t}\n\t/* in case memory was allocated but no data received or an error occurred */\n\tfree(data);\n\n\tdebug_info(\"Didn't get any further data\");\n\n\tafc_unlock(client);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Aborting restore. Info.plist is missing.\\n\""
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Aborting restore. Backup data is not compatible with the current device.\\n\""
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mobilebackup_info_is_current_device",
          "args": [
            "info_plist"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "mobilebackup_info_is_current_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
          "lines": "364-423",
          "snippet": "static int mobilebackup_info_is_current_device(plist_t info)\n{\n\tplist_t value_node = NULL;\n\tplist_t node = NULL;\n\tplist_t root_node = NULL;\n\tint ret = 0;\n\n\tif (!info)\n\t\treturn ret;\n\n\tif (plist_get_node_type(info) != PLIST_DICT)\n\t\treturn ret;\n\n\t/* get basic device information in one go */\n\tlockdownd_get_value(client, NULL, NULL, &root_node);\n\n\t/* verify UDID */\n\tvalue_node = plist_dict_get_item(root_node, \"UniqueDeviceID\");\n\tnode = plist_dict_get_item(info, \"Target Identifier\");\n\n\tif(plist_compare_node_value(value_node, node))\n\t\tret = 1;\n\telse {\n\t\tprintf(\"Info.plist: UniqueDeviceID does not match.\\n\");\n\t}\n\n\t/* verify SerialNumber */\n\tif (ret == 1) {\n\t\tvalue_node = plist_dict_get_item(root_node, \"SerialNumber\");\n\t\tnode = plist_dict_get_item(info, \"Serial Number\");\n\n\t\tif(plist_compare_node_value(value_node, node))\n\t\t\tret = 1;\n\t\telse {\n\t\t\tprintf(\"Info.plist: SerialNumber does not match.\\n\");\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\t/* verify ProductVersion to prevent using backup with different OS version */\n\tif (ret == 1) {\n\t\tvalue_node = plist_dict_get_item(root_node, \"ProductVersion\");\n\t\tnode = plist_dict_get_item(info, \"Product Version\");\n\n\t\tif(plist_compare_node_value(value_node, node))\n\t\t\tret = 1;\n\t\telse {\n\t\t\tprintf(\"Info.plist: ProductVersion does not match.\\n\");\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\tplist_free(root_node);\n\troot_node = NULL;\n\n\tvalue_node = NULL;\n\tnode = NULL;\n\n\treturn ret;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <unistd.h>",
            "#include <gcrypt.h>",
            "#include <openssl/sha.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static lockdownd_client_t client = NULL;",
            "static idevice_t device = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic lockdownd_client_t client = NULL;\nstatic idevice_t device = NULL;\n\nstatic int mobilebackup_info_is_current_device(plist_t info)\n{\n\tplist_t value_node = NULL;\n\tplist_t node = NULL;\n\tplist_t root_node = NULL;\n\tint ret = 0;\n\n\tif (!info)\n\t\treturn ret;\n\n\tif (plist_get_node_type(info) != PLIST_DICT)\n\t\treturn ret;\n\n\t/* get basic device information in one go */\n\tlockdownd_get_value(client, NULL, NULL, &root_node);\n\n\t/* verify UDID */\n\tvalue_node = plist_dict_get_item(root_node, \"UniqueDeviceID\");\n\tnode = plist_dict_get_item(info, \"Target Identifier\");\n\n\tif(plist_compare_node_value(value_node, node))\n\t\tret = 1;\n\telse {\n\t\tprintf(\"Info.plist: UniqueDeviceID does not match.\\n\");\n\t}\n\n\t/* verify SerialNumber */\n\tif (ret == 1) {\n\t\tvalue_node = plist_dict_get_item(root_node, \"SerialNumber\");\n\t\tnode = plist_dict_get_item(info, \"Serial Number\");\n\n\t\tif(plist_compare_node_value(value_node, node))\n\t\t\tret = 1;\n\t\telse {\n\t\t\tprintf(\"Info.plist: SerialNumber does not match.\\n\");\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\t/* verify ProductVersion to prevent using backup with different OS version */\n\tif (ret == 1) {\n\t\tvalue_node = plist_dict_get_item(root_node, \"ProductVersion\");\n\t\tnode = plist_dict_get_item(info, \"Product Version\");\n\n\t\tif(plist_compare_node_value(value_node, node))\n\t\t\tret = 1;\n\t\telse {\n\t\t\tprintf(\"Info.plist: ProductVersion does not match.\\n\");\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\tplist_free(root_node);\n\troot_node = NULL;\n\n\tvalue_node = NULL;\n\tnode = NULL;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Aborting backup. Backup is not compatible with the current device.\\n\""
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mobilebackup_info_update_last_backup_date",
          "args": [
            "info_plist"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "mobilebackup_info_update_last_backup_date",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
          "lines": "283-294",
          "snippet": "static void mobilebackup_info_update_last_backup_date(plist_t info_plist)\n{\n\tplist_t node = NULL;\n\n\tif (!info_plist)\n\t\treturn;\n\n\tnode = plist_dict_get_item(info_plist, \"Last Backup Date\");\n\tplist_set_date_val(node, time(NULL), 0);\n\n\tnode = NULL;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <unistd.h>",
            "#include <gcrypt.h>",
            "#include <openssl/sha.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void mobilebackup_info_update_last_backup_date(plist_t info_plist)\n{\n\tplist_t node = NULL;\n\n\tif (!info_plist)\n\t\treturn;\n\n\tnode = plist_dict_get_item(info_plist, \"Last Backup Date\");\n\tplist_set_date_val(node, time(NULL), 0);\n\n\tnode = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Could not read Info.plist\\n\""
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Reading Info.plist from backup.\\n\""
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Aborting backup. Cancelled by user.\\n\""
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdownd_service_descriptor_free",
          "args": [
            "service"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "lockdownd_service_descriptor_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/lockdown.c",
          "lines": "1522-1528",
          "snippet": "LIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_service_descriptor_free(lockdownd_service_descriptor_t service)\n{\n\tif (service)\n\t\tfree(service);\n\n\treturn LOCKDOWN_E_SUCCESS;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/userpref.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"lockdown.h\"",
            "#include \"property_list_service.h\"",
            "#include <plist/plist.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/x509.h>",
            "#include <libtasn1.h>",
            "#include <openssl/x509v3.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/pem.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/userpref.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"lockdown.h\"\n#include \"property_list_service.h\"\n#include <plist/plist.h>\n#include <gnutls/crypto.h>\n#include <gnutls/x509.h>\n#include <libtasn1.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/pem.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_service_descriptor_free(lockdownd_service_descriptor_t service)\n{\n\tif (service)\n\t\tfree(service);\n\n\treturn LOCKDOWN_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mobilebackup_client_new",
          "args": [
            "device",
            "service",
            "&mobilebackup"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "mobilebackup_client_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/mobilebackup.c",
          "lines": "63-88",
          "snippet": "LIBIMOBILEDEVICE_API mobilebackup_error_t mobilebackup_client_new(idevice_t device, lockdownd_service_descriptor_t service, mobilebackup_client_t * client)\n{\n\tif (!device || !service || service->port == 0 || !client || *client)\n\t\treturn MOBILEBACKUP_E_INVALID_ARG;\n\n\tdevice_link_service_client_t dlclient = NULL;\n\tmobilebackup_error_t ret = mobilebackup_error(device_link_service_client_new(device, service, &dlclient));\n\tif (ret != MOBILEBACKUP_E_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tmobilebackup_client_t client_loc = (mobilebackup_client_t) malloc(sizeof(struct mobilebackup_client_private));\n\tclient_loc->parent = dlclient;\n\n\t/* perform handshake */\n\tret = mobilebackup_error(device_link_service_version_exchange(dlclient, MBACKUP_VERSION_INT1, MBACKUP_VERSION_INT2));\n\tif (ret != MOBILEBACKUP_E_SUCCESS) {\n\t\tdebug_info(\"version exchange failed, error %d\", ret);\n\t\tmobilebackup_client_free(client_loc);\n\t\treturn ret;\n\t}\n\n\t*client = client_loc;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"device_link_service.h\"",
            "#include \"mobilebackup.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <plist/plist.h>"
          ],
          "macros_used": [
            "#define MBACKUP_VERSION_INT2 0",
            "#define MBACKUP_VERSION_INT1 100"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"device_link_service.h\"\n#include \"mobilebackup.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <plist/plist.h>\n\n#define MBACKUP_VERSION_INT2 0\n#define MBACKUP_VERSION_INT1 100\n\nLIBIMOBILEDEVICE_API mobilebackup_error_t mobilebackup_client_new(idevice_t device, lockdownd_service_descriptor_t service, mobilebackup_client_t * client)\n{\n\tif (!device || !service || service->port == 0 || !client || *client)\n\t\treturn MOBILEBACKUP_E_INVALID_ARG;\n\n\tdevice_link_service_client_t dlclient = NULL;\n\tmobilebackup_error_t ret = mobilebackup_error(device_link_service_client_new(device, service, &dlclient));\n\tif (ret != MOBILEBACKUP_E_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tmobilebackup_client_t client_loc = (mobilebackup_client_t) malloc(sizeof(struct mobilebackup_client_private));\n\tclient_loc->parent = dlclient;\n\n\t/* perform handshake */\n\tret = mobilebackup_error(device_link_service_version_exchange(dlclient, MBACKUP_VERSION_INT1, MBACKUP_VERSION_INT2));\n\tif (ret != MOBILEBACKUP_E_SUCCESS) {\n\t\tdebug_info(\"version exchange failed, error %d\", ret);\n\t\tmobilebackup_client_free(client_loc);\n\t\treturn ret;\n\t}\n\n\t*client = client_loc;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdownd_start_service",
          "args": [
            "client",
            "MOBILEBACKUP_SERVICE_NAME",
            "&service"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "lockdownd_start_service_with_escrow_bag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/lockdown.c",
          "lines": "1364-1367",
          "snippet": "LIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_start_service_with_escrow_bag(lockdownd_client_t client, const char *identifier, lockdownd_service_descriptor_t *service)\n{\n\treturn lockdownd_do_start_service(client, identifier, 1, service);\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/userpref.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"lockdown.h\"",
            "#include \"property_list_service.h\"",
            "#include <plist/plist.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/x509.h>",
            "#include <libtasn1.h>",
            "#include <openssl/x509v3.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/pem.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/userpref.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"lockdown.h\"\n#include \"property_list_service.h\"\n#include <plist/plist.h>\n#include <gnutls/crypto.h>\n#include <gnutls/x509.h>\n#include <libtasn1.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/pem.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_start_service_with_escrow_bag(lockdownd_client_t client, const char *identifier, lockdownd_service_descriptor_t *service)\n{\n\treturn lockdownd_do_start_service(client, identifier, 1, service);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afc_client_new",
          "args": [
            "device",
            "service",
            "&afc"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "afc_client_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "99-116",
          "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_client_new(idevice_t device, lockdownd_service_descriptor_t service, afc_client_t * client)\n{\n\tif (!device || !service || service->port == 0)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tservice_client_t parent = NULL;\n\tif (service_client_new(device, service, &parent) != SERVICE_E_SUCCESS) {\n\t\treturn AFC_E_MUX_ERROR;\n\t}\n\n\tafc_error_t err = afc_client_new_with_service_client(parent, client);\n\tif (err != AFC_E_SUCCESS) {\n\t\tservice_client_free(parent);\n\t} else {\n\t\t(*client)->free_parent = 1;\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_client_new(idevice_t device, lockdownd_service_descriptor_t service, afc_client_t * client)\n{\n\tif (!device || !service || service->port == 0)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tservice_client_t parent = NULL;\n\tif (service_client_new(device, service, &parent) != SERVICE_E_SUCCESS) {\n\t\treturn AFC_E_MUX_ERROR;\n\t}\n\n\tafc_error_t err = afc_client_new_with_service_client(parent, client);\n\tif (err != AFC_E_SUCCESS) {\n\t\tservice_client_free(parent);\n\t} else {\n\t\t(*client)->free_parent = 1;\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "np_observe_notifications",
          "args": [
            "np",
            "noties"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "np_observe_notifications",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/notification_proxy.c",
          "lines": "210-233",
          "snippet": "LIBIMOBILEDEVICE_API np_error_t np_observe_notifications(np_client_t client, const char **notification_spec)\n{\n\tint i = 0;\n\tnp_error_t res = NP_E_UNKNOWN_ERROR;\n\tconst char **notifications = notification_spec;\n\n\tif (!client) {\n\t\treturn NP_E_INVALID_ARG;\n\t}\n\n\tif (!notifications) {\n\t\treturn NP_E_INVALID_ARG;\n\t}\n\n\twhile (notifications[i]) {\n\t\tres = np_observe_notification(client, notifications[i]);\n\t\tif (res != NP_E_SUCCESS) {\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\n\treturn res;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"property_list_service.h\"",
            "#include \"notification_proxy.h\"",
            "#include <plist/plist.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"property_list_service.h\"\n#include \"notification_proxy.h\"\n#include <plist/plist.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n\nLIBIMOBILEDEVICE_API np_error_t np_observe_notifications(np_client_t client, const char **notification_spec)\n{\n\tint i = 0;\n\tnp_error_t res = NP_E_UNKNOWN_ERROR;\n\tconst char **notifications = notification_spec;\n\n\tif (!client) {\n\t\treturn NP_E_INVALID_ARG;\n\t}\n\n\tif (!notifications) {\n\t\treturn NP_E_INVALID_ARG;\n\t}\n\n\twhile (notifications[i]) {\n\t\tres = np_observe_notification(client, notifications[i]);\n\t\tif (res != NP_E_SUCCESS) {\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "np_set_notify_callback",
          "args": [
            "np",
            "notify_cb",
            "NULL"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "np_set_notify_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/notification_proxy.c",
          "lines": "339-374",
          "snippet": "LIBIMOBILEDEVICE_API np_error_t np_set_notify_callback( np_client_t client, np_notify_cb_t notify_cb, void *user_data )\n{\n\tif (!client)\n\t\treturn NP_E_INVALID_ARG;\n\n\tnp_error_t res = NP_E_UNKNOWN_ERROR;\n\n\tnp_lock(client);\n\tif (client->notifier) {\n\t\tdebug_info(\"callback already set, removing\");\n\t\tproperty_list_service_client_t parent = client->parent;\n\t\tclient->parent = NULL;\n\t\tthread_join(client->notifier);\n\t\tthread_free(client->notifier);\n\t\tclient->notifier = (thread_t)NULL;\n\t\tclient->parent = parent;\n\t}\n\n\tif (notify_cb) {\n\t\tstruct np_thread *npt = (struct np_thread*)malloc(sizeof(struct np_thread));\n\t\tif (npt) {\n\t\t\tnpt->client = client;\n\t\t\tnpt->cbfunc = notify_cb;\n\t\t\tnpt->user_data = user_data;\n\n\t\t\tif (thread_new(&client->notifier, np_notifier, npt) == 0) {\n\t\t\t\tres = NP_E_SUCCESS;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tdebug_info(\"no callback set\");\n\t}\n\tnp_unlock(client);\n\n\treturn res;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"property_list_service.h\"",
            "#include \"notification_proxy.h\"",
            "#include <plist/plist.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"property_list_service.h\"\n#include \"notification_proxy.h\"\n#include <plist/plist.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n\nLIBIMOBILEDEVICE_API np_error_t np_set_notify_callback( np_client_t client, np_notify_cb_t notify_cb, void *user_data )\n{\n\tif (!client)\n\t\treturn NP_E_INVALID_ARG;\n\n\tnp_error_t res = NP_E_UNKNOWN_ERROR;\n\n\tnp_lock(client);\n\tif (client->notifier) {\n\t\tdebug_info(\"callback already set, removing\");\n\t\tproperty_list_service_client_t parent = client->parent;\n\t\tclient->parent = NULL;\n\t\tthread_join(client->notifier);\n\t\tthread_free(client->notifier);\n\t\tclient->notifier = (thread_t)NULL;\n\t\tclient->parent = parent;\n\t}\n\n\tif (notify_cb) {\n\t\tstruct np_thread *npt = (struct np_thread*)malloc(sizeof(struct np_thread));\n\t\tif (npt) {\n\t\t\tnpt->client = client;\n\t\t\tnpt->cbfunc = notify_cb;\n\t\t\tnpt->user_data = user_data;\n\n\t\t\tif (thread_new(&client->notifier, np_notifier, npt) == 0) {\n\t\t\t\tres = NP_E_SUCCESS;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tdebug_info(\"no callback set\");\n\t}\n\tnp_unlock(client);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "np_client_new",
          "args": [
            "device",
            "service",
            "&np"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "np_client_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/notification_proxy.c",
          "lines": "89-105",
          "snippet": "LIBIMOBILEDEVICE_API np_error_t np_client_new(idevice_t device, lockdownd_service_descriptor_t service, np_client_t *client)\n{\n\tproperty_list_service_client_t plistclient = NULL;\n\tnp_error_t err = np_error(property_list_service_client_new(device, service, &plistclient));\n\tif (err != NP_E_SUCCESS) {\n\t\treturn err;\n\t}\n\n\tnp_client_t client_loc = (np_client_t) malloc(sizeof(struct np_client_private));\n\tclient_loc->parent = plistclient;\n\n\tmutex_init(&client_loc->mutex);\n\tclient_loc->notifier = (thread_t)NULL;\n\n\t*client = client_loc;\n\treturn NP_E_SUCCESS;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"property_list_service.h\"",
            "#include \"notification_proxy.h\"",
            "#include <plist/plist.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"property_list_service.h\"\n#include \"notification_proxy.h\"\n#include <plist/plist.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n\nLIBIMOBILEDEVICE_API np_error_t np_client_new(idevice_t device, lockdownd_service_descriptor_t service, np_client_t *client)\n{\n\tproperty_list_service_client_t plistclient = NULL;\n\tnp_error_t err = np_error(property_list_service_client_new(device, service, &plistclient));\n\tif (err != NP_E_SUCCESS) {\n\t\treturn err;\n\t}\n\n\tnp_client_t client_loc = (np_client_t) malloc(sizeof(struct np_client_private));\n\tclient_loc->parent = plistclient;\n\n\tmutex_init(&client_loc->mutex);\n\tclient_loc->notifier = (thread_t)NULL;\n\n\t*client = client_loc;\n\treturn NP_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ERROR: This tool is only compatible with iOS 3 or below. For newer iOS versions please use the idevicebackup2 tool.\\n\""
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "str",
            "NULL",
            "10"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_free",
          "args": [
            "node"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_string_val",
          "args": [
            "node",
            "&str"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_node_type",
          "args": [
            "node"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdownd_get_value",
          "args": [
            "client",
            "NULL",
            "\"ProductVersion\"",
            "&node"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "lockdownd_get_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/lockdown.c",
          "lines": "426-478",
          "snippet": "LIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_get_value(lockdownd_client_t client, const char *domain, const char *key, plist_t *value)\n{\n\tif (!client)\n\t\treturn LOCKDOWN_E_INVALID_ARG;\n\n\tplist_t dict = NULL;\n\tlockdownd_error_t ret = LOCKDOWN_E_UNKNOWN_ERROR;\n\n\t/* setup request plist */\n\tdict = plist_new_dict();\n\tplist_dict_add_label(dict, client->label);\n\tif (domain) {\n\t\tplist_dict_set_item(dict,\"Domain\", plist_new_string(domain));\n\t}\n\tif (key) {\n\t\tplist_dict_set_item(dict,\"Key\", plist_new_string(key));\n\t}\n\tplist_dict_set_item(dict,\"Request\", plist_new_string(\"GetValue\"));\n\n\t/* send to device */\n\tret = lockdownd_send(client, dict);\n\n\tplist_free(dict);\n\tdict = NULL;\n\n\tif (ret != LOCKDOWN_E_SUCCESS)\n\t\treturn ret;\n\n\t/* Now get device's answer */\n\tret = lockdownd_receive(client, &dict);\n\tif (ret != LOCKDOWN_E_SUCCESS)\n\t\treturn ret;\n\n\tret = lockdown_check_result(dict, \"GetValue\");\n\tif (ret == LOCKDOWN_E_SUCCESS) {\n\t\tdebug_info(\"success\");\n\t}\n\n\tif (ret != LOCKDOWN_E_SUCCESS) {\n\t\tplist_free(dict);\n\t\treturn ret;\n\t}\n\n\tplist_t value_node = plist_dict_get_item(dict, \"Value\");\n\n\tif (value_node) {\n\t\tdebug_info(\"has a value\");\n\t\t*value = plist_copy(value_node);\n\t}\n\n\tplist_free(dict);\n\treturn ret;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/userpref.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"lockdown.h\"",
            "#include \"property_list_service.h\"",
            "#include <plist/plist.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/x509.h>",
            "#include <libtasn1.h>",
            "#include <openssl/x509v3.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/pem.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/userpref.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"lockdown.h\"\n#include \"property_list_service.h\"\n#include <plist/plist.h>\n#include <gnutls/crypto.h>\n#include <gnutls/x509.h>\n#include <libtasn1.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/pem.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_get_value(lockdownd_client_t client, const char *domain, const char *key, plist_t *value)\n{\n\tif (!client)\n\t\treturn LOCKDOWN_E_INVALID_ARG;\n\n\tplist_t dict = NULL;\n\tlockdownd_error_t ret = LOCKDOWN_E_UNKNOWN_ERROR;\n\n\t/* setup request plist */\n\tdict = plist_new_dict();\n\tplist_dict_add_label(dict, client->label);\n\tif (domain) {\n\t\tplist_dict_set_item(dict,\"Domain\", plist_new_string(domain));\n\t}\n\tif (key) {\n\t\tplist_dict_set_item(dict,\"Key\", plist_new_string(key));\n\t}\n\tplist_dict_set_item(dict,\"Request\", plist_new_string(\"GetValue\"));\n\n\t/* send to device */\n\tret = lockdownd_send(client, dict);\n\n\tplist_free(dict);\n\tdict = NULL;\n\n\tif (ret != LOCKDOWN_E_SUCCESS)\n\t\treturn ret;\n\n\t/* Now get device's answer */\n\tret = lockdownd_receive(client, &dict);\n\tif (ret != LOCKDOWN_E_SUCCESS)\n\t\treturn ret;\n\n\tret = lockdown_check_result(dict, \"GetValue\");\n\tif (ret == LOCKDOWN_E_SUCCESS) {\n\t\tdebug_info(\"success\");\n\t}\n\n\tif (ret != LOCKDOWN_E_SUCCESS) {\n\t\tplist_free(dict);\n\t\treturn ret;\n\t}\n\n\tplist_t value_node = plist_dict_get_item(dict, \"Value\");\n\n\tif (value_node) {\n\t\tdebug_info(\"has a value\");\n\t\t*value = plist_copy(value_node);\n\t}\n\n\tplist_free(dict);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdownd_client_new_with_handshake",
          "args": [
            "device",
            "&client",
            "\"idevicebackup\""
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "lockdownd_client_new_with_handshake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/lockdown.c",
          "lines": "671-753",
          "snippet": "LIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_client_new_with_handshake(idevice_t device, lockdownd_client_t *client, const char *label)\n{\n\tif (!client)\n\t\treturn LOCKDOWN_E_INVALID_ARG;\n\n\tlockdownd_error_t ret = LOCKDOWN_E_SUCCESS;\n\tlockdownd_client_t client_loc = NULL;\n\tplist_t pair_record = NULL;\n\tchar *host_id = NULL;\n\tchar *type = NULL;\n\n\tret = lockdownd_client_new(device, &client_loc, label);\n\tif (LOCKDOWN_E_SUCCESS != ret) {\n\t\tdebug_info(\"failed to create lockdownd client.\");\n\t\treturn ret;\n\t}\n\n\t/* perform handshake */\n\tif (LOCKDOWN_E_SUCCESS != lockdownd_query_type(client_loc, &type)) {\n\t\tdebug_info(\"QueryType failed in the lockdownd client.\");\n\t\tret = LOCKDOWN_E_NOT_ENOUGH_DATA;\n\t} else {\n\t\tif (strcmp(\"com.apple.mobile.lockdown\", type)) {\n\t\t\tdebug_info(\"Warning QueryType request returned \\\"%s\\\".\", type);\n\t\t}\n\t}\n\tfree(type);\n\n\tuserpref_read_pair_record(client_loc->udid, &pair_record);\n\tif (pair_record) {\n\t\tpair_record_get_host_id(pair_record, &host_id);\n\t}\n\tif (LOCKDOWN_E_SUCCESS == ret && !host_id) {\n\t\tret = LOCKDOWN_E_INVALID_CONF;\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS == ret && !pair_record) {\n\t\t/* attempt pairing */\n\t\tret = lockdownd_pair(client_loc, NULL);\n\t}\n\n\tplist_free(pair_record);\n\tpair_record = NULL;\n\n\t/* in any case, we need to validate pairing to receive trusted host status */\n\tret = lockdownd_validate_pair(client_loc, NULL);\n\n\t/* if not paired yet, let's do it now */\n\tif (LOCKDOWN_E_INVALID_HOST_ID == ret) {\n\t\tfree(host_id);\n\t\thost_id = NULL;\n\t\tret = lockdownd_pair(client_loc, NULL);\n\t\tif (LOCKDOWN_E_SUCCESS == ret) {\n\t\t\tret = lockdownd_validate_pair(client_loc, NULL);\n\t\t} else if (LOCKDOWN_E_PAIRING_DIALOG_RESPONSE_PENDING == ret) {\n\t\t\tdebug_info(\"Device shows the pairing dialog.\");\n\t\t}\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS == ret) {\n\t\tif (!host_id) {\n\t\t\tuserpref_read_pair_record(client_loc->udid, &pair_record);\n\t\t\tif (pair_record) {\n\t\t\t\tpair_record_get_host_id(pair_record, &host_id);\n\t\t\t\tplist_free(pair_record);\n\t\t\t}\n\t\t}\n\n\t\tret = lockdownd_start_session(client_loc, host_id, NULL, NULL);\n\t\tif (LOCKDOWN_E_SUCCESS != ret) {\n\t\t\tdebug_info(\"Session opening failed.\");\n\t\t}\n\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS == ret) {\n\t\t*client = client_loc;\n\t} else {\n\t\tlockdownd_client_free(client_loc);\n\t}\n\tfree(host_id);\n\treturn ret;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/userpref.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"lockdown.h\"",
            "#include \"property_list_service.h\"",
            "#include <plist/plist.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/x509.h>",
            "#include <libtasn1.h>",
            "#include <openssl/x509v3.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/pem.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/userpref.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"lockdown.h\"\n#include \"property_list_service.h\"\n#include <plist/plist.h>\n#include <gnutls/crypto.h>\n#include <gnutls/x509.h>\n#include <libtasn1.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/pem.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_client_new_with_handshake(idevice_t device, lockdownd_client_t *client, const char *label)\n{\n\tif (!client)\n\t\treturn LOCKDOWN_E_INVALID_ARG;\n\n\tlockdownd_error_t ret = LOCKDOWN_E_SUCCESS;\n\tlockdownd_client_t client_loc = NULL;\n\tplist_t pair_record = NULL;\n\tchar *host_id = NULL;\n\tchar *type = NULL;\n\n\tret = lockdownd_client_new(device, &client_loc, label);\n\tif (LOCKDOWN_E_SUCCESS != ret) {\n\t\tdebug_info(\"failed to create lockdownd client.\");\n\t\treturn ret;\n\t}\n\n\t/* perform handshake */\n\tif (LOCKDOWN_E_SUCCESS != lockdownd_query_type(client_loc, &type)) {\n\t\tdebug_info(\"QueryType failed in the lockdownd client.\");\n\t\tret = LOCKDOWN_E_NOT_ENOUGH_DATA;\n\t} else {\n\t\tif (strcmp(\"com.apple.mobile.lockdown\", type)) {\n\t\t\tdebug_info(\"Warning QueryType request returned \\\"%s\\\".\", type);\n\t\t}\n\t}\n\tfree(type);\n\n\tuserpref_read_pair_record(client_loc->udid, &pair_record);\n\tif (pair_record) {\n\t\tpair_record_get_host_id(pair_record, &host_id);\n\t}\n\tif (LOCKDOWN_E_SUCCESS == ret && !host_id) {\n\t\tret = LOCKDOWN_E_INVALID_CONF;\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS == ret && !pair_record) {\n\t\t/* attempt pairing */\n\t\tret = lockdownd_pair(client_loc, NULL);\n\t}\n\n\tplist_free(pair_record);\n\tpair_record = NULL;\n\n\t/* in any case, we need to validate pairing to receive trusted host status */\n\tret = lockdownd_validate_pair(client_loc, NULL);\n\n\t/* if not paired yet, let's do it now */\n\tif (LOCKDOWN_E_INVALID_HOST_ID == ret) {\n\t\tfree(host_id);\n\t\thost_id = NULL;\n\t\tret = lockdownd_pair(client_loc, NULL);\n\t\tif (LOCKDOWN_E_SUCCESS == ret) {\n\t\t\tret = lockdownd_validate_pair(client_loc, NULL);\n\t\t} else if (LOCKDOWN_E_PAIRING_DIALOG_RESPONSE_PENDING == ret) {\n\t\t\tdebug_info(\"Device shows the pairing dialog.\");\n\t\t}\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS == ret) {\n\t\tif (!host_id) {\n\t\t\tuserpref_read_pair_record(client_loc->udid, &pair_record);\n\t\t\tif (pair_record) {\n\t\t\t\tpair_record_get_host_id(pair_record, &host_id);\n\t\t\t\tplist_free(pair_record);\n\t\t\t}\n\t\t}\n\n\t\tret = lockdownd_start_session(client_loc, host_id, NULL, NULL);\n\t\tif (LOCKDOWN_E_SUCCESS != ret) {\n\t\t\tdebug_info(\"Session opening failed.\");\n\t\t}\n\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS == ret) {\n\t\t*client = client_loc;\n\t} else {\n\t\tlockdownd_client_free(client_loc);\n\t}\n\tfree(host_id);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"No device found, is it plugged in?\\n\""
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idevice_new",
          "args": [
            "&device",
            "NULL"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "idevice_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
          "lines": "230-245",
          "snippet": "LIBIMOBILEDEVICE_API idevice_error_t idevice_new(idevice_t * device, const char *udid)\n{\n\tusbmuxd_device_info_t muxdev;\n\tint res = usbmuxd_get_device_by_udid(udid, &muxdev);\n\tif (res > 0) {\n\t\tidevice_t dev = (idevice_t) malloc(sizeof(struct idevice_private));\n\t\tdev->udid = strdup(muxdev.udid);\n\t\tdev->conn_type = CONNECTION_USBMUXD;\n\t\tdev->conn_data = (void*)(long)muxdev.handle;\n\t\t*device = dev;\n\t\treturn IDEVICE_E_SUCCESS;\n\t}\n\t/* other connection types could follow here */\n\n\treturn IDEVICE_E_NO_DEVICE;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"common/thread.h\"",
            "#include \"common/userpref.h\"",
            "#include \"idevice.h\"",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <usbmuxd.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "LIBIMOBILEDEVICE_API idevice_error_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nLIBIMOBILEDEVICE_API idevice_error_t idevice_new(idevice_t * device, const char *udid)\n{\n\tusbmuxd_device_info_t muxdev;\n\tint res = usbmuxd_get_device_by_udid(udid, &muxdev);\n\tif (res > 0) {\n\t\tidevice_t dev = (idevice_t) malloc(sizeof(struct idevice_private));\n\t\tdev->udid = strdup(muxdev.udid);\n\t\tdev->conn_type = CONNECTION_USBMUXD;\n\t\tdev->conn_data = (void*)(long)muxdev.handle;\n\t\t*device = dev;\n\t\treturn IDEVICE_E_SUCCESS;\n\t}\n\t/* other connection types could follow here */\n\n\treturn IDEVICE_E_NO_DEVICE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_usage",
          "args": [
            "argc",
            "argv"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "print_usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
          "lines": "663-678",
          "snippet": "static void print_usage(int argc, char **argv)\n{\n\tchar *name = NULL;\n\tname = strrchr(argv[0], '/');\n\tprintf(\"Usage: %s [OPTIONS] CMD [DIRECTORY]\\n\", (name ? name + 1: argv[0]));\n\tprintf(\"Create or restore backup from the current or specified directory.\\n\\n\");\n\tprintf(\"commands:\\n\");\n\tprintf(\"  backup\\tSaves a device backup into DIRECTORY\\n\");\n\tprintf(\"  restore\\tRestores a device backup from DIRECTORY.\\n\\n\");\n\tprintf(\"options:\\n\");\n\tprintf(\"  -d, --debug\\t\\tenable communication debugging\\n\");\n\tprintf(\"  -u, --udid UDID\\ttarget specific device by its 40-digit device UDID\\n\");\n\tprintf(\"  -h, --help\\t\\tprints usage information\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"Homepage: <\" PACKAGE_URL \">\\n\");\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <unistd.h>",
            "#include <gcrypt.h>",
            "#include <openssl/sha.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static idevice_t device = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic idevice_t device = NULL;\n\nstatic void print_usage(int argc, char **argv)\n{\n\tchar *name = NULL;\n\tname = strrchr(argv[0], '/');\n\tprintf(\"Usage: %s [OPTIONS] CMD [DIRECTORY]\\n\", (name ? name + 1: argv[0]));\n\tprintf(\"Create or restore backup from the current or specified directory.\\n\\n\");\n\tprintf(\"commands:\\n\");\n\tprintf(\"  backup\\tSaves a device backup into DIRECTORY\\n\");\n\tprintf(\"  restore\\tRestores a device backup from DIRECTORY.\\n\\n\");\n\tprintf(\"options:\\n\");\n\tprintf(\"  -d, --debug\\t\\tenable communication debugging\\n\");\n\tprintf(\"  -u, --udid UDID\\ttarget specific device by its 40-digit device UDID\\n\");\n\tprintf(\"  -h, --help\\t\\tprints usage information\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"Homepage: <\" PACKAGE_URL \">\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"No target backup directory specified.\\n\""
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"No command specified.\\n\""
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[i]"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "argv[i]"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idevice_set_debug_level",
          "args": [
            "1"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "idevice_set_debug_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
          "lines": "225-228",
          "snippet": "LIBIMOBILEDEVICE_API void idevice_set_debug_level(int level)\n{\n\tinternal_set_debug_level(level);\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"common/thread.h\"",
            "#include \"common/userpref.h\"",
            "#include \"idevice.h\"",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <usbmuxd.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API void idevice_set_debug_level(int level)\n{\n\tinternal_set_debug_level(level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGPIPE",
            "SIG_IGN"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGQUIT",
            "clean_exit"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGTERM",
            "clean_exit"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGINT",
            "clean_exit"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\n#define LOCK_WAIT 200000\n#define LOCK_ATTEMPTS 50\n#define NP_SERVICE_NAME \"com.apple.mobile.notification_proxy\"\n#define MOBILEBACKUP_SERVICE_NAME \"com.apple.mobilebackup\"\n\nstatic mobilebackup_client_t mobilebackup = NULL;\nstatic lockdownd_client_t client = NULL;\nstatic idevice_t device = NULL;\nstatic int quit_flag = 0;\n\nint main(int argc, char *argv[])\n{\n\tidevice_error_t ret = IDEVICE_E_UNKNOWN_ERROR;\n\tlockdownd_error_t ldret = LOCKDOWN_E_UNKNOWN_ERROR;\n\tint i;\n\tchar* udid = NULL;\n\tlockdownd_service_descriptor_t service = NULL;\n\tint cmd = -1;\n\tint is_full_backup = 0;\n\tchar *backup_directory = NULL;\n\tstruct stat st;\n\tplist_t node = NULL;\n\tplist_t node_tmp = NULL;\n\tplist_t manifest_plist = NULL;\n\tplist_t info_plist = NULL;\n\tchar *buffer = NULL;\n\tchar *file_path = NULL;\n\tuint64_t length = 0;\n\tuint64_t backup_total_size = 0;\n\tenum device_link_file_status_t file_status = DEVICE_LINK_FILE_STATUS_NONE;\n\tuint64_t c = 0;\n\n\t/* we need to exit cleanly on running backups and restores or we cause havok */\n\tsignal(SIGINT, clean_exit);\n\tsignal(SIGTERM, clean_exit);\n#ifndef WIN32\n\tsignal(SIGQUIT, clean_exit);\n\tsignal(SIGPIPE, SIG_IGN);\n#endif\n\n\t/* parse cmdline args */\n\tfor (i = 1; i < argc; i++) {\n\t\tif (!strcmp(argv[i], \"-d\") || !strcmp(argv[i], \"--debug\")) {\n\t\t\tidevice_set_debug_level(1);\n\t\t\tcontinue;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"-u\") || !strcmp(argv[i], \"--udid\")) {\n\t\t\ti++;\n\t\t\tif (!argv[i] || (strlen(argv[i]) != 40)) {\n\t\t\t\tprint_usage(argc, argv);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tudid = strdup(argv[i]);\n\t\t\tcontinue;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"-h\") || !strcmp(argv[i], \"--help\")) {\n\t\t\tprint_usage(argc, argv);\n\t\t\treturn 0;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"backup\")) {\n\t\t\tcmd = CMD_BACKUP;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"restore\")) {\n\t\t\tcmd = CMD_RESTORE;\n\t\t}\n\t\telse if (backup_directory == NULL) {\n\t\t\tbackup_directory = argv[i];\n\t\t}\n\t\telse {\n\t\t\tprint_usage(argc, argv);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* verify options */\n\tif (cmd == -1) {\n\t\tprintf(\"No command specified.\\n\");\n\t\tprint_usage(argc, argv);\n\t\treturn -1;\n\t}\n\n\tif (backup_directory == NULL) {\n\t\tprintf(\"No target backup directory specified.\\n\");\n\t\tprint_usage(argc, argv);\n\t\treturn -1;\n\t}\n\n\t/* verify if passed backup directory exists */\n\tif (stat(backup_directory, &st) != 0) {\n\t\tprintf(\"ERROR: Backup directory \\\"%s\\\" does not exist!\\n\", backup_directory);\n\t\treturn -1;\n\t}\n\n\t/* restore directory must contain an Info.plist */\n\tchar *info_path = mobilebackup_build_path(backup_directory, \"Info\", \".plist\");\n\tif (cmd == CMD_RESTORE) {\n\t\tif (stat(info_path, &st) != 0) {\n\t\t\tfree(info_path);\n\t\t\tprintf(\"ERROR: Backup directory \\\"%s\\\" is invalid. No Info.plist found.\\n\", backup_directory);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tprintf(\"Backup directory is \\\"%s\\\"\\n\", backup_directory);\n\n\tif (udid) {\n\t\tret = idevice_new(&device, udid);\n\t\tif (ret != IDEVICE_E_SUCCESS) {\n\t\t\tprintf(\"No device found with udid %s, is it plugged in?\\n\", udid);\n\t\t\treturn -1;\n\t\t}\n\t}\n\telse\n\t{\n\t\tret = idevice_new(&device, NULL);\n\t\tif (ret != IDEVICE_E_SUCCESS) {\n\t\t\tprintf(\"No device found, is it plugged in?\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS != (ldret = lockdownd_client_new_with_handshake(device, &client, \"idevicebackup\"))) {\n\t\tprintf(\"ERROR: Could not connect to lockdownd, error code %d\\n\", ldret);\n\t\tidevice_free(device);\n\t\treturn -1;\n\t}\n\n\tnode = NULL;\n\tlockdownd_get_value(client, NULL, \"ProductVersion\", &node);\n\tif (node) {\n\t\tchar* str = NULL;\n\t\tif (plist_get_node_type(node) == PLIST_STRING) {\n\t\t\tplist_get_string_val(node, &str);\n\t\t}\n\t\tplist_free(node);\n\t\tnode = NULL;\n\t\tif (str) {\n\t\t\tint maj = strtol(str, NULL, 10);\n\t\t\tfree(str);\n\t\t\tif (maj > 3) {\n\t\t\t\tprintf(\"ERROR: This tool is only compatible with iOS 3 or below. For newer iOS versions please use the idevicebackup2 tool.\\n\");\n\t\t\t\tlockdownd_client_free(client);\n\t\t\t\tidevice_free(device);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* start notification_proxy */\n\tnp_client_t np = NULL;\n\tldret = lockdownd_start_service(client, NP_SERVICE_NAME, &service);\n\tif ((ldret == LOCKDOWN_E_SUCCESS) && service && service->port) {\n\t\tnp_client_new(device, service, &np);\n\t\tnp_set_notify_callback(np, notify_cb, NULL);\n\t\tconst char *noties[5] = {\n\t\t\tNP_SYNC_CANCEL_REQUEST,\n\t\t\tNP_SYNC_SUSPEND_REQUEST,\n\t\t\tNP_SYNC_RESUME_REQUEST,\n\t\t\tNP_BACKUP_DOMAIN_CHANGED,\n\t\t\tNULL\n\t\t};\n\t\tnp_observe_notifications(np, noties);\n\t} else {\n\t\tprintf(\"ERROR: Could not start service %s.\\n\", NP_SERVICE_NAME);\n\t}\n\n\tafc_client_t afc = NULL;\n\tif (cmd == CMD_BACKUP) {\n\t\t/* start AFC, we need this for the lock file */\n\t\tservice->port = 0;\n\t\tservice->ssl_enabled = 0;\n\t\tldret = lockdownd_start_service(client, \"com.apple.afc\", &service);\n\t\tif ((ldret == LOCKDOWN_E_SUCCESS) && service->port) {\n\t\t\tafc_client_new(device, service, &afc);\n\t\t}\n\t}\n\n\tif (service) {\n\t\tlockdownd_service_descriptor_free(service);\n\t\tservice = NULL;\n\t}\n\n\t/* start mobilebackup service and retrieve port */\n\tldret = lockdownd_start_service(client, MOBILEBACKUP_SERVICE_NAME, &service);\n\tif ((ldret == LOCKDOWN_E_SUCCESS) && service && service->port) {\n\t\tprintf(\"Started \\\"%s\\\" service on port %d.\\n\", MOBILEBACKUP_SERVICE_NAME, service->port);\n\t\tmobilebackup_client_new(device, service, &mobilebackup);\n\n\t\tif (service) {\n\t\t\tlockdownd_service_descriptor_free(service);\n\t\t\tservice = NULL;\n\t\t}\n\n\t\t/* check abort conditions */\n\t\tif (quit_flag > 0) {\n\t\t\tprintf(\"Aborting backup. Cancelled by user.\\n\");\n\t\t\tcmd = CMD_LEAVE;\n\t\t}\n\n\t\t/* verify existing Info.plist */\n\t\tif (stat(info_path, &st) == 0) {\n\t\t\tprintf(\"Reading Info.plist from backup.\\n\");\n\t\t\tplist_read_from_filename(&info_plist, info_path);\n\n\t\t\tif (!info_plist) {\n\t\t\t\tprintf(\"Could not read Info.plist\\n\");\n\t\t\t\tis_full_backup = 1;\n\t\t\t}\n\t\t\tif (info_plist && (cmd == CMD_BACKUP)) {\n\t\t\t\tif (mobilebackup_info_is_current_device(info_plist)) {\n\t\t\t\t\t/* update the last backup time within Info.plist */\n\t\t\t\t\tmobilebackup_info_update_last_backup_date(info_plist);\n\t\t\t\t\tremove(info_path);\n\t\t\t\t\tplist_write_to_filename(info_plist, info_path, PLIST_FORMAT_XML);\n\t\t\t\t} else {\n\t\t\t\t\tprintf(\"Aborting backup. Backup is not compatible with the current device.\\n\");\n\t\t\t\t\tcmd = CMD_LEAVE;\n\t\t\t\t}\n\t\t\t} else if (info_plist && (cmd == CMD_RESTORE)) {\n\t\t\t\tif (!mobilebackup_info_is_current_device(info_plist)) {\n\t\t\t\t\tprintf(\"Aborting restore. Backup data is not compatible with the current device.\\n\");\n\t\t\t\t\tcmd = CMD_LEAVE;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (cmd == CMD_RESTORE) {\n\t\t\t\tprintf(\"Aborting restore. Info.plist is missing.\\n\");\n\t\t\t\tcmd = CMD_LEAVE;\n\t\t\t} else {\n\t\t\t\tis_full_backup = 1;\n\t\t\t}\n\t\t}\n\n\t\tuint64_t lockfile = 0;\n\t\tif (cmd == CMD_BACKUP) {\n\t\t\tdo_post_notification(NP_SYNC_WILL_START);\n\t\t\tafc_file_open(afc, \"/com.apple.itunes.lock_sync\", AFC_FOPEN_RW, &lockfile);\n\t\t}\n\t\tif (lockfile) {\n\t\t\tafc_error_t aerr;\n\t\t\tdo_post_notification(NP_SYNC_LOCK_REQUEST);\n\t\t\tfor (i = 0; i < LOCK_ATTEMPTS; i++) {\n\t\t\t\taerr = afc_file_lock(afc, lockfile, AFC_LOCK_EX);\n\t\t\t\tif (aerr == AFC_E_SUCCESS) {\n\t\t\t\t\tdo_post_notification(NP_SYNC_DID_START);\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (aerr == AFC_E_OP_WOULD_BLOCK) {\n\t\t\t\t\tusleep(LOCK_WAIT);\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"ERROR: could not lock file! error code: %d\\n\", aerr);\n\t\t\t\t\tafc_file_close(afc, lockfile);\n\t\t\t\t\tlockfile = 0;\n\t\t\t\t\tcmd = CMD_LEAVE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == LOCK_ATTEMPTS) {\n\t\t\t\tfprintf(stderr, \"ERROR: timeout while locking for sync\\n\");\n\t\t\t\tafc_file_close(afc, lockfile);\n\t\t\t\tlockfile = 0;\n\t\t\t\tcmd = CMD_LEAVE;\n\t\t\t}\n\t\t}\n\n\t\tmobilebackup_error_t err;\n\n\t\t/* Manifest.plist (backup manifest (backup state)) */\n\t\tchar *manifest_path = mobilebackup_build_path(backup_directory, \"Manifest\", \".plist\");\n\n\t\tswitch(cmd) {\n\t\t\tcase CMD_BACKUP:\n\t\t\tprintf(\"Starting backup...\\n\");\n\t\t\t/* TODO: check domain com.apple.mobile.backup key RequiresEncrypt and WillEncrypt with lockdown */\n\t\t\t/* TODO: verify battery on AC enough battery remaining */\n\n\t\t\t/* read the last Manifest.plist */\n\t\t\tif (!is_full_backup) {\n\t\t\t\tprintf(\"Reading existing Manifest.\\n\");\n\t\t\t\tplist_read_from_filename(&manifest_plist, manifest_path);\n\t\t\t\tif (!manifest_plist) {\n\t\t\t\t\tprintf(\"Could not read Manifest.plist, switching to full backup mode.\\n\");\n\t\t\t\t\tis_full_backup = 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Info.plist (Device infos, IC-Info.sidb, photos, app_ids, iTunesPrefs) */\n\n\t\t\t/* create new Info.plist on new backups */\n\t\t\tif (is_full_backup) {\n\t\t\t\tif (info_plist) {\n\t\t\t\t\tplist_free(info_plist);\n\t\t\t\t\tinfo_plist = NULL;\n\t\t\t\t}\n\t\t\t\tremove(info_path);\n\t\t\t\tprintf(\"Creating Info.plist for new backup.\\n\");\n\t\t\t\tinfo_plist = mobilebackup_factory_info_plist_new(udid);\n\t\t\t\tplist_write_to_filename(info_plist, info_path, PLIST_FORMAT_XML);\n\t\t\t}\n\t\t\tfree(info_path);\n\n\t\t\tplist_free(info_plist);\n\t\t\tinfo_plist = NULL;\n\n\t\t\t/* close down the lockdown connection as it is no longer needed */\n\t\t\tif (client) {\n\t\t\t\tlockdownd_client_free(client);\n\t\t\t\tclient = NULL;\n\t\t\t}\n\n\t\t\t/* create Status.plist with failed status for now */\n\t\t\tmobilebackup_write_status(backup_directory, 0);\n\n\t\t\t/* request backup from device with manifest from last backup */\n\t\t\tprintf(\"Requesting backup from device...\\n\");\n\n\t\t\terr = mobilebackup_request_backup(mobilebackup, manifest_plist, \"/\", \"1.6\");\n\t\t\tif (err == MOBILEBACKUP_E_SUCCESS) {\n\t\t\t\tif (is_full_backup)\n\t\t\t\t\tprintf(\"Full backup mode.\\n\");\n\t\t\t\telse\n\t\t\t\t\tprintf(\"Incremental backup mode.\\n\");\n\t\t\t\tprintf(\"Please wait. Device is preparing backup data...\\n\");\n\t\t\t} else {\n\t\t\t\tif (err == MOBILEBACKUP_E_BAD_VERSION) {\n\t\t\t\t\tprintf(\"ERROR: Could not start backup process: backup protocol version mismatch!\\n\");\n\t\t\t\t} else if (err == MOBILEBACKUP_E_REPLY_NOT_OK) {\n\t\t\t\t\tprintf(\"ERROR: Could not start backup process: device refused to start the backup process.\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tprintf(\"ERROR: Could not start backup process: unspecified error occured\\n\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* reset backup status */\n\t\t\tint backup_ok = 0;\n\t\t\tplist_t message = NULL;\n\n\t\t\t/* receive and save DLSendFile files and metadata, ACK each */\n\t\t\tuint64_t file_size = 0;\n\t\t\tuint64_t file_size_current = 0;\n\t\t\tint file_index = 0;\n\t\t\tint hunk_index = 0;\n\t\t\tuint64_t backup_real_size = 0;\n\t\t\tchar *file_ext = NULL;\n\t\t\tchar *filename_mdinfo = NULL;\n\t\t\tchar *filename_mddata = NULL;\n\t\t\tchar *filename_source = NULL;\n\t\t\tchar *format_size = NULL;\n\t\t\tint is_manifest = 0;\n\t\t\tuint8_t b = 0;\n\n\t\t\t/* process series of DLSendFile messages */\n\t\t\tdo {\n\t\t\t\tmobilebackup_receive(mobilebackup, &message);\n\t\t\t\tif (!message) {\n\t\t\t\t\tprintf(\"Device is not ready yet. Going to try again in 2 seconds...\\n\");\n\t\t\t\t\tsleep(2);\n\t\t\t\t\tgoto files_out;\n\t\t\t\t}\n\n\t\t\t\tnode = plist_array_get_item(message, 0);\n\n\t\t\t\t/* get out if we don't get a DLSendFile */\n\t\t\t\tif (plist_strcmp(node, \"DLSendFile\"))\n\t\t\t\t\tbreak;\n\n\t\t\t\tnode_tmp = plist_array_get_item(message, 2);\n\n\t\t\t\t/* first message hunk contains total backup size */\n\t\t\t\tif ((hunk_index == 0) && (file_index == 0)) {\n\t\t\t\t\tnode = plist_dict_get_item(node_tmp, \"BackupTotalSizeKey\");\n\t\t\t\t\tif (node) {\n\t\t\t\t\t\tplist_get_uint_val(node, &backup_total_size);\n\t\t\t\t\t\tformat_size = string_format_size(backup_total_size);\n\t\t\t\t\t\tprintf(\"Backup data requires %s on the disk.\\n\", format_size);\n\t\t\t\t\t\tfree(format_size);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* check DLFileStatusKey (codes: 1 = Hunk, 2 = Last Hunk) */\n\t\t\t\tnode = plist_dict_get_item(node_tmp, \"DLFileStatusKey\");\n\t\t\t\tplist_get_uint_val(node, &c);\n\t\t\t\tfile_status = c;\n\n\t\t\t\t/* get source filename */\n\t\t\t\tnode = plist_dict_get_item(node_tmp, \"BackupManifestKey\");\n\t\t\t\tb = 0;\n\t\t\t\tif (node) {\n\t\t\t\t\tplist_get_bool_val(node, &b);\n\t\t\t\t}\n\t\t\t\tis_manifest = (b == 1) ? 1 : 0;\n\n\t\t\t\tif ((hunk_index == 0) && (!is_manifest)) {\n\t\t\t\t\t/* get source filename */\n\t\t\t\t\tnode = plist_dict_get_item(node_tmp, \"DLFileSource\");\n\t\t\t\t\tplist_get_string_val(node, &filename_source);\n\n\t\t\t\t\t/* increase received size */\n\t\t\t\t\tnode = plist_dict_get_item(node_tmp, \"DLFileAttributesKey\");\n\t\t\t\t\tnode = plist_dict_get_item(node, \"FileSize\");\n\t\t\t\t\tplist_get_uint_val(node, &file_size);\n\t\t\t\t\tbackup_real_size += file_size;\n\n\t\t\t\t\tformat_size = string_format_size(backup_real_size);\n\t\t\t\t\tprintf(\"(%s\", format_size);\n\t\t\t\t\tfree(format_size);\n\n\t\t\t\t\tformat_size = string_format_size(backup_total_size);\n\t\t\t\t\tprintf(\"/%s): \", format_size);\n\t\t\t\t\tfree(format_size);\n\n\t\t\t\t\tformat_size = string_format_size(file_size);\n\t\t\t\t\tprintf(\"Receiving file %s (%s)... \\n\", filename_source, format_size);\n\t\t\t\t\tfree(format_size);\n\n\t\t\t\t\tif (filename_source)\n\t\t\t\t\t\tfree(filename_source);\n\t\t\t\t}\n\n\t\t\t\t/* check if we completed a file */\n\t\t\t\tif ((file_status == DEVICE_LINK_FILE_STATUS_LAST_HUNK) && (!is_manifest)) {\n\t\t\t\t\t/* save <hash>.mdinfo */\n\t\t\t\t\tnode = plist_dict_get_item(node_tmp, \"BackupFileInfo\");\n\t\t\t\t\tif (node) {\n\t\t\t\t\t\tnode = plist_dict_get_item(node_tmp, \"DLFileDest\");\n\t\t\t\t\t\tplist_get_string_val(node, &file_path);\n\n\t\t\t\t\t\tfilename_mdinfo = mobilebackup_build_path(backup_directory, file_path, \".mdinfo\");\n\n\t\t\t\t\t\t/* remove any existing file */\n\t\t\t\t\t\tif (stat(filename_mdinfo, &st) == 0)\n\t\t\t\t\t\t\tremove(filename_mdinfo);\n\n\t\t\t\t\t\tnode = plist_dict_get_item(node_tmp, \"BackupFileInfo\");\n\t\t\t\t\t\tplist_write_to_filename(node, filename_mdinfo, PLIST_FORMAT_BINARY);\n\n\t\t\t\t\t\tfree(filename_mdinfo);\n\t\t\t\t\t}\n\n\t\t\t\t\tfile_index++;\n\t\t\t\t}\n\n\t\t\t\t/* save <hash>.mddata */\n\t\t\t\tnode = plist_dict_get_item(node_tmp, \"BackupFileInfo\");\n\t\t\t\tif (node_tmp) {\n\t\t\t\t\tnode = plist_dict_get_item(node_tmp, \"DLFileDest\");\n\t\t\t\t\tplist_get_string_val(node, &file_path);\n\n\t\t\t\t\tfilename_mddata = mobilebackup_build_path(backup_directory, file_path, is_manifest ? NULL: \".mddata\");\n\n\t\t\t\t\t/* if this is the first hunk, remove any existing file */\n\t\t\t\t\tif ((hunk_index == 0) && (stat(filename_mddata, &st) == 0))\n\t\t\t\t\t\tremove(filename_mddata);\n\n\t\t\t\t\t/* get file data hunk */\n\t\t\t\t\tnode_tmp = plist_array_get_item(message, 1);\n\t\t\t\t\tplist_get_data_val(node_tmp, &buffer, &length);\n\n\t\t\t\t\tbuffer_write_to_filename(filename_mddata, buffer, length);\n\t\t\t\t\tif (!is_manifest)\n\t\t\t\t\t\tfile_size_current += length;\n\n\t\t\t\t\t/* activate currently sent manifest */\n\t\t\t\t\tif ((file_status == DEVICE_LINK_FILE_STATUS_LAST_HUNK) && (is_manifest)) {\n\t\t\t\t\t\trename(filename_mddata, manifest_path);\n\t\t\t\t\t}\n\n\t\t\t\t\tfree(buffer);\n\t\t\t\t\tbuffer = NULL;\n\n\t\t\t\t\tfree(filename_mddata);\n\t\t\t\t}\n\n\t\t\t\tif ((!is_manifest)) {\n\t\t\t\t\tif (hunk_index == 0 && file_status == DEVICE_LINK_FILE_STATUS_LAST_HUNK) {\n\t\t\t\t\t\t\tprint_progress(100);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (file_size > 0)\n\t\t\t\t\t\t\tprint_progress((double)((file_size_current*100)/file_size));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\thunk_index++;\n\n\t\t\t\tif (file_ext)\n\t\t\t\t\tfree(file_ext);\n\n\t\t\t\tif (message)\n\t\t\t\t\tplist_free(message);\n\t\t\t\tmessage = NULL;\n\n\t\t\t\tif (file_status == DEVICE_LINK_FILE_STATUS_LAST_HUNK) {\n\t\t\t\t\t/* acknowlegdge that we received the file */\n\t\t\t\t\tmobilebackup_send_backup_file_received(mobilebackup);\n\t\t\t\t\t/* reset hunk_index */\n\t\t\t\t\thunk_index = 0;\n\t\t\t\t\tif (!is_manifest) {\n\t\t\t\t\t\tfile_size_current = 0;\n\t\t\t\t\t\tfile_size = 0;\n\t\t\t\t\t}\n\t\t\t\t}\nfiles_out:\n\t\t\t\tif (quit_flag > 0) {\n\t\t\t\t\t/* need to cancel the backup here */\n\t\t\t\t\tmobilebackup_send_error(mobilebackup, \"Cancelling DLSendFile\");\n\n\t\t\t\t\t/* remove any atomic Manifest.plist.tmp */\n\t\t\t\t\tif (manifest_path)\n\t\t\t\t\t\tfree(manifest_path);\n\n\t\t\t\t\tmanifest_path = mobilebackup_build_path(backup_directory, \"Manifest\", \".plist.tmp\");\n\t\t\t\t\tif (stat(manifest_path, &st) == 0)\n\t\t\t\t\t\tremove(manifest_path);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (1);\n\n\t\t\tprintf(\"Received %d files from device.\\n\", file_index);\n\n\t\t\tif (!quit_flag && !plist_strcmp(node, \"DLMessageProcessMessage\")) {\n\t\t\t\tnode_tmp = plist_array_get_item(message, 1);\n\t\t\t\tnode = plist_dict_get_item(node_tmp, \"BackupMessageTypeKey\");\n\t\t\t\t/* check if we received the final \"backup finished\" message */\n\t\t\t\tif (node && !plist_strcmp(node, \"BackupMessageBackupFinished\")) {\n\t\t\t\t\t/* backup finished */\n\n\t\t\t\t\t/* process BackupFilesToDeleteKey */\n\t\t\t\t\tnode = plist_dict_get_item(node_tmp, \"BackupFilesToDeleteKey\");\n\t\t\t\t\tif (node) {\n\t\t\t\t\t\tlength = plist_array_get_size(node);\n\t\t\t\t\t\ti = 0;\n\t\t\t\t\t\twhile ((node_tmp = plist_array_get_item(node, i++)) != NULL) {\n\t\t\t\t\t\t\tplist_get_string_val(node_tmp, &file_path);\n\n\t\t\t\t\t\t\tif (mobilebackup_delete_backup_file_by_hash(backup_directory, file_path)) {\n\t\t\t\t\t\t\t\tprintf(\"DONE\\n\");\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\tprintf(\"FAILED\\n\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/* save last valid Manifest.plist */\n\t\t\t\t\tnode_tmp = plist_array_get_item(message, 1);\n\t\t\t\t\tmanifest_plist = plist_dict_get_item(node_tmp, \"BackupManifestKey\");\n\t\t\t\t\tif (manifest_plist) {\n\t\t\t\t\t\tremove(manifest_path);\n\t\t\t\t\t\tprintf(\"Storing Manifest.plist...\\n\");\n\t\t\t\t\t\tplist_write_to_filename(manifest_plist, manifest_path, PLIST_FORMAT_XML);\n\t\t\t\t\t}\n\n\t\t\t\t\tbackup_ok = 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (backup_ok) {\n\t\t\t\t/* Status.plist (Info on how the backup process turned out) */\n\t\t\t\tprintf(\"Backup Successful.\\n\");\n\t\t\t\tmobilebackup_write_status(backup_directory, 1);\n\t\t\t} else {\n\t\t\t\tprintf(\"Backup Failed.\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase CMD_RESTORE:\n\t\t\t/* close down the lockdown connection as it is no longer needed */\n\t\t\tif (client) {\n\t\t\t\tlockdownd_client_free(client);\n\t\t\t\tclient = NULL;\n\t\t\t}\n\n\t\t\t/* TODO: verify battery on AC enough battery remaining */\n\n\t\t\t/* verify if Status.plist says we read from an successful backup */\n\t\t\tif (mobilebackup_read_status(backup_directory) <= 0) {\n\t\t\t\tprintf(\"ERROR: Cannot ensure we restore from a successful backup. Aborting.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* now make sure backup integrity is ok! verify all files */\n\t\t\tprintf(\"Reading existing Manifest.\\n\");\n\t\t\tplist_read_from_filename(&manifest_plist, manifest_path);\n\t\t\tif (!manifest_plist) {\n\t\t\t\tprintf(\"Could not read Manifest.plist. Aborting.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tprintf(\"Verifying backup integrity, please wait.\\n\");\n\t\t\tchar *bin = NULL;\n\t\t\tuint64_t binsize = 0;\n\t\t\tnode = plist_dict_get_item(manifest_plist, \"Data\");\n\t\t\tif (!node || (plist_get_node_type(node) != PLIST_DATA)) {\n\t\t\t\tprintf(\"Could not read Data key from Manifest.plist!\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tplist_get_data_val(node, &bin, &binsize);\n\t\t\tplist_t backup_data = NULL;\n\t\t\tif (bin) {\n\t\t\t\tchar *auth_ver = NULL;\n\t\t\t\tunsigned char *auth_sig = NULL;\n\t\t\t\tuint64_t auth_sig_len = 0;\n\t\t\t\t/* verify AuthSignature */\n\t\t\t\tnode = plist_dict_get_item(manifest_plist, \"AuthVersion\");\n\t\t\t\tplist_get_string_val(node, &auth_ver);\n\t\t\t\tif (auth_ver && (strcmp(auth_ver, \"2.0\") == 0)) {\n\t\t\t\t\tnode = plist_dict_get_item(manifest_plist, \"AuthSignature\");\n\t\t\t\t\tif (node && (plist_get_node_type(node) == PLIST_DATA)) {\n\t\t\t\t\t\tplist_get_data_val(node, (char**)&auth_sig, &auth_sig_len);\n\t\t\t\t\t}\n\t\t\t\t\tif (auth_sig && (auth_sig_len == 20)) {\n\t\t\t\t\t\t/* calculate the sha1, then compare */\n\t\t\t\t\t\tunsigned char data_sha1[20];\n\t\t\t\t\t\tsha1_of_data(bin, binsize, data_sha1);\n\t\t\t\t\t\tif (compare_hash(auth_sig, data_sha1, 20)) {\n\t\t\t\t\t\t\tprintf(\"AuthSignature is valid\\n\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tprintf(\"ERROR: AuthSignature is NOT VALID\\n\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprintf(\"Could not get AuthSignature from manifest!\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tfree(auth_sig);\n\t\t\t\t} else if (auth_ver) {\n\t\t\t\t\tprintf(\"Unknown AuthVersion '%s', cannot verify AuthSignature\\n\", auth_ver);\n\t\t\t\t}\n\t\t\t\tplist_from_bin(bin, (uint32_t)binsize, &backup_data);\n\t\t\t\tfree(bin);\n\t\t\t}\n\t\t\tif (!backup_data) {\n\t\t\t\tprintf(\"Could not read plist from Manifest.plist Data key!\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tplist_t files = plist_dict_get_item(backup_data, \"Files\");\n\t\t\tif (files && (plist_get_node_type(files) == PLIST_DICT)) {\n\t\t\t\tplist_dict_iter iter = NULL;\n\t\t\t\tplist_dict_new_iter(files, &iter);\n\t\t\t\tif (iter) {\n\t\t\t\t\t/* loop over Files entries in Manifest data plist */\n\t\t\t\t\tchar *hash = NULL;\n\t\t\t\t\tint file_ok = 0;\n\t\t\t\t\tint total_files = plist_dict_get_size(files);\n\t\t\t\t\tint cur_file = 1;\n\t\t\t\t\tnode = NULL;\n\t\t\t\t\tplist_dict_next_item(files, iter, &hash, &node);\n\t\t\t\t\twhile (node) {\n\t\t\t\t\t\tprintf(\"Verifying file %d/%d (%d%%) \\r\", cur_file, total_files, (cur_file*100/total_files));\n\t\t\t\t\t\tcur_file++;\n\t\t\t\t\t\t/* make sure both .mddata/.mdinfo files are available for each entry */\n\t\t\t\t\t\tfile_ok = mobilebackup_check_file_integrity(backup_directory, hash, node);\n\t\t\t\t\t\tnode = NULL;\n\t\t\t\t\t\tfree(hash);\n\t\t\t\t\t\thash = NULL;\n\t\t\t\t\t\tif (!file_ok) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tplist_dict_next_item(files, iter, &hash, &node);\n\t\t\t\t\t}\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\t\tfree(iter);\n\t\t\t\t\tif (!file_ok) {\n\t\t\t\t\t\tplist_free(backup_data);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tprintf(\"All backup files appear to be valid\\n\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprintf(\"Requesting restore from device...\\n\");\n\n\t\t\t/* request restore from device with manifest (BackupMessageRestoreMigrate) */\n\t\t\tint restore_flags = MB_RESTORE_NOTIFY_SPRINGBOARD | MB_RESTORE_PRESERVE_SETTINGS | MB_RESTORE_PRESERVE_CAMERA_ROLL;\n\t\t\terr = mobilebackup_request_restore(mobilebackup, manifest_plist, restore_flags, \"1.6\");\n\t\t\tif (err != MOBILEBACKUP_E_SUCCESS) {\n\t\t\t\tif (err == MOBILEBACKUP_E_BAD_VERSION) {\n\t\t\t\t\tprintf(\"ERROR: Could not start restore process: backup protocol version mismatch!\\n\");\n\t\t\t\t} else if (err == MOBILEBACKUP_E_REPLY_NOT_OK) {\n\t\t\t\t\tprintf(\"ERROR: Could not start restore process: device refused to start the restore process.\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tprintf(\"ERROR: Could not start restore process: unspecified error occured (%d)\\n\", err);\n\t\t\t\t}\n\t\t\t\tplist_free(backup_data);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tprintf(\"Entered restore mode.\\n\");\n\n\t\t\tint restore_ok = 0;\n\n\t\t\tif (files && (plist_get_node_type(files) == PLIST_DICT)) {\n\t\t\t\tplist_dict_iter iter = NULL;\n\t\t\t\tplist_dict_new_iter(files, &iter);\n\t\t\t\tif (iter) {\n\t\t\t\t\t/* loop over Files entries in Manifest data plist */\n\t\t\t\t\tchar *hash = NULL;\n\t\t\t\t\tplist_t file_info = NULL;\n\t\t\t\t\tchar *file_info_path = NULL;\n\t\t\t\t\tint total_files = plist_dict_get_size(files);\n\t\t\t\t\tint cur_file = 0;\n\t\t\t\t\tuint64_t file_offset = 0;\n\t\t\t\t\tuint8_t is_encrypted = 0;\n\t\t\t\t\tplist_t tmp_node = NULL;\n\t\t\t\t\tplist_t file_path_node = NULL;\n\t\t\t\t\tplist_t send_file_node = NULL;\n\t\t\t\t\tnode = NULL;\n\t\t\t\t\tplist_dict_next_item(files, iter, &hash, &node);\n\t\t\t\t\twhile (node) {\n\t\t\t\t\t\t/* TODO: read mddata/mdinfo files and send to device using DLSendFile */\n\t\t\t\t\t\tfile_info_path = mobilebackup_build_path(backup_directory, hash, \".mdinfo\");\n\t\t\t\t\t\tplist_read_from_filename(&file_info, file_info_path);\n\n\t\t\t\t\t\t/* get encryption state */\n\t\t\t\t\t\ttmp_node = plist_dict_get_item(file_info, \"IsEncrypted\");\n\t\t\t\t\t\tplist_get_bool_val(tmp_node, &is_encrypted);\n\t\t\t\t\t\ttmp_node = NULL;\n\n\t\t\t\t\t\t/* get real file path from metadata */\n\t\t\t\t\t\ttmp_node = plist_dict_get_item(file_info, \"Metadata\");\n\t\t\t\t\t\tplist_get_data_val(tmp_node, &buffer, &length);\n\t\t\t\t\t\ttmp_node = NULL;\n\t\t\t\t\t\tplist_from_bin(buffer, length, &tmp_node);\n\t\t\t\t\t\tfile_path_node = plist_dict_get_item(tmp_node, \"Path\");\n\t\t\t\t\t\tplist_get_string_val(file_path_node, &file_path);\n\n\t\t\t\t\t\tprintf(\"Restoring file %s %d/%d (%d%%)... \", file_path, cur_file, total_files, (cur_file*100/total_files));\n\n\t\t\t\t\t\t/* add additional device link file information keys */\n\t\t\t\t\t\tplist_dict_set_item(file_info, \"DLFileAttributesKey\", plist_copy(node));\n\t\t\t\t\t\tplist_dict_set_item(file_info, \"DLFileSource\", plist_new_string(file_info_path));\n\t\t\t\t\t\tplist_dict_set_item(file_info, \"DLFileDest\", plist_new_string(\"/tmp/RestoreFile.plist\"));\n\t\t\t\t\t\tplist_dict_set_item(file_info, \"DLFileIsEncrypted\", plist_new_bool(is_encrypted));\n\t\t\t\t\t\tplist_dict_set_item(file_info, \"DLFileOffsetKey\", plist_new_uint(file_offset));\n\t\t\t\t\t\tplist_dict_set_item(file_info, \"DLFileStatusKey\", plist_new_uint(file_status));\n\n\t\t\t\t\t\t/* read data from file */\n\t\t\t\t\t\tfree(file_info_path);\n\t\t\t\t\t\tfile_info_path = mobilebackup_build_path(backup_directory, hash, \".mddata\");\n\n\t\t\t\t\t\t/* determine file size */\n#ifdef WIN32\n\t\t\t\t\t\tstruct _stati64 fst;\n\t\t\t\t\t\tif (_stati64(file_info_path, &fst) != 0)\n#else\n\t\t\t\t\t\tstruct stat fst;\n\t\t\t\t\t\tif (stat(file_info_path, &fst) != 0)\n#endif\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tprintf(\"ERROR: stat() failed for '%s': %s\\n\", file_info_path, strerror(errno));\n\t\t\t\t\t\t\tfree(file_info_path);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlength = fst.st_size;\n\n\t\t\t\t\t\tFILE *f = fopen(file_info_path, \"rb\");\n\t\t\t\t\t\tif (!f) {\n\t\t\t\t\t\t\tprintf(\"ERROR: could not open local file '%s': %s\\n\", file_info_path, strerror(errno));\n\t\t\t\t\t\t\tfree(file_info_path);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree(file_info_path);\n\n\t\t\t\t\t\t/* send DLSendFile messages */\n\t\t\t\t\t\tfile_offset = 0;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tchar buf[8192];\n\t\t\t\t\t\t\tsize_t len = fread(buf, 1, sizeof(buf), f);\n\n\t\t\t\t\t\t\tif ((length-file_offset) <= sizeof(buf))\n\t\t\t\t\t\t\t\tfile_status = DEVICE_LINK_FILE_STATUS_LAST_HUNK;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tfile_status = DEVICE_LINK_FILE_STATUS_HUNK;\n\n\t\t\t\t\t\t\tplist_dict_remove_item(file_info, \"DLFileOffsetKey\");\n\t\t\t\t\t\t\tplist_dict_set_item(file_info, \"DLFileOffsetKey\", plist_new_uint(file_offset));\n\n\t\t\t\t\t\t\tplist_dict_remove_item(file_info, \"DLFileStatusKey\");\n\t\t\t\t\t\t\tplist_dict_set_item(file_info, \"DLFileStatusKey\", plist_new_uint(file_status));\n\n\t\t\t\t\t\t\tsend_file_node = plist_new_array();\n\n\t\t\t\t\t\t\tplist_array_append_item(send_file_node, plist_new_string(\"DLSendFile\"));\n\n\t\t\t\t\t\t\tplist_array_append_item(send_file_node, plist_new_data(buf, len));\n\t\t\t\t\t\t\tplist_array_append_item(send_file_node, plist_copy(file_info));\n\n\t\t\t\t\t\t\terr = mobilebackup_send(mobilebackup, send_file_node);\n\t\t\t\t\t\t\tif (err != MOBILEBACKUP_E_SUCCESS) {\n\t\t\t\t\t\t\t\tprintf(\"ERROR: Unable to send file hunk due to error %d. Aborting...\\n\", err);\n\t\t\t\t\t\t\t\tfile_status = DEVICE_LINK_FILE_STATUS_NONE;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (file_status == DEVICE_LINK_FILE_STATUS_LAST_HUNK) {\n\t\t\t\t\t\t\t\t/* TODO: if all hunks of a file are sent, device must send ack */\n\t\t\t\t\t\t\t\terr = mobilebackup_receive_restore_file_received(mobilebackup, NULL);\n\t\t\t\t\t\t\t\tif (err != MOBILEBACKUP_E_SUCCESS) {\n\t\t\t\t\t\t\t\t\tprintf(\"ERROR: Did not receive an ack for the sent file due to error %d. Aborting...\\n\", err);\n\t\t\t\t\t\t\t\t\tfile_status = DEVICE_LINK_FILE_STATUS_NONE;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfile_offset += len;\n\n\t\t\t\t\t\t\tif (file_status == DEVICE_LINK_FILE_STATUS_LAST_HUNK)\n\t\t\t\t\t\t\t\tprintf(\"DONE\\n\");\n\n\t\t\t\t\t\t\tplist_free(send_file_node);\n\n\t\t\t\t\t\t\tif (file_status == DEVICE_LINK_FILE_STATUS_NONE)\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t} while((file_offset < length));\n\n\t\t\t\t\t\tfree(hash);\n\t\t\t\t\t\tnode = NULL;\n\t\t\t\t\t\thash = NULL;\n\n\t\t\t\t\t\trestore_ok = 1;\n\t\t\t\t\t\tif (file_status == DEVICE_LINK_FILE_STATUS_NONE) {\n\t\t\t\t\t\t\trestore_ok = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcur_file++;\n\t\t\t\t\t\tplist_dict_next_item(files, iter, &hash, &node);\n\t\t\t\t\t}\n\t\t\t\t\tfree(iter);\n\n\t\t\t\t\tprintf(\"Restored %d files on device.\\n\", cur_file);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* TODO: observe notification_proxy id com.apple.mobile.application_installed */\n\t\t\t/* TODO: loop over Applications entries in Manifest data plist */\n\t\t\tplist_t applications = plist_dict_get_item(backup_data, \"Applications\");\n\t\t\tif (applications && (plist_get_node_type(applications) == PLIST_DICT) && restore_ok) {\n\t\t\t\tplist_dict_iter iter = NULL;\n\t\t\t\tplist_dict_new_iter(applications, &iter);\n\t\t\t\tif (iter) {\n\t\t\t\t\t/* loop over Application entries in Manifest data plist */\n\t\t\t\t\tchar *hash = NULL;\n\t\t\t\t\tint total_files = plist_dict_get_size(applications);\n\t\t\t\t\tint cur_file = 1;\n\t\t\t\t\tplist_t tmp_node = NULL;\n\t\t\t\t\tplist_t dict = NULL;\n\t\t\t\t\tplist_t array = NULL;\n\t\t\t\t\tnode = NULL;\n\t\t\t\t\tplist_dict_next_item(applications, iter, &hash, &node);\n\t\t\t\t\twhile (node) {\n\t\t\t\t\t\tprintf(\"Restoring Application %s %d/%d (%d%%)...\", hash, cur_file, total_files, (cur_file*100/total_files));\n\t\t\t\t\t\t/* FIXME: receive com.apple.mobile.application_installed notification */\n\t\t\t\t\t\t/* send AppInfo entry */\n\t\t\t\t\t\ttmp_node = plist_dict_get_item(node, \"AppInfo\");\n\n\t\t\t\t\t\tdict = plist_new_dict();\n\t\t\t\t\t\tplist_dict_set_item(dict, \"AppInfo\", plist_copy(tmp_node));\n\t\t\t\t\t\tplist_dict_set_item(dict, \"BackupMessageTypeKey\", plist_new_string(\"BackupMessageRestoreApplicationSent\"));\n\n\t\t\t\t\t\tarray = plist_new_array();\n\t\t\t\t\t\tplist_array_append_item(array, plist_new_string(\"DLMessageProcessMessage\"));\n\t\t\t\t\t\tplist_array_append_item(array, dict);\n\n\t\t\t\t\t\terr = mobilebackup_send(mobilebackup, array);\n\t\t\t\t\t\tif (err != MOBILEBACKUP_E_SUCCESS) {\n\t\t\t\t\t\t\tprintf(\"ERROR: Unable to restore application %s due to error %d. Aborting...\\n\", hash, err);\n\t\t\t\t\t\t\trestore_ok = 0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tplist_free(array);\n\t\t\t\t\t\tarray = NULL;\n\t\t\t\t\t\tdict = NULL;\n\n\t\t\t\t\t\t/* receive BackupMessageRestoreApplicationReceived from device */\n\t\t\t\t\t\tif (restore_ok) {\n\t\t\t\t\t\t\terr = mobilebackup_receive_restore_application_received(mobilebackup, NULL);\n\t\t\t\t\t\t\tif (err != MOBILEBACKUP_E_SUCCESS) {\n\t\t\t\t\t\t\t\tprintf(\"ERROR: Failed to receive an ack from the device for this application due to error %d. Aborting...\\n\", err);\n\t\t\t\t\t\t\t\trestore_ok = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttmp_node = NULL;\n\t\t\t\t\t\tnode = NULL;\n\t\t\t\t\t\tfree(hash);\n\t\t\t\t\t\thash = NULL;\n\n\t\t\t\t\t\tif (restore_ok) {\n\t\t\t\t\t\t\tprintf(\"DONE\\n\");\n\t\t\t\t\t\t\tcur_file++;\n\t\t\t\t\t\t\tplist_dict_next_item(applications, iter, &hash, &node);\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfree(iter);\n\n\t\t\t\t\tif (restore_ok)\n\t\t\t\t\t\tprintf(\"All applications restored.\\n\");\n\t\t\t\t\telse\n\t\t\t\t\t\tprintf(\"Failed to restore applications.\\n\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tplist_free(backup_data);\n\n\t\t\t/* signal restore finished message to device; BackupMessageRestoreComplete */\n\t\t\tif (restore_ok) {\n\t\t\t\terr = mobilebackup_send_restore_complete(mobilebackup);\n\t\t\t\tif (err != MOBILEBACKUP_E_SUCCESS) {\n\t\t\t\t\tprintf(\"ERROR: Could not send BackupMessageRestoreComplete, error code %d\\n\", err);\n\t\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (restore_ok) {\n\t\t\t\tprintf(\"Restore Successful.\\n\");\n\t\t\t} else {\n\t\t\t\tprintf(\"Restore Failed.\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase CMD_LEAVE:\n\t\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (lockfile) {\n\t\t\tafc_file_lock(afc, lockfile, AFC_LOCK_UN);\n\t\t\tafc_file_close(afc, lockfile);\n\t\t\tlockfile = 0;\n\t\t\tdo_post_notification(NP_SYNC_DID_FINISH);\n\t\t}\n\t\tif (manifest_path)\n\t\t\tfree(manifest_path);\n\t} else {\n\t\tprintf(\"ERROR: Could not start service %s.\\n\", MOBILEBACKUP_SERVICE_NAME);\n\t\tlockdownd_client_free(client);\n\t\tclient = NULL;\n\t}\n\n\tif (client) {\n\t\tlockdownd_client_free(client);\n\t\tclient = NULL;\n\t}\n\n\tif (afc)\n\t\tafc_client_free(afc);\n\n\tif (np)\n\t\tnp_client_free(np);\n\n\tif (mobilebackup)\n\t\tmobilebackup_client_free(mobilebackup);\n\n\tidevice_free(device);\n\n\tif (udid) {\n\t\tfree(udid);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "print_usage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
    "lines": "663-678",
    "snippet": "static void print_usage(int argc, char **argv)\n{\n\tchar *name = NULL;\n\tname = strrchr(argv[0], '/');\n\tprintf(\"Usage: %s [OPTIONS] CMD [DIRECTORY]\\n\", (name ? name + 1: argv[0]));\n\tprintf(\"Create or restore backup from the current or specified directory.\\n\\n\");\n\tprintf(\"commands:\\n\");\n\tprintf(\"  backup\\tSaves a device backup into DIRECTORY\\n\");\n\tprintf(\"  restore\\tRestores a device backup from DIRECTORY.\\n\\n\");\n\tprintf(\"options:\\n\");\n\tprintf(\"  -d, --debug\\t\\tenable communication debugging\\n\");\n\tprintf(\"  -u, --udid UDID\\ttarget specific device by its 40-digit device UDID\\n\");\n\tprintf(\"  -h, --help\\t\\tprints usage information\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"Homepage: <\" PACKAGE_URL \">\\n\");\n}",
    "includes": [
      "#include <windows.h>",
      "#include \"common/utils.h\"",
      "#include <libimobiledevice/afc.h>",
      "#include <libimobiledevice/notification_proxy.h>",
      "#include <libimobiledevice/mobilebackup.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <unistd.h>",
      "#include <gcrypt.h>",
      "#include <openssl/sha.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static idevice_t device = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Homepage: <\" PACKAGE_URL \">\\n\""
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  -h, --help\\t\\tprints usage information\\n\""
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  -u, --udid UDID\\ttarget specific device by its 40-digit device UDID\\n\""
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  -d, --debug\\t\\tenable communication debugging\\n\""
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"options:\\n\""
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  restore\\tRestores a device backup from DIRECTORY.\\n\\n\""
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  backup\\tSaves a device backup into DIRECTORY\\n\""
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"commands:\\n\""
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Create or restore backup from the current or specified directory.\\n\\n\""
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Usage: %s [OPTIONS] CMD [DIRECTORY]\\n\"",
            "(name ? name + 1: argv[0])"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "asprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/include/asprintf.h",
          "lines": "23-31",
          "snippet": "static inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}",
          "includes": [
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <config.h>\n\nstatic inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "argv[0]",
            "'/'"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic idevice_t device = NULL;\n\nstatic void print_usage(int argc, char **argv)\n{\n\tchar *name = NULL;\n\tname = strrchr(argv[0], '/');\n\tprintf(\"Usage: %s [OPTIONS] CMD [DIRECTORY]\\n\", (name ? name + 1: argv[0]));\n\tprintf(\"Create or restore backup from the current or specified directory.\\n\\n\");\n\tprintf(\"commands:\\n\");\n\tprintf(\"  backup\\tSaves a device backup into DIRECTORY\\n\");\n\tprintf(\"  restore\\tRestores a device backup from DIRECTORY.\\n\\n\");\n\tprintf(\"options:\\n\");\n\tprintf(\"  -d, --debug\\t\\tenable communication debugging\\n\");\n\tprintf(\"  -u, --udid UDID\\ttarget specific device by its 40-digit device UDID\\n\");\n\tprintf(\"  -h, --help\\t\\tprints usage information\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"Homepage: <\" PACKAGE_URL \">\\n\");\n}"
  },
  {
    "function_name": "clean_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
    "lines": "657-661",
    "snippet": "static void clean_exit(int sig)\n{\n\tfprintf(stderr, \"Exiting...\\n\");\n\tquit_flag++;\n}",
    "includes": [
      "#include <windows.h>",
      "#include \"common/utils.h\"",
      "#include <libimobiledevice/afc.h>",
      "#include <libimobiledevice/notification_proxy.h>",
      "#include <libimobiledevice/mobilebackup.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <unistd.h>",
      "#include <gcrypt.h>",
      "#include <openssl/sha.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int quit_flag = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Exiting...\\n\""
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int quit_flag = 0;\n\nstatic void clean_exit(int sig)\n{\n\tfprintf(stderr, \"Exiting...\\n\");\n\tquit_flag++;\n}"
  },
  {
    "function_name": "print_progress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
    "lines": "631-652",
    "snippet": "static void print_progress(double progress)\n{\n\tint i = 0;\n\tif (progress < 0)\n\t\treturn;\n\n\tif (progress > 100)\n\t\tprogress = 100;\n\n\tprintf(\"\\r[\");\n\tfor(i = 0; i < 50; i++) {\n\t\tif(i < progress / 2) {\n\t\t\tprintf(\"=\");\n\t\t} else {\n\t\t\tprintf(\" \");\n\t\t}\n\t}\n\tprintf(\"] %3.0f%%\", progress);\n\tfflush(stdout);\n\tif (progress == 100)\n\t\tprintf(\"\\n\");\n}",
    "includes": [
      "#include <windows.h>",
      "#include \"common/utils.h\"",
      "#include <libimobiledevice/afc.h>",
      "#include <libimobiledevice/notification_proxy.h>",
      "#include <libimobiledevice/mobilebackup.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <unistd.h>",
      "#include <gcrypt.h>",
      "#include <openssl/sha.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stdout"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"] %3.0f%%\"",
            "progress"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "asprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/include/asprintf.h",
          "lines": "23-31",
          "snippet": "static inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}",
          "includes": [
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <config.h>\n\nstatic inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" \""
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"=\""
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\r[\""
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void print_progress(double progress)\n{\n\tint i = 0;\n\tif (progress < 0)\n\t\treturn;\n\n\tif (progress > 100)\n\t\tprogress = 100;\n\n\tprintf(\"\\r[\");\n\tfor(i = 0; i < 50; i++) {\n\t\tif(i < progress / 2) {\n\t\t\tprintf(\"=\");\n\t\t} else {\n\t\t\tprintf(\" \");\n\t\t}\n\t}\n\tprintf(\"] %3.0f%%\", progress);\n\tfflush(stdout);\n\tif (progress == 100)\n\t\tprintf(\"\\n\");\n}"
  },
  {
    "function_name": "do_post_notification",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
    "lines": "603-629",
    "snippet": "static void do_post_notification(const char *notification)\n{\n\tlockdownd_service_descriptor_t service = NULL;\n\tnp_client_t np;\n\n\tif (!client) {\n\t\tif (lockdownd_client_new_with_handshake(device, &client, \"idevicebackup\") != LOCKDOWN_E_SUCCESS) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlockdownd_start_service(client, NP_SERVICE_NAME, &service);\n\tif (service && service->port) {\n\t\tnp_client_new(device, service, &np);\n\t\tif (np) {\n\t\t\tnp_post_notification(np, notification);\n\t\t\tnp_client_free(np);\n\t\t}\n\t} else {\n\t\tprintf(\"Could not start %s\\n\", NP_SERVICE_NAME);\n\t}\n\n\tif (service) {\n\t\tlockdownd_service_descriptor_free(service);\n\t\tservice = NULL;\n\t}\n}",
    "includes": [
      "#include <windows.h>",
      "#include \"common/utils.h\"",
      "#include <libimobiledevice/afc.h>",
      "#include <libimobiledevice/notification_proxy.h>",
      "#include <libimobiledevice/mobilebackup.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <unistd.h>",
      "#include <gcrypt.h>",
      "#include <openssl/sha.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define NP_SERVICE_NAME \"com.apple.mobile.notification_proxy\""
    ],
    "globals_used": [
      "static lockdownd_client_t client = NULL;",
      "static idevice_t device = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdownd_service_descriptor_free",
          "args": [
            "service"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "lockdownd_service_descriptor_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/lockdown.c",
          "lines": "1522-1528",
          "snippet": "LIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_service_descriptor_free(lockdownd_service_descriptor_t service)\n{\n\tif (service)\n\t\tfree(service);\n\n\treturn LOCKDOWN_E_SUCCESS;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/userpref.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"lockdown.h\"",
            "#include \"property_list_service.h\"",
            "#include <plist/plist.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/x509.h>",
            "#include <libtasn1.h>",
            "#include <openssl/x509v3.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/pem.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/userpref.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"lockdown.h\"\n#include \"property_list_service.h\"\n#include <plist/plist.h>\n#include <gnutls/crypto.h>\n#include <gnutls/x509.h>\n#include <libtasn1.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/pem.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_service_descriptor_free(lockdownd_service_descriptor_t service)\n{\n\tif (service)\n\t\tfree(service);\n\n\treturn LOCKDOWN_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Could not start %s\\n\"",
            "NP_SERVICE_NAME"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "asprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/include/asprintf.h",
          "lines": "23-31",
          "snippet": "static inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}",
          "includes": [
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <config.h>\n\nstatic inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "np_client_free",
          "args": [
            "np"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "np_client_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/notification_proxy.c",
          "lines": "114-166",
          "snippet": "LIBIMOBILEDEVICE_API np_error_t np_client_free(np_client_t client)\n{\n\tplist_t dict;\n\tproperty_list_service_client_t parent;\n\n\tif (!client)\n\t\treturn NP_E_INVALID_ARG;\n\n\tdict = plist_new_dict();\n\tplist_dict_set_item(dict,\"Command\", plist_new_string(\"Shutdown\"));\n\tproperty_list_service_send_xml_plist(client->parent, dict);\n\tplist_free(dict);\n\n\tparent = client->parent;\n\t/* notifies the client->notifier thread that it should terminate */\n\tclient->parent = NULL;\n\n\tif (client->notifier) {\n\t\tdebug_info(\"joining np callback\");\n\t\tthread_join(client->notifier);\n\t\tthread_free(client->notifier);\n\t\tclient->notifier = (thread_t)NULL;\n\t} else {\n\t\tdict = NULL;\n\t\tproperty_list_service_receive_plist(parent, &dict);\n\t\tif (dict) {\n#ifndef STRIP_DEBUG_CODE\n\t\t\tchar *cmd_value = NULL;\n\t\t\tplist_t cmd_value_node = plist_dict_get_item(dict, \"Command\");\n\t\t\tif (plist_get_node_type(cmd_value_node) == PLIST_STRING) {\n\t\t\t\tplist_get_string_val(cmd_value_node, &cmd_value);\n\t\t\t}\n\t\t\tif (cmd_value && !strcmp(cmd_value, \"ProxyDeath\")) {\n\t\t\t\t// this is the expected answer\n\t\t\t} else {\n\t\t\t\tdebug_info(\"Did not get ProxyDeath but:\");\n\t\t\t\tdebug_plist(dict);\n\t\t\t}\n\t\t\tif (cmd_value) {\n\t\t\t\tfree(cmd_value);\n\t\t\t}\n#endif\n\t\t\tplist_free(dict);\n\t\t}\n\t}\n\n\tproperty_list_service_client_free(parent);\n\n\tmutex_destroy(&client->mutex);\n\tfree(client);\n\n\treturn NP_E_SUCCESS;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"property_list_service.h\"",
            "#include \"notification_proxy.h\"",
            "#include <plist/plist.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"property_list_service.h\"\n#include \"notification_proxy.h\"\n#include <plist/plist.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n\nLIBIMOBILEDEVICE_API np_error_t np_client_free(np_client_t client)\n{\n\tplist_t dict;\n\tproperty_list_service_client_t parent;\n\n\tif (!client)\n\t\treturn NP_E_INVALID_ARG;\n\n\tdict = plist_new_dict();\n\tplist_dict_set_item(dict,\"Command\", plist_new_string(\"Shutdown\"));\n\tproperty_list_service_send_xml_plist(client->parent, dict);\n\tplist_free(dict);\n\n\tparent = client->parent;\n\t/* notifies the client->notifier thread that it should terminate */\n\tclient->parent = NULL;\n\n\tif (client->notifier) {\n\t\tdebug_info(\"joining np callback\");\n\t\tthread_join(client->notifier);\n\t\tthread_free(client->notifier);\n\t\tclient->notifier = (thread_t)NULL;\n\t} else {\n\t\tdict = NULL;\n\t\tproperty_list_service_receive_plist(parent, &dict);\n\t\tif (dict) {\n#ifndef STRIP_DEBUG_CODE\n\t\t\tchar *cmd_value = NULL;\n\t\t\tplist_t cmd_value_node = plist_dict_get_item(dict, \"Command\");\n\t\t\tif (plist_get_node_type(cmd_value_node) == PLIST_STRING) {\n\t\t\t\tplist_get_string_val(cmd_value_node, &cmd_value);\n\t\t\t}\n\t\t\tif (cmd_value && !strcmp(cmd_value, \"ProxyDeath\")) {\n\t\t\t\t// this is the expected answer\n\t\t\t} else {\n\t\t\t\tdebug_info(\"Did not get ProxyDeath but:\");\n\t\t\t\tdebug_plist(dict);\n\t\t\t}\n\t\t\tif (cmd_value) {\n\t\t\t\tfree(cmd_value);\n\t\t\t}\n#endif\n\t\t\tplist_free(dict);\n\t\t}\n\t}\n\n\tproperty_list_service_client_free(parent);\n\n\tmutex_destroy(&client->mutex);\n\tfree(client);\n\n\treturn NP_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "np_post_notification",
          "args": [
            "np",
            "notification"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "np_post_notification",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/notification_proxy.c",
          "lines": "168-187",
          "snippet": "LIBIMOBILEDEVICE_API np_error_t np_post_notification(np_client_t client, const char *notification)\n{\n\tif (!client || !notification) {\n\t\treturn NP_E_INVALID_ARG;\n\t}\n\tnp_lock(client);\n\n\tplist_t dict = plist_new_dict();\n\tplist_dict_set_item(dict,\"Command\", plist_new_string(\"PostNotification\"));\n\tplist_dict_set_item(dict,\"Name\", plist_new_string(notification));\n\n\tnp_error_t res = np_error(property_list_service_send_xml_plist(client->parent, dict));\n\tplist_free(dict);\n\n\tif (res != NP_E_SUCCESS) {\n\t\tdebug_info(\"Error sending XML plist to device!\");\n\t}\n\tnp_unlock(client);\n\treturn res;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"property_list_service.h\"",
            "#include \"notification_proxy.h\"",
            "#include <plist/plist.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"property_list_service.h\"\n#include \"notification_proxy.h\"\n#include <plist/plist.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n\nLIBIMOBILEDEVICE_API np_error_t np_post_notification(np_client_t client, const char *notification)\n{\n\tif (!client || !notification) {\n\t\treturn NP_E_INVALID_ARG;\n\t}\n\tnp_lock(client);\n\n\tplist_t dict = plist_new_dict();\n\tplist_dict_set_item(dict,\"Command\", plist_new_string(\"PostNotification\"));\n\tplist_dict_set_item(dict,\"Name\", plist_new_string(notification));\n\n\tnp_error_t res = np_error(property_list_service_send_xml_plist(client->parent, dict));\n\tplist_free(dict);\n\n\tif (res != NP_E_SUCCESS) {\n\t\tdebug_info(\"Error sending XML plist to device!\");\n\t}\n\tnp_unlock(client);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "np_client_new",
          "args": [
            "device",
            "service",
            "&np"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "np_client_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/notification_proxy.c",
          "lines": "89-105",
          "snippet": "LIBIMOBILEDEVICE_API np_error_t np_client_new(idevice_t device, lockdownd_service_descriptor_t service, np_client_t *client)\n{\n\tproperty_list_service_client_t plistclient = NULL;\n\tnp_error_t err = np_error(property_list_service_client_new(device, service, &plistclient));\n\tif (err != NP_E_SUCCESS) {\n\t\treturn err;\n\t}\n\n\tnp_client_t client_loc = (np_client_t) malloc(sizeof(struct np_client_private));\n\tclient_loc->parent = plistclient;\n\n\tmutex_init(&client_loc->mutex);\n\tclient_loc->notifier = (thread_t)NULL;\n\n\t*client = client_loc;\n\treturn NP_E_SUCCESS;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"property_list_service.h\"",
            "#include \"notification_proxy.h\"",
            "#include <plist/plist.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"property_list_service.h\"\n#include \"notification_proxy.h\"\n#include <plist/plist.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n\nLIBIMOBILEDEVICE_API np_error_t np_client_new(idevice_t device, lockdownd_service_descriptor_t service, np_client_t *client)\n{\n\tproperty_list_service_client_t plistclient = NULL;\n\tnp_error_t err = np_error(property_list_service_client_new(device, service, &plistclient));\n\tif (err != NP_E_SUCCESS) {\n\t\treturn err;\n\t}\n\n\tnp_client_t client_loc = (np_client_t) malloc(sizeof(struct np_client_private));\n\tclient_loc->parent = plistclient;\n\n\tmutex_init(&client_loc->mutex);\n\tclient_loc->notifier = (thread_t)NULL;\n\n\t*client = client_loc;\n\treturn NP_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdownd_start_service",
          "args": [
            "client",
            "NP_SERVICE_NAME",
            "&service"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "lockdownd_start_service_with_escrow_bag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/lockdown.c",
          "lines": "1364-1367",
          "snippet": "LIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_start_service_with_escrow_bag(lockdownd_client_t client, const char *identifier, lockdownd_service_descriptor_t *service)\n{\n\treturn lockdownd_do_start_service(client, identifier, 1, service);\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/userpref.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"lockdown.h\"",
            "#include \"property_list_service.h\"",
            "#include <plist/plist.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/x509.h>",
            "#include <libtasn1.h>",
            "#include <openssl/x509v3.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/pem.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/userpref.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"lockdown.h\"\n#include \"property_list_service.h\"\n#include <plist/plist.h>\n#include <gnutls/crypto.h>\n#include <gnutls/x509.h>\n#include <libtasn1.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/pem.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_start_service_with_escrow_bag(lockdownd_client_t client, const char *identifier, lockdownd_service_descriptor_t *service)\n{\n\treturn lockdownd_do_start_service(client, identifier, 1, service);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdownd_client_new_with_handshake",
          "args": [
            "device",
            "&client",
            "\"idevicebackup\""
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "lockdownd_client_new_with_handshake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/lockdown.c",
          "lines": "671-753",
          "snippet": "LIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_client_new_with_handshake(idevice_t device, lockdownd_client_t *client, const char *label)\n{\n\tif (!client)\n\t\treturn LOCKDOWN_E_INVALID_ARG;\n\n\tlockdownd_error_t ret = LOCKDOWN_E_SUCCESS;\n\tlockdownd_client_t client_loc = NULL;\n\tplist_t pair_record = NULL;\n\tchar *host_id = NULL;\n\tchar *type = NULL;\n\n\tret = lockdownd_client_new(device, &client_loc, label);\n\tif (LOCKDOWN_E_SUCCESS != ret) {\n\t\tdebug_info(\"failed to create lockdownd client.\");\n\t\treturn ret;\n\t}\n\n\t/* perform handshake */\n\tif (LOCKDOWN_E_SUCCESS != lockdownd_query_type(client_loc, &type)) {\n\t\tdebug_info(\"QueryType failed in the lockdownd client.\");\n\t\tret = LOCKDOWN_E_NOT_ENOUGH_DATA;\n\t} else {\n\t\tif (strcmp(\"com.apple.mobile.lockdown\", type)) {\n\t\t\tdebug_info(\"Warning QueryType request returned \\\"%s\\\".\", type);\n\t\t}\n\t}\n\tfree(type);\n\n\tuserpref_read_pair_record(client_loc->udid, &pair_record);\n\tif (pair_record) {\n\t\tpair_record_get_host_id(pair_record, &host_id);\n\t}\n\tif (LOCKDOWN_E_SUCCESS == ret && !host_id) {\n\t\tret = LOCKDOWN_E_INVALID_CONF;\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS == ret && !pair_record) {\n\t\t/* attempt pairing */\n\t\tret = lockdownd_pair(client_loc, NULL);\n\t}\n\n\tplist_free(pair_record);\n\tpair_record = NULL;\n\n\t/* in any case, we need to validate pairing to receive trusted host status */\n\tret = lockdownd_validate_pair(client_loc, NULL);\n\n\t/* if not paired yet, let's do it now */\n\tif (LOCKDOWN_E_INVALID_HOST_ID == ret) {\n\t\tfree(host_id);\n\t\thost_id = NULL;\n\t\tret = lockdownd_pair(client_loc, NULL);\n\t\tif (LOCKDOWN_E_SUCCESS == ret) {\n\t\t\tret = lockdownd_validate_pair(client_loc, NULL);\n\t\t} else if (LOCKDOWN_E_PAIRING_DIALOG_RESPONSE_PENDING == ret) {\n\t\t\tdebug_info(\"Device shows the pairing dialog.\");\n\t\t}\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS == ret) {\n\t\tif (!host_id) {\n\t\t\tuserpref_read_pair_record(client_loc->udid, &pair_record);\n\t\t\tif (pair_record) {\n\t\t\t\tpair_record_get_host_id(pair_record, &host_id);\n\t\t\t\tplist_free(pair_record);\n\t\t\t}\n\t\t}\n\n\t\tret = lockdownd_start_session(client_loc, host_id, NULL, NULL);\n\t\tif (LOCKDOWN_E_SUCCESS != ret) {\n\t\t\tdebug_info(\"Session opening failed.\");\n\t\t}\n\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS == ret) {\n\t\t*client = client_loc;\n\t} else {\n\t\tlockdownd_client_free(client_loc);\n\t}\n\tfree(host_id);\n\treturn ret;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/userpref.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"lockdown.h\"",
            "#include \"property_list_service.h\"",
            "#include <plist/plist.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/x509.h>",
            "#include <libtasn1.h>",
            "#include <openssl/x509v3.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/pem.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/userpref.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"lockdown.h\"\n#include \"property_list_service.h\"\n#include <plist/plist.h>\n#include <gnutls/crypto.h>\n#include <gnutls/x509.h>\n#include <libtasn1.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/pem.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_client_new_with_handshake(idevice_t device, lockdownd_client_t *client, const char *label)\n{\n\tif (!client)\n\t\treturn LOCKDOWN_E_INVALID_ARG;\n\n\tlockdownd_error_t ret = LOCKDOWN_E_SUCCESS;\n\tlockdownd_client_t client_loc = NULL;\n\tplist_t pair_record = NULL;\n\tchar *host_id = NULL;\n\tchar *type = NULL;\n\n\tret = lockdownd_client_new(device, &client_loc, label);\n\tif (LOCKDOWN_E_SUCCESS != ret) {\n\t\tdebug_info(\"failed to create lockdownd client.\");\n\t\treturn ret;\n\t}\n\n\t/* perform handshake */\n\tif (LOCKDOWN_E_SUCCESS != lockdownd_query_type(client_loc, &type)) {\n\t\tdebug_info(\"QueryType failed in the lockdownd client.\");\n\t\tret = LOCKDOWN_E_NOT_ENOUGH_DATA;\n\t} else {\n\t\tif (strcmp(\"com.apple.mobile.lockdown\", type)) {\n\t\t\tdebug_info(\"Warning QueryType request returned \\\"%s\\\".\", type);\n\t\t}\n\t}\n\tfree(type);\n\n\tuserpref_read_pair_record(client_loc->udid, &pair_record);\n\tif (pair_record) {\n\t\tpair_record_get_host_id(pair_record, &host_id);\n\t}\n\tif (LOCKDOWN_E_SUCCESS == ret && !host_id) {\n\t\tret = LOCKDOWN_E_INVALID_CONF;\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS == ret && !pair_record) {\n\t\t/* attempt pairing */\n\t\tret = lockdownd_pair(client_loc, NULL);\n\t}\n\n\tplist_free(pair_record);\n\tpair_record = NULL;\n\n\t/* in any case, we need to validate pairing to receive trusted host status */\n\tret = lockdownd_validate_pair(client_loc, NULL);\n\n\t/* if not paired yet, let's do it now */\n\tif (LOCKDOWN_E_INVALID_HOST_ID == ret) {\n\t\tfree(host_id);\n\t\thost_id = NULL;\n\t\tret = lockdownd_pair(client_loc, NULL);\n\t\tif (LOCKDOWN_E_SUCCESS == ret) {\n\t\t\tret = lockdownd_validate_pair(client_loc, NULL);\n\t\t} else if (LOCKDOWN_E_PAIRING_DIALOG_RESPONSE_PENDING == ret) {\n\t\t\tdebug_info(\"Device shows the pairing dialog.\");\n\t\t}\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS == ret) {\n\t\tif (!host_id) {\n\t\t\tuserpref_read_pair_record(client_loc->udid, &pair_record);\n\t\t\tif (pair_record) {\n\t\t\t\tpair_record_get_host_id(pair_record, &host_id);\n\t\t\t\tplist_free(pair_record);\n\t\t\t}\n\t\t}\n\n\t\tret = lockdownd_start_session(client_loc, host_id, NULL, NULL);\n\t\tif (LOCKDOWN_E_SUCCESS != ret) {\n\t\t\tdebug_info(\"Session opening failed.\");\n\t\t}\n\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS == ret) {\n\t\t*client = client_loc;\n\t} else {\n\t\tlockdownd_client_free(client_loc);\n\t}\n\tfree(host_id);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\n#define NP_SERVICE_NAME \"com.apple.mobile.notification_proxy\"\n\nstatic lockdownd_client_t client = NULL;\nstatic idevice_t device = NULL;\n\nstatic void do_post_notification(const char *notification)\n{\n\tlockdownd_service_descriptor_t service = NULL;\n\tnp_client_t np;\n\n\tif (!client) {\n\t\tif (lockdownd_client_new_with_handshake(device, &client, \"idevicebackup\") != LOCKDOWN_E_SUCCESS) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlockdownd_start_service(client, NP_SERVICE_NAME, &service);\n\tif (service && service->port) {\n\t\tnp_client_new(device, service, &np);\n\t\tif (np) {\n\t\t\tnp_post_notification(np, notification);\n\t\t\tnp_client_free(np);\n\t\t}\n\t} else {\n\t\tprintf(\"Could not start %s\\n\", NP_SERVICE_NAME);\n\t}\n\n\tif (service) {\n\t\tlockdownd_service_descriptor_free(service);\n\t\tservice = NULL;\n\t}\n}"
  },
  {
    "function_name": "mobilebackup_check_file_integrity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
    "lines": "452-601",
    "snippet": "static int mobilebackup_check_file_integrity(const char *backup_directory, const char *hash, plist_t filedata)\n{\n\tchar *datapath;\n\tchar *infopath;\n\tplist_t mdinfo = NULL;\n\tstruct stat st;\n\tunsigned char file_hash[20];\n\n\tdatapath = mobilebackup_build_path(backup_directory, hash, \".mddata\");\n\tif (stat(datapath, &st) != 0) {\n\t\tprintf(\"\\r\\n\");\n\t\tprintf(\"ERROR: '%s.mddata' is missing!\\n\", hash);\n\t\tfree(datapath);\n\t\treturn 0;\n\t}\n\n\tinfopath = mobilebackup_build_path(backup_directory, hash, \".mdinfo\");\n\tplist_read_from_filename(&mdinfo, infopath);\n\tfree(infopath);\n\tif (!mdinfo) {\n\t\tprintf(\"\\r\\n\");\n\t\tprintf(\"ERROR: '%s.mdinfo' is missing or corrupted!\\n\", hash);\n\t\tfree(datapath);\n\t\treturn 0;\n\t}\n\n\t/* sha1 hash verification */\n\tplist_t node = plist_dict_get_item(filedata, \"DataHash\");\n\tif (!node || (plist_get_node_type(node) != PLIST_DATA)) {\n\t\tprintf(\"\\r\\n\");\n\t\tprintf(\"ERROR: Could not get DataHash for file entry '%s'\\n\", hash);\n\t\tplist_free(mdinfo);\n\t\tfree(datapath);\n\t\treturn 0;\n\t}\n\n\tnode = plist_dict_get_item(mdinfo, \"Metadata\");\n\tif (!node && (plist_get_node_type(node) != PLIST_DATA)) {\n\t\tprintf(\"\\r\\n\");\n\t\tprintf(\"ERROR: Could not find Metadata in plist '%s.mdinfo'\\n\", hash);\n\t\tplist_free(mdinfo);\n\t\tfree(datapath);\n\t\treturn 0;\n\t}\n\n\tchar *meta_bin = NULL;\n\tuint64_t meta_bin_size = 0;\n\tplist_get_data_val(node, &meta_bin, &meta_bin_size);\n\tplist_t metadata = NULL;\n\tif (meta_bin) {\n\t\tplist_from_bin(meta_bin, (uint32_t)meta_bin_size, &metadata);\n\t}\n\tif (!metadata) {\n\t\tprintf(\"\\r\\n\");\n\t\tprintf(\"ERROR: Could not get Metadata from plist '%s.mdinfo'\\n\", hash);\n\t\tplist_free(mdinfo);\n\t\tfree(datapath);\n\t\treturn 0;\n\t}\n\n\tchar *version = NULL;\n\tnode = plist_dict_get_item(metadata, \"Version\");\n\tif (node && (plist_get_node_type(node) == PLIST_STRING)) {\n\t\tplist_get_string_val(node, &version);\n\t}\n\n\tchar *destpath = NULL;\n\tnode = plist_dict_get_item(metadata, \"Path\");\n\tif (node && (plist_get_node_type(node) == PLIST_STRING)) {\n\t\tplist_get_string_val(node, &destpath);\n\t}\n\n\tuint8_t greylist = 0;\n\tnode = plist_dict_get_item(metadata, \"Greylist\");\n\tif (node && (plist_get_node_type(node) == PLIST_BOOLEAN)) {\n\t\tplist_get_bool_val(node, &greylist);\n\t}\n\n\tchar *domain = NULL;\n\tnode = plist_dict_get_item(metadata, \"Domain\");\n\tif (node && (plist_get_node_type(node) == PLIST_STRING)) {\n\t\tplist_get_string_val(node, &domain);\n\t}\n\n\tchar *fnstr = malloc(strlen(domain) + 1 + strlen(destpath) + 1);\n\tstrcpy(fnstr, domain);\n\tstrcat(fnstr, \"-\");\n\tstrcat(fnstr, destpath);\n\tunsigned char fnhash[20];\n\tchar fnamehash[41];\n\tchar *p = fnamehash;\n\tsha1_of_data(fnstr, strlen(fnstr), fnhash);\n\tfree(fnstr);\n\tint i;\n\tfor ( i = 0; i < 20; i++, p += 2 ) {\n\t\tsnprintf (p, 3, \"%02x\", (unsigned char)fnhash[i] );\n\t}\n\tif (strcmp(fnamehash, hash)) {\n\t\tprintf(\"\\r\\n\");\n\t\tprintf(\"WARNING: filename hash does not match for entry '%s'\\n\", hash);\n\t}\n\n\tchar *auth_version = NULL;\n\tnode = plist_dict_get_item(mdinfo, \"AuthVersion\");\n\tif (node && (plist_get_node_type(node) == PLIST_STRING)) {\n\t\tplist_get_string_val(node, &auth_version);\n\t}\n\n\tif (strcmp(auth_version, \"1.0\")) {\n\t\tprintf(\"\\r\\n\");\n\t\tprintf(\"WARNING: Unknown AuthVersion '%s', DataHash cannot be verified!\\n\", auth_version);\n\t}\n\n\tnode = plist_dict_get_item(filedata, \"DataHash\");\n\tif (!node || (plist_get_node_type(node) != PLIST_DATA)) {\n\t\tprintf(\"\\r\\n\");\n\t\tprintf(\"WARNING: Could not get DataHash key from file info data for entry '%s'\\n\", hash);\n\t}\n\n\tint res = 1;\n\tunsigned char *data_hash = NULL;\n\tuint64_t data_hash_len = 0;\n\tplist_get_data_val(node, (char**)&data_hash, &data_hash_len);\n\tint hash_ok = 0;\n\tif (data_hash && (data_hash_len == 20)) {\n\t\tcompute_datahash(datapath, destpath, greylist, domain, NULL, version, file_hash);\n\t\thash_ok = compare_hash(data_hash, file_hash, 20);\n\t} else if (data_hash_len == 0) {\n\t\t/* no datahash present */\n\t\thash_ok = 1;\n\t}\n\n\tfree(domain);\n\tfree(version);\n\tfree(destpath);\n\n\tif (!hash_ok) {\n\t\tprintf(\"\\r\\n\");\n\t\tprintf(\"ERROR: The hash for '%s.mddata' does not match DataHash entry in Manifest\\n\", hash);\n\t\tprintf(\"datahash: \");\n\t\tprint_hash(data_hash, 20);\n\t\tprintf(\"\\nfilehash: \");\n\t\tprint_hash(file_hash, 20);\n\t\tprintf(\"\\n\");\n\t\tres = 0;\n\t}\n\tfree(data_hash);\n\tplist_free(mdinfo);\n\treturn res;\n}",
    "includes": [
      "#include <windows.h>",
      "#include \"common/utils.h\"",
      "#include <libimobiledevice/afc.h>",
      "#include <libimobiledevice/notification_proxy.h>",
      "#include <libimobiledevice/mobilebackup.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <unistd.h>",
      "#include <gcrypt.h>",
      "#include <openssl/sha.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "plist_free",
          "args": [
            "mdinfo"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "data_hash"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "thread_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "39-44",
          "snippet": "void thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nvoid thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_hash",
          "args": [
            "file_hash",
            "20"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "print_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
          "lines": "209-215",
          "snippet": "static void print_hash(const unsigned char *hash, int len)\n{\n\tint i;\n\tfor (i = 0; i < len; i++) {\n\t\tprintf(\"%02x\", hash[i]);\n\t}\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <unistd.h>",
            "#include <gcrypt.h>",
            "#include <openssl/sha.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void print_hash(const unsigned char *hash, int len)\n{\n\tint i;\n\tfor (i = 0; i < len; i++) {\n\t\tprintf(\"%02x\", hash[i]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\nfilehash: \""
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"datahash: \""
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ERROR: The hash for '%s.mddata' does not match DataHash entry in Manifest\\n\"",
            "hash"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "asprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/include/asprintf.h",
          "lines": "23-31",
          "snippet": "static inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}",
          "includes": [
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <config.h>\n\nstatic inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\r\\n\""
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compare_hash",
          "args": [
            "data_hash",
            "file_hash",
            "20"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "compare_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
          "lines": "86-95",
          "snippet": "static int compare_hash(const unsigned char *hash1, const unsigned char *hash2, int hash_len)\n{\n\tint i;\n\tfor (i = 0; i < hash_len; i++) {\n\t\tif (hash1[i] != hash2[i]) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <unistd.h>",
            "#include <gcrypt.h>",
            "#include <openssl/sha.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int compare_hash(const unsigned char *hash1, const unsigned char *hash2, int hash_len)\n{\n\tint i;\n\tfor (i = 0; i < hash_len; i++) {\n\t\tif (hash1[i] != hash2[i]) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "compute_datahash",
          "args": [
            "datapath",
            "destpath",
            "greylist",
            "domain",
            "NULL",
            "version",
            "file_hash"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "compute_datahash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
          "lines": "97-207",
          "snippet": "static void compute_datahash(const char *path, const char *destpath, uint8_t greylist, const char *domain, const char *appid, const char *version, unsigned char *hash_out)\n{\n#ifdef HAVE_OPENSSL\n\tSHA_CTX sha1;\n\tSHA1_Init(&sha1);\n#else\n\tgcry_md_hd_t hd = NULL;\n\tgcry_md_open(&hd, GCRY_MD_SHA1, 0);\n\tif (!hd) {\n\t\tprintf(\"ERROR: Could not initialize libgcrypt/SHA1\\n\");\n\t\treturn;\n\t}\n\tgcry_md_reset(hd);\n#endif\n\tFILE *f = fopen(path, \"rb\");\n\tif (f) {\n\t\tunsigned char buf[16384];\n\t\tsize_t len;\n\t\twhile ((len = fread(buf, 1, 16384, f)) > 0) {\n#ifdef HAVE_OPENSSL\n\t\t\tSHA1_Update(&sha1, buf, len);\n#else\n\t\t\tgcry_md_write(hd, buf, len);\n#endif\n\t\t}\n\t\tfclose(f);\n#ifdef HAVE_OPENSSL\n\t\tSHA1_Update(&sha1, destpath, strlen(destpath));\n\t\tSHA1_Update(&sha1, \";\", 1);\n#else\n\t\tgcry_md_write(hd, destpath, strlen(destpath));\n\t\tgcry_md_write(hd, \";\", 1);\n#endif\n\t\tif (greylist == 1) {\n#ifdef HAVE_OPENSSL\n\t\t\tSHA1_Update(&sha1, \"true\", 4);\n#else\n\t\t\tgcry_md_write(hd, \"true\", 4);\n#endif\n\t\t} else {\n#ifdef HAVE_OPENSSL\n\t\t\tSHA1_Update(&sha1, \"false\", 5);\n#else\n\t\t\tgcry_md_write(hd, \"false\", 5);\n#endif\n\t\t}\n#ifdef HAVE_OPENSSL\n\t\tSHA1_Update(&sha1, \";\", 1);\n#else\n\t\tgcry_md_write(hd, \";\", 1);\n#endif\n\t\tif (domain) {\n#ifdef HAVE_OPENSSL\n\t\t\tSHA1_Update(&sha1, domain, strlen(domain));\n#else\n\t\t\tgcry_md_write(hd, domain, strlen(domain));\n#endif\n\t\t} else {\n#ifdef HAVE_OPENSSL\n\t\t\tSHA1_Update(&sha1, \"(null)\", 6);\n#else\n\t\t\tgcry_md_write(hd, \"(null)\", 6);\n#endif\n\t\t}\n#ifdef HAVE_OPENSSL\n\t\tSHA1_Update(&sha1, \";\", 1);\n#else\n\t\tgcry_md_write(hd, \";\", 1);\n#endif\n\t\tif (appid) {\n#ifdef HAVE_OPENSSL\n\t\t\tSHA1_Update(&sha1, appid, strlen(appid));\n#else\n\t\t\tgcry_md_write(hd, appid, strlen(appid));\n#endif\n\t\t} else {\n#ifdef HAVE_OPENSSL\n\t\t\tSHA1_Update(&sha1, \"(null)\", 6);\n#else\n\t\t\tgcry_md_write(hd, \"(null)\", 6);\n#endif\n\t\t}\n#ifdef HAVE_OPENSSL\n\t\tSHA1_Update(&sha1, \";\", 1);\n#else\n\t\tgcry_md_write(hd, \";\", 1);\n#endif\n\t\tif (version) {\n#ifdef HAVE_OPENSSL\n\t\t\tSHA1_Update(&sha1, version, strlen(version));\n#else\n\t\t\tgcry_md_write(hd, version, strlen(version));\n#endif\n\t\t} else {\n#ifdef HAVE_OPENSSL\n\t\t\tSHA1_Update(&sha1, \"(null)\", 6);\n#else\n\t\t\tgcry_md_write(hd, \"(null)\", 6);\n#endif\n\t\t}\n#ifdef HAVE_OPENSSL\n\t\tSHA1_Final(hash_out, &sha1);\n#else\n\t\tunsigned char *newhash = gcry_md_read(hd, GCRY_MD_SHA1);\n\t\tmemcpy(hash_out, newhash, 20);\n#endif\n\t}\n#ifndef HAVE_OPENSSL\n\tgcry_md_close(hd);\n#endif\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <unistd.h>",
            "#include <gcrypt.h>",
            "#include <openssl/sha.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void compute_datahash(const char *path, const char *destpath, uint8_t greylist, const char *domain, const char *appid, const char *version, unsigned char *hash_out)\n{\n#ifdef HAVE_OPENSSL\n\tSHA_CTX sha1;\n\tSHA1_Init(&sha1);\n#else\n\tgcry_md_hd_t hd = NULL;\n\tgcry_md_open(&hd, GCRY_MD_SHA1, 0);\n\tif (!hd) {\n\t\tprintf(\"ERROR: Could not initialize libgcrypt/SHA1\\n\");\n\t\treturn;\n\t}\n\tgcry_md_reset(hd);\n#endif\n\tFILE *f = fopen(path, \"rb\");\n\tif (f) {\n\t\tunsigned char buf[16384];\n\t\tsize_t len;\n\t\twhile ((len = fread(buf, 1, 16384, f)) > 0) {\n#ifdef HAVE_OPENSSL\n\t\t\tSHA1_Update(&sha1, buf, len);\n#else\n\t\t\tgcry_md_write(hd, buf, len);\n#endif\n\t\t}\n\t\tfclose(f);\n#ifdef HAVE_OPENSSL\n\t\tSHA1_Update(&sha1, destpath, strlen(destpath));\n\t\tSHA1_Update(&sha1, \";\", 1);\n#else\n\t\tgcry_md_write(hd, destpath, strlen(destpath));\n\t\tgcry_md_write(hd, \";\", 1);\n#endif\n\t\tif (greylist == 1) {\n#ifdef HAVE_OPENSSL\n\t\t\tSHA1_Update(&sha1, \"true\", 4);\n#else\n\t\t\tgcry_md_write(hd, \"true\", 4);\n#endif\n\t\t} else {\n#ifdef HAVE_OPENSSL\n\t\t\tSHA1_Update(&sha1, \"false\", 5);\n#else\n\t\t\tgcry_md_write(hd, \"false\", 5);\n#endif\n\t\t}\n#ifdef HAVE_OPENSSL\n\t\tSHA1_Update(&sha1, \";\", 1);\n#else\n\t\tgcry_md_write(hd, \";\", 1);\n#endif\n\t\tif (domain) {\n#ifdef HAVE_OPENSSL\n\t\t\tSHA1_Update(&sha1, domain, strlen(domain));\n#else\n\t\t\tgcry_md_write(hd, domain, strlen(domain));\n#endif\n\t\t} else {\n#ifdef HAVE_OPENSSL\n\t\t\tSHA1_Update(&sha1, \"(null)\", 6);\n#else\n\t\t\tgcry_md_write(hd, \"(null)\", 6);\n#endif\n\t\t}\n#ifdef HAVE_OPENSSL\n\t\tSHA1_Update(&sha1, \";\", 1);\n#else\n\t\tgcry_md_write(hd, \";\", 1);\n#endif\n\t\tif (appid) {\n#ifdef HAVE_OPENSSL\n\t\t\tSHA1_Update(&sha1, appid, strlen(appid));\n#else\n\t\t\tgcry_md_write(hd, appid, strlen(appid));\n#endif\n\t\t} else {\n#ifdef HAVE_OPENSSL\n\t\t\tSHA1_Update(&sha1, \"(null)\", 6);\n#else\n\t\t\tgcry_md_write(hd, \"(null)\", 6);\n#endif\n\t\t}\n#ifdef HAVE_OPENSSL\n\t\tSHA1_Update(&sha1, \";\", 1);\n#else\n\t\tgcry_md_write(hd, \";\", 1);\n#endif\n\t\tif (version) {\n#ifdef HAVE_OPENSSL\n\t\t\tSHA1_Update(&sha1, version, strlen(version));\n#else\n\t\t\tgcry_md_write(hd, version, strlen(version));\n#endif\n\t\t} else {\n#ifdef HAVE_OPENSSL\n\t\t\tSHA1_Update(&sha1, \"(null)\", 6);\n#else\n\t\t\tgcry_md_write(hd, \"(null)\", 6);\n#endif\n\t\t}\n#ifdef HAVE_OPENSSL\n\t\tSHA1_Final(hash_out, &sha1);\n#else\n\t\tunsigned char *newhash = gcry_md_read(hd, GCRY_MD_SHA1);\n\t\tmemcpy(hash_out, newhash, 20);\n#endif\n\t}\n#ifndef HAVE_OPENSSL\n\tgcry_md_close(hd);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_get_data_val",
          "args": [
            "node",
            "(char**)&data_hash",
            "&data_hash_len"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\r\\n\""
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_node_type",
          "args": [
            "node"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "filedata",
            "\"DataHash\""
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\r\\n\""
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "auth_version",
            "\"1.0\""
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "plist_strcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
          "lines": "296-309",
          "snippet": "static int plist_strcmp(plist_t node, const char *str)\n{\n\tchar *buffer = NULL;\n\tint ret = 0;\n\n\tif (plist_get_node_type(node) != PLIST_STRING)\n\t\treturn ret;\n\n\tplist_get_string_val(node, &buffer);\n\tret = strcmp(buffer, str);\n\tfree(buffer);\n\n\treturn ret;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <unistd.h>",
            "#include <gcrypt.h>",
            "#include <openssl/sha.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int plist_strcmp(plist_t node, const char *str)\n{\n\tchar *buffer = NULL;\n\tint ret = 0;\n\n\tif (plist_get_node_type(node) != PLIST_STRING)\n\t\treturn ret;\n\n\tplist_get_string_val(node, &buffer);\n\tret = strcmp(buffer, str);\n\tfree(buffer);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_get_string_val",
          "args": [
            "node",
            "&auth_version"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_node_type",
          "args": [
            "node"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "mdinfo",
            "\"AuthVersion\""
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\r\\n\""
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "p",
            "3",
            "\"%02x\"",
            "(unsigned char)fnhash[i]"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sha1_of_data",
          "args": [
            "fnstr",
            "strlen(fnstr)",
            "fnhash"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "sha1_of_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
          "lines": "77-84",
          "snippet": "static void sha1_of_data(const char *input, uint32_t size, unsigned char *hash_out)\n{\n#ifdef HAVE_OPENSSL\n\tSHA1((const unsigned char*)input, size, hash_out);\n#else\n\tgcry_md_hash_buffer(GCRY_MD_SHA1, hash_out, input, size);\n#endif\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <unistd.h>",
            "#include <gcrypt.h>",
            "#include <openssl/sha.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void sha1_of_data(const char *input, uint32_t size, unsigned char *hash_out)\n{\n#ifdef HAVE_OPENSSL\n\tSHA1((const unsigned char*)input, size, hash_out);\n#else\n\tgcry_md_hash_buffer(GCRY_MD_SHA1, hash_out, input, size);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "fnstr"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "fnstr",
            "destpath"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "fnstr",
            "\"-\""
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fnstr",
            "domain"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(domain) + 1 + strlen(destpath) + 1"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "destpath"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "domain"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_string_val",
          "args": [
            "node",
            "&domain"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_node_type",
          "args": [
            "node"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "metadata",
            "\"Domain\""
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_bool_val",
          "args": [
            "node",
            "&greylist"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_node_type",
          "args": [
            "node"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "metadata",
            "\"Greylist\""
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_string_val",
          "args": [
            "node",
            "&destpath"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_node_type",
          "args": [
            "node"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "metadata",
            "\"Path\""
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_string_val",
          "args": [
            "node",
            "&version"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_node_type",
          "args": [
            "node"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "metadata",
            "\"Version\""
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_free",
          "args": [
            "mdinfo"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\r\\n\""
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_from_bin",
          "args": [
            "meta_bin",
            "(uint32_t)meta_bin_size",
            "&metadata"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_data_val",
          "args": [
            "node",
            "&meta_bin",
            "&meta_bin_size"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_free",
          "args": [
            "mdinfo"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\r\\n\""
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_node_type",
          "args": [
            "node"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "mdinfo",
            "\"Metadata\""
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_free",
          "args": [
            "mdinfo"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\r\\n\""
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_node_type",
          "args": [
            "node"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "filedata",
            "\"DataHash\""
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\r\\n\""
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_read_from_filename",
          "args": [
            "&mdinfo",
            "infopath"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "plist_read_from_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/utils.c",
          "lines": "245-268",
          "snippet": "int plist_read_from_filename(plist_t *plist, const char *filename)\n{\n\tchar *buffer = NULL;\n\tuint64_t length;\n\n\tif (!filename)\n\t\treturn 0;\n\n\tbuffer_read_from_filename(filename, &buffer, &length);\n\n\tif (!buffer) {\n\t\treturn 0;\n\t}\n\n\tif ((length > 8) && (memcmp(buffer, \"bplist00\", 8) == 0)) {\n\t\tplist_from_bin(buffer, length, plist);\n\t} else {\n\t\tplist_from_xml(buffer, length, plist);\n\t}\n\n\tfree(buffer);\n\n\treturn 1;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include <ctype.h>",
            "#include <inttypes.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include <ctype.h>\n#include <inttypes.h>\n#include <sys/time.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <config.h>\n\nint plist_read_from_filename(plist_t *plist, const char *filename)\n{\n\tchar *buffer = NULL;\n\tuint64_t length;\n\n\tif (!filename)\n\t\treturn 0;\n\n\tbuffer_read_from_filename(filename, &buffer, &length);\n\n\tif (!buffer) {\n\t\treturn 0;\n\t}\n\n\tif ((length > 8) && (memcmp(buffer, \"bplist00\", 8) == 0)) {\n\t\tplist_from_bin(buffer, length, plist);\n\t} else {\n\t\tplist_from_xml(buffer, length, plist);\n\t}\n\n\tfree(buffer);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mobilebackup_build_path",
          "args": [
            "backup_directory",
            "hash",
            "\".mdinfo\""
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "mobilebackup_build_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
          "lines": "311-320",
          "snippet": "static char *mobilebackup_build_path(const char *backup_directory, const char *name, const char *extension)\n{\n\tchar* filename = (char*)malloc(strlen(name)+(extension == NULL ? 0: strlen(extension))+1);\n\tstrcpy(filename, name);\n\tif (extension != NULL)\n\t\tstrcat(filename, extension);\n\tchar *path = string_build_path(backup_directory, filename, NULL);\n\tfree(filename);\n\treturn path;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <unistd.h>",
            "#include <gcrypt.h>",
            "#include <openssl/sha.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic char *mobilebackup_build_path(const char *backup_directory, const char *name, const char *extension)\n{\n\tchar* filename = (char*)malloc(strlen(name)+(extension == NULL ? 0: strlen(extension))+1);\n\tstrcpy(filename, name);\n\tif (extension != NULL)\n\t\tstrcat(filename, extension);\n\tchar *path = string_build_path(backup_directory, filename, NULL);\n\tfree(filename);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\r\\n\""
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "datapath",
            "&st"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "mobilebackup_write_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
          "lines": "322-338",
          "snippet": "static void mobilebackup_write_status(const char *path, int status)\n{\n\tstruct stat st;\n\tplist_t status_plist = plist_new_dict();\n\tplist_dict_set_item(status_plist, \"Backup Success\", plist_new_bool(status));\n\tchar *file_path = mobilebackup_build_path(path, \"Status\", \".plist\");\n\n\tif (stat(file_path, &st) == 0)\n\t\tremove(file_path);\n\n\tplist_write_to_filename(status_plist, file_path, PLIST_FORMAT_XML);\n\n\tplist_free(status_plist);\n\tstatus_plist = NULL;\n\n\tfree(file_path);\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <unistd.h>",
            "#include <gcrypt.h>",
            "#include <openssl/sha.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void mobilebackup_write_status(const char *path, int status)\n{\n\tstruct stat st;\n\tplist_t status_plist = plist_new_dict();\n\tplist_dict_set_item(status_plist, \"Backup Success\", plist_new_bool(status));\n\tchar *file_path = mobilebackup_build_path(path, \"Status\", \".plist\");\n\n\tif (stat(file_path, &st) == 0)\n\t\tremove(file_path);\n\n\tplist_write_to_filename(status_plist, file_path, PLIST_FORMAT_XML);\n\n\tplist_free(status_plist);\n\tstatus_plist = NULL;\n\n\tfree(file_path);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int mobilebackup_check_file_integrity(const char *backup_directory, const char *hash, plist_t filedata)\n{\n\tchar *datapath;\n\tchar *infopath;\n\tplist_t mdinfo = NULL;\n\tstruct stat st;\n\tunsigned char file_hash[20];\n\n\tdatapath = mobilebackup_build_path(backup_directory, hash, \".mddata\");\n\tif (stat(datapath, &st) != 0) {\n\t\tprintf(\"\\r\\n\");\n\t\tprintf(\"ERROR: '%s.mddata' is missing!\\n\", hash);\n\t\tfree(datapath);\n\t\treturn 0;\n\t}\n\n\tinfopath = mobilebackup_build_path(backup_directory, hash, \".mdinfo\");\n\tplist_read_from_filename(&mdinfo, infopath);\n\tfree(infopath);\n\tif (!mdinfo) {\n\t\tprintf(\"\\r\\n\");\n\t\tprintf(\"ERROR: '%s.mdinfo' is missing or corrupted!\\n\", hash);\n\t\tfree(datapath);\n\t\treturn 0;\n\t}\n\n\t/* sha1 hash verification */\n\tplist_t node = plist_dict_get_item(filedata, \"DataHash\");\n\tif (!node || (plist_get_node_type(node) != PLIST_DATA)) {\n\t\tprintf(\"\\r\\n\");\n\t\tprintf(\"ERROR: Could not get DataHash for file entry '%s'\\n\", hash);\n\t\tplist_free(mdinfo);\n\t\tfree(datapath);\n\t\treturn 0;\n\t}\n\n\tnode = plist_dict_get_item(mdinfo, \"Metadata\");\n\tif (!node && (plist_get_node_type(node) != PLIST_DATA)) {\n\t\tprintf(\"\\r\\n\");\n\t\tprintf(\"ERROR: Could not find Metadata in plist '%s.mdinfo'\\n\", hash);\n\t\tplist_free(mdinfo);\n\t\tfree(datapath);\n\t\treturn 0;\n\t}\n\n\tchar *meta_bin = NULL;\n\tuint64_t meta_bin_size = 0;\n\tplist_get_data_val(node, &meta_bin, &meta_bin_size);\n\tplist_t metadata = NULL;\n\tif (meta_bin) {\n\t\tplist_from_bin(meta_bin, (uint32_t)meta_bin_size, &metadata);\n\t}\n\tif (!metadata) {\n\t\tprintf(\"\\r\\n\");\n\t\tprintf(\"ERROR: Could not get Metadata from plist '%s.mdinfo'\\n\", hash);\n\t\tplist_free(mdinfo);\n\t\tfree(datapath);\n\t\treturn 0;\n\t}\n\n\tchar *version = NULL;\n\tnode = plist_dict_get_item(metadata, \"Version\");\n\tif (node && (plist_get_node_type(node) == PLIST_STRING)) {\n\t\tplist_get_string_val(node, &version);\n\t}\n\n\tchar *destpath = NULL;\n\tnode = plist_dict_get_item(metadata, \"Path\");\n\tif (node && (plist_get_node_type(node) == PLIST_STRING)) {\n\t\tplist_get_string_val(node, &destpath);\n\t}\n\n\tuint8_t greylist = 0;\n\tnode = plist_dict_get_item(metadata, \"Greylist\");\n\tif (node && (plist_get_node_type(node) == PLIST_BOOLEAN)) {\n\t\tplist_get_bool_val(node, &greylist);\n\t}\n\n\tchar *domain = NULL;\n\tnode = plist_dict_get_item(metadata, \"Domain\");\n\tif (node && (plist_get_node_type(node) == PLIST_STRING)) {\n\t\tplist_get_string_val(node, &domain);\n\t}\n\n\tchar *fnstr = malloc(strlen(domain) + 1 + strlen(destpath) + 1);\n\tstrcpy(fnstr, domain);\n\tstrcat(fnstr, \"-\");\n\tstrcat(fnstr, destpath);\n\tunsigned char fnhash[20];\n\tchar fnamehash[41];\n\tchar *p = fnamehash;\n\tsha1_of_data(fnstr, strlen(fnstr), fnhash);\n\tfree(fnstr);\n\tint i;\n\tfor ( i = 0; i < 20; i++, p += 2 ) {\n\t\tsnprintf (p, 3, \"%02x\", (unsigned char)fnhash[i] );\n\t}\n\tif (strcmp(fnamehash, hash)) {\n\t\tprintf(\"\\r\\n\");\n\t\tprintf(\"WARNING: filename hash does not match for entry '%s'\\n\", hash);\n\t}\n\n\tchar *auth_version = NULL;\n\tnode = plist_dict_get_item(mdinfo, \"AuthVersion\");\n\tif (node && (plist_get_node_type(node) == PLIST_STRING)) {\n\t\tplist_get_string_val(node, &auth_version);\n\t}\n\n\tif (strcmp(auth_version, \"1.0\")) {\n\t\tprintf(\"\\r\\n\");\n\t\tprintf(\"WARNING: Unknown AuthVersion '%s', DataHash cannot be verified!\\n\", auth_version);\n\t}\n\n\tnode = plist_dict_get_item(filedata, \"DataHash\");\n\tif (!node || (plist_get_node_type(node) != PLIST_DATA)) {\n\t\tprintf(\"\\r\\n\");\n\t\tprintf(\"WARNING: Could not get DataHash key from file info data for entry '%s'\\n\", hash);\n\t}\n\n\tint res = 1;\n\tunsigned char *data_hash = NULL;\n\tuint64_t data_hash_len = 0;\n\tplist_get_data_val(node, (char**)&data_hash, &data_hash_len);\n\tint hash_ok = 0;\n\tif (data_hash && (data_hash_len == 20)) {\n\t\tcompute_datahash(datapath, destpath, greylist, domain, NULL, version, file_hash);\n\t\thash_ok = compare_hash(data_hash, file_hash, 20);\n\t} else if (data_hash_len == 0) {\n\t\t/* no datahash present */\n\t\thash_ok = 1;\n\t}\n\n\tfree(domain);\n\tfree(version);\n\tfree(destpath);\n\n\tif (!hash_ok) {\n\t\tprintf(\"\\r\\n\");\n\t\tprintf(\"ERROR: The hash for '%s.mddata' does not match DataHash entry in Manifest\\n\", hash);\n\t\tprintf(\"datahash: \");\n\t\tprint_hash(data_hash, 20);\n\t\tprintf(\"\\nfilehash: \");\n\t\tprint_hash(file_hash, 20);\n\t\tprintf(\"\\n\");\n\t\tres = 0;\n\t}\n\tfree(data_hash);\n\tplist_free(mdinfo);\n\treturn res;\n}"
  },
  {
    "function_name": "mobilebackup_delete_backup_file_by_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
    "lines": "425-450",
    "snippet": "static int mobilebackup_delete_backup_file_by_hash(const char *backup_directory, const char *hash)\n{\n\tint ret = 0;\n\tchar *path = mobilebackup_build_path(backup_directory, hash, \".mddata\");\n\tprintf(\"Removing \\\"%s\\\" \", path);\n\tif (!remove( path ))\n\t\tret = 1;\n\telse\n\t\tret = 0;\n\n\tfree(path);\n\n\tif (!ret)\n\t\treturn ret;\n\n\tpath = mobilebackup_build_path(backup_directory, hash, \".mdinfo\");\n\tprintf(\"and \\\"%s\\\"... \", path);\n\tif (!remove( path ))\n\t\tret = 1;\n\telse\n\t\tret = 0;\n\n\tfree(path);\n\n\treturn ret;\n}",
    "includes": [
      "#include <windows.h>",
      "#include \"common/utils.h\"",
      "#include <libimobiledevice/afc.h>",
      "#include <libimobiledevice/notification_proxy.h>",
      "#include <libimobiledevice/mobilebackup.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <unistd.h>",
      "#include <gcrypt.h>",
      "#include <openssl/sha.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "path"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "thread_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "39-44",
          "snippet": "void thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nvoid thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove",
          "args": [
            "path"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "str_remove_spaces",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/lockdown.c",
          "lines": "1443-1453",
          "snippet": "static void str_remove_spaces(char *source)\n{\n\tchar *dest = source;\n\twhile (*source != 0) {\n\t\tif (!isspace(*source)) {\n\t\t\t*dest++ = *source; /* copy */\n\t\t}\n\t\tsource++;\n\t}\n\t*dest = 0;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/userpref.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"lockdown.h\"",
            "#include \"property_list_service.h\"",
            "#include <plist/plist.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/x509.h>",
            "#include <libtasn1.h>",
            "#include <openssl/x509v3.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/pem.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/userpref.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"lockdown.h\"\n#include \"property_list_service.h\"\n#include <plist/plist.h>\n#include <gnutls/crypto.h>\n#include <gnutls/x509.h>\n#include <libtasn1.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/pem.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nstatic void str_remove_spaces(char *source)\n{\n\tchar *dest = source;\n\twhile (*source != 0) {\n\t\tif (!isspace(*source)) {\n\t\t\t*dest++ = *source; /* copy */\n\t\t}\n\t\tsource++;\n\t}\n\t*dest = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"and \\\"%s\\\"... \"",
            "path"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "asprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/include/asprintf.h",
          "lines": "23-31",
          "snippet": "static inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}",
          "includes": [
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <config.h>\n\nstatic inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mobilebackup_build_path",
          "args": [
            "backup_directory",
            "hash",
            "\".mdinfo\""
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "mobilebackup_build_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
          "lines": "311-320",
          "snippet": "static char *mobilebackup_build_path(const char *backup_directory, const char *name, const char *extension)\n{\n\tchar* filename = (char*)malloc(strlen(name)+(extension == NULL ? 0: strlen(extension))+1);\n\tstrcpy(filename, name);\n\tif (extension != NULL)\n\t\tstrcat(filename, extension);\n\tchar *path = string_build_path(backup_directory, filename, NULL);\n\tfree(filename);\n\treturn path;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <unistd.h>",
            "#include <gcrypt.h>",
            "#include <openssl/sha.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic char *mobilebackup_build_path(const char *backup_directory, const char *name, const char *extension)\n{\n\tchar* filename = (char*)malloc(strlen(name)+(extension == NULL ? 0: strlen(extension))+1);\n\tstrcpy(filename, name);\n\tif (extension != NULL)\n\t\tstrcat(filename, extension);\n\tchar *path = string_build_path(backup_directory, filename, NULL);\n\tfree(filename);\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int mobilebackup_delete_backup_file_by_hash(const char *backup_directory, const char *hash)\n{\n\tint ret = 0;\n\tchar *path = mobilebackup_build_path(backup_directory, hash, \".mddata\");\n\tprintf(\"Removing \\\"%s\\\" \", path);\n\tif (!remove( path ))\n\t\tret = 1;\n\telse\n\t\tret = 0;\n\n\tfree(path);\n\n\tif (!ret)\n\t\treturn ret;\n\n\tpath = mobilebackup_build_path(backup_directory, hash, \".mdinfo\");\n\tprintf(\"and \\\"%s\\\"... \", path);\n\tif (!remove( path ))\n\t\tret = 1;\n\telse\n\t\tret = 0;\n\n\tfree(path);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "mobilebackup_info_is_current_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
    "lines": "364-423",
    "snippet": "static int mobilebackup_info_is_current_device(plist_t info)\n{\n\tplist_t value_node = NULL;\n\tplist_t node = NULL;\n\tplist_t root_node = NULL;\n\tint ret = 0;\n\n\tif (!info)\n\t\treturn ret;\n\n\tif (plist_get_node_type(info) != PLIST_DICT)\n\t\treturn ret;\n\n\t/* get basic device information in one go */\n\tlockdownd_get_value(client, NULL, NULL, &root_node);\n\n\t/* verify UDID */\n\tvalue_node = plist_dict_get_item(root_node, \"UniqueDeviceID\");\n\tnode = plist_dict_get_item(info, \"Target Identifier\");\n\n\tif(plist_compare_node_value(value_node, node))\n\t\tret = 1;\n\telse {\n\t\tprintf(\"Info.plist: UniqueDeviceID does not match.\\n\");\n\t}\n\n\t/* verify SerialNumber */\n\tif (ret == 1) {\n\t\tvalue_node = plist_dict_get_item(root_node, \"SerialNumber\");\n\t\tnode = plist_dict_get_item(info, \"Serial Number\");\n\n\t\tif(plist_compare_node_value(value_node, node))\n\t\t\tret = 1;\n\t\telse {\n\t\t\tprintf(\"Info.plist: SerialNumber does not match.\\n\");\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\t/* verify ProductVersion to prevent using backup with different OS version */\n\tif (ret == 1) {\n\t\tvalue_node = plist_dict_get_item(root_node, \"ProductVersion\");\n\t\tnode = plist_dict_get_item(info, \"Product Version\");\n\n\t\tif(plist_compare_node_value(value_node, node))\n\t\t\tret = 1;\n\t\telse {\n\t\t\tprintf(\"Info.plist: ProductVersion does not match.\\n\");\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\tplist_free(root_node);\n\troot_node = NULL;\n\n\tvalue_node = NULL;\n\tnode = NULL;\n\n\treturn ret;\n}",
    "includes": [
      "#include <windows.h>",
      "#include \"common/utils.h\"",
      "#include <libimobiledevice/afc.h>",
      "#include <libimobiledevice/notification_proxy.h>",
      "#include <libimobiledevice/mobilebackup.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <unistd.h>",
      "#include <gcrypt.h>",
      "#include <openssl/sha.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static lockdownd_client_t client = NULL;",
      "static idevice_t device = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "plist_free",
          "args": [
            "root_node"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Info.plist: ProductVersion does not match.\\n\""
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_compare_node_value",
          "args": [
            "value_node",
            "node"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "info",
            "\"Product Version\""
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "root_node",
            "\"ProductVersion\""
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Info.plist: SerialNumber does not match.\\n\""
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_compare_node_value",
          "args": [
            "value_node",
            "node"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "info",
            "\"Serial Number\""
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "root_node",
            "\"SerialNumber\""
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Info.plist: UniqueDeviceID does not match.\\n\""
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_compare_node_value",
          "args": [
            "value_node",
            "node"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "info",
            "\"Target Identifier\""
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "root_node",
            "\"UniqueDeviceID\""
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdownd_get_value",
          "args": [
            "client",
            "NULL",
            "NULL",
            "&root_node"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "lockdownd_get_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/lockdown.c",
          "lines": "426-478",
          "snippet": "LIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_get_value(lockdownd_client_t client, const char *domain, const char *key, plist_t *value)\n{\n\tif (!client)\n\t\treturn LOCKDOWN_E_INVALID_ARG;\n\n\tplist_t dict = NULL;\n\tlockdownd_error_t ret = LOCKDOWN_E_UNKNOWN_ERROR;\n\n\t/* setup request plist */\n\tdict = plist_new_dict();\n\tplist_dict_add_label(dict, client->label);\n\tif (domain) {\n\t\tplist_dict_set_item(dict,\"Domain\", plist_new_string(domain));\n\t}\n\tif (key) {\n\t\tplist_dict_set_item(dict,\"Key\", plist_new_string(key));\n\t}\n\tplist_dict_set_item(dict,\"Request\", plist_new_string(\"GetValue\"));\n\n\t/* send to device */\n\tret = lockdownd_send(client, dict);\n\n\tplist_free(dict);\n\tdict = NULL;\n\n\tif (ret != LOCKDOWN_E_SUCCESS)\n\t\treturn ret;\n\n\t/* Now get device's answer */\n\tret = lockdownd_receive(client, &dict);\n\tif (ret != LOCKDOWN_E_SUCCESS)\n\t\treturn ret;\n\n\tret = lockdown_check_result(dict, \"GetValue\");\n\tif (ret == LOCKDOWN_E_SUCCESS) {\n\t\tdebug_info(\"success\");\n\t}\n\n\tif (ret != LOCKDOWN_E_SUCCESS) {\n\t\tplist_free(dict);\n\t\treturn ret;\n\t}\n\n\tplist_t value_node = plist_dict_get_item(dict, \"Value\");\n\n\tif (value_node) {\n\t\tdebug_info(\"has a value\");\n\t\t*value = plist_copy(value_node);\n\t}\n\n\tplist_free(dict);\n\treturn ret;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/userpref.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"lockdown.h\"",
            "#include \"property_list_service.h\"",
            "#include <plist/plist.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/x509.h>",
            "#include <libtasn1.h>",
            "#include <openssl/x509v3.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/pem.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/userpref.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"lockdown.h\"\n#include \"property_list_service.h\"\n#include <plist/plist.h>\n#include <gnutls/crypto.h>\n#include <gnutls/x509.h>\n#include <libtasn1.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/pem.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_get_value(lockdownd_client_t client, const char *domain, const char *key, plist_t *value)\n{\n\tif (!client)\n\t\treturn LOCKDOWN_E_INVALID_ARG;\n\n\tplist_t dict = NULL;\n\tlockdownd_error_t ret = LOCKDOWN_E_UNKNOWN_ERROR;\n\n\t/* setup request plist */\n\tdict = plist_new_dict();\n\tplist_dict_add_label(dict, client->label);\n\tif (domain) {\n\t\tplist_dict_set_item(dict,\"Domain\", plist_new_string(domain));\n\t}\n\tif (key) {\n\t\tplist_dict_set_item(dict,\"Key\", plist_new_string(key));\n\t}\n\tplist_dict_set_item(dict,\"Request\", plist_new_string(\"GetValue\"));\n\n\t/* send to device */\n\tret = lockdownd_send(client, dict);\n\n\tplist_free(dict);\n\tdict = NULL;\n\n\tif (ret != LOCKDOWN_E_SUCCESS)\n\t\treturn ret;\n\n\t/* Now get device's answer */\n\tret = lockdownd_receive(client, &dict);\n\tif (ret != LOCKDOWN_E_SUCCESS)\n\t\treturn ret;\n\n\tret = lockdown_check_result(dict, \"GetValue\");\n\tif (ret == LOCKDOWN_E_SUCCESS) {\n\t\tdebug_info(\"success\");\n\t}\n\n\tif (ret != LOCKDOWN_E_SUCCESS) {\n\t\tplist_free(dict);\n\t\treturn ret;\n\t}\n\n\tplist_t value_node = plist_dict_get_item(dict, \"Value\");\n\n\tif (value_node) {\n\t\tdebug_info(\"has a value\");\n\t\t*value = plist_copy(value_node);\n\t}\n\n\tplist_free(dict);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_get_node_type",
          "args": [
            "info"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic lockdownd_client_t client = NULL;\nstatic idevice_t device = NULL;\n\nstatic int mobilebackup_info_is_current_device(plist_t info)\n{\n\tplist_t value_node = NULL;\n\tplist_t node = NULL;\n\tplist_t root_node = NULL;\n\tint ret = 0;\n\n\tif (!info)\n\t\treturn ret;\n\n\tif (plist_get_node_type(info) != PLIST_DICT)\n\t\treturn ret;\n\n\t/* get basic device information in one go */\n\tlockdownd_get_value(client, NULL, NULL, &root_node);\n\n\t/* verify UDID */\n\tvalue_node = plist_dict_get_item(root_node, \"UniqueDeviceID\");\n\tnode = plist_dict_get_item(info, \"Target Identifier\");\n\n\tif(plist_compare_node_value(value_node, node))\n\t\tret = 1;\n\telse {\n\t\tprintf(\"Info.plist: UniqueDeviceID does not match.\\n\");\n\t}\n\n\t/* verify SerialNumber */\n\tif (ret == 1) {\n\t\tvalue_node = plist_dict_get_item(root_node, \"SerialNumber\");\n\t\tnode = plist_dict_get_item(info, \"Serial Number\");\n\n\t\tif(plist_compare_node_value(value_node, node))\n\t\t\tret = 1;\n\t\telse {\n\t\t\tprintf(\"Info.plist: SerialNumber does not match.\\n\");\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\t/* verify ProductVersion to prevent using backup with different OS version */\n\tif (ret == 1) {\n\t\tvalue_node = plist_dict_get_item(root_node, \"ProductVersion\");\n\t\tnode = plist_dict_get_item(info, \"Product Version\");\n\n\t\tif(plist_compare_node_value(value_node, node))\n\t\t\tret = 1;\n\t\telse {\n\t\t\tprintf(\"Info.plist: ProductVersion does not match.\\n\");\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\tplist_free(root_node);\n\troot_node = NULL;\n\n\tvalue_node = NULL;\n\tnode = NULL;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "mobilebackup_read_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
    "lines": "340-362",
    "snippet": "static int mobilebackup_read_status(const char *path)\n{\n\tint ret = -1;\n\tplist_t status_plist = NULL;\n\tchar *file_path = mobilebackup_build_path(path, \"Status\", \".plist\");\n\n\tplist_read_from_filename(&status_plist, file_path);\n\tfree(file_path);\n\tif (!status_plist) {\n\t\tprintf(\"Could not read Status.plist!\\n\");\n\t\treturn ret;\n\t}\n\tplist_t node = plist_dict_get_item(status_plist, \"Backup Success\");\n\tif (node && (plist_get_node_type(node) == PLIST_BOOLEAN)) {\n\t\tuint8_t bval = 0;\n\t\tplist_get_bool_val(node, &bval);\n\t\tret = bval;\n\t} else {\n\t\tprintf(\"%s: ERROR could not get Backup Success key from Status.plist!\\n\", __func__);\n\t}\n\tplist_free(status_plist);\n\treturn ret;\n}",
    "includes": [
      "#include <windows.h>",
      "#include \"common/utils.h\"",
      "#include <libimobiledevice/afc.h>",
      "#include <libimobiledevice/notification_proxy.h>",
      "#include <libimobiledevice/mobilebackup.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <unistd.h>",
      "#include <gcrypt.h>",
      "#include <openssl/sha.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "plist_free",
          "args": [
            "status_plist"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: ERROR could not get Backup Success key from Status.plist!\\n\"",
            "__func__"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "asprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/include/asprintf.h",
          "lines": "23-31",
          "snippet": "static inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}",
          "includes": [
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <config.h>\n\nstatic inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_get_bool_val",
          "args": [
            "node",
            "&bval"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_node_type",
          "args": [
            "node"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "status_plist",
            "\"Backup Success\""
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Could not read Status.plist!\\n\""
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "file_path"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "thread_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "39-44",
          "snippet": "void thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nvoid thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_read_from_filename",
          "args": [
            "&status_plist",
            "file_path"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "plist_read_from_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/utils.c",
          "lines": "245-268",
          "snippet": "int plist_read_from_filename(plist_t *plist, const char *filename)\n{\n\tchar *buffer = NULL;\n\tuint64_t length;\n\n\tif (!filename)\n\t\treturn 0;\n\n\tbuffer_read_from_filename(filename, &buffer, &length);\n\n\tif (!buffer) {\n\t\treturn 0;\n\t}\n\n\tif ((length > 8) && (memcmp(buffer, \"bplist00\", 8) == 0)) {\n\t\tplist_from_bin(buffer, length, plist);\n\t} else {\n\t\tplist_from_xml(buffer, length, plist);\n\t}\n\n\tfree(buffer);\n\n\treturn 1;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include <ctype.h>",
            "#include <inttypes.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include <ctype.h>\n#include <inttypes.h>\n#include <sys/time.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <config.h>\n\nint plist_read_from_filename(plist_t *plist, const char *filename)\n{\n\tchar *buffer = NULL;\n\tuint64_t length;\n\n\tif (!filename)\n\t\treturn 0;\n\n\tbuffer_read_from_filename(filename, &buffer, &length);\n\n\tif (!buffer) {\n\t\treturn 0;\n\t}\n\n\tif ((length > 8) && (memcmp(buffer, \"bplist00\", 8) == 0)) {\n\t\tplist_from_bin(buffer, length, plist);\n\t} else {\n\t\tplist_from_xml(buffer, length, plist);\n\t}\n\n\tfree(buffer);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mobilebackup_build_path",
          "args": [
            "path",
            "\"Status\"",
            "\".plist\""
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "mobilebackup_build_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
          "lines": "311-320",
          "snippet": "static char *mobilebackup_build_path(const char *backup_directory, const char *name, const char *extension)\n{\n\tchar* filename = (char*)malloc(strlen(name)+(extension == NULL ? 0: strlen(extension))+1);\n\tstrcpy(filename, name);\n\tif (extension != NULL)\n\t\tstrcat(filename, extension);\n\tchar *path = string_build_path(backup_directory, filename, NULL);\n\tfree(filename);\n\treturn path;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <unistd.h>",
            "#include <gcrypt.h>",
            "#include <openssl/sha.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic char *mobilebackup_build_path(const char *backup_directory, const char *name, const char *extension)\n{\n\tchar* filename = (char*)malloc(strlen(name)+(extension == NULL ? 0: strlen(extension))+1);\n\tstrcpy(filename, name);\n\tif (extension != NULL)\n\t\tstrcat(filename, extension);\n\tchar *path = string_build_path(backup_directory, filename, NULL);\n\tfree(filename);\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int mobilebackup_read_status(const char *path)\n{\n\tint ret = -1;\n\tplist_t status_plist = NULL;\n\tchar *file_path = mobilebackup_build_path(path, \"Status\", \".plist\");\n\n\tplist_read_from_filename(&status_plist, file_path);\n\tfree(file_path);\n\tif (!status_plist) {\n\t\tprintf(\"Could not read Status.plist!\\n\");\n\t\treturn ret;\n\t}\n\tplist_t node = plist_dict_get_item(status_plist, \"Backup Success\");\n\tif (node && (plist_get_node_type(node) == PLIST_BOOLEAN)) {\n\t\tuint8_t bval = 0;\n\t\tplist_get_bool_val(node, &bval);\n\t\tret = bval;\n\t} else {\n\t\tprintf(\"%s: ERROR could not get Backup Success key from Status.plist!\\n\", __func__);\n\t}\n\tplist_free(status_plist);\n\treturn ret;\n}"
  },
  {
    "function_name": "mobilebackup_write_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
    "lines": "322-338",
    "snippet": "static void mobilebackup_write_status(const char *path, int status)\n{\n\tstruct stat st;\n\tplist_t status_plist = plist_new_dict();\n\tplist_dict_set_item(status_plist, \"Backup Success\", plist_new_bool(status));\n\tchar *file_path = mobilebackup_build_path(path, \"Status\", \".plist\");\n\n\tif (stat(file_path, &st) == 0)\n\t\tremove(file_path);\n\n\tplist_write_to_filename(status_plist, file_path, PLIST_FORMAT_XML);\n\n\tplist_free(status_plist);\n\tstatus_plist = NULL;\n\n\tfree(file_path);\n}",
    "includes": [
      "#include <windows.h>",
      "#include \"common/utils.h\"",
      "#include <libimobiledevice/afc.h>",
      "#include <libimobiledevice/notification_proxy.h>",
      "#include <libimobiledevice/mobilebackup.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <unistd.h>",
      "#include <gcrypt.h>",
      "#include <openssl/sha.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "file_path"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "thread_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "39-44",
          "snippet": "void thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nvoid thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_free",
          "args": [
            "status_plist"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_write_to_filename",
          "args": [
            "status_plist",
            "file_path",
            "PLIST_FORMAT_XML"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "plist_write_to_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/utils.c",
          "lines": "270-290",
          "snippet": "int plist_write_to_filename(plist_t plist, const char *filename, enum plist_format_t format)\n{\n\tchar *buffer = NULL;\n\tuint32_t length;\n\n\tif (!plist || !filename)\n\t\treturn 0;\n\n\tif (format == PLIST_FORMAT_XML)\n\t\tplist_to_xml(plist, &buffer, &length);\n\telse if (format == PLIST_FORMAT_BINARY)\n\t\tplist_to_bin(plist, &buffer, &length);\n\telse\n\t\treturn 0;\n\n\tbuffer_write_to_filename(filename, buffer, length);\n\n\tfree(buffer);\n\n\treturn 1;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include <ctype.h>",
            "#include <inttypes.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include <ctype.h>\n#include <inttypes.h>\n#include <sys/time.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <config.h>\n\nint plist_write_to_filename(plist_t plist, const char *filename, enum plist_format_t format)\n{\n\tchar *buffer = NULL;\n\tuint32_t length;\n\n\tif (!plist || !filename)\n\t\treturn 0;\n\n\tif (format == PLIST_FORMAT_XML)\n\t\tplist_to_xml(plist, &buffer, &length);\n\telse if (format == PLIST_FORMAT_BINARY)\n\t\tplist_to_bin(plist, &buffer, &length);\n\telse\n\t\treturn 0;\n\n\tbuffer_write_to_filename(filename, buffer, length);\n\n\tfree(buffer);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove",
          "args": [
            "file_path"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "str_remove_spaces",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/lockdown.c",
          "lines": "1443-1453",
          "snippet": "static void str_remove_spaces(char *source)\n{\n\tchar *dest = source;\n\twhile (*source != 0) {\n\t\tif (!isspace(*source)) {\n\t\t\t*dest++ = *source; /* copy */\n\t\t}\n\t\tsource++;\n\t}\n\t*dest = 0;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/userpref.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"lockdown.h\"",
            "#include \"property_list_service.h\"",
            "#include <plist/plist.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/x509.h>",
            "#include <libtasn1.h>",
            "#include <openssl/x509v3.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/pem.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/userpref.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"lockdown.h\"\n#include \"property_list_service.h\"\n#include <plist/plist.h>\n#include <gnutls/crypto.h>\n#include <gnutls/x509.h>\n#include <libtasn1.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/pem.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nstatic void str_remove_spaces(char *source)\n{\n\tchar *dest = source;\n\twhile (*source != 0) {\n\t\tif (!isspace(*source)) {\n\t\t\t*dest++ = *source; /* copy */\n\t\t}\n\t\tsource++;\n\t}\n\t*dest = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "file_path",
            "&st"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "mobilebackup_write_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
          "lines": "322-338",
          "snippet": "static void mobilebackup_write_status(const char *path, int status)\n{\n\tstruct stat st;\n\tplist_t status_plist = plist_new_dict();\n\tplist_dict_set_item(status_plist, \"Backup Success\", plist_new_bool(status));\n\tchar *file_path = mobilebackup_build_path(path, \"Status\", \".plist\");\n\n\tif (stat(file_path, &st) == 0)\n\t\tremove(file_path);\n\n\tplist_write_to_filename(status_plist, file_path, PLIST_FORMAT_XML);\n\n\tplist_free(status_plist);\n\tstatus_plist = NULL;\n\n\tfree(file_path);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "mobilebackup_build_path",
          "args": [
            "path",
            "\"Status\"",
            "\".plist\""
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "mobilebackup_build_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
          "lines": "311-320",
          "snippet": "static char *mobilebackup_build_path(const char *backup_directory, const char *name, const char *extension)\n{\n\tchar* filename = (char*)malloc(strlen(name)+(extension == NULL ? 0: strlen(extension))+1);\n\tstrcpy(filename, name);\n\tif (extension != NULL)\n\t\tstrcat(filename, extension);\n\tchar *path = string_build_path(backup_directory, filename, NULL);\n\tfree(filename);\n\treturn path;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <unistd.h>",
            "#include <gcrypt.h>",
            "#include <openssl/sha.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic char *mobilebackup_build_path(const char *backup_directory, const char *name, const char *extension)\n{\n\tchar* filename = (char*)malloc(strlen(name)+(extension == NULL ? 0: strlen(extension))+1);\n\tstrcpy(filename, name);\n\tif (extension != NULL)\n\t\tstrcat(filename, extension);\n\tchar *path = string_build_path(backup_directory, filename, NULL);\n\tfree(filename);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "status_plist",
            "\"Backup Success\"",
            "plist_new_bool(status)"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_bool",
          "args": [
            "status"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_dict",
          "args": [],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void mobilebackup_write_status(const char *path, int status)\n{\n\tstruct stat st;\n\tplist_t status_plist = plist_new_dict();\n\tplist_dict_set_item(status_plist, \"Backup Success\", plist_new_bool(status));\n\tchar *file_path = mobilebackup_build_path(path, \"Status\", \".plist\");\n\n\tif (stat(file_path, &st) == 0)\n\t\tremove(file_path);\n\n\tplist_write_to_filename(status_plist, file_path, PLIST_FORMAT_XML);\n\n\tplist_free(status_plist);\n\tstatus_plist = NULL;\n\n\tfree(file_path);\n}"
  },
  {
    "function_name": "mobilebackup_build_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
    "lines": "311-320",
    "snippet": "static char *mobilebackup_build_path(const char *backup_directory, const char *name, const char *extension)\n{\n\tchar* filename = (char*)malloc(strlen(name)+(extension == NULL ? 0: strlen(extension))+1);\n\tstrcpy(filename, name);\n\tif (extension != NULL)\n\t\tstrcat(filename, extension);\n\tchar *path = string_build_path(backup_directory, filename, NULL);\n\tfree(filename);\n\treturn path;\n}",
    "includes": [
      "#include <windows.h>",
      "#include \"common/utils.h\"",
      "#include <libimobiledevice/afc.h>",
      "#include <libimobiledevice/notification_proxy.h>",
      "#include <libimobiledevice/mobilebackup.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <unistd.h>",
      "#include <gcrypt.h>",
      "#include <openssl/sha.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "filename"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "thread_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "39-44",
          "snippet": "void thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nvoid thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "string_build_path",
          "args": [
            "backup_directory",
            "filename",
            "NULL"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "string_build_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/utils.c",
          "lines": "114-140",
          "snippet": "char *string_build_path(const char *elem, ...)\n{\n\tif (!elem)\n\t\treturn NULL;\n\tva_list args;\n\tint len = strlen(elem)+1;\n\tva_start(args, elem);\n\tchar *arg = va_arg(args, char*);\n\twhile (arg) {\n\t\tlen += strlen(arg)+1;\n\t\targ = va_arg(args, char*);\n\t}\n\tva_end(args);\n\n\tchar* out = (char*)malloc(len);\n\tstrcpy(out, elem);\n\n\tva_start(args, elem);\n\targ = va_arg(args, char*);\n\twhile (arg) {\n\t\tstrcat(out, \"/\");\n\t\tstrcat(out, arg);\n\t\targ = va_arg(args, char*);\n\t}\n\tva_end(args);\n\treturn out;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include <ctype.h>",
            "#include <inttypes.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include <ctype.h>\n#include <inttypes.h>\n#include <sys/time.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <config.h>\n\nchar *string_build_path(const char *elem, ...)\n{\n\tif (!elem)\n\t\treturn NULL;\n\tva_list args;\n\tint len = strlen(elem)+1;\n\tva_start(args, elem);\n\tchar *arg = va_arg(args, char*);\n\twhile (arg) {\n\t\tlen += strlen(arg)+1;\n\t\targ = va_arg(args, char*);\n\t}\n\tva_end(args);\n\n\tchar* out = (char*)malloc(len);\n\tstrcpy(out, elem);\n\n\tva_start(args, elem);\n\targ = va_arg(args, char*);\n\twhile (arg) {\n\t\tstrcat(out, \"/\");\n\t\tstrcat(out, arg);\n\t\targ = va_arg(args, char*);\n\t}\n\tva_end(args);\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "filename",
            "extension"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "filename",
            "name"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(name)+(extension == NULL ? 0: strlen(extension))+1"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "extension"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic char *mobilebackup_build_path(const char *backup_directory, const char *name, const char *extension)\n{\n\tchar* filename = (char*)malloc(strlen(name)+(extension == NULL ? 0: strlen(extension))+1);\n\tstrcpy(filename, name);\n\tif (extension != NULL)\n\t\tstrcat(filename, extension);\n\tchar *path = string_build_path(backup_directory, filename, NULL);\n\tfree(filename);\n\treturn path;\n}"
  },
  {
    "function_name": "plist_strcmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
    "lines": "296-309",
    "snippet": "static int plist_strcmp(plist_t node, const char *str)\n{\n\tchar *buffer = NULL;\n\tint ret = 0;\n\n\tif (plist_get_node_type(node) != PLIST_STRING)\n\t\treturn ret;\n\n\tplist_get_string_val(node, &buffer);\n\tret = strcmp(buffer, str);\n\tfree(buffer);\n\n\treturn ret;\n}",
    "includes": [
      "#include <windows.h>",
      "#include \"common/utils.h\"",
      "#include <libimobiledevice/afc.h>",
      "#include <libimobiledevice/notification_proxy.h>",
      "#include <libimobiledevice/mobilebackup.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <unistd.h>",
      "#include <gcrypt.h>",
      "#include <openssl/sha.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "buffer"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "thread_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "39-44",
          "snippet": "void thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nvoid thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "buffer",
            "str"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "plist_strcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
          "lines": "296-309",
          "snippet": "static int plist_strcmp(plist_t node, const char *str)\n{\n\tchar *buffer = NULL;\n\tint ret = 0;\n\n\tif (plist_get_node_type(node) != PLIST_STRING)\n\t\treturn ret;\n\n\tplist_get_string_val(node, &buffer);\n\tret = strcmp(buffer, str);\n\tfree(buffer);\n\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "plist_get_string_val",
          "args": [
            "node",
            "&buffer"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_node_type",
          "args": [
            "node"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int plist_strcmp(plist_t node, const char *str)\n{\n\tchar *buffer = NULL;\n\tint ret = 0;\n\n\tif (plist_get_node_type(node) != PLIST_STRING)\n\t\treturn ret;\n\n\tplist_get_string_val(node, &buffer);\n\tret = strcmp(buffer, str);\n\tfree(buffer);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "mobilebackup_info_update_last_backup_date",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
    "lines": "283-294",
    "snippet": "static void mobilebackup_info_update_last_backup_date(plist_t info_plist)\n{\n\tplist_t node = NULL;\n\n\tif (!info_plist)\n\t\treturn;\n\n\tnode = plist_dict_get_item(info_plist, \"Last Backup Date\");\n\tplist_set_date_val(node, time(NULL), 0);\n\n\tnode = NULL;\n}",
    "includes": [
      "#include <windows.h>",
      "#include \"common/utils.h\"",
      "#include <libimobiledevice/afc.h>",
      "#include <libimobiledevice/notification_proxy.h>",
      "#include <libimobiledevice/mobilebackup.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <unistd.h>",
      "#include <gcrypt.h>",
      "#include <openssl/sha.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "plist_set_date_val",
          "args": [
            "node",
            "time(NULL)",
            "0"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "info_plist",
            "\"Last Backup Date\""
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void mobilebackup_info_update_last_backup_date(plist_t info_plist)\n{\n\tplist_t node = NULL;\n\n\tif (!info_plist)\n\t\treturn;\n\n\tnode = plist_dict_get_item(info_plist, \"Last Backup Date\");\n\tplist_set_date_val(node, time(NULL), 0);\n\n\tnode = NULL;\n}"
  },
  {
    "function_name": "mobilebackup_factory_info_plist_new",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
    "lines": "227-281",
    "snippet": "static plist_t mobilebackup_factory_info_plist_new(const char* udid)\n{\n\t/* gather data from lockdown */\n\tplist_t value_node = NULL;\n\tplist_t root_node = NULL;\n\tchar *udid_uppercase = NULL;\n\n\tplist_t ret = plist_new_dict();\n\n\t/* get basic device information in one go */\n\tlockdownd_get_value(client, NULL, NULL, &root_node);\n\n\t/* set fields we understand */\n\tvalue_node = plist_dict_get_item(root_node, \"BuildVersion\");\n\tplist_dict_set_item(ret, \"Build Version\", plist_copy(value_node));\n\n\tvalue_node = plist_dict_get_item(root_node, \"DeviceName\");\n\tplist_dict_set_item(ret, \"Device Name\", plist_copy(value_node));\n\tplist_dict_set_item(ret, \"Display Name\", plist_copy(value_node));\n\n\t/* FIXME: How is the GUID generated? */\n\tplist_dict_set_item(ret, \"GUID\", plist_new_string(\"---\"));\n\n\tvalue_node = plist_dict_get_item(root_node, \"InternationalMobileEquipmentIdentity\");\n\tif (value_node)\n\t\tplist_dict_set_item(ret, \"IMEI\", plist_copy(value_node));\n\n\tplist_dict_set_item(ret, \"Last Backup Date\", plist_new_date(time(NULL), 0));\n\n\tvalue_node = plist_dict_get_item(root_node, \"ProductType\");\n\tplist_dict_set_item(ret, \"Product Type\", plist_copy(value_node));\n\n\tvalue_node = plist_dict_get_item(root_node, \"ProductVersion\");\n\tplist_dict_set_item(ret, \"Product Version\", plist_copy(value_node));\n\n\tvalue_node = plist_dict_get_item(root_node, \"SerialNumber\");\n\tplist_dict_set_item(ret, \"Serial Number\", plist_copy(value_node));\n\n\tvalue_node = plist_dict_get_item(root_node, \"UniqueDeviceID\");\n\tplist_dict_set_item(ret, \"Target Identifier\", plist_new_string(udid));\n\n\t/* uppercase */\n\tudid_uppercase = string_toupper((char*)udid);\n\tplist_dict_set_item(ret, \"Unique Identifier\", plist_new_string(udid_uppercase));\n\tfree(udid_uppercase);\n\n\t/* FIXME: Embed files as <data> nodes */\n\tplist_t files = plist_new_dict();\n\tplist_dict_set_item(ret, \"iTunes Files\", files);\n\tplist_dict_set_item(ret, \"iTunes Version\", plist_new_string(\"9.0.2\"));\n\n\tplist_free(root_node);\n\n\treturn ret;\n}",
    "includes": [
      "#include <windows.h>",
      "#include \"common/utils.h\"",
      "#include <libimobiledevice/afc.h>",
      "#include <libimobiledevice/notification_proxy.h>",
      "#include <libimobiledevice/mobilebackup.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <unistd.h>",
      "#include <gcrypt.h>",
      "#include <openssl/sha.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static lockdownd_client_t client = NULL;",
      "static idevice_t device = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "plist_free",
          "args": [
            "root_node"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "ret",
            "\"iTunes Version\"",
            "plist_new_string(\"9.0.2\")"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_string",
          "args": [
            "\"9.0.2\""
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "ret",
            "\"iTunes Files\"",
            "files"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_dict",
          "args": [],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "udid_uppercase"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "thread_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "39-44",
          "snippet": "void thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nvoid thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "ret",
            "\"Unique Identifier\"",
            "plist_new_string(udid_uppercase)"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_string",
          "args": [
            "udid_uppercase"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "string_toupper",
          "args": [
            "(char*)udid"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "string_toupper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/utils.c",
          "lines": "164-172",
          "snippet": "char *string_toupper(char* str)\n{\n\tchar *res = strdup(str);\n\tunsigned int i;\n\tfor (i = 0; i < strlen(res); i++) {\n\t\tres[i] = toupper(res[i]);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include <ctype.h>",
            "#include <inttypes.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include <ctype.h>\n#include <inttypes.h>\n#include <sys/time.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <config.h>\n\nchar *string_toupper(char* str)\n{\n\tchar *res = strdup(str);\n\tunsigned int i;\n\tfor (i = 0; i < strlen(res); i++) {\n\t\tres[i] = toupper(res[i]);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "ret",
            "\"Target Identifier\"",
            "plist_new_string(udid)"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_string",
          "args": [
            "udid"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "root_node",
            "\"UniqueDeviceID\""
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "ret",
            "\"Serial Number\"",
            "plist_copy(value_node)"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_copy",
          "args": [
            "value_node"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "root_node",
            "\"SerialNumber\""
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "ret",
            "\"Product Version\"",
            "plist_copy(value_node)"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_copy",
          "args": [
            "value_node"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "root_node",
            "\"ProductVersion\""
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "ret",
            "\"Product Type\"",
            "plist_copy(value_node)"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_copy",
          "args": [
            "value_node"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "root_node",
            "\"ProductType\""
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "ret",
            "\"Last Backup Date\"",
            "plist_new_date(time(NULL), 0)"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_date",
          "args": [
            "time(NULL)",
            "0"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "ret",
            "\"IMEI\"",
            "plist_copy(value_node)"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_copy",
          "args": [
            "value_node"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "root_node",
            "\"InternationalMobileEquipmentIdentity\""
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "ret",
            "\"GUID\"",
            "plist_new_string(\"---\")"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_string",
          "args": [
            "\"---\""
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "ret",
            "\"Display Name\"",
            "plist_copy(value_node)"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_copy",
          "args": [
            "value_node"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "ret",
            "\"Device Name\"",
            "plist_copy(value_node)"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_copy",
          "args": [
            "value_node"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "root_node",
            "\"DeviceName\""
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "ret",
            "\"Build Version\"",
            "plist_copy(value_node)"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_copy",
          "args": [
            "value_node"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "root_node",
            "\"BuildVersion\""
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdownd_get_value",
          "args": [
            "client",
            "NULL",
            "NULL",
            "&root_node"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "lockdownd_get_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/lockdown.c",
          "lines": "426-478",
          "snippet": "LIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_get_value(lockdownd_client_t client, const char *domain, const char *key, plist_t *value)\n{\n\tif (!client)\n\t\treturn LOCKDOWN_E_INVALID_ARG;\n\n\tplist_t dict = NULL;\n\tlockdownd_error_t ret = LOCKDOWN_E_UNKNOWN_ERROR;\n\n\t/* setup request plist */\n\tdict = plist_new_dict();\n\tplist_dict_add_label(dict, client->label);\n\tif (domain) {\n\t\tplist_dict_set_item(dict,\"Domain\", plist_new_string(domain));\n\t}\n\tif (key) {\n\t\tplist_dict_set_item(dict,\"Key\", plist_new_string(key));\n\t}\n\tplist_dict_set_item(dict,\"Request\", plist_new_string(\"GetValue\"));\n\n\t/* send to device */\n\tret = lockdownd_send(client, dict);\n\n\tplist_free(dict);\n\tdict = NULL;\n\n\tif (ret != LOCKDOWN_E_SUCCESS)\n\t\treturn ret;\n\n\t/* Now get device's answer */\n\tret = lockdownd_receive(client, &dict);\n\tif (ret != LOCKDOWN_E_SUCCESS)\n\t\treturn ret;\n\n\tret = lockdown_check_result(dict, \"GetValue\");\n\tif (ret == LOCKDOWN_E_SUCCESS) {\n\t\tdebug_info(\"success\");\n\t}\n\n\tif (ret != LOCKDOWN_E_SUCCESS) {\n\t\tplist_free(dict);\n\t\treturn ret;\n\t}\n\n\tplist_t value_node = plist_dict_get_item(dict, \"Value\");\n\n\tif (value_node) {\n\t\tdebug_info(\"has a value\");\n\t\t*value = plist_copy(value_node);\n\t}\n\n\tplist_free(dict);\n\treturn ret;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/userpref.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"lockdown.h\"",
            "#include \"property_list_service.h\"",
            "#include <plist/plist.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/x509.h>",
            "#include <libtasn1.h>",
            "#include <openssl/x509v3.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/pem.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/userpref.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"lockdown.h\"\n#include \"property_list_service.h\"\n#include <plist/plist.h>\n#include <gnutls/crypto.h>\n#include <gnutls/x509.h>\n#include <libtasn1.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/pem.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_get_value(lockdownd_client_t client, const char *domain, const char *key, plist_t *value)\n{\n\tif (!client)\n\t\treturn LOCKDOWN_E_INVALID_ARG;\n\n\tplist_t dict = NULL;\n\tlockdownd_error_t ret = LOCKDOWN_E_UNKNOWN_ERROR;\n\n\t/* setup request plist */\n\tdict = plist_new_dict();\n\tplist_dict_add_label(dict, client->label);\n\tif (domain) {\n\t\tplist_dict_set_item(dict,\"Domain\", plist_new_string(domain));\n\t}\n\tif (key) {\n\t\tplist_dict_set_item(dict,\"Key\", plist_new_string(key));\n\t}\n\tplist_dict_set_item(dict,\"Request\", plist_new_string(\"GetValue\"));\n\n\t/* send to device */\n\tret = lockdownd_send(client, dict);\n\n\tplist_free(dict);\n\tdict = NULL;\n\n\tif (ret != LOCKDOWN_E_SUCCESS)\n\t\treturn ret;\n\n\t/* Now get device's answer */\n\tret = lockdownd_receive(client, &dict);\n\tif (ret != LOCKDOWN_E_SUCCESS)\n\t\treturn ret;\n\n\tret = lockdown_check_result(dict, \"GetValue\");\n\tif (ret == LOCKDOWN_E_SUCCESS) {\n\t\tdebug_info(\"success\");\n\t}\n\n\tif (ret != LOCKDOWN_E_SUCCESS) {\n\t\tplist_free(dict);\n\t\treturn ret;\n\t}\n\n\tplist_t value_node = plist_dict_get_item(dict, \"Value\");\n\n\tif (value_node) {\n\t\tdebug_info(\"has a value\");\n\t\t*value = plist_copy(value_node);\n\t}\n\n\tplist_free(dict);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_new_dict",
          "args": [],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic lockdownd_client_t client = NULL;\nstatic idevice_t device = NULL;\n\nstatic plist_t mobilebackup_factory_info_plist_new(const char* udid)\n{\n\t/* gather data from lockdown */\n\tplist_t value_node = NULL;\n\tplist_t root_node = NULL;\n\tchar *udid_uppercase = NULL;\n\n\tplist_t ret = plist_new_dict();\n\n\t/* get basic device information in one go */\n\tlockdownd_get_value(client, NULL, NULL, &root_node);\n\n\t/* set fields we understand */\n\tvalue_node = plist_dict_get_item(root_node, \"BuildVersion\");\n\tplist_dict_set_item(ret, \"Build Version\", plist_copy(value_node));\n\n\tvalue_node = plist_dict_get_item(root_node, \"DeviceName\");\n\tplist_dict_set_item(ret, \"Device Name\", plist_copy(value_node));\n\tplist_dict_set_item(ret, \"Display Name\", plist_copy(value_node));\n\n\t/* FIXME: How is the GUID generated? */\n\tplist_dict_set_item(ret, \"GUID\", plist_new_string(\"---\"));\n\n\tvalue_node = plist_dict_get_item(root_node, \"InternationalMobileEquipmentIdentity\");\n\tif (value_node)\n\t\tplist_dict_set_item(ret, \"IMEI\", plist_copy(value_node));\n\n\tplist_dict_set_item(ret, \"Last Backup Date\", plist_new_date(time(NULL), 0));\n\n\tvalue_node = plist_dict_get_item(root_node, \"ProductType\");\n\tplist_dict_set_item(ret, \"Product Type\", plist_copy(value_node));\n\n\tvalue_node = plist_dict_get_item(root_node, \"ProductVersion\");\n\tplist_dict_set_item(ret, \"Product Version\", plist_copy(value_node));\n\n\tvalue_node = plist_dict_get_item(root_node, \"SerialNumber\");\n\tplist_dict_set_item(ret, \"Serial Number\", plist_copy(value_node));\n\n\tvalue_node = plist_dict_get_item(root_node, \"UniqueDeviceID\");\n\tplist_dict_set_item(ret, \"Target Identifier\", plist_new_string(udid));\n\n\t/* uppercase */\n\tudid_uppercase = string_toupper((char*)udid);\n\tplist_dict_set_item(ret, \"Unique Identifier\", plist_new_string(udid_uppercase));\n\tfree(udid_uppercase);\n\n\t/* FIXME: Embed files as <data> nodes */\n\tplist_t files = plist_new_dict();\n\tplist_dict_set_item(ret, \"iTunes Files\", files);\n\tplist_dict_set_item(ret, \"iTunes Version\", plist_new_string(\"9.0.2\"));\n\n\tplist_free(root_node);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "notify_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
    "lines": "217-225",
    "snippet": "static void notify_cb(const char *notification, void *userdata)\n{\n\tif (!strcmp(notification, NP_SYNC_CANCEL_REQUEST)) {\n\t\tprintf(\"User has aborted on-device\\n\");\n\t\tquit_flag++;\n\t} else {\n\t\tprintf(\"unhandled notification '%s' (TODO: implement)\\n\", notification);\n\t}\n}",
    "includes": [
      "#include <windows.h>",
      "#include \"common/utils.h\"",
      "#include <libimobiledevice/afc.h>",
      "#include <libimobiledevice/notification_proxy.h>",
      "#include <libimobiledevice/mobilebackup.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <unistd.h>",
      "#include <gcrypt.h>",
      "#include <openssl/sha.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static idevice_t device = NULL;",
      "static int quit_flag = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"unhandled notification '%s' (TODO: implement)\\n\"",
            "notification"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "asprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/include/asprintf.h",
          "lines": "23-31",
          "snippet": "static inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}",
          "includes": [
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <config.h>\n\nstatic inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"User has aborted on-device\\n\""
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "notification",
            "NP_SYNC_CANCEL_REQUEST"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "plist_strcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
          "lines": "296-309",
          "snippet": "static int plist_strcmp(plist_t node, const char *str)\n{\n\tchar *buffer = NULL;\n\tint ret = 0;\n\n\tif (plist_get_node_type(node) != PLIST_STRING)\n\t\treturn ret;\n\n\tplist_get_string_val(node, &buffer);\n\tret = strcmp(buffer, str);\n\tfree(buffer);\n\n\treturn ret;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <unistd.h>",
            "#include <gcrypt.h>",
            "#include <openssl/sha.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int plist_strcmp(plist_t node, const char *str)\n{\n\tchar *buffer = NULL;\n\tint ret = 0;\n\n\tif (plist_get_node_type(node) != PLIST_STRING)\n\t\treturn ret;\n\n\tplist_get_string_val(node, &buffer);\n\tret = strcmp(buffer, str);\n\tfree(buffer);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic idevice_t device = NULL;\nstatic int quit_flag = 0;\n\nstatic void notify_cb(const char *notification, void *userdata)\n{\n\tif (!strcmp(notification, NP_SYNC_CANCEL_REQUEST)) {\n\t\tprintf(\"User has aborted on-device\\n\");\n\t\tquit_flag++;\n\t} else {\n\t\tprintf(\"unhandled notification '%s' (TODO: implement)\\n\", notification);\n\t}\n}"
  },
  {
    "function_name": "print_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
    "lines": "209-215",
    "snippet": "static void print_hash(const unsigned char *hash, int len)\n{\n\tint i;\n\tfor (i = 0; i < len; i++) {\n\t\tprintf(\"%02x\", hash[i]);\n\t}\n}",
    "includes": [
      "#include <windows.h>",
      "#include \"common/utils.h\"",
      "#include <libimobiledevice/afc.h>",
      "#include <libimobiledevice/notification_proxy.h>",
      "#include <libimobiledevice/mobilebackup.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <unistd.h>",
      "#include <gcrypt.h>",
      "#include <openssl/sha.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%02x\"",
            "hash[i]"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "asprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/include/asprintf.h",
          "lines": "23-31",
          "snippet": "static inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}",
          "includes": [
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <config.h>\n\nstatic inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void print_hash(const unsigned char *hash, int len)\n{\n\tint i;\n\tfor (i = 0; i < len; i++) {\n\t\tprintf(\"%02x\", hash[i]);\n\t}\n}"
  },
  {
    "function_name": "compute_datahash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
    "lines": "97-207",
    "snippet": "static void compute_datahash(const char *path, const char *destpath, uint8_t greylist, const char *domain, const char *appid, const char *version, unsigned char *hash_out)\n{\n#ifdef HAVE_OPENSSL\n\tSHA_CTX sha1;\n\tSHA1_Init(&sha1);\n#else\n\tgcry_md_hd_t hd = NULL;\n\tgcry_md_open(&hd, GCRY_MD_SHA1, 0);\n\tif (!hd) {\n\t\tprintf(\"ERROR: Could not initialize libgcrypt/SHA1\\n\");\n\t\treturn;\n\t}\n\tgcry_md_reset(hd);\n#endif\n\tFILE *f = fopen(path, \"rb\");\n\tif (f) {\n\t\tunsigned char buf[16384];\n\t\tsize_t len;\n\t\twhile ((len = fread(buf, 1, 16384, f)) > 0) {\n#ifdef HAVE_OPENSSL\n\t\t\tSHA1_Update(&sha1, buf, len);\n#else\n\t\t\tgcry_md_write(hd, buf, len);\n#endif\n\t\t}\n\t\tfclose(f);\n#ifdef HAVE_OPENSSL\n\t\tSHA1_Update(&sha1, destpath, strlen(destpath));\n\t\tSHA1_Update(&sha1, \";\", 1);\n#else\n\t\tgcry_md_write(hd, destpath, strlen(destpath));\n\t\tgcry_md_write(hd, \";\", 1);\n#endif\n\t\tif (greylist == 1) {\n#ifdef HAVE_OPENSSL\n\t\t\tSHA1_Update(&sha1, \"true\", 4);\n#else\n\t\t\tgcry_md_write(hd, \"true\", 4);\n#endif\n\t\t} else {\n#ifdef HAVE_OPENSSL\n\t\t\tSHA1_Update(&sha1, \"false\", 5);\n#else\n\t\t\tgcry_md_write(hd, \"false\", 5);\n#endif\n\t\t}\n#ifdef HAVE_OPENSSL\n\t\tSHA1_Update(&sha1, \";\", 1);\n#else\n\t\tgcry_md_write(hd, \";\", 1);\n#endif\n\t\tif (domain) {\n#ifdef HAVE_OPENSSL\n\t\t\tSHA1_Update(&sha1, domain, strlen(domain));\n#else\n\t\t\tgcry_md_write(hd, domain, strlen(domain));\n#endif\n\t\t} else {\n#ifdef HAVE_OPENSSL\n\t\t\tSHA1_Update(&sha1, \"(null)\", 6);\n#else\n\t\t\tgcry_md_write(hd, \"(null)\", 6);\n#endif\n\t\t}\n#ifdef HAVE_OPENSSL\n\t\tSHA1_Update(&sha1, \";\", 1);\n#else\n\t\tgcry_md_write(hd, \";\", 1);\n#endif\n\t\tif (appid) {\n#ifdef HAVE_OPENSSL\n\t\t\tSHA1_Update(&sha1, appid, strlen(appid));\n#else\n\t\t\tgcry_md_write(hd, appid, strlen(appid));\n#endif\n\t\t} else {\n#ifdef HAVE_OPENSSL\n\t\t\tSHA1_Update(&sha1, \"(null)\", 6);\n#else\n\t\t\tgcry_md_write(hd, \"(null)\", 6);\n#endif\n\t\t}\n#ifdef HAVE_OPENSSL\n\t\tSHA1_Update(&sha1, \";\", 1);\n#else\n\t\tgcry_md_write(hd, \";\", 1);\n#endif\n\t\tif (version) {\n#ifdef HAVE_OPENSSL\n\t\t\tSHA1_Update(&sha1, version, strlen(version));\n#else\n\t\t\tgcry_md_write(hd, version, strlen(version));\n#endif\n\t\t} else {\n#ifdef HAVE_OPENSSL\n\t\t\tSHA1_Update(&sha1, \"(null)\", 6);\n#else\n\t\t\tgcry_md_write(hd, \"(null)\", 6);\n#endif\n\t\t}\n#ifdef HAVE_OPENSSL\n\t\tSHA1_Final(hash_out, &sha1);\n#else\n\t\tunsigned char *newhash = gcry_md_read(hd, GCRY_MD_SHA1);\n\t\tmemcpy(hash_out, newhash, 20);\n#endif\n\t}\n#ifndef HAVE_OPENSSL\n\tgcry_md_close(hd);\n#endif\n}",
    "includes": [
      "#include <windows.h>",
      "#include \"common/utils.h\"",
      "#include <libimobiledevice/afc.h>",
      "#include <libimobiledevice/notification_proxy.h>",
      "#include <libimobiledevice/mobilebackup.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <unistd.h>",
      "#include <gcrypt.h>",
      "#include <openssl/sha.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gcry_md_close",
          "args": [
            "hd"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "hash_out",
            "newhash",
            "20"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gcry_md_read",
          "args": [
            "hd",
            "GCRY_MD_SHA1"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SHA1_Final",
          "args": [
            "hash_out",
            "&sha1"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gcry_md_write",
          "args": [
            "hd",
            "\"(null)\"",
            "6"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SHA1_Update",
          "args": [
            "&sha1",
            "\"(null)\"",
            "6"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gcry_md_write",
          "args": [
            "hd",
            "version",
            "strlen(version)"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "version"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SHA1_Update",
          "args": [
            "&sha1",
            "version",
            "strlen(version)"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "version"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gcry_md_write",
          "args": [
            "hd",
            "\";\"",
            "1"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SHA1_Update",
          "args": [
            "&sha1",
            "\";\"",
            "1"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gcry_md_write",
          "args": [
            "hd",
            "\"(null)\"",
            "6"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SHA1_Update",
          "args": [
            "&sha1",
            "\"(null)\"",
            "6"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gcry_md_write",
          "args": [
            "hd",
            "appid",
            "strlen(appid)"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "appid"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SHA1_Update",
          "args": [
            "&sha1",
            "appid",
            "strlen(appid)"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "appid"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gcry_md_write",
          "args": [
            "hd",
            "\";\"",
            "1"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SHA1_Update",
          "args": [
            "&sha1",
            "\";\"",
            "1"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gcry_md_write",
          "args": [
            "hd",
            "\"(null)\"",
            "6"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SHA1_Update",
          "args": [
            "&sha1",
            "\"(null)\"",
            "6"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gcry_md_write",
          "args": [
            "hd",
            "domain",
            "strlen(domain)"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "domain"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SHA1_Update",
          "args": [
            "&sha1",
            "domain",
            "strlen(domain)"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "domain"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gcry_md_write",
          "args": [
            "hd",
            "\";\"",
            "1"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SHA1_Update",
          "args": [
            "&sha1",
            "\";\"",
            "1"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gcry_md_write",
          "args": [
            "hd",
            "\"false\"",
            "5"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SHA1_Update",
          "args": [
            "&sha1",
            "\"false\"",
            "5"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gcry_md_write",
          "args": [
            "hd",
            "\"true\"",
            "4"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SHA1_Update",
          "args": [
            "&sha1",
            "\"true\"",
            "4"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gcry_md_write",
          "args": [
            "hd",
            "\";\"",
            "1"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gcry_md_write",
          "args": [
            "hd",
            "destpath",
            "strlen(destpath)"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "destpath"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SHA1_Update",
          "args": [
            "&sha1",
            "\";\"",
            "1"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SHA1_Update",
          "args": [
            "&sha1",
            "destpath",
            "strlen(destpath)"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "destpath"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gcry_md_write",
          "args": [
            "hd",
            "buf",
            "len"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SHA1_Update",
          "args": [
            "&sha1",
            "buf",
            "len"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fread",
          "args": [
            "buf",
            "1",
            "16384",
            "f"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "path",
            "\"rb\""
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gcry_md_reset",
          "args": [
            "hd"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ERROR: Could not initialize libgcrypt/SHA1\\n\""
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gcry_md_open",
          "args": [
            "&hd",
            "GCRY_MD_SHA1",
            "0"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SHA1_Init",
          "args": [
            "&sha1"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void compute_datahash(const char *path, const char *destpath, uint8_t greylist, const char *domain, const char *appid, const char *version, unsigned char *hash_out)\n{\n#ifdef HAVE_OPENSSL\n\tSHA_CTX sha1;\n\tSHA1_Init(&sha1);\n#else\n\tgcry_md_hd_t hd = NULL;\n\tgcry_md_open(&hd, GCRY_MD_SHA1, 0);\n\tif (!hd) {\n\t\tprintf(\"ERROR: Could not initialize libgcrypt/SHA1\\n\");\n\t\treturn;\n\t}\n\tgcry_md_reset(hd);\n#endif\n\tFILE *f = fopen(path, \"rb\");\n\tif (f) {\n\t\tunsigned char buf[16384];\n\t\tsize_t len;\n\t\twhile ((len = fread(buf, 1, 16384, f)) > 0) {\n#ifdef HAVE_OPENSSL\n\t\t\tSHA1_Update(&sha1, buf, len);\n#else\n\t\t\tgcry_md_write(hd, buf, len);\n#endif\n\t\t}\n\t\tfclose(f);\n#ifdef HAVE_OPENSSL\n\t\tSHA1_Update(&sha1, destpath, strlen(destpath));\n\t\tSHA1_Update(&sha1, \";\", 1);\n#else\n\t\tgcry_md_write(hd, destpath, strlen(destpath));\n\t\tgcry_md_write(hd, \";\", 1);\n#endif\n\t\tif (greylist == 1) {\n#ifdef HAVE_OPENSSL\n\t\t\tSHA1_Update(&sha1, \"true\", 4);\n#else\n\t\t\tgcry_md_write(hd, \"true\", 4);\n#endif\n\t\t} else {\n#ifdef HAVE_OPENSSL\n\t\t\tSHA1_Update(&sha1, \"false\", 5);\n#else\n\t\t\tgcry_md_write(hd, \"false\", 5);\n#endif\n\t\t}\n#ifdef HAVE_OPENSSL\n\t\tSHA1_Update(&sha1, \";\", 1);\n#else\n\t\tgcry_md_write(hd, \";\", 1);\n#endif\n\t\tif (domain) {\n#ifdef HAVE_OPENSSL\n\t\t\tSHA1_Update(&sha1, domain, strlen(domain));\n#else\n\t\t\tgcry_md_write(hd, domain, strlen(domain));\n#endif\n\t\t} else {\n#ifdef HAVE_OPENSSL\n\t\t\tSHA1_Update(&sha1, \"(null)\", 6);\n#else\n\t\t\tgcry_md_write(hd, \"(null)\", 6);\n#endif\n\t\t}\n#ifdef HAVE_OPENSSL\n\t\tSHA1_Update(&sha1, \";\", 1);\n#else\n\t\tgcry_md_write(hd, \";\", 1);\n#endif\n\t\tif (appid) {\n#ifdef HAVE_OPENSSL\n\t\t\tSHA1_Update(&sha1, appid, strlen(appid));\n#else\n\t\t\tgcry_md_write(hd, appid, strlen(appid));\n#endif\n\t\t} else {\n#ifdef HAVE_OPENSSL\n\t\t\tSHA1_Update(&sha1, \"(null)\", 6);\n#else\n\t\t\tgcry_md_write(hd, \"(null)\", 6);\n#endif\n\t\t}\n#ifdef HAVE_OPENSSL\n\t\tSHA1_Update(&sha1, \";\", 1);\n#else\n\t\tgcry_md_write(hd, \";\", 1);\n#endif\n\t\tif (version) {\n#ifdef HAVE_OPENSSL\n\t\t\tSHA1_Update(&sha1, version, strlen(version));\n#else\n\t\t\tgcry_md_write(hd, version, strlen(version));\n#endif\n\t\t} else {\n#ifdef HAVE_OPENSSL\n\t\t\tSHA1_Update(&sha1, \"(null)\", 6);\n#else\n\t\t\tgcry_md_write(hd, \"(null)\", 6);\n#endif\n\t\t}\n#ifdef HAVE_OPENSSL\n\t\tSHA1_Final(hash_out, &sha1);\n#else\n\t\tunsigned char *newhash = gcry_md_read(hd, GCRY_MD_SHA1);\n\t\tmemcpy(hash_out, newhash, 20);\n#endif\n\t}\n#ifndef HAVE_OPENSSL\n\tgcry_md_close(hd);\n#endif\n}"
  },
  {
    "function_name": "compare_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
    "lines": "86-95",
    "snippet": "static int compare_hash(const unsigned char *hash1, const unsigned char *hash2, int hash_len)\n{\n\tint i;\n\tfor (i = 0; i < hash_len; i++) {\n\t\tif (hash1[i] != hash2[i]) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include <windows.h>",
      "#include \"common/utils.h\"",
      "#include <libimobiledevice/afc.h>",
      "#include <libimobiledevice/notification_proxy.h>",
      "#include <libimobiledevice/mobilebackup.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <unistd.h>",
      "#include <gcrypt.h>",
      "#include <openssl/sha.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int compare_hash(const unsigned char *hash1, const unsigned char *hash2, int hash_len)\n{\n\tint i;\n\tfor (i = 0; i < hash_len; i++) {\n\t\tif (hash1[i] != hash2[i]) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "sha1_of_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
    "lines": "77-84",
    "snippet": "static void sha1_of_data(const char *input, uint32_t size, unsigned char *hash_out)\n{\n#ifdef HAVE_OPENSSL\n\tSHA1((const unsigned char*)input, size, hash_out);\n#else\n\tgcry_md_hash_buffer(GCRY_MD_SHA1, hash_out, input, size);\n#endif\n}",
    "includes": [
      "#include <windows.h>",
      "#include \"common/utils.h\"",
      "#include <libimobiledevice/afc.h>",
      "#include <libimobiledevice/notification_proxy.h>",
      "#include <libimobiledevice/mobilebackup.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <unistd.h>",
      "#include <gcrypt.h>",
      "#include <openssl/sha.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gcry_md_hash_buffer",
          "args": [
            "GCRY_MD_SHA1",
            "hash_out",
            "input",
            "size"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SHA1",
          "args": [
            "(const unsigned char*)input",
            "size",
            "hash_out"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void sha1_of_data(const char *input, uint32_t size, unsigned char *hash_out)\n{\n#ifdef HAVE_OPENSSL\n\tSHA1((const unsigned char*)input, size, hash_out);\n#else\n\tgcry_md_hash_buffer(GCRY_MD_SHA1, hash_out, input, size);\n#endif\n}"
  }
]