[
  {
    "function_name": "pair_record_set_item_from_key_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/userpref.c",
    "lines": "920-932",
    "snippet": "userpref_error_t pair_record_set_item_from_key_data(plist_t pair_record, const char* name, key_data_t *value)\n{\n\tuserpref_error_t ret = USERPREF_E_SUCCESS;\n\n\tif (!pair_record || !value) {\n\t\treturn USERPREF_E_INVALID_ARG;\n\t}\n\n\t/* set new item */\n\tplist_dict_set_item(pair_record, name, plist_new_data((char*)value->data, value->size));\n\n\treturn ret;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"debug.h\"",
      "#include \"userpref.h\"",
      "#include <shlobj.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <libgen.h>",
      "#include <dirent.h>",
      "#include <libtasn1.h>",
      "#include <gcrypt.h>",
      "#include <gnutls/x509.h>",
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include <openssl/x509v3.h>",
      "#include <openssl/x509.h>",
      "#include <openssl/rsa.h>",
      "#include <openssl/pem.h>",
      "#include <usbmuxd.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "pair_record",
            "name",
            "plist_new_data((char*)value->data, value->size)"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_data",
          "args": [
            "(char*)value->data",
            "value->size"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"debug.h\"\n#include \"userpref.h\"\n#include <shlobj.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <libtasn1.h>\n#include <gcrypt.h>\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/rsa.h>\n#include <openssl/pem.h>\n#include <usbmuxd.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <config.h>\n\nuserpref_error_t pair_record_set_item_from_key_data(plist_t pair_record, const char* name, key_data_t *value)\n{\n\tuserpref_error_t ret = USERPREF_E_SUCCESS;\n\n\tif (!pair_record || !value) {\n\t\treturn USERPREF_E_INVALID_ARG;\n\t}\n\n\t/* set new item */\n\tplist_dict_set_item(pair_record, name, plist_new_data((char*)value->data, value->size));\n\n\treturn ret;\n}"
  },
  {
    "function_name": "pair_record_get_item_as_key_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/userpref.c",
    "lines": "892-918",
    "snippet": "userpref_error_t pair_record_get_item_as_key_data(plist_t pair_record, const char* name, key_data_t *value)\n{\n\tif (!pair_record || !value)\n\t\treturn USERPREF_E_INVALID_ARG;\n\n\tuserpref_error_t ret = USERPREF_E_SUCCESS;\n\tchar* buffer = NULL;\n\tuint64_t length = 0;\n\n\tplist_t node = plist_dict_get_item(pair_record, name);\n\n\tif (node && plist_get_node_type(node) == PLIST_DATA) {\n\t\tplist_get_data_val(node, &buffer, &length);\n\t\tvalue->data = (unsigned char*)malloc(length);\n\t\tmemcpy(value->data, buffer, length);\n\t\tvalue->size = length;\n\t\tfree(buffer);\n\t\tbuffer = NULL;\n\t} else {\n\t\tret = USERPREF_E_INVALID_CONF;\n\t}\n\n\tif (buffer)\n\t\tfree(buffer);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"debug.h\"",
      "#include \"userpref.h\"",
      "#include <shlobj.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <libgen.h>",
      "#include <dirent.h>",
      "#include <libtasn1.h>",
      "#include <gcrypt.h>",
      "#include <gnutls/x509.h>",
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include <openssl/x509v3.h>",
      "#include <openssl/x509.h>",
      "#include <openssl/rsa.h>",
      "#include <openssl/pem.h>",
      "#include <usbmuxd.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "buffer"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "thread_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "39-44",
          "snippet": "void thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nvoid thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "value->data",
            "buffer",
            "length"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "length"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_data_val",
          "args": [
            "node",
            "&buffer",
            "&length"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_node_type",
          "args": [
            "node"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "pair_record",
            "name"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"debug.h\"\n#include \"userpref.h\"\n#include <shlobj.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <libtasn1.h>\n#include <gcrypt.h>\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/rsa.h>\n#include <openssl/pem.h>\n#include <usbmuxd.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <config.h>\n\nuserpref_error_t pair_record_get_item_as_key_data(plist_t pair_record, const char* name, key_data_t *value)\n{\n\tif (!pair_record || !value)\n\t\treturn USERPREF_E_INVALID_ARG;\n\n\tuserpref_error_t ret = USERPREF_E_SUCCESS;\n\tchar* buffer = NULL;\n\tuint64_t length = 0;\n\n\tplist_t node = plist_dict_get_item(pair_record, name);\n\n\tif (node && plist_get_node_type(node) == PLIST_DATA) {\n\t\tplist_get_data_val(node, &buffer, &length);\n\t\tvalue->data = (unsigned char*)malloc(length);\n\t\tmemcpy(value->data, buffer, length);\n\t\tvalue->size = length;\n\t\tfree(buffer);\n\t\tbuffer = NULL;\n\t} else {\n\t\tret = USERPREF_E_INVALID_CONF;\n\t}\n\n\tif (buffer)\n\t\tfree(buffer);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "pair_record_set_host_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/userpref.c",
    "lines": "885-890",
    "snippet": "userpref_error_t pair_record_set_host_id(plist_t pair_record, const char* host_id)\n{\n\tplist_dict_set_item(pair_record, USERPREF_HOST_ID_KEY, plist_new_string(host_id));\n\n\treturn USERPREF_E_SUCCESS;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"debug.h\"",
      "#include \"userpref.h\"",
      "#include <shlobj.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <libgen.h>",
      "#include <dirent.h>",
      "#include <libtasn1.h>",
      "#include <gcrypt.h>",
      "#include <gnutls/x509.h>",
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include <openssl/x509v3.h>",
      "#include <openssl/x509.h>",
      "#include <openssl/rsa.h>",
      "#include <openssl/pem.h>",
      "#include <usbmuxd.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "pair_record",
            "USERPREF_HOST_ID_KEY",
            "plist_new_string(host_id)"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_string",
          "args": [
            "host_id"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"debug.h\"\n#include \"userpref.h\"\n#include <shlobj.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <libtasn1.h>\n#include <gcrypt.h>\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/rsa.h>\n#include <openssl/pem.h>\n#include <usbmuxd.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <config.h>\n\nuserpref_error_t pair_record_set_host_id(plist_t pair_record, const char* host_id)\n{\n\tplist_dict_set_item(pair_record, USERPREF_HOST_ID_KEY, plist_new_string(host_id));\n\n\treturn USERPREF_E_SUCCESS;\n}"
  },
  {
    "function_name": "pair_record_get_host_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/userpref.c",
    "lines": "874-883",
    "snippet": "userpref_error_t pair_record_get_host_id(plist_t pair_record, char** host_id)\n{\n\tplist_t node = plist_dict_get_item(pair_record, USERPREF_HOST_ID_KEY);\n\n\tif (node && plist_get_node_type(node) == PLIST_STRING) {\n\t\tplist_get_string_val(node, host_id);\n\t}\n\n\treturn USERPREF_E_SUCCESS;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"debug.h\"",
      "#include \"userpref.h\"",
      "#include <shlobj.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <libgen.h>",
      "#include <dirent.h>",
      "#include <libtasn1.h>",
      "#include <gcrypt.h>",
      "#include <gnutls/x509.h>",
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include <openssl/x509v3.h>",
      "#include <openssl/x509.h>",
      "#include <openssl/rsa.h>",
      "#include <openssl/pem.h>",
      "#include <usbmuxd.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "plist_get_string_val",
          "args": [
            "node",
            "host_id"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_node_type",
          "args": [
            "node"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "pair_record",
            "USERPREF_HOST_ID_KEY"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"debug.h\"\n#include \"userpref.h\"\n#include <shlobj.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <libtasn1.h>\n#include <gcrypt.h>\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/rsa.h>\n#include <openssl/pem.h>\n#include <usbmuxd.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <config.h>\n\nuserpref_error_t pair_record_get_host_id(plist_t pair_record, char** host_id)\n{\n\tplist_t node = plist_dict_get_item(pair_record, USERPREF_HOST_ID_KEY);\n\n\tif (node && plist_get_node_type(node) == PLIST_STRING) {\n\t\tplist_get_string_val(node, host_id);\n\t}\n\n\treturn USERPREF_E_SUCCESS;\n}"
  },
  {
    "function_name": "pair_record_import_crt_with_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/userpref.c",
    "lines": "848-872",
    "snippet": "userpref_error_t pair_record_import_crt_with_name(plist_t pair_record, const char* name, gnutls_x509_crt_t cert)\n#endif\n{\n#ifdef HAVE_OPENSSL\n\tif (!cert)\n\t\treturn USERPREF_E_SUCCESS;\n#endif\n\tuserpref_error_t ret = USERPREF_E_INVALID_CONF;\n\n#ifdef HAVE_OPENSSL\n\t\tret = pair_record_get_item_as_key_data(pair_record, name, cert);\n#else\n\t\tkey_data_t pem = { NULL, 0 };\n\t\tret = pair_record_get_item_as_key_data(pair_record, name, &pem);\n\t\tif (ret == USERPREF_E_SUCCESS && GNUTLS_E_SUCCESS == gnutls_x509_crt_import(cert, &pem, GNUTLS_X509_FMT_PEM))\n\t\t\tret = USERPREF_E_SUCCESS;\n\t\telse\n\t\t\tret = USERPREF_E_SSL_ERROR;\n\n\t\tif (pem.data)\n\t\t\tfree(pem.data);\n#endif\n\n\treturn ret;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"debug.h\"",
      "#include \"userpref.h\"",
      "#include <shlobj.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <libgen.h>",
      "#include <dirent.h>",
      "#include <libtasn1.h>",
      "#include <gcrypt.h>",
      "#include <gnutls/x509.h>",
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include <openssl/x509v3.h>",
      "#include <openssl/x509.h>",
      "#include <openssl/rsa.h>",
      "#include <openssl/pem.h>",
      "#include <usbmuxd.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "pem.data"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "thread_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "39-44",
          "snippet": "void thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nvoid thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_import",
          "args": [
            "cert",
            "&pem",
            "GNUTLS_X509_FMT_PEM"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pair_record_get_item_as_key_data",
          "args": [
            "pair_record",
            "name",
            "&pem"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "pair_record_get_item_as_key_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/userpref.c",
          "lines": "892-918",
          "snippet": "userpref_error_t pair_record_get_item_as_key_data(plist_t pair_record, const char* name, key_data_t *value)\n{\n\tif (!pair_record || !value)\n\t\treturn USERPREF_E_INVALID_ARG;\n\n\tuserpref_error_t ret = USERPREF_E_SUCCESS;\n\tchar* buffer = NULL;\n\tuint64_t length = 0;\n\n\tplist_t node = plist_dict_get_item(pair_record, name);\n\n\tif (node && plist_get_node_type(node) == PLIST_DATA) {\n\t\tplist_get_data_val(node, &buffer, &length);\n\t\tvalue->data = (unsigned char*)malloc(length);\n\t\tmemcpy(value->data, buffer, length);\n\t\tvalue->size = length;\n\t\tfree(buffer);\n\t\tbuffer = NULL;\n\t} else {\n\t\tret = USERPREF_E_INVALID_CONF;\n\t}\n\n\tif (buffer)\n\t\tfree(buffer);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"debug.h\"",
            "#include \"userpref.h\"",
            "#include <shlobj.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <libgen.h>",
            "#include <dirent.h>",
            "#include <libtasn1.h>",
            "#include <gcrypt.h>",
            "#include <gnutls/x509.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/x509v3.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/pem.h>",
            "#include <usbmuxd.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"debug.h\"\n#include \"userpref.h\"\n#include <shlobj.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <libtasn1.h>\n#include <gcrypt.h>\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/rsa.h>\n#include <openssl/pem.h>\n#include <usbmuxd.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <config.h>\n\nuserpref_error_t pair_record_get_item_as_key_data(plist_t pair_record, const char* name, key_data_t *value)\n{\n\tif (!pair_record || !value)\n\t\treturn USERPREF_E_INVALID_ARG;\n\n\tuserpref_error_t ret = USERPREF_E_SUCCESS;\n\tchar* buffer = NULL;\n\tuint64_t length = 0;\n\n\tplist_t node = plist_dict_get_item(pair_record, name);\n\n\tif (node && plist_get_node_type(node) == PLIST_DATA) {\n\t\tplist_get_data_val(node, &buffer, &length);\n\t\tvalue->data = (unsigned char*)malloc(length);\n\t\tmemcpy(value->data, buffer, length);\n\t\tvalue->size = length;\n\t\tfree(buffer);\n\t\tbuffer = NULL;\n\t} else {\n\t\tret = USERPREF_E_INVALID_CONF;\n\t}\n\n\tif (buffer)\n\t\tfree(buffer);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"debug.h\"\n#include \"userpref.h\"\n#include <shlobj.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <libtasn1.h>\n#include <gcrypt.h>\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/rsa.h>\n#include <openssl/pem.h>\n#include <usbmuxd.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <config.h>\n\nuserpref_error_t pair_record_import_crt_with_name(plist_t pair_record, const char* name, gnutls_x509_crt_t cert)\n#endif\n{\n#ifdef HAVE_OPENSSL\n\tif (!cert)\n\t\treturn USERPREF_E_SUCCESS;\n#endif\n\tuserpref_error_t ret = USERPREF_E_INVALID_CONF;\n\n#ifdef HAVE_OPENSSL\n\t\tret = pair_record_get_item_as_key_data(pair_record, name, cert);\n#else\n\t\tkey_data_t pem = { NULL, 0 };\n\t\tret = pair_record_get_item_as_key_data(pair_record, name, &pem);\n\t\tif (ret == USERPREF_E_SUCCESS && GNUTLS_E_SUCCESS == gnutls_x509_crt_import(cert, &pem, GNUTLS_X509_FMT_PEM))\n\t\t\tret = USERPREF_E_SUCCESS;\n\t\telse\n\t\t\tret = USERPREF_E_SSL_ERROR;\n\n\t\tif (pem.data)\n\t\t\tfree(pem.data);\n#endif\n\n\treturn ret;\n}"
  },
  {
    "function_name": "pair_record_import_key_with_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/userpref.c",
    "lines": "811-835",
    "snippet": "userpref_error_t pair_record_import_key_with_name(plist_t pair_record, const char* name, gnutls_x509_privkey_t key)\n#endif\n{\n#ifdef HAVE_OPENSSL\n\tif (!key)\n\t\treturn USERPREF_E_SUCCESS;\n#endif\n\tuserpref_error_t ret = USERPREF_E_INVALID_CONF;\n\n#ifdef HAVE_OPENSSL\n\t\tret = pair_record_get_item_as_key_data(pair_record, name, key);\n#else\n\t\tkey_data_t pem = { NULL, 0 };\n\t\tret = pair_record_get_item_as_key_data(pair_record, name, &pem);\n\t\tif (ret == USERPREF_E_SUCCESS && GNUTLS_E_SUCCESS == gnutls_x509_privkey_import(key, &pem, GNUTLS_X509_FMT_PEM))\n\t\t\tret = USERPREF_E_SUCCESS;\n\t\telse\n\t\t\tret = USERPREF_E_SSL_ERROR;\n\n\t\tif (pem.data)\n\t\t\tfree(pem.data);\n#endif\n\n\treturn ret;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"debug.h\"",
      "#include \"userpref.h\"",
      "#include <shlobj.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <libgen.h>",
      "#include <dirent.h>",
      "#include <libtasn1.h>",
      "#include <gcrypt.h>",
      "#include <gnutls/x509.h>",
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include <openssl/x509v3.h>",
      "#include <openssl/x509.h>",
      "#include <openssl/rsa.h>",
      "#include <openssl/pem.h>",
      "#include <usbmuxd.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "pem.data"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "thread_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "39-44",
          "snippet": "void thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nvoid thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "gnutls_x509_privkey_import",
          "args": [
            "key",
            "&pem",
            "GNUTLS_X509_FMT_PEM"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pair_record_get_item_as_key_data",
          "args": [
            "pair_record",
            "name",
            "&pem"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "pair_record_get_item_as_key_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/userpref.c",
          "lines": "892-918",
          "snippet": "userpref_error_t pair_record_get_item_as_key_data(plist_t pair_record, const char* name, key_data_t *value)\n{\n\tif (!pair_record || !value)\n\t\treturn USERPREF_E_INVALID_ARG;\n\n\tuserpref_error_t ret = USERPREF_E_SUCCESS;\n\tchar* buffer = NULL;\n\tuint64_t length = 0;\n\n\tplist_t node = plist_dict_get_item(pair_record, name);\n\n\tif (node && plist_get_node_type(node) == PLIST_DATA) {\n\t\tplist_get_data_val(node, &buffer, &length);\n\t\tvalue->data = (unsigned char*)malloc(length);\n\t\tmemcpy(value->data, buffer, length);\n\t\tvalue->size = length;\n\t\tfree(buffer);\n\t\tbuffer = NULL;\n\t} else {\n\t\tret = USERPREF_E_INVALID_CONF;\n\t}\n\n\tif (buffer)\n\t\tfree(buffer);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"debug.h\"",
            "#include \"userpref.h\"",
            "#include <shlobj.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <libgen.h>",
            "#include <dirent.h>",
            "#include <libtasn1.h>",
            "#include <gcrypt.h>",
            "#include <gnutls/x509.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/x509v3.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/pem.h>",
            "#include <usbmuxd.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"debug.h\"\n#include \"userpref.h\"\n#include <shlobj.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <libtasn1.h>\n#include <gcrypt.h>\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/rsa.h>\n#include <openssl/pem.h>\n#include <usbmuxd.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <config.h>\n\nuserpref_error_t pair_record_get_item_as_key_data(plist_t pair_record, const char* name, key_data_t *value)\n{\n\tif (!pair_record || !value)\n\t\treturn USERPREF_E_INVALID_ARG;\n\n\tuserpref_error_t ret = USERPREF_E_SUCCESS;\n\tchar* buffer = NULL;\n\tuint64_t length = 0;\n\n\tplist_t node = plist_dict_get_item(pair_record, name);\n\n\tif (node && plist_get_node_type(node) == PLIST_DATA) {\n\t\tplist_get_data_val(node, &buffer, &length);\n\t\tvalue->data = (unsigned char*)malloc(length);\n\t\tmemcpy(value->data, buffer, length);\n\t\tvalue->size = length;\n\t\tfree(buffer);\n\t\tbuffer = NULL;\n\t} else {\n\t\tret = USERPREF_E_INVALID_CONF;\n\t}\n\n\tif (buffer)\n\t\tfree(buffer);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"debug.h\"\n#include \"userpref.h\"\n#include <shlobj.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <libtasn1.h>\n#include <gcrypt.h>\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/rsa.h>\n#include <openssl/pem.h>\n#include <usbmuxd.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <config.h>\n\nuserpref_error_t pair_record_import_key_with_name(plist_t pair_record, const char* name, gnutls_x509_privkey_t key)\n#endif\n{\n#ifdef HAVE_OPENSSL\n\tif (!key)\n\t\treturn USERPREF_E_SUCCESS;\n#endif\n\tuserpref_error_t ret = USERPREF_E_INVALID_CONF;\n\n#ifdef HAVE_OPENSSL\n\t\tret = pair_record_get_item_as_key_data(pair_record, name, key);\n#else\n\t\tkey_data_t pem = { NULL, 0 };\n\t\tret = pair_record_get_item_as_key_data(pair_record, name, &pem);\n\t\tif (ret == USERPREF_E_SUCCESS && GNUTLS_E_SUCCESS == gnutls_x509_privkey_import(key, &pem, GNUTLS_X509_FMT_PEM))\n\t\t\tret = USERPREF_E_SUCCESS;\n\t\telse\n\t\t\tret = USERPREF_E_SSL_ERROR;\n\n\t\tif (pem.data)\n\t\t\tfree(pem.data);\n#endif\n\n\treturn ret;\n}"
  },
  {
    "function_name": "pair_record_generate_keys_and_certs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/userpref.c",
    "lines": "405-798",
    "snippet": "userpref_error_t pair_record_generate_keys_and_certs(plist_t pair_record, key_data_t public_key)\n{\n\tuserpref_error_t ret = USERPREF_E_SSL_ERROR;\n\n\tkey_data_t dev_cert_pem = { NULL, 0 };\n\tkey_data_t root_key_pem = { NULL, 0 };\n\tkey_data_t root_cert_pem = { NULL, 0 };\n\tkey_data_t host_key_pem = { NULL, 0 };\n\tkey_data_t host_cert_pem = { NULL, 0 };\n\n\tif (!pair_record || !public_key.data)\n\t\treturn USERPREF_E_INVALID_ARG;\n\n\tdebug_info(\"Generating keys and certificates...\");\n\n#ifdef HAVE_OPENSSL\n\tBIGNUM *e = BN_new();\n\tRSA* root_keypair = RSA_new();\n\tRSA* host_keypair = RSA_new();\n\n\tBN_set_word(e, 65537);\n\n\tRSA_generate_key_ex(root_keypair, 2048, e, NULL);\n\tRSA_generate_key_ex(host_keypair, 2048, e, NULL);\n\n\tBN_free(e);\n\n\tEVP_PKEY* root_pkey = EVP_PKEY_new();\n\tEVP_PKEY_assign_RSA(root_pkey, root_keypair);\n\n\tEVP_PKEY* host_pkey = EVP_PKEY_new();\n\tEVP_PKEY_assign_RSA(host_pkey, host_keypair);\n\n\t/* generate root certificate */\n\tX509* root_cert = X509_new();\n\t{\n\t\t/* set serial number */\n\t\tASN1_INTEGER* sn = ASN1_INTEGER_new();\n\t\tASN1_INTEGER_set(sn, 0);\n\t\tX509_set_serialNumber(root_cert, sn);\n\t\tASN1_INTEGER_free(sn);\n\n\t\t/* set version */\n\t\tX509_set_version(root_cert, 2);\n\n\t\t/* set x509v3 basic constraints */\n\t\tX509_add_ext_helper(root_cert, NID_basic_constraints, (char*)\"critical,CA:TRUE\");\n\n\t\t/* set key validity */\n\t\tASN1_TIME* asn1time = ASN1_TIME_new();\n\t\tASN1_TIME_set(asn1time, time(NULL));\n\t\tX509_set_notBefore(root_cert, asn1time);\n\t\tASN1_TIME_set(asn1time, time(NULL) + (60 * 60 * 24 * 365 * 10));\n\t\tX509_set_notAfter(root_cert, asn1time);\n\t\tASN1_TIME_free(asn1time);\n\n\t\t/* use root public key for root cert */\n\t\tX509_set_pubkey(root_cert, root_pkey);\n\n\t\t/* sign root cert with root private key */\n\t\tX509_sign(root_cert, root_pkey, EVP_sha1());\n\t}\n\n\t/* create host certificate */\n\tX509* host_cert = X509_new();\n\t{\n\t\t/* set serial number */\n\t\tASN1_INTEGER* sn = ASN1_INTEGER_new();\n\t\tASN1_INTEGER_set(sn, 0);\n\t\tX509_set_serialNumber(host_cert, sn);\n\t\tASN1_INTEGER_free(sn);\n\n\t\t/* set version */\n\t\tX509_set_version(host_cert, 2);\n\n\t\t/* set x509v3 basic constraints */\n\t\tX509_add_ext_helper(host_cert, NID_basic_constraints, (char*)\"critical,CA:FALSE\");\n\n\t\t/* set x509v3 key usage */\n\t\tX509_add_ext_helper(host_cert, NID_key_usage, (char*)\"critical,digitalSignature,keyEncipherment\");\n\n\t\t/* set key validity */\n\t\tASN1_TIME* asn1time = ASN1_TIME_new();\n\t\tASN1_TIME_set(asn1time, time(NULL));\n\t\tX509_set_notBefore(host_cert, asn1time);\n\t\tASN1_TIME_set(asn1time, time(NULL) + (60 * 60 * 24 * 365 * 10));\n\t\tX509_set_notAfter(host_cert, asn1time);\n\t\tASN1_TIME_free(asn1time);\n\n\t\t/* use host public key for host cert */\n\t\tX509_set_pubkey(host_cert, host_pkey);\n\n\t\t/* sign host cert with root private key */\n\t\tX509_sign(host_cert, root_pkey, EVP_sha1());\n\t}\n\n\tif (root_cert && root_pkey && host_cert && host_pkey) {\n\t\tBIO* membp;\n\t\tchar *bdata;\n\n\t\tmembp = BIO_new(BIO_s_mem());\n\t\tif (PEM_write_bio_X509(membp, root_cert) > 0) {\n\t\t\troot_cert_pem.size = BIO_get_mem_data(membp, &bdata);\n\t\t\troot_cert_pem.data = (unsigned char*)malloc(root_cert_pem.size);\n\t\t\tif (root_cert_pem.data) {\n\t\t\t\tmemcpy(root_cert_pem.data, bdata, root_cert_pem.size);\n\t\t\t}\n\t\t\tBIO_free(membp);\n\t\t\tmembp = NULL;\n\t\t}\n\t\tmembp = BIO_new(BIO_s_mem());\n\t\tif (PEM_write_bio_PrivateKey(membp, root_pkey, NULL, NULL, 0, 0, NULL) > 0) {\n\t\t\troot_key_pem.size = BIO_get_mem_data(membp, &bdata);\n\t\t\troot_key_pem.data = (unsigned char*)malloc(root_key_pem.size);\n\t\t\tif (root_key_pem.data) {\n\t\t\t\tmemcpy(root_key_pem.data, bdata, root_key_pem.size);\n\t\t\t}\n\t\t\tBIO_free(membp);\n\t\t\tmembp = NULL;\n\t\t}\n\t\tmembp = BIO_new(BIO_s_mem());\n\t\tif (PEM_write_bio_X509(membp, host_cert) > 0) {\n\t\t\thost_cert_pem.size = BIO_get_mem_data(membp, &bdata);\n\t\t\thost_cert_pem.data = (unsigned char*)malloc(host_cert_pem.size);\n\t\t\tif (host_cert_pem.data) {\n\t\t\t\tmemcpy(host_cert_pem.data, bdata, host_cert_pem.size);\n\t\t\t}\n\t\t\tBIO_free(membp);\n\t\t\tmembp = NULL;\n\t\t}\n\t\tmembp = BIO_new(BIO_s_mem());\n\t\tif (PEM_write_bio_PrivateKey(membp, host_pkey, NULL, NULL, 0, 0, NULL) > 0) {\n\t\t\thost_key_pem.size = BIO_get_mem_data(membp, &bdata);\n\t\t\thost_key_pem.data = (unsigned char*)malloc(host_key_pem.size);\n\t\t\tif (host_key_pem.data) {\n\t\t\t\tmemcpy(host_key_pem.data, bdata, host_key_pem.size);\n\t\t\t}\n\t\t\tBIO_free(membp);\n\t\t\tmembp = NULL;\n\t\t}\n\t}\n\n\tRSA *pubkey = NULL;\n\t{\n\t\tBIO *membp = BIO_new_mem_buf(public_key.data, public_key.size);\n\t\tif (!PEM_read_bio_RSAPublicKey(membp, &pubkey, NULL, NULL)) {\n\t\t\tdebug_info(\"WARNING: Could not read public key\");\n\t\t}\n\t\tBIO_free(membp);\n\t}\n\n\tX509* dev_cert = X509_new();\n\tif (pubkey && dev_cert) {\n\t\t/* generate device certificate */\n\t\tASN1_INTEGER* sn = ASN1_INTEGER_new();\n\t\tASN1_INTEGER_set(sn, 0);\n\t\tX509_set_serialNumber(dev_cert, sn);\n\t\tASN1_INTEGER_free(sn);\n\t\tX509_set_version(dev_cert, 2);\n\n\t\tX509_add_ext_helper(dev_cert, NID_basic_constraints, (char*)\"critical,CA:FALSE\");\n\n\t\tASN1_TIME* asn1time = ASN1_TIME_new();\n\t\tASN1_TIME_set(asn1time, time(NULL));\n\t\tX509_set_notBefore(dev_cert, asn1time);\n\t\tASN1_TIME_set(asn1time, time(NULL) + (60 * 60 * 24 * 365 * 10));\n\t\tX509_set_notAfter(dev_cert, asn1time);\n\t\tASN1_TIME_free(asn1time);\n\n\t\tEVP_PKEY* pkey = EVP_PKEY_new();\n\t\tEVP_PKEY_assign_RSA(pkey, pubkey);\n\t\tX509_set_pubkey(dev_cert, pkey);\n\t\tEVP_PKEY_free(pkey);\n\n\t\tX509_add_ext_helper(dev_cert, NID_subject_key_identifier, (char*)\"hash\");\n\t\tX509_add_ext_helper(dev_cert, NID_key_usage, (char*)\"critical,digitalSignature,keyEncipherment\");\n\n\t\t/* sign device certificate with root private key */\n\t\tif (X509_sign(dev_cert, root_pkey, EVP_sha1())) {\n\t\t\t/* if signing succeeded, export in PEM format */\n\t\t\tBIO* membp = BIO_new(BIO_s_mem());\n\t\t\tif (PEM_write_bio_X509(membp, dev_cert) > 0) {\n\t\t\t\tchar *bdata = NULL;\n\t\t\t\tdev_cert_pem.size = BIO_get_mem_data(membp, &bdata);\n\t\t\t\tdev_cert_pem.data = (unsigned char*)malloc(dev_cert_pem.size);\n\t\t\t\tif (dev_cert_pem.data) {\n\t\t\t\t\tmemcpy(dev_cert_pem.data, bdata, dev_cert_pem.size);\n\t\t\t\t}\n\t\t\t\tBIO_free(membp);\n\t\t\t\tmembp = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tdebug_info(\"ERROR: Signing device certificate with root private key failed!\");\n\t\t}\n\t}\n\n\tX509V3_EXT_cleanup();\n\tX509_free(dev_cert);\n\n\tEVP_PKEY_free(root_pkey);\n\tEVP_PKEY_free(host_pkey);\n\n\tX509_free(host_cert);\n\tX509_free(root_cert);\n#else\n\tgnutls_x509_privkey_t root_privkey;\n\tgnutls_x509_crt_t root_cert;\n\tgnutls_x509_privkey_t host_privkey;\n\tgnutls_x509_crt_t host_cert;\n\n\t/* use less secure random to speed up key generation */\n\tgcry_control(GCRYCTL_ENABLE_QUICK_RANDOM);\n\n\tgnutls_x509_privkey_init(&root_privkey);\n\tgnutls_x509_privkey_init(&host_privkey);\n\n\tgnutls_x509_crt_init(&root_cert);\n\tgnutls_x509_crt_init(&host_cert);\n\n\t/* generate root key */\n\tgnutls_x509_privkey_generate(root_privkey, GNUTLS_PK_RSA, 2048, 0);\n\tgnutls_x509_privkey_generate(host_privkey, GNUTLS_PK_RSA, 2048, 0);\n\n\t/* generate certificates */\n\tgnutls_x509_crt_set_key(root_cert, root_privkey);\n\tgnutls_x509_crt_set_serial(root_cert, \"\\x00\", 1);\n\tgnutls_x509_crt_set_version(root_cert, 3);\n\tgnutls_x509_crt_set_ca_status(root_cert, 1);\n\tgnutls_x509_crt_set_activation_time(root_cert, time(NULL));\n\tgnutls_x509_crt_set_expiration_time(root_cert, time(NULL) + (60 * 60 * 24 * 365 * 10));\n\tgnutls_x509_crt_sign(root_cert, root_cert, root_privkey);\n\n\tgnutls_x509_crt_set_key(host_cert, host_privkey);\n\tgnutls_x509_crt_set_serial(host_cert, \"\\x00\", 1);\n\tgnutls_x509_crt_set_version(host_cert, 3);\n\tgnutls_x509_crt_set_ca_status(host_cert, 0);\n\tgnutls_x509_crt_set_key_usage(host_cert, GNUTLS_KEY_KEY_ENCIPHERMENT | GNUTLS_KEY_DIGITAL_SIGNATURE);\n\tgnutls_x509_crt_set_activation_time(host_cert, time(NULL));\n\tgnutls_x509_crt_set_expiration_time(host_cert, time(NULL) + (60 * 60 * 24 * 365 * 10));\n\tgnutls_x509_crt_sign(host_cert, root_cert, root_privkey);\n\n\t/* export to PEM format */\n\tsize_t root_key_export_size = 0;\n\tsize_t host_key_export_size = 0;\n\n\tgnutls_x509_privkey_export(root_privkey, GNUTLS_X509_FMT_PEM, NULL, &root_key_export_size);\n\tgnutls_x509_privkey_export(host_privkey, GNUTLS_X509_FMT_PEM, NULL, &host_key_export_size);\n\n\troot_key_pem.data = gnutls_malloc(root_key_export_size);\n\thost_key_pem.data = gnutls_malloc(host_key_export_size);\n\n\tgnutls_x509_privkey_export(root_privkey, GNUTLS_X509_FMT_PEM, root_key_pem.data, &root_key_export_size);\n\troot_key_pem.size = root_key_export_size;\n\tgnutls_x509_privkey_export(host_privkey, GNUTLS_X509_FMT_PEM, host_key_pem.data, &host_key_export_size);\n\thost_key_pem.size = host_key_export_size;\n\n\tsize_t root_cert_export_size = 0;\n\tsize_t host_cert_export_size = 0;\n\n\tgnutls_x509_crt_export(root_cert, GNUTLS_X509_FMT_PEM, NULL, &root_cert_export_size);\n\tgnutls_x509_crt_export(host_cert, GNUTLS_X509_FMT_PEM, NULL, &host_cert_export_size);\n\n\troot_cert_pem.data = gnutls_malloc(root_cert_export_size);\n\thost_cert_pem.data = gnutls_malloc(host_cert_export_size);\n\n\tgnutls_x509_crt_export(root_cert, GNUTLS_X509_FMT_PEM, root_cert_pem.data, &root_cert_export_size);\n\troot_cert_pem.size = root_cert_export_size;\n\tgnutls_x509_crt_export(host_cert, GNUTLS_X509_FMT_PEM, host_cert_pem.data, &host_cert_export_size);\n\thost_cert_pem.size = host_cert_export_size;\n\n\tret = USERPREF_E_UNKNOWN_ERROR;\n\n\tgnutls_datum_t modulus = { NULL, 0 };\n\tgnutls_datum_t exponent = { NULL, 0 };\n\n\t/* now decode the PEM encoded key */\n\tgnutls_datum_t der_pub_key;\n\tif (GNUTLS_E_SUCCESS == gnutls_pem_base64_decode_alloc(\"RSA PUBLIC KEY\", &public_key, &der_pub_key)) {\n\n\t\t/* initalize asn.1 parser */\n\t\tASN1_TYPE pkcs1 = ASN1_TYPE_EMPTY;\n\t\tif (ASN1_SUCCESS == asn1_array2tree(pkcs1_asn1_tab, &pkcs1, NULL)) {\n\n\t\t\tASN1_TYPE asn1_pub_key = ASN1_TYPE_EMPTY;\n\t\t\tasn1_create_element(pkcs1, \"PKCS1.RSAPublicKey\", &asn1_pub_key);\n\n\t\t\tif (ASN1_SUCCESS == asn1_der_decoding(&asn1_pub_key, der_pub_key.data, der_pub_key.size, NULL)) {\n\n\t\t\t\t/* get size to read */\n\t\t\t\tint ret1 = asn1_read_value(asn1_pub_key, \"modulus\", NULL, (int*)&modulus.size);\n\t\t\t\tint ret2 = asn1_read_value(asn1_pub_key, \"publicExponent\", NULL, (int*)&exponent.size);\n\n\t\t\t\tmodulus.data = gnutls_malloc(modulus.size);\n\t\t\t\texponent.data = gnutls_malloc(exponent.size);\n\n\t\t\t\tret1 = asn1_read_value(asn1_pub_key, \"modulus\", modulus.data, (int*)&modulus.size);\n\t\t\t\tret2 = asn1_read_value(asn1_pub_key, \"publicExponent\", exponent.data, (int*)&exponent.size);\n\t\t\t\tif (ASN1_SUCCESS == ret1 && ASN1_SUCCESS == ret2)\n\t\t\t\t\tret = USERPREF_E_SUCCESS;\n\t\t\t}\n\t\t\tif (asn1_pub_key)\n\t\t\t\tasn1_delete_structure(&asn1_pub_key);\n\t\t}\n\t\tif (pkcs1)\n\t\t\tasn1_delete_structure(&pkcs1);\n\t} else {\n\t\tdebug_info(\"WARNING: Could not read public key\");\n\t}\n\n\t/* now generate certificates */\n\tif (USERPREF_E_SUCCESS == ret && 0 != modulus.size && 0 != exponent.size) {\n\t\tgnutls_datum_t essentially_null = { (unsigned char*)strdup(\"abababababababab\"), strlen(\"abababababababab\") };\n\n\t\tgnutls_x509_privkey_t fake_privkey;\n\t\tgnutls_x509_crt_t dev_cert;\n\n\t\tgnutls_x509_privkey_init(&fake_privkey);\n\t\tgnutls_x509_crt_init(&dev_cert);\n\n\t\tif (GNUTLS_E_SUCCESS == gnutls_x509_privkey_import_rsa_raw(fake_privkey, &modulus, &exponent, &essentially_null, &essentially_null, &essentially_null, &essentially_null)) {\n\t\t\t/* generate device certificate */\n\t\t\tgnutls_x509_crt_set_key(dev_cert, fake_privkey);\n\t\t\tgnutls_x509_crt_set_serial(dev_cert, \"\\x00\", 1);\n\t\t\tgnutls_x509_crt_set_version(dev_cert, 3);\n\t\t\tgnutls_x509_crt_set_ca_status(dev_cert, 0);\n\t\t\tgnutls_x509_crt_set_activation_time(dev_cert, time(NULL));\n\t\t\tgnutls_x509_crt_set_expiration_time(dev_cert, time(NULL) + (60 * 60 * 24 * 365 * 10));\n\n\t\t\t/* use custom hash generation for compatibility with the \"Apple ecosystem\" */\n\t\t\tconst gnutls_digest_algorithm_t dig_sha1 = GNUTLS_DIG_SHA1;\n\t\t\tsize_t hash_size = gnutls_hash_get_len(dig_sha1);\n\t\t\tunsigned char hash[hash_size];\n\t\t\tif (gnutls_hash_fast(dig_sha1, der_pub_key.data, der_pub_key.size, (unsigned char*)&hash) < 0) {\n\t\t\t\tdebug_info(\"ERROR: Failed to generate SHA1 for public key\");\n\t\t\t} else {\n\t\t\t\tgnutls_x509_crt_set_subject_key_id(dev_cert, hash, hash_size);\n\t\t\t}\n\n\t\t\tgnutls_x509_crt_set_key_usage(dev_cert, GNUTLS_KEY_DIGITAL_SIGNATURE | GNUTLS_KEY_KEY_ENCIPHERMENT);\n\t\t\tgnutls_x509_crt_sign(dev_cert, root_cert, root_privkey);\n\n\t\t\tif (USERPREF_E_SUCCESS == ret) {\n\t\t\t\t/* if everything went well, export in PEM format */\n\t\t\t\tsize_t export_size = 0;\n\t\t\t\tgnutls_x509_crt_export(dev_cert, GNUTLS_X509_FMT_PEM, NULL, &export_size);\n\t\t\t\tdev_cert_pem.data = gnutls_malloc(export_size);\n\t\t\t\tgnutls_x509_crt_export(dev_cert, GNUTLS_X509_FMT_PEM, dev_cert_pem.data, &export_size);\n\t\t\t\tdev_cert_pem.size = export_size;\n\t\t\t} else {\n\t\t\t\tdebug_info(\"ERROR: Signing device certificate with root private key failed!\");\n\t\t\t}\n\t\t}\n\n\t\tif (essentially_null.data)\n\t\t\tfree(essentially_null.data);\n\n\t\tgnutls_x509_crt_deinit(dev_cert);\n\t\tgnutls_x509_privkey_deinit(fake_privkey);\n\t}\n\n\tgnutls_x509_crt_deinit(root_cert);\n\tgnutls_x509_crt_deinit(host_cert);\n\tgnutls_x509_privkey_deinit(root_privkey);\n\tgnutls_x509_privkey_deinit(host_privkey);\n\n\tgnutls_free(modulus.data);\n\tgnutls_free(exponent.data);\n\n\tgnutls_free(der_pub_key.data);\n#endif\n\tif (NULL != root_cert_pem.data && 0 != root_cert_pem.size &&\n\t\tNULL != host_cert_pem.data && 0 != host_cert_pem.size)\n\t\tret = USERPREF_E_SUCCESS;\n\n\t/* now set keys and certificates */\n\tpair_record_set_item_from_key_data(pair_record, USERPREF_DEVICE_CERTIFICATE_KEY, &dev_cert_pem);\n\tpair_record_set_item_from_key_data(pair_record, USERPREF_HOST_PRIVATE_KEY_KEY, &host_key_pem);\n\tpair_record_set_item_from_key_data(pair_record, USERPREF_HOST_CERTIFICATE_KEY, &host_cert_pem);\n\tpair_record_set_item_from_key_data(pair_record, USERPREF_ROOT_PRIVATE_KEY_KEY, &root_key_pem);\n\tpair_record_set_item_from_key_data(pair_record, USERPREF_ROOT_CERTIFICATE_KEY, &root_cert_pem);\n\n\tif (dev_cert_pem.data)\n\t\tfree(dev_cert_pem.data);\n\tif (root_key_pem.data)\n\t\tfree(root_key_pem.data);\n\tif (root_cert_pem.data)\n\t\tfree(root_cert_pem.data);\n\tif (host_key_pem.data)\n\t\tfree(host_key_pem.data);\n\tif (host_cert_pem.data)\n\t\tfree(host_cert_pem.data);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"debug.h\"",
      "#include \"userpref.h\"",
      "#include <shlobj.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <libgen.h>",
      "#include <dirent.h>",
      "#include <libtasn1.h>",
      "#include <gcrypt.h>",
      "#include <gnutls/x509.h>",
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include <openssl/x509v3.h>",
      "#include <openssl/x509.h>",
      "#include <openssl/rsa.h>",
      "#include <openssl/pem.h>",
      "#include <usbmuxd.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "host_cert_pem.data"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "thread_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "39-44",
          "snippet": "void thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nvoid thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "pair_record_set_item_from_key_data",
          "args": [
            "pair_record",
            "USERPREF_ROOT_CERTIFICATE_KEY",
            "&root_cert_pem"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "pair_record_set_item_from_key_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/userpref.c",
          "lines": "920-932",
          "snippet": "userpref_error_t pair_record_set_item_from_key_data(plist_t pair_record, const char* name, key_data_t *value)\n{\n\tuserpref_error_t ret = USERPREF_E_SUCCESS;\n\n\tif (!pair_record || !value) {\n\t\treturn USERPREF_E_INVALID_ARG;\n\t}\n\n\t/* set new item */\n\tplist_dict_set_item(pair_record, name, plist_new_data((char*)value->data, value->size));\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"debug.h\"",
            "#include \"userpref.h\"",
            "#include <shlobj.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <libgen.h>",
            "#include <dirent.h>",
            "#include <libtasn1.h>",
            "#include <gcrypt.h>",
            "#include <gnutls/x509.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/x509v3.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/pem.h>",
            "#include <usbmuxd.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"debug.h\"\n#include \"userpref.h\"\n#include <shlobj.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <libtasn1.h>\n#include <gcrypt.h>\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/rsa.h>\n#include <openssl/pem.h>\n#include <usbmuxd.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <config.h>\n\nuserpref_error_t pair_record_set_item_from_key_data(plist_t pair_record, const char* name, key_data_t *value)\n{\n\tuserpref_error_t ret = USERPREF_E_SUCCESS;\n\n\tif (!pair_record || !value) {\n\t\treturn USERPREF_E_INVALID_ARG;\n\t}\n\n\t/* set new item */\n\tplist_dict_set_item(pair_record, name, plist_new_data((char*)value->data, value->size));\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gnutls_free",
          "args": [
            "der_pub_key.data"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_free",
          "args": [
            "exponent.data"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_free",
          "args": [
            "modulus.data"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_privkey_deinit",
          "args": [
            "host_privkey"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_privkey_deinit",
          "args": [
            "root_privkey"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_deinit",
          "args": [
            "host_cert"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_deinit",
          "args": [
            "root_cert"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_privkey_deinit",
          "args": [
            "fake_privkey"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_deinit",
          "args": [
            "dev_cert"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"ERROR: Signing device certificate with root private key failed!\""
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_export",
          "args": [
            "dev_cert",
            "GNUTLS_X509_FMT_PEM",
            "dev_cert_pem.data",
            "&export_size"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_malloc",
          "args": [
            "export_size"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_export",
          "args": [
            "dev_cert",
            "GNUTLS_X509_FMT_PEM",
            "NULL",
            "&export_size"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_sign",
          "args": [
            "dev_cert",
            "root_cert",
            "root_privkey"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_set_key_usage",
          "args": [
            "dev_cert",
            "GNUTLS_KEY_DIGITAL_SIGNATURE | GNUTLS_KEY_KEY_ENCIPHERMENT"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_set_subject_key_id",
          "args": [
            "dev_cert",
            "hash",
            "hash_size"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"ERROR: Failed to generate SHA1 for public key\""
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_hash_fast",
          "args": [
            "dig_sha1",
            "der_pub_key.data",
            "der_pub_key.size",
            "(unsigned char*)&hash"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_hash_get_len",
          "args": [
            "dig_sha1"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_set_expiration_time",
          "args": [
            "dev_cert",
            "time(NULL) + (60 * 60 * 24 * 365 * 10)"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_set_activation_time",
          "args": [
            "dev_cert",
            "time(NULL)"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_set_ca_status",
          "args": [
            "dev_cert",
            "0"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_set_version",
          "args": [
            "dev_cert",
            "3"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_set_serial",
          "args": [
            "dev_cert",
            "\"\\x00\"",
            "1"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_set_key",
          "args": [
            "dev_cert",
            "fake_privkey"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_privkey_import_rsa_raw",
          "args": [
            "fake_privkey",
            "&modulus",
            "&exponent",
            "&essentially_null",
            "&essentially_null",
            "&essentially_null",
            "&essentially_null"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_init",
          "args": [
            "&dev_cert"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_privkey_init",
          "args": [
            "&fake_privkey"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"abababababababab\""
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"abababababababab\""
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"WARNING: Could not read public key\""
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asn1_delete_structure",
          "args": [
            "&pkcs1"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asn1_delete_structure",
          "args": [
            "&asn1_pub_key"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asn1_read_value",
          "args": [
            "asn1_pub_key",
            "\"publicExponent\"",
            "exponent.data",
            "(int*)&exponent.size"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asn1_read_value",
          "args": [
            "asn1_pub_key",
            "\"modulus\"",
            "modulus.data",
            "(int*)&modulus.size"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_malloc",
          "args": [
            "exponent.size"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_malloc",
          "args": [
            "modulus.size"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asn1_read_value",
          "args": [
            "asn1_pub_key",
            "\"publicExponent\"",
            "NULL",
            "(int*)&exponent.size"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asn1_read_value",
          "args": [
            "asn1_pub_key",
            "\"modulus\"",
            "NULL",
            "(int*)&modulus.size"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asn1_der_decoding",
          "args": [
            "&asn1_pub_key",
            "der_pub_key.data",
            "der_pub_key.size",
            "NULL"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asn1_create_element",
          "args": [
            "pkcs1",
            "\"PKCS1.RSAPublicKey\"",
            "&asn1_pub_key"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asn1_array2tree",
          "args": [
            "pkcs1_asn1_tab",
            "&pkcs1",
            "NULL"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_pem_base64_decode_alloc",
          "args": [
            "\"RSA PUBLIC KEY\"",
            "&public_key",
            "&der_pub_key"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_export",
          "args": [
            "host_cert",
            "GNUTLS_X509_FMT_PEM",
            "host_cert_pem.data",
            "&host_cert_export_size"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_export",
          "args": [
            "root_cert",
            "GNUTLS_X509_FMT_PEM",
            "root_cert_pem.data",
            "&root_cert_export_size"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_malloc",
          "args": [
            "host_cert_export_size"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_malloc",
          "args": [
            "root_cert_export_size"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_export",
          "args": [
            "host_cert",
            "GNUTLS_X509_FMT_PEM",
            "NULL",
            "&host_cert_export_size"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_export",
          "args": [
            "root_cert",
            "GNUTLS_X509_FMT_PEM",
            "NULL",
            "&root_cert_export_size"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_privkey_export",
          "args": [
            "host_privkey",
            "GNUTLS_X509_FMT_PEM",
            "host_key_pem.data",
            "&host_key_export_size"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_privkey_export",
          "args": [
            "root_privkey",
            "GNUTLS_X509_FMT_PEM",
            "root_key_pem.data",
            "&root_key_export_size"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_malloc",
          "args": [
            "host_key_export_size"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_malloc",
          "args": [
            "root_key_export_size"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_privkey_export",
          "args": [
            "host_privkey",
            "GNUTLS_X509_FMT_PEM",
            "NULL",
            "&host_key_export_size"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_privkey_export",
          "args": [
            "root_privkey",
            "GNUTLS_X509_FMT_PEM",
            "NULL",
            "&root_key_export_size"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_sign",
          "args": [
            "host_cert",
            "root_cert",
            "root_privkey"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_set_expiration_time",
          "args": [
            "host_cert",
            "time(NULL) + (60 * 60 * 24 * 365 * 10)"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_set_activation_time",
          "args": [
            "host_cert",
            "time(NULL)"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_set_key_usage",
          "args": [
            "host_cert",
            "GNUTLS_KEY_KEY_ENCIPHERMENT | GNUTLS_KEY_DIGITAL_SIGNATURE"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_set_ca_status",
          "args": [
            "host_cert",
            "0"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_set_version",
          "args": [
            "host_cert",
            "3"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_set_serial",
          "args": [
            "host_cert",
            "\"\\x00\"",
            "1"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_set_key",
          "args": [
            "host_cert",
            "host_privkey"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_sign",
          "args": [
            "root_cert",
            "root_cert",
            "root_privkey"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_set_expiration_time",
          "args": [
            "root_cert",
            "time(NULL) + (60 * 60 * 24 * 365 * 10)"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_set_activation_time",
          "args": [
            "root_cert",
            "time(NULL)"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_set_ca_status",
          "args": [
            "root_cert",
            "1"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_set_version",
          "args": [
            "root_cert",
            "3"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_set_serial",
          "args": [
            "root_cert",
            "\"\\x00\"",
            "1"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_set_key",
          "args": [
            "root_cert",
            "root_privkey"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_privkey_generate",
          "args": [
            "host_privkey",
            "GNUTLS_PK_RSA",
            "2048",
            "0"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_privkey_generate",
          "args": [
            "root_privkey",
            "GNUTLS_PK_RSA",
            "2048",
            "0"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_init",
          "args": [
            "&host_cert"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_init",
          "args": [
            "&root_cert"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_privkey_init",
          "args": [
            "&host_privkey"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_privkey_init",
          "args": [
            "&root_privkey"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gcry_control",
          "args": [
            "GCRYCTL_ENABLE_QUICK_RANDOM"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_free",
          "args": [
            "root_cert"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_free",
          "args": [
            "host_cert"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_PKEY_free",
          "args": [
            "host_pkey"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_PKEY_free",
          "args": [
            "root_pkey"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_free",
          "args": [
            "dev_cert"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509V3_EXT_cleanup",
          "args": [],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"ERROR: Signing device certificate with root private key failed!\""
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIO_free",
          "args": [
            "membp"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dev_cert_pem.data",
            "bdata",
            "dev_cert_pem.size"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "dev_cert_pem.size"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIO_get_mem_data",
          "args": [
            "membp",
            "&bdata"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PEM_write_bio_X509",
          "args": [
            "membp",
            "dev_cert"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIO_new",
          "args": [
            "BIO_s_mem()"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIO_s_mem",
          "args": [],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_sign",
          "args": [
            "dev_cert",
            "root_pkey",
            "EVP_sha1()"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_sha1",
          "args": [],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_add_ext_helper",
          "args": [
            "dev_cert",
            "NID_key_usage",
            "(char*)\"critical,digitalSignature,keyEncipherment\""
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "X509_add_ext_helper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/userpref.c",
          "lines": "374-393",
          "snippet": "static int X509_add_ext_helper(X509 *cert, int nid, char *value)\n{\n\tX509_EXTENSION *ex;\n\tX509V3_CTX ctx;\n\n\t/* No configuration database */\n\tX509V3_set_ctx_nodb(&ctx);\n\n\tX509V3_set_ctx(&ctx, NULL, cert, NULL, NULL, 0);\n\tex = X509V3_EXT_conf_nid(NULL, &ctx, nid, value);\n\tif (!ex) {\n\t\tdebug_info(\"ERROR: X509V3_EXT_conf_nid(%d, %s) failed\", nid, value);\n\t\treturn 0;\n\t}\n\n\tX509_add_ext(cert, ex, -1);\n\tX509_EXTENSION_free(ex);\n\n\treturn 1;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"debug.h\"",
            "#include \"userpref.h\"",
            "#include <shlobj.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <libgen.h>",
            "#include <dirent.h>",
            "#include <libtasn1.h>",
            "#include <gcrypt.h>",
            "#include <gnutls/x509.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/x509v3.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/pem.h>",
            "#include <usbmuxd.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"debug.h\"\n#include \"userpref.h\"\n#include <shlobj.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <libtasn1.h>\n#include <gcrypt.h>\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/rsa.h>\n#include <openssl/pem.h>\n#include <usbmuxd.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int X509_add_ext_helper(X509 *cert, int nid, char *value)\n{\n\tX509_EXTENSION *ex;\n\tX509V3_CTX ctx;\n\n\t/* No configuration database */\n\tX509V3_set_ctx_nodb(&ctx);\n\n\tX509V3_set_ctx(&ctx, NULL, cert, NULL, NULL, 0);\n\tex = X509V3_EXT_conf_nid(NULL, &ctx, nid, value);\n\tif (!ex) {\n\t\tdebug_info(\"ERROR: X509V3_EXT_conf_nid(%d, %s) failed\", nid, value);\n\t\treturn 0;\n\t}\n\n\tX509_add_ext(cert, ex, -1);\n\tX509_EXTENSION_free(ex);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EVP_PKEY_free",
          "args": [
            "pkey"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_set_pubkey",
          "args": [
            "dev_cert",
            "pkey"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_PKEY_assign_RSA",
          "args": [
            "pkey",
            "pubkey"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_PKEY_new",
          "args": [],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASN1_TIME_free",
          "args": [
            "asn1time"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_set_notAfter",
          "args": [
            "dev_cert",
            "asn1time"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASN1_TIME_set",
          "args": [
            "asn1time",
            "time(NULL) + (60 * 60 * 24 * 365 * 10)"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_set_notBefore",
          "args": [
            "dev_cert",
            "asn1time"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASN1_TIME_set",
          "args": [
            "asn1time",
            "time(NULL)"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASN1_TIME_new",
          "args": [],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_set_version",
          "args": [
            "dev_cert",
            "2"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASN1_INTEGER_free",
          "args": [
            "sn"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_set_serialNumber",
          "args": [
            "dev_cert",
            "sn"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASN1_INTEGER_set",
          "args": [
            "sn",
            "0"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASN1_INTEGER_new",
          "args": [],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_new",
          "args": [],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIO_free",
          "args": [
            "membp"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"WARNING: Could not read public key\""
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PEM_read_bio_RSAPublicKey",
          "args": [
            "membp",
            "&pubkey",
            "NULL",
            "NULL"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIO_new_mem_buf",
          "args": [
            "public_key.data",
            "public_key.size"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIO_free",
          "args": [
            "membp"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "host_key_pem.data",
            "bdata",
            "host_key_pem.size"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "host_key_pem.size"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIO_get_mem_data",
          "args": [
            "membp",
            "&bdata"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PEM_write_bio_PrivateKey",
          "args": [
            "membp",
            "host_pkey",
            "NULL",
            "NULL",
            "0",
            "0",
            "NULL"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIO_new",
          "args": [
            "BIO_s_mem()"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIO_s_mem",
          "args": [],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIO_free",
          "args": [
            "membp"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "host_cert_pem.data",
            "bdata",
            "host_cert_pem.size"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "host_cert_pem.size"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIO_get_mem_data",
          "args": [
            "membp",
            "&bdata"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PEM_write_bio_X509",
          "args": [
            "membp",
            "host_cert"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIO_new",
          "args": [
            "BIO_s_mem()"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIO_s_mem",
          "args": [],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIO_free",
          "args": [
            "membp"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "root_key_pem.data",
            "bdata",
            "root_key_pem.size"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "root_key_pem.size"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIO_get_mem_data",
          "args": [
            "membp",
            "&bdata"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PEM_write_bio_PrivateKey",
          "args": [
            "membp",
            "root_pkey",
            "NULL",
            "NULL",
            "0",
            "0",
            "NULL"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIO_new",
          "args": [
            "BIO_s_mem()"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIO_s_mem",
          "args": [],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIO_free",
          "args": [
            "membp"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "root_cert_pem.data",
            "bdata",
            "root_cert_pem.size"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "root_cert_pem.size"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIO_get_mem_data",
          "args": [
            "membp",
            "&bdata"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PEM_write_bio_X509",
          "args": [
            "membp",
            "root_cert"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIO_new",
          "args": [
            "BIO_s_mem()"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIO_s_mem",
          "args": [],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_sign",
          "args": [
            "host_cert",
            "root_pkey",
            "EVP_sha1()"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_sha1",
          "args": [],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_set_pubkey",
          "args": [
            "host_cert",
            "host_pkey"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASN1_TIME_free",
          "args": [
            "asn1time"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_set_notAfter",
          "args": [
            "host_cert",
            "asn1time"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASN1_TIME_set",
          "args": [
            "asn1time",
            "time(NULL) + (60 * 60 * 24 * 365 * 10)"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_set_notBefore",
          "args": [
            "host_cert",
            "asn1time"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASN1_TIME_set",
          "args": [
            "asn1time",
            "time(NULL)"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASN1_TIME_new",
          "args": [],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_set_version",
          "args": [
            "host_cert",
            "2"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASN1_INTEGER_free",
          "args": [
            "sn"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_set_serialNumber",
          "args": [
            "host_cert",
            "sn"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASN1_INTEGER_set",
          "args": [
            "sn",
            "0"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASN1_INTEGER_new",
          "args": [],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_new",
          "args": [],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_sign",
          "args": [
            "root_cert",
            "root_pkey",
            "EVP_sha1()"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_sha1",
          "args": [],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_set_pubkey",
          "args": [
            "root_cert",
            "root_pkey"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASN1_TIME_free",
          "args": [
            "asn1time"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_set_notAfter",
          "args": [
            "root_cert",
            "asn1time"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASN1_TIME_set",
          "args": [
            "asn1time",
            "time(NULL) + (60 * 60 * 24 * 365 * 10)"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_set_notBefore",
          "args": [
            "root_cert",
            "asn1time"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASN1_TIME_set",
          "args": [
            "asn1time",
            "time(NULL)"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASN1_TIME_new",
          "args": [],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_set_version",
          "args": [
            "root_cert",
            "2"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASN1_INTEGER_free",
          "args": [
            "sn"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_set_serialNumber",
          "args": [
            "root_cert",
            "sn"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASN1_INTEGER_set",
          "args": [
            "sn",
            "0"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASN1_INTEGER_new",
          "args": [],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_new",
          "args": [],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_PKEY_assign_RSA",
          "args": [
            "host_pkey",
            "host_keypair"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_PKEY_new",
          "args": [],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_PKEY_assign_RSA",
          "args": [
            "root_pkey",
            "root_keypair"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_PKEY_new",
          "args": [],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_free",
          "args": [
            "e"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RSA_generate_key_ex",
          "args": [
            "host_keypair",
            "2048",
            "e",
            "NULL"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RSA_generate_key_ex",
          "args": [
            "root_keypair",
            "2048",
            "e",
            "NULL"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_set_word",
          "args": [
            "e",
            "65537"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RSA_new",
          "args": [],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RSA_new",
          "args": [],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_new",
          "args": [],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"Generating keys and certificates...\""
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"debug.h\"\n#include \"userpref.h\"\n#include <shlobj.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <libtasn1.h>\n#include <gcrypt.h>\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/rsa.h>\n#include <openssl/pem.h>\n#include <usbmuxd.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <config.h>\n\nuserpref_error_t pair_record_generate_keys_and_certs(plist_t pair_record, key_data_t public_key)\n{\n\tuserpref_error_t ret = USERPREF_E_SSL_ERROR;\n\n\tkey_data_t dev_cert_pem = { NULL, 0 };\n\tkey_data_t root_key_pem = { NULL, 0 };\n\tkey_data_t root_cert_pem = { NULL, 0 };\n\tkey_data_t host_key_pem = { NULL, 0 };\n\tkey_data_t host_cert_pem = { NULL, 0 };\n\n\tif (!pair_record || !public_key.data)\n\t\treturn USERPREF_E_INVALID_ARG;\n\n\tdebug_info(\"Generating keys and certificates...\");\n\n#ifdef HAVE_OPENSSL\n\tBIGNUM *e = BN_new();\n\tRSA* root_keypair = RSA_new();\n\tRSA* host_keypair = RSA_new();\n\n\tBN_set_word(e, 65537);\n\n\tRSA_generate_key_ex(root_keypair, 2048, e, NULL);\n\tRSA_generate_key_ex(host_keypair, 2048, e, NULL);\n\n\tBN_free(e);\n\n\tEVP_PKEY* root_pkey = EVP_PKEY_new();\n\tEVP_PKEY_assign_RSA(root_pkey, root_keypair);\n\n\tEVP_PKEY* host_pkey = EVP_PKEY_new();\n\tEVP_PKEY_assign_RSA(host_pkey, host_keypair);\n\n\t/* generate root certificate */\n\tX509* root_cert = X509_new();\n\t{\n\t\t/* set serial number */\n\t\tASN1_INTEGER* sn = ASN1_INTEGER_new();\n\t\tASN1_INTEGER_set(sn, 0);\n\t\tX509_set_serialNumber(root_cert, sn);\n\t\tASN1_INTEGER_free(sn);\n\n\t\t/* set version */\n\t\tX509_set_version(root_cert, 2);\n\n\t\t/* set x509v3 basic constraints */\n\t\tX509_add_ext_helper(root_cert, NID_basic_constraints, (char*)\"critical,CA:TRUE\");\n\n\t\t/* set key validity */\n\t\tASN1_TIME* asn1time = ASN1_TIME_new();\n\t\tASN1_TIME_set(asn1time, time(NULL));\n\t\tX509_set_notBefore(root_cert, asn1time);\n\t\tASN1_TIME_set(asn1time, time(NULL) + (60 * 60 * 24 * 365 * 10));\n\t\tX509_set_notAfter(root_cert, asn1time);\n\t\tASN1_TIME_free(asn1time);\n\n\t\t/* use root public key for root cert */\n\t\tX509_set_pubkey(root_cert, root_pkey);\n\n\t\t/* sign root cert with root private key */\n\t\tX509_sign(root_cert, root_pkey, EVP_sha1());\n\t}\n\n\t/* create host certificate */\n\tX509* host_cert = X509_new();\n\t{\n\t\t/* set serial number */\n\t\tASN1_INTEGER* sn = ASN1_INTEGER_new();\n\t\tASN1_INTEGER_set(sn, 0);\n\t\tX509_set_serialNumber(host_cert, sn);\n\t\tASN1_INTEGER_free(sn);\n\n\t\t/* set version */\n\t\tX509_set_version(host_cert, 2);\n\n\t\t/* set x509v3 basic constraints */\n\t\tX509_add_ext_helper(host_cert, NID_basic_constraints, (char*)\"critical,CA:FALSE\");\n\n\t\t/* set x509v3 key usage */\n\t\tX509_add_ext_helper(host_cert, NID_key_usage, (char*)\"critical,digitalSignature,keyEncipherment\");\n\n\t\t/* set key validity */\n\t\tASN1_TIME* asn1time = ASN1_TIME_new();\n\t\tASN1_TIME_set(asn1time, time(NULL));\n\t\tX509_set_notBefore(host_cert, asn1time);\n\t\tASN1_TIME_set(asn1time, time(NULL) + (60 * 60 * 24 * 365 * 10));\n\t\tX509_set_notAfter(host_cert, asn1time);\n\t\tASN1_TIME_free(asn1time);\n\n\t\t/* use host public key for host cert */\n\t\tX509_set_pubkey(host_cert, host_pkey);\n\n\t\t/* sign host cert with root private key */\n\t\tX509_sign(host_cert, root_pkey, EVP_sha1());\n\t}\n\n\tif (root_cert && root_pkey && host_cert && host_pkey) {\n\t\tBIO* membp;\n\t\tchar *bdata;\n\n\t\tmembp = BIO_new(BIO_s_mem());\n\t\tif (PEM_write_bio_X509(membp, root_cert) > 0) {\n\t\t\troot_cert_pem.size = BIO_get_mem_data(membp, &bdata);\n\t\t\troot_cert_pem.data = (unsigned char*)malloc(root_cert_pem.size);\n\t\t\tif (root_cert_pem.data) {\n\t\t\t\tmemcpy(root_cert_pem.data, bdata, root_cert_pem.size);\n\t\t\t}\n\t\t\tBIO_free(membp);\n\t\t\tmembp = NULL;\n\t\t}\n\t\tmembp = BIO_new(BIO_s_mem());\n\t\tif (PEM_write_bio_PrivateKey(membp, root_pkey, NULL, NULL, 0, 0, NULL) > 0) {\n\t\t\troot_key_pem.size = BIO_get_mem_data(membp, &bdata);\n\t\t\troot_key_pem.data = (unsigned char*)malloc(root_key_pem.size);\n\t\t\tif (root_key_pem.data) {\n\t\t\t\tmemcpy(root_key_pem.data, bdata, root_key_pem.size);\n\t\t\t}\n\t\t\tBIO_free(membp);\n\t\t\tmembp = NULL;\n\t\t}\n\t\tmembp = BIO_new(BIO_s_mem());\n\t\tif (PEM_write_bio_X509(membp, host_cert) > 0) {\n\t\t\thost_cert_pem.size = BIO_get_mem_data(membp, &bdata);\n\t\t\thost_cert_pem.data = (unsigned char*)malloc(host_cert_pem.size);\n\t\t\tif (host_cert_pem.data) {\n\t\t\t\tmemcpy(host_cert_pem.data, bdata, host_cert_pem.size);\n\t\t\t}\n\t\t\tBIO_free(membp);\n\t\t\tmembp = NULL;\n\t\t}\n\t\tmembp = BIO_new(BIO_s_mem());\n\t\tif (PEM_write_bio_PrivateKey(membp, host_pkey, NULL, NULL, 0, 0, NULL) > 0) {\n\t\t\thost_key_pem.size = BIO_get_mem_data(membp, &bdata);\n\t\t\thost_key_pem.data = (unsigned char*)malloc(host_key_pem.size);\n\t\t\tif (host_key_pem.data) {\n\t\t\t\tmemcpy(host_key_pem.data, bdata, host_key_pem.size);\n\t\t\t}\n\t\t\tBIO_free(membp);\n\t\t\tmembp = NULL;\n\t\t}\n\t}\n\n\tRSA *pubkey = NULL;\n\t{\n\t\tBIO *membp = BIO_new_mem_buf(public_key.data, public_key.size);\n\t\tif (!PEM_read_bio_RSAPublicKey(membp, &pubkey, NULL, NULL)) {\n\t\t\tdebug_info(\"WARNING: Could not read public key\");\n\t\t}\n\t\tBIO_free(membp);\n\t}\n\n\tX509* dev_cert = X509_new();\n\tif (pubkey && dev_cert) {\n\t\t/* generate device certificate */\n\t\tASN1_INTEGER* sn = ASN1_INTEGER_new();\n\t\tASN1_INTEGER_set(sn, 0);\n\t\tX509_set_serialNumber(dev_cert, sn);\n\t\tASN1_INTEGER_free(sn);\n\t\tX509_set_version(dev_cert, 2);\n\n\t\tX509_add_ext_helper(dev_cert, NID_basic_constraints, (char*)\"critical,CA:FALSE\");\n\n\t\tASN1_TIME* asn1time = ASN1_TIME_new();\n\t\tASN1_TIME_set(asn1time, time(NULL));\n\t\tX509_set_notBefore(dev_cert, asn1time);\n\t\tASN1_TIME_set(asn1time, time(NULL) + (60 * 60 * 24 * 365 * 10));\n\t\tX509_set_notAfter(dev_cert, asn1time);\n\t\tASN1_TIME_free(asn1time);\n\n\t\tEVP_PKEY* pkey = EVP_PKEY_new();\n\t\tEVP_PKEY_assign_RSA(pkey, pubkey);\n\t\tX509_set_pubkey(dev_cert, pkey);\n\t\tEVP_PKEY_free(pkey);\n\n\t\tX509_add_ext_helper(dev_cert, NID_subject_key_identifier, (char*)\"hash\");\n\t\tX509_add_ext_helper(dev_cert, NID_key_usage, (char*)\"critical,digitalSignature,keyEncipherment\");\n\n\t\t/* sign device certificate with root private key */\n\t\tif (X509_sign(dev_cert, root_pkey, EVP_sha1())) {\n\t\t\t/* if signing succeeded, export in PEM format */\n\t\t\tBIO* membp = BIO_new(BIO_s_mem());\n\t\t\tif (PEM_write_bio_X509(membp, dev_cert) > 0) {\n\t\t\t\tchar *bdata = NULL;\n\t\t\t\tdev_cert_pem.size = BIO_get_mem_data(membp, &bdata);\n\t\t\t\tdev_cert_pem.data = (unsigned char*)malloc(dev_cert_pem.size);\n\t\t\t\tif (dev_cert_pem.data) {\n\t\t\t\t\tmemcpy(dev_cert_pem.data, bdata, dev_cert_pem.size);\n\t\t\t\t}\n\t\t\t\tBIO_free(membp);\n\t\t\t\tmembp = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tdebug_info(\"ERROR: Signing device certificate with root private key failed!\");\n\t\t}\n\t}\n\n\tX509V3_EXT_cleanup();\n\tX509_free(dev_cert);\n\n\tEVP_PKEY_free(root_pkey);\n\tEVP_PKEY_free(host_pkey);\n\n\tX509_free(host_cert);\n\tX509_free(root_cert);\n#else\n\tgnutls_x509_privkey_t root_privkey;\n\tgnutls_x509_crt_t root_cert;\n\tgnutls_x509_privkey_t host_privkey;\n\tgnutls_x509_crt_t host_cert;\n\n\t/* use less secure random to speed up key generation */\n\tgcry_control(GCRYCTL_ENABLE_QUICK_RANDOM);\n\n\tgnutls_x509_privkey_init(&root_privkey);\n\tgnutls_x509_privkey_init(&host_privkey);\n\n\tgnutls_x509_crt_init(&root_cert);\n\tgnutls_x509_crt_init(&host_cert);\n\n\t/* generate root key */\n\tgnutls_x509_privkey_generate(root_privkey, GNUTLS_PK_RSA, 2048, 0);\n\tgnutls_x509_privkey_generate(host_privkey, GNUTLS_PK_RSA, 2048, 0);\n\n\t/* generate certificates */\n\tgnutls_x509_crt_set_key(root_cert, root_privkey);\n\tgnutls_x509_crt_set_serial(root_cert, \"\\x00\", 1);\n\tgnutls_x509_crt_set_version(root_cert, 3);\n\tgnutls_x509_crt_set_ca_status(root_cert, 1);\n\tgnutls_x509_crt_set_activation_time(root_cert, time(NULL));\n\tgnutls_x509_crt_set_expiration_time(root_cert, time(NULL) + (60 * 60 * 24 * 365 * 10));\n\tgnutls_x509_crt_sign(root_cert, root_cert, root_privkey);\n\n\tgnutls_x509_crt_set_key(host_cert, host_privkey);\n\tgnutls_x509_crt_set_serial(host_cert, \"\\x00\", 1);\n\tgnutls_x509_crt_set_version(host_cert, 3);\n\tgnutls_x509_crt_set_ca_status(host_cert, 0);\n\tgnutls_x509_crt_set_key_usage(host_cert, GNUTLS_KEY_KEY_ENCIPHERMENT | GNUTLS_KEY_DIGITAL_SIGNATURE);\n\tgnutls_x509_crt_set_activation_time(host_cert, time(NULL));\n\tgnutls_x509_crt_set_expiration_time(host_cert, time(NULL) + (60 * 60 * 24 * 365 * 10));\n\tgnutls_x509_crt_sign(host_cert, root_cert, root_privkey);\n\n\t/* export to PEM format */\n\tsize_t root_key_export_size = 0;\n\tsize_t host_key_export_size = 0;\n\n\tgnutls_x509_privkey_export(root_privkey, GNUTLS_X509_FMT_PEM, NULL, &root_key_export_size);\n\tgnutls_x509_privkey_export(host_privkey, GNUTLS_X509_FMT_PEM, NULL, &host_key_export_size);\n\n\troot_key_pem.data = gnutls_malloc(root_key_export_size);\n\thost_key_pem.data = gnutls_malloc(host_key_export_size);\n\n\tgnutls_x509_privkey_export(root_privkey, GNUTLS_X509_FMT_PEM, root_key_pem.data, &root_key_export_size);\n\troot_key_pem.size = root_key_export_size;\n\tgnutls_x509_privkey_export(host_privkey, GNUTLS_X509_FMT_PEM, host_key_pem.data, &host_key_export_size);\n\thost_key_pem.size = host_key_export_size;\n\n\tsize_t root_cert_export_size = 0;\n\tsize_t host_cert_export_size = 0;\n\n\tgnutls_x509_crt_export(root_cert, GNUTLS_X509_FMT_PEM, NULL, &root_cert_export_size);\n\tgnutls_x509_crt_export(host_cert, GNUTLS_X509_FMT_PEM, NULL, &host_cert_export_size);\n\n\troot_cert_pem.data = gnutls_malloc(root_cert_export_size);\n\thost_cert_pem.data = gnutls_malloc(host_cert_export_size);\n\n\tgnutls_x509_crt_export(root_cert, GNUTLS_X509_FMT_PEM, root_cert_pem.data, &root_cert_export_size);\n\troot_cert_pem.size = root_cert_export_size;\n\tgnutls_x509_crt_export(host_cert, GNUTLS_X509_FMT_PEM, host_cert_pem.data, &host_cert_export_size);\n\thost_cert_pem.size = host_cert_export_size;\n\n\tret = USERPREF_E_UNKNOWN_ERROR;\n\n\tgnutls_datum_t modulus = { NULL, 0 };\n\tgnutls_datum_t exponent = { NULL, 0 };\n\n\t/* now decode the PEM encoded key */\n\tgnutls_datum_t der_pub_key;\n\tif (GNUTLS_E_SUCCESS == gnutls_pem_base64_decode_alloc(\"RSA PUBLIC KEY\", &public_key, &der_pub_key)) {\n\n\t\t/* initalize asn.1 parser */\n\t\tASN1_TYPE pkcs1 = ASN1_TYPE_EMPTY;\n\t\tif (ASN1_SUCCESS == asn1_array2tree(pkcs1_asn1_tab, &pkcs1, NULL)) {\n\n\t\t\tASN1_TYPE asn1_pub_key = ASN1_TYPE_EMPTY;\n\t\t\tasn1_create_element(pkcs1, \"PKCS1.RSAPublicKey\", &asn1_pub_key);\n\n\t\t\tif (ASN1_SUCCESS == asn1_der_decoding(&asn1_pub_key, der_pub_key.data, der_pub_key.size, NULL)) {\n\n\t\t\t\t/* get size to read */\n\t\t\t\tint ret1 = asn1_read_value(asn1_pub_key, \"modulus\", NULL, (int*)&modulus.size);\n\t\t\t\tint ret2 = asn1_read_value(asn1_pub_key, \"publicExponent\", NULL, (int*)&exponent.size);\n\n\t\t\t\tmodulus.data = gnutls_malloc(modulus.size);\n\t\t\t\texponent.data = gnutls_malloc(exponent.size);\n\n\t\t\t\tret1 = asn1_read_value(asn1_pub_key, \"modulus\", modulus.data, (int*)&modulus.size);\n\t\t\t\tret2 = asn1_read_value(asn1_pub_key, \"publicExponent\", exponent.data, (int*)&exponent.size);\n\t\t\t\tif (ASN1_SUCCESS == ret1 && ASN1_SUCCESS == ret2)\n\t\t\t\t\tret = USERPREF_E_SUCCESS;\n\t\t\t}\n\t\t\tif (asn1_pub_key)\n\t\t\t\tasn1_delete_structure(&asn1_pub_key);\n\t\t}\n\t\tif (pkcs1)\n\t\t\tasn1_delete_structure(&pkcs1);\n\t} else {\n\t\tdebug_info(\"WARNING: Could not read public key\");\n\t}\n\n\t/* now generate certificates */\n\tif (USERPREF_E_SUCCESS == ret && 0 != modulus.size && 0 != exponent.size) {\n\t\tgnutls_datum_t essentially_null = { (unsigned char*)strdup(\"abababababababab\"), strlen(\"abababababababab\") };\n\n\t\tgnutls_x509_privkey_t fake_privkey;\n\t\tgnutls_x509_crt_t dev_cert;\n\n\t\tgnutls_x509_privkey_init(&fake_privkey);\n\t\tgnutls_x509_crt_init(&dev_cert);\n\n\t\tif (GNUTLS_E_SUCCESS == gnutls_x509_privkey_import_rsa_raw(fake_privkey, &modulus, &exponent, &essentially_null, &essentially_null, &essentially_null, &essentially_null)) {\n\t\t\t/* generate device certificate */\n\t\t\tgnutls_x509_crt_set_key(dev_cert, fake_privkey);\n\t\t\tgnutls_x509_crt_set_serial(dev_cert, \"\\x00\", 1);\n\t\t\tgnutls_x509_crt_set_version(dev_cert, 3);\n\t\t\tgnutls_x509_crt_set_ca_status(dev_cert, 0);\n\t\t\tgnutls_x509_crt_set_activation_time(dev_cert, time(NULL));\n\t\t\tgnutls_x509_crt_set_expiration_time(dev_cert, time(NULL) + (60 * 60 * 24 * 365 * 10));\n\n\t\t\t/* use custom hash generation for compatibility with the \"Apple ecosystem\" */\n\t\t\tconst gnutls_digest_algorithm_t dig_sha1 = GNUTLS_DIG_SHA1;\n\t\t\tsize_t hash_size = gnutls_hash_get_len(dig_sha1);\n\t\t\tunsigned char hash[hash_size];\n\t\t\tif (gnutls_hash_fast(dig_sha1, der_pub_key.data, der_pub_key.size, (unsigned char*)&hash) < 0) {\n\t\t\t\tdebug_info(\"ERROR: Failed to generate SHA1 for public key\");\n\t\t\t} else {\n\t\t\t\tgnutls_x509_crt_set_subject_key_id(dev_cert, hash, hash_size);\n\t\t\t}\n\n\t\t\tgnutls_x509_crt_set_key_usage(dev_cert, GNUTLS_KEY_DIGITAL_SIGNATURE | GNUTLS_KEY_KEY_ENCIPHERMENT);\n\t\t\tgnutls_x509_crt_sign(dev_cert, root_cert, root_privkey);\n\n\t\t\tif (USERPREF_E_SUCCESS == ret) {\n\t\t\t\t/* if everything went well, export in PEM format */\n\t\t\t\tsize_t export_size = 0;\n\t\t\t\tgnutls_x509_crt_export(dev_cert, GNUTLS_X509_FMT_PEM, NULL, &export_size);\n\t\t\t\tdev_cert_pem.data = gnutls_malloc(export_size);\n\t\t\t\tgnutls_x509_crt_export(dev_cert, GNUTLS_X509_FMT_PEM, dev_cert_pem.data, &export_size);\n\t\t\t\tdev_cert_pem.size = export_size;\n\t\t\t} else {\n\t\t\t\tdebug_info(\"ERROR: Signing device certificate with root private key failed!\");\n\t\t\t}\n\t\t}\n\n\t\tif (essentially_null.data)\n\t\t\tfree(essentially_null.data);\n\n\t\tgnutls_x509_crt_deinit(dev_cert);\n\t\tgnutls_x509_privkey_deinit(fake_privkey);\n\t}\n\n\tgnutls_x509_crt_deinit(root_cert);\n\tgnutls_x509_crt_deinit(host_cert);\n\tgnutls_x509_privkey_deinit(root_privkey);\n\tgnutls_x509_privkey_deinit(host_privkey);\n\n\tgnutls_free(modulus.data);\n\tgnutls_free(exponent.data);\n\n\tgnutls_free(der_pub_key.data);\n#endif\n\tif (NULL != root_cert_pem.data && 0 != root_cert_pem.size &&\n\t\tNULL != host_cert_pem.data && 0 != host_cert_pem.size)\n\t\tret = USERPREF_E_SUCCESS;\n\n\t/* now set keys and certificates */\n\tpair_record_set_item_from_key_data(pair_record, USERPREF_DEVICE_CERTIFICATE_KEY, &dev_cert_pem);\n\tpair_record_set_item_from_key_data(pair_record, USERPREF_HOST_PRIVATE_KEY_KEY, &host_key_pem);\n\tpair_record_set_item_from_key_data(pair_record, USERPREF_HOST_CERTIFICATE_KEY, &host_cert_pem);\n\tpair_record_set_item_from_key_data(pair_record, USERPREF_ROOT_PRIVATE_KEY_KEY, &root_key_pem);\n\tpair_record_set_item_from_key_data(pair_record, USERPREF_ROOT_CERTIFICATE_KEY, &root_cert_pem);\n\n\tif (dev_cert_pem.data)\n\t\tfree(dev_cert_pem.data);\n\tif (root_key_pem.data)\n\t\tfree(root_key_pem.data);\n\tif (root_cert_pem.data)\n\t\tfree(root_cert_pem.data);\n\tif (host_key_pem.data)\n\t\tfree(host_key_pem.data);\n\tif (host_cert_pem.data)\n\t\tfree(host_cert_pem.data);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "X509_add_ext_helper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/userpref.c",
    "lines": "374-393",
    "snippet": "static int X509_add_ext_helper(X509 *cert, int nid, char *value)\n{\n\tX509_EXTENSION *ex;\n\tX509V3_CTX ctx;\n\n\t/* No configuration database */\n\tX509V3_set_ctx_nodb(&ctx);\n\n\tX509V3_set_ctx(&ctx, NULL, cert, NULL, NULL, 0);\n\tex = X509V3_EXT_conf_nid(NULL, &ctx, nid, value);\n\tif (!ex) {\n\t\tdebug_info(\"ERROR: X509V3_EXT_conf_nid(%d, %s) failed\", nid, value);\n\t\treturn 0;\n\t}\n\n\tX509_add_ext(cert, ex, -1);\n\tX509_EXTENSION_free(ex);\n\n\treturn 1;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"debug.h\"",
      "#include \"userpref.h\"",
      "#include <shlobj.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <libgen.h>",
      "#include <dirent.h>",
      "#include <libtasn1.h>",
      "#include <gcrypt.h>",
      "#include <gnutls/x509.h>",
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include <openssl/x509v3.h>",
      "#include <openssl/x509.h>",
      "#include <openssl/rsa.h>",
      "#include <openssl/pem.h>",
      "#include <usbmuxd.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "X509_EXTENSION_free",
          "args": [
            "ex"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_add_ext",
          "args": [
            "cert",
            "ex",
            "-1"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "X509_add_ext_helper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/userpref.c",
          "lines": "374-393",
          "snippet": "static int X509_add_ext_helper(X509 *cert, int nid, char *value)\n{\n\tX509_EXTENSION *ex;\n\tX509V3_CTX ctx;\n\n\t/* No configuration database */\n\tX509V3_set_ctx_nodb(&ctx);\n\n\tX509V3_set_ctx(&ctx, NULL, cert, NULL, NULL, 0);\n\tex = X509V3_EXT_conf_nid(NULL, &ctx, nid, value);\n\tif (!ex) {\n\t\tdebug_info(\"ERROR: X509V3_EXT_conf_nid(%d, %s) failed\", nid, value);\n\t\treturn 0;\n\t}\n\n\tX509_add_ext(cert, ex, -1);\n\tX509_EXTENSION_free(ex);\n\n\treturn 1;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"ERROR: X509V3_EXT_conf_nid(%d, %s) failed\"",
            "nid",
            "value"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509V3_EXT_conf_nid",
          "args": [
            "NULL",
            "&ctx",
            "nid",
            "value"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509V3_set_ctx",
          "args": [
            "&ctx",
            "NULL",
            "cert",
            "NULL",
            "NULL",
            "0"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509V3_set_ctx_nodb",
          "args": [
            "&ctx"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"debug.h\"\n#include \"userpref.h\"\n#include <shlobj.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <libtasn1.h>\n#include <gcrypt.h>\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/rsa.h>\n#include <openssl/pem.h>\n#include <usbmuxd.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int X509_add_ext_helper(X509 *cert, int nid, char *value)\n{\n\tX509_EXTENSION *ex;\n\tX509V3_CTX ctx;\n\n\t/* No configuration database */\n\tX509V3_set_ctx_nodb(&ctx);\n\n\tX509V3_set_ctx(&ctx, NULL, cert, NULL, NULL, 0);\n\tex = X509V3_EXT_conf_nid(NULL, &ctx, nid, value);\n\tif (!ex) {\n\t\tdebug_info(\"ERROR: X509V3_EXT_conf_nid(%d, %s) failed\", nid, value);\n\t\treturn 0;\n\t}\n\n\tX509_add_ext(cert, ex, -1);\n\tX509_EXTENSION_free(ex);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "userpref_delete_pair_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/userpref.c",
    "lines": "366-371",
    "snippet": "userpref_error_t userpref_delete_pair_record(const char *udid)\n{\n\tint res = usbmuxd_delete_pair_record(udid);\n\n\treturn res == 0 ? USERPREF_E_SUCCESS: USERPREF_E_UNKNOWN_ERROR;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"debug.h\"",
      "#include \"userpref.h\"",
      "#include <shlobj.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <libgen.h>",
      "#include <dirent.h>",
      "#include <libtasn1.h>",
      "#include <gcrypt.h>",
      "#include <gnutls/x509.h>",
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include <openssl/x509v3.h>",
      "#include <openssl/x509.h>",
      "#include <openssl/rsa.h>",
      "#include <openssl/pem.h>",
      "#include <usbmuxd.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbmuxd_delete_pair_record",
          "args": [
            "udid"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"debug.h\"\n#include \"userpref.h\"\n#include <shlobj.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <libtasn1.h>\n#include <gcrypt.h>\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/rsa.h>\n#include <openssl/pem.h>\n#include <usbmuxd.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <config.h>\n\nuserpref_error_t userpref_delete_pair_record(const char *udid)\n{\n\tint res = usbmuxd_delete_pair_record(udid);\n\n\treturn res == 0 ? USERPREF_E_SUCCESS: USERPREF_E_UNKNOWN_ERROR;\n}"
  },
  {
    "function_name": "userpref_read_pair_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/userpref.c",
    "lines": "333-357",
    "snippet": "userpref_error_t userpref_read_pair_record(const char *udid, plist_t *pair_record)\n{\n\tchar* record_data = NULL;\n\tuint32_t record_size = 0;\n\n\tint res = usbmuxd_read_pair_record(udid, &record_data, &record_size);\n\n\tif (res < 0) {\n\t\tif (record_data)\n\t\t\tfree(record_data);\n\n\t\treturn USERPREF_E_INVALID_CONF;\n\t}\n\n\t*pair_record = NULL;\n\tif (memcmp(record_data, \"bplist00\", 8) == 0) {\n\t\tplist_from_bin(record_data, record_size, pair_record);\n\t} else {\n\t\tplist_from_xml(record_data, record_size, pair_record);\n\t}\n\n\tfree(record_data);\n\n\treturn res == 0 ? USERPREF_E_SUCCESS: USERPREF_E_UNKNOWN_ERROR;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"debug.h\"",
      "#include \"userpref.h\"",
      "#include <shlobj.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <libgen.h>",
      "#include <dirent.h>",
      "#include <libtasn1.h>",
      "#include <gcrypt.h>",
      "#include <gnutls/x509.h>",
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include <openssl/x509v3.h>",
      "#include <openssl/x509.h>",
      "#include <openssl/rsa.h>",
      "#include <openssl/pem.h>",
      "#include <usbmuxd.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "record_data"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "thread_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "39-44",
          "snippet": "void thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nvoid thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_from_xml",
          "args": [
            "record_data",
            "record_size",
            "pair_record"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_from_bin",
          "args": [
            "record_data",
            "record_size",
            "pair_record"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "record_data",
            "\"bplist00\"",
            "8"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbmuxd_read_pair_record",
          "args": [
            "udid",
            "&record_data",
            "&record_size"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"debug.h\"\n#include \"userpref.h\"\n#include <shlobj.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <libtasn1.h>\n#include <gcrypt.h>\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/rsa.h>\n#include <openssl/pem.h>\n#include <usbmuxd.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <config.h>\n\nuserpref_error_t userpref_read_pair_record(const char *udid, plist_t *pair_record)\n{\n\tchar* record_data = NULL;\n\tuint32_t record_size = 0;\n\n\tint res = usbmuxd_read_pair_record(udid, &record_data, &record_size);\n\n\tif (res < 0) {\n\t\tif (record_data)\n\t\t\tfree(record_data);\n\n\t\treturn USERPREF_E_INVALID_CONF;\n\t}\n\n\t*pair_record = NULL;\n\tif (memcmp(record_data, \"bplist00\", 8) == 0) {\n\t\tplist_from_bin(record_data, record_size, pair_record);\n\t} else {\n\t\tplist_from_xml(record_data, record_size, pair_record);\n\t}\n\n\tfree(record_data);\n\n\treturn res == 0 ? USERPREF_E_SUCCESS: USERPREF_E_UNKNOWN_ERROR;\n}"
  },
  {
    "function_name": "userpref_save_pair_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/userpref.c",
    "lines": "310-322",
    "snippet": "userpref_error_t userpref_save_pair_record(const char *udid, plist_t pair_record)\n{\n\tchar* record_data = NULL;\n\tuint32_t record_size = 0;\n\n\tplist_to_bin(pair_record, &record_data, &record_size);\n\n\tint res = usbmuxd_save_pair_record(udid, record_data, record_size);\n\n\tfree(record_data);\n\n\treturn res == 0 ? USERPREF_E_SUCCESS: USERPREF_E_UNKNOWN_ERROR;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"debug.h\"",
      "#include \"userpref.h\"",
      "#include <shlobj.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <libgen.h>",
      "#include <dirent.h>",
      "#include <libtasn1.h>",
      "#include <gcrypt.h>",
      "#include <gnutls/x509.h>",
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include <openssl/x509v3.h>",
      "#include <openssl/x509.h>",
      "#include <openssl/rsa.h>",
      "#include <openssl/pem.h>",
      "#include <usbmuxd.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "record_data"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "thread_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "39-44",
          "snippet": "void thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nvoid thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbmuxd_save_pair_record",
          "args": [
            "udid",
            "record_data",
            "record_size"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_to_bin",
          "args": [
            "pair_record",
            "&record_data",
            "&record_size"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"debug.h\"\n#include \"userpref.h\"\n#include <shlobj.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <libtasn1.h>\n#include <gcrypt.h>\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/rsa.h>\n#include <openssl/pem.h>\n#include <usbmuxd.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <config.h>\n\nuserpref_error_t userpref_save_pair_record(const char *udid, plist_t pair_record)\n{\n\tchar* record_data = NULL;\n\tuint32_t record_size = 0;\n\n\tplist_to_bin(pair_record, &record_data, &record_size);\n\n\tint res = usbmuxd_save_pair_record(udid, record_data, record_size);\n\n\tfree(record_data);\n\n\treturn res == 0 ? USERPREF_E_SUCCESS: USERPREF_E_UNKNOWN_ERROR;\n}"
  },
  {
    "function_name": "userpref_get_paired_udids",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/userpref.c",
    "lines": "238-299",
    "snippet": "userpref_error_t userpref_get_paired_udids(char ***list, unsigned int *count)\n{\n\tstruct slist_t {\n\t\tchar *name;\n\t\tvoid *next;\n\t};\n\tDIR *config_dir;\n\tconst char *config_path = NULL;\n\tstruct slist_t *udids = NULL;\n\tunsigned int i;\n\tunsigned int found = 0;\n\n\tif (!list || (list && *list)) {\n\t\tdebug_info(\"ERROR: The list parameter needs to point to NULL!\");\n\t\treturn USERPREF_E_INVALID_ARG;\n\t}\n\n\tif (count) {\n\t\t*count = 0;\n\t}\n\n\tconfig_path = userpref_get_config_dir();\n\tconfig_dir = opendir(config_path);\n\tif (config_dir) {\n\t\tstruct dirent *entry;\n\t\tstruct slist_t *listp = udids;\n\t\twhile ((entry = readdir(config_dir))) {\n\t\t\tchar *ext = strstr(entry->d_name, USERPREF_CONFIG_EXTENSION);\n\t\t\tif (ext && ((ext - entry->d_name) == 40) && (strlen(entry->d_name) == (40 + strlen(ext)))) {\n\t\t\t\tstruct slist_t *ne = (struct slist_t*)malloc(sizeof(struct slist_t));\n\t\t\t\tne->name = (char*)malloc(41);\n\t\t\t\tstrncpy(ne->name, entry->d_name, 40);\n\t\t\t\tne->name[40] = 0;\n\t\t\t\tne->next = NULL;\n\t\t\t\tif (!listp) {\n\t\t\t\t\tlistp = ne;\n\t\t\t\t\tudids = listp;\n\t\t\t\t} else {\n\t\t\t\t\tlistp->next = ne;\n\t\t\t\t\tlistp = listp->next;\n\t\t\t\t}\n\t\t\t\tfound++;\n\t\t\t}\n\t\t}\n\t\tclosedir(config_dir);\n\t}\n\t*list = (char**)malloc(sizeof(char*) * (found+1));\n\ti = 0;\n\twhile (udids) {\n\t\t(*list)[i++] = udids->name;\n\t\tstruct slist_t *old = udids;\n\t\tudids = udids->next;\n\t\tfree(old);\n\t}\n\t(*list)[i] = NULL;\n\n\tif (count) {\n\t\t*count = found;\n\t}\n\n\treturn USERPREF_E_SUCCESS;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"debug.h\"",
      "#include \"userpref.h\"",
      "#include <shlobj.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <libgen.h>",
      "#include <dirent.h>",
      "#include <libtasn1.h>",
      "#include <gcrypt.h>",
      "#include <gnutls/x509.h>",
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include <openssl/x509v3.h>",
      "#include <openssl/x509.h>",
      "#include <openssl/rsa.h>",
      "#include <openssl/pem.h>",
      "#include <usbmuxd.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define USERPREF_CONFIG_EXTENSION \".plist\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "old"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "thread_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "39-44",
          "snippet": "void thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nvoid thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(char*) * (found+1)"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "config_dir"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "ne->name",
            "entry->d_name",
            "40"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "41"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(struct slist_t)"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ext"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "entry->d_name"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "entry->d_name",
            "USERPREF_CONFIG_EXTENSION"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readdir",
          "args": [
            "config_dir"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opendir",
          "args": [
            "config_path"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "userpref_get_config_dir",
          "args": [],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "userpref_get_config_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/userpref.c",
          "lines": "131-173",
          "snippet": "const char *userpref_get_config_dir()\n{\n\tchar *base_config_dir = NULL;\n\n\tif (__config_dir)\n\t\treturn __config_dir;\n\n#ifdef WIN32\n\twchar_t path[MAX_PATH+1];\n\tHRESULT hr;\n\tLPITEMIDLIST pidl = NULL;\n\tBOOL b = FALSE;\n\n\thr = SHGetSpecialFolderLocation (NULL, CSIDL_COMMON_APPDATA, &pidl);\n\tif (hr == S_OK) {\n\t\tb = SHGetPathFromIDListW (pidl, path);\n\t\tif (b) {\n\t\t\tbase_config_dir = userpref_utf16_to_utf8 (path, wcslen(path), NULL, NULL);\n\t\t\tCoTaskMemFree (pidl);\n\t\t}\n\t}\n#else\n#ifdef __APPLE__\n\tbase_config_dir = strdup(\"/var/db\");\n#else\n\tbase_config_dir = strdup(\"/var/lib\");\n#endif\n#endif\n\t__config_dir = string_concat(base_config_dir, DIR_SEP_S, USERPREF_CONFIG_DIR, NULL);\n\n\tif (__config_dir) {\n\t\tint i = strlen(__config_dir)-1;\n\t\twhile ((i > 0) && (__config_dir[i] == DIR_SEP)) {\n\t\t\t__config_dir[i--] = '\\0';\n\t\t}\n\t}\n\n\tfree(base_config_dir);\n\n\tdebug_info(\"initialized config_dir to %s\", __config_dir);\n\n\treturn __config_dir;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"debug.h\"",
            "#include \"userpref.h\"",
            "#include <shlobj.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <libgen.h>",
            "#include <dirent.h>",
            "#include <libtasn1.h>",
            "#include <gcrypt.h>",
            "#include <gnutls/x509.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/x509v3.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/pem.h>",
            "#include <usbmuxd.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define USERPREF_CONFIG_DIR \"lockdown\"",
            "#define USERPREF_CONFIG_DIR \"Apple\"DIR_SEP_S\"Lockdown\"",
            "#define DIR_SEP_S \"/\"",
            "#define DIR_SEP '/'",
            "#define DIR_SEP_S \"\\\\\"",
            "#define DIR_SEP '\\\\'"
          ],
          "globals_used": [
            "static char *__config_dir = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"debug.h\"\n#include \"userpref.h\"\n#include <shlobj.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <libtasn1.h>\n#include <gcrypt.h>\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/rsa.h>\n#include <openssl/pem.h>\n#include <usbmuxd.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <config.h>\n\n#define USERPREF_CONFIG_DIR \"lockdown\"\n#define USERPREF_CONFIG_DIR \"Apple\"DIR_SEP_S\"Lockdown\"\n#define DIR_SEP_S \"/\"\n#define DIR_SEP '/'\n#define DIR_SEP_S \"\\\\\"\n#define DIR_SEP '\\\\'\n\nstatic char *__config_dir = NULL;\n\nconst char *userpref_get_config_dir()\n{\n\tchar *base_config_dir = NULL;\n\n\tif (__config_dir)\n\t\treturn __config_dir;\n\n#ifdef WIN32\n\twchar_t path[MAX_PATH+1];\n\tHRESULT hr;\n\tLPITEMIDLIST pidl = NULL;\n\tBOOL b = FALSE;\n\n\thr = SHGetSpecialFolderLocation (NULL, CSIDL_COMMON_APPDATA, &pidl);\n\tif (hr == S_OK) {\n\t\tb = SHGetPathFromIDListW (pidl, path);\n\t\tif (b) {\n\t\t\tbase_config_dir = userpref_utf16_to_utf8 (path, wcslen(path), NULL, NULL);\n\t\t\tCoTaskMemFree (pidl);\n\t\t}\n\t}\n#else\n#ifdef __APPLE__\n\tbase_config_dir = strdup(\"/var/db\");\n#else\n\tbase_config_dir = strdup(\"/var/lib\");\n#endif\n#endif\n\t__config_dir = string_concat(base_config_dir, DIR_SEP_S, USERPREF_CONFIG_DIR, NULL);\n\n\tif (__config_dir) {\n\t\tint i = strlen(__config_dir)-1;\n\t\twhile ((i > 0) && (__config_dir[i] == DIR_SEP)) {\n\t\t\t__config_dir[i--] = '\\0';\n\t\t}\n\t}\n\n\tfree(base_config_dir);\n\n\tdebug_info(\"initialized config_dir to %s\", __config_dir);\n\n\treturn __config_dir;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"ERROR: The list parameter needs to point to NULL!\""
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"debug.h\"\n#include \"userpref.h\"\n#include <shlobj.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <libtasn1.h>\n#include <gcrypt.h>\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/rsa.h>\n#include <openssl/pem.h>\n#include <usbmuxd.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <config.h>\n\n#define USERPREF_CONFIG_EXTENSION \".plist\"\n\nuserpref_error_t userpref_get_paired_udids(char ***list, unsigned int *count)\n{\n\tstruct slist_t {\n\t\tchar *name;\n\t\tvoid *next;\n\t};\n\tDIR *config_dir;\n\tconst char *config_path = NULL;\n\tstruct slist_t *udids = NULL;\n\tunsigned int i;\n\tunsigned int found = 0;\n\n\tif (!list || (list && *list)) {\n\t\tdebug_info(\"ERROR: The list parameter needs to point to NULL!\");\n\t\treturn USERPREF_E_INVALID_ARG;\n\t}\n\n\tif (count) {\n\t\t*count = 0;\n\t}\n\n\tconfig_path = userpref_get_config_dir();\n\tconfig_dir = opendir(config_path);\n\tif (config_dir) {\n\t\tstruct dirent *entry;\n\t\tstruct slist_t *listp = udids;\n\t\twhile ((entry = readdir(config_dir))) {\n\t\t\tchar *ext = strstr(entry->d_name, USERPREF_CONFIG_EXTENSION);\n\t\t\tif (ext && ((ext - entry->d_name) == 40) && (strlen(entry->d_name) == (40 + strlen(ext)))) {\n\t\t\t\tstruct slist_t *ne = (struct slist_t*)malloc(sizeof(struct slist_t));\n\t\t\t\tne->name = (char*)malloc(41);\n\t\t\t\tstrncpy(ne->name, entry->d_name, 40);\n\t\t\t\tne->name[40] = 0;\n\t\t\t\tne->next = NULL;\n\t\t\t\tif (!listp) {\n\t\t\t\t\tlistp = ne;\n\t\t\t\t\tudids = listp;\n\t\t\t\t} else {\n\t\t\t\t\tlistp->next = ne;\n\t\t\t\t\tlistp = listp->next;\n\t\t\t\t}\n\t\t\t\tfound++;\n\t\t\t}\n\t\t}\n\t\tclosedir(config_dir);\n\t}\n\t*list = (char**)malloc(sizeof(char*) * (found+1));\n\ti = 0;\n\twhile (udids) {\n\t\t(*list)[i++] = udids->name;\n\t\tstruct slist_t *old = udids;\n\t\tudids = udids->next;\n\t\tfree(old);\n\t}\n\t(*list)[i] = NULL;\n\n\tif (count) {\n\t\t*count = found;\n\t}\n\n\treturn USERPREF_E_SUCCESS;\n}"
  },
  {
    "function_name": "userpref_has_pair_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/userpref.c",
    "lines": "202-221",
    "snippet": "int userpref_has_pair_record(const char *udid)\n{\n\tint ret = 0;\n\tconst char *config_path = NULL;\n\tchar *config_file = NULL;\n\tstruct stat st;\n\n\tif (!udid) return 0;\n\n\t/* first get config file */\n\tconfig_path = userpref_get_config_dir();\n\tconfig_file = string_concat(config_path, DIR_SEP_S, udid, USERPREF_CONFIG_EXTENSION, NULL);\n\n\tif ((stat(config_file, &st) == 0) && S_ISREG(st.st_mode))\n\t\tret = 1;\n\n\tfree(config_file);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"debug.h\"",
      "#include \"userpref.h\"",
      "#include <shlobj.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <libgen.h>",
      "#include <dirent.h>",
      "#include <libtasn1.h>",
      "#include <gcrypt.h>",
      "#include <gnutls/x509.h>",
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include <openssl/x509v3.h>",
      "#include <openssl/x509.h>",
      "#include <openssl/rsa.h>",
      "#include <openssl/pem.h>",
      "#include <usbmuxd.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define USERPREF_CONFIG_EXTENSION \".plist\"",
      "#define DIR_SEP_S \"/\"",
      "#define DIR_SEP_S \"\\\\\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "config_file"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "thread_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "39-44",
          "snippet": "void thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nvoid thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "st.st_mode"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "config_file",
            "&st"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "mobilebackup_write_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
          "lines": "322-338",
          "snippet": "static void mobilebackup_write_status(const char *path, int status)\n{\n\tstruct stat st;\n\tplist_t status_plist = plist_new_dict();\n\tplist_dict_set_item(status_plist, \"Backup Success\", plist_new_bool(status));\n\tchar *file_path = mobilebackup_build_path(path, \"Status\", \".plist\");\n\n\tif (stat(file_path, &st) == 0)\n\t\tremove(file_path);\n\n\tplist_write_to_filename(status_plist, file_path, PLIST_FORMAT_XML);\n\n\tplist_free(status_plist);\n\tstatus_plist = NULL;\n\n\tfree(file_path);\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <unistd.h>",
            "#include <gcrypt.h>",
            "#include <openssl/sha.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void mobilebackup_write_status(const char *path, int status)\n{\n\tstruct stat st;\n\tplist_t status_plist = plist_new_dict();\n\tplist_dict_set_item(status_plist, \"Backup Success\", plist_new_bool(status));\n\tchar *file_path = mobilebackup_build_path(path, \"Status\", \".plist\");\n\n\tif (stat(file_path, &st) == 0)\n\t\tremove(file_path);\n\n\tplist_write_to_filename(status_plist, file_path, PLIST_FORMAT_XML);\n\n\tplist_free(status_plist);\n\tstatus_plist = NULL;\n\n\tfree(file_path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "string_concat",
          "args": [
            "config_path",
            "DIR_SEP_S",
            "udid",
            "USERPREF_CONFIG_EXTENSION",
            "NULL"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "string_concat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/utils.c",
          "lines": "70-112",
          "snippet": "char *string_concat(const char *str, ...)\n{\n\tsize_t len;\n\tva_list args;\n\tchar *s;\n\tchar *result;\n\tchar *dest;\n\n\tif (!str)\n\t\treturn NULL;\n\n\t/* Compute final length */\n\n\tlen = strlen(str) + 1; /* plus 1 for the null terminator */\n\n\tva_start(args, str);\n\ts = va_arg(args, char *);\n\twhile (s) {\n\t\tlen += strlen(s);\n\t\ts = va_arg(args, char*);\n\t}\n\tva_end(args);\n\n\t/* Concat each string */\n\n\tresult = malloc(len);\n\tif (!result)\n\t\treturn NULL; /* errno remains set */\n\n\tdest = result;\n\n\tdest = stpcpy(dest, str);\n\n\tva_start(args, str);\n\ts = va_arg(args, char *);\n\twhile (s) {\n\t\tdest = stpcpy(dest, s);\n\t\ts = va_arg(args, char *);\n\t}\n\tva_end(args);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include <ctype.h>",
            "#include <inttypes.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include <ctype.h>\n#include <inttypes.h>\n#include <sys/time.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <config.h>\n\nchar *string_concat(const char *str, ...)\n{\n\tsize_t len;\n\tva_list args;\n\tchar *s;\n\tchar *result;\n\tchar *dest;\n\n\tif (!str)\n\t\treturn NULL;\n\n\t/* Compute final length */\n\n\tlen = strlen(str) + 1; /* plus 1 for the null terminator */\n\n\tva_start(args, str);\n\ts = va_arg(args, char *);\n\twhile (s) {\n\t\tlen += strlen(s);\n\t\ts = va_arg(args, char*);\n\t}\n\tva_end(args);\n\n\t/* Concat each string */\n\n\tresult = malloc(len);\n\tif (!result)\n\t\treturn NULL; /* errno remains set */\n\n\tdest = result;\n\n\tdest = stpcpy(dest, str);\n\n\tva_start(args, str);\n\ts = va_arg(args, char *);\n\twhile (s) {\n\t\tdest = stpcpy(dest, s);\n\t\ts = va_arg(args, char *);\n\t}\n\tva_end(args);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "userpref_get_config_dir",
          "args": [],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "userpref_get_config_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/userpref.c",
          "lines": "131-173",
          "snippet": "const char *userpref_get_config_dir()\n{\n\tchar *base_config_dir = NULL;\n\n\tif (__config_dir)\n\t\treturn __config_dir;\n\n#ifdef WIN32\n\twchar_t path[MAX_PATH+1];\n\tHRESULT hr;\n\tLPITEMIDLIST pidl = NULL;\n\tBOOL b = FALSE;\n\n\thr = SHGetSpecialFolderLocation (NULL, CSIDL_COMMON_APPDATA, &pidl);\n\tif (hr == S_OK) {\n\t\tb = SHGetPathFromIDListW (pidl, path);\n\t\tif (b) {\n\t\t\tbase_config_dir = userpref_utf16_to_utf8 (path, wcslen(path), NULL, NULL);\n\t\t\tCoTaskMemFree (pidl);\n\t\t}\n\t}\n#else\n#ifdef __APPLE__\n\tbase_config_dir = strdup(\"/var/db\");\n#else\n\tbase_config_dir = strdup(\"/var/lib\");\n#endif\n#endif\n\t__config_dir = string_concat(base_config_dir, DIR_SEP_S, USERPREF_CONFIG_DIR, NULL);\n\n\tif (__config_dir) {\n\t\tint i = strlen(__config_dir)-1;\n\t\twhile ((i > 0) && (__config_dir[i] == DIR_SEP)) {\n\t\t\t__config_dir[i--] = '\\0';\n\t\t}\n\t}\n\n\tfree(base_config_dir);\n\n\tdebug_info(\"initialized config_dir to %s\", __config_dir);\n\n\treturn __config_dir;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"debug.h\"",
            "#include \"userpref.h\"",
            "#include <shlobj.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <libgen.h>",
            "#include <dirent.h>",
            "#include <libtasn1.h>",
            "#include <gcrypt.h>",
            "#include <gnutls/x509.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/x509v3.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/pem.h>",
            "#include <usbmuxd.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define USERPREF_CONFIG_DIR \"lockdown\"",
            "#define USERPREF_CONFIG_DIR \"Apple\"DIR_SEP_S\"Lockdown\"",
            "#define DIR_SEP_S \"/\"",
            "#define DIR_SEP '/'",
            "#define DIR_SEP_S \"\\\\\"",
            "#define DIR_SEP '\\\\'"
          ],
          "globals_used": [
            "static char *__config_dir = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"debug.h\"\n#include \"userpref.h\"\n#include <shlobj.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <libtasn1.h>\n#include <gcrypt.h>\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/rsa.h>\n#include <openssl/pem.h>\n#include <usbmuxd.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <config.h>\n\n#define USERPREF_CONFIG_DIR \"lockdown\"\n#define USERPREF_CONFIG_DIR \"Apple\"DIR_SEP_S\"Lockdown\"\n#define DIR_SEP_S \"/\"\n#define DIR_SEP '/'\n#define DIR_SEP_S \"\\\\\"\n#define DIR_SEP '\\\\'\n\nstatic char *__config_dir = NULL;\n\nconst char *userpref_get_config_dir()\n{\n\tchar *base_config_dir = NULL;\n\n\tif (__config_dir)\n\t\treturn __config_dir;\n\n#ifdef WIN32\n\twchar_t path[MAX_PATH+1];\n\tHRESULT hr;\n\tLPITEMIDLIST pidl = NULL;\n\tBOOL b = FALSE;\n\n\thr = SHGetSpecialFolderLocation (NULL, CSIDL_COMMON_APPDATA, &pidl);\n\tif (hr == S_OK) {\n\t\tb = SHGetPathFromIDListW (pidl, path);\n\t\tif (b) {\n\t\t\tbase_config_dir = userpref_utf16_to_utf8 (path, wcslen(path), NULL, NULL);\n\t\t\tCoTaskMemFree (pidl);\n\t\t}\n\t}\n#else\n#ifdef __APPLE__\n\tbase_config_dir = strdup(\"/var/db\");\n#else\n\tbase_config_dir = strdup(\"/var/lib\");\n#endif\n#endif\n\t__config_dir = string_concat(base_config_dir, DIR_SEP_S, USERPREF_CONFIG_DIR, NULL);\n\n\tif (__config_dir) {\n\t\tint i = strlen(__config_dir)-1;\n\t\twhile ((i > 0) && (__config_dir[i] == DIR_SEP)) {\n\t\t\t__config_dir[i--] = '\\0';\n\t\t}\n\t}\n\n\tfree(base_config_dir);\n\n\tdebug_info(\"initialized config_dir to %s\", __config_dir);\n\n\treturn __config_dir;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"debug.h\"\n#include \"userpref.h\"\n#include <shlobj.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <libtasn1.h>\n#include <gcrypt.h>\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/rsa.h>\n#include <openssl/pem.h>\n#include <usbmuxd.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <config.h>\n\n#define USERPREF_CONFIG_EXTENSION \".plist\"\n#define DIR_SEP_S \"/\"\n#define DIR_SEP_S \"\\\\\"\n\nint userpref_has_pair_record(const char *udid)\n{\n\tint ret = 0;\n\tconst char *config_path = NULL;\n\tchar *config_file = NULL;\n\tstruct stat st;\n\n\tif (!udid) return 0;\n\n\t/* first get config file */\n\tconfig_path = userpref_get_config_dir();\n\tconfig_file = string_concat(config_path, DIR_SEP_S, udid, USERPREF_CONFIG_EXTENSION, NULL);\n\n\tif ((stat(config_file, &st) == 0) && S_ISREG(st.st_mode))\n\t\tret = 1;\n\n\tfree(config_file);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "userpref_read_system_buid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/userpref.c",
    "lines": "183-192",
    "snippet": "int userpref_read_system_buid(char **system_buid)\n{\n\tint res = usbmuxd_read_buid(system_buid);\n\tif (res == 0) {\n\t\tdebug_info(\"using %s as %s\", *system_buid, USERPREF_SYSTEM_BUID_KEY);\n\t} else {\n\t\tdebug_info(\"could not read system buid, error %d\", res);\n\t}\n\treturn res;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"debug.h\"",
      "#include \"userpref.h\"",
      "#include <shlobj.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <libgen.h>",
      "#include <dirent.h>",
      "#include <libtasn1.h>",
      "#include <gcrypt.h>",
      "#include <gnutls/x509.h>",
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include <openssl/x509v3.h>",
      "#include <openssl/x509.h>",
      "#include <openssl/rsa.h>",
      "#include <openssl/pem.h>",
      "#include <usbmuxd.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"could not read system buid, error %d\"",
            "res"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"using %s as %s\"",
            "*system_buid",
            "USERPREF_SYSTEM_BUID_KEY"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbmuxd_read_buid",
          "args": [
            "system_buid"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"debug.h\"\n#include \"userpref.h\"\n#include <shlobj.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <libtasn1.h>\n#include <gcrypt.h>\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/rsa.h>\n#include <openssl/pem.h>\n#include <usbmuxd.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <config.h>\n\nint userpref_read_system_buid(char **system_buid)\n{\n\tint res = usbmuxd_read_buid(system_buid);\n\tif (res == 0) {\n\t\tdebug_info(\"using %s as %s\", *system_buid, USERPREF_SYSTEM_BUID_KEY);\n\t} else {\n\t\tdebug_info(\"could not read system buid, error %d\", res);\n\t}\n\treturn res;\n}"
  },
  {
    "function_name": "userpref_get_config_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/userpref.c",
    "lines": "131-173",
    "snippet": "const char *userpref_get_config_dir()\n{\n\tchar *base_config_dir = NULL;\n\n\tif (__config_dir)\n\t\treturn __config_dir;\n\n#ifdef WIN32\n\twchar_t path[MAX_PATH+1];\n\tHRESULT hr;\n\tLPITEMIDLIST pidl = NULL;\n\tBOOL b = FALSE;\n\n\thr = SHGetSpecialFolderLocation (NULL, CSIDL_COMMON_APPDATA, &pidl);\n\tif (hr == S_OK) {\n\t\tb = SHGetPathFromIDListW (pidl, path);\n\t\tif (b) {\n\t\t\tbase_config_dir = userpref_utf16_to_utf8 (path, wcslen(path), NULL, NULL);\n\t\t\tCoTaskMemFree (pidl);\n\t\t}\n\t}\n#else\n#ifdef __APPLE__\n\tbase_config_dir = strdup(\"/var/db\");\n#else\n\tbase_config_dir = strdup(\"/var/lib\");\n#endif\n#endif\n\t__config_dir = string_concat(base_config_dir, DIR_SEP_S, USERPREF_CONFIG_DIR, NULL);\n\n\tif (__config_dir) {\n\t\tint i = strlen(__config_dir)-1;\n\t\twhile ((i > 0) && (__config_dir[i] == DIR_SEP)) {\n\t\t\t__config_dir[i--] = '\\0';\n\t\t}\n\t}\n\n\tfree(base_config_dir);\n\n\tdebug_info(\"initialized config_dir to %s\", __config_dir);\n\n\treturn __config_dir;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"debug.h\"",
      "#include \"userpref.h\"",
      "#include <shlobj.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <libgen.h>",
      "#include <dirent.h>",
      "#include <libtasn1.h>",
      "#include <gcrypt.h>",
      "#include <gnutls/x509.h>",
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include <openssl/x509v3.h>",
      "#include <openssl/x509.h>",
      "#include <openssl/rsa.h>",
      "#include <openssl/pem.h>",
      "#include <usbmuxd.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define USERPREF_CONFIG_DIR \"lockdown\"",
      "#define USERPREF_CONFIG_DIR \"Apple\"DIR_SEP_S\"Lockdown\"",
      "#define DIR_SEP_S \"/\"",
      "#define DIR_SEP '/'",
      "#define DIR_SEP_S \"\\\\\"",
      "#define DIR_SEP '\\\\'"
    ],
    "globals_used": [
      "static char *__config_dir = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"initialized config_dir to %s\"",
            "__config_dir"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "base_config_dir"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "thread_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "39-44",
          "snippet": "void thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nvoid thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "__config_dir"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "string_concat",
          "args": [
            "base_config_dir",
            "DIR_SEP_S",
            "USERPREF_CONFIG_DIR",
            "NULL"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "string_concat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/utils.c",
          "lines": "70-112",
          "snippet": "char *string_concat(const char *str, ...)\n{\n\tsize_t len;\n\tva_list args;\n\tchar *s;\n\tchar *result;\n\tchar *dest;\n\n\tif (!str)\n\t\treturn NULL;\n\n\t/* Compute final length */\n\n\tlen = strlen(str) + 1; /* plus 1 for the null terminator */\n\n\tva_start(args, str);\n\ts = va_arg(args, char *);\n\twhile (s) {\n\t\tlen += strlen(s);\n\t\ts = va_arg(args, char*);\n\t}\n\tva_end(args);\n\n\t/* Concat each string */\n\n\tresult = malloc(len);\n\tif (!result)\n\t\treturn NULL; /* errno remains set */\n\n\tdest = result;\n\n\tdest = stpcpy(dest, str);\n\n\tva_start(args, str);\n\ts = va_arg(args, char *);\n\twhile (s) {\n\t\tdest = stpcpy(dest, s);\n\t\ts = va_arg(args, char *);\n\t}\n\tva_end(args);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include <ctype.h>",
            "#include <inttypes.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include <ctype.h>\n#include <inttypes.h>\n#include <sys/time.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <config.h>\n\nchar *string_concat(const char *str, ...)\n{\n\tsize_t len;\n\tva_list args;\n\tchar *s;\n\tchar *result;\n\tchar *dest;\n\n\tif (!str)\n\t\treturn NULL;\n\n\t/* Compute final length */\n\n\tlen = strlen(str) + 1; /* plus 1 for the null terminator */\n\n\tva_start(args, str);\n\ts = va_arg(args, char *);\n\twhile (s) {\n\t\tlen += strlen(s);\n\t\ts = va_arg(args, char*);\n\t}\n\tva_end(args);\n\n\t/* Concat each string */\n\n\tresult = malloc(len);\n\tif (!result)\n\t\treturn NULL; /* errno remains set */\n\n\tdest = result;\n\n\tdest = stpcpy(dest, str);\n\n\tva_start(args, str);\n\ts = va_arg(args, char *);\n\twhile (s) {\n\t\tdest = stpcpy(dest, s);\n\t\ts = va_arg(args, char *);\n\t}\n\tva_end(args);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"/var/lib\""
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"/var/db\""
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CoTaskMemFree",
          "args": [
            "pidl"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "userpref_utf16_to_utf8",
          "args": [
            "path",
            "wcslen(path)",
            "NULL",
            "NULL"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "userpref_utf16_to_utf8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/userpref.c",
          "lines": "97-128",
          "snippet": "static char *userpref_utf16_to_utf8(wchar_t *unistr, long len, long *items_read, long *items_written)\n{\n\tif (!unistr || (len <= 0)) return NULL;\n\tchar *outbuf = (char*)malloc(3*(len+1));\n\tint p = 0;\n\tint i = 0;\n\n\twchar_t wc;\n\n\twhile (i < len) {\n\t\twc = unistr[i++];\n\t\tif (wc >= 0x800) {\n\t\t\toutbuf[p++] = (char)(0xE0 + ((wc >> 12) & 0xF));\n\t\t\toutbuf[p++] = (char)(0x80 + ((wc >> 6) & 0x3F));\n\t\t\toutbuf[p++] = (char)(0x80 + (wc & 0x3F));\n\t\t} else if (wc >= 0x80) {\n\t\t\toutbuf[p++] = (char)(0xC0 + ((wc >> 6) & 0x1F));\n\t\t\toutbuf[p++] = (char)(0x80 + (wc & 0x3F));\n\t\t} else {\n\t\t\toutbuf[p++] = (char)(wc & 0x7F);\n\t\t}\n\t}\n\tif (items_read) {\n\t\t*items_read = i;\n\t}\n\tif (items_written) {\n\t\t*items_written = p;\n\t}\n\toutbuf[p] = 0;\n\n\treturn outbuf;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"debug.h\"",
            "#include \"userpref.h\"",
            "#include <shlobj.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <libgen.h>",
            "#include <dirent.h>",
            "#include <libtasn1.h>",
            "#include <gcrypt.h>",
            "#include <gnutls/x509.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/x509v3.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/pem.h>",
            "#include <usbmuxd.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"debug.h\"\n#include \"userpref.h\"\n#include <shlobj.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <libtasn1.h>\n#include <gcrypt.h>\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/rsa.h>\n#include <openssl/pem.h>\n#include <usbmuxd.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic char *userpref_utf16_to_utf8(wchar_t *unistr, long len, long *items_read, long *items_written)\n{\n\tif (!unistr || (len <= 0)) return NULL;\n\tchar *outbuf = (char*)malloc(3*(len+1));\n\tint p = 0;\n\tint i = 0;\n\n\twchar_t wc;\n\n\twhile (i < len) {\n\t\twc = unistr[i++];\n\t\tif (wc >= 0x800) {\n\t\t\toutbuf[p++] = (char)(0xE0 + ((wc >> 12) & 0xF));\n\t\t\toutbuf[p++] = (char)(0x80 + ((wc >> 6) & 0x3F));\n\t\t\toutbuf[p++] = (char)(0x80 + (wc & 0x3F));\n\t\t} else if (wc >= 0x80) {\n\t\t\toutbuf[p++] = (char)(0xC0 + ((wc >> 6) & 0x1F));\n\t\t\toutbuf[p++] = (char)(0x80 + (wc & 0x3F));\n\t\t} else {\n\t\t\toutbuf[p++] = (char)(wc & 0x7F);\n\t\t}\n\t}\n\tif (items_read) {\n\t\t*items_read = i;\n\t}\n\tif (items_written) {\n\t\t*items_written = p;\n\t}\n\toutbuf[p] = 0;\n\n\treturn outbuf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wcslen",
          "args": [
            "path"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SHGetPathFromIDListW",
          "args": [
            "pidl",
            "path"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SHGetSpecialFolderLocation",
          "args": [
            "NULL",
            "CSIDL_COMMON_APPDATA",
            "&pidl"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"debug.h\"\n#include \"userpref.h\"\n#include <shlobj.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <libtasn1.h>\n#include <gcrypt.h>\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/rsa.h>\n#include <openssl/pem.h>\n#include <usbmuxd.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <config.h>\n\n#define USERPREF_CONFIG_DIR \"lockdown\"\n#define USERPREF_CONFIG_DIR \"Apple\"DIR_SEP_S\"Lockdown\"\n#define DIR_SEP_S \"/\"\n#define DIR_SEP '/'\n#define DIR_SEP_S \"\\\\\"\n#define DIR_SEP '\\\\'\n\nstatic char *__config_dir = NULL;\n\nconst char *userpref_get_config_dir()\n{\n\tchar *base_config_dir = NULL;\n\n\tif (__config_dir)\n\t\treturn __config_dir;\n\n#ifdef WIN32\n\twchar_t path[MAX_PATH+1];\n\tHRESULT hr;\n\tLPITEMIDLIST pidl = NULL;\n\tBOOL b = FALSE;\n\n\thr = SHGetSpecialFolderLocation (NULL, CSIDL_COMMON_APPDATA, &pidl);\n\tif (hr == S_OK) {\n\t\tb = SHGetPathFromIDListW (pidl, path);\n\t\tif (b) {\n\t\t\tbase_config_dir = userpref_utf16_to_utf8 (path, wcslen(path), NULL, NULL);\n\t\t\tCoTaskMemFree (pidl);\n\t\t}\n\t}\n#else\n#ifdef __APPLE__\n\tbase_config_dir = strdup(\"/var/db\");\n#else\n\tbase_config_dir = strdup(\"/var/lib\");\n#endif\n#endif\n\t__config_dir = string_concat(base_config_dir, DIR_SEP_S, USERPREF_CONFIG_DIR, NULL);\n\n\tif (__config_dir) {\n\t\tint i = strlen(__config_dir)-1;\n\t\twhile ((i > 0) && (__config_dir[i] == DIR_SEP)) {\n\t\t\t__config_dir[i--] = '\\0';\n\t\t}\n\t}\n\n\tfree(base_config_dir);\n\n\tdebug_info(\"initialized config_dir to %s\", __config_dir);\n\n\treturn __config_dir;\n}"
  },
  {
    "function_name": "userpref_utf16_to_utf8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/userpref.c",
    "lines": "97-128",
    "snippet": "static char *userpref_utf16_to_utf8(wchar_t *unistr, long len, long *items_read, long *items_written)\n{\n\tif (!unistr || (len <= 0)) return NULL;\n\tchar *outbuf = (char*)malloc(3*(len+1));\n\tint p = 0;\n\tint i = 0;\n\n\twchar_t wc;\n\n\twhile (i < len) {\n\t\twc = unistr[i++];\n\t\tif (wc >= 0x800) {\n\t\t\toutbuf[p++] = (char)(0xE0 + ((wc >> 12) & 0xF));\n\t\t\toutbuf[p++] = (char)(0x80 + ((wc >> 6) & 0x3F));\n\t\t\toutbuf[p++] = (char)(0x80 + (wc & 0x3F));\n\t\t} else if (wc >= 0x80) {\n\t\t\toutbuf[p++] = (char)(0xC0 + ((wc >> 6) & 0x1F));\n\t\t\toutbuf[p++] = (char)(0x80 + (wc & 0x3F));\n\t\t} else {\n\t\t\toutbuf[p++] = (char)(wc & 0x7F);\n\t\t}\n\t}\n\tif (items_read) {\n\t\t*items_read = i;\n\t}\n\tif (items_written) {\n\t\t*items_written = p;\n\t}\n\toutbuf[p] = 0;\n\n\treturn outbuf;\n}",
    "includes": [
      "#include \"utils.h\"",
      "#include \"debug.h\"",
      "#include \"userpref.h\"",
      "#include <shlobj.h>",
      "#include <errno.h>",
      "#include <sys/stat.h>",
      "#include <libgen.h>",
      "#include <dirent.h>",
      "#include <libtasn1.h>",
      "#include <gcrypt.h>",
      "#include <gnutls/x509.h>",
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include <openssl/x509v3.h>",
      "#include <openssl/x509.h>",
      "#include <openssl/rsa.h>",
      "#include <openssl/pem.h>",
      "#include <usbmuxd.h>",
      "#include <unistd.h>",
      "#include <pwd.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "3*(len+1)"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils.h\"\n#include \"debug.h\"\n#include \"userpref.h\"\n#include <shlobj.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <libtasn1.h>\n#include <gcrypt.h>\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/rsa.h>\n#include <openssl/pem.h>\n#include <usbmuxd.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic char *userpref_utf16_to_utf8(wchar_t *unistr, long len, long *items_read, long *items_written)\n{\n\tif (!unistr || (len <= 0)) return NULL;\n\tchar *outbuf = (char*)malloc(3*(len+1));\n\tint p = 0;\n\tint i = 0;\n\n\twchar_t wc;\n\n\twhile (i < len) {\n\t\twc = unistr[i++];\n\t\tif (wc >= 0x800) {\n\t\t\toutbuf[p++] = (char)(0xE0 + ((wc >> 12) & 0xF));\n\t\t\toutbuf[p++] = (char)(0x80 + ((wc >> 6) & 0x3F));\n\t\t\toutbuf[p++] = (char)(0x80 + (wc & 0x3F));\n\t\t} else if (wc >= 0x80) {\n\t\t\toutbuf[p++] = (char)(0xC0 + ((wc >> 6) & 0x1F));\n\t\t\toutbuf[p++] = (char)(0x80 + (wc & 0x3F));\n\t\t} else {\n\t\t\toutbuf[p++] = (char)(wc & 0x7F);\n\t\t}\n\t}\n\tif (items_read) {\n\t\t*items_read = i;\n\t}\n\tif (items_written) {\n\t\t*items_written = p;\n\t}\n\toutbuf[p] = 0;\n\n\treturn outbuf;\n}"
  }
]