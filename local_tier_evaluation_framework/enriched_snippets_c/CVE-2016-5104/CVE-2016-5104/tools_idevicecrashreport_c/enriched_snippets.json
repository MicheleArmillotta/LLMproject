[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicecrashreport.c",
    "lines": "310-472",
    "snippet": "int main(int argc, char* argv[]) {\n\tidevice_t device = NULL;\n\tlockdownd_client_t lockdownd = NULL;\n\tafc_client_t afc = NULL;\n\n\tidevice_error_t device_error = IDEVICE_E_SUCCESS;\n\tlockdownd_error_t lockdownd_error = LOCKDOWN_E_SUCCESS;\n\tafc_error_t afc_error = AFC_E_SUCCESS;\n\n\tint i;\n\tconst char* udid = NULL;\n\n\t/* parse cmdline args */\n\tfor (i = 1; i < argc; i++) {\n\t\tif (!strcmp(argv[i], \"-d\") || !strcmp(argv[i], \"--debug\")) {\n\t\t\tidevice_set_debug_level(1);\n\t\t\tcontinue;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"-u\") || !strcmp(argv[i], \"--udid\")) {\n\t\t\ti++;\n\t\t\tif (!argv[i] || (strlen(argv[i]) != 40)) {\n\t\t\t\tprint_usage(argc, argv);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tudid = argv[i];\n\t\t\tcontinue;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"-h\") || !strcmp(argv[i], \"--help\")) {\n\t\t\tprint_usage(argc, argv);\n\t\t\treturn 0;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"-e\") || !strcmp(argv[i], \"--extract\")) {\n\t\t\textract_raw_crash_reports = 1;\n\t\t\tcontinue;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"-k\") || !strcmp(argv[i], \"--keep\")) {\n\t\t\tkeep_crash_reports = 1;\n\t\t\tcontinue;\n\t\t}\n\t\telse if (target_directory == NULL) {\n\t\t\ttarget_directory = argv[i];\n\t\t\tcontinue;\n\t\t}\n\t\telse {\n\t\t\tprint_usage(argc, argv);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* ensure a target directory was supplied */\n\tif (!target_directory) {\n\t\tprint_usage(argc, argv);\n\t\treturn 0;\n\t}\n\n\t/* check if target directory exists */\n\tif (!file_exists(target_directory)) {\n\t\tfprintf(stderr, \"ERROR: Directory '%s' does not exist.\\n\", target_directory);\n\t\tprint_usage(argc, argv);\n\t\treturn 0;\n\t}\n\n\tdevice_error = idevice_new(&device, udid);\n\tif (device_error != IDEVICE_E_SUCCESS) {\n\t\tif (udid) {\n\t\t\tprintf(\"No device found with udid %s, is it plugged in?\\n\", udid);\n\t\t} else {\n\t\t\tprintf(\"No device found, is it plugged in?\\n\");\n\t\t}\n\t\treturn -1;\n\t}\n\n\tlockdownd_error = lockdownd_client_new_with_handshake(device, &lockdownd, \"idevicecrashreport\");\n\tif (lockdownd_error != LOCKDOWN_E_SUCCESS) {\n\t\tfprintf(stderr, \"ERROR: Could not connect to lockdownd, error code %d\\n\", lockdownd_error);\n\t\tidevice_free(device);\n\t\treturn -1;\n\t}\n\n\t/* start crash log mover service */\n\tlockdownd_service_descriptor_t service = NULL;\n\tlockdownd_error = lockdownd_start_service(lockdownd, \"com.apple.crashreportmover\", &service);\n\tif (lockdownd_error != LOCKDOWN_E_SUCCESS) {\n\t\tlockdownd_client_free(lockdownd);\n\t\tidevice_free(device);\n\t\treturn -1;\n\t}\n\n\t/* trigger move operation on device */\n\tidevice_connection_t connection = NULL;\n\tdevice_error = idevice_connect(device, service->port, &connection);\n\tif(device_error != IDEVICE_E_SUCCESS) {\n\t\tlockdownd_client_free(lockdownd);\n\t\tidevice_free(device);\n\t\treturn -1;\n\t}\n\n\t/* read \"ping\" message which indicates the crash logs have been moved to a safe harbor */\n\tchar *ping = malloc(4);\n\tmemset(ping, '\\0', 4);\n\tint attempts = 0;\n\twhile ((strncmp(ping, \"ping\", 4) != 0) && (attempts < 10)) {\n\t\tuint32_t bytes = 0;\n\t\tdevice_error = idevice_connection_receive_timeout(connection, ping, 4, &bytes, 2000);\n\t\tif ((bytes == 0) && (device_error == IDEVICE_E_SUCCESS)) {\n\t\t\tattempts++;\n\t\t\tcontinue;\n\t\t} else if (device_error < 0) {\n\t\t\tfprintf(stderr, \"ERROR: Crash logs could not be moved. Connection interrupted.\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\tidevice_disconnect(connection);\n\tfree(ping);\n\n\tif (service) {\n\t\tlockdownd_service_descriptor_free(service);\n\t\tservice = NULL;\n\t}\n\n\tif (device_error != IDEVICE_E_SUCCESS || attempts > 10) {\n\t\tfprintf(stderr, \"ERROR: Failed to receive ping message from crash report mover.\\n\");\n\t\tlockdownd_client_free(lockdownd);\n\t\tidevice_free(device);\n\t\treturn -1;\n\t}\n\n\tlockdownd_error = lockdownd_start_service(lockdownd, \"com.apple.crashreportcopymobile\", &service);\n\tif (lockdownd_error != LOCKDOWN_E_SUCCESS) {\n\t\tlockdownd_client_free(lockdownd);\n\t\tidevice_free(device);\n\t\treturn -1;\n\t}\n\tlockdownd_client_free(lockdownd);\n\n\tafc = NULL;\n\tafc_error = afc_client_new(device, service, &afc);\n\tif(afc_error != AFC_E_SUCCESS) {\n\t\tlockdownd_client_free(lockdownd);\n\t\tidevice_free(device);\n\t\treturn -1;\n\t}\n\n\tif (service) {\n\t\tlockdownd_service_descriptor_free(service);\n\t\tservice = NULL;\n\t}\n\n\t/* recursively copy crash reports from the device to a local directory */\n\tif (afc_client_copy_and_remove_crash_reports(afc, \".\", target_directory) < 0) {\n\t\tfprintf(stderr, \"ERROR: Failed to get crash reports from device.\\n\");\n\t\tafc_client_free(afc);\n\t\tidevice_free(device);\n\t\treturn -1;\n\t}\n\n\tprintf(\"Done.\\n\");\n\n\tafc_client_free(afc);\n\tidevice_free(device);\n\n\treturn 0;\n}",
    "includes": [
      "#include <windows.h>",
      "#include <plist/plist.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/afc.h>",
      "#include \"common/utils.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const char* target_directory = NULL;",
      "static int extract_raw_crash_reports = 0;",
      "static int keep_crash_reports = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "idevice_free",
          "args": [
            "device"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "idevice_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
          "lines": "247-265",
          "snippet": "LIBIMOBILEDEVICE_API idevice_error_t idevice_free(idevice_t device)\n{\n\tif (!device)\n\t\treturn IDEVICE_E_INVALID_ARG;\n\tidevice_error_t ret = IDEVICE_E_UNKNOWN_ERROR;\n\n\tret = IDEVICE_E_SUCCESS;\n\n\tfree(device->udid);\n\n\tif (device->conn_type == CONNECTION_USBMUXD) {\n\t\tdevice->conn_data = 0;\n\t}\n\tif (device->conn_data) {\n\t\tfree(device->conn_data);\n\t}\n\tfree(device);\n\treturn ret;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"common/thread.h\"",
            "#include \"common/userpref.h\"",
            "#include \"idevice.h\"",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <usbmuxd.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "LIBIMOBILEDEVICE_API idevice_error_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nLIBIMOBILEDEVICE_API idevice_error_t idevice_free(idevice_t device)\n{\n\tif (!device)\n\t\treturn IDEVICE_E_INVALID_ARG;\n\tidevice_error_t ret = IDEVICE_E_UNKNOWN_ERROR;\n\n\tret = IDEVICE_E_SUCCESS;\n\n\tfree(device->udid);\n\n\tif (device->conn_type == CONNECTION_USBMUXD) {\n\t\tdevice->conn_data = 0;\n\t}\n\tif (device->conn_data) {\n\t\tfree(device->conn_data);\n\t}\n\tfree(device);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afc_client_free",
          "args": [
            "afc"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "afc_client_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "125-138",
          "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_client_free(afc_client_t client)\n{\n\tif (!client || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tif (client->free_parent && client->parent) {\n\t\tservice_client_free(client->parent);\n\t\tclient->parent = NULL;\n\t}\n\tfree(client->afc_packet);\n\tmutex_destroy(&client->mutex);\n\tfree(client);\n\treturn AFC_E_SUCCESS;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_client_free(afc_client_t client)\n{\n\tif (!client || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tif (client->free_parent && client->parent) {\n\t\tservice_client_free(client->parent);\n\t\tclient->parent = NULL;\n\t}\n\tfree(client->afc_packet);\n\tmutex_destroy(&client->mutex);\n\tfree(client);\n\treturn AFC_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Done.\\n\""
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"ERROR: Failed to get crash reports from device.\\n\""
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afc_client_copy_and_remove_crash_reports",
          "args": [
            "afc",
            "\".\"",
            "target_directory"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "afc_client_copy_and_remove_crash_reports",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicecrashreport.c",
          "lines": "96-292",
          "snippet": "static int afc_client_copy_and_remove_crash_reports(afc_client_t afc, const char* device_directory, const char* host_directory)\n{\n\tafc_error_t afc_error;\n\tint k;\n\tint res = -1;\n\tint crash_report_count = 0;\n\tuint64_t handle;\n\tchar source_filename[512];\n\tchar target_filename[512];\n\n\tif (!afc)\n\t\treturn res;\n\n\tchar** list = NULL;\n\tafc_error = afc_read_directory(afc, device_directory, &list);\n\tif (afc_error != AFC_E_SUCCESS) {\n\t\tfprintf(stderr, \"ERROR: Could not read device directory '%s'\\n\", device_directory);\n\t\treturn res;\n\t}\n\n\t/* ensure we have a trailing slash */\n\tstrcpy(source_filename, device_directory);\n\tif (source_filename[strlen(source_filename)-1] != '/') {\n\t\tstrcat(source_filename, \"/\");\n\t}\n\tint device_directory_length = strlen(source_filename);\n\n\t/* ensure we have a trailing slash */\n\tstrcpy(target_filename, host_directory);\n\tif (target_filename[strlen(target_filename)-1] != '/') {\n\t\tstrcat(target_filename, \"/\");\n\t}\n\tint host_directory_length = strlen(target_filename);\n\n\t/* loop over file entries */\n\tfor (k = 0; list[k]; k++) {\n\t\tif (!strcmp(list[k], \".\") || !strcmp(list[k], \"..\")) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tchar **fileinfo = NULL;\n\t\tstruct stat stbuf;\n\t\tstbuf.st_size = 0;\n\n\t\t/* assemble absolute source filename */\n\t\tstrcpy(((char*)source_filename) + device_directory_length, list[k]);\n\n\t\t/* assemble absolute target filename */\n\t\tchar* p = strrchr(list[k], '.');\n\t\tif (p != NULL && !strncmp(p, \".synced\", 7)) {\n\t\t\t/* make sure to strip \".synced\" extension as seen on iOS 5 */\n\t\t\tint newlen = strlen(list[k]) - 7;\n\t\t\tstrncpy(((char*)target_filename) + host_directory_length, list[k], newlen);\n\t\t\ttarget_filename[host_directory_length + newlen] = '\\0';\n\t\t} else {\n\t\t\tstrcpy(((char*)target_filename) + host_directory_length, list[k]);\n\t\t}\n\n\t\t/* get file information */\n\t\tafc_get_file_info(afc, source_filename, &fileinfo);\n\t\tif (!fileinfo) {\n\t\t\tprintf(\"Failed to read information for '%s'. Skipping...\\n\", source_filename);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* parse file information */\n\t\tint i;\n\t\tfor (i = 0; fileinfo[i]; i+=2) {\n\t\t\tif (!strcmp(fileinfo[i], \"st_size\")) {\n\t\t\t\tstbuf.st_size = atoll(fileinfo[i+1]);\n\t\t\t} else if (!strcmp(fileinfo[i], \"st_ifmt\")) {\n\t\t\t\tif (!strcmp(fileinfo[i+1], \"S_IFREG\")) {\n\t\t\t\t\tstbuf.st_mode = S_IFREG;\n\t\t\t\t} else if (!strcmp(fileinfo[i+1], \"S_IFDIR\")) {\n\t\t\t\t\tstbuf.st_mode = S_IFDIR;\n\t\t\t\t} else if (!strcmp(fileinfo[i+1], \"S_IFLNK\")) {\n\t\t\t\t\tstbuf.st_mode = S_IFLNK;\n\t\t\t\t} else if (!strcmp(fileinfo[i+1], \"S_IFBLK\")) {\n\t\t\t\t\tstbuf.st_mode = S_IFBLK;\n\t\t\t\t} else if (!strcmp(fileinfo[i+1], \"S_IFCHR\")) {\n\t\t\t\t\tstbuf.st_mode = S_IFCHR;\n\t\t\t\t} else if (!strcmp(fileinfo[i+1], \"S_IFIFO\")) {\n\t\t\t\t\tstbuf.st_mode = S_IFIFO;\n\t\t\t\t} else if (!strcmp(fileinfo[i+1], \"S_IFSOCK\")) {\n\t\t\t\t\tstbuf.st_mode = S_IFSOCK;\n\t\t\t\t}\n\t\t\t} else if (!strcmp(fileinfo[i], \"st_nlink\")) {\n\t\t\t\tstbuf.st_nlink = atoi(fileinfo[i+1]);\n\t\t\t} else if (!strcmp(fileinfo[i], \"st_mtime\")) {\n\t\t\t\tstbuf.st_mtime = (time_t)(atoll(fileinfo[i+1]) / 1000000000);\n\t\t\t} else if (!strcmp(fileinfo[i], \"LinkTarget\")) {\n\t\t\t\t/* report latest crash report filename */\n\t\t\t\tprintf(\"Link: %s\\n\", (char*)target_filename + strlen(target_directory));\n\n\t\t\t\t/* remove any previous symlink */\n\t\t\t\tif (file_exists(target_filename)) {\n\t\t\t\t\tremove(target_filename);\n\t\t\t\t}\n\n#ifndef WIN32\n\t\t\t\t/* use relative filename */\n\t\t\t\tchar* b = strrchr(fileinfo[i+1], '/');\n\t\t\t\tif (b == NULL) {\n\t\t\t\t\tb = fileinfo[i+1];\n\t\t\t\t} else {\n\t\t\t\t\tb++;\n\t\t\t\t}\n\n\t\t\t\t/* create a symlink pointing to latest log */\n\t\t\t\tif (symlink(b, target_filename) < 0) {\n\t\t\t\t\tfprintf(stderr, \"Can't create symlink to %s\\n\", b);\n\t\t\t\t}\n#endif\n\n\t\t\t\tif (!keep_crash_reports)\n\t\t\t\t\tafc_remove_path(afc, source_filename);\n\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t}\n\n\t\t/* free file information */\n\t\tafc_dictionary_free(fileinfo);\n\n\t\t/* recurse into child directories */\n\t\tif (S_ISDIR(stbuf.st_mode)) {\n#ifdef WIN32\n\t\t\tmkdir(target_filename);\n#else\n\t\t\tmkdir(target_filename, 0755);\n#endif\n\t\t\tres = afc_client_copy_and_remove_crash_reports(afc, source_filename, target_filename);\n\n\t\t\t/* remove directory from device */\n\t\t\tif (!keep_crash_reports)\n\t\t\t\tafc_remove_path(afc, source_filename);\n\t\t} else if (S_ISREG(stbuf.st_mode)) {\n\t\t\t/* copy file to host */\n\t\t\tafc_error = afc_file_open(afc, source_filename, AFC_FOPEN_RDONLY, &handle);\n\t\t\tif(afc_error != AFC_E_SUCCESS) {\n\t\t\t\tif (afc_error == AFC_E_OBJECT_NOT_FOUND) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"Unable to open device file '%s' (%d). Skipping...\\n\", source_filename, afc_error);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tFILE* output = fopen(target_filename, \"wb\");\n\t\t\tif(output == NULL) {\n\t\t\t\tfprintf(stderr, \"Unable to open local file '%s'. Skipping...\\n\", target_filename);\n\t\t\t\tafc_file_close(afc, handle);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tprintf(\"%s: %s\\n\", (keep_crash_reports ? \"Copy\": \"Move\") , (char*)target_filename + strlen(target_directory));\n\n\t\t\tuint32_t bytes_read = 0;\n\t\t\tuint32_t bytes_total = 0;\n\t\t\tunsigned char data[0x1000];\n\n\t\t\tafc_error = afc_file_read(afc, handle, (char*)data, 0x1000, &bytes_read);\n\t\t\twhile(afc_error == AFC_E_SUCCESS && bytes_read > 0) {\n\t\t\t\tfwrite(data, 1, bytes_read, output);\n\t\t\t\tbytes_total += bytes_read;\n\t\t\t\tafc_error = afc_file_read(afc, handle, (char*)data, 0x1000, &bytes_read);\n\t\t\t}\n\t\t\tafc_file_close(afc, handle);\n\t\t\tfclose(output);\n\n\t\t\tif ((uint32_t)stbuf.st_size != bytes_total) {\n\t\t\t\tfprintf(stderr, \"File size mismatch. Skipping...\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* remove file from device */\n\t\t\tif (!keep_crash_reports) {\n\t\t\t\tafc_remove_path(afc, source_filename);\n\t\t\t}\n\n\t\t\t/* extract raw crash information into separate '.crash' file */\n\t\t\tif (extract_raw_crash_reports) {\n\t\t\t\textract_raw_crash_report(target_filename);\n\t\t\t}\n\n\t\t\tcrash_report_count++;\n\n\t\t\tres = 0;\n\t\t}\n\t}\n\tafc_dictionary_free(list);\n\n\t/* no reports, no error */\n\tif (crash_report_count == 0)\n\t\tres = 0;\n\n\treturn res;\n}",
          "includes": [
            "#include <windows.h>",
            "#include <plist/plist.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/afc.h>",
            "#include \"common/utils.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define S_IFSOCK S_IFREG",
            "#define S_IFLNK S_IFREG"
          ],
          "globals_used": [
            "const char* target_directory = NULL;",
            "static int extract_raw_crash_reports = 0;",
            "static int keep_crash_reports = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include <plist/plist.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/afc.h>\n#include \"common/utils.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\n#define S_IFSOCK S_IFREG\n#define S_IFLNK S_IFREG\n\nconst char* target_directory = NULL;\nstatic int extract_raw_crash_reports = 0;\nstatic int keep_crash_reports = 0;\n\nstatic int afc_client_copy_and_remove_crash_reports(afc_client_t afc, const char* device_directory, const char* host_directory)\n{\n\tafc_error_t afc_error;\n\tint k;\n\tint res = -1;\n\tint crash_report_count = 0;\n\tuint64_t handle;\n\tchar source_filename[512];\n\tchar target_filename[512];\n\n\tif (!afc)\n\t\treturn res;\n\n\tchar** list = NULL;\n\tafc_error = afc_read_directory(afc, device_directory, &list);\n\tif (afc_error != AFC_E_SUCCESS) {\n\t\tfprintf(stderr, \"ERROR: Could not read device directory '%s'\\n\", device_directory);\n\t\treturn res;\n\t}\n\n\t/* ensure we have a trailing slash */\n\tstrcpy(source_filename, device_directory);\n\tif (source_filename[strlen(source_filename)-1] != '/') {\n\t\tstrcat(source_filename, \"/\");\n\t}\n\tint device_directory_length = strlen(source_filename);\n\n\t/* ensure we have a trailing slash */\n\tstrcpy(target_filename, host_directory);\n\tif (target_filename[strlen(target_filename)-1] != '/') {\n\t\tstrcat(target_filename, \"/\");\n\t}\n\tint host_directory_length = strlen(target_filename);\n\n\t/* loop over file entries */\n\tfor (k = 0; list[k]; k++) {\n\t\tif (!strcmp(list[k], \".\") || !strcmp(list[k], \"..\")) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tchar **fileinfo = NULL;\n\t\tstruct stat stbuf;\n\t\tstbuf.st_size = 0;\n\n\t\t/* assemble absolute source filename */\n\t\tstrcpy(((char*)source_filename) + device_directory_length, list[k]);\n\n\t\t/* assemble absolute target filename */\n\t\tchar* p = strrchr(list[k], '.');\n\t\tif (p != NULL && !strncmp(p, \".synced\", 7)) {\n\t\t\t/* make sure to strip \".synced\" extension as seen on iOS 5 */\n\t\t\tint newlen = strlen(list[k]) - 7;\n\t\t\tstrncpy(((char*)target_filename) + host_directory_length, list[k], newlen);\n\t\t\ttarget_filename[host_directory_length + newlen] = '\\0';\n\t\t} else {\n\t\t\tstrcpy(((char*)target_filename) + host_directory_length, list[k]);\n\t\t}\n\n\t\t/* get file information */\n\t\tafc_get_file_info(afc, source_filename, &fileinfo);\n\t\tif (!fileinfo) {\n\t\t\tprintf(\"Failed to read information for '%s'. Skipping...\\n\", source_filename);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* parse file information */\n\t\tint i;\n\t\tfor (i = 0; fileinfo[i]; i+=2) {\n\t\t\tif (!strcmp(fileinfo[i], \"st_size\")) {\n\t\t\t\tstbuf.st_size = atoll(fileinfo[i+1]);\n\t\t\t} else if (!strcmp(fileinfo[i], \"st_ifmt\")) {\n\t\t\t\tif (!strcmp(fileinfo[i+1], \"S_IFREG\")) {\n\t\t\t\t\tstbuf.st_mode = S_IFREG;\n\t\t\t\t} else if (!strcmp(fileinfo[i+1], \"S_IFDIR\")) {\n\t\t\t\t\tstbuf.st_mode = S_IFDIR;\n\t\t\t\t} else if (!strcmp(fileinfo[i+1], \"S_IFLNK\")) {\n\t\t\t\t\tstbuf.st_mode = S_IFLNK;\n\t\t\t\t} else if (!strcmp(fileinfo[i+1], \"S_IFBLK\")) {\n\t\t\t\t\tstbuf.st_mode = S_IFBLK;\n\t\t\t\t} else if (!strcmp(fileinfo[i+1], \"S_IFCHR\")) {\n\t\t\t\t\tstbuf.st_mode = S_IFCHR;\n\t\t\t\t} else if (!strcmp(fileinfo[i+1], \"S_IFIFO\")) {\n\t\t\t\t\tstbuf.st_mode = S_IFIFO;\n\t\t\t\t} else if (!strcmp(fileinfo[i+1], \"S_IFSOCK\")) {\n\t\t\t\t\tstbuf.st_mode = S_IFSOCK;\n\t\t\t\t}\n\t\t\t} else if (!strcmp(fileinfo[i], \"st_nlink\")) {\n\t\t\t\tstbuf.st_nlink = atoi(fileinfo[i+1]);\n\t\t\t} else if (!strcmp(fileinfo[i], \"st_mtime\")) {\n\t\t\t\tstbuf.st_mtime = (time_t)(atoll(fileinfo[i+1]) / 1000000000);\n\t\t\t} else if (!strcmp(fileinfo[i], \"LinkTarget\")) {\n\t\t\t\t/* report latest crash report filename */\n\t\t\t\tprintf(\"Link: %s\\n\", (char*)target_filename + strlen(target_directory));\n\n\t\t\t\t/* remove any previous symlink */\n\t\t\t\tif (file_exists(target_filename)) {\n\t\t\t\t\tremove(target_filename);\n\t\t\t\t}\n\n#ifndef WIN32\n\t\t\t\t/* use relative filename */\n\t\t\t\tchar* b = strrchr(fileinfo[i+1], '/');\n\t\t\t\tif (b == NULL) {\n\t\t\t\t\tb = fileinfo[i+1];\n\t\t\t\t} else {\n\t\t\t\t\tb++;\n\t\t\t\t}\n\n\t\t\t\t/* create a symlink pointing to latest log */\n\t\t\t\tif (symlink(b, target_filename) < 0) {\n\t\t\t\t\tfprintf(stderr, \"Can't create symlink to %s\\n\", b);\n\t\t\t\t}\n#endif\n\n\t\t\t\tif (!keep_crash_reports)\n\t\t\t\t\tafc_remove_path(afc, source_filename);\n\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t}\n\n\t\t/* free file information */\n\t\tafc_dictionary_free(fileinfo);\n\n\t\t/* recurse into child directories */\n\t\tif (S_ISDIR(stbuf.st_mode)) {\n#ifdef WIN32\n\t\t\tmkdir(target_filename);\n#else\n\t\t\tmkdir(target_filename, 0755);\n#endif\n\t\t\tres = afc_client_copy_and_remove_crash_reports(afc, source_filename, target_filename);\n\n\t\t\t/* remove directory from device */\n\t\t\tif (!keep_crash_reports)\n\t\t\t\tafc_remove_path(afc, source_filename);\n\t\t} else if (S_ISREG(stbuf.st_mode)) {\n\t\t\t/* copy file to host */\n\t\t\tafc_error = afc_file_open(afc, source_filename, AFC_FOPEN_RDONLY, &handle);\n\t\t\tif(afc_error != AFC_E_SUCCESS) {\n\t\t\t\tif (afc_error == AFC_E_OBJECT_NOT_FOUND) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"Unable to open device file '%s' (%d). Skipping...\\n\", source_filename, afc_error);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tFILE* output = fopen(target_filename, \"wb\");\n\t\t\tif(output == NULL) {\n\t\t\t\tfprintf(stderr, \"Unable to open local file '%s'. Skipping...\\n\", target_filename);\n\t\t\t\tafc_file_close(afc, handle);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tprintf(\"%s: %s\\n\", (keep_crash_reports ? \"Copy\": \"Move\") , (char*)target_filename + strlen(target_directory));\n\n\t\t\tuint32_t bytes_read = 0;\n\t\t\tuint32_t bytes_total = 0;\n\t\t\tunsigned char data[0x1000];\n\n\t\t\tafc_error = afc_file_read(afc, handle, (char*)data, 0x1000, &bytes_read);\n\t\t\twhile(afc_error == AFC_E_SUCCESS && bytes_read > 0) {\n\t\t\t\tfwrite(data, 1, bytes_read, output);\n\t\t\t\tbytes_total += bytes_read;\n\t\t\t\tafc_error = afc_file_read(afc, handle, (char*)data, 0x1000, &bytes_read);\n\t\t\t}\n\t\t\tafc_file_close(afc, handle);\n\t\t\tfclose(output);\n\n\t\t\tif ((uint32_t)stbuf.st_size != bytes_total) {\n\t\t\t\tfprintf(stderr, \"File size mismatch. Skipping...\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* remove file from device */\n\t\t\tif (!keep_crash_reports) {\n\t\t\t\tafc_remove_path(afc, source_filename);\n\t\t\t}\n\n\t\t\t/* extract raw crash information into separate '.crash' file */\n\t\t\tif (extract_raw_crash_reports) {\n\t\t\t\textract_raw_crash_report(target_filename);\n\t\t\t}\n\n\t\t\tcrash_report_count++;\n\n\t\t\tres = 0;\n\t\t}\n\t}\n\tafc_dictionary_free(list);\n\n\t/* no reports, no error */\n\tif (crash_report_count == 0)\n\t\tres = 0;\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdownd_service_descriptor_free",
          "args": [
            "service"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "lockdownd_service_descriptor_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/lockdown.c",
          "lines": "1522-1528",
          "snippet": "LIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_service_descriptor_free(lockdownd_service_descriptor_t service)\n{\n\tif (service)\n\t\tfree(service);\n\n\treturn LOCKDOWN_E_SUCCESS;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/userpref.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"lockdown.h\"",
            "#include \"property_list_service.h\"",
            "#include <plist/plist.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/x509.h>",
            "#include <libtasn1.h>",
            "#include <openssl/x509v3.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/pem.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/userpref.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"lockdown.h\"\n#include \"property_list_service.h\"\n#include <plist/plist.h>\n#include <gnutls/crypto.h>\n#include <gnutls/x509.h>\n#include <libtasn1.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/pem.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_service_descriptor_free(lockdownd_service_descriptor_t service)\n{\n\tif (service)\n\t\tfree(service);\n\n\treturn LOCKDOWN_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdownd_client_free",
          "args": [
            "lockdownd"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "lockdownd_client_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/lockdown.c",
          "lines": "322-336",
          "snippet": "LIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_client_free(lockdownd_client_t client)\n{\n\tif (!client)\n\t\treturn LOCKDOWN_E_INVALID_ARG;\n\n\tlockdownd_error_t ret = LOCKDOWN_E_UNKNOWN_ERROR;\n\n\tif (client->session_id) {\n\t\tlockdownd_stop_session(client, client->session_id);\n\t}\n\n\tret = lockdownd_client_free_simple(client);\n\n\treturn ret;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/userpref.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"lockdown.h\"",
            "#include \"property_list_service.h\"",
            "#include <plist/plist.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/x509.h>",
            "#include <libtasn1.h>",
            "#include <openssl/x509v3.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/pem.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/userpref.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"lockdown.h\"\n#include \"property_list_service.h\"\n#include <plist/plist.h>\n#include <gnutls/crypto.h>\n#include <gnutls/x509.h>\n#include <libtasn1.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/pem.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_client_free(lockdownd_client_t client)\n{\n\tif (!client)\n\t\treturn LOCKDOWN_E_INVALID_ARG;\n\n\tlockdownd_error_t ret = LOCKDOWN_E_UNKNOWN_ERROR;\n\n\tif (client->session_id) {\n\t\tlockdownd_stop_session(client, client->session_id);\n\t}\n\n\tret = lockdownd_client_free_simple(client);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afc_client_new",
          "args": [
            "device",
            "service",
            "&afc"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "afc_client_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "99-116",
          "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_client_new(idevice_t device, lockdownd_service_descriptor_t service, afc_client_t * client)\n{\n\tif (!device || !service || service->port == 0)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tservice_client_t parent = NULL;\n\tif (service_client_new(device, service, &parent) != SERVICE_E_SUCCESS) {\n\t\treturn AFC_E_MUX_ERROR;\n\t}\n\n\tafc_error_t err = afc_client_new_with_service_client(parent, client);\n\tif (err != AFC_E_SUCCESS) {\n\t\tservice_client_free(parent);\n\t} else {\n\t\t(*client)->free_parent = 1;\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_client_new(idevice_t device, lockdownd_service_descriptor_t service, afc_client_t * client)\n{\n\tif (!device || !service || service->port == 0)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tservice_client_t parent = NULL;\n\tif (service_client_new(device, service, &parent) != SERVICE_E_SUCCESS) {\n\t\treturn AFC_E_MUX_ERROR;\n\t}\n\n\tafc_error_t err = afc_client_new_with_service_client(parent, client);\n\tif (err != AFC_E_SUCCESS) {\n\t\tservice_client_free(parent);\n\t} else {\n\t\t(*client)->free_parent = 1;\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdownd_start_service",
          "args": [
            "lockdownd",
            "\"com.apple.crashreportcopymobile\"",
            "&service"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "lockdownd_start_service_with_escrow_bag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/lockdown.c",
          "lines": "1364-1367",
          "snippet": "LIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_start_service_with_escrow_bag(lockdownd_client_t client, const char *identifier, lockdownd_service_descriptor_t *service)\n{\n\treturn lockdownd_do_start_service(client, identifier, 1, service);\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/userpref.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"lockdown.h\"",
            "#include \"property_list_service.h\"",
            "#include <plist/plist.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/x509.h>",
            "#include <libtasn1.h>",
            "#include <openssl/x509v3.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/pem.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/userpref.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"lockdown.h\"\n#include \"property_list_service.h\"\n#include <plist/plist.h>\n#include <gnutls/crypto.h>\n#include <gnutls/x509.h>\n#include <libtasn1.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/pem.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_start_service_with_escrow_bag(lockdownd_client_t client, const char *identifier, lockdownd_service_descriptor_t *service)\n{\n\treturn lockdownd_do_start_service(client, identifier, 1, service);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"ERROR: Failed to receive ping message from crash report mover.\\n\""
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ping"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "thread_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "39-44",
          "snippet": "void thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nvoid thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "idevice_disconnect",
          "args": [
            "connection"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "idevice_disconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
          "lines": "293-318",
          "snippet": "LIBIMOBILEDEVICE_API idevice_error_t idevice_disconnect(idevice_connection_t connection)\n{\n\tif (!connection) {\n\t\treturn IDEVICE_E_INVALID_ARG;\n\t}\n\t/* shut down ssl if enabled */\n\tif (connection->ssl_data) {\n\t\tidevice_connection_disable_ssl(connection);\n\t}\n\tidevice_error_t result = IDEVICE_E_UNKNOWN_ERROR;\n\tif (connection->type == CONNECTION_USBMUXD) {\n\t\tusbmuxd_disconnect((int)(long)connection->data);\n\t\tconnection->data = NULL;\n\t\tresult = IDEVICE_E_SUCCESS;\n\t} else {\n\t\tdebug_info(\"Unknown connection type %d\", connection->type);\n\t}\n\n\tif (connection->udid)\n\t\tfree(connection->udid);\n\n\tfree(connection);\n\tconnection = NULL;\n\n\treturn result;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"common/thread.h\"",
            "#include \"common/userpref.h\"",
            "#include \"idevice.h\"",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <usbmuxd.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "LIBIMOBILEDEVICE_API idevice_error_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nLIBIMOBILEDEVICE_API idevice_error_t idevice_disconnect(idevice_connection_t connection)\n{\n\tif (!connection) {\n\t\treturn IDEVICE_E_INVALID_ARG;\n\t}\n\t/* shut down ssl if enabled */\n\tif (connection->ssl_data) {\n\t\tidevice_connection_disable_ssl(connection);\n\t}\n\tidevice_error_t result = IDEVICE_E_UNKNOWN_ERROR;\n\tif (connection->type == CONNECTION_USBMUXD) {\n\t\tusbmuxd_disconnect((int)(long)connection->data);\n\t\tconnection->data = NULL;\n\t\tresult = IDEVICE_E_SUCCESS;\n\t} else {\n\t\tdebug_info(\"Unknown connection type %d\", connection->type);\n\t}\n\n\tif (connection->udid)\n\t\tfree(connection->udid);\n\n\tfree(connection);\n\tconnection = NULL;\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"ERROR: Crash logs could not be moved. Connection interrupted.\\n\""
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idevice_connection_receive_timeout",
          "args": [
            "connection",
            "ping",
            "4",
            "&bytes",
            "2000"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "idevice_connection_receive_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
          "lines": "389-418",
          "snippet": "LIBIMOBILEDEVICE_API idevice_error_t idevice_connection_receive_timeout(idevice_connection_t connection, char *data, uint32_t len, uint32_t *recv_bytes, unsigned int timeout)\n{\n\tif (!connection || (connection->ssl_data && !connection->ssl_data->session)) {\n\t\treturn IDEVICE_E_INVALID_ARG;\n\t}\n\n\tif (connection->ssl_data) {\n\t\tuint32_t received = 0;\n\t\twhile (received < len) {\n#ifdef HAVE_OPENSSL\n\t\t\tint r = SSL_read(connection->ssl_data->session, (void*)((char*)(data+received)), (int)len-received);\n#else\n\t\t\tssize_t r = gnutls_record_recv(connection->ssl_data->session, (void*)(data+received), (size_t)len-received);\n#endif\n\t\t\tif (r > 0) {\n\t\t\t\treceived += r;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tdebug_info(\"SSL_read %d, received %d\", len, received);\n\t\tif (received > 0) {\n\t\t\t*recv_bytes = received;\n\t\t\treturn IDEVICE_E_SUCCESS;\n\t\t}\n\t\t*recv_bytes = 0;\n\t\treturn IDEVICE_E_SSL_ERROR;\n\t}\n\treturn internal_connection_receive_timeout(connection, data, len, recv_bytes, timeout);\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"common/thread.h\"",
            "#include \"common/userpref.h\"",
            "#include \"idevice.h\"",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <usbmuxd.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "LIBIMOBILEDEVICE_API idevice_error_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nLIBIMOBILEDEVICE_API idevice_error_t idevice_connection_receive_timeout(idevice_connection_t connection, char *data, uint32_t len, uint32_t *recv_bytes, unsigned int timeout)\n{\n\tif (!connection || (connection->ssl_data && !connection->ssl_data->session)) {\n\t\treturn IDEVICE_E_INVALID_ARG;\n\t}\n\n\tif (connection->ssl_data) {\n\t\tuint32_t received = 0;\n\t\twhile (received < len) {\n#ifdef HAVE_OPENSSL\n\t\t\tint r = SSL_read(connection->ssl_data->session, (void*)((char*)(data+received)), (int)len-received);\n#else\n\t\t\tssize_t r = gnutls_record_recv(connection->ssl_data->session, (void*)(data+received), (size_t)len-received);\n#endif\n\t\t\tif (r > 0) {\n\t\t\t\treceived += r;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tdebug_info(\"SSL_read %d, received %d\", len, received);\n\t\tif (received > 0) {\n\t\t\t*recv_bytes = received;\n\t\t\treturn IDEVICE_E_SUCCESS;\n\t\t}\n\t\t*recv_bytes = 0;\n\t\treturn IDEVICE_E_SSL_ERROR;\n\t}\n\treturn internal_connection_receive_timeout(connection, data, len, recv_bytes, timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ping",
            "\"ping\"",
            "4"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ping",
            "'\\0'",
            "4"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "4"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idevice_connect",
          "args": [
            "device",
            "service->port",
            "&connection"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "idevice_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
          "lines": "267-291",
          "snippet": "LIBIMOBILEDEVICE_API idevice_error_t idevice_connect(idevice_t device, uint16_t port, idevice_connection_t *connection)\n{\n\tif (!device) {\n\t\treturn IDEVICE_E_INVALID_ARG;\n\t}\n\n\tif (device->conn_type == CONNECTION_USBMUXD) {\n\t\tint sfd = usbmuxd_connect((uint32_t)(long)device->conn_data, port);\n\t\tif (sfd < 0) {\n\t\t\tdebug_info(\"ERROR: Connecting to usbmuxd failed: %d (%s)\", sfd, strerror(-sfd));\n\t\t\treturn IDEVICE_E_UNKNOWN_ERROR;\n\t\t}\n\t\tidevice_connection_t new_connection = (idevice_connection_t)malloc(sizeof(struct idevice_connection_private));\n\t\tnew_connection->type = CONNECTION_USBMUXD;\n\t\tnew_connection->data = (void*)(long)sfd;\n\t\tnew_connection->ssl_data = NULL;\n\t\tidevice_get_udid(device, &new_connection->udid);\n\t\t*connection = new_connection;\n\t\treturn IDEVICE_E_SUCCESS;\n\t} else {\n\t\tdebug_info(\"Unknown connection type %d\", device->conn_type);\n\t}\n\n\treturn IDEVICE_E_UNKNOWN_ERROR;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"common/thread.h\"",
            "#include \"common/userpref.h\"",
            "#include \"idevice.h\"",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <usbmuxd.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "LIBIMOBILEDEVICE_API idevice_error_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nLIBIMOBILEDEVICE_API idevice_error_t idevice_connect(idevice_t device, uint16_t port, idevice_connection_t *connection)\n{\n\tif (!device) {\n\t\treturn IDEVICE_E_INVALID_ARG;\n\t}\n\n\tif (device->conn_type == CONNECTION_USBMUXD) {\n\t\tint sfd = usbmuxd_connect((uint32_t)(long)device->conn_data, port);\n\t\tif (sfd < 0) {\n\t\t\tdebug_info(\"ERROR: Connecting to usbmuxd failed: %d (%s)\", sfd, strerror(-sfd));\n\t\t\treturn IDEVICE_E_UNKNOWN_ERROR;\n\t\t}\n\t\tidevice_connection_t new_connection = (idevice_connection_t)malloc(sizeof(struct idevice_connection_private));\n\t\tnew_connection->type = CONNECTION_USBMUXD;\n\t\tnew_connection->data = (void*)(long)sfd;\n\t\tnew_connection->ssl_data = NULL;\n\t\tidevice_get_udid(device, &new_connection->udid);\n\t\t*connection = new_connection;\n\t\treturn IDEVICE_E_SUCCESS;\n\t} else {\n\t\tdebug_info(\"Unknown connection type %d\", device->conn_type);\n\t}\n\n\treturn IDEVICE_E_UNKNOWN_ERROR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"ERROR: Could not connect to lockdownd, error code %d\\n\"",
            "lockdownd_error"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdownd_client_new_with_handshake",
          "args": [
            "device",
            "&lockdownd",
            "\"idevicecrashreport\""
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "lockdownd_client_new_with_handshake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/lockdown.c",
          "lines": "671-753",
          "snippet": "LIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_client_new_with_handshake(idevice_t device, lockdownd_client_t *client, const char *label)\n{\n\tif (!client)\n\t\treturn LOCKDOWN_E_INVALID_ARG;\n\n\tlockdownd_error_t ret = LOCKDOWN_E_SUCCESS;\n\tlockdownd_client_t client_loc = NULL;\n\tplist_t pair_record = NULL;\n\tchar *host_id = NULL;\n\tchar *type = NULL;\n\n\tret = lockdownd_client_new(device, &client_loc, label);\n\tif (LOCKDOWN_E_SUCCESS != ret) {\n\t\tdebug_info(\"failed to create lockdownd client.\");\n\t\treturn ret;\n\t}\n\n\t/* perform handshake */\n\tif (LOCKDOWN_E_SUCCESS != lockdownd_query_type(client_loc, &type)) {\n\t\tdebug_info(\"QueryType failed in the lockdownd client.\");\n\t\tret = LOCKDOWN_E_NOT_ENOUGH_DATA;\n\t} else {\n\t\tif (strcmp(\"com.apple.mobile.lockdown\", type)) {\n\t\t\tdebug_info(\"Warning QueryType request returned \\\"%s\\\".\", type);\n\t\t}\n\t}\n\tfree(type);\n\n\tuserpref_read_pair_record(client_loc->udid, &pair_record);\n\tif (pair_record) {\n\t\tpair_record_get_host_id(pair_record, &host_id);\n\t}\n\tif (LOCKDOWN_E_SUCCESS == ret && !host_id) {\n\t\tret = LOCKDOWN_E_INVALID_CONF;\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS == ret && !pair_record) {\n\t\t/* attempt pairing */\n\t\tret = lockdownd_pair(client_loc, NULL);\n\t}\n\n\tplist_free(pair_record);\n\tpair_record = NULL;\n\n\t/* in any case, we need to validate pairing to receive trusted host status */\n\tret = lockdownd_validate_pair(client_loc, NULL);\n\n\t/* if not paired yet, let's do it now */\n\tif (LOCKDOWN_E_INVALID_HOST_ID == ret) {\n\t\tfree(host_id);\n\t\thost_id = NULL;\n\t\tret = lockdownd_pair(client_loc, NULL);\n\t\tif (LOCKDOWN_E_SUCCESS == ret) {\n\t\t\tret = lockdownd_validate_pair(client_loc, NULL);\n\t\t} else if (LOCKDOWN_E_PAIRING_DIALOG_RESPONSE_PENDING == ret) {\n\t\t\tdebug_info(\"Device shows the pairing dialog.\");\n\t\t}\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS == ret) {\n\t\tif (!host_id) {\n\t\t\tuserpref_read_pair_record(client_loc->udid, &pair_record);\n\t\t\tif (pair_record) {\n\t\t\t\tpair_record_get_host_id(pair_record, &host_id);\n\t\t\t\tplist_free(pair_record);\n\t\t\t}\n\t\t}\n\n\t\tret = lockdownd_start_session(client_loc, host_id, NULL, NULL);\n\t\tif (LOCKDOWN_E_SUCCESS != ret) {\n\t\t\tdebug_info(\"Session opening failed.\");\n\t\t}\n\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS == ret) {\n\t\t*client = client_loc;\n\t} else {\n\t\tlockdownd_client_free(client_loc);\n\t}\n\tfree(host_id);\n\treturn ret;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/userpref.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"lockdown.h\"",
            "#include \"property_list_service.h\"",
            "#include <plist/plist.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/x509.h>",
            "#include <libtasn1.h>",
            "#include <openssl/x509v3.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/pem.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/userpref.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"lockdown.h\"\n#include \"property_list_service.h\"\n#include <plist/plist.h>\n#include <gnutls/crypto.h>\n#include <gnutls/x509.h>\n#include <libtasn1.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/pem.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_client_new_with_handshake(idevice_t device, lockdownd_client_t *client, const char *label)\n{\n\tif (!client)\n\t\treturn LOCKDOWN_E_INVALID_ARG;\n\n\tlockdownd_error_t ret = LOCKDOWN_E_SUCCESS;\n\tlockdownd_client_t client_loc = NULL;\n\tplist_t pair_record = NULL;\n\tchar *host_id = NULL;\n\tchar *type = NULL;\n\n\tret = lockdownd_client_new(device, &client_loc, label);\n\tif (LOCKDOWN_E_SUCCESS != ret) {\n\t\tdebug_info(\"failed to create lockdownd client.\");\n\t\treturn ret;\n\t}\n\n\t/* perform handshake */\n\tif (LOCKDOWN_E_SUCCESS != lockdownd_query_type(client_loc, &type)) {\n\t\tdebug_info(\"QueryType failed in the lockdownd client.\");\n\t\tret = LOCKDOWN_E_NOT_ENOUGH_DATA;\n\t} else {\n\t\tif (strcmp(\"com.apple.mobile.lockdown\", type)) {\n\t\t\tdebug_info(\"Warning QueryType request returned \\\"%s\\\".\", type);\n\t\t}\n\t}\n\tfree(type);\n\n\tuserpref_read_pair_record(client_loc->udid, &pair_record);\n\tif (pair_record) {\n\t\tpair_record_get_host_id(pair_record, &host_id);\n\t}\n\tif (LOCKDOWN_E_SUCCESS == ret && !host_id) {\n\t\tret = LOCKDOWN_E_INVALID_CONF;\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS == ret && !pair_record) {\n\t\t/* attempt pairing */\n\t\tret = lockdownd_pair(client_loc, NULL);\n\t}\n\n\tplist_free(pair_record);\n\tpair_record = NULL;\n\n\t/* in any case, we need to validate pairing to receive trusted host status */\n\tret = lockdownd_validate_pair(client_loc, NULL);\n\n\t/* if not paired yet, let's do it now */\n\tif (LOCKDOWN_E_INVALID_HOST_ID == ret) {\n\t\tfree(host_id);\n\t\thost_id = NULL;\n\t\tret = lockdownd_pair(client_loc, NULL);\n\t\tif (LOCKDOWN_E_SUCCESS == ret) {\n\t\t\tret = lockdownd_validate_pair(client_loc, NULL);\n\t\t} else if (LOCKDOWN_E_PAIRING_DIALOG_RESPONSE_PENDING == ret) {\n\t\t\tdebug_info(\"Device shows the pairing dialog.\");\n\t\t}\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS == ret) {\n\t\tif (!host_id) {\n\t\t\tuserpref_read_pair_record(client_loc->udid, &pair_record);\n\t\t\tif (pair_record) {\n\t\t\t\tpair_record_get_host_id(pair_record, &host_id);\n\t\t\t\tplist_free(pair_record);\n\t\t\t}\n\t\t}\n\n\t\tret = lockdownd_start_session(client_loc, host_id, NULL, NULL);\n\t\tif (LOCKDOWN_E_SUCCESS != ret) {\n\t\t\tdebug_info(\"Session opening failed.\");\n\t\t}\n\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS == ret) {\n\t\t*client = client_loc;\n\t} else {\n\t\tlockdownd_client_free(client_loc);\n\t}\n\tfree(host_id);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"No device found, is it plugged in?\\n\""
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"No device found with udid %s, is it plugged in?\\n\"",
            "udid"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "asprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/include/asprintf.h",
          "lines": "23-31",
          "snippet": "static inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}",
          "includes": [
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <config.h>\n\nstatic inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "idevice_new",
          "args": [
            "&device",
            "udid"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "idevice_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
          "lines": "230-245",
          "snippet": "LIBIMOBILEDEVICE_API idevice_error_t idevice_new(idevice_t * device, const char *udid)\n{\n\tusbmuxd_device_info_t muxdev;\n\tint res = usbmuxd_get_device_by_udid(udid, &muxdev);\n\tif (res > 0) {\n\t\tidevice_t dev = (idevice_t) malloc(sizeof(struct idevice_private));\n\t\tdev->udid = strdup(muxdev.udid);\n\t\tdev->conn_type = CONNECTION_USBMUXD;\n\t\tdev->conn_data = (void*)(long)muxdev.handle;\n\t\t*device = dev;\n\t\treturn IDEVICE_E_SUCCESS;\n\t}\n\t/* other connection types could follow here */\n\n\treturn IDEVICE_E_NO_DEVICE;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"common/thread.h\"",
            "#include \"common/userpref.h\"",
            "#include \"idevice.h\"",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <usbmuxd.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "LIBIMOBILEDEVICE_API idevice_error_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nLIBIMOBILEDEVICE_API idevice_error_t idevice_new(idevice_t * device, const char *udid)\n{\n\tusbmuxd_device_info_t muxdev;\n\tint res = usbmuxd_get_device_by_udid(udid, &muxdev);\n\tif (res > 0) {\n\t\tidevice_t dev = (idevice_t) malloc(sizeof(struct idevice_private));\n\t\tdev->udid = strdup(muxdev.udid);\n\t\tdev->conn_type = CONNECTION_USBMUXD;\n\t\tdev->conn_data = (void*)(long)muxdev.handle;\n\t\t*device = dev;\n\t\treturn IDEVICE_E_SUCCESS;\n\t}\n\t/* other connection types could follow here */\n\n\treturn IDEVICE_E_NO_DEVICE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_usage",
          "args": [
            "argc",
            "argv"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "print_usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicecrashreport.c",
          "lines": "294-308",
          "snippet": "static void print_usage(int argc, char **argv)\n{\n\tchar *name = NULL;\n\n\tname = strrchr(argv[0], '/');\n\tprintf(\"Usage: %s [OPTIONS] DIRECTORY\\n\", (name ? name + 1: argv[0]));\n\tprintf(\"Move crash reports from device to a local DIRECTORY.\\n\\n\");\n\tprintf(\"  -e, --extract\\t\\textract raw crash report into separate '.crash' file\\n\");\n\tprintf(\"  -k, --keep\\t\\tcopy but do not remove crash reports from device\\n\");\n\tprintf(\"  -d, --debug\\t\\tenable communication debugging\\n\");\n\tprintf(\"  -u, --udid UDID\\ttarget specific device by its 40-digit device UDID\\n\");\n\tprintf(\"  -h, --help\\t\\tprints usage information\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"Homepage: <\" PACKAGE_URL \">\\n\");\n}",
          "includes": [
            "#include <windows.h>",
            "#include <plist/plist.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/afc.h>",
            "#include \"common/utils.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include <plist/plist.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/afc.h>\n#include \"common/utils.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void print_usage(int argc, char **argv)\n{\n\tchar *name = NULL;\n\n\tname = strrchr(argv[0], '/');\n\tprintf(\"Usage: %s [OPTIONS] DIRECTORY\\n\", (name ? name + 1: argv[0]));\n\tprintf(\"Move crash reports from device to a local DIRECTORY.\\n\\n\");\n\tprintf(\"  -e, --extract\\t\\textract raw crash report into separate '.crash' file\\n\");\n\tprintf(\"  -k, --keep\\t\\tcopy but do not remove crash reports from device\\n\");\n\tprintf(\"  -d, --debug\\t\\tenable communication debugging\\n\");\n\tprintf(\"  -u, --udid UDID\\ttarget specific device by its 40-digit device UDID\\n\");\n\tprintf(\"  -h, --help\\t\\tprints usage information\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"Homepage: <\" PACKAGE_URL \">\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"ERROR: Directory '%s' does not exist.\\n\"",
            "target_directory"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_exists",
          "args": [
            "target_directory"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "file_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicecrashreport.c",
          "lines": "48-56",
          "snippet": "static int file_exists(const char* path)\n{\n\tstruct stat tst;\n#ifdef WIN32\n\treturn (stat(path, &tst) == 0);\n#else\n\treturn (lstat(path, &tst) == 0);\n#endif\n}",
          "includes": [
            "#include <windows.h>",
            "#include <plist/plist.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/afc.h>",
            "#include \"common/utils.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include <plist/plist.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/afc.h>\n#include \"common/utils.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int file_exists(const char* path)\n{\n\tstruct stat tst;\n#ifdef WIN32\n\treturn (stat(path, &tst) == 0);\n#else\n\treturn (lstat(path, &tst) == 0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"--keep\""
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "plist_strcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
          "lines": "296-309",
          "snippet": "static int plist_strcmp(plist_t node, const char *str)\n{\n\tchar *buffer = NULL;\n\tint ret = 0;\n\n\tif (plist_get_node_type(node) != PLIST_STRING)\n\t\treturn ret;\n\n\tplist_get_string_val(node, &buffer);\n\tret = strcmp(buffer, str);\n\tfree(buffer);\n\n\treturn ret;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <unistd.h>",
            "#include <gcrypt.h>",
            "#include <openssl/sha.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int plist_strcmp(plist_t node, const char *str)\n{\n\tchar *buffer = NULL;\n\tint ret = 0;\n\n\tif (plist_get_node_type(node) != PLIST_STRING)\n\t\treturn ret;\n\n\tplist_get_string_val(node, &buffer);\n\tret = strcmp(buffer, str);\n\tfree(buffer);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "argv[i]"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idevice_set_debug_level",
          "args": [
            "1"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "idevice_set_debug_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
          "lines": "225-228",
          "snippet": "LIBIMOBILEDEVICE_API void idevice_set_debug_level(int level)\n{\n\tinternal_set_debug_level(level);\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"common/thread.h\"",
            "#include \"common/userpref.h\"",
            "#include \"idevice.h\"",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <usbmuxd.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API void idevice_set_debug_level(int level)\n{\n\tinternal_set_debug_level(level);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include <plist/plist.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/afc.h>\n#include \"common/utils.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nconst char* target_directory = NULL;\nstatic int extract_raw_crash_reports = 0;\nstatic int keep_crash_reports = 0;\n\nint main(int argc, char* argv[]) {\n\tidevice_t device = NULL;\n\tlockdownd_client_t lockdownd = NULL;\n\tafc_client_t afc = NULL;\n\n\tidevice_error_t device_error = IDEVICE_E_SUCCESS;\n\tlockdownd_error_t lockdownd_error = LOCKDOWN_E_SUCCESS;\n\tafc_error_t afc_error = AFC_E_SUCCESS;\n\n\tint i;\n\tconst char* udid = NULL;\n\n\t/* parse cmdline args */\n\tfor (i = 1; i < argc; i++) {\n\t\tif (!strcmp(argv[i], \"-d\") || !strcmp(argv[i], \"--debug\")) {\n\t\t\tidevice_set_debug_level(1);\n\t\t\tcontinue;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"-u\") || !strcmp(argv[i], \"--udid\")) {\n\t\t\ti++;\n\t\t\tif (!argv[i] || (strlen(argv[i]) != 40)) {\n\t\t\t\tprint_usage(argc, argv);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tudid = argv[i];\n\t\t\tcontinue;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"-h\") || !strcmp(argv[i], \"--help\")) {\n\t\t\tprint_usage(argc, argv);\n\t\t\treturn 0;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"-e\") || !strcmp(argv[i], \"--extract\")) {\n\t\t\textract_raw_crash_reports = 1;\n\t\t\tcontinue;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"-k\") || !strcmp(argv[i], \"--keep\")) {\n\t\t\tkeep_crash_reports = 1;\n\t\t\tcontinue;\n\t\t}\n\t\telse if (target_directory == NULL) {\n\t\t\ttarget_directory = argv[i];\n\t\t\tcontinue;\n\t\t}\n\t\telse {\n\t\t\tprint_usage(argc, argv);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* ensure a target directory was supplied */\n\tif (!target_directory) {\n\t\tprint_usage(argc, argv);\n\t\treturn 0;\n\t}\n\n\t/* check if target directory exists */\n\tif (!file_exists(target_directory)) {\n\t\tfprintf(stderr, \"ERROR: Directory '%s' does not exist.\\n\", target_directory);\n\t\tprint_usage(argc, argv);\n\t\treturn 0;\n\t}\n\n\tdevice_error = idevice_new(&device, udid);\n\tif (device_error != IDEVICE_E_SUCCESS) {\n\t\tif (udid) {\n\t\t\tprintf(\"No device found with udid %s, is it plugged in?\\n\", udid);\n\t\t} else {\n\t\t\tprintf(\"No device found, is it plugged in?\\n\");\n\t\t}\n\t\treturn -1;\n\t}\n\n\tlockdownd_error = lockdownd_client_new_with_handshake(device, &lockdownd, \"idevicecrashreport\");\n\tif (lockdownd_error != LOCKDOWN_E_SUCCESS) {\n\t\tfprintf(stderr, \"ERROR: Could not connect to lockdownd, error code %d\\n\", lockdownd_error);\n\t\tidevice_free(device);\n\t\treturn -1;\n\t}\n\n\t/* start crash log mover service */\n\tlockdownd_service_descriptor_t service = NULL;\n\tlockdownd_error = lockdownd_start_service(lockdownd, \"com.apple.crashreportmover\", &service);\n\tif (lockdownd_error != LOCKDOWN_E_SUCCESS) {\n\t\tlockdownd_client_free(lockdownd);\n\t\tidevice_free(device);\n\t\treturn -1;\n\t}\n\n\t/* trigger move operation on device */\n\tidevice_connection_t connection = NULL;\n\tdevice_error = idevice_connect(device, service->port, &connection);\n\tif(device_error != IDEVICE_E_SUCCESS) {\n\t\tlockdownd_client_free(lockdownd);\n\t\tidevice_free(device);\n\t\treturn -1;\n\t}\n\n\t/* read \"ping\" message which indicates the crash logs have been moved to a safe harbor */\n\tchar *ping = malloc(4);\n\tmemset(ping, '\\0', 4);\n\tint attempts = 0;\n\twhile ((strncmp(ping, \"ping\", 4) != 0) && (attempts < 10)) {\n\t\tuint32_t bytes = 0;\n\t\tdevice_error = idevice_connection_receive_timeout(connection, ping, 4, &bytes, 2000);\n\t\tif ((bytes == 0) && (device_error == IDEVICE_E_SUCCESS)) {\n\t\t\tattempts++;\n\t\t\tcontinue;\n\t\t} else if (device_error < 0) {\n\t\t\tfprintf(stderr, \"ERROR: Crash logs could not be moved. Connection interrupted.\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\tidevice_disconnect(connection);\n\tfree(ping);\n\n\tif (service) {\n\t\tlockdownd_service_descriptor_free(service);\n\t\tservice = NULL;\n\t}\n\n\tif (device_error != IDEVICE_E_SUCCESS || attempts > 10) {\n\t\tfprintf(stderr, \"ERROR: Failed to receive ping message from crash report mover.\\n\");\n\t\tlockdownd_client_free(lockdownd);\n\t\tidevice_free(device);\n\t\treturn -1;\n\t}\n\n\tlockdownd_error = lockdownd_start_service(lockdownd, \"com.apple.crashreportcopymobile\", &service);\n\tif (lockdownd_error != LOCKDOWN_E_SUCCESS) {\n\t\tlockdownd_client_free(lockdownd);\n\t\tidevice_free(device);\n\t\treturn -1;\n\t}\n\tlockdownd_client_free(lockdownd);\n\n\tafc = NULL;\n\tafc_error = afc_client_new(device, service, &afc);\n\tif(afc_error != AFC_E_SUCCESS) {\n\t\tlockdownd_client_free(lockdownd);\n\t\tidevice_free(device);\n\t\treturn -1;\n\t}\n\n\tif (service) {\n\t\tlockdownd_service_descriptor_free(service);\n\t\tservice = NULL;\n\t}\n\n\t/* recursively copy crash reports from the device to a local directory */\n\tif (afc_client_copy_and_remove_crash_reports(afc, \".\", target_directory) < 0) {\n\t\tfprintf(stderr, \"ERROR: Failed to get crash reports from device.\\n\");\n\t\tafc_client_free(afc);\n\t\tidevice_free(device);\n\t\treturn -1;\n\t}\n\n\tprintf(\"Done.\\n\");\n\n\tafc_client_free(afc);\n\tidevice_free(device);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "print_usage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicecrashreport.c",
    "lines": "294-308",
    "snippet": "static void print_usage(int argc, char **argv)\n{\n\tchar *name = NULL;\n\n\tname = strrchr(argv[0], '/');\n\tprintf(\"Usage: %s [OPTIONS] DIRECTORY\\n\", (name ? name + 1: argv[0]));\n\tprintf(\"Move crash reports from device to a local DIRECTORY.\\n\\n\");\n\tprintf(\"  -e, --extract\\t\\textract raw crash report into separate '.crash' file\\n\");\n\tprintf(\"  -k, --keep\\t\\tcopy but do not remove crash reports from device\\n\");\n\tprintf(\"  -d, --debug\\t\\tenable communication debugging\\n\");\n\tprintf(\"  -u, --udid UDID\\ttarget specific device by its 40-digit device UDID\\n\");\n\tprintf(\"  -h, --help\\t\\tprints usage information\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"Homepage: <\" PACKAGE_URL \">\\n\");\n}",
    "includes": [
      "#include <windows.h>",
      "#include <plist/plist.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/afc.h>",
      "#include \"common/utils.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Homepage: <\" PACKAGE_URL \">\\n\""
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  -h, --help\\t\\tprints usage information\\n\""
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  -u, --udid UDID\\ttarget specific device by its 40-digit device UDID\\n\""
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  -d, --debug\\t\\tenable communication debugging\\n\""
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  -k, --keep\\t\\tcopy but do not remove crash reports from device\\n\""
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  -e, --extract\\t\\textract raw crash report into separate '.crash' file\\n\""
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Move crash reports from device to a local DIRECTORY.\\n\\n\""
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Usage: %s [OPTIONS] DIRECTORY\\n\"",
            "(name ? name + 1: argv[0])"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "asprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/include/asprintf.h",
          "lines": "23-31",
          "snippet": "static inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}",
          "includes": [
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <config.h>\n\nstatic inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "argv[0]",
            "'/'"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include <plist/plist.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/afc.h>\n#include \"common/utils.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void print_usage(int argc, char **argv)\n{\n\tchar *name = NULL;\n\n\tname = strrchr(argv[0], '/');\n\tprintf(\"Usage: %s [OPTIONS] DIRECTORY\\n\", (name ? name + 1: argv[0]));\n\tprintf(\"Move crash reports from device to a local DIRECTORY.\\n\\n\");\n\tprintf(\"  -e, --extract\\t\\textract raw crash report into separate '.crash' file\\n\");\n\tprintf(\"  -k, --keep\\t\\tcopy but do not remove crash reports from device\\n\");\n\tprintf(\"  -d, --debug\\t\\tenable communication debugging\\n\");\n\tprintf(\"  -u, --udid UDID\\ttarget specific device by its 40-digit device UDID\\n\");\n\tprintf(\"  -h, --help\\t\\tprints usage information\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"Homepage: <\" PACKAGE_URL \">\\n\");\n}"
  },
  {
    "function_name": "afc_client_copy_and_remove_crash_reports",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicecrashreport.c",
    "lines": "96-292",
    "snippet": "static int afc_client_copy_and_remove_crash_reports(afc_client_t afc, const char* device_directory, const char* host_directory)\n{\n\tafc_error_t afc_error;\n\tint k;\n\tint res = -1;\n\tint crash_report_count = 0;\n\tuint64_t handle;\n\tchar source_filename[512];\n\tchar target_filename[512];\n\n\tif (!afc)\n\t\treturn res;\n\n\tchar** list = NULL;\n\tafc_error = afc_read_directory(afc, device_directory, &list);\n\tif (afc_error != AFC_E_SUCCESS) {\n\t\tfprintf(stderr, \"ERROR: Could not read device directory '%s'\\n\", device_directory);\n\t\treturn res;\n\t}\n\n\t/* ensure we have a trailing slash */\n\tstrcpy(source_filename, device_directory);\n\tif (source_filename[strlen(source_filename)-1] != '/') {\n\t\tstrcat(source_filename, \"/\");\n\t}\n\tint device_directory_length = strlen(source_filename);\n\n\t/* ensure we have a trailing slash */\n\tstrcpy(target_filename, host_directory);\n\tif (target_filename[strlen(target_filename)-1] != '/') {\n\t\tstrcat(target_filename, \"/\");\n\t}\n\tint host_directory_length = strlen(target_filename);\n\n\t/* loop over file entries */\n\tfor (k = 0; list[k]; k++) {\n\t\tif (!strcmp(list[k], \".\") || !strcmp(list[k], \"..\")) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tchar **fileinfo = NULL;\n\t\tstruct stat stbuf;\n\t\tstbuf.st_size = 0;\n\n\t\t/* assemble absolute source filename */\n\t\tstrcpy(((char*)source_filename) + device_directory_length, list[k]);\n\n\t\t/* assemble absolute target filename */\n\t\tchar* p = strrchr(list[k], '.');\n\t\tif (p != NULL && !strncmp(p, \".synced\", 7)) {\n\t\t\t/* make sure to strip \".synced\" extension as seen on iOS 5 */\n\t\t\tint newlen = strlen(list[k]) - 7;\n\t\t\tstrncpy(((char*)target_filename) + host_directory_length, list[k], newlen);\n\t\t\ttarget_filename[host_directory_length + newlen] = '\\0';\n\t\t} else {\n\t\t\tstrcpy(((char*)target_filename) + host_directory_length, list[k]);\n\t\t}\n\n\t\t/* get file information */\n\t\tafc_get_file_info(afc, source_filename, &fileinfo);\n\t\tif (!fileinfo) {\n\t\t\tprintf(\"Failed to read information for '%s'. Skipping...\\n\", source_filename);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* parse file information */\n\t\tint i;\n\t\tfor (i = 0; fileinfo[i]; i+=2) {\n\t\t\tif (!strcmp(fileinfo[i], \"st_size\")) {\n\t\t\t\tstbuf.st_size = atoll(fileinfo[i+1]);\n\t\t\t} else if (!strcmp(fileinfo[i], \"st_ifmt\")) {\n\t\t\t\tif (!strcmp(fileinfo[i+1], \"S_IFREG\")) {\n\t\t\t\t\tstbuf.st_mode = S_IFREG;\n\t\t\t\t} else if (!strcmp(fileinfo[i+1], \"S_IFDIR\")) {\n\t\t\t\t\tstbuf.st_mode = S_IFDIR;\n\t\t\t\t} else if (!strcmp(fileinfo[i+1], \"S_IFLNK\")) {\n\t\t\t\t\tstbuf.st_mode = S_IFLNK;\n\t\t\t\t} else if (!strcmp(fileinfo[i+1], \"S_IFBLK\")) {\n\t\t\t\t\tstbuf.st_mode = S_IFBLK;\n\t\t\t\t} else if (!strcmp(fileinfo[i+1], \"S_IFCHR\")) {\n\t\t\t\t\tstbuf.st_mode = S_IFCHR;\n\t\t\t\t} else if (!strcmp(fileinfo[i+1], \"S_IFIFO\")) {\n\t\t\t\t\tstbuf.st_mode = S_IFIFO;\n\t\t\t\t} else if (!strcmp(fileinfo[i+1], \"S_IFSOCK\")) {\n\t\t\t\t\tstbuf.st_mode = S_IFSOCK;\n\t\t\t\t}\n\t\t\t} else if (!strcmp(fileinfo[i], \"st_nlink\")) {\n\t\t\t\tstbuf.st_nlink = atoi(fileinfo[i+1]);\n\t\t\t} else if (!strcmp(fileinfo[i], \"st_mtime\")) {\n\t\t\t\tstbuf.st_mtime = (time_t)(atoll(fileinfo[i+1]) / 1000000000);\n\t\t\t} else if (!strcmp(fileinfo[i], \"LinkTarget\")) {\n\t\t\t\t/* report latest crash report filename */\n\t\t\t\tprintf(\"Link: %s\\n\", (char*)target_filename + strlen(target_directory));\n\n\t\t\t\t/* remove any previous symlink */\n\t\t\t\tif (file_exists(target_filename)) {\n\t\t\t\t\tremove(target_filename);\n\t\t\t\t}\n\n#ifndef WIN32\n\t\t\t\t/* use relative filename */\n\t\t\t\tchar* b = strrchr(fileinfo[i+1], '/');\n\t\t\t\tif (b == NULL) {\n\t\t\t\t\tb = fileinfo[i+1];\n\t\t\t\t} else {\n\t\t\t\t\tb++;\n\t\t\t\t}\n\n\t\t\t\t/* create a symlink pointing to latest log */\n\t\t\t\tif (symlink(b, target_filename) < 0) {\n\t\t\t\t\tfprintf(stderr, \"Can't create symlink to %s\\n\", b);\n\t\t\t\t}\n#endif\n\n\t\t\t\tif (!keep_crash_reports)\n\t\t\t\t\tafc_remove_path(afc, source_filename);\n\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t}\n\n\t\t/* free file information */\n\t\tafc_dictionary_free(fileinfo);\n\n\t\t/* recurse into child directories */\n\t\tif (S_ISDIR(stbuf.st_mode)) {\n#ifdef WIN32\n\t\t\tmkdir(target_filename);\n#else\n\t\t\tmkdir(target_filename, 0755);\n#endif\n\t\t\tres = afc_client_copy_and_remove_crash_reports(afc, source_filename, target_filename);\n\n\t\t\t/* remove directory from device */\n\t\t\tif (!keep_crash_reports)\n\t\t\t\tafc_remove_path(afc, source_filename);\n\t\t} else if (S_ISREG(stbuf.st_mode)) {\n\t\t\t/* copy file to host */\n\t\t\tafc_error = afc_file_open(afc, source_filename, AFC_FOPEN_RDONLY, &handle);\n\t\t\tif(afc_error != AFC_E_SUCCESS) {\n\t\t\t\tif (afc_error == AFC_E_OBJECT_NOT_FOUND) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"Unable to open device file '%s' (%d). Skipping...\\n\", source_filename, afc_error);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tFILE* output = fopen(target_filename, \"wb\");\n\t\t\tif(output == NULL) {\n\t\t\t\tfprintf(stderr, \"Unable to open local file '%s'. Skipping...\\n\", target_filename);\n\t\t\t\tafc_file_close(afc, handle);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tprintf(\"%s: %s\\n\", (keep_crash_reports ? \"Copy\": \"Move\") , (char*)target_filename + strlen(target_directory));\n\n\t\t\tuint32_t bytes_read = 0;\n\t\t\tuint32_t bytes_total = 0;\n\t\t\tunsigned char data[0x1000];\n\n\t\t\tafc_error = afc_file_read(afc, handle, (char*)data, 0x1000, &bytes_read);\n\t\t\twhile(afc_error == AFC_E_SUCCESS && bytes_read > 0) {\n\t\t\t\tfwrite(data, 1, bytes_read, output);\n\t\t\t\tbytes_total += bytes_read;\n\t\t\t\tafc_error = afc_file_read(afc, handle, (char*)data, 0x1000, &bytes_read);\n\t\t\t}\n\t\t\tafc_file_close(afc, handle);\n\t\t\tfclose(output);\n\n\t\t\tif ((uint32_t)stbuf.st_size != bytes_total) {\n\t\t\t\tfprintf(stderr, \"File size mismatch. Skipping...\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* remove file from device */\n\t\t\tif (!keep_crash_reports) {\n\t\t\t\tafc_remove_path(afc, source_filename);\n\t\t\t}\n\n\t\t\t/* extract raw crash information into separate '.crash' file */\n\t\t\tif (extract_raw_crash_reports) {\n\t\t\t\textract_raw_crash_report(target_filename);\n\t\t\t}\n\n\t\t\tcrash_report_count++;\n\n\t\t\tres = 0;\n\t\t}\n\t}\n\tafc_dictionary_free(list);\n\n\t/* no reports, no error */\n\tif (crash_report_count == 0)\n\t\tres = 0;\n\n\treturn res;\n}",
    "includes": [
      "#include <windows.h>",
      "#include <plist/plist.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/afc.h>",
      "#include \"common/utils.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define S_IFSOCK S_IFREG",
      "#define S_IFLNK S_IFREG"
    ],
    "globals_used": [
      "const char* target_directory = NULL;",
      "static int extract_raw_crash_reports = 0;",
      "static int keep_crash_reports = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "afc_dictionary_free",
          "args": [
            "list"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "afc_dictionary_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "1025-1038",
          "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_dictionary_free(char **dictionary)\n{\n\tint i = 0;\n\n\tif (!dictionary)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tfor (i = 0; dictionary[i]; i++) {\n\t\tfree(dictionary[i]);\n\t}\n\tfree(dictionary);\n\n\treturn AFC_E_SUCCESS;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_dictionary_free(char **dictionary)\n{\n\tint i = 0;\n\n\tif (!dictionary)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tfor (i = 0; dictionary[i]; i++) {\n\t\tfree(dictionary[i]);\n\t}\n\tfree(dictionary);\n\n\treturn AFC_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "extract_raw_crash_report",
          "args": [
            "target_filename"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "extract_raw_crash_report",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicecrashreport.c",
          "lines": "58-94",
          "snippet": "static int extract_raw_crash_report(const char* filename) {\n\tint res = 0;\n\tplist_t report = NULL;\n\tchar* raw = NULL;\n\tchar* raw_filename = strdup(filename);\n\n\t/* create filename with '.crash' extension */\n\tchar* p = strrchr(raw_filename, '.');\n\tif ((p == NULL) || (strcmp(p, \".plist\") != 0)) {\n\t\tfree(raw_filename);\n\t\treturn res;\n\t}\n\tstrcpy(p, \".crash\");\n\n\t/* read plist crash report */\n\tif (plist_read_from_filename(&report, filename)) {\n\t\tplist_t description_node = plist_dict_get_item(report, \"description\");\n\t\tif (description_node && plist_get_node_type(description_node) == PLIST_STRING) {\n\t\t\tplist_get_string_val(description_node, &raw);\n\n\t\t\tif (raw != NULL) {\n\t\t\t\t/* write file */\n\t\t\t\tbuffer_write_to_filename(raw_filename, raw, strlen(raw));\n\t\t\t\tfree(raw);\n\t\t\t\tres = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (report)\n\t\tplist_free(report);\n\n\tif (raw_filename)\n\t\tfree(raw_filename);\n\n\treturn res;\n}",
          "includes": [
            "#include <windows.h>",
            "#include <plist/plist.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/afc.h>",
            "#include \"common/utils.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include <plist/plist.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/afc.h>\n#include \"common/utils.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int extract_raw_crash_report(const char* filename) {\n\tint res = 0;\n\tplist_t report = NULL;\n\tchar* raw = NULL;\n\tchar* raw_filename = strdup(filename);\n\n\t/* create filename with '.crash' extension */\n\tchar* p = strrchr(raw_filename, '.');\n\tif ((p == NULL) || (strcmp(p, \".plist\") != 0)) {\n\t\tfree(raw_filename);\n\t\treturn res;\n\t}\n\tstrcpy(p, \".crash\");\n\n\t/* read plist crash report */\n\tif (plist_read_from_filename(&report, filename)) {\n\t\tplist_t description_node = plist_dict_get_item(report, \"description\");\n\t\tif (description_node && plist_get_node_type(description_node) == PLIST_STRING) {\n\t\t\tplist_get_string_val(description_node, &raw);\n\n\t\t\tif (raw != NULL) {\n\t\t\t\t/* write file */\n\t\t\t\tbuffer_write_to_filename(raw_filename, raw, strlen(raw));\n\t\t\t\tfree(raw);\n\t\t\t\tres = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (report)\n\t\tplist_free(report);\n\n\tif (raw_filename)\n\t\tfree(raw_filename);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afc_remove_path",
          "args": [
            "afc",
            "source_filename"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "afc_remove_path_and_contents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "1001-1023",
          "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_remove_path_and_contents(afc_client_t client, const char *path)\n{\n\tuint32_t bytes = 0;\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tif (!client || !path || !client->afc_packet || !client->parent)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_lock(client);\n\n\t/* Send command */\n\tret = afc_dispatch_packet(client, AFC_OP_REMOVE_PATH_AND_CONTENTS, path, strlen(path)+1, NULL, 0, &bytes);\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\t/* Receive response */\n\tret = afc_receive_data(client, NULL, &bytes);\n\n\tafc_unlock(client);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_remove_path_and_contents(afc_client_t client, const char *path)\n{\n\tuint32_t bytes = 0;\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tif (!client || !path || !client->afc_packet || !client->parent)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_lock(client);\n\n\t/* Send command */\n\tret = afc_dispatch_packet(client, AFC_OP_REMOVE_PATH_AND_CONTENTS, path, strlen(path)+1, NULL, 0, &bytes);\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\t/* Receive response */\n\tret = afc_receive_data(client, NULL, &bytes);\n\n\tafc_unlock(client);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"File size mismatch. Skipping...\\n\""
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "output"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afc_file_close",
          "args": [
            "afc",
            "handle"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "afc_file_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "749-775",
          "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_file_close(afc_client_t client, uint64_t handle)\n{\n\tuint32_t bytes = 0;\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tif (!client || (handle == 0))\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_lock(client);\n\n\tdebug_info(\"File handle %i\", handle);\n\n\t/* Send command */\n\tret = afc_dispatch_packet(client, AFC_OP_FILE_CLOSE, (const char*)&handle, 8, NULL, 0, &bytes);\n\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_UNKNOWN_ERROR;\n\t}\n\n\t/* Receive the response */\n\tret = afc_receive_data(client, NULL, &bytes);\n\n\tafc_unlock(client);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_file_close(afc_client_t client, uint64_t handle)\n{\n\tuint32_t bytes = 0;\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tif (!client || (handle == 0))\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_lock(client);\n\n\tdebug_info(\"File handle %i\", handle);\n\n\t/* Send command */\n\tret = afc_dispatch_packet(client, AFC_OP_FILE_CLOSE, (const char*)&handle, 8, NULL, 0, &bytes);\n\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_UNKNOWN_ERROR;\n\t}\n\n\t/* Receive the response */\n\tret = afc_receive_data(client, NULL, &bytes);\n\n\tafc_unlock(client);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afc_file_read",
          "args": [
            "afc",
            "handle",
            "(char*)data",
            "0x1000",
            "&bytes_read"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "afc_file_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "664-715",
          "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_file_read(afc_client_t client, uint64_t handle, char *data, uint32_t length, uint32_t *bytes_read)\n{\n\tchar *input = NULL;\n\tuint32_t current_count = 0, bytes_loc = 0;\n\tafc_error_t ret = AFC_E_SUCCESS;\n\n\tif (!client || !client->afc_packet || !client->parent || handle == 0)\n\t\treturn AFC_E_INVALID_ARG;\n\tdebug_info(\"called for length %i\", length);\n\n\tafc_lock(client);\n\n\t/* Send the read command */\n\tstruct {\n\t\tuint64_t handle;\n\t\tuint64_t size;\n\t} readinfo;\n\treadinfo.handle = handle;\n\treadinfo.size = htole64(length);\n\tret = afc_dispatch_packet(client, AFC_OP_FILE_READ, (const char*)&readinfo, sizeof(readinfo), NULL, 0, &bytes_loc);\n\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\t/* Receive the data */\n\tret = afc_receive_data(client, &input, &bytes_loc);\n\tdebug_info(\"afc_receive_data returned error: %d\", ret);\n\tdebug_info(\"bytes returned: %i\", bytes_loc);\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn ret;\n\t} else if (bytes_loc == 0) {\n\t\tif (input)\n\t\t\tfree(input);\n\t\tafc_unlock(client);\n\t\t*bytes_read = current_count;\n\t\t/* FIXME: check that's actually a success */\n\t\treturn ret;\n\t} else {\n\t\tif (input) {\n\t\t\tdebug_info(\"%d\", bytes_loc);\n\t\t\tmemcpy(data + current_count, input, (bytes_loc > length) ? length : bytes_loc);\n\t\t\tfree(input);\n\t\t\tinput = NULL;\n\t\t\tcurrent_count += (bytes_loc > length) ? length : bytes_loc;\n\t\t}\n\t}\n\tafc_unlock(client);\n\t*bytes_read = current_count;\n\treturn ret;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_file_read(afc_client_t client, uint64_t handle, char *data, uint32_t length, uint32_t *bytes_read)\n{\n\tchar *input = NULL;\n\tuint32_t current_count = 0, bytes_loc = 0;\n\tafc_error_t ret = AFC_E_SUCCESS;\n\n\tif (!client || !client->afc_packet || !client->parent || handle == 0)\n\t\treturn AFC_E_INVALID_ARG;\n\tdebug_info(\"called for length %i\", length);\n\n\tafc_lock(client);\n\n\t/* Send the read command */\n\tstruct {\n\t\tuint64_t handle;\n\t\tuint64_t size;\n\t} readinfo;\n\treadinfo.handle = handle;\n\treadinfo.size = htole64(length);\n\tret = afc_dispatch_packet(client, AFC_OP_FILE_READ, (const char*)&readinfo, sizeof(readinfo), NULL, 0, &bytes_loc);\n\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\t/* Receive the data */\n\tret = afc_receive_data(client, &input, &bytes_loc);\n\tdebug_info(\"afc_receive_data returned error: %d\", ret);\n\tdebug_info(\"bytes returned: %i\", bytes_loc);\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn ret;\n\t} else if (bytes_loc == 0) {\n\t\tif (input)\n\t\t\tfree(input);\n\t\tafc_unlock(client);\n\t\t*bytes_read = current_count;\n\t\t/* FIXME: check that's actually a success */\n\t\treturn ret;\n\t} else {\n\t\tif (input) {\n\t\t\tdebug_info(\"%d\", bytes_loc);\n\t\t\tmemcpy(data + current_count, input, (bytes_loc > length) ? length : bytes_loc);\n\t\t\tfree(input);\n\t\t\tinput = NULL;\n\t\t\tcurrent_count += (bytes_loc > length) ? length : bytes_loc;\n\t\t}\n\t}\n\tafc_unlock(client);\n\t*bytes_read = current_count;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fwrite",
          "args": [
            "data",
            "1",
            "bytes_read",
            "output"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: %s\\n\"",
            "(keep_crash_reports ? \"Copy\": \"Move\")",
            "(char*)target_filename + strlen(target_directory)"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "asprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/include/asprintf.h",
          "lines": "23-31",
          "snippet": "static inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}",
          "includes": [
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <config.h>\n\nstatic inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "target_directory"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Unable to open local file '%s'. Skipping...\\n\"",
            "target_filename"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "target_filename",
            "\"wb\""
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Unable to open device file '%s' (%d). Skipping...\\n\"",
            "source_filename",
            "afc_error"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afc_file_open",
          "args": [
            "afc",
            "source_filename",
            "AFC_FOPEN_RDONLY",
            "&handle"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "afc_file_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "616-662",
          "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_file_open(afc_client_t client, const char *filename, afc_file_mode_t file_mode, uint64_t *handle)\n{\n\tif (!client || !client->parent || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tuint64_t file_mode_loc = htole64(file_mode);\n\tuint32_t bytes = 0;\n\tchar *data = (char *) malloc(sizeof(char) * (8 + strlen(filename) + 1));\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\t/* set handle to 0 so in case an error occurs, the handle is invalid */\n\t*handle = 0;\n\n\tafc_lock(client);\n\n\t/* Send command */\n\tmemcpy(data, &file_mode_loc, 8);\n\tmemcpy(data + 8, filename, strlen(filename));\n\tdata[8 + strlen(filename)] = '\\0';\n\tret = afc_dispatch_packet(client, AFC_OP_FILE_OPEN, data, 8 + strlen(filename) + 1, NULL, 0, &bytes);\n\tfree(data);\n\n\tif (ret != AFC_E_SUCCESS) {\n\t\tdebug_info(\"Didn't receive a response to the command\");\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\t/* Receive the data */\n\tdata = NULL;\n\tret = afc_receive_data(client, &data, &bytes);\n\tif ((ret == AFC_E_SUCCESS) && (bytes > 0) && data) {\n\t\tafc_unlock(client);\n\n\t\t/* Get the file handle */\n\t\tmemcpy(handle, data, sizeof(uint64_t));\n\t\tfree(data);\n\t\treturn ret;\n\t}\n\t/* in case memory was allocated but no data received or an error occurred */\n\tfree(data);\n\n\tdebug_info(\"Didn't get any further data\");\n\n\tafc_unlock(client);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_file_open(afc_client_t client, const char *filename, afc_file_mode_t file_mode, uint64_t *handle)\n{\n\tif (!client || !client->parent || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tuint64_t file_mode_loc = htole64(file_mode);\n\tuint32_t bytes = 0;\n\tchar *data = (char *) malloc(sizeof(char) * (8 + strlen(filename) + 1));\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\t/* set handle to 0 so in case an error occurs, the handle is invalid */\n\t*handle = 0;\n\n\tafc_lock(client);\n\n\t/* Send command */\n\tmemcpy(data, &file_mode_loc, 8);\n\tmemcpy(data + 8, filename, strlen(filename));\n\tdata[8 + strlen(filename)] = '\\0';\n\tret = afc_dispatch_packet(client, AFC_OP_FILE_OPEN, data, 8 + strlen(filename) + 1, NULL, 0, &bytes);\n\tfree(data);\n\n\tif (ret != AFC_E_SUCCESS) {\n\t\tdebug_info(\"Didn't receive a response to the command\");\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\t/* Receive the data */\n\tdata = NULL;\n\tret = afc_receive_data(client, &data, &bytes);\n\tif ((ret == AFC_E_SUCCESS) && (bytes > 0) && data) {\n\t\tafc_unlock(client);\n\n\t\t/* Get the file handle */\n\t\tmemcpy(handle, data, sizeof(uint64_t));\n\t\tfree(data);\n\t\treturn ret;\n\t}\n\t/* in case memory was allocated but no data received or an error occurred */\n\tfree(data);\n\n\tdebug_info(\"Didn't get any further data\");\n\n\tafc_unlock(client);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "stbuf.st_mode"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afc_client_copy_and_remove_crash_reports",
          "args": [
            "afc",
            "source_filename",
            "target_filename"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "afc_client_copy_and_remove_crash_reports",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicecrashreport.c",
          "lines": "96-292",
          "snippet": "static int afc_client_copy_and_remove_crash_reports(afc_client_t afc, const char* device_directory, const char* host_directory)\n{\n\tafc_error_t afc_error;\n\tint k;\n\tint res = -1;\n\tint crash_report_count = 0;\n\tuint64_t handle;\n\tchar source_filename[512];\n\tchar target_filename[512];\n\n\tif (!afc)\n\t\treturn res;\n\n\tchar** list = NULL;\n\tafc_error = afc_read_directory(afc, device_directory, &list);\n\tif (afc_error != AFC_E_SUCCESS) {\n\t\tfprintf(stderr, \"ERROR: Could not read device directory '%s'\\n\", device_directory);\n\t\treturn res;\n\t}\n\n\t/* ensure we have a trailing slash */\n\tstrcpy(source_filename, device_directory);\n\tif (source_filename[strlen(source_filename)-1] != '/') {\n\t\tstrcat(source_filename, \"/\");\n\t}\n\tint device_directory_length = strlen(source_filename);\n\n\t/* ensure we have a trailing slash */\n\tstrcpy(target_filename, host_directory);\n\tif (target_filename[strlen(target_filename)-1] != '/') {\n\t\tstrcat(target_filename, \"/\");\n\t}\n\tint host_directory_length = strlen(target_filename);\n\n\t/* loop over file entries */\n\tfor (k = 0; list[k]; k++) {\n\t\tif (!strcmp(list[k], \".\") || !strcmp(list[k], \"..\")) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tchar **fileinfo = NULL;\n\t\tstruct stat stbuf;\n\t\tstbuf.st_size = 0;\n\n\t\t/* assemble absolute source filename */\n\t\tstrcpy(((char*)source_filename) + device_directory_length, list[k]);\n\n\t\t/* assemble absolute target filename */\n\t\tchar* p = strrchr(list[k], '.');\n\t\tif (p != NULL && !strncmp(p, \".synced\", 7)) {\n\t\t\t/* make sure to strip \".synced\" extension as seen on iOS 5 */\n\t\t\tint newlen = strlen(list[k]) - 7;\n\t\t\tstrncpy(((char*)target_filename) + host_directory_length, list[k], newlen);\n\t\t\ttarget_filename[host_directory_length + newlen] = '\\0';\n\t\t} else {\n\t\t\tstrcpy(((char*)target_filename) + host_directory_length, list[k]);\n\t\t}\n\n\t\t/* get file information */\n\t\tafc_get_file_info(afc, source_filename, &fileinfo);\n\t\tif (!fileinfo) {\n\t\t\tprintf(\"Failed to read information for '%s'. Skipping...\\n\", source_filename);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* parse file information */\n\t\tint i;\n\t\tfor (i = 0; fileinfo[i]; i+=2) {\n\t\t\tif (!strcmp(fileinfo[i], \"st_size\")) {\n\t\t\t\tstbuf.st_size = atoll(fileinfo[i+1]);\n\t\t\t} else if (!strcmp(fileinfo[i], \"st_ifmt\")) {\n\t\t\t\tif (!strcmp(fileinfo[i+1], \"S_IFREG\")) {\n\t\t\t\t\tstbuf.st_mode = S_IFREG;\n\t\t\t\t} else if (!strcmp(fileinfo[i+1], \"S_IFDIR\")) {\n\t\t\t\t\tstbuf.st_mode = S_IFDIR;\n\t\t\t\t} else if (!strcmp(fileinfo[i+1], \"S_IFLNK\")) {\n\t\t\t\t\tstbuf.st_mode = S_IFLNK;\n\t\t\t\t} else if (!strcmp(fileinfo[i+1], \"S_IFBLK\")) {\n\t\t\t\t\tstbuf.st_mode = S_IFBLK;\n\t\t\t\t} else if (!strcmp(fileinfo[i+1], \"S_IFCHR\")) {\n\t\t\t\t\tstbuf.st_mode = S_IFCHR;\n\t\t\t\t} else if (!strcmp(fileinfo[i+1], \"S_IFIFO\")) {\n\t\t\t\t\tstbuf.st_mode = S_IFIFO;\n\t\t\t\t} else if (!strcmp(fileinfo[i+1], \"S_IFSOCK\")) {\n\t\t\t\t\tstbuf.st_mode = S_IFSOCK;\n\t\t\t\t}\n\t\t\t} else if (!strcmp(fileinfo[i], \"st_nlink\")) {\n\t\t\t\tstbuf.st_nlink = atoi(fileinfo[i+1]);\n\t\t\t} else if (!strcmp(fileinfo[i], \"st_mtime\")) {\n\t\t\t\tstbuf.st_mtime = (time_t)(atoll(fileinfo[i+1]) / 1000000000);\n\t\t\t} else if (!strcmp(fileinfo[i], \"LinkTarget\")) {\n\t\t\t\t/* report latest crash report filename */\n\t\t\t\tprintf(\"Link: %s\\n\", (char*)target_filename + strlen(target_directory));\n\n\t\t\t\t/* remove any previous symlink */\n\t\t\t\tif (file_exists(target_filename)) {\n\t\t\t\t\tremove(target_filename);\n\t\t\t\t}\n\n#ifndef WIN32\n\t\t\t\t/* use relative filename */\n\t\t\t\tchar* b = strrchr(fileinfo[i+1], '/');\n\t\t\t\tif (b == NULL) {\n\t\t\t\t\tb = fileinfo[i+1];\n\t\t\t\t} else {\n\t\t\t\t\tb++;\n\t\t\t\t}\n\n\t\t\t\t/* create a symlink pointing to latest log */\n\t\t\t\tif (symlink(b, target_filename) < 0) {\n\t\t\t\t\tfprintf(stderr, \"Can't create symlink to %s\\n\", b);\n\t\t\t\t}\n#endif\n\n\t\t\t\tif (!keep_crash_reports)\n\t\t\t\t\tafc_remove_path(afc, source_filename);\n\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t}\n\n\t\t/* free file information */\n\t\tafc_dictionary_free(fileinfo);\n\n\t\t/* recurse into child directories */\n\t\tif (S_ISDIR(stbuf.st_mode)) {\n#ifdef WIN32\n\t\t\tmkdir(target_filename);\n#else\n\t\t\tmkdir(target_filename, 0755);\n#endif\n\t\t\tres = afc_client_copy_and_remove_crash_reports(afc, source_filename, target_filename);\n\n\t\t\t/* remove directory from device */\n\t\t\tif (!keep_crash_reports)\n\t\t\t\tafc_remove_path(afc, source_filename);\n\t\t} else if (S_ISREG(stbuf.st_mode)) {\n\t\t\t/* copy file to host */\n\t\t\tafc_error = afc_file_open(afc, source_filename, AFC_FOPEN_RDONLY, &handle);\n\t\t\tif(afc_error != AFC_E_SUCCESS) {\n\t\t\t\tif (afc_error == AFC_E_OBJECT_NOT_FOUND) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"Unable to open device file '%s' (%d). Skipping...\\n\", source_filename, afc_error);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tFILE* output = fopen(target_filename, \"wb\");\n\t\t\tif(output == NULL) {\n\t\t\t\tfprintf(stderr, \"Unable to open local file '%s'. Skipping...\\n\", target_filename);\n\t\t\t\tafc_file_close(afc, handle);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tprintf(\"%s: %s\\n\", (keep_crash_reports ? \"Copy\": \"Move\") , (char*)target_filename + strlen(target_directory));\n\n\t\t\tuint32_t bytes_read = 0;\n\t\t\tuint32_t bytes_total = 0;\n\t\t\tunsigned char data[0x1000];\n\n\t\t\tafc_error = afc_file_read(afc, handle, (char*)data, 0x1000, &bytes_read);\n\t\t\twhile(afc_error == AFC_E_SUCCESS && bytes_read > 0) {\n\t\t\t\tfwrite(data, 1, bytes_read, output);\n\t\t\t\tbytes_total += bytes_read;\n\t\t\t\tafc_error = afc_file_read(afc, handle, (char*)data, 0x1000, &bytes_read);\n\t\t\t}\n\t\t\tafc_file_close(afc, handle);\n\t\t\tfclose(output);\n\n\t\t\tif ((uint32_t)stbuf.st_size != bytes_total) {\n\t\t\t\tfprintf(stderr, \"File size mismatch. Skipping...\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* remove file from device */\n\t\t\tif (!keep_crash_reports) {\n\t\t\t\tafc_remove_path(afc, source_filename);\n\t\t\t}\n\n\t\t\t/* extract raw crash information into separate '.crash' file */\n\t\t\tif (extract_raw_crash_reports) {\n\t\t\t\textract_raw_crash_report(target_filename);\n\t\t\t}\n\n\t\t\tcrash_report_count++;\n\n\t\t\tres = 0;\n\t\t}\n\t}\n\tafc_dictionary_free(list);\n\n\t/* no reports, no error */\n\tif (crash_report_count == 0)\n\t\tres = 0;\n\n\treturn res;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "target_filename",
            "0755"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir_with_parents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
          "lines": "172-193",
          "snippet": "static int mkdir_with_parents(const char *dir, int mode)\n{\n\tif (!dir) return -1;\n\tif (__mkdir(dir, mode) == 0) {\n\t\treturn 0;\n\t} else {\n\t\tif (errno == EEXIST) return 0;\n\t}\n\tint res;\n\tchar *parent = strdup(dir);\n\tchar *parentdir = dirname(parent);\n\tif (parentdir) {\n\t\tres = mkdir_with_parents(parentdir, mode);\n\t} else {\n\t\tres = -1;\n\t}\n\tfree(parent);\n\tif (res == 0) {\n\t\tmkdir_with_parents(dir, mode);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <sys/statvfs.h>",
            "#include <termios.h>",
            "#include <conio.h>",
            "#include <windows.h>",
            "#include <endianness.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup2.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <libgen.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int mkdir_with_parents(const char *dir, int mode)\n{\n\tif (!dir) return -1;\n\tif (__mkdir(dir, mode) == 0) {\n\t\treturn 0;\n\t} else {\n\t\tif (errno == EEXIST) return 0;\n\t}\n\tint res;\n\tchar *parent = strdup(dir);\n\tchar *parentdir = dirname(parent);\n\tif (parentdir) {\n\t\tres = mkdir_with_parents(parentdir, mode);\n\t} else {\n\t\tres = -1;\n\t}\n\tfree(parent);\n\tif (res == 0) {\n\t\tmkdir_with_parents(dir, mode);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "target_filename"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "stbuf.st_mode"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Can't create symlink to %s\\n\"",
            "b"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "symlink",
          "args": [
            "b",
            "target_filename"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "fileinfo[i+1]",
            "'/'"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove",
          "args": [
            "target_filename"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "str_remove_spaces",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/lockdown.c",
          "lines": "1443-1453",
          "snippet": "static void str_remove_spaces(char *source)\n{\n\tchar *dest = source;\n\twhile (*source != 0) {\n\t\tif (!isspace(*source)) {\n\t\t\t*dest++ = *source; /* copy */\n\t\t}\n\t\tsource++;\n\t}\n\t*dest = 0;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/userpref.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"lockdown.h\"",
            "#include \"property_list_service.h\"",
            "#include <plist/plist.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/x509.h>",
            "#include <libtasn1.h>",
            "#include <openssl/x509v3.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/pem.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/userpref.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"lockdown.h\"\n#include \"property_list_service.h\"\n#include <plist/plist.h>\n#include <gnutls/crypto.h>\n#include <gnutls/x509.h>\n#include <libtasn1.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/pem.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nstatic void str_remove_spaces(char *source)\n{\n\tchar *dest = source;\n\twhile (*source != 0) {\n\t\tif (!isspace(*source)) {\n\t\t\t*dest++ = *source; /* copy */\n\t\t}\n\t\tsource++;\n\t}\n\t*dest = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_exists",
          "args": [
            "target_filename"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "file_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicecrashreport.c",
          "lines": "48-56",
          "snippet": "static int file_exists(const char* path)\n{\n\tstruct stat tst;\n#ifdef WIN32\n\treturn (stat(path, &tst) == 0);\n#else\n\treturn (lstat(path, &tst) == 0);\n#endif\n}",
          "includes": [
            "#include <windows.h>",
            "#include <plist/plist.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/afc.h>",
            "#include \"common/utils.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include <plist/plist.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/afc.h>\n#include \"common/utils.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int file_exists(const char* path)\n{\n\tstruct stat tst;\n#ifdef WIN32\n\treturn (stat(path, &tst) == 0);\n#else\n\treturn (lstat(path, &tst) == 0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "target_directory"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "fileinfo[i]",
            "\"LinkTarget\""
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "plist_strcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
          "lines": "296-309",
          "snippet": "static int plist_strcmp(plist_t node, const char *str)\n{\n\tchar *buffer = NULL;\n\tint ret = 0;\n\n\tif (plist_get_node_type(node) != PLIST_STRING)\n\t\treturn ret;\n\n\tplist_get_string_val(node, &buffer);\n\tret = strcmp(buffer, str);\n\tfree(buffer);\n\n\treturn ret;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <unistd.h>",
            "#include <gcrypt.h>",
            "#include <openssl/sha.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int plist_strcmp(plist_t node, const char *str)\n{\n\tchar *buffer = NULL;\n\tint ret = 0;\n\n\tif (plist_get_node_type(node) != PLIST_STRING)\n\t\treturn ret;\n\n\tplist_get_string_val(node, &buffer);\n\tret = strcmp(buffer, str);\n\tfree(buffer);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "atoll(fileinfo[i+1]) / 1000000000"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoll",
          "args": [
            "fileinfo[i+1]"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "fileinfo[i+1]"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoll",
          "args": [
            "fileinfo[i+1]"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afc_get_file_info",
          "args": [
            "afc",
            "source_filename",
            "&fileinfo"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "afc_get_file_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "586-614",
          "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_get_file_info(afc_client_t client, const char *path, char ***file_information)\n{\n\tchar *received = NULL;\n\tuint32_t bytes = 0;\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tif (!client || !path || !file_information)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_lock(client);\n\n\t/* Send command */\n\tret = afc_dispatch_packet(client, AFC_OP_GET_FILE_INFO, path, strlen(path)+1, NULL, 0, &bytes);\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\n\t/* Receive data */\n\tret = afc_receive_data(client, &received, &bytes);\n\tif (received) {\n\t\t*file_information = make_strings_list(received, bytes);\n\t\tfree(received);\n\t}\n\n\tafc_unlock(client);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_get_file_info(afc_client_t client, const char *path, char ***file_information)\n{\n\tchar *received = NULL;\n\tuint32_t bytes = 0;\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tif (!client || !path || !file_information)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_lock(client);\n\n\t/* Send command */\n\tret = afc_dispatch_packet(client, AFC_OP_GET_FILE_INFO, path, strlen(path)+1, NULL, 0, &bytes);\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\n\t/* Receive data */\n\tret = afc_receive_data(client, &received, &bytes);\n\tif (received) {\n\t\t*file_information = make_strings_list(received, bytes);\n\t\tfree(received);\n\t}\n\n\tafc_unlock(client);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "((char*)target_filename) + host_directory_length",
            "list[k]"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "((char*)target_filename) + host_directory_length",
            "list[k]",
            "newlen"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "list[k]"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "p",
            "\".synced\"",
            "7"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "list[k]",
            "'.'"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "((char*)source_filename) + device_directory_length",
            "list[k]"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "target_filename"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "target_filename",
            "\"/\""
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "target_filename"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "target_filename",
            "host_directory"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "source_filename"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "source_filename",
            "\"/\""
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "source_filename"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "source_filename",
            "device_directory"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"ERROR: Could not read device directory '%s'\\n\"",
            "device_directory"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afc_read_directory",
          "args": [
            "afc",
            "device_directory",
            "&list"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "afc_read_directory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "405-439",
          "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_read_directory(afc_client_t client, const char *path, char ***directory_information)\n{\n\tuint32_t bytes = 0;\n\tchar *data = NULL, **list_loc = NULL;\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tif (!client || !path || !directory_information || (directory_information && *directory_information))\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_lock(client);\n\n\t/* Send the command */\n\tret = afc_dispatch_packet(client, AFC_OP_READ_DIR, path, strlen(path)+1, NULL, 0, &bytes);\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\t/* Receive the data */\n\tret = afc_receive_data(client, &data, &bytes);\n\tif (ret != AFC_E_SUCCESS) {\n\t\tif (data)\n\t\t\tfree(data);\n\t\tafc_unlock(client);\n\t\treturn ret;\n\t}\n\t/* Parse the data */\n\tlist_loc = make_strings_list(data, bytes);\n\tif (data)\n\t\tfree(data);\n\n\tafc_unlock(client);\n\t*directory_information = list_loc;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_read_directory(afc_client_t client, const char *path, char ***directory_information)\n{\n\tuint32_t bytes = 0;\n\tchar *data = NULL, **list_loc = NULL;\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tif (!client || !path || !directory_information || (directory_information && *directory_information))\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_lock(client);\n\n\t/* Send the command */\n\tret = afc_dispatch_packet(client, AFC_OP_READ_DIR, path, strlen(path)+1, NULL, 0, &bytes);\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\t/* Receive the data */\n\tret = afc_receive_data(client, &data, &bytes);\n\tif (ret != AFC_E_SUCCESS) {\n\t\tif (data)\n\t\t\tfree(data);\n\t\tafc_unlock(client);\n\t\treturn ret;\n\t}\n\t/* Parse the data */\n\tlist_loc = make_strings_list(data, bytes);\n\tif (data)\n\t\tfree(data);\n\n\tafc_unlock(client);\n\t*directory_information = list_loc;\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include <plist/plist.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/afc.h>\n#include \"common/utils.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\n#define S_IFSOCK S_IFREG\n#define S_IFLNK S_IFREG\n\nconst char* target_directory = NULL;\nstatic int extract_raw_crash_reports = 0;\nstatic int keep_crash_reports = 0;\n\nstatic int afc_client_copy_and_remove_crash_reports(afc_client_t afc, const char* device_directory, const char* host_directory)\n{\n\tafc_error_t afc_error;\n\tint k;\n\tint res = -1;\n\tint crash_report_count = 0;\n\tuint64_t handle;\n\tchar source_filename[512];\n\tchar target_filename[512];\n\n\tif (!afc)\n\t\treturn res;\n\n\tchar** list = NULL;\n\tafc_error = afc_read_directory(afc, device_directory, &list);\n\tif (afc_error != AFC_E_SUCCESS) {\n\t\tfprintf(stderr, \"ERROR: Could not read device directory '%s'\\n\", device_directory);\n\t\treturn res;\n\t}\n\n\t/* ensure we have a trailing slash */\n\tstrcpy(source_filename, device_directory);\n\tif (source_filename[strlen(source_filename)-1] != '/') {\n\t\tstrcat(source_filename, \"/\");\n\t}\n\tint device_directory_length = strlen(source_filename);\n\n\t/* ensure we have a trailing slash */\n\tstrcpy(target_filename, host_directory);\n\tif (target_filename[strlen(target_filename)-1] != '/') {\n\t\tstrcat(target_filename, \"/\");\n\t}\n\tint host_directory_length = strlen(target_filename);\n\n\t/* loop over file entries */\n\tfor (k = 0; list[k]; k++) {\n\t\tif (!strcmp(list[k], \".\") || !strcmp(list[k], \"..\")) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tchar **fileinfo = NULL;\n\t\tstruct stat stbuf;\n\t\tstbuf.st_size = 0;\n\n\t\t/* assemble absolute source filename */\n\t\tstrcpy(((char*)source_filename) + device_directory_length, list[k]);\n\n\t\t/* assemble absolute target filename */\n\t\tchar* p = strrchr(list[k], '.');\n\t\tif (p != NULL && !strncmp(p, \".synced\", 7)) {\n\t\t\t/* make sure to strip \".synced\" extension as seen on iOS 5 */\n\t\t\tint newlen = strlen(list[k]) - 7;\n\t\t\tstrncpy(((char*)target_filename) + host_directory_length, list[k], newlen);\n\t\t\ttarget_filename[host_directory_length + newlen] = '\\0';\n\t\t} else {\n\t\t\tstrcpy(((char*)target_filename) + host_directory_length, list[k]);\n\t\t}\n\n\t\t/* get file information */\n\t\tafc_get_file_info(afc, source_filename, &fileinfo);\n\t\tif (!fileinfo) {\n\t\t\tprintf(\"Failed to read information for '%s'. Skipping...\\n\", source_filename);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* parse file information */\n\t\tint i;\n\t\tfor (i = 0; fileinfo[i]; i+=2) {\n\t\t\tif (!strcmp(fileinfo[i], \"st_size\")) {\n\t\t\t\tstbuf.st_size = atoll(fileinfo[i+1]);\n\t\t\t} else if (!strcmp(fileinfo[i], \"st_ifmt\")) {\n\t\t\t\tif (!strcmp(fileinfo[i+1], \"S_IFREG\")) {\n\t\t\t\t\tstbuf.st_mode = S_IFREG;\n\t\t\t\t} else if (!strcmp(fileinfo[i+1], \"S_IFDIR\")) {\n\t\t\t\t\tstbuf.st_mode = S_IFDIR;\n\t\t\t\t} else if (!strcmp(fileinfo[i+1], \"S_IFLNK\")) {\n\t\t\t\t\tstbuf.st_mode = S_IFLNK;\n\t\t\t\t} else if (!strcmp(fileinfo[i+1], \"S_IFBLK\")) {\n\t\t\t\t\tstbuf.st_mode = S_IFBLK;\n\t\t\t\t} else if (!strcmp(fileinfo[i+1], \"S_IFCHR\")) {\n\t\t\t\t\tstbuf.st_mode = S_IFCHR;\n\t\t\t\t} else if (!strcmp(fileinfo[i+1], \"S_IFIFO\")) {\n\t\t\t\t\tstbuf.st_mode = S_IFIFO;\n\t\t\t\t} else if (!strcmp(fileinfo[i+1], \"S_IFSOCK\")) {\n\t\t\t\t\tstbuf.st_mode = S_IFSOCK;\n\t\t\t\t}\n\t\t\t} else if (!strcmp(fileinfo[i], \"st_nlink\")) {\n\t\t\t\tstbuf.st_nlink = atoi(fileinfo[i+1]);\n\t\t\t} else if (!strcmp(fileinfo[i], \"st_mtime\")) {\n\t\t\t\tstbuf.st_mtime = (time_t)(atoll(fileinfo[i+1]) / 1000000000);\n\t\t\t} else if (!strcmp(fileinfo[i], \"LinkTarget\")) {\n\t\t\t\t/* report latest crash report filename */\n\t\t\t\tprintf(\"Link: %s\\n\", (char*)target_filename + strlen(target_directory));\n\n\t\t\t\t/* remove any previous symlink */\n\t\t\t\tif (file_exists(target_filename)) {\n\t\t\t\t\tremove(target_filename);\n\t\t\t\t}\n\n#ifndef WIN32\n\t\t\t\t/* use relative filename */\n\t\t\t\tchar* b = strrchr(fileinfo[i+1], '/');\n\t\t\t\tif (b == NULL) {\n\t\t\t\t\tb = fileinfo[i+1];\n\t\t\t\t} else {\n\t\t\t\t\tb++;\n\t\t\t\t}\n\n\t\t\t\t/* create a symlink pointing to latest log */\n\t\t\t\tif (symlink(b, target_filename) < 0) {\n\t\t\t\t\tfprintf(stderr, \"Can't create symlink to %s\\n\", b);\n\t\t\t\t}\n#endif\n\n\t\t\t\tif (!keep_crash_reports)\n\t\t\t\t\tafc_remove_path(afc, source_filename);\n\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t}\n\n\t\t/* free file information */\n\t\tafc_dictionary_free(fileinfo);\n\n\t\t/* recurse into child directories */\n\t\tif (S_ISDIR(stbuf.st_mode)) {\n#ifdef WIN32\n\t\t\tmkdir(target_filename);\n#else\n\t\t\tmkdir(target_filename, 0755);\n#endif\n\t\t\tres = afc_client_copy_and_remove_crash_reports(afc, source_filename, target_filename);\n\n\t\t\t/* remove directory from device */\n\t\t\tif (!keep_crash_reports)\n\t\t\t\tafc_remove_path(afc, source_filename);\n\t\t} else if (S_ISREG(stbuf.st_mode)) {\n\t\t\t/* copy file to host */\n\t\t\tafc_error = afc_file_open(afc, source_filename, AFC_FOPEN_RDONLY, &handle);\n\t\t\tif(afc_error != AFC_E_SUCCESS) {\n\t\t\t\tif (afc_error == AFC_E_OBJECT_NOT_FOUND) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"Unable to open device file '%s' (%d). Skipping...\\n\", source_filename, afc_error);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tFILE* output = fopen(target_filename, \"wb\");\n\t\t\tif(output == NULL) {\n\t\t\t\tfprintf(stderr, \"Unable to open local file '%s'. Skipping...\\n\", target_filename);\n\t\t\t\tafc_file_close(afc, handle);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tprintf(\"%s: %s\\n\", (keep_crash_reports ? \"Copy\": \"Move\") , (char*)target_filename + strlen(target_directory));\n\n\t\t\tuint32_t bytes_read = 0;\n\t\t\tuint32_t bytes_total = 0;\n\t\t\tunsigned char data[0x1000];\n\n\t\t\tafc_error = afc_file_read(afc, handle, (char*)data, 0x1000, &bytes_read);\n\t\t\twhile(afc_error == AFC_E_SUCCESS && bytes_read > 0) {\n\t\t\t\tfwrite(data, 1, bytes_read, output);\n\t\t\t\tbytes_total += bytes_read;\n\t\t\t\tafc_error = afc_file_read(afc, handle, (char*)data, 0x1000, &bytes_read);\n\t\t\t}\n\t\t\tafc_file_close(afc, handle);\n\t\t\tfclose(output);\n\n\t\t\tif ((uint32_t)stbuf.st_size != bytes_total) {\n\t\t\t\tfprintf(stderr, \"File size mismatch. Skipping...\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* remove file from device */\n\t\t\tif (!keep_crash_reports) {\n\t\t\t\tafc_remove_path(afc, source_filename);\n\t\t\t}\n\n\t\t\t/* extract raw crash information into separate '.crash' file */\n\t\t\tif (extract_raw_crash_reports) {\n\t\t\t\textract_raw_crash_report(target_filename);\n\t\t\t}\n\n\t\t\tcrash_report_count++;\n\n\t\t\tres = 0;\n\t\t}\n\t}\n\tafc_dictionary_free(list);\n\n\t/* no reports, no error */\n\tif (crash_report_count == 0)\n\t\tres = 0;\n\n\treturn res;\n}"
  },
  {
    "function_name": "extract_raw_crash_report",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicecrashreport.c",
    "lines": "58-94",
    "snippet": "static int extract_raw_crash_report(const char* filename) {\n\tint res = 0;\n\tplist_t report = NULL;\n\tchar* raw = NULL;\n\tchar* raw_filename = strdup(filename);\n\n\t/* create filename with '.crash' extension */\n\tchar* p = strrchr(raw_filename, '.');\n\tif ((p == NULL) || (strcmp(p, \".plist\") != 0)) {\n\t\tfree(raw_filename);\n\t\treturn res;\n\t}\n\tstrcpy(p, \".crash\");\n\n\t/* read plist crash report */\n\tif (plist_read_from_filename(&report, filename)) {\n\t\tplist_t description_node = plist_dict_get_item(report, \"description\");\n\t\tif (description_node && plist_get_node_type(description_node) == PLIST_STRING) {\n\t\t\tplist_get_string_val(description_node, &raw);\n\n\t\t\tif (raw != NULL) {\n\t\t\t\t/* write file */\n\t\t\t\tbuffer_write_to_filename(raw_filename, raw, strlen(raw));\n\t\t\t\tfree(raw);\n\t\t\t\tres = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (report)\n\t\tplist_free(report);\n\n\tif (raw_filename)\n\t\tfree(raw_filename);\n\n\treturn res;\n}",
    "includes": [
      "#include <windows.h>",
      "#include <plist/plist.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/afc.h>",
      "#include \"common/utils.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "raw_filename"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "thread_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "39-44",
          "snippet": "void thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nvoid thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_free",
          "args": [
            "report"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_write_to_filename",
          "args": [
            "raw_filename",
            "raw",
            "strlen(raw)"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "buffer_write_to_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/utils.c",
          "lines": "234-243",
          "snippet": "void buffer_write_to_filename(const char *filename, const char *buffer, uint64_t length)\n{\n\tFILE *f;\n\n\tf = fopen(filename, \"wb\");\n\tif (f) {\n\t\tfwrite(buffer, sizeof(char), length, f);\n\t\tfclose(f);\n\t}\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include <ctype.h>",
            "#include <inttypes.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include <ctype.h>\n#include <inttypes.h>\n#include <sys/time.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <config.h>\n\nvoid buffer_write_to_filename(const char *filename, const char *buffer, uint64_t length)\n{\n\tFILE *f;\n\n\tf = fopen(filename, \"wb\");\n\tif (f) {\n\t\tfwrite(buffer, sizeof(char), length, f);\n\t\tfclose(f);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "raw"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_string_val",
          "args": [
            "description_node",
            "&raw"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_node_type",
          "args": [
            "description_node"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "report",
            "\"description\""
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_read_from_filename",
          "args": [
            "&report",
            "filename"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "plist_read_from_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/utils.c",
          "lines": "245-268",
          "snippet": "int plist_read_from_filename(plist_t *plist, const char *filename)\n{\n\tchar *buffer = NULL;\n\tuint64_t length;\n\n\tif (!filename)\n\t\treturn 0;\n\n\tbuffer_read_from_filename(filename, &buffer, &length);\n\n\tif (!buffer) {\n\t\treturn 0;\n\t}\n\n\tif ((length > 8) && (memcmp(buffer, \"bplist00\", 8) == 0)) {\n\t\tplist_from_bin(buffer, length, plist);\n\t} else {\n\t\tplist_from_xml(buffer, length, plist);\n\t}\n\n\tfree(buffer);\n\n\treturn 1;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include <ctype.h>",
            "#include <inttypes.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include <ctype.h>\n#include <inttypes.h>\n#include <sys/time.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <config.h>\n\nint plist_read_from_filename(plist_t *plist, const char *filename)\n{\n\tchar *buffer = NULL;\n\tuint64_t length;\n\n\tif (!filename)\n\t\treturn 0;\n\n\tbuffer_read_from_filename(filename, &buffer, &length);\n\n\tif (!buffer) {\n\t\treturn 0;\n\t}\n\n\tif ((length > 8) && (memcmp(buffer, \"bplist00\", 8) == 0)) {\n\t\tplist_from_bin(buffer, length, plist);\n\t} else {\n\t\tplist_from_xml(buffer, length, plist);\n\t}\n\n\tfree(buffer);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "p",
            "\".crash\""
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\".plist\""
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "plist_strcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
          "lines": "296-309",
          "snippet": "static int plist_strcmp(plist_t node, const char *str)\n{\n\tchar *buffer = NULL;\n\tint ret = 0;\n\n\tif (plist_get_node_type(node) != PLIST_STRING)\n\t\treturn ret;\n\n\tplist_get_string_val(node, &buffer);\n\tret = strcmp(buffer, str);\n\tfree(buffer);\n\n\treturn ret;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <unistd.h>",
            "#include <gcrypt.h>",
            "#include <openssl/sha.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int plist_strcmp(plist_t node, const char *str)\n{\n\tchar *buffer = NULL;\n\tint ret = 0;\n\n\tif (plist_get_node_type(node) != PLIST_STRING)\n\t\treturn ret;\n\n\tplist_get_string_val(node, &buffer);\n\tret = strcmp(buffer, str);\n\tfree(buffer);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "raw_filename",
            "'.'"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "filename"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include <plist/plist.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/afc.h>\n#include \"common/utils.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int extract_raw_crash_report(const char* filename) {\n\tint res = 0;\n\tplist_t report = NULL;\n\tchar* raw = NULL;\n\tchar* raw_filename = strdup(filename);\n\n\t/* create filename with '.crash' extension */\n\tchar* p = strrchr(raw_filename, '.');\n\tif ((p == NULL) || (strcmp(p, \".plist\") != 0)) {\n\t\tfree(raw_filename);\n\t\treturn res;\n\t}\n\tstrcpy(p, \".crash\");\n\n\t/* read plist crash report */\n\tif (plist_read_from_filename(&report, filename)) {\n\t\tplist_t description_node = plist_dict_get_item(report, \"description\");\n\t\tif (description_node && plist_get_node_type(description_node) == PLIST_STRING) {\n\t\t\tplist_get_string_val(description_node, &raw);\n\n\t\t\tif (raw != NULL) {\n\t\t\t\t/* write file */\n\t\t\t\tbuffer_write_to_filename(raw_filename, raw, strlen(raw));\n\t\t\t\tfree(raw);\n\t\t\t\tres = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (report)\n\t\tplist_free(report);\n\n\tif (raw_filename)\n\t\tfree(raw_filename);\n\n\treturn res;\n}"
  },
  {
    "function_name": "file_exists",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicecrashreport.c",
    "lines": "48-56",
    "snippet": "static int file_exists(const char* path)\n{\n\tstruct stat tst;\n#ifdef WIN32\n\treturn (stat(path, &tst) == 0);\n#else\n\treturn (lstat(path, &tst) == 0);\n#endif\n}",
    "includes": [
      "#include <windows.h>",
      "#include <plist/plist.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/afc.h>",
      "#include \"common/utils.h\"",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lstat",
          "args": [
            "path",
            "&tst"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "path",
            "&tst"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "mobilebackup_write_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
          "lines": "322-338",
          "snippet": "static void mobilebackup_write_status(const char *path, int status)\n{\n\tstruct stat st;\n\tplist_t status_plist = plist_new_dict();\n\tplist_dict_set_item(status_plist, \"Backup Success\", plist_new_bool(status));\n\tchar *file_path = mobilebackup_build_path(path, \"Status\", \".plist\");\n\n\tif (stat(file_path, &st) == 0)\n\t\tremove(file_path);\n\n\tplist_write_to_filename(status_plist, file_path, PLIST_FORMAT_XML);\n\n\tplist_free(status_plist);\n\tstatus_plist = NULL;\n\n\tfree(file_path);\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <unistd.h>",
            "#include <gcrypt.h>",
            "#include <openssl/sha.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void mobilebackup_write_status(const char *path, int status)\n{\n\tstruct stat st;\n\tplist_t status_plist = plist_new_dict();\n\tplist_dict_set_item(status_plist, \"Backup Success\", plist_new_bool(status));\n\tchar *file_path = mobilebackup_build_path(path, \"Status\", \".plist\");\n\n\tif (stat(file_path, &st) == 0)\n\t\tremove(file_path);\n\n\tplist_write_to_filename(status_plist, file_path, PLIST_FORMAT_XML);\n\n\tplist_free(status_plist);\n\tstatus_plist = NULL;\n\n\tfree(file_path);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include <plist/plist.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/afc.h>\n#include \"common/utils.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int file_exists(const char* path)\n{\n\tstruct stat tst;\n#ifdef WIN32\n\treturn (stat(path, &tst) == 0);\n#else\n\treturn (lstat(path, &tst) == 0);\n#endif\n}"
  }
]