[
  {
    "function_name": "service_disable_ssl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/service.c",
    "lines": "184-189",
    "snippet": "LIBIMOBILEDEVICE_API service_error_t service_disable_ssl(service_client_t client)\n{\n\tif (!client || !client->connection)\n\t\treturn SERVICE_E_INVALID_ARG;\n\treturn idevice_to_service_error(idevice_connection_disable_ssl(client->connection));\n}",
    "includes": [
      "#include \"common/debug.h\"",
      "#include \"idevice.h\"",
      "#include \"service.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "idevice_to_service_error",
          "args": [
            "idevice_connection_disable_ssl(client->connection)"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "idevice_to_service_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/service.c",
          "lines": "40-53",
          "snippet": "static service_error_t idevice_to_service_error(idevice_error_t err)\n{\n\tswitch (err) {\n\t\tcase IDEVICE_E_SUCCESS:\n\t\t\treturn SERVICE_E_SUCCESS;\n\t\tcase IDEVICE_E_INVALID_ARG:\n\t\t\treturn SERVICE_E_INVALID_ARG;\n\t\tcase IDEVICE_E_SSL_ERROR:\n\t\t\treturn SERVICE_E_SSL_ERROR;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn SERVICE_E_UNKNOWN_ERROR;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"service.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"service.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nstatic service_error_t idevice_to_service_error(idevice_error_t err)\n{\n\tswitch (err) {\n\t\tcase IDEVICE_E_SUCCESS:\n\t\t\treturn SERVICE_E_SUCCESS;\n\t\tcase IDEVICE_E_INVALID_ARG:\n\t\t\treturn SERVICE_E_INVALID_ARG;\n\t\tcase IDEVICE_E_SSL_ERROR:\n\t\t\treturn SERVICE_E_SSL_ERROR;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn SERVICE_E_UNKNOWN_ERROR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "idevice_connection_disable_ssl",
          "args": [
            "client->connection"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "idevice_connection_disable_ssl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
          "lines": "793-821",
          "snippet": "LIBIMOBILEDEVICE_API idevice_error_t idevice_connection_disable_ssl(idevice_connection_t connection)\n{\n\tif (!connection)\n\t\treturn IDEVICE_E_INVALID_ARG;\n\tif (!connection->ssl_data) {\n\t\t/* ignore if ssl is not enabled */\n\t\treturn IDEVICE_E_SUCCESS;\n\t}\n\n#ifdef HAVE_OPENSSL\n\tif (connection->ssl_data->session) {\n\t\t/* see: https://www.openssl.org/docs/ssl/SSL_shutdown.html#RETURN_VALUES */\n\t\tif (SSL_shutdown(connection->ssl_data->session) == 0) {\n\t\t\tSSL_shutdown(connection->ssl_data->session);\n\t\t}\n\t}\n#else\n\tif (connection->ssl_data->session) {\n\t\tgnutls_bye(connection->ssl_data->session, GNUTLS_SHUT_RDWR);\n\t}\n#endif\n\tinternal_ssl_cleanup(connection->ssl_data);\n\tfree(connection->ssl_data);\n\tconnection->ssl_data = NULL;\n\n\tdebug_info(\"SSL mode disabled\");\n\n\treturn IDEVICE_E_SUCCESS;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"common/thread.h\"",
            "#include \"common/userpref.h\"",
            "#include \"idevice.h\"",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <usbmuxd.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "LIBIMOBILEDEVICE_API idevice_error_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nLIBIMOBILEDEVICE_API idevice_error_t idevice_connection_disable_ssl(idevice_connection_t connection)\n{\n\tif (!connection)\n\t\treturn IDEVICE_E_INVALID_ARG;\n\tif (!connection->ssl_data) {\n\t\t/* ignore if ssl is not enabled */\n\t\treturn IDEVICE_E_SUCCESS;\n\t}\n\n#ifdef HAVE_OPENSSL\n\tif (connection->ssl_data->session) {\n\t\t/* see: https://www.openssl.org/docs/ssl/SSL_shutdown.html#RETURN_VALUES */\n\t\tif (SSL_shutdown(connection->ssl_data->session) == 0) {\n\t\t\tSSL_shutdown(connection->ssl_data->session);\n\t\t}\n\t}\n#else\n\tif (connection->ssl_data->session) {\n\t\tgnutls_bye(connection->ssl_data->session, GNUTLS_SHUT_RDWR);\n\t}\n#endif\n\tinternal_ssl_cleanup(connection->ssl_data);\n\tfree(connection->ssl_data);\n\tconnection->ssl_data = NULL;\n\n\tdebug_info(\"SSL mode disabled\");\n\n\treturn IDEVICE_E_SUCCESS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"service.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API service_error_t service_disable_ssl(service_client_t client)\n{\n\tif (!client || !client->connection)\n\t\treturn SERVICE_E_INVALID_ARG;\n\treturn idevice_to_service_error(idevice_connection_disable_ssl(client->connection));\n}"
  },
  {
    "function_name": "service_enable_ssl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/service.c",
    "lines": "177-182",
    "snippet": "LIBIMOBILEDEVICE_API service_error_t service_enable_ssl(service_client_t client)\n{\n\tif (!client || !client->connection)\n\t\treturn SERVICE_E_INVALID_ARG;\n\treturn idevice_to_service_error(idevice_connection_enable_ssl(client->connection));\n}",
    "includes": [
      "#include \"common/debug.h\"",
      "#include \"idevice.h\"",
      "#include \"service.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "idevice_to_service_error",
          "args": [
            "idevice_connection_enable_ssl(client->connection)"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "idevice_to_service_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/service.c",
          "lines": "40-53",
          "snippet": "static service_error_t idevice_to_service_error(idevice_error_t err)\n{\n\tswitch (err) {\n\t\tcase IDEVICE_E_SUCCESS:\n\t\t\treturn SERVICE_E_SUCCESS;\n\t\tcase IDEVICE_E_INVALID_ARG:\n\t\t\treturn SERVICE_E_INVALID_ARG;\n\t\tcase IDEVICE_E_SSL_ERROR:\n\t\t\treturn SERVICE_E_SSL_ERROR;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn SERVICE_E_UNKNOWN_ERROR;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"service.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"service.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nstatic service_error_t idevice_to_service_error(idevice_error_t err)\n{\n\tswitch (err) {\n\t\tcase IDEVICE_E_SUCCESS:\n\t\t\treturn SERVICE_E_SUCCESS;\n\t\tcase IDEVICE_E_INVALID_ARG:\n\t\t\treturn SERVICE_E_INVALID_ARG;\n\t\tcase IDEVICE_E_SSL_ERROR:\n\t\t\treturn SERVICE_E_SSL_ERROR;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn SERVICE_E_UNKNOWN_ERROR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "idevice_connection_enable_ssl",
          "args": [
            "client->connection"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "idevice_connection_enable_ssl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
          "lines": "649-791",
          "snippet": "LIBIMOBILEDEVICE_API idevice_error_t idevice_connection_enable_ssl(idevice_connection_t connection)\n{\n\tif (!connection || connection->ssl_data)\n\t\treturn IDEVICE_E_INVALID_ARG;\n\n\tidevice_error_t ret = IDEVICE_E_SSL_ERROR;\n\tuint32_t return_me = 0;\n\tplist_t pair_record = NULL;\n\n\tuserpref_read_pair_record(connection->udid, &pair_record);\n\tif (!pair_record) {\n\t\tdebug_info(\"ERROR: Failed enabling SSL. Unable to read pair record for udid %s.\", connection->udid);\n\t\treturn ret;\n\t}\n\n#ifdef HAVE_OPENSSL\n\tkey_data_t root_cert = { NULL, 0 };\n\tkey_data_t root_privkey = { NULL, 0 };\n\n\tpair_record_import_crt_with_name(pair_record, USERPREF_ROOT_CERTIFICATE_KEY, &root_cert);\n\tpair_record_import_key_with_name(pair_record, USERPREF_ROOT_PRIVATE_KEY_KEY, &root_privkey);\n\n\tif (pair_record)\n\t\tplist_free(pair_record);\n\n\tBIO *ssl_bio = BIO_new(BIO_s_socket());\n\tif (!ssl_bio) {\n\t\tdebug_info(\"ERROR: Could not create SSL bio.\");\n\t\treturn ret;\n\t}\n\tBIO_set_fd(ssl_bio, (int)(long)connection->data, BIO_NOCLOSE);\n\n\tSSL_CTX *ssl_ctx = SSL_CTX_new(SSLv3_method());\n\tif (ssl_ctx == NULL) {\n\t\tdebug_info(\"ERROR: Could not create SSL context.\");\n\t\tBIO_free(ssl_bio);\n\t\treturn ret;\n\t}\n\n\tBIO* membp;\n\tX509* rootCert = NULL;\n\tmembp = BIO_new_mem_buf(root_cert.data, root_cert.size);\n\tPEM_read_bio_X509(membp, &rootCert, NULL, NULL);\n\tBIO_free(membp);\n\tif (SSL_CTX_use_certificate(ssl_ctx, rootCert) != 1) {\n\t\tdebug_info(\"WARNING: Could not load RootCertificate\");\n\t}\n\tX509_free(rootCert);\n\tfree(root_cert.data);\n\n\tRSA* rootPrivKey = NULL;\n\tmembp = BIO_new_mem_buf(root_privkey.data, root_privkey.size);\n\tPEM_read_bio_RSAPrivateKey(membp, &rootPrivKey, NULL, NULL);\n\tBIO_free(membp);\n\tif (SSL_CTX_use_RSAPrivateKey(ssl_ctx, rootPrivKey) != 1) {\n\t\tdebug_info(\"WARNING: Could not load RootPrivateKey\");\n\t}\n\tRSA_free(rootPrivKey);\n\tfree(root_privkey.data);\n\n\tSSL *ssl = SSL_new(ssl_ctx);\n\tif (!ssl) {\n\t\tdebug_info(\"ERROR: Could not create SSL object\");\n\t\tBIO_free(ssl_bio);\n\t\tSSL_CTX_free(ssl_ctx);\n\t\treturn ret;\n\t}\n\tSSL_set_connect_state(ssl);\n\tSSL_set_verify(ssl, 0, ssl_verify_callback);\n\tSSL_set_bio(ssl, ssl_bio, ssl_bio);\n\n\treturn_me = SSL_do_handshake(ssl);\n\tif (return_me != 1) {\n\t\tdebug_info(\"ERROR in SSL_do_handshake: %s\", ssl_error_to_string(SSL_get_error(ssl, return_me)));\n\t\tSSL_free(ssl);\n\t\tSSL_CTX_free(ssl_ctx);\n\t} else {\n\t\tssl_data_t ssl_data_loc = (ssl_data_t)malloc(sizeof(struct ssl_data_private));\n\t\tssl_data_loc->session = ssl;\n\t\tssl_data_loc->ctx = ssl_ctx;\n\t\tconnection->ssl_data = ssl_data_loc;\n\t\tret = IDEVICE_E_SUCCESS;\n\t\tdebug_info(\"SSL mode enabled, cipher: %s\", SSL_get_cipher(ssl));\n\t}\n\t/* required for proper multi-thread clean up to prevent leaks */\n#ifdef HAVE_ERR_REMOVE_THREAD_STATE\n\tERR_remove_thread_state(NULL);\n#else\n\tERR_remove_state(0);\n#endif\n#else\n\tssl_data_t ssl_data_loc = (ssl_data_t)malloc(sizeof(struct ssl_data_private));\n\n\t/* Set up GnuTLS... */\n\tdebug_info(\"enabling SSL mode\");\n\terrno = 0;\n\tgnutls_certificate_allocate_credentials(&ssl_data_loc->certificate);\n\tgnutls_certificate_client_set_retrieve_function(ssl_data_loc->certificate, internal_cert_callback);\n\tgnutls_init(&ssl_data_loc->session, GNUTLS_CLIENT);\n\tgnutls_priority_set_direct(ssl_data_loc->session, \"NONE:+VERS-SSL3.0:+ANON-DH:+RSA:+AES-128-CBC:+AES-256-CBC:+SHA1:+MD5:+COMP-NULL\", NULL);\n\tgnutls_credentials_set(ssl_data_loc->session, GNUTLS_CRD_CERTIFICATE, ssl_data_loc->certificate);\n\tgnutls_session_set_ptr(ssl_data_loc->session, ssl_data_loc);\n\n\tgnutls_x509_crt_init(&ssl_data_loc->root_cert);\n\tgnutls_x509_crt_init(&ssl_data_loc->host_cert);\n\tgnutls_x509_privkey_init(&ssl_data_loc->root_privkey);\n\tgnutls_x509_privkey_init(&ssl_data_loc->host_privkey);\n\n\tpair_record_import_crt_with_name(pair_record, USERPREF_ROOT_CERTIFICATE_KEY, ssl_data_loc->root_cert);\n\tpair_record_import_crt_with_name(pair_record, USERPREF_HOST_CERTIFICATE_KEY, ssl_data_loc->host_cert);\n\tpair_record_import_key_with_name(pair_record, USERPREF_ROOT_PRIVATE_KEY_KEY, ssl_data_loc->root_privkey);\n\tpair_record_import_key_with_name(pair_record, USERPREF_HOST_PRIVATE_KEY_KEY, ssl_data_loc->host_privkey);\n\n\tif (pair_record)\n\t\tplist_free(pair_record);\n\n\tdebug_info(\"GnuTLS step 1...\");\n\tgnutls_transport_set_ptr(ssl_data_loc->session, (gnutls_transport_ptr_t)connection);\n\tdebug_info(\"GnuTLS step 2...\");\n\tgnutls_transport_set_push_function(ssl_data_loc->session, (gnutls_push_func) & internal_ssl_write);\n\tdebug_info(\"GnuTLS step 3...\");\n\tgnutls_transport_set_pull_function(ssl_data_loc->session, (gnutls_pull_func) & internal_ssl_read);\n\tdebug_info(\"GnuTLS step 4 -- now handshaking...\");\n\tif (errno) {\n\t\tdebug_info(\"WARNING: errno says %s before handshake!\", strerror(errno));\n\t}\n\treturn_me = gnutls_handshake(ssl_data_loc->session);\n\tdebug_info(\"GnuTLS handshake done...\");\n\n\tif (return_me != GNUTLS_E_SUCCESS) {\n\t\tinternal_ssl_cleanup(ssl_data_loc);\n\t\tfree(ssl_data_loc);\n\t\tdebug_info(\"GnuTLS reported something wrong.\");\n\t\tgnutls_perror(return_me);\n\t\tdebug_info(\"oh.. errno says %s\", strerror(errno));\n\t} else {\n\t\tconnection->ssl_data = ssl_data_loc;\n\t\tret = IDEVICE_E_SUCCESS;\n\t\tdebug_info(\"SSL mode enabled\");\n\t}\n#endif\n\treturn ret;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"common/thread.h\"",
            "#include \"common/userpref.h\"",
            "#include \"idevice.h\"",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <usbmuxd.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define HAVE_ERR_REMOVE_THREAD_STATE 1"
          ],
          "globals_used": [
            "LIBIMOBILEDEVICE_API idevice_error_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\n#define HAVE_ERR_REMOVE_THREAD_STATE 1\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nLIBIMOBILEDEVICE_API idevice_error_t idevice_connection_enable_ssl(idevice_connection_t connection)\n{\n\tif (!connection || connection->ssl_data)\n\t\treturn IDEVICE_E_INVALID_ARG;\n\n\tidevice_error_t ret = IDEVICE_E_SSL_ERROR;\n\tuint32_t return_me = 0;\n\tplist_t pair_record = NULL;\n\n\tuserpref_read_pair_record(connection->udid, &pair_record);\n\tif (!pair_record) {\n\t\tdebug_info(\"ERROR: Failed enabling SSL. Unable to read pair record for udid %s.\", connection->udid);\n\t\treturn ret;\n\t}\n\n#ifdef HAVE_OPENSSL\n\tkey_data_t root_cert = { NULL, 0 };\n\tkey_data_t root_privkey = { NULL, 0 };\n\n\tpair_record_import_crt_with_name(pair_record, USERPREF_ROOT_CERTIFICATE_KEY, &root_cert);\n\tpair_record_import_key_with_name(pair_record, USERPREF_ROOT_PRIVATE_KEY_KEY, &root_privkey);\n\n\tif (pair_record)\n\t\tplist_free(pair_record);\n\n\tBIO *ssl_bio = BIO_new(BIO_s_socket());\n\tif (!ssl_bio) {\n\t\tdebug_info(\"ERROR: Could not create SSL bio.\");\n\t\treturn ret;\n\t}\n\tBIO_set_fd(ssl_bio, (int)(long)connection->data, BIO_NOCLOSE);\n\n\tSSL_CTX *ssl_ctx = SSL_CTX_new(SSLv3_method());\n\tif (ssl_ctx == NULL) {\n\t\tdebug_info(\"ERROR: Could not create SSL context.\");\n\t\tBIO_free(ssl_bio);\n\t\treturn ret;\n\t}\n\n\tBIO* membp;\n\tX509* rootCert = NULL;\n\tmembp = BIO_new_mem_buf(root_cert.data, root_cert.size);\n\tPEM_read_bio_X509(membp, &rootCert, NULL, NULL);\n\tBIO_free(membp);\n\tif (SSL_CTX_use_certificate(ssl_ctx, rootCert) != 1) {\n\t\tdebug_info(\"WARNING: Could not load RootCertificate\");\n\t}\n\tX509_free(rootCert);\n\tfree(root_cert.data);\n\n\tRSA* rootPrivKey = NULL;\n\tmembp = BIO_new_mem_buf(root_privkey.data, root_privkey.size);\n\tPEM_read_bio_RSAPrivateKey(membp, &rootPrivKey, NULL, NULL);\n\tBIO_free(membp);\n\tif (SSL_CTX_use_RSAPrivateKey(ssl_ctx, rootPrivKey) != 1) {\n\t\tdebug_info(\"WARNING: Could not load RootPrivateKey\");\n\t}\n\tRSA_free(rootPrivKey);\n\tfree(root_privkey.data);\n\n\tSSL *ssl = SSL_new(ssl_ctx);\n\tif (!ssl) {\n\t\tdebug_info(\"ERROR: Could not create SSL object\");\n\t\tBIO_free(ssl_bio);\n\t\tSSL_CTX_free(ssl_ctx);\n\t\treturn ret;\n\t}\n\tSSL_set_connect_state(ssl);\n\tSSL_set_verify(ssl, 0, ssl_verify_callback);\n\tSSL_set_bio(ssl, ssl_bio, ssl_bio);\n\n\treturn_me = SSL_do_handshake(ssl);\n\tif (return_me != 1) {\n\t\tdebug_info(\"ERROR in SSL_do_handshake: %s\", ssl_error_to_string(SSL_get_error(ssl, return_me)));\n\t\tSSL_free(ssl);\n\t\tSSL_CTX_free(ssl_ctx);\n\t} else {\n\t\tssl_data_t ssl_data_loc = (ssl_data_t)malloc(sizeof(struct ssl_data_private));\n\t\tssl_data_loc->session = ssl;\n\t\tssl_data_loc->ctx = ssl_ctx;\n\t\tconnection->ssl_data = ssl_data_loc;\n\t\tret = IDEVICE_E_SUCCESS;\n\t\tdebug_info(\"SSL mode enabled, cipher: %s\", SSL_get_cipher(ssl));\n\t}\n\t/* required for proper multi-thread clean up to prevent leaks */\n#ifdef HAVE_ERR_REMOVE_THREAD_STATE\n\tERR_remove_thread_state(NULL);\n#else\n\tERR_remove_state(0);\n#endif\n#else\n\tssl_data_t ssl_data_loc = (ssl_data_t)malloc(sizeof(struct ssl_data_private));\n\n\t/* Set up GnuTLS... */\n\tdebug_info(\"enabling SSL mode\");\n\terrno = 0;\n\tgnutls_certificate_allocate_credentials(&ssl_data_loc->certificate);\n\tgnutls_certificate_client_set_retrieve_function(ssl_data_loc->certificate, internal_cert_callback);\n\tgnutls_init(&ssl_data_loc->session, GNUTLS_CLIENT);\n\tgnutls_priority_set_direct(ssl_data_loc->session, \"NONE:+VERS-SSL3.0:+ANON-DH:+RSA:+AES-128-CBC:+AES-256-CBC:+SHA1:+MD5:+COMP-NULL\", NULL);\n\tgnutls_credentials_set(ssl_data_loc->session, GNUTLS_CRD_CERTIFICATE, ssl_data_loc->certificate);\n\tgnutls_session_set_ptr(ssl_data_loc->session, ssl_data_loc);\n\n\tgnutls_x509_crt_init(&ssl_data_loc->root_cert);\n\tgnutls_x509_crt_init(&ssl_data_loc->host_cert);\n\tgnutls_x509_privkey_init(&ssl_data_loc->root_privkey);\n\tgnutls_x509_privkey_init(&ssl_data_loc->host_privkey);\n\n\tpair_record_import_crt_with_name(pair_record, USERPREF_ROOT_CERTIFICATE_KEY, ssl_data_loc->root_cert);\n\tpair_record_import_crt_with_name(pair_record, USERPREF_HOST_CERTIFICATE_KEY, ssl_data_loc->host_cert);\n\tpair_record_import_key_with_name(pair_record, USERPREF_ROOT_PRIVATE_KEY_KEY, ssl_data_loc->root_privkey);\n\tpair_record_import_key_with_name(pair_record, USERPREF_HOST_PRIVATE_KEY_KEY, ssl_data_loc->host_privkey);\n\n\tif (pair_record)\n\t\tplist_free(pair_record);\n\n\tdebug_info(\"GnuTLS step 1...\");\n\tgnutls_transport_set_ptr(ssl_data_loc->session, (gnutls_transport_ptr_t)connection);\n\tdebug_info(\"GnuTLS step 2...\");\n\tgnutls_transport_set_push_function(ssl_data_loc->session, (gnutls_push_func) & internal_ssl_write);\n\tdebug_info(\"GnuTLS step 3...\");\n\tgnutls_transport_set_pull_function(ssl_data_loc->session, (gnutls_pull_func) & internal_ssl_read);\n\tdebug_info(\"GnuTLS step 4 -- now handshaking...\");\n\tif (errno) {\n\t\tdebug_info(\"WARNING: errno says %s before handshake!\", strerror(errno));\n\t}\n\treturn_me = gnutls_handshake(ssl_data_loc->session);\n\tdebug_info(\"GnuTLS handshake done...\");\n\n\tif (return_me != GNUTLS_E_SUCCESS) {\n\t\tinternal_ssl_cleanup(ssl_data_loc);\n\t\tfree(ssl_data_loc);\n\t\tdebug_info(\"GnuTLS reported something wrong.\");\n\t\tgnutls_perror(return_me);\n\t\tdebug_info(\"oh.. errno says %s\", strerror(errno));\n\t} else {\n\t\tconnection->ssl_data = ssl_data_loc;\n\t\tret = IDEVICE_E_SUCCESS;\n\t\tdebug_info(\"SSL mode enabled\");\n\t}\n#endif\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"service.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API service_error_t service_enable_ssl(service_client_t client)\n{\n\tif (!client || !client->connection)\n\t\treturn SERVICE_E_INVALID_ARG;\n\treturn idevice_to_service_error(idevice_connection_enable_ssl(client->connection));\n}"
  },
  {
    "function_name": "service_receive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/service.c",
    "lines": "172-175",
    "snippet": "LIBIMOBILEDEVICE_API service_error_t service_receive(service_client_t client, char* data, uint32_t size, uint32_t *received)\n{\n\treturn service_receive_with_timeout(client, data, size, received, 10000);\n}",
    "includes": [
      "#include \"common/debug.h\"",
      "#include \"idevice.h\"",
      "#include \"service.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "service_receive_with_timeout",
          "args": [
            "client",
            "data",
            "size",
            "received",
            "10000"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "service_receive_with_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/service.c",
          "lines": "152-170",
          "snippet": "LIBIMOBILEDEVICE_API service_error_t service_receive_with_timeout(service_client_t client, char* data, uint32_t size, uint32_t *received, unsigned int timeout)\n{\n\tservice_error_t res = SERVICE_E_UNKNOWN_ERROR;\n\tint bytes = 0;\n\n\tif (!client || (client && !client->connection) || !data || (size == 0)) {\n\t\treturn SERVICE_E_INVALID_ARG;\n\t}\n\n\tres = idevice_to_service_error(idevice_connection_receive_timeout(client->connection, data, size, (uint32_t*)&bytes, timeout));\n\tif (bytes <= 0) {\n\t\tdebug_info(\"could not read data\");\n\t}\n\tif (received) {\n\t\t*received = (uint32_t)bytes;\n\t}\n\n\treturn res;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"service.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"service.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API service_error_t service_receive_with_timeout(service_client_t client, char* data, uint32_t size, uint32_t *received, unsigned int timeout)\n{\n\tservice_error_t res = SERVICE_E_UNKNOWN_ERROR;\n\tint bytes = 0;\n\n\tif (!client || (client && !client->connection) || !data || (size == 0)) {\n\t\treturn SERVICE_E_INVALID_ARG;\n\t}\n\n\tres = idevice_to_service_error(idevice_connection_receive_timeout(client->connection, data, size, (uint32_t*)&bytes, timeout));\n\tif (bytes <= 0) {\n\t\tdebug_info(\"could not read data\");\n\t}\n\tif (received) {\n\t\t*received = (uint32_t)bytes;\n\t}\n\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"service.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API service_error_t service_receive(service_client_t client, char* data, uint32_t size, uint32_t *received)\n{\n\treturn service_receive_with_timeout(client, data, size, received, 10000);\n}"
  },
  {
    "function_name": "service_receive_with_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/service.c",
    "lines": "152-170",
    "snippet": "LIBIMOBILEDEVICE_API service_error_t service_receive_with_timeout(service_client_t client, char* data, uint32_t size, uint32_t *received, unsigned int timeout)\n{\n\tservice_error_t res = SERVICE_E_UNKNOWN_ERROR;\n\tint bytes = 0;\n\n\tif (!client || (client && !client->connection) || !data || (size == 0)) {\n\t\treturn SERVICE_E_INVALID_ARG;\n\t}\n\n\tres = idevice_to_service_error(idevice_connection_receive_timeout(client->connection, data, size, (uint32_t*)&bytes, timeout));\n\tif (bytes <= 0) {\n\t\tdebug_info(\"could not read data\");\n\t}\n\tif (received) {\n\t\t*received = (uint32_t)bytes;\n\t}\n\n\treturn res;\n}",
    "includes": [
      "#include \"common/debug.h\"",
      "#include \"idevice.h\"",
      "#include \"service.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"could not read data\""
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idevice_to_service_error",
          "args": [
            "idevice_connection_receive_timeout(client->connection, data, size, (uint32_t*)&bytes, timeout)"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "idevice_to_service_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/service.c",
          "lines": "40-53",
          "snippet": "static service_error_t idevice_to_service_error(idevice_error_t err)\n{\n\tswitch (err) {\n\t\tcase IDEVICE_E_SUCCESS:\n\t\t\treturn SERVICE_E_SUCCESS;\n\t\tcase IDEVICE_E_INVALID_ARG:\n\t\t\treturn SERVICE_E_INVALID_ARG;\n\t\tcase IDEVICE_E_SSL_ERROR:\n\t\t\treturn SERVICE_E_SSL_ERROR;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn SERVICE_E_UNKNOWN_ERROR;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"service.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"service.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nstatic service_error_t idevice_to_service_error(idevice_error_t err)\n{\n\tswitch (err) {\n\t\tcase IDEVICE_E_SUCCESS:\n\t\t\treturn SERVICE_E_SUCCESS;\n\t\tcase IDEVICE_E_INVALID_ARG:\n\t\t\treturn SERVICE_E_INVALID_ARG;\n\t\tcase IDEVICE_E_SSL_ERROR:\n\t\t\treturn SERVICE_E_SSL_ERROR;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn SERVICE_E_UNKNOWN_ERROR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "idevice_connection_receive_timeout",
          "args": [
            "client->connection",
            "data",
            "size",
            "(uint32_t*)&bytes",
            "timeout"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "idevice_connection_receive_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
          "lines": "389-418",
          "snippet": "LIBIMOBILEDEVICE_API idevice_error_t idevice_connection_receive_timeout(idevice_connection_t connection, char *data, uint32_t len, uint32_t *recv_bytes, unsigned int timeout)\n{\n\tif (!connection || (connection->ssl_data && !connection->ssl_data->session)) {\n\t\treturn IDEVICE_E_INVALID_ARG;\n\t}\n\n\tif (connection->ssl_data) {\n\t\tuint32_t received = 0;\n\t\twhile (received < len) {\n#ifdef HAVE_OPENSSL\n\t\t\tint r = SSL_read(connection->ssl_data->session, (void*)((char*)(data+received)), (int)len-received);\n#else\n\t\t\tssize_t r = gnutls_record_recv(connection->ssl_data->session, (void*)(data+received), (size_t)len-received);\n#endif\n\t\t\tif (r > 0) {\n\t\t\t\treceived += r;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tdebug_info(\"SSL_read %d, received %d\", len, received);\n\t\tif (received > 0) {\n\t\t\t*recv_bytes = received;\n\t\t\treturn IDEVICE_E_SUCCESS;\n\t\t}\n\t\t*recv_bytes = 0;\n\t\treturn IDEVICE_E_SSL_ERROR;\n\t}\n\treturn internal_connection_receive_timeout(connection, data, len, recv_bytes, timeout);\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"common/thread.h\"",
            "#include \"common/userpref.h\"",
            "#include \"idevice.h\"",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <usbmuxd.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "LIBIMOBILEDEVICE_API idevice_error_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nLIBIMOBILEDEVICE_API idevice_error_t idevice_connection_receive_timeout(idevice_connection_t connection, char *data, uint32_t len, uint32_t *recv_bytes, unsigned int timeout)\n{\n\tif (!connection || (connection->ssl_data && !connection->ssl_data->session)) {\n\t\treturn IDEVICE_E_INVALID_ARG;\n\t}\n\n\tif (connection->ssl_data) {\n\t\tuint32_t received = 0;\n\t\twhile (received < len) {\n#ifdef HAVE_OPENSSL\n\t\t\tint r = SSL_read(connection->ssl_data->session, (void*)((char*)(data+received)), (int)len-received);\n#else\n\t\t\tssize_t r = gnutls_record_recv(connection->ssl_data->session, (void*)(data+received), (size_t)len-received);\n#endif\n\t\t\tif (r > 0) {\n\t\t\t\treceived += r;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tdebug_info(\"SSL_read %d, received %d\", len, received);\n\t\tif (received > 0) {\n\t\t\t*recv_bytes = received;\n\t\t\treturn IDEVICE_E_SUCCESS;\n\t\t}\n\t\t*recv_bytes = 0;\n\t\treturn IDEVICE_E_SSL_ERROR;\n\t}\n\treturn internal_connection_receive_timeout(connection, data, len, recv_bytes, timeout);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"service.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API service_error_t service_receive_with_timeout(service_client_t client, char* data, uint32_t size, uint32_t *received, unsigned int timeout)\n{\n\tservice_error_t res = SERVICE_E_UNKNOWN_ERROR;\n\tint bytes = 0;\n\n\tif (!client || (client && !client->connection) || !data || (size == 0)) {\n\t\treturn SERVICE_E_INVALID_ARG;\n\t}\n\n\tres = idevice_to_service_error(idevice_connection_receive_timeout(client->connection, data, size, (uint32_t*)&bytes, timeout));\n\tif (bytes <= 0) {\n\t\tdebug_info(\"could not read data\");\n\t}\n\tif (received) {\n\t\t*received = (uint32_t)bytes;\n\t}\n\n\treturn res;\n}"
  },
  {
    "function_name": "service_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/service.c",
    "lines": "131-150",
    "snippet": "LIBIMOBILEDEVICE_API service_error_t service_send(service_client_t client, const char* data, uint32_t size, uint32_t *sent)\n{\n\tservice_error_t res = SERVICE_E_UNKNOWN_ERROR;\n\tint bytes = 0;\n\n\tif (!client || (client && !client->connection) || !data || (size == 0)) {\n\t\treturn SERVICE_E_INVALID_ARG;\n\t}\n\n\tdebug_info(\"sending %d bytes\", size);\n\tres = idevice_to_service_error(idevice_connection_send(client->connection, data, size, (uint32_t*)&bytes));\n\tif (bytes <= 0) {\n\t\tdebug_info(\"ERROR: sending to device failed.\");\n\t}\n\tif (sent) {\n\t\t*sent = (uint32_t)bytes;\n\t}\n\n\treturn res;\n}",
    "includes": [
      "#include \"common/debug.h\"",
      "#include \"idevice.h\"",
      "#include \"service.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"ERROR: sending to device failed.\""
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idevice_to_service_error",
          "args": [
            "idevice_connection_send(client->connection, data, size, (uint32_t*)&bytes)"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "idevice_to_service_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/service.c",
          "lines": "40-53",
          "snippet": "static service_error_t idevice_to_service_error(idevice_error_t err)\n{\n\tswitch (err) {\n\t\tcase IDEVICE_E_SUCCESS:\n\t\t\treturn SERVICE_E_SUCCESS;\n\t\tcase IDEVICE_E_INVALID_ARG:\n\t\t\treturn SERVICE_E_INVALID_ARG;\n\t\tcase IDEVICE_E_SSL_ERROR:\n\t\t\treturn SERVICE_E_SSL_ERROR;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn SERVICE_E_UNKNOWN_ERROR;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"service.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"service.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nstatic service_error_t idevice_to_service_error(idevice_error_t err)\n{\n\tswitch (err) {\n\t\tcase IDEVICE_E_SUCCESS:\n\t\t\treturn SERVICE_E_SUCCESS;\n\t\tcase IDEVICE_E_INVALID_ARG:\n\t\t\treturn SERVICE_E_INVALID_ARG;\n\t\tcase IDEVICE_E_SSL_ERROR:\n\t\t\treturn SERVICE_E_SSL_ERROR;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn SERVICE_E_UNKNOWN_ERROR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "idevice_connection_send",
          "args": [
            "client->connection",
            "data",
            "size",
            "(uint32_t*)&bytes"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "idevice_connection_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
          "lines": "343-364",
          "snippet": "LIBIMOBILEDEVICE_API idevice_error_t idevice_connection_send(idevice_connection_t connection, const char *data, uint32_t len, uint32_t *sent_bytes)\n{\n\tif (!connection || !data || (connection->ssl_data && !connection->ssl_data->session)) {\n\t\treturn IDEVICE_E_INVALID_ARG;\n\t}\n\n\tif (connection->ssl_data) {\n#ifdef HAVE_OPENSSL\n\t\tint sent = SSL_write(connection->ssl_data->session, (const void*)data, (int)len);\n\t\tdebug_info(\"SSL_write %d, sent %d\", len, sent);\n#else\n\t\tssize_t sent = gnutls_record_send(connection->ssl_data->session, (void*)data, (size_t)len);\n#endif\n\t\tif ((uint32_t)sent == (uint32_t)len) {\n\t\t\t*sent_bytes = sent;\n\t\t\treturn IDEVICE_E_SUCCESS;\n\t\t}\n\t\t*sent_bytes = 0;\n\t\treturn IDEVICE_E_SSL_ERROR;\n\t}\n\treturn internal_connection_send(connection, data, len, sent_bytes);\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"common/thread.h\"",
            "#include \"common/userpref.h\"",
            "#include \"idevice.h\"",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <usbmuxd.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "LIBIMOBILEDEVICE_API idevice_error_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nLIBIMOBILEDEVICE_API idevice_error_t idevice_connection_send(idevice_connection_t connection, const char *data, uint32_t len, uint32_t *sent_bytes)\n{\n\tif (!connection || !data || (connection->ssl_data && !connection->ssl_data->session)) {\n\t\treturn IDEVICE_E_INVALID_ARG;\n\t}\n\n\tif (connection->ssl_data) {\n#ifdef HAVE_OPENSSL\n\t\tint sent = SSL_write(connection->ssl_data->session, (const void*)data, (int)len);\n\t\tdebug_info(\"SSL_write %d, sent %d\", len, sent);\n#else\n\t\tssize_t sent = gnutls_record_send(connection->ssl_data->session, (void*)data, (size_t)len);\n#endif\n\t\tif ((uint32_t)sent == (uint32_t)len) {\n\t\t\t*sent_bytes = sent;\n\t\t\treturn IDEVICE_E_SUCCESS;\n\t\t}\n\t\t*sent_bytes = 0;\n\t\treturn IDEVICE_E_SSL_ERROR;\n\t}\n\treturn internal_connection_send(connection, data, len, sent_bytes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"sending %d bytes\"",
            "size"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"service.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API service_error_t service_send(service_client_t client, const char* data, uint32_t size, uint32_t *sent)\n{\n\tservice_error_t res = SERVICE_E_UNKNOWN_ERROR;\n\tint bytes = 0;\n\n\tif (!client || (client && !client->connection) || !data || (size == 0)) {\n\t\treturn SERVICE_E_INVALID_ARG;\n\t}\n\n\tdebug_info(\"sending %d bytes\", size);\n\tres = idevice_to_service_error(idevice_connection_send(client->connection, data, size, (uint32_t*)&bytes));\n\tif (bytes <= 0) {\n\t\tdebug_info(\"ERROR: sending to device failed.\");\n\t}\n\tif (sent) {\n\t\t*sent = (uint32_t)bytes;\n\t}\n\n\treturn res;\n}"
  },
  {
    "function_name": "service_client_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/service.c",
    "lines": "118-129",
    "snippet": "LIBIMOBILEDEVICE_API service_error_t service_client_free(service_client_t client)\n{\n\tif (!client)\n\t\treturn SERVICE_E_INVALID_ARG;\n\n\tservice_error_t err = idevice_to_service_error(idevice_disconnect(client->connection));\n\n\tfree(client);\n\tclient = NULL;\n\n\treturn err;\n}",
    "includes": [
      "#include \"common/debug.h\"",
      "#include \"idevice.h\"",
      "#include \"service.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "client"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "service_client_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/service.c",
          "lines": "118-129",
          "snippet": "LIBIMOBILEDEVICE_API service_error_t service_client_free(service_client_t client)\n{\n\tif (!client)\n\t\treturn SERVICE_E_INVALID_ARG;\n\n\tservice_error_t err = idevice_to_service_error(idevice_disconnect(client->connection));\n\n\tfree(client);\n\tclient = NULL;\n\n\treturn err;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "idevice_to_service_error",
          "args": [
            "idevice_disconnect(client->connection)"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "idevice_to_service_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/service.c",
          "lines": "40-53",
          "snippet": "static service_error_t idevice_to_service_error(idevice_error_t err)\n{\n\tswitch (err) {\n\t\tcase IDEVICE_E_SUCCESS:\n\t\t\treturn SERVICE_E_SUCCESS;\n\t\tcase IDEVICE_E_INVALID_ARG:\n\t\t\treturn SERVICE_E_INVALID_ARG;\n\t\tcase IDEVICE_E_SSL_ERROR:\n\t\t\treturn SERVICE_E_SSL_ERROR;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn SERVICE_E_UNKNOWN_ERROR;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"service.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"service.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nstatic service_error_t idevice_to_service_error(idevice_error_t err)\n{\n\tswitch (err) {\n\t\tcase IDEVICE_E_SUCCESS:\n\t\t\treturn SERVICE_E_SUCCESS;\n\t\tcase IDEVICE_E_INVALID_ARG:\n\t\t\treturn SERVICE_E_INVALID_ARG;\n\t\tcase IDEVICE_E_SSL_ERROR:\n\t\t\treturn SERVICE_E_SSL_ERROR;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn SERVICE_E_UNKNOWN_ERROR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "idevice_disconnect",
          "args": [
            "client->connection"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "idevice_disconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
          "lines": "293-318",
          "snippet": "LIBIMOBILEDEVICE_API idevice_error_t idevice_disconnect(idevice_connection_t connection)\n{\n\tif (!connection) {\n\t\treturn IDEVICE_E_INVALID_ARG;\n\t}\n\t/* shut down ssl if enabled */\n\tif (connection->ssl_data) {\n\t\tidevice_connection_disable_ssl(connection);\n\t}\n\tidevice_error_t result = IDEVICE_E_UNKNOWN_ERROR;\n\tif (connection->type == CONNECTION_USBMUXD) {\n\t\tusbmuxd_disconnect((int)(long)connection->data);\n\t\tconnection->data = NULL;\n\t\tresult = IDEVICE_E_SUCCESS;\n\t} else {\n\t\tdebug_info(\"Unknown connection type %d\", connection->type);\n\t}\n\n\tif (connection->udid)\n\t\tfree(connection->udid);\n\n\tfree(connection);\n\tconnection = NULL;\n\n\treturn result;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"common/thread.h\"",
            "#include \"common/userpref.h\"",
            "#include \"idevice.h\"",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <usbmuxd.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "LIBIMOBILEDEVICE_API idevice_error_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nLIBIMOBILEDEVICE_API idevice_error_t idevice_disconnect(idevice_connection_t connection)\n{\n\tif (!connection) {\n\t\treturn IDEVICE_E_INVALID_ARG;\n\t}\n\t/* shut down ssl if enabled */\n\tif (connection->ssl_data) {\n\t\tidevice_connection_disable_ssl(connection);\n\t}\n\tidevice_error_t result = IDEVICE_E_UNKNOWN_ERROR;\n\tif (connection->type == CONNECTION_USBMUXD) {\n\t\tusbmuxd_disconnect((int)(long)connection->data);\n\t\tconnection->data = NULL;\n\t\tresult = IDEVICE_E_SUCCESS;\n\t} else {\n\t\tdebug_info(\"Unknown connection type %d\", connection->type);\n\t}\n\n\tif (connection->udid)\n\t\tfree(connection->udid);\n\n\tfree(connection);\n\tconnection = NULL;\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"service.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API service_error_t service_client_free(service_client_t client)\n{\n\tif (!client)\n\t\treturn SERVICE_E_INVALID_ARG;\n\n\tservice_error_t err = idevice_to_service_error(idevice_disconnect(client->connection));\n\n\tfree(client);\n\tclient = NULL;\n\n\treturn err;\n}"
  },
  {
    "function_name": "service_client_factory_start_service",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/service.c",
    "lines": "79-116",
    "snippet": "LIBIMOBILEDEVICE_API service_error_t service_client_factory_start_service(idevice_t device, const char* service_name, void **client, const char* label, int32_t (*constructor_func)(idevice_t, lockdownd_service_descriptor_t, void**), int32_t *error_code)\n{\n\t*client = NULL;\n\n\tlockdownd_client_t lckd = NULL;\n\tif (LOCKDOWN_E_SUCCESS != lockdownd_client_new_with_handshake(device, &lckd, label)) {\n\t\tdebug_info(\"Could not create a lockdown client.\");\n\t\treturn SERVICE_E_START_SERVICE_ERROR;\n\t}\n\n\tlockdownd_service_descriptor_t service = NULL;\n\tlockdownd_start_service(lckd, service_name, &service);\n\tlockdownd_client_free(lckd);\n\n\tif (!service || service->port == 0) {\n\t\tdebug_info(\"Could not start service %s!\", service_name);\n\t\treturn SERVICE_E_START_SERVICE_ERROR;\n\t}\n\n\tint32_t ec;\n\tif (constructor_func) {\n\t\tec = (int32_t)constructor_func(device, service, client);\n\t} else {\n\t\tec = service_client_new(device, service, (service_client_t*)client);\n\t}\n\tif (error_code) {\n\t\t*error_code = ec;\n\t}\n\n\tif (ec != SERVICE_E_SUCCESS) {\n\t\tdebug_info(\"Could not connect to service %s! Port: %i, error: %i\", service_name, service->port, ec);\n\t}\n\n\tlockdownd_service_descriptor_free(service);\n\tservice = NULL;\n\n\treturn (ec == SERVICE_E_SUCCESS) ? SERVICE_E_SUCCESS : SERVICE_E_START_SERVICE_ERROR;\n}",
    "includes": [
      "#include \"common/debug.h\"",
      "#include \"idevice.h\"",
      "#include \"service.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdownd_service_descriptor_free",
          "args": [
            "service"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "lockdownd_service_descriptor_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/lockdown.c",
          "lines": "1522-1528",
          "snippet": "LIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_service_descriptor_free(lockdownd_service_descriptor_t service)\n{\n\tif (service)\n\t\tfree(service);\n\n\treturn LOCKDOWN_E_SUCCESS;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/userpref.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"lockdown.h\"",
            "#include \"property_list_service.h\"",
            "#include <plist/plist.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/x509.h>",
            "#include <libtasn1.h>",
            "#include <openssl/x509v3.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/pem.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/userpref.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"lockdown.h\"\n#include \"property_list_service.h\"\n#include <plist/plist.h>\n#include <gnutls/crypto.h>\n#include <gnutls/x509.h>\n#include <libtasn1.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/pem.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_service_descriptor_free(lockdownd_service_descriptor_t service)\n{\n\tif (service)\n\t\tfree(service);\n\n\treturn LOCKDOWN_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"Could not connect to service %s! Port: %i, error: %i\"",
            "service_name",
            "service->port",
            "ec"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "debug_info_real",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/debug.c",
          "lines": "81-99",
          "snippet": "void debug_info_real(const char *func, const char *file, int line, const char *format, ...)\n{\n#ifndef STRIP_DEBUG_CODE\n\tva_list args;\n\tchar *buffer = NULL;\n\n\tif (!debug_level)\n\t\treturn;\n\n\t/* run the real fprintf */\n\tva_start(args, format);\n\t(void)vasprintf(&buffer, format, args);\n\tva_end(args);\n\n\tdebug_print_line(func, file, line, buffer);\n\n\tfree(buffer);\n#endif\n}",
          "includes": [
            "#include \"asprintf.h\"",
            "#include \"src/idevice.h\"",
            "#include \"libimobiledevice/libimobiledevice.h\"",
            "#include \"debug.h\"",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int debug_level;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"asprintf.h\"\n#include \"src/idevice.h\"\n#include \"libimobiledevice/libimobiledevice.h\"\n#include \"debug.h\"\n#include <time.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int debug_level;\n\nvoid debug_info_real(const char *func, const char *file, int line, const char *format, ...)\n{\n#ifndef STRIP_DEBUG_CODE\n\tva_list args;\n\tchar *buffer = NULL;\n\n\tif (!debug_level)\n\t\treturn;\n\n\t/* run the real fprintf */\n\tva_start(args, format);\n\t(void)vasprintf(&buffer, format, args);\n\tva_end(args);\n\n\tdebug_print_line(func, file, line, buffer);\n\n\tfree(buffer);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "service_client_new",
          "args": [
            "device",
            "service",
            "(service_client_t*)client"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "service_client_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/service.c",
          "lines": "55-77",
          "snippet": "LIBIMOBILEDEVICE_API service_error_t service_client_new(idevice_t device, lockdownd_service_descriptor_t service, service_client_t *client)\n{\n\tif (!device || !service || service->port == 0 || !client || *client)\n\t\treturn SERVICE_E_INVALID_ARG;\n\n\t/* Attempt connection */\n\tidevice_connection_t connection = NULL;\n\tif (idevice_connect(device, service->port, &connection) != IDEVICE_E_SUCCESS) {\n\t\treturn SERVICE_E_MUX_ERROR;\n\t}\n\n\t/* create client object */\n\tservice_client_t client_loc = (service_client_t)malloc(sizeof(struct service_client_private));\n\tclient_loc->connection = connection;\n\n\t/* enable SSL if requested */\n\tif (service->ssl_enabled == 1)\n\t\tservice_enable_ssl(client_loc);\n\n\t/* all done, return success */\n\t*client = client_loc;\n\treturn SERVICE_E_SUCCESS;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"service.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"service.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API service_error_t service_client_new(idevice_t device, lockdownd_service_descriptor_t service, service_client_t *client)\n{\n\tif (!device || !service || service->port == 0 || !client || *client)\n\t\treturn SERVICE_E_INVALID_ARG;\n\n\t/* Attempt connection */\n\tidevice_connection_t connection = NULL;\n\tif (idevice_connect(device, service->port, &connection) != IDEVICE_E_SUCCESS) {\n\t\treturn SERVICE_E_MUX_ERROR;\n\t}\n\n\t/* create client object */\n\tservice_client_t client_loc = (service_client_t)malloc(sizeof(struct service_client_private));\n\tclient_loc->connection = connection;\n\n\t/* enable SSL if requested */\n\tif (service->ssl_enabled == 1)\n\t\tservice_enable_ssl(client_loc);\n\n\t/* all done, return success */\n\t*client = client_loc;\n\treturn SERVICE_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "constructor_func",
          "args": [
            "device",
            "service",
            "client"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"Could not start service %s!\"",
            "service_name"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdownd_client_free",
          "args": [
            "lckd"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "lockdownd_client_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/lockdown.c",
          "lines": "322-336",
          "snippet": "LIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_client_free(lockdownd_client_t client)\n{\n\tif (!client)\n\t\treturn LOCKDOWN_E_INVALID_ARG;\n\n\tlockdownd_error_t ret = LOCKDOWN_E_UNKNOWN_ERROR;\n\n\tif (client->session_id) {\n\t\tlockdownd_stop_session(client, client->session_id);\n\t}\n\n\tret = lockdownd_client_free_simple(client);\n\n\treturn ret;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/userpref.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"lockdown.h\"",
            "#include \"property_list_service.h\"",
            "#include <plist/plist.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/x509.h>",
            "#include <libtasn1.h>",
            "#include <openssl/x509v3.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/pem.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/userpref.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"lockdown.h\"\n#include \"property_list_service.h\"\n#include <plist/plist.h>\n#include <gnutls/crypto.h>\n#include <gnutls/x509.h>\n#include <libtasn1.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/pem.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_client_free(lockdownd_client_t client)\n{\n\tif (!client)\n\t\treturn LOCKDOWN_E_INVALID_ARG;\n\n\tlockdownd_error_t ret = LOCKDOWN_E_UNKNOWN_ERROR;\n\n\tif (client->session_id) {\n\t\tlockdownd_stop_session(client, client->session_id);\n\t}\n\n\tret = lockdownd_client_free_simple(client);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdownd_start_service",
          "args": [
            "lckd",
            "service_name",
            "&service"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "lockdownd_start_service_with_escrow_bag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/lockdown.c",
          "lines": "1364-1367",
          "snippet": "LIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_start_service_with_escrow_bag(lockdownd_client_t client, const char *identifier, lockdownd_service_descriptor_t *service)\n{\n\treturn lockdownd_do_start_service(client, identifier, 1, service);\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/userpref.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"lockdown.h\"",
            "#include \"property_list_service.h\"",
            "#include <plist/plist.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/x509.h>",
            "#include <libtasn1.h>",
            "#include <openssl/x509v3.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/pem.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/userpref.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"lockdown.h\"\n#include \"property_list_service.h\"\n#include <plist/plist.h>\n#include <gnutls/crypto.h>\n#include <gnutls/x509.h>\n#include <libtasn1.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/pem.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_start_service_with_escrow_bag(lockdownd_client_t client, const char *identifier, lockdownd_service_descriptor_t *service)\n{\n\treturn lockdownd_do_start_service(client, identifier, 1, service);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"Could not create a lockdown client.\""
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdownd_client_new_with_handshake",
          "args": [
            "device",
            "&lckd",
            "label"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "lockdownd_client_new_with_handshake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/lockdown.c",
          "lines": "671-753",
          "snippet": "LIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_client_new_with_handshake(idevice_t device, lockdownd_client_t *client, const char *label)\n{\n\tif (!client)\n\t\treturn LOCKDOWN_E_INVALID_ARG;\n\n\tlockdownd_error_t ret = LOCKDOWN_E_SUCCESS;\n\tlockdownd_client_t client_loc = NULL;\n\tplist_t pair_record = NULL;\n\tchar *host_id = NULL;\n\tchar *type = NULL;\n\n\tret = lockdownd_client_new(device, &client_loc, label);\n\tif (LOCKDOWN_E_SUCCESS != ret) {\n\t\tdebug_info(\"failed to create lockdownd client.\");\n\t\treturn ret;\n\t}\n\n\t/* perform handshake */\n\tif (LOCKDOWN_E_SUCCESS != lockdownd_query_type(client_loc, &type)) {\n\t\tdebug_info(\"QueryType failed in the lockdownd client.\");\n\t\tret = LOCKDOWN_E_NOT_ENOUGH_DATA;\n\t} else {\n\t\tif (strcmp(\"com.apple.mobile.lockdown\", type)) {\n\t\t\tdebug_info(\"Warning QueryType request returned \\\"%s\\\".\", type);\n\t\t}\n\t}\n\tfree(type);\n\n\tuserpref_read_pair_record(client_loc->udid, &pair_record);\n\tif (pair_record) {\n\t\tpair_record_get_host_id(pair_record, &host_id);\n\t}\n\tif (LOCKDOWN_E_SUCCESS == ret && !host_id) {\n\t\tret = LOCKDOWN_E_INVALID_CONF;\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS == ret && !pair_record) {\n\t\t/* attempt pairing */\n\t\tret = lockdownd_pair(client_loc, NULL);\n\t}\n\n\tplist_free(pair_record);\n\tpair_record = NULL;\n\n\t/* in any case, we need to validate pairing to receive trusted host status */\n\tret = lockdownd_validate_pair(client_loc, NULL);\n\n\t/* if not paired yet, let's do it now */\n\tif (LOCKDOWN_E_INVALID_HOST_ID == ret) {\n\t\tfree(host_id);\n\t\thost_id = NULL;\n\t\tret = lockdownd_pair(client_loc, NULL);\n\t\tif (LOCKDOWN_E_SUCCESS == ret) {\n\t\t\tret = lockdownd_validate_pair(client_loc, NULL);\n\t\t} else if (LOCKDOWN_E_PAIRING_DIALOG_RESPONSE_PENDING == ret) {\n\t\t\tdebug_info(\"Device shows the pairing dialog.\");\n\t\t}\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS == ret) {\n\t\tif (!host_id) {\n\t\t\tuserpref_read_pair_record(client_loc->udid, &pair_record);\n\t\t\tif (pair_record) {\n\t\t\t\tpair_record_get_host_id(pair_record, &host_id);\n\t\t\t\tplist_free(pair_record);\n\t\t\t}\n\t\t}\n\n\t\tret = lockdownd_start_session(client_loc, host_id, NULL, NULL);\n\t\tif (LOCKDOWN_E_SUCCESS != ret) {\n\t\t\tdebug_info(\"Session opening failed.\");\n\t\t}\n\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS == ret) {\n\t\t*client = client_loc;\n\t} else {\n\t\tlockdownd_client_free(client_loc);\n\t}\n\tfree(host_id);\n\treturn ret;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/userpref.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"lockdown.h\"",
            "#include \"property_list_service.h\"",
            "#include <plist/plist.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/x509.h>",
            "#include <libtasn1.h>",
            "#include <openssl/x509v3.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/pem.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/userpref.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"lockdown.h\"\n#include \"property_list_service.h\"\n#include <plist/plist.h>\n#include <gnutls/crypto.h>\n#include <gnutls/x509.h>\n#include <libtasn1.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/pem.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_client_new_with_handshake(idevice_t device, lockdownd_client_t *client, const char *label)\n{\n\tif (!client)\n\t\treturn LOCKDOWN_E_INVALID_ARG;\n\n\tlockdownd_error_t ret = LOCKDOWN_E_SUCCESS;\n\tlockdownd_client_t client_loc = NULL;\n\tplist_t pair_record = NULL;\n\tchar *host_id = NULL;\n\tchar *type = NULL;\n\n\tret = lockdownd_client_new(device, &client_loc, label);\n\tif (LOCKDOWN_E_SUCCESS != ret) {\n\t\tdebug_info(\"failed to create lockdownd client.\");\n\t\treturn ret;\n\t}\n\n\t/* perform handshake */\n\tif (LOCKDOWN_E_SUCCESS != lockdownd_query_type(client_loc, &type)) {\n\t\tdebug_info(\"QueryType failed in the lockdownd client.\");\n\t\tret = LOCKDOWN_E_NOT_ENOUGH_DATA;\n\t} else {\n\t\tif (strcmp(\"com.apple.mobile.lockdown\", type)) {\n\t\t\tdebug_info(\"Warning QueryType request returned \\\"%s\\\".\", type);\n\t\t}\n\t}\n\tfree(type);\n\n\tuserpref_read_pair_record(client_loc->udid, &pair_record);\n\tif (pair_record) {\n\t\tpair_record_get_host_id(pair_record, &host_id);\n\t}\n\tif (LOCKDOWN_E_SUCCESS == ret && !host_id) {\n\t\tret = LOCKDOWN_E_INVALID_CONF;\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS == ret && !pair_record) {\n\t\t/* attempt pairing */\n\t\tret = lockdownd_pair(client_loc, NULL);\n\t}\n\n\tplist_free(pair_record);\n\tpair_record = NULL;\n\n\t/* in any case, we need to validate pairing to receive trusted host status */\n\tret = lockdownd_validate_pair(client_loc, NULL);\n\n\t/* if not paired yet, let's do it now */\n\tif (LOCKDOWN_E_INVALID_HOST_ID == ret) {\n\t\tfree(host_id);\n\t\thost_id = NULL;\n\t\tret = lockdownd_pair(client_loc, NULL);\n\t\tif (LOCKDOWN_E_SUCCESS == ret) {\n\t\t\tret = lockdownd_validate_pair(client_loc, NULL);\n\t\t} else if (LOCKDOWN_E_PAIRING_DIALOG_RESPONSE_PENDING == ret) {\n\t\t\tdebug_info(\"Device shows the pairing dialog.\");\n\t\t}\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS == ret) {\n\t\tif (!host_id) {\n\t\t\tuserpref_read_pair_record(client_loc->udid, &pair_record);\n\t\t\tif (pair_record) {\n\t\t\t\tpair_record_get_host_id(pair_record, &host_id);\n\t\t\t\tplist_free(pair_record);\n\t\t\t}\n\t\t}\n\n\t\tret = lockdownd_start_session(client_loc, host_id, NULL, NULL);\n\t\tif (LOCKDOWN_E_SUCCESS != ret) {\n\t\t\tdebug_info(\"Session opening failed.\");\n\t\t}\n\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS == ret) {\n\t\t*client = client_loc;\n\t} else {\n\t\tlockdownd_client_free(client_loc);\n\t}\n\tfree(host_id);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"service.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API service_error_t service_client_factory_start_service(idevice_t device, const char* service_name, void **client, const char* label, int32_t (*constructor_func)(idevice_t, lockdownd_service_descriptor_t, void**), int32_t *error_code)\n{\n\t*client = NULL;\n\n\tlockdownd_client_t lckd = NULL;\n\tif (LOCKDOWN_E_SUCCESS != lockdownd_client_new_with_handshake(device, &lckd, label)) {\n\t\tdebug_info(\"Could not create a lockdown client.\");\n\t\treturn SERVICE_E_START_SERVICE_ERROR;\n\t}\n\n\tlockdownd_service_descriptor_t service = NULL;\n\tlockdownd_start_service(lckd, service_name, &service);\n\tlockdownd_client_free(lckd);\n\n\tif (!service || service->port == 0) {\n\t\tdebug_info(\"Could not start service %s!\", service_name);\n\t\treturn SERVICE_E_START_SERVICE_ERROR;\n\t}\n\n\tint32_t ec;\n\tif (constructor_func) {\n\t\tec = (int32_t)constructor_func(device, service, client);\n\t} else {\n\t\tec = service_client_new(device, service, (service_client_t*)client);\n\t}\n\tif (error_code) {\n\t\t*error_code = ec;\n\t}\n\n\tif (ec != SERVICE_E_SUCCESS) {\n\t\tdebug_info(\"Could not connect to service %s! Port: %i, error: %i\", service_name, service->port, ec);\n\t}\n\n\tlockdownd_service_descriptor_free(service);\n\tservice = NULL;\n\n\treturn (ec == SERVICE_E_SUCCESS) ? SERVICE_E_SUCCESS : SERVICE_E_START_SERVICE_ERROR;\n}"
  },
  {
    "function_name": "service_client_new",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/service.c",
    "lines": "55-77",
    "snippet": "LIBIMOBILEDEVICE_API service_error_t service_client_new(idevice_t device, lockdownd_service_descriptor_t service, service_client_t *client)\n{\n\tif (!device || !service || service->port == 0 || !client || *client)\n\t\treturn SERVICE_E_INVALID_ARG;\n\n\t/* Attempt connection */\n\tidevice_connection_t connection = NULL;\n\tif (idevice_connect(device, service->port, &connection) != IDEVICE_E_SUCCESS) {\n\t\treturn SERVICE_E_MUX_ERROR;\n\t}\n\n\t/* create client object */\n\tservice_client_t client_loc = (service_client_t)malloc(sizeof(struct service_client_private));\n\tclient_loc->connection = connection;\n\n\t/* enable SSL if requested */\n\tif (service->ssl_enabled == 1)\n\t\tservice_enable_ssl(client_loc);\n\n\t/* all done, return success */\n\t*client = client_loc;\n\treturn SERVICE_E_SUCCESS;\n}",
    "includes": [
      "#include \"common/debug.h\"",
      "#include \"idevice.h\"",
      "#include \"service.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "service_enable_ssl",
          "args": [
            "client_loc"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "service_enable_ssl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/service.c",
          "lines": "177-182",
          "snippet": "LIBIMOBILEDEVICE_API service_error_t service_enable_ssl(service_client_t client)\n{\n\tif (!client || !client->connection)\n\t\treturn SERVICE_E_INVALID_ARG;\n\treturn idevice_to_service_error(idevice_connection_enable_ssl(client->connection));\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"service.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"service.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API service_error_t service_enable_ssl(service_client_t client)\n{\n\tif (!client || !client->connection)\n\t\treturn SERVICE_E_INVALID_ARG;\n\treturn idevice_to_service_error(idevice_connection_enable_ssl(client->connection));\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(struct service_client_private)"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idevice_connect",
          "args": [
            "device",
            "service->port",
            "&connection"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "idevice_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
          "lines": "267-291",
          "snippet": "LIBIMOBILEDEVICE_API idevice_error_t idevice_connect(idevice_t device, uint16_t port, idevice_connection_t *connection)\n{\n\tif (!device) {\n\t\treturn IDEVICE_E_INVALID_ARG;\n\t}\n\n\tif (device->conn_type == CONNECTION_USBMUXD) {\n\t\tint sfd = usbmuxd_connect((uint32_t)(long)device->conn_data, port);\n\t\tif (sfd < 0) {\n\t\t\tdebug_info(\"ERROR: Connecting to usbmuxd failed: %d (%s)\", sfd, strerror(-sfd));\n\t\t\treturn IDEVICE_E_UNKNOWN_ERROR;\n\t\t}\n\t\tidevice_connection_t new_connection = (idevice_connection_t)malloc(sizeof(struct idevice_connection_private));\n\t\tnew_connection->type = CONNECTION_USBMUXD;\n\t\tnew_connection->data = (void*)(long)sfd;\n\t\tnew_connection->ssl_data = NULL;\n\t\tidevice_get_udid(device, &new_connection->udid);\n\t\t*connection = new_connection;\n\t\treturn IDEVICE_E_SUCCESS;\n\t} else {\n\t\tdebug_info(\"Unknown connection type %d\", device->conn_type);\n\t}\n\n\treturn IDEVICE_E_UNKNOWN_ERROR;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"common/thread.h\"",
            "#include \"common/userpref.h\"",
            "#include \"idevice.h\"",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <usbmuxd.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "LIBIMOBILEDEVICE_API idevice_error_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nLIBIMOBILEDEVICE_API idevice_error_t idevice_connect(idevice_t device, uint16_t port, idevice_connection_t *connection)\n{\n\tif (!device) {\n\t\treturn IDEVICE_E_INVALID_ARG;\n\t}\n\n\tif (device->conn_type == CONNECTION_USBMUXD) {\n\t\tint sfd = usbmuxd_connect((uint32_t)(long)device->conn_data, port);\n\t\tif (sfd < 0) {\n\t\t\tdebug_info(\"ERROR: Connecting to usbmuxd failed: %d (%s)\", sfd, strerror(-sfd));\n\t\t\treturn IDEVICE_E_UNKNOWN_ERROR;\n\t\t}\n\t\tidevice_connection_t new_connection = (idevice_connection_t)malloc(sizeof(struct idevice_connection_private));\n\t\tnew_connection->type = CONNECTION_USBMUXD;\n\t\tnew_connection->data = (void*)(long)sfd;\n\t\tnew_connection->ssl_data = NULL;\n\t\tidevice_get_udid(device, &new_connection->udid);\n\t\t*connection = new_connection;\n\t\treturn IDEVICE_E_SUCCESS;\n\t} else {\n\t\tdebug_info(\"Unknown connection type %d\", device->conn_type);\n\t}\n\n\treturn IDEVICE_E_UNKNOWN_ERROR;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"service.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API service_error_t service_client_new(idevice_t device, lockdownd_service_descriptor_t service, service_client_t *client)\n{\n\tif (!device || !service || service->port == 0 || !client || *client)\n\t\treturn SERVICE_E_INVALID_ARG;\n\n\t/* Attempt connection */\n\tidevice_connection_t connection = NULL;\n\tif (idevice_connect(device, service->port, &connection) != IDEVICE_E_SUCCESS) {\n\t\treturn SERVICE_E_MUX_ERROR;\n\t}\n\n\t/* create client object */\n\tservice_client_t client_loc = (service_client_t)malloc(sizeof(struct service_client_private));\n\tclient_loc->connection = connection;\n\n\t/* enable SSL if requested */\n\tif (service->ssl_enabled == 1)\n\t\tservice_enable_ssl(client_loc);\n\n\t/* all done, return success */\n\t*client = client_loc;\n\treturn SERVICE_E_SUCCESS;\n}"
  },
  {
    "function_name": "idevice_to_service_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/service.c",
    "lines": "40-53",
    "snippet": "static service_error_t idevice_to_service_error(idevice_error_t err)\n{\n\tswitch (err) {\n\t\tcase IDEVICE_E_SUCCESS:\n\t\t\treturn SERVICE_E_SUCCESS;\n\t\tcase IDEVICE_E_INVALID_ARG:\n\t\t\treturn SERVICE_E_INVALID_ARG;\n\t\tcase IDEVICE_E_SSL_ERROR:\n\t\t\treturn SERVICE_E_SSL_ERROR;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn SERVICE_E_UNKNOWN_ERROR;\n}",
    "includes": [
      "#include \"common/debug.h\"",
      "#include \"idevice.h\"",
      "#include \"service.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"service.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nstatic service_error_t idevice_to_service_error(idevice_error_t err)\n{\n\tswitch (err) {\n\t\tcase IDEVICE_E_SUCCESS:\n\t\t\treturn SERVICE_E_SUCCESS;\n\t\tcase IDEVICE_E_INVALID_ARG:\n\t\t\treturn SERVICE_E_INVALID_ARG;\n\t\tcase IDEVICE_E_SSL_ERROR:\n\t\t\treturn SERVICE_E_SSL_ERROR;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn SERVICE_E_UNKNOWN_ERROR;\n}"
  }
]