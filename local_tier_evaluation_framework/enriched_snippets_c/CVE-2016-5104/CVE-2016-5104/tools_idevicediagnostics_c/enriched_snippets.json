[
  {
    "function_name": "print_usage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicediagnostics.c",
    "lines": "285-304",
    "snippet": "void print_usage(int argc, char **argv)\n{\n\tchar *name = NULL;\n\tname = strrchr(argv[0], '/');\n\tprintf(\"Usage: %s COMMAND [OPTIONS]\\n\", (name ? name + 1: argv[0]));\n\tprintf(\"Use diagnostics interface of a device running iOS 4 or later.\\n\\n\");\n\tprintf(\" Where COMMAND is one of:\\n\");\n\tprintf(\"  diagnostics [TYPE]\\t\\tprint diagnostics information from device by TYPE (All, WiFi, GasGauge, NAND)\\n\");\n\tprintf(\"  mobilegestalt KEY [...]\\tprint mobilegestalt keys passed as arguments seperated by a space.\\n\");\n\tprintf(\"  ioreg [PLANE]\\t\\t\\tprint IORegistry of device, optionally by PLANE (IODeviceTree, IOPower, IOService) (iOS 5+ only)\\n\");\n\tprintf(\"  shutdown\\t\\t\\tshutdown device\\n\");\n\tprintf(\"  restart\\t\\t\\trestart device\\n\");\n\tprintf(\"  sleep\\t\\t\\t\\tput device into sleep mode (disconnects from host)\\n\\n\");\n\tprintf(\" The following OPTIONS are accepted:\\n\");\n\tprintf(\"  -d, --debug\\t\\tenable communication debugging\\n\");\n\tprintf(\"  -u, --udid UDID\\ttarget specific device by its 40-digit device UDID\\n\");\n\tprintf(\"  -h, --help\\t\\tprints usage information\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"Homepage: <\" PACKAGE_URL \">\\n\");\n}",
    "includes": [
      "#include <libimobiledevice/diagnostics_relay.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <time.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void print_usage(int argc, char **argv);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Homepage: <\" PACKAGE_URL \">\\n\""
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  -h, --help\\t\\tprints usage information\\n\""
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  -u, --udid UDID\\ttarget specific device by its 40-digit device UDID\\n\""
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  -d, --debug\\t\\tenable communication debugging\\n\""
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" The following OPTIONS are accepted:\\n\""
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  sleep\\t\\t\\t\\tput device into sleep mode (disconnects from host)\\n\\n\""
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  restart\\t\\t\\trestart device\\n\""
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  shutdown\\t\\t\\tshutdown device\\n\""
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  ioreg [PLANE]\\t\\t\\tprint IORegistry of device, optionally by PLANE (IODeviceTree, IOPower, IOService) (iOS 5+ only)\\n\""
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  mobilegestalt KEY [...]\\tprint mobilegestalt keys passed as arguments seperated by a space.\\n\""
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  diagnostics [TYPE]\\t\\tprint diagnostics information from device by TYPE (All, WiFi, GasGauge, NAND)\\n\""
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" Where COMMAND is one of:\\n\""
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Use diagnostics interface of a device running iOS 4 or later.\\n\\n\""
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Usage: %s COMMAND [OPTIONS]\\n\"",
            "(name ? name + 1: argv[0])"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "asprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/include/asprintf.h",
          "lines": "23-31",
          "snippet": "static inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}",
          "includes": [
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <config.h>\n\nstatic inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "argv[0]",
            "'/'"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <libimobiledevice/diagnostics_relay.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nvoid print_usage(int argc, char **argv);\n\nvoid print_usage(int argc, char **argv)\n{\n\tchar *name = NULL;\n\tname = strrchr(argv[0], '/');\n\tprintf(\"Usage: %s COMMAND [OPTIONS]\\n\", (name ? name + 1: argv[0]));\n\tprintf(\"Use diagnostics interface of a device running iOS 4 or later.\\n\\n\");\n\tprintf(\" Where COMMAND is one of:\\n\");\n\tprintf(\"  diagnostics [TYPE]\\t\\tprint diagnostics information from device by TYPE (All, WiFi, GasGauge, NAND)\\n\");\n\tprintf(\"  mobilegestalt KEY [...]\\tprint mobilegestalt keys passed as arguments seperated by a space.\\n\");\n\tprintf(\"  ioreg [PLANE]\\t\\t\\tprint IORegistry of device, optionally by PLANE (IODeviceTree, IOPower, IOService) (iOS 5+ only)\\n\");\n\tprintf(\"  shutdown\\t\\t\\tshutdown device\\n\");\n\tprintf(\"  restart\\t\\t\\trestart device\\n\");\n\tprintf(\"  sleep\\t\\t\\t\\tput device into sleep mode (disconnects from host)\\n\\n\");\n\tprintf(\" The following OPTIONS are accepted:\\n\");\n\tprintf(\"  -d, --debug\\t\\tenable communication debugging\\n\");\n\tprintf(\"  -u, --udid UDID\\ttarget specific device by its 40-digit device UDID\\n\");\n\tprintf(\"  -h, --help\\t\\tprints usage information\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"Homepage: <\" PACKAGE_URL \">\\n\");\n}"
  },
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicediagnostics.c",
    "lines": "58-283",
    "snippet": "int main(int argc, char **argv)\n{\n\tidevice_t device = NULL;\n\tlockdownd_client_t lockdown_client = NULL;\n\tdiagnostics_relay_client_t diagnostics_client = NULL;\n\tlockdownd_error_t ret = LOCKDOWN_E_UNKNOWN_ERROR;\n\tlockdownd_service_descriptor_t service = NULL;\n\tint result = -1;\n\tint i;\n\tconst char *udid = NULL;\n\tint cmd = CMD_NONE;\n\tchar* cmd_arg = NULL;\n\tplist_t node = NULL;\n\tplist_t keys = NULL;\n\n\t/* parse cmdline args */\n\tfor (i = 1; i < argc; i++) {\n\t\tif (!strcmp(argv[i], \"-d\") || !strcmp(argv[i], \"--debug\")) {\n\t\t\tidevice_set_debug_level(1);\n\t\t\tcontinue;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"-u\") || !strcmp(argv[i], \"--udid\")) {\n\t\t\ti++;\n\t\t\tif (!argv[i] || (strlen(argv[i]) != 40)) {\n\t\t\t\tprint_usage(argc, argv);\n\t\t\t\tresult = 0;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tudid = argv[i];\n\t\t\tcontinue;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"-h\") || !strcmp(argv[i], \"--help\")) {\n\t\t\tprint_usage(argc, argv);\n\t\t\tresult = 0;\n\t\t\tgoto cleanup;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"sleep\")) {\n\t\t\tcmd = CMD_SLEEP;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"restart\")) {\n\t\t\tcmd = CMD_RESTART;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"shutdown\")) {\n\t\t\tcmd = CMD_SHUTDOWN;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"diagnostics\")) {\n\t\t\tcmd = CMD_DIAGNOSTICS;\n\t\t\t/*  read type */\n\t\t\ti++;\n\t\t\tif (!argv[i] || ((strcmp(argv[i], \"All\") != 0) && (strcmp(argv[i], \"WiFi\") != 0) && (strcmp(argv[i], \"GasGauge\") != 0) && (strcmp(argv[i], \"NAND\") != 0))) {\n\t\t\t\tif (argv[i] == NULL) {\n\t\t\t\t\tcmd_arg = strdup(\"All\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (!strncmp(argv[i], \"-\", 1)) {\n\t\t\t\t\tcmd_arg = strdup(\"All\");\n\t\t\t\t\ti--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tprintf(\"Unknown TYPE %s\\n\", argv[i]);\n\t\t\t\tprint_usage(argc, argv);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\n\t\t\tcmd_arg = strdup(argv[i]);\n\t\t\tcontinue;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"mobilegestalt\")) {\n\t\t\tcmd = CMD_MOBILEGESTALT;\n\t\t\t/*  read keys */\n\t\t\ti++;\n\n\t\t\tif (!argv[i] || argv[i] == NULL || (!strncmp(argv[i], \"-\", 1))) {\n\t\t\t\tprintf(\"Please supply the key to query.\\n\");\n\t\t\t\tprint_usage(argc, argv);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\n\t\t\tkeys = plist_new_array();\n\t\t\twhile(1) {\n\t\t\t\tif (argv[i] && (strlen(argv[i]) >= 2) && (strncmp(argv[i], \"-\", 1) != 0)) {\n\t\t\t\t\tplist_array_append_item(keys, plist_new_string(argv[i]));\n\t\t\t\t\ti++;\n\t\t\t\t} else {\n\t\t\t\t\ti--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"ioreg\")) {\n\t\t\tcmd = CMD_IOREGISTRY;\n\t\t\t/*  read plane */\n\t\t\ti++;\n\t\t\tif (argv[i]) {\n\t\t\t\tcmd_arg = strdup(argv[i]);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\telse {\n\t\t\tprint_usage(argc, argv);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* verify options */\n\tif (cmd == CMD_NONE) {\n\t\tprint_usage(argc, argv);\n\t\tgoto cleanup;\n\t}\n\n\tif (IDEVICE_E_SUCCESS != idevice_new(&device, udid)) {\n\t\tif (udid) {\n\t\t\tprintf(\"No device found with udid %s, is it plugged in?\\n\", udid);\n\t\t} else {\n\t\t\tprintf(\"No device found, is it plugged in?\\n\");\n\t\t}\n\t\tgoto cleanup;\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS != (ret = lockdownd_client_new_with_handshake(device, &lockdown_client, \"idevicediagnostics\"))) {\n\t\tidevice_free(device);\n\t\tprintf(\"ERROR: Could not connect to lockdownd, error code %d\\n\", ret);\n\t\tgoto cleanup;\n\t}\n\n\t/*  attempt to use newer diagnostics service available on iOS 5 and later */\n\tret = lockdownd_start_service(lockdown_client, \"com.apple.mobile.diagnostics_relay\", &service);\n\tif (ret != LOCKDOWN_E_SUCCESS) {\n\t\t/*  attempt to use older diagnostics service */\n\t\tret = lockdownd_start_service(lockdown_client, \"com.apple.iosdiagnostics.relay\", &service);\n\t}\n\n\tlockdownd_client_free(lockdown_client);\n\n\tif ((ret == LOCKDOWN_E_SUCCESS) && service && (service->port > 0)) {\n\t\tif (diagnostics_relay_client_new(device, service, &diagnostics_client) != DIAGNOSTICS_RELAY_E_SUCCESS) {\n\t\t\tprintf(\"Could not connect to diagnostics_relay!\\n\");\n\t\t\tresult = -1;\n\t\t} else {\n\t\t\tswitch (cmd) {\n\t\t\t\tcase CMD_SLEEP:\n\t\t\t\t\tif (diagnostics_relay_sleep(diagnostics_client) == DIAGNOSTICS_RELAY_E_SUCCESS) {\n\t\t\t\t\t\tprintf(\"Putting device into deep sleep mode.\\n\");\n\t\t\t\t\t\tresult = EXIT_SUCCESS;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprintf(\"Failed to put device into deep sleep mode.\\n\");\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\tcase CMD_RESTART:\n\t\t\t\t\tif (diagnostics_relay_restart(diagnostics_client, DIAGNOSTICS_RELAY_ACTION_FLAG_WAIT_FOR_DISCONNECT) == DIAGNOSTICS_RELAY_E_SUCCESS) {\n\t\t\t\t\t\tprintf(\"Restarting device.\\n\");\n\t\t\t\t\t\tresult = EXIT_SUCCESS;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprintf(\"Failed to restart device.\\n\");\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\tcase CMD_SHUTDOWN:\n\t\t\t\t\tif (diagnostics_relay_shutdown(diagnostics_client, DIAGNOSTICS_RELAY_ACTION_FLAG_WAIT_FOR_DISCONNECT) == DIAGNOSTICS_RELAY_E_SUCCESS) {\n\t\t\t\t\t\tprintf(\"Shutting down device.\\n\");\n\t\t\t\t\t\tresult = EXIT_SUCCESS;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprintf(\"Failed to shutdown device.\\n\");\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\tcase CMD_MOBILEGESTALT:\n\t\t\t\t\tif (diagnostics_relay_query_mobilegestalt(diagnostics_client, keys, &node) == DIAGNOSTICS_RELAY_E_SUCCESS) {\n\t\t\t\t\t\tif (node) {\n\t\t\t\t\t\t\tprint_xml(node);\n\t\t\t\t\t\t\tresult = EXIT_SUCCESS;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprintf(\"Unable to query mobilegestalt keys.\\n\");\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\tcase CMD_IOREGISTRY:\n\t\t\t\t\tif (diagnostics_relay_query_ioregistry_plane(diagnostics_client, cmd_arg == NULL ? \"\": cmd_arg, &node) == DIAGNOSTICS_RELAY_E_SUCCESS) {\n\t\t\t\t\t\tif (node) {\n\t\t\t\t\t\t\tprint_xml(node);\n\t\t\t\t\t\t\tresult = EXIT_SUCCESS;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprintf(\"Unable to retrieve IORegistry from device.\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase CMD_DIAGNOSTICS:\n\t\t\t\tdefault:\n\t\t\t\t\tif (diagnostics_relay_request_diagnostics(diagnostics_client, cmd_arg, &node) == DIAGNOSTICS_RELAY_E_SUCCESS) {\n\t\t\t\t\t\tif (node) {\n\t\t\t\t\t\t\tprint_xml(node);\n\t\t\t\t\t\t\tresult = EXIT_SUCCESS;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprintf(\"Unable to retrieve diagnostics from device.\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdiagnostics_relay_goodbye(diagnostics_client);\n\t\t\tdiagnostics_relay_client_free(diagnostics_client);\n\t\t}\n\t} else {\n\t\tprintf(\"Could not start diagnostics service!\\n\");\n\t}\n\n\tif (service) {\n\t\tlockdownd_service_descriptor_free(service);\n\t\tservice = NULL;\n\t}\n\n\tidevice_free(device);\n\ncleanup:\n\tif (node) {\n\t\tplist_free(node);\n\t}\n\tif (keys) {\n\t\tplist_free(keys);\n\t}\n\tif (cmd_arg) {\n\t\tfree(cmd_arg);\n\t}\n\treturn result;\n}",
    "includes": [
      "#include <libimobiledevice/diagnostics_relay.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <time.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void print_usage(int argc, char **argv);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cmd_arg"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "thread_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "39-44",
          "snippet": "void thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nvoid thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_free",
          "args": [
            "keys"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_free",
          "args": [
            "node"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idevice_free",
          "args": [
            "device"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "idevice_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
          "lines": "247-265",
          "snippet": "LIBIMOBILEDEVICE_API idevice_error_t idevice_free(idevice_t device)\n{\n\tif (!device)\n\t\treturn IDEVICE_E_INVALID_ARG;\n\tidevice_error_t ret = IDEVICE_E_UNKNOWN_ERROR;\n\n\tret = IDEVICE_E_SUCCESS;\n\n\tfree(device->udid);\n\n\tif (device->conn_type == CONNECTION_USBMUXD) {\n\t\tdevice->conn_data = 0;\n\t}\n\tif (device->conn_data) {\n\t\tfree(device->conn_data);\n\t}\n\tfree(device);\n\treturn ret;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"common/thread.h\"",
            "#include \"common/userpref.h\"",
            "#include \"idevice.h\"",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <usbmuxd.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "LIBIMOBILEDEVICE_API idevice_error_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nLIBIMOBILEDEVICE_API idevice_error_t idevice_free(idevice_t device)\n{\n\tif (!device)\n\t\treturn IDEVICE_E_INVALID_ARG;\n\tidevice_error_t ret = IDEVICE_E_UNKNOWN_ERROR;\n\n\tret = IDEVICE_E_SUCCESS;\n\n\tfree(device->udid);\n\n\tif (device->conn_type == CONNECTION_USBMUXD) {\n\t\tdevice->conn_data = 0;\n\t}\n\tif (device->conn_data) {\n\t\tfree(device->conn_data);\n\t}\n\tfree(device);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdownd_service_descriptor_free",
          "args": [
            "service"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "lockdownd_service_descriptor_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/lockdown.c",
          "lines": "1522-1528",
          "snippet": "LIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_service_descriptor_free(lockdownd_service_descriptor_t service)\n{\n\tif (service)\n\t\tfree(service);\n\n\treturn LOCKDOWN_E_SUCCESS;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/userpref.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"lockdown.h\"",
            "#include \"property_list_service.h\"",
            "#include <plist/plist.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/x509.h>",
            "#include <libtasn1.h>",
            "#include <openssl/x509v3.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/pem.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/userpref.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"lockdown.h\"\n#include \"property_list_service.h\"\n#include <plist/plist.h>\n#include <gnutls/crypto.h>\n#include <gnutls/x509.h>\n#include <libtasn1.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/pem.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_service_descriptor_free(lockdownd_service_descriptor_t service)\n{\n\tif (service)\n\t\tfree(service);\n\n\treturn LOCKDOWN_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Could not start diagnostics service!\\n\""
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "diagnostics_relay_client_free",
          "args": [
            "diagnostics_client"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "diagnostics_relay_client_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/diagnostics_relay.c",
          "lines": "99-108",
          "snippet": "LIBIMOBILEDEVICE_API diagnostics_relay_error_t diagnostics_relay_client_free(diagnostics_relay_client_t client)\n{\n\tif (!client)\n\t\treturn DIAGNOSTICS_RELAY_E_INVALID_ARG;\n\n\tif (property_list_service_client_free(client->parent) != PROPERTY_LIST_SERVICE_E_SUCCESS) {\n\t\treturn DIAGNOSTICS_RELAY_E_UNKNOWN_ERROR;\n\t}\n\treturn DIAGNOSTICS_RELAY_E_SUCCESS;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"property_list_service.h\"",
            "#include \"diagnostics_relay.h\"",
            "#include <stdlib.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"property_list_service.h\"\n#include \"diagnostics_relay.h\"\n#include <stdlib.h>\n#include <string.h>\n\nLIBIMOBILEDEVICE_API diagnostics_relay_error_t diagnostics_relay_client_free(diagnostics_relay_client_t client)\n{\n\tif (!client)\n\t\treturn DIAGNOSTICS_RELAY_E_INVALID_ARG;\n\n\tif (property_list_service_client_free(client->parent) != PROPERTY_LIST_SERVICE_E_SUCCESS) {\n\t\treturn DIAGNOSTICS_RELAY_E_UNKNOWN_ERROR;\n\t}\n\treturn DIAGNOSTICS_RELAY_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "diagnostics_relay_goodbye",
          "args": [
            "diagnostics_client"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "diagnostics_relay_goodbye",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/diagnostics_relay.c",
          "lines": "165-197",
          "snippet": "LIBIMOBILEDEVICE_API diagnostics_relay_error_t diagnostics_relay_goodbye(diagnostics_relay_client_t client)\n{\n\tif (!client)\n\t\treturn DIAGNOSTICS_RELAY_E_INVALID_ARG;\n\n\tdiagnostics_relay_error_t ret = DIAGNOSTICS_RELAY_E_UNKNOWN_ERROR;\n\n\tplist_t dict = plist_new_dict();\n\tplist_dict_set_item(dict, \"Request\", plist_new_string(\"Goodbye\"));\n\n\tret = diagnostics_relay_send(client, dict);\n\tplist_free(dict);\n\tdict = NULL;\n\n\tret = diagnostics_relay_receive(client, &dict);\n\tif (!dict) {\n\t\tdebug_info(\"did not get goodbye response back\");\n\t\treturn DIAGNOSTICS_RELAY_E_PLIST_ERROR;\n\t}\n\n\tint check = diagnostics_relay_check_result(dict);\n\tif (check == RESULT_SUCCESS) {\n\t\tret = DIAGNOSTICS_RELAY_E_SUCCESS;\n\t} else if (check == RESULT_UNKNOWN_REQUEST) {\n\t\tret = DIAGNOSTICS_RELAY_E_UNKNOWN_REQUEST;\n\t} else {\n\t\tret = DIAGNOSTICS_RELAY_E_UNKNOWN_ERROR;\n\t}\n\n\tplist_free(dict);\n\tdict = NULL;\n\treturn ret;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"property_list_service.h\"",
            "#include \"diagnostics_relay.h\"",
            "#include <stdlib.h>",
            "#include <string.h>"
          ],
          "macros_used": [
            "#define RESULT_UNKNOWN_REQUEST 2",
            "#define RESULT_SUCCESS 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"property_list_service.h\"\n#include \"diagnostics_relay.h\"\n#include <stdlib.h>\n#include <string.h>\n\n#define RESULT_UNKNOWN_REQUEST 2\n#define RESULT_SUCCESS 0\n\nLIBIMOBILEDEVICE_API diagnostics_relay_error_t diagnostics_relay_goodbye(diagnostics_relay_client_t client)\n{\n\tif (!client)\n\t\treturn DIAGNOSTICS_RELAY_E_INVALID_ARG;\n\n\tdiagnostics_relay_error_t ret = DIAGNOSTICS_RELAY_E_UNKNOWN_ERROR;\n\n\tplist_t dict = plist_new_dict();\n\tplist_dict_set_item(dict, \"Request\", plist_new_string(\"Goodbye\"));\n\n\tret = diagnostics_relay_send(client, dict);\n\tplist_free(dict);\n\tdict = NULL;\n\n\tret = diagnostics_relay_receive(client, &dict);\n\tif (!dict) {\n\t\tdebug_info(\"did not get goodbye response back\");\n\t\treturn DIAGNOSTICS_RELAY_E_PLIST_ERROR;\n\t}\n\n\tint check = diagnostics_relay_check_result(dict);\n\tif (check == RESULT_SUCCESS) {\n\t\tret = DIAGNOSTICS_RELAY_E_SUCCESS;\n\t} else if (check == RESULT_UNKNOWN_REQUEST) {\n\t\tret = DIAGNOSTICS_RELAY_E_UNKNOWN_REQUEST;\n\t} else {\n\t\tret = DIAGNOSTICS_RELAY_E_UNKNOWN_ERROR;\n\t}\n\n\tplist_free(dict);\n\tdict = NULL;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Unable to retrieve diagnostics from device.\\n\""
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_xml",
          "args": [
            "node"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "print_xml",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicediagnostics.c",
          "lines": "46-54",
          "snippet": "static void print_xml(plist_t node)\n{\n\tchar *xml = NULL;\n\tuint32_t len = 0;\n\tplist_to_xml(node, &xml, &len);\n\tif (xml) {\n\t\tputs(xml);\n\t}\n}",
          "includes": [
            "#include <libimobiledevice/diagnostics_relay.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libimobiledevice/diagnostics_relay.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void print_xml(plist_t node)\n{\n\tchar *xml = NULL;\n\tuint32_t len = 0;\n\tplist_to_xml(node, &xml, &len);\n\tif (xml) {\n\t\tputs(xml);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "diagnostics_relay_request_diagnostics",
          "args": [
            "diagnostics_client",
            "cmd_arg",
            "&node"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "diagnostics_relay_request_diagnostics",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/diagnostics_relay.c",
          "lines": "285-324",
          "snippet": "LIBIMOBILEDEVICE_API diagnostics_relay_error_t diagnostics_relay_request_diagnostics(diagnostics_relay_client_t client, const char* type, plist_t* diagnostics)\n{\n\tif (!client || diagnostics == NULL)\n\t\treturn DIAGNOSTICS_RELAY_E_INVALID_ARG;\n\n\tdiagnostics_relay_error_t ret = DIAGNOSTICS_RELAY_E_UNKNOWN_ERROR;\n\n\tplist_t dict = plist_new_dict();\n\tplist_dict_set_item(dict,\"Request\", plist_new_string(type));\n\tret = diagnostics_relay_send(client, dict);\n\tplist_free(dict);\n\tdict = NULL;\n\n\tret = diagnostics_relay_receive(client, &dict);\n\tif (!dict) {\n\t\treturn DIAGNOSTICS_RELAY_E_PLIST_ERROR;\n\t}\n\n\tint check = diagnostics_relay_check_result(dict);\n\tif (check == RESULT_SUCCESS) {\n\t\tret = DIAGNOSTICS_RELAY_E_SUCCESS;\n\t} else if (check == RESULT_UNKNOWN_REQUEST) {\n\t\tret = DIAGNOSTICS_RELAY_E_UNKNOWN_REQUEST;\n\t} else {\n\t\tret = DIAGNOSTICS_RELAY_E_UNKNOWN_ERROR;\n\t}\n\n\tif (ret != DIAGNOSTICS_RELAY_E_SUCCESS) {\n\t\tplist_free(dict);\n\t\treturn ret;\n\t}\n\n\tplist_t value_node = plist_dict_get_item(dict, \"Diagnostics\");\n\tif (value_node) {\n\t\t*diagnostics = plist_copy(value_node);\n\t}\n\n\tplist_free(dict);\n\treturn ret;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"property_list_service.h\"",
            "#include \"diagnostics_relay.h\"",
            "#include <stdlib.h>",
            "#include <string.h>"
          ],
          "macros_used": [
            "#define RESULT_UNKNOWN_REQUEST 2",
            "#define RESULT_SUCCESS 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"property_list_service.h\"\n#include \"diagnostics_relay.h\"\n#include <stdlib.h>\n#include <string.h>\n\n#define RESULT_UNKNOWN_REQUEST 2\n#define RESULT_SUCCESS 0\n\nLIBIMOBILEDEVICE_API diagnostics_relay_error_t diagnostics_relay_request_diagnostics(diagnostics_relay_client_t client, const char* type, plist_t* diagnostics)\n{\n\tif (!client || diagnostics == NULL)\n\t\treturn DIAGNOSTICS_RELAY_E_INVALID_ARG;\n\n\tdiagnostics_relay_error_t ret = DIAGNOSTICS_RELAY_E_UNKNOWN_ERROR;\n\n\tplist_t dict = plist_new_dict();\n\tplist_dict_set_item(dict,\"Request\", plist_new_string(type));\n\tret = diagnostics_relay_send(client, dict);\n\tplist_free(dict);\n\tdict = NULL;\n\n\tret = diagnostics_relay_receive(client, &dict);\n\tif (!dict) {\n\t\treturn DIAGNOSTICS_RELAY_E_PLIST_ERROR;\n\t}\n\n\tint check = diagnostics_relay_check_result(dict);\n\tif (check == RESULT_SUCCESS) {\n\t\tret = DIAGNOSTICS_RELAY_E_SUCCESS;\n\t} else if (check == RESULT_UNKNOWN_REQUEST) {\n\t\tret = DIAGNOSTICS_RELAY_E_UNKNOWN_REQUEST;\n\t} else {\n\t\tret = DIAGNOSTICS_RELAY_E_UNKNOWN_ERROR;\n\t}\n\n\tif (ret != DIAGNOSTICS_RELAY_E_SUCCESS) {\n\t\tplist_free(dict);\n\t\treturn ret;\n\t}\n\n\tplist_t value_node = plist_dict_get_item(dict, \"Diagnostics\");\n\tif (value_node) {\n\t\t*diagnostics = plist_copy(value_node);\n\t}\n\n\tplist_free(dict);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Unable to retrieve IORegistry from device.\\n\""
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "diagnostics_relay_query_ioregistry_plane",
          "args": [
            "diagnostics_client",
            "cmd_arg == NULL ? \"\": cmd_arg",
            "&node"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "diagnostics_relay_query_ioregistry_plane",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/diagnostics_relay.c",
          "lines": "413-453",
          "snippet": "LIBIMOBILEDEVICE_API diagnostics_relay_error_t diagnostics_relay_query_ioregistry_plane(diagnostics_relay_client_t client, const char* plane, plist_t* result)\n{\n\tif (!client || plane == NULL || result == NULL)\n\t\treturn DIAGNOSTICS_RELAY_E_INVALID_ARG;\n\n\tdiagnostics_relay_error_t ret = DIAGNOSTICS_RELAY_E_UNKNOWN_ERROR;\n\n\tplist_t dict = plist_new_dict();\n\tplist_dict_set_item(dict,\"CurrentPlane\", plist_new_string(plane));\n\tplist_dict_set_item(dict,\"Request\", plist_new_string(\"IORegistry\"));\n\tret = diagnostics_relay_send(client, dict);\n\tplist_free(dict);\n\tdict = NULL;\n\n\tret = diagnostics_relay_receive(client, &dict);\n\tif (!dict) {\n\t\treturn DIAGNOSTICS_RELAY_E_PLIST_ERROR;\n\t}\n\n\tint check = diagnostics_relay_check_result(dict);\n\tif (check == RESULT_SUCCESS) {\n\t\tret = DIAGNOSTICS_RELAY_E_SUCCESS;\n\t} else if (check == RESULT_UNKNOWN_REQUEST) {\n\t\tret = DIAGNOSTICS_RELAY_E_UNKNOWN_REQUEST;\n\t} else {\n\t\tret = DIAGNOSTICS_RELAY_E_UNKNOWN_ERROR;\n\t}\n\n\tif (ret != DIAGNOSTICS_RELAY_E_SUCCESS) {\n\t\tplist_free(dict);\n\t\treturn ret;\n\t}\n\n\tplist_t value_node = plist_dict_get_item(dict, \"Diagnostics\");\n\tif (value_node) {\n\t\t*result = plist_copy(value_node);\n\t}\n\n\tplist_free(dict);\n\treturn ret;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"property_list_service.h\"",
            "#include \"diagnostics_relay.h\"",
            "#include <stdlib.h>",
            "#include <string.h>"
          ],
          "macros_used": [
            "#define RESULT_UNKNOWN_REQUEST 2",
            "#define RESULT_SUCCESS 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"property_list_service.h\"\n#include \"diagnostics_relay.h\"\n#include <stdlib.h>\n#include <string.h>\n\n#define RESULT_UNKNOWN_REQUEST 2\n#define RESULT_SUCCESS 0\n\nLIBIMOBILEDEVICE_API diagnostics_relay_error_t diagnostics_relay_query_ioregistry_plane(diagnostics_relay_client_t client, const char* plane, plist_t* result)\n{\n\tif (!client || plane == NULL || result == NULL)\n\t\treturn DIAGNOSTICS_RELAY_E_INVALID_ARG;\n\n\tdiagnostics_relay_error_t ret = DIAGNOSTICS_RELAY_E_UNKNOWN_ERROR;\n\n\tplist_t dict = plist_new_dict();\n\tplist_dict_set_item(dict,\"CurrentPlane\", plist_new_string(plane));\n\tplist_dict_set_item(dict,\"Request\", plist_new_string(\"IORegistry\"));\n\tret = diagnostics_relay_send(client, dict);\n\tplist_free(dict);\n\tdict = NULL;\n\n\tret = diagnostics_relay_receive(client, &dict);\n\tif (!dict) {\n\t\treturn DIAGNOSTICS_RELAY_E_PLIST_ERROR;\n\t}\n\n\tint check = diagnostics_relay_check_result(dict);\n\tif (check == RESULT_SUCCESS) {\n\t\tret = DIAGNOSTICS_RELAY_E_SUCCESS;\n\t} else if (check == RESULT_UNKNOWN_REQUEST) {\n\t\tret = DIAGNOSTICS_RELAY_E_UNKNOWN_REQUEST;\n\t} else {\n\t\tret = DIAGNOSTICS_RELAY_E_UNKNOWN_ERROR;\n\t}\n\n\tif (ret != DIAGNOSTICS_RELAY_E_SUCCESS) {\n\t\tplist_free(dict);\n\t\treturn ret;\n\t}\n\n\tplist_t value_node = plist_dict_get_item(dict, \"Diagnostics\");\n\tif (value_node) {\n\t\t*result = plist_copy(value_node);\n\t}\n\n\tplist_free(dict);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Unable to query mobilegestalt keys.\\n\""
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "diagnostics_relay_query_mobilegestalt",
          "args": [
            "diagnostics_client",
            "keys",
            "&node"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "diagnostics_relay_query_mobilegestalt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/diagnostics_relay.c",
          "lines": "326-366",
          "snippet": "LIBIMOBILEDEVICE_API diagnostics_relay_error_t diagnostics_relay_query_mobilegestalt(diagnostics_relay_client_t client, plist_t keys, plist_t* result)\n{\n\tif (!client || plist_get_node_type(keys) != PLIST_ARRAY || result == NULL)\n\t\treturn DIAGNOSTICS_RELAY_E_INVALID_ARG;\n\n\tdiagnostics_relay_error_t ret = DIAGNOSTICS_RELAY_E_UNKNOWN_ERROR;\n\n\tplist_t dict = plist_new_dict();\n\tplist_dict_set_item(dict,\"MobileGestaltKeys\", plist_copy(keys));\n\tplist_dict_set_item(dict,\"Request\", plist_new_string(\"MobileGestalt\"));\n\tret = diagnostics_relay_send(client, dict);\n\tplist_free(dict);\n\tdict = NULL;\n\n\tret = diagnostics_relay_receive(client, &dict);\n\tif (!dict) {\n\t\treturn DIAGNOSTICS_RELAY_E_PLIST_ERROR;\n\t}\n\n\tint check = diagnostics_relay_check_result(dict);\n\tif (check == RESULT_SUCCESS) {\n\t\tret = DIAGNOSTICS_RELAY_E_SUCCESS;\n\t} else if (check == RESULT_UNKNOWN_REQUEST) {\n\t\tret = DIAGNOSTICS_RELAY_E_UNKNOWN_REQUEST;\n\t} else {\n\t\tret = DIAGNOSTICS_RELAY_E_UNKNOWN_ERROR;\n\t}\n\n\tif (ret != DIAGNOSTICS_RELAY_E_SUCCESS) {\n\t\tplist_free(dict);\n\t\treturn ret;\n\t}\n\n\tplist_t value_node = plist_dict_get_item(dict, \"Diagnostics\");\n\tif (value_node) {\n\t\t*result = plist_copy(value_node);\n\t}\n\n\tplist_free(dict);\n\treturn ret;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"property_list_service.h\"",
            "#include \"diagnostics_relay.h\"",
            "#include <stdlib.h>",
            "#include <string.h>"
          ],
          "macros_used": [
            "#define RESULT_UNKNOWN_REQUEST 2",
            "#define RESULT_SUCCESS 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"property_list_service.h\"\n#include \"diagnostics_relay.h\"\n#include <stdlib.h>\n#include <string.h>\n\n#define RESULT_UNKNOWN_REQUEST 2\n#define RESULT_SUCCESS 0\n\nLIBIMOBILEDEVICE_API diagnostics_relay_error_t diagnostics_relay_query_mobilegestalt(diagnostics_relay_client_t client, plist_t keys, plist_t* result)\n{\n\tif (!client || plist_get_node_type(keys) != PLIST_ARRAY || result == NULL)\n\t\treturn DIAGNOSTICS_RELAY_E_INVALID_ARG;\n\n\tdiagnostics_relay_error_t ret = DIAGNOSTICS_RELAY_E_UNKNOWN_ERROR;\n\n\tplist_t dict = plist_new_dict();\n\tplist_dict_set_item(dict,\"MobileGestaltKeys\", plist_copy(keys));\n\tplist_dict_set_item(dict,\"Request\", plist_new_string(\"MobileGestalt\"));\n\tret = diagnostics_relay_send(client, dict);\n\tplist_free(dict);\n\tdict = NULL;\n\n\tret = diagnostics_relay_receive(client, &dict);\n\tif (!dict) {\n\t\treturn DIAGNOSTICS_RELAY_E_PLIST_ERROR;\n\t}\n\n\tint check = diagnostics_relay_check_result(dict);\n\tif (check == RESULT_SUCCESS) {\n\t\tret = DIAGNOSTICS_RELAY_E_SUCCESS;\n\t} else if (check == RESULT_UNKNOWN_REQUEST) {\n\t\tret = DIAGNOSTICS_RELAY_E_UNKNOWN_REQUEST;\n\t} else {\n\t\tret = DIAGNOSTICS_RELAY_E_UNKNOWN_ERROR;\n\t}\n\n\tif (ret != DIAGNOSTICS_RELAY_E_SUCCESS) {\n\t\tplist_free(dict);\n\t\treturn ret;\n\t}\n\n\tplist_t value_node = plist_dict_get_item(dict, \"Diagnostics\");\n\tif (value_node) {\n\t\t*result = plist_copy(value_node);\n\t}\n\n\tplist_free(dict);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Failed to shutdown device.\\n\""
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Shutting down device.\\n\""
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "diagnostics_relay_shutdown",
          "args": [
            "diagnostics_client",
            "DIAGNOSTICS_RELAY_ACTION_FLAG_WAIT_FOR_DISCONNECT"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "diagnostics_relay_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/diagnostics_relay.c",
          "lines": "280-283",
          "snippet": "LIBIMOBILEDEVICE_API diagnostics_relay_error_t diagnostics_relay_shutdown(diagnostics_relay_client_t client, int flags)\n{\n\treturn internal_diagnostics_relay_action(client, \"Shutdown\", flags);\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"property_list_service.h\"",
            "#include \"diagnostics_relay.h\"",
            "#include <stdlib.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"property_list_service.h\"\n#include \"diagnostics_relay.h\"\n#include <stdlib.h>\n#include <string.h>\n\nLIBIMOBILEDEVICE_API diagnostics_relay_error_t diagnostics_relay_shutdown(diagnostics_relay_client_t client, int flags)\n{\n\treturn internal_diagnostics_relay_action(client, \"Shutdown\", flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Failed to restart device.\\n\""
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Restarting device.\\n\""
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "diagnostics_relay_restart",
          "args": [
            "diagnostics_client",
            "DIAGNOSTICS_RELAY_ACTION_FLAG_WAIT_FOR_DISCONNECT"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "diagnostics_relay_restart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/diagnostics_relay.c",
          "lines": "275-278",
          "snippet": "LIBIMOBILEDEVICE_API diagnostics_relay_error_t diagnostics_relay_restart(diagnostics_relay_client_t client, int flags)\n{\n\treturn internal_diagnostics_relay_action(client, \"Restart\", flags);\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"property_list_service.h\"",
            "#include \"diagnostics_relay.h\"",
            "#include <stdlib.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"property_list_service.h\"\n#include \"diagnostics_relay.h\"\n#include <stdlib.h>\n#include <string.h>\n\nLIBIMOBILEDEVICE_API diagnostics_relay_error_t diagnostics_relay_restart(diagnostics_relay_client_t client, int flags)\n{\n\treturn internal_diagnostics_relay_action(client, \"Restart\", flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Failed to put device into deep sleep mode.\\n\""
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Putting device into deep sleep mode.\\n\""
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "diagnostics_relay_sleep",
          "args": [
            "diagnostics_client"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "diagnostics_relay_sleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/diagnostics_relay.c",
          "lines": "199-229",
          "snippet": "LIBIMOBILEDEVICE_API diagnostics_relay_error_t diagnostics_relay_sleep(diagnostics_relay_client_t client)\n{\n\tif (!client)\n\t\treturn DIAGNOSTICS_RELAY_E_INVALID_ARG;\n\n\tdiagnostics_relay_error_t ret = DIAGNOSTICS_RELAY_E_UNKNOWN_ERROR;\n\n\tplist_t dict = plist_new_dict();\n\n\tplist_dict_set_item(dict,\"Request\", plist_new_string(\"Sleep\"));\n\tret = diagnostics_relay_send(client, dict);\n\tplist_free(dict);\n\tdict = NULL;\n\n\tret = diagnostics_relay_receive(client, &dict);\n\tif (!dict) {\n\t\treturn DIAGNOSTICS_RELAY_E_PLIST_ERROR;\n\t}\n\n\tint check = diagnostics_relay_check_result(dict);\n\tif (check == RESULT_SUCCESS) {\n\t\tret = DIAGNOSTICS_RELAY_E_SUCCESS;\n\t} else if (check == RESULT_UNKNOWN_REQUEST) {\n\t\tret = DIAGNOSTICS_RELAY_E_UNKNOWN_REQUEST;\n\t} else {\n\t\tret = DIAGNOSTICS_RELAY_E_UNKNOWN_ERROR;\n\t}\n\n\tplist_free(dict);\n\treturn ret;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"property_list_service.h\"",
            "#include \"diagnostics_relay.h\"",
            "#include <stdlib.h>",
            "#include <string.h>"
          ],
          "macros_used": [
            "#define RESULT_UNKNOWN_REQUEST 2",
            "#define RESULT_SUCCESS 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"property_list_service.h\"\n#include \"diagnostics_relay.h\"\n#include <stdlib.h>\n#include <string.h>\n\n#define RESULT_UNKNOWN_REQUEST 2\n#define RESULT_SUCCESS 0\n\nLIBIMOBILEDEVICE_API diagnostics_relay_error_t diagnostics_relay_sleep(diagnostics_relay_client_t client)\n{\n\tif (!client)\n\t\treturn DIAGNOSTICS_RELAY_E_INVALID_ARG;\n\n\tdiagnostics_relay_error_t ret = DIAGNOSTICS_RELAY_E_UNKNOWN_ERROR;\n\n\tplist_t dict = plist_new_dict();\n\n\tplist_dict_set_item(dict,\"Request\", plist_new_string(\"Sleep\"));\n\tret = diagnostics_relay_send(client, dict);\n\tplist_free(dict);\n\tdict = NULL;\n\n\tret = diagnostics_relay_receive(client, &dict);\n\tif (!dict) {\n\t\treturn DIAGNOSTICS_RELAY_E_PLIST_ERROR;\n\t}\n\n\tint check = diagnostics_relay_check_result(dict);\n\tif (check == RESULT_SUCCESS) {\n\t\tret = DIAGNOSTICS_RELAY_E_SUCCESS;\n\t} else if (check == RESULT_UNKNOWN_REQUEST) {\n\t\tret = DIAGNOSTICS_RELAY_E_UNKNOWN_REQUEST;\n\t} else {\n\t\tret = DIAGNOSTICS_RELAY_E_UNKNOWN_ERROR;\n\t}\n\n\tplist_free(dict);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Could not connect to diagnostics_relay!\\n\""
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "diagnostics_relay_client_new",
          "args": [
            "device",
            "service",
            "&diagnostics_client"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "diagnostics_relay_client_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/diagnostics_relay.c",
          "lines": "72-90",
          "snippet": "LIBIMOBILEDEVICE_API diagnostics_relay_error_t diagnostics_relay_client_new(idevice_t device, lockdownd_service_descriptor_t service, diagnostics_relay_client_t *client)\n{\n\tif (!device || !service || service->port == 0 || !client || *client) {\n\t\treturn DIAGNOSTICS_RELAY_E_INVALID_ARG;\n\t}\n\n\tproperty_list_service_client_t plistclient = NULL;\n\tif (property_list_service_client_new(device, service, &plistclient) != PROPERTY_LIST_SERVICE_E_SUCCESS) {\n\t\treturn DIAGNOSTICS_RELAY_E_MUX_ERROR;\n\t}\n\n\t/* create client object */\n\tdiagnostics_relay_client_t client_loc = (diagnostics_relay_client_t) malloc(sizeof(struct diagnostics_relay_client_private));\n\tclient_loc->parent = plistclient;\n\n\t/* all done, return success */\n\t*client = client_loc;\n\treturn DIAGNOSTICS_RELAY_E_SUCCESS;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"property_list_service.h\"",
            "#include \"diagnostics_relay.h\"",
            "#include <stdlib.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"property_list_service.h\"\n#include \"diagnostics_relay.h\"\n#include <stdlib.h>\n#include <string.h>\n\nLIBIMOBILEDEVICE_API diagnostics_relay_error_t diagnostics_relay_client_new(idevice_t device, lockdownd_service_descriptor_t service, diagnostics_relay_client_t *client)\n{\n\tif (!device || !service || service->port == 0 || !client || *client) {\n\t\treturn DIAGNOSTICS_RELAY_E_INVALID_ARG;\n\t}\n\n\tproperty_list_service_client_t plistclient = NULL;\n\tif (property_list_service_client_new(device, service, &plistclient) != PROPERTY_LIST_SERVICE_E_SUCCESS) {\n\t\treturn DIAGNOSTICS_RELAY_E_MUX_ERROR;\n\t}\n\n\t/* create client object */\n\tdiagnostics_relay_client_t client_loc = (diagnostics_relay_client_t) malloc(sizeof(struct diagnostics_relay_client_private));\n\tclient_loc->parent = plistclient;\n\n\t/* all done, return success */\n\t*client = client_loc;\n\treturn DIAGNOSTICS_RELAY_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdownd_client_free",
          "args": [
            "lockdown_client"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "lockdownd_client_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/lockdown.c",
          "lines": "322-336",
          "snippet": "LIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_client_free(lockdownd_client_t client)\n{\n\tif (!client)\n\t\treturn LOCKDOWN_E_INVALID_ARG;\n\n\tlockdownd_error_t ret = LOCKDOWN_E_UNKNOWN_ERROR;\n\n\tif (client->session_id) {\n\t\tlockdownd_stop_session(client, client->session_id);\n\t}\n\n\tret = lockdownd_client_free_simple(client);\n\n\treturn ret;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/userpref.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"lockdown.h\"",
            "#include \"property_list_service.h\"",
            "#include <plist/plist.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/x509.h>",
            "#include <libtasn1.h>",
            "#include <openssl/x509v3.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/pem.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/userpref.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"lockdown.h\"\n#include \"property_list_service.h\"\n#include <plist/plist.h>\n#include <gnutls/crypto.h>\n#include <gnutls/x509.h>\n#include <libtasn1.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/pem.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_client_free(lockdownd_client_t client)\n{\n\tif (!client)\n\t\treturn LOCKDOWN_E_INVALID_ARG;\n\n\tlockdownd_error_t ret = LOCKDOWN_E_UNKNOWN_ERROR;\n\n\tif (client->session_id) {\n\t\tlockdownd_stop_session(client, client->session_id);\n\t}\n\n\tret = lockdownd_client_free_simple(client);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdownd_start_service",
          "args": [
            "lockdown_client",
            "\"com.apple.iosdiagnostics.relay\"",
            "&service"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "lockdownd_start_service_with_escrow_bag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/lockdown.c",
          "lines": "1364-1367",
          "snippet": "LIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_start_service_with_escrow_bag(lockdownd_client_t client, const char *identifier, lockdownd_service_descriptor_t *service)\n{\n\treturn lockdownd_do_start_service(client, identifier, 1, service);\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/userpref.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"lockdown.h\"",
            "#include \"property_list_service.h\"",
            "#include <plist/plist.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/x509.h>",
            "#include <libtasn1.h>",
            "#include <openssl/x509v3.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/pem.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/userpref.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"lockdown.h\"\n#include \"property_list_service.h\"\n#include <plist/plist.h>\n#include <gnutls/crypto.h>\n#include <gnutls/x509.h>\n#include <libtasn1.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/pem.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_start_service_with_escrow_bag(lockdownd_client_t client, const char *identifier, lockdownd_service_descriptor_t *service)\n{\n\treturn lockdownd_do_start_service(client, identifier, 1, service);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ERROR: Could not connect to lockdownd, error code %d\\n\"",
            "ret"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "asprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/include/asprintf.h",
          "lines": "23-31",
          "snippet": "static inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}",
          "includes": [
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <config.h>\n\nstatic inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdownd_client_new_with_handshake",
          "args": [
            "device",
            "&lockdown_client",
            "\"idevicediagnostics\""
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "lockdownd_client_new_with_handshake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/lockdown.c",
          "lines": "671-753",
          "snippet": "LIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_client_new_with_handshake(idevice_t device, lockdownd_client_t *client, const char *label)\n{\n\tif (!client)\n\t\treturn LOCKDOWN_E_INVALID_ARG;\n\n\tlockdownd_error_t ret = LOCKDOWN_E_SUCCESS;\n\tlockdownd_client_t client_loc = NULL;\n\tplist_t pair_record = NULL;\n\tchar *host_id = NULL;\n\tchar *type = NULL;\n\n\tret = lockdownd_client_new(device, &client_loc, label);\n\tif (LOCKDOWN_E_SUCCESS != ret) {\n\t\tdebug_info(\"failed to create lockdownd client.\");\n\t\treturn ret;\n\t}\n\n\t/* perform handshake */\n\tif (LOCKDOWN_E_SUCCESS != lockdownd_query_type(client_loc, &type)) {\n\t\tdebug_info(\"QueryType failed in the lockdownd client.\");\n\t\tret = LOCKDOWN_E_NOT_ENOUGH_DATA;\n\t} else {\n\t\tif (strcmp(\"com.apple.mobile.lockdown\", type)) {\n\t\t\tdebug_info(\"Warning QueryType request returned \\\"%s\\\".\", type);\n\t\t}\n\t}\n\tfree(type);\n\n\tuserpref_read_pair_record(client_loc->udid, &pair_record);\n\tif (pair_record) {\n\t\tpair_record_get_host_id(pair_record, &host_id);\n\t}\n\tif (LOCKDOWN_E_SUCCESS == ret && !host_id) {\n\t\tret = LOCKDOWN_E_INVALID_CONF;\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS == ret && !pair_record) {\n\t\t/* attempt pairing */\n\t\tret = lockdownd_pair(client_loc, NULL);\n\t}\n\n\tplist_free(pair_record);\n\tpair_record = NULL;\n\n\t/* in any case, we need to validate pairing to receive trusted host status */\n\tret = lockdownd_validate_pair(client_loc, NULL);\n\n\t/* if not paired yet, let's do it now */\n\tif (LOCKDOWN_E_INVALID_HOST_ID == ret) {\n\t\tfree(host_id);\n\t\thost_id = NULL;\n\t\tret = lockdownd_pair(client_loc, NULL);\n\t\tif (LOCKDOWN_E_SUCCESS == ret) {\n\t\t\tret = lockdownd_validate_pair(client_loc, NULL);\n\t\t} else if (LOCKDOWN_E_PAIRING_DIALOG_RESPONSE_PENDING == ret) {\n\t\t\tdebug_info(\"Device shows the pairing dialog.\");\n\t\t}\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS == ret) {\n\t\tif (!host_id) {\n\t\t\tuserpref_read_pair_record(client_loc->udid, &pair_record);\n\t\t\tif (pair_record) {\n\t\t\t\tpair_record_get_host_id(pair_record, &host_id);\n\t\t\t\tplist_free(pair_record);\n\t\t\t}\n\t\t}\n\n\t\tret = lockdownd_start_session(client_loc, host_id, NULL, NULL);\n\t\tif (LOCKDOWN_E_SUCCESS != ret) {\n\t\t\tdebug_info(\"Session opening failed.\");\n\t\t}\n\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS == ret) {\n\t\t*client = client_loc;\n\t} else {\n\t\tlockdownd_client_free(client_loc);\n\t}\n\tfree(host_id);\n\treturn ret;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/userpref.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"lockdown.h\"",
            "#include \"property_list_service.h\"",
            "#include <plist/plist.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/x509.h>",
            "#include <libtasn1.h>",
            "#include <openssl/x509v3.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/pem.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/userpref.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"lockdown.h\"\n#include \"property_list_service.h\"\n#include <plist/plist.h>\n#include <gnutls/crypto.h>\n#include <gnutls/x509.h>\n#include <libtasn1.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/pem.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_client_new_with_handshake(idevice_t device, lockdownd_client_t *client, const char *label)\n{\n\tif (!client)\n\t\treturn LOCKDOWN_E_INVALID_ARG;\n\n\tlockdownd_error_t ret = LOCKDOWN_E_SUCCESS;\n\tlockdownd_client_t client_loc = NULL;\n\tplist_t pair_record = NULL;\n\tchar *host_id = NULL;\n\tchar *type = NULL;\n\n\tret = lockdownd_client_new(device, &client_loc, label);\n\tif (LOCKDOWN_E_SUCCESS != ret) {\n\t\tdebug_info(\"failed to create lockdownd client.\");\n\t\treturn ret;\n\t}\n\n\t/* perform handshake */\n\tif (LOCKDOWN_E_SUCCESS != lockdownd_query_type(client_loc, &type)) {\n\t\tdebug_info(\"QueryType failed in the lockdownd client.\");\n\t\tret = LOCKDOWN_E_NOT_ENOUGH_DATA;\n\t} else {\n\t\tif (strcmp(\"com.apple.mobile.lockdown\", type)) {\n\t\t\tdebug_info(\"Warning QueryType request returned \\\"%s\\\".\", type);\n\t\t}\n\t}\n\tfree(type);\n\n\tuserpref_read_pair_record(client_loc->udid, &pair_record);\n\tif (pair_record) {\n\t\tpair_record_get_host_id(pair_record, &host_id);\n\t}\n\tif (LOCKDOWN_E_SUCCESS == ret && !host_id) {\n\t\tret = LOCKDOWN_E_INVALID_CONF;\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS == ret && !pair_record) {\n\t\t/* attempt pairing */\n\t\tret = lockdownd_pair(client_loc, NULL);\n\t}\n\n\tplist_free(pair_record);\n\tpair_record = NULL;\n\n\t/* in any case, we need to validate pairing to receive trusted host status */\n\tret = lockdownd_validate_pair(client_loc, NULL);\n\n\t/* if not paired yet, let's do it now */\n\tif (LOCKDOWN_E_INVALID_HOST_ID == ret) {\n\t\tfree(host_id);\n\t\thost_id = NULL;\n\t\tret = lockdownd_pair(client_loc, NULL);\n\t\tif (LOCKDOWN_E_SUCCESS == ret) {\n\t\t\tret = lockdownd_validate_pair(client_loc, NULL);\n\t\t} else if (LOCKDOWN_E_PAIRING_DIALOG_RESPONSE_PENDING == ret) {\n\t\t\tdebug_info(\"Device shows the pairing dialog.\");\n\t\t}\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS == ret) {\n\t\tif (!host_id) {\n\t\t\tuserpref_read_pair_record(client_loc->udid, &pair_record);\n\t\t\tif (pair_record) {\n\t\t\t\tpair_record_get_host_id(pair_record, &host_id);\n\t\t\t\tplist_free(pair_record);\n\t\t\t}\n\t\t}\n\n\t\tret = lockdownd_start_session(client_loc, host_id, NULL, NULL);\n\t\tif (LOCKDOWN_E_SUCCESS != ret) {\n\t\t\tdebug_info(\"Session opening failed.\");\n\t\t}\n\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS == ret) {\n\t\t*client = client_loc;\n\t} else {\n\t\tlockdownd_client_free(client_loc);\n\t}\n\tfree(host_id);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"No device found, is it plugged in?\\n\""
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idevice_new",
          "args": [
            "&device",
            "udid"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "idevice_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
          "lines": "230-245",
          "snippet": "LIBIMOBILEDEVICE_API idevice_error_t idevice_new(idevice_t * device, const char *udid)\n{\n\tusbmuxd_device_info_t muxdev;\n\tint res = usbmuxd_get_device_by_udid(udid, &muxdev);\n\tif (res > 0) {\n\t\tidevice_t dev = (idevice_t) malloc(sizeof(struct idevice_private));\n\t\tdev->udid = strdup(muxdev.udid);\n\t\tdev->conn_type = CONNECTION_USBMUXD;\n\t\tdev->conn_data = (void*)(long)muxdev.handle;\n\t\t*device = dev;\n\t\treturn IDEVICE_E_SUCCESS;\n\t}\n\t/* other connection types could follow here */\n\n\treturn IDEVICE_E_NO_DEVICE;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"common/thread.h\"",
            "#include \"common/userpref.h\"",
            "#include \"idevice.h\"",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <usbmuxd.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "LIBIMOBILEDEVICE_API idevice_error_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nLIBIMOBILEDEVICE_API idevice_error_t idevice_new(idevice_t * device, const char *udid)\n{\n\tusbmuxd_device_info_t muxdev;\n\tint res = usbmuxd_get_device_by_udid(udid, &muxdev);\n\tif (res > 0) {\n\t\tidevice_t dev = (idevice_t) malloc(sizeof(struct idevice_private));\n\t\tdev->udid = strdup(muxdev.udid);\n\t\tdev->conn_type = CONNECTION_USBMUXD;\n\t\tdev->conn_data = (void*)(long)muxdev.handle;\n\t\t*device = dev;\n\t\treturn IDEVICE_E_SUCCESS;\n\t}\n\t/* other connection types could follow here */\n\n\treturn IDEVICE_E_NO_DEVICE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_usage",
          "args": [
            "argc",
            "argv"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "print_usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicediagnostics.c",
          "lines": "285-304",
          "snippet": "void print_usage(int argc, char **argv)\n{\n\tchar *name = NULL;\n\tname = strrchr(argv[0], '/');\n\tprintf(\"Usage: %s COMMAND [OPTIONS]\\n\", (name ? name + 1: argv[0]));\n\tprintf(\"Use diagnostics interface of a device running iOS 4 or later.\\n\\n\");\n\tprintf(\" Where COMMAND is one of:\\n\");\n\tprintf(\"  diagnostics [TYPE]\\t\\tprint diagnostics information from device by TYPE (All, WiFi, GasGauge, NAND)\\n\");\n\tprintf(\"  mobilegestalt KEY [...]\\tprint mobilegestalt keys passed as arguments seperated by a space.\\n\");\n\tprintf(\"  ioreg [PLANE]\\t\\t\\tprint IORegistry of device, optionally by PLANE (IODeviceTree, IOPower, IOService) (iOS 5+ only)\\n\");\n\tprintf(\"  shutdown\\t\\t\\tshutdown device\\n\");\n\tprintf(\"  restart\\t\\t\\trestart device\\n\");\n\tprintf(\"  sleep\\t\\t\\t\\tput device into sleep mode (disconnects from host)\\n\\n\");\n\tprintf(\" The following OPTIONS are accepted:\\n\");\n\tprintf(\"  -d, --debug\\t\\tenable communication debugging\\n\");\n\tprintf(\"  -u, --udid UDID\\ttarget specific device by its 40-digit device UDID\\n\");\n\tprintf(\"  -h, --help\\t\\tprints usage information\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"Homepage: <\" PACKAGE_URL \">\\n\");\n}",
          "includes": [
            "#include <libimobiledevice/diagnostics_relay.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <errno.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void print_usage(int argc, char **argv);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <libimobiledevice/diagnostics_relay.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nvoid print_usage(int argc, char **argv);\n\nvoid print_usage(int argc, char **argv)\n{\n\tchar *name = NULL;\n\tname = strrchr(argv[0], '/');\n\tprintf(\"Usage: %s COMMAND [OPTIONS]\\n\", (name ? name + 1: argv[0]));\n\tprintf(\"Use diagnostics interface of a device running iOS 4 or later.\\n\\n\");\n\tprintf(\" Where COMMAND is one of:\\n\");\n\tprintf(\"  diagnostics [TYPE]\\t\\tprint diagnostics information from device by TYPE (All, WiFi, GasGauge, NAND)\\n\");\n\tprintf(\"  mobilegestalt KEY [...]\\tprint mobilegestalt keys passed as arguments seperated by a space.\\n\");\n\tprintf(\"  ioreg [PLANE]\\t\\t\\tprint IORegistry of device, optionally by PLANE (IODeviceTree, IOPower, IOService) (iOS 5+ only)\\n\");\n\tprintf(\"  shutdown\\t\\t\\tshutdown device\\n\");\n\tprintf(\"  restart\\t\\t\\trestart device\\n\");\n\tprintf(\"  sleep\\t\\t\\t\\tput device into sleep mode (disconnects from host)\\n\\n\");\n\tprintf(\" The following OPTIONS are accepted:\\n\");\n\tprintf(\"  -d, --debug\\t\\tenable communication debugging\\n\");\n\tprintf(\"  -u, --udid UDID\\ttarget specific device by its 40-digit device UDID\\n\");\n\tprintf(\"  -h, --help\\t\\tprints usage information\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"Homepage: <\" PACKAGE_URL \">\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[i]"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"ioreg\""
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "plist_strcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
          "lines": "296-309",
          "snippet": "static int plist_strcmp(plist_t node, const char *str)\n{\n\tchar *buffer = NULL;\n\tint ret = 0;\n\n\tif (plist_get_node_type(node) != PLIST_STRING)\n\t\treturn ret;\n\n\tplist_get_string_val(node, &buffer);\n\tret = strcmp(buffer, str);\n\tfree(buffer);\n\n\treturn ret;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <unistd.h>",
            "#include <gcrypt.h>",
            "#include <openssl/sha.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int plist_strcmp(plist_t node, const char *str)\n{\n\tchar *buffer = NULL;\n\tint ret = 0;\n\n\tif (plist_get_node_type(node) != PLIST_STRING)\n\t\treturn ret;\n\n\tplist_get_string_val(node, &buffer);\n\tret = strcmp(buffer, str);\n\tfree(buffer);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_array_append_item",
          "args": [
            "keys",
            "plist_new_string(argv[i])"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_string",
          "args": [
            "argv[i]"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "argv[i]",
            "\"-\"",
            "1"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "argv[i]"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_array",
          "args": [],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Please supply the key to query.\\n\""
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "argv[i]",
            "\"-\"",
            "1"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[i]"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"All\""
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "argv[i]",
            "\"-\"",
            "1"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"All\""
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "argv[i]"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idevice_set_debug_level",
          "args": [
            "1"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "idevice_set_debug_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
          "lines": "225-228",
          "snippet": "LIBIMOBILEDEVICE_API void idevice_set_debug_level(int level)\n{\n\tinternal_set_debug_level(level);\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"common/thread.h\"",
            "#include \"common/userpref.h\"",
            "#include \"idevice.h\"",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <usbmuxd.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API void idevice_set_debug_level(int level)\n{\n\tinternal_set_debug_level(level);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <libimobiledevice/diagnostics_relay.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nvoid print_usage(int argc, char **argv);\n\nint main(int argc, char **argv)\n{\n\tidevice_t device = NULL;\n\tlockdownd_client_t lockdown_client = NULL;\n\tdiagnostics_relay_client_t diagnostics_client = NULL;\n\tlockdownd_error_t ret = LOCKDOWN_E_UNKNOWN_ERROR;\n\tlockdownd_service_descriptor_t service = NULL;\n\tint result = -1;\n\tint i;\n\tconst char *udid = NULL;\n\tint cmd = CMD_NONE;\n\tchar* cmd_arg = NULL;\n\tplist_t node = NULL;\n\tplist_t keys = NULL;\n\n\t/* parse cmdline args */\n\tfor (i = 1; i < argc; i++) {\n\t\tif (!strcmp(argv[i], \"-d\") || !strcmp(argv[i], \"--debug\")) {\n\t\t\tidevice_set_debug_level(1);\n\t\t\tcontinue;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"-u\") || !strcmp(argv[i], \"--udid\")) {\n\t\t\ti++;\n\t\t\tif (!argv[i] || (strlen(argv[i]) != 40)) {\n\t\t\t\tprint_usage(argc, argv);\n\t\t\t\tresult = 0;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tudid = argv[i];\n\t\t\tcontinue;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"-h\") || !strcmp(argv[i], \"--help\")) {\n\t\t\tprint_usage(argc, argv);\n\t\t\tresult = 0;\n\t\t\tgoto cleanup;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"sleep\")) {\n\t\t\tcmd = CMD_SLEEP;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"restart\")) {\n\t\t\tcmd = CMD_RESTART;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"shutdown\")) {\n\t\t\tcmd = CMD_SHUTDOWN;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"diagnostics\")) {\n\t\t\tcmd = CMD_DIAGNOSTICS;\n\t\t\t/*  read type */\n\t\t\ti++;\n\t\t\tif (!argv[i] || ((strcmp(argv[i], \"All\") != 0) && (strcmp(argv[i], \"WiFi\") != 0) && (strcmp(argv[i], \"GasGauge\") != 0) && (strcmp(argv[i], \"NAND\") != 0))) {\n\t\t\t\tif (argv[i] == NULL) {\n\t\t\t\t\tcmd_arg = strdup(\"All\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (!strncmp(argv[i], \"-\", 1)) {\n\t\t\t\t\tcmd_arg = strdup(\"All\");\n\t\t\t\t\ti--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tprintf(\"Unknown TYPE %s\\n\", argv[i]);\n\t\t\t\tprint_usage(argc, argv);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\n\t\t\tcmd_arg = strdup(argv[i]);\n\t\t\tcontinue;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"mobilegestalt\")) {\n\t\t\tcmd = CMD_MOBILEGESTALT;\n\t\t\t/*  read keys */\n\t\t\ti++;\n\n\t\t\tif (!argv[i] || argv[i] == NULL || (!strncmp(argv[i], \"-\", 1))) {\n\t\t\t\tprintf(\"Please supply the key to query.\\n\");\n\t\t\t\tprint_usage(argc, argv);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\n\t\t\tkeys = plist_new_array();\n\t\t\twhile(1) {\n\t\t\t\tif (argv[i] && (strlen(argv[i]) >= 2) && (strncmp(argv[i], \"-\", 1) != 0)) {\n\t\t\t\t\tplist_array_append_item(keys, plist_new_string(argv[i]));\n\t\t\t\t\ti++;\n\t\t\t\t} else {\n\t\t\t\t\ti--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"ioreg\")) {\n\t\t\tcmd = CMD_IOREGISTRY;\n\t\t\t/*  read plane */\n\t\t\ti++;\n\t\t\tif (argv[i]) {\n\t\t\t\tcmd_arg = strdup(argv[i]);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\telse {\n\t\t\tprint_usage(argc, argv);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* verify options */\n\tif (cmd == CMD_NONE) {\n\t\tprint_usage(argc, argv);\n\t\tgoto cleanup;\n\t}\n\n\tif (IDEVICE_E_SUCCESS != idevice_new(&device, udid)) {\n\t\tif (udid) {\n\t\t\tprintf(\"No device found with udid %s, is it plugged in?\\n\", udid);\n\t\t} else {\n\t\t\tprintf(\"No device found, is it plugged in?\\n\");\n\t\t}\n\t\tgoto cleanup;\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS != (ret = lockdownd_client_new_with_handshake(device, &lockdown_client, \"idevicediagnostics\"))) {\n\t\tidevice_free(device);\n\t\tprintf(\"ERROR: Could not connect to lockdownd, error code %d\\n\", ret);\n\t\tgoto cleanup;\n\t}\n\n\t/*  attempt to use newer diagnostics service available on iOS 5 and later */\n\tret = lockdownd_start_service(lockdown_client, \"com.apple.mobile.diagnostics_relay\", &service);\n\tif (ret != LOCKDOWN_E_SUCCESS) {\n\t\t/*  attempt to use older diagnostics service */\n\t\tret = lockdownd_start_service(lockdown_client, \"com.apple.iosdiagnostics.relay\", &service);\n\t}\n\n\tlockdownd_client_free(lockdown_client);\n\n\tif ((ret == LOCKDOWN_E_SUCCESS) && service && (service->port > 0)) {\n\t\tif (diagnostics_relay_client_new(device, service, &diagnostics_client) != DIAGNOSTICS_RELAY_E_SUCCESS) {\n\t\t\tprintf(\"Could not connect to diagnostics_relay!\\n\");\n\t\t\tresult = -1;\n\t\t} else {\n\t\t\tswitch (cmd) {\n\t\t\t\tcase CMD_SLEEP:\n\t\t\t\t\tif (diagnostics_relay_sleep(diagnostics_client) == DIAGNOSTICS_RELAY_E_SUCCESS) {\n\t\t\t\t\t\tprintf(\"Putting device into deep sleep mode.\\n\");\n\t\t\t\t\t\tresult = EXIT_SUCCESS;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprintf(\"Failed to put device into deep sleep mode.\\n\");\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\tcase CMD_RESTART:\n\t\t\t\t\tif (diagnostics_relay_restart(diagnostics_client, DIAGNOSTICS_RELAY_ACTION_FLAG_WAIT_FOR_DISCONNECT) == DIAGNOSTICS_RELAY_E_SUCCESS) {\n\t\t\t\t\t\tprintf(\"Restarting device.\\n\");\n\t\t\t\t\t\tresult = EXIT_SUCCESS;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprintf(\"Failed to restart device.\\n\");\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\tcase CMD_SHUTDOWN:\n\t\t\t\t\tif (diagnostics_relay_shutdown(diagnostics_client, DIAGNOSTICS_RELAY_ACTION_FLAG_WAIT_FOR_DISCONNECT) == DIAGNOSTICS_RELAY_E_SUCCESS) {\n\t\t\t\t\t\tprintf(\"Shutting down device.\\n\");\n\t\t\t\t\t\tresult = EXIT_SUCCESS;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprintf(\"Failed to shutdown device.\\n\");\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\tcase CMD_MOBILEGESTALT:\n\t\t\t\t\tif (diagnostics_relay_query_mobilegestalt(diagnostics_client, keys, &node) == DIAGNOSTICS_RELAY_E_SUCCESS) {\n\t\t\t\t\t\tif (node) {\n\t\t\t\t\t\t\tprint_xml(node);\n\t\t\t\t\t\t\tresult = EXIT_SUCCESS;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprintf(\"Unable to query mobilegestalt keys.\\n\");\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\tcase CMD_IOREGISTRY:\n\t\t\t\t\tif (diagnostics_relay_query_ioregistry_plane(diagnostics_client, cmd_arg == NULL ? \"\": cmd_arg, &node) == DIAGNOSTICS_RELAY_E_SUCCESS) {\n\t\t\t\t\t\tif (node) {\n\t\t\t\t\t\t\tprint_xml(node);\n\t\t\t\t\t\t\tresult = EXIT_SUCCESS;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprintf(\"Unable to retrieve IORegistry from device.\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase CMD_DIAGNOSTICS:\n\t\t\t\tdefault:\n\t\t\t\t\tif (diagnostics_relay_request_diagnostics(diagnostics_client, cmd_arg, &node) == DIAGNOSTICS_RELAY_E_SUCCESS) {\n\t\t\t\t\t\tif (node) {\n\t\t\t\t\t\t\tprint_xml(node);\n\t\t\t\t\t\t\tresult = EXIT_SUCCESS;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprintf(\"Unable to retrieve diagnostics from device.\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdiagnostics_relay_goodbye(diagnostics_client);\n\t\t\tdiagnostics_relay_client_free(diagnostics_client);\n\t\t}\n\t} else {\n\t\tprintf(\"Could not start diagnostics service!\\n\");\n\t}\n\n\tif (service) {\n\t\tlockdownd_service_descriptor_free(service);\n\t\tservice = NULL;\n\t}\n\n\tidevice_free(device);\n\ncleanup:\n\tif (node) {\n\t\tplist_free(node);\n\t}\n\tif (keys) {\n\t\tplist_free(keys);\n\t}\n\tif (cmd_arg) {\n\t\tfree(cmd_arg);\n\t}\n\treturn result;\n}"
  },
  {
    "function_name": "print_xml",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicediagnostics.c",
    "lines": "46-54",
    "snippet": "static void print_xml(plist_t node)\n{\n\tchar *xml = NULL;\n\tuint32_t len = 0;\n\tplist_to_xml(node, &xml, &len);\n\tif (xml) {\n\t\tputs(xml);\n\t}\n}",
    "includes": [
      "#include <libimobiledevice/diagnostics_relay.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <time.h>",
      "#include <errno.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "puts",
          "args": [
            "xml"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_to_xml",
          "args": [
            "node",
            "&xml",
            "&len"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <libimobiledevice/diagnostics_relay.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void print_xml(plist_t node)\n{\n\tchar *xml = NULL;\n\tuint32_t len = 0;\n\tplist_to_xml(node, &xml, &len);\n\tif (xml) {\n\t\tputs(xml);\n\t}\n}"
  }
]