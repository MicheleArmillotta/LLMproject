[
  {
    "function_name": "socket_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/socket.c",
    "lines": "389-392",
    "snippet": "int socket_send(int fd, void *data, size_t length)\n{\n\treturn send(fd, data, length, 0);\n}",
    "includes": [
      "#include \"socket.h\"",
      "#include <arpa/inet.h>",
      "#include <netdb.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <windows.h>",
      "#include <winsock2.h>",
      "#include <sys/stat.h>",
      "#include <sys/time.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "send",
          "args": [
            "fd",
            "data",
            "length",
            "0"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "mobilesync_send_changes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/mobilesync.c",
          "lines": "588-614",
          "snippet": "LIBIMOBILEDEVICE_API mobilesync_error_t mobilesync_send_changes(mobilesync_client_t client, plist_t entities, uint8_t is_last_record, plist_t actions)\n{\n\tif (!client || !client->data_class || !entities) {\n\t\treturn MOBILESYNC_E_INVALID_ARG;\n\t}\n\n\tif (plist_get_node_type(entities) != PLIST_DICT) {\n\t\treturn MOBILESYNC_E_INVALID_ARG;\n\t}\n\n\tif (client->direction != MOBILESYNC_SYNC_DIR_COMPUTER_TO_DEVICE) {\n\t\treturn MOBILESYNC_E_WRONG_DIRECTION;\n\t}\n\n\tmobilesync_error_t err = MOBILESYNC_E_UNKNOWN_ERROR;\n\tplist_t msg = NULL;\n\n\tmsg = create_process_changes_message(client->data_class, entities, (is_last_record > 0 ? 0 : 1), actions);\n\terr = mobilesync_send(client, msg);\n\n\tif (msg) {\n\t\tplist_free(msg);\n\t\tmsg = NULL;\n\t}\n\n\treturn err;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"device_link_service.h\"",
            "#include \"mobilesync.h\"",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <plist/plist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"device_link_service.h\"\n#include \"mobilesync.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <plist/plist.h>\n\nLIBIMOBILEDEVICE_API mobilesync_error_t mobilesync_send_changes(mobilesync_client_t client, plist_t entities, uint8_t is_last_record, plist_t actions)\n{\n\tif (!client || !client->data_class || !entities) {\n\t\treturn MOBILESYNC_E_INVALID_ARG;\n\t}\n\n\tif (plist_get_node_type(entities) != PLIST_DICT) {\n\t\treturn MOBILESYNC_E_INVALID_ARG;\n\t}\n\n\tif (client->direction != MOBILESYNC_SYNC_DIR_COMPUTER_TO_DEVICE) {\n\t\treturn MOBILESYNC_E_WRONG_DIRECTION;\n\t}\n\n\tmobilesync_error_t err = MOBILESYNC_E_UNKNOWN_ERROR;\n\tplist_t msg = NULL;\n\n\tmsg = create_process_changes_message(client->data_class, entities, (is_last_record > 0 ? 0 : 1), actions);\n\terr = mobilesync_send(client, msg);\n\n\tif (msg) {\n\t\tplist_free(msg);\n\t\tmsg = NULL;\n\t}\n\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"socket.h\"\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <windows.h>\n#include <winsock2.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdio.h>\n\nint socket_send(int fd, void *data, size_t length)\n{\n\treturn send(fd, data, length, 0);\n}"
  },
  {
    "function_name": "socket_receive_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/socket.c",
    "lines": "364-387",
    "snippet": "int socket_receive_timeout(int fd, void *data, size_t length, int flags,\n\t\t\t\t\t unsigned int timeout)\n{\n\tint res;\n\tint result;\n\n\t// check if data is available\n\tres = socket_check_fd(fd, FDM_READ, timeout);\n\tif (res <= 0) {\n\t\treturn res;\n\t}\n\t// if we get here, there _is_ data available\n\tresult = recv(fd, data, length, flags);\n\tif (res > 0 && result == 0) {\n\t\t// but this is an error condition\n\t\tif (verbose >= 3)\n\t\t\tfprintf(stderr, \"%s: fd=%d recv returned 0\\n\", __func__, fd);\n\t\treturn -EAGAIN;\n\t}\n\tif (result < 0) {\n\t\treturn -errno;\n\t}\n\treturn result;\n}",
    "includes": [
      "#include \"socket.h\"",
      "#include <arpa/inet.h>",
      "#include <netdb.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <windows.h>",
      "#include <winsock2.h>",
      "#include <sys/stat.h>",
      "#include <sys/time.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int verbose = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: fd=%d recv returned 0\\n\"",
            "__func__",
            "fd"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recv",
          "args": [
            "fd",
            "data",
            "length",
            "flags"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket_check_fd",
          "args": [
            "fd",
            "FDM_READ",
            "timeout"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "socket_check_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/socket.c",
          "lines": "253-318",
          "snippet": "int socket_check_fd(int fd, fd_mode fdm, unsigned int timeout)\n{\n\tfd_set fds;\n\tint sret;\n\tint eagain;\n\tstruct timeval to;\n\tstruct timeval *pto;\n\n\tif (fd <= 0) {\n\t\tif (verbose >= 2)\n\t\t\tfprintf(stderr, \"ERROR: invalid fd in check_fd %d\\n\", fd);\n\t\treturn -1;\n\t}\n\n\tFD_ZERO(&fds);\n\tFD_SET(fd, &fds);\n\n\tif (timeout > 0) {\n\t\tto.tv_sec = (time_t) (timeout / 1000);\n\t\tto.tv_usec = (time_t) ((timeout - (to.tv_sec * 1000)) * 1000);\n\t\tpto = &to;\n\t} else {\n\t\tpto = NULL;\n\t}\n\n\tsret = -1;\n\n\tdo {\n\t\teagain = 0;\n\t\tswitch (fdm) {\n\t\tcase FDM_READ:\n\t\t\tsret = select(fd + 1, &fds, NULL, NULL, pto);\n\t\t\tbreak;\n\t\tcase FDM_WRITE:\n\t\t\tsret = select(fd + 1, NULL, &fds, NULL, pto);\n\t\t\tbreak;\n\t\tcase FDM_EXCEPT:\n\t\t\tsret = select(fd + 1, NULL, NULL, &fds, pto);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (sret < 0) {\n\t\t\tswitch (errno) {\n\t\t\tcase EINTR:\n\t\t\t\t// interrupt signal in select\n\t\t\t\tif (verbose >= 2)\n\t\t\t\t\tfprintf(stderr, \"%s: EINTR\\n\", __func__);\n\t\t\t\teagain = 1;\n\t\t\t\tbreak;\n\t\t\tcase EAGAIN:\n\t\t\t\tif (verbose >= 2)\n\t\t\t\t\tfprintf(stderr, \"%s: EAGAIN\\n\", __func__);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (verbose >= 2)\n\t\t\t\t\tfprintf(stderr, \"%s: select failed: %s\\n\", __func__,\n\t\t\t\t\t\t\tstrerror(errno));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t} while (eagain);\n\n\treturn sret;\n}",
          "includes": [
            "#include \"socket.h\"",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <windows.h>",
            "#include <winsock2.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int verbose = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"socket.h\"\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <windows.h>\n#include <winsock2.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdio.h>\n\nstatic int verbose = 0;\n\nint socket_check_fd(int fd, fd_mode fdm, unsigned int timeout)\n{\n\tfd_set fds;\n\tint sret;\n\tint eagain;\n\tstruct timeval to;\n\tstruct timeval *pto;\n\n\tif (fd <= 0) {\n\t\tif (verbose >= 2)\n\t\t\tfprintf(stderr, \"ERROR: invalid fd in check_fd %d\\n\", fd);\n\t\treturn -1;\n\t}\n\n\tFD_ZERO(&fds);\n\tFD_SET(fd, &fds);\n\n\tif (timeout > 0) {\n\t\tto.tv_sec = (time_t) (timeout / 1000);\n\t\tto.tv_usec = (time_t) ((timeout - (to.tv_sec * 1000)) * 1000);\n\t\tpto = &to;\n\t} else {\n\t\tpto = NULL;\n\t}\n\n\tsret = -1;\n\n\tdo {\n\t\teagain = 0;\n\t\tswitch (fdm) {\n\t\tcase FDM_READ:\n\t\t\tsret = select(fd + 1, &fds, NULL, NULL, pto);\n\t\t\tbreak;\n\t\tcase FDM_WRITE:\n\t\t\tsret = select(fd + 1, NULL, &fds, NULL, pto);\n\t\t\tbreak;\n\t\tcase FDM_EXCEPT:\n\t\t\tsret = select(fd + 1, NULL, NULL, &fds, pto);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (sret < 0) {\n\t\t\tswitch (errno) {\n\t\t\tcase EINTR:\n\t\t\t\t// interrupt signal in select\n\t\t\t\tif (verbose >= 2)\n\t\t\t\t\tfprintf(stderr, \"%s: EINTR\\n\", __func__);\n\t\t\t\teagain = 1;\n\t\t\t\tbreak;\n\t\t\tcase EAGAIN:\n\t\t\t\tif (verbose >= 2)\n\t\t\t\t\tfprintf(stderr, \"%s: EAGAIN\\n\", __func__);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (verbose >= 2)\n\t\t\t\t\tfprintf(stderr, \"%s: select failed: %s\\n\", __func__,\n\t\t\t\t\t\t\tstrerror(errno));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t} while (eagain);\n\n\treturn sret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"socket.h\"\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <windows.h>\n#include <winsock2.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdio.h>\n\nstatic int verbose = 0;\n\nint socket_receive_timeout(int fd, void *data, size_t length, int flags,\n\t\t\t\t\t unsigned int timeout)\n{\n\tint res;\n\tint result;\n\n\t// check if data is available\n\tres = socket_check_fd(fd, FDM_READ, timeout);\n\tif (res <= 0) {\n\t\treturn res;\n\t}\n\t// if we get here, there _is_ data available\n\tresult = recv(fd, data, length, flags);\n\tif (res > 0 && result == 0) {\n\t\t// but this is an error condition\n\t\tif (verbose >= 3)\n\t\t\tfprintf(stderr, \"%s: fd=%d recv returned 0\\n\", __func__, fd);\n\t\treturn -EAGAIN;\n\t}\n\tif (result < 0) {\n\t\treturn -errno;\n\t}\n\treturn result;\n}"
  },
  {
    "function_name": "socket_peek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/socket.c",
    "lines": "359-362",
    "snippet": "int socket_peek(int fd, void *data, size_t length)\n{\n\treturn socket_receive_timeout(fd, data, length, MSG_PEEK, RECV_TIMEOUT);\n}",
    "includes": [
      "#include \"socket.h\"",
      "#include <arpa/inet.h>",
      "#include <netdb.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <windows.h>",
      "#include <winsock2.h>",
      "#include <sys/stat.h>",
      "#include <sys/time.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [
      "#define RECV_TIMEOUT 20000"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "socket_receive_timeout",
          "args": [
            "fd",
            "data",
            "length",
            "MSG_PEEK",
            "RECV_TIMEOUT"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "socket_receive_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/socket.c",
          "lines": "364-387",
          "snippet": "int socket_receive_timeout(int fd, void *data, size_t length, int flags,\n\t\t\t\t\t unsigned int timeout)\n{\n\tint res;\n\tint result;\n\n\t// check if data is available\n\tres = socket_check_fd(fd, FDM_READ, timeout);\n\tif (res <= 0) {\n\t\treturn res;\n\t}\n\t// if we get here, there _is_ data available\n\tresult = recv(fd, data, length, flags);\n\tif (res > 0 && result == 0) {\n\t\t// but this is an error condition\n\t\tif (verbose >= 3)\n\t\t\tfprintf(stderr, \"%s: fd=%d recv returned 0\\n\", __func__, fd);\n\t\treturn -EAGAIN;\n\t}\n\tif (result < 0) {\n\t\treturn -errno;\n\t}\n\treturn result;\n}",
          "includes": [
            "#include \"socket.h\"",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <windows.h>",
            "#include <winsock2.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int verbose = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"socket.h\"\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <windows.h>\n#include <winsock2.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdio.h>\n\nstatic int verbose = 0;\n\nint socket_receive_timeout(int fd, void *data, size_t length, int flags,\n\t\t\t\t\t unsigned int timeout)\n{\n\tint res;\n\tint result;\n\n\t// check if data is available\n\tres = socket_check_fd(fd, FDM_READ, timeout);\n\tif (res <= 0) {\n\t\treturn res;\n\t}\n\t// if we get here, there _is_ data available\n\tresult = recv(fd, data, length, flags);\n\tif (res > 0 && result == 0) {\n\t\t// but this is an error condition\n\t\tif (verbose >= 3)\n\t\t\tfprintf(stderr, \"%s: fd=%d recv returned 0\\n\", __func__, fd);\n\t\treturn -EAGAIN;\n\t}\n\tif (result < 0) {\n\t\treturn -errno;\n\t}\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"socket.h\"\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <windows.h>\n#include <winsock2.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdio.h>\n\n#define RECV_TIMEOUT 20000\n\nint socket_peek(int fd, void *data, size_t length)\n{\n\treturn socket_receive_timeout(fd, data, length, MSG_PEEK, RECV_TIMEOUT);\n}"
  },
  {
    "function_name": "socket_receive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/socket.c",
    "lines": "354-357",
    "snippet": "int socket_receive(int fd, void *data, size_t length)\n{\n\treturn socket_receive_timeout(fd, data, length, 0, RECV_TIMEOUT);\n}",
    "includes": [
      "#include \"socket.h\"",
      "#include <arpa/inet.h>",
      "#include <netdb.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <windows.h>",
      "#include <winsock2.h>",
      "#include <sys/stat.h>",
      "#include <sys/time.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [
      "#define RECV_TIMEOUT 20000"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "socket_receive_timeout",
          "args": [
            "fd",
            "data",
            "length",
            "0",
            "RECV_TIMEOUT"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "socket_receive_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/socket.c",
          "lines": "364-387",
          "snippet": "int socket_receive_timeout(int fd, void *data, size_t length, int flags,\n\t\t\t\t\t unsigned int timeout)\n{\n\tint res;\n\tint result;\n\n\t// check if data is available\n\tres = socket_check_fd(fd, FDM_READ, timeout);\n\tif (res <= 0) {\n\t\treturn res;\n\t}\n\t// if we get here, there _is_ data available\n\tresult = recv(fd, data, length, flags);\n\tif (res > 0 && result == 0) {\n\t\t// but this is an error condition\n\t\tif (verbose >= 3)\n\t\t\tfprintf(stderr, \"%s: fd=%d recv returned 0\\n\", __func__, fd);\n\t\treturn -EAGAIN;\n\t}\n\tif (result < 0) {\n\t\treturn -errno;\n\t}\n\treturn result;\n}",
          "includes": [
            "#include \"socket.h\"",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <windows.h>",
            "#include <winsock2.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int verbose = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"socket.h\"\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <windows.h>\n#include <winsock2.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdio.h>\n\nstatic int verbose = 0;\n\nint socket_receive_timeout(int fd, void *data, size_t length, int flags,\n\t\t\t\t\t unsigned int timeout)\n{\n\tint res;\n\tint result;\n\n\t// check if data is available\n\tres = socket_check_fd(fd, FDM_READ, timeout);\n\tif (res <= 0) {\n\t\treturn res;\n\t}\n\t// if we get here, there _is_ data available\n\tresult = recv(fd, data, length, flags);\n\tif (res > 0 && result == 0) {\n\t\t// but this is an error condition\n\t\tif (verbose >= 3)\n\t\t\tfprintf(stderr, \"%s: fd=%d recv returned 0\\n\", __func__, fd);\n\t\treturn -EAGAIN;\n\t}\n\tif (result < 0) {\n\t\treturn -errno;\n\t}\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"socket.h\"\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <windows.h>\n#include <winsock2.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdio.h>\n\n#define RECV_TIMEOUT 20000\n\nint socket_receive(int fd, void *data, size_t length)\n{\n\treturn socket_receive_timeout(fd, data, length, 0, RECV_TIMEOUT);\n}"
  },
  {
    "function_name": "socket_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/socket.c",
    "lines": "346-352",
    "snippet": "int socket_close(int fd) {\n#ifdef WIN32\n\treturn closesocket(fd);\n#else\n\treturn close(fd);\n#endif\n}",
    "includes": [
      "#include \"socket.h\"",
      "#include <arpa/inet.h>",
      "#include <netdb.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <windows.h>",
      "#include <winsock2.h>",
      "#include <sys/stat.h>",
      "#include <sys/time.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "socket_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/socket.c",
          "lines": "346-352",
          "snippet": "int socket_close(int fd) {\n#ifdef WIN32\n\treturn closesocket(fd);\n#else\n\treturn close(fd);\n#endif\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "closesocket",
          "args": [
            "fd"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"socket.h\"\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <windows.h>\n#include <winsock2.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdio.h>\n\nint socket_close(int fd) {\n#ifdef WIN32\n\treturn closesocket(fd);\n#else\n\treturn close(fd);\n#endif\n}"
  },
  {
    "function_name": "socket_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/socket.c",
    "lines": "341-344",
    "snippet": "int socket_shutdown(int fd, int how)\n{\n\treturn shutdown(fd, how);\n}",
    "includes": [
      "#include \"socket.h\"",
      "#include <arpa/inet.h>",
      "#include <netdb.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <windows.h>",
      "#include <winsock2.h>",
      "#include <sys/stat.h>",
      "#include <sys/time.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "shutdown",
          "args": [
            "fd",
            "how"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "socket_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/socket.c",
          "lines": "341-344",
          "snippet": "int socket_shutdown(int fd, int how)\n{\n\treturn shutdown(fd, how);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"socket.h\"\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <windows.h>\n#include <winsock2.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdio.h>\n\nint socket_shutdown(int fd, int how)\n{\n\treturn shutdown(fd, how);\n}"
  },
  {
    "function_name": "socket_accept",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/socket.c",
    "lines": "320-339",
    "snippet": "int socket_accept(int fd, uint16_t port)\n{\n#ifdef WIN32\n\tint addr_len;\n#else\n\tsocklen_t addr_len;\n#endif\n\tint result;\n\tstruct sockaddr_in addr;\n\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.sin_family = AF_INET;\n\taddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\taddr.sin_port = htons(port);\n\n\taddr_len = sizeof(addr);\n\tresult = accept(fd, (struct sockaddr*)&addr, &addr_len);\n\n\treturn result;\n}",
    "includes": [
      "#include \"socket.h\"",
      "#include <arpa/inet.h>",
      "#include <netdb.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <windows.h>",
      "#include <winsock2.h>",
      "#include <sys/stat.h>",
      "#include <sys/time.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "accept",
          "args": [
            "fd",
            "(struct sockaddr*)&addr",
            "&addr_len"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "port"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "INADDR_ANY"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&addr",
            "0",
            "sizeof(addr)"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"socket.h\"\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <windows.h>\n#include <winsock2.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdio.h>\n\nint socket_accept(int fd, uint16_t port)\n{\n#ifdef WIN32\n\tint addr_len;\n#else\n\tsocklen_t addr_len;\n#endif\n\tint result;\n\tstruct sockaddr_in addr;\n\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.sin_family = AF_INET;\n\taddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\taddr.sin_port = htons(port);\n\n\taddr_len = sizeof(addr);\n\tresult = accept(fd, (struct sockaddr*)&addr, &addr_len);\n\n\treturn result;\n}"
  },
  {
    "function_name": "socket_check_fd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/socket.c",
    "lines": "253-318",
    "snippet": "int socket_check_fd(int fd, fd_mode fdm, unsigned int timeout)\n{\n\tfd_set fds;\n\tint sret;\n\tint eagain;\n\tstruct timeval to;\n\tstruct timeval *pto;\n\n\tif (fd <= 0) {\n\t\tif (verbose >= 2)\n\t\t\tfprintf(stderr, \"ERROR: invalid fd in check_fd %d\\n\", fd);\n\t\treturn -1;\n\t}\n\n\tFD_ZERO(&fds);\n\tFD_SET(fd, &fds);\n\n\tif (timeout > 0) {\n\t\tto.tv_sec = (time_t) (timeout / 1000);\n\t\tto.tv_usec = (time_t) ((timeout - (to.tv_sec * 1000)) * 1000);\n\t\tpto = &to;\n\t} else {\n\t\tpto = NULL;\n\t}\n\n\tsret = -1;\n\n\tdo {\n\t\teagain = 0;\n\t\tswitch (fdm) {\n\t\tcase FDM_READ:\n\t\t\tsret = select(fd + 1, &fds, NULL, NULL, pto);\n\t\t\tbreak;\n\t\tcase FDM_WRITE:\n\t\t\tsret = select(fd + 1, NULL, &fds, NULL, pto);\n\t\t\tbreak;\n\t\tcase FDM_EXCEPT:\n\t\t\tsret = select(fd + 1, NULL, NULL, &fds, pto);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (sret < 0) {\n\t\t\tswitch (errno) {\n\t\t\tcase EINTR:\n\t\t\t\t// interrupt signal in select\n\t\t\t\tif (verbose >= 2)\n\t\t\t\t\tfprintf(stderr, \"%s: EINTR\\n\", __func__);\n\t\t\t\teagain = 1;\n\t\t\t\tbreak;\n\t\t\tcase EAGAIN:\n\t\t\t\tif (verbose >= 2)\n\t\t\t\t\tfprintf(stderr, \"%s: EAGAIN\\n\", __func__);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (verbose >= 2)\n\t\t\t\t\tfprintf(stderr, \"%s: select failed: %s\\n\", __func__,\n\t\t\t\t\t\t\tstrerror(errno));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t} while (eagain);\n\n\treturn sret;\n}",
    "includes": [
      "#include \"socket.h\"",
      "#include <arpa/inet.h>",
      "#include <netdb.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <windows.h>",
      "#include <winsock2.h>",
      "#include <sys/stat.h>",
      "#include <sys/time.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int verbose = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: select failed: %s\\n\"",
            "__func__",
            "strerror(errno)"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: EAGAIN\\n\"",
            "__func__"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: EINTR\\n\"",
            "__func__"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "select",
          "args": [
            "fd + 1",
            "NULL",
            "NULL",
            "&fds",
            "pto"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "select",
          "args": [
            "fd + 1",
            "NULL",
            "&fds",
            "NULL",
            "pto"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "select",
          "args": [
            "fd + 1",
            "&fds",
            "NULL",
            "NULL",
            "pto"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(timeout - (to.tv_sec * 1000)) * 1000"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "timeout / 1000"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "fd",
            "&fds"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ZERO",
          "args": [
            "&fds"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"ERROR: invalid fd in check_fd %d\\n\"",
            "fd"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"socket.h\"\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <windows.h>\n#include <winsock2.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdio.h>\n\nstatic int verbose = 0;\n\nint socket_check_fd(int fd, fd_mode fdm, unsigned int timeout)\n{\n\tfd_set fds;\n\tint sret;\n\tint eagain;\n\tstruct timeval to;\n\tstruct timeval *pto;\n\n\tif (fd <= 0) {\n\t\tif (verbose >= 2)\n\t\t\tfprintf(stderr, \"ERROR: invalid fd in check_fd %d\\n\", fd);\n\t\treturn -1;\n\t}\n\n\tFD_ZERO(&fds);\n\tFD_SET(fd, &fds);\n\n\tif (timeout > 0) {\n\t\tto.tv_sec = (time_t) (timeout / 1000);\n\t\tto.tv_usec = (time_t) ((timeout - (to.tv_sec * 1000)) * 1000);\n\t\tpto = &to;\n\t} else {\n\t\tpto = NULL;\n\t}\n\n\tsret = -1;\n\n\tdo {\n\t\teagain = 0;\n\t\tswitch (fdm) {\n\t\tcase FDM_READ:\n\t\t\tsret = select(fd + 1, &fds, NULL, NULL, pto);\n\t\t\tbreak;\n\t\tcase FDM_WRITE:\n\t\t\tsret = select(fd + 1, NULL, &fds, NULL, pto);\n\t\t\tbreak;\n\t\tcase FDM_EXCEPT:\n\t\t\tsret = select(fd + 1, NULL, NULL, &fds, pto);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (sret < 0) {\n\t\t\tswitch (errno) {\n\t\t\tcase EINTR:\n\t\t\t\t// interrupt signal in select\n\t\t\t\tif (verbose >= 2)\n\t\t\t\t\tfprintf(stderr, \"%s: EINTR\\n\", __func__);\n\t\t\t\teagain = 1;\n\t\t\t\tbreak;\n\t\t\tcase EAGAIN:\n\t\t\t\tif (verbose >= 2)\n\t\t\t\t\tfprintf(stderr, \"%s: EAGAIN\\n\", __func__);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (verbose >= 2)\n\t\t\t\t\tfprintf(stderr, \"%s: select failed: %s\\n\", __func__,\n\t\t\t\t\t\t\tstrerror(errno));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t} while (eagain);\n\n\treturn sret;\n}"
  },
  {
    "function_name": "socket_connect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/socket.c",
    "lines": "193-251",
    "snippet": "int socket_connect(const char *addr, uint16_t port)\n{\n\tint sfd = -1;\n\tint yes = 1;\n\tstruct hostent *hp;\n\tstruct sockaddr_in saddr;\n#ifdef WIN32\n\tWSADATA wsa_data;\n\tif (!wsa_init) {\n\t\tif (WSAStartup(MAKEWORD(2,2), &wsa_data) != ERROR_SUCCESS) {\n\t\t\tfprintf(stderr, \"WSAStartup failed!\\n\");\n\t\t\tExitProcess(-1);\n\t\t}\n\t\twsa_init = 1;\n\t}\n#endif\n\n\tif (!addr) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tif ((hp = gethostbyname(addr)) == NULL) {\n\t\tif (verbose >= 2)\n\t\t\tfprintf(stderr, \"%s: unknown host '%s'\\n\", __func__, addr);\n\t\treturn -1;\n\t}\n\n\tif (!hp->h_addr) {\n\t\tif (verbose >= 2)\n\t\t\tfprintf(stderr, \"%s: gethostbyname returned NULL address!\\n\",\n\t\t\t\t\t__func__);\n\t\treturn -1;\n\t}\n\n\tif (0 > (sfd = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP))) {\n\t\tperror(\"socket()\");\n\t\treturn -1;\n\t}\n\n\tif (setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void*)&yes, sizeof(int)) == -1) {\n\t\tperror(\"setsockopt()\");\n\t\tsocket_close(sfd);\n\t\treturn -1;\n\t}\n\n\tmemset((void *) &saddr, 0, sizeof(saddr));\n\tsaddr.sin_family = AF_INET;\n\tsaddr.sin_addr.s_addr = *(uint32_t *) hp->h_addr;\n\tsaddr.sin_port = htons(port);\n\n\tif (connect(sfd, (struct sockaddr *) &saddr, sizeof(saddr)) < 0) {\n\t\tperror(\"connect\");\n\t\tsocket_close(sfd);\n\t\treturn -2;\n\t}\n\n\treturn sfd;\n}",
    "includes": [
      "#include \"socket.h\"",
      "#include <arpa/inet.h>",
      "#include <netdb.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <windows.h>",
      "#include <winsock2.h>",
      "#include <sys/stat.h>",
      "#include <sys/time.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int verbose = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "socket_close",
          "args": [
            "sfd"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "socket_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/socket.c",
          "lines": "346-352",
          "snippet": "int socket_close(int fd) {\n#ifdef WIN32\n\treturn closesocket(fd);\n#else\n\treturn close(fd);\n#endif\n}",
          "includes": [
            "#include \"socket.h\"",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <windows.h>",
            "#include <winsock2.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"socket.h\"\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <windows.h>\n#include <winsock2.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdio.h>\n\nint socket_close(int fd) {\n#ifdef WIN32\n\treturn closesocket(fd);\n#else\n\treturn close(fd);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"connect\""
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "connect",
          "args": [
            "sfd",
            "(struct sockaddr *) &saddr",
            "sizeof(saddr)"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "idevice_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
          "lines": "267-291",
          "snippet": "LIBIMOBILEDEVICE_API idevice_error_t idevice_connect(idevice_t device, uint16_t port, idevice_connection_t *connection)\n{\n\tif (!device) {\n\t\treturn IDEVICE_E_INVALID_ARG;\n\t}\n\n\tif (device->conn_type == CONNECTION_USBMUXD) {\n\t\tint sfd = usbmuxd_connect((uint32_t)(long)device->conn_data, port);\n\t\tif (sfd < 0) {\n\t\t\tdebug_info(\"ERROR: Connecting to usbmuxd failed: %d (%s)\", sfd, strerror(-sfd));\n\t\t\treturn IDEVICE_E_UNKNOWN_ERROR;\n\t\t}\n\t\tidevice_connection_t new_connection = (idevice_connection_t)malloc(sizeof(struct idevice_connection_private));\n\t\tnew_connection->type = CONNECTION_USBMUXD;\n\t\tnew_connection->data = (void*)(long)sfd;\n\t\tnew_connection->ssl_data = NULL;\n\t\tidevice_get_udid(device, &new_connection->udid);\n\t\t*connection = new_connection;\n\t\treturn IDEVICE_E_SUCCESS;\n\t} else {\n\t\tdebug_info(\"Unknown connection type %d\", device->conn_type);\n\t}\n\n\treturn IDEVICE_E_UNKNOWN_ERROR;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"common/thread.h\"",
            "#include \"common/userpref.h\"",
            "#include \"idevice.h\"",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <usbmuxd.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "LIBIMOBILEDEVICE_API idevice_error_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nLIBIMOBILEDEVICE_API idevice_error_t idevice_connect(idevice_t device, uint16_t port, idevice_connection_t *connection)\n{\n\tif (!device) {\n\t\treturn IDEVICE_E_INVALID_ARG;\n\t}\n\n\tif (device->conn_type == CONNECTION_USBMUXD) {\n\t\tint sfd = usbmuxd_connect((uint32_t)(long)device->conn_data, port);\n\t\tif (sfd < 0) {\n\t\t\tdebug_info(\"ERROR: Connecting to usbmuxd failed: %d (%s)\", sfd, strerror(-sfd));\n\t\t\treturn IDEVICE_E_UNKNOWN_ERROR;\n\t\t}\n\t\tidevice_connection_t new_connection = (idevice_connection_t)malloc(sizeof(struct idevice_connection_private));\n\t\tnew_connection->type = CONNECTION_USBMUXD;\n\t\tnew_connection->data = (void*)(long)sfd;\n\t\tnew_connection->ssl_data = NULL;\n\t\tidevice_get_udid(device, &new_connection->udid);\n\t\t*connection = new_connection;\n\t\treturn IDEVICE_E_SUCCESS;\n\t} else {\n\t\tdebug_info(\"Unknown connection type %d\", device->conn_type);\n\t}\n\n\treturn IDEVICE_E_UNKNOWN_ERROR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "port"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(void *) &saddr",
            "0",
            "sizeof(saddr)"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"setsockopt()\""
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "sfd",
            "SOL_SOCKET",
            "SO_REUSEADDR",
            "(void*)&yes",
            "sizeof(int)"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"socket()\""
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "PF_INET",
            "SOCK_STREAM",
            "IPPROTO_TCP"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "socket_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/socket.c",
          "lines": "389-392",
          "snippet": "int socket_send(int fd, void *data, size_t length)\n{\n\treturn send(fd, data, length, 0);\n}",
          "includes": [
            "#include \"socket.h\"",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <windows.h>",
            "#include <winsock2.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"socket.h\"\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <windows.h>\n#include <winsock2.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdio.h>\n\nint socket_send(int fd, void *data, size_t length)\n{\n\treturn send(fd, data, length, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: gethostbyname returned NULL address!\\n\"",
            "__func__"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: unknown host '%s'\\n\"",
            "__func__",
            "addr"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gethostbyname",
          "args": [
            "addr"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ExitProcess",
          "args": [
            "-1"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"WSAStartup failed!\\n\""
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WSAStartup",
          "args": [
            "MAKEWORD(2,2)",
            "&wsa_data"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAKEWORD",
          "args": [
            "2",
            "2"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"socket.h\"\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <windows.h>\n#include <winsock2.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdio.h>\n\nstatic int verbose = 0;\n\nint socket_connect(const char *addr, uint16_t port)\n{\n\tint sfd = -1;\n\tint yes = 1;\n\tstruct hostent *hp;\n\tstruct sockaddr_in saddr;\n#ifdef WIN32\n\tWSADATA wsa_data;\n\tif (!wsa_init) {\n\t\tif (WSAStartup(MAKEWORD(2,2), &wsa_data) != ERROR_SUCCESS) {\n\t\t\tfprintf(stderr, \"WSAStartup failed!\\n\");\n\t\t\tExitProcess(-1);\n\t\t}\n\t\twsa_init = 1;\n\t}\n#endif\n\n\tif (!addr) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tif ((hp = gethostbyname(addr)) == NULL) {\n\t\tif (verbose >= 2)\n\t\t\tfprintf(stderr, \"%s: unknown host '%s'\\n\", __func__, addr);\n\t\treturn -1;\n\t}\n\n\tif (!hp->h_addr) {\n\t\tif (verbose >= 2)\n\t\t\tfprintf(stderr, \"%s: gethostbyname returned NULL address!\\n\",\n\t\t\t\t\t__func__);\n\t\treturn -1;\n\t}\n\n\tif (0 > (sfd = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP))) {\n\t\tperror(\"socket()\");\n\t\treturn -1;\n\t}\n\n\tif (setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void*)&yes, sizeof(int)) == -1) {\n\t\tperror(\"setsockopt()\");\n\t\tsocket_close(sfd);\n\t\treturn -1;\n\t}\n\n\tmemset((void *) &saddr, 0, sizeof(saddr));\n\tsaddr.sin_family = AF_INET;\n\tsaddr.sin_addr.s_addr = *(uint32_t *) hp->h_addr;\n\tsaddr.sin_port = htons(port);\n\n\tif (connect(sfd, (struct sockaddr *) &saddr, sizeof(saddr)) < 0) {\n\t\tperror(\"connect\");\n\t\tsocket_close(sfd);\n\t\treturn -2;\n\t}\n\n\treturn sfd;\n}"
  },
  {
    "function_name": "socket_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/socket.c",
    "lines": "146-191",
    "snippet": "int socket_create(uint16_t port)\n{\n\tint sfd = -1;\n\tint yes = 1;\n#ifdef WIN32\n\tWSADATA wsa_data;\n\tif (!wsa_init) {\n\t\tif (WSAStartup(MAKEWORD(2,2), &wsa_data) != ERROR_SUCCESS) {\n\t\t\tfprintf(stderr, \"WSAStartup failed!\\n\");\n\t\t\tExitProcess(-1);\n\t\t}\n\t\twsa_init = 1;\n\t}\n#endif\n\tstruct sockaddr_in saddr;\n\n\tif (0 > (sfd = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP))) {\n\t\tperror(\"socket()\");\n\t\treturn -1;\n\t}\n\n\tif (setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void*)&yes, sizeof(int)) == -1) {\n\t\tperror(\"setsockopt()\");\n\t\tsocket_close(sfd);\n\t\treturn -1;\n\t}\n\n\tmemset((void *) &saddr, 0, sizeof(saddr));\n\tsaddr.sin_family = AF_INET;\n\tsaddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\tsaddr.sin_port = htons(port);\n\n\tif (0 > bind(sfd, (struct sockaddr *) &saddr, sizeof(saddr))) {\n\t\tperror(\"bind()\");\n\t\tsocket_close(sfd);\n\t\treturn -1;\n\t}\n\n\tif (listen(sfd, 1) == -1) {\n\t\tperror(\"listen()\");\n\t\tsocket_close(sfd);\n\t\treturn -1;\n\t}\n\n\treturn sfd;\n}",
    "includes": [
      "#include \"socket.h\"",
      "#include <arpa/inet.h>",
      "#include <netdb.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <windows.h>",
      "#include <winsock2.h>",
      "#include <sys/stat.h>",
      "#include <sys/time.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "socket_close",
          "args": [
            "sfd"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "socket_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/socket.c",
          "lines": "346-352",
          "snippet": "int socket_close(int fd) {\n#ifdef WIN32\n\treturn closesocket(fd);\n#else\n\treturn close(fd);\n#endif\n}",
          "includes": [
            "#include \"socket.h\"",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <windows.h>",
            "#include <winsock2.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"socket.h\"\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <windows.h>\n#include <winsock2.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdio.h>\n\nint socket_close(int fd) {\n#ifdef WIN32\n\treturn closesocket(fd);\n#else\n\treturn close(fd);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"listen()\""
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "listen",
          "args": [
            "sfd",
            "1"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"bind()\""
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bind",
          "args": [
            "sfd",
            "(struct sockaddr *) &saddr",
            "sizeof(saddr)"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "port"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "INADDR_ANY"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(void *) &saddr",
            "0",
            "sizeof(saddr)"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"setsockopt()\""
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "sfd",
            "SOL_SOCKET",
            "SO_REUSEADDR",
            "(void*)&yes",
            "sizeof(int)"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"socket()\""
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "PF_INET",
            "SOCK_STREAM",
            "IPPROTO_TCP"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "socket_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/socket.c",
          "lines": "389-392",
          "snippet": "int socket_send(int fd, void *data, size_t length)\n{\n\treturn send(fd, data, length, 0);\n}",
          "includes": [
            "#include \"socket.h\"",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <windows.h>",
            "#include <winsock2.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"socket.h\"\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <windows.h>\n#include <winsock2.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdio.h>\n\nint socket_send(int fd, void *data, size_t length)\n{\n\treturn send(fd, data, length, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ExitProcess",
          "args": [
            "-1"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"WSAStartup failed!\\n\""
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WSAStartup",
          "args": [
            "MAKEWORD(2,2)",
            "&wsa_data"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAKEWORD",
          "args": [
            "2",
            "2"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"socket.h\"\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <windows.h>\n#include <winsock2.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdio.h>\n\nint socket_create(uint16_t port)\n{\n\tint sfd = -1;\n\tint yes = 1;\n#ifdef WIN32\n\tWSADATA wsa_data;\n\tif (!wsa_init) {\n\t\tif (WSAStartup(MAKEWORD(2,2), &wsa_data) != ERROR_SUCCESS) {\n\t\t\tfprintf(stderr, \"WSAStartup failed!\\n\");\n\t\t\tExitProcess(-1);\n\t\t}\n\t\twsa_init = 1;\n\t}\n#endif\n\tstruct sockaddr_in saddr;\n\n\tif (0 > (sfd = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP))) {\n\t\tperror(\"socket()\");\n\t\treturn -1;\n\t}\n\n\tif (setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void*)&yes, sizeof(int)) == -1) {\n\t\tperror(\"setsockopt()\");\n\t\tsocket_close(sfd);\n\t\treturn -1;\n\t}\n\n\tmemset((void *) &saddr, 0, sizeof(saddr));\n\tsaddr.sin_family = AF_INET;\n\tsaddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\tsaddr.sin_port = htons(port);\n\n\tif (0 > bind(sfd, (struct sockaddr *) &saddr, sizeof(saddr))) {\n\t\tperror(\"bind()\");\n\t\tsocket_close(sfd);\n\t\treturn -1;\n\t}\n\n\tif (listen(sfd, 1) == -1) {\n\t\tperror(\"listen()\");\n\t\tsocket_close(sfd);\n\t\treturn -1;\n\t}\n\n\treturn sfd;\n}"
  },
  {
    "function_name": "socket_connect_unix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/socket.c",
    "lines": "99-143",
    "snippet": "int socket_connect_unix(const char *filename)\n{\n\tstruct sockaddr_un name;\n\tint sfd = -1;\n\tsize_t size;\n\tstruct stat fst;\n\n\t// check if socket file exists...\n\tif (stat(filename, &fst) != 0) {\n\t\tif (verbose >= 2)\n\t\t\tfprintf(stderr, \"%s: stat '%s': %s\\n\", __func__, filename,\n\t\t\t\t\tstrerror(errno));\n\t\treturn -1;\n\t}\n\t// ... and if it is a unix domain socket\n\tif (!S_ISSOCK(fst.st_mode)) {\n\t\tif (verbose >= 2)\n\t\t\tfprintf(stderr, \"%s: File '%s' is not a socket!\\n\", __func__,\n\t\t\t\t\tfilename);\n\t\treturn -1;\n\t}\n\t// make a new socket\n\tif ((sfd = socket(PF_LOCAL, SOCK_STREAM, 0)) < 0) {\n\t\tif (verbose >= 2)\n\t\t\tfprintf(stderr, \"%s: socket: %s\\n\", __func__, strerror(errno));\n\t\treturn -1;\n\t}\n\t// and connect to 'filename'\n\tname.sun_family = AF_LOCAL;\n\tstrncpy(name.sun_path, filename, sizeof(name.sun_path));\n\tname.sun_path[sizeof(name.sun_path) - 1] = 0;\n\n\tsize = (offsetof(struct sockaddr_un, sun_path)\n\t\t\t+ strlen(name.sun_path) + 1);\n\n\tif (connect(sfd, (struct sockaddr *) &name, size) < 0) {\n\t\tsocket_close(sfd);\n\t\tif (verbose >= 2)\n\t\t\tfprintf(stderr, \"%s: connect: %s\\n\", __func__,\n\t\t\t\t\tstrerror(errno));\n\t\treturn -1;\n\t}\n\n\treturn sfd;\n}",
    "includes": [
      "#include \"socket.h\"",
      "#include <arpa/inet.h>",
      "#include <netdb.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <windows.h>",
      "#include <winsock2.h>",
      "#include <sys/stat.h>",
      "#include <sys/time.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int verbose = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: connect: %s\\n\"",
            "__func__",
            "strerror(errno)"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket_close",
          "args": [
            "sfd"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "socket_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/socket.c",
          "lines": "346-352",
          "snippet": "int socket_close(int fd) {\n#ifdef WIN32\n\treturn closesocket(fd);\n#else\n\treturn close(fd);\n#endif\n}",
          "includes": [
            "#include \"socket.h\"",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <windows.h>",
            "#include <winsock2.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"socket.h\"\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <windows.h>\n#include <winsock2.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdio.h>\n\nint socket_close(int fd) {\n#ifdef WIN32\n\treturn closesocket(fd);\n#else\n\treturn close(fd);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "connect",
          "args": [
            "sfd",
            "(struct sockaddr *) &name",
            "size"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "idevice_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
          "lines": "267-291",
          "snippet": "LIBIMOBILEDEVICE_API idevice_error_t idevice_connect(idevice_t device, uint16_t port, idevice_connection_t *connection)\n{\n\tif (!device) {\n\t\treturn IDEVICE_E_INVALID_ARG;\n\t}\n\n\tif (device->conn_type == CONNECTION_USBMUXD) {\n\t\tint sfd = usbmuxd_connect((uint32_t)(long)device->conn_data, port);\n\t\tif (sfd < 0) {\n\t\t\tdebug_info(\"ERROR: Connecting to usbmuxd failed: %d (%s)\", sfd, strerror(-sfd));\n\t\t\treturn IDEVICE_E_UNKNOWN_ERROR;\n\t\t}\n\t\tidevice_connection_t new_connection = (idevice_connection_t)malloc(sizeof(struct idevice_connection_private));\n\t\tnew_connection->type = CONNECTION_USBMUXD;\n\t\tnew_connection->data = (void*)(long)sfd;\n\t\tnew_connection->ssl_data = NULL;\n\t\tidevice_get_udid(device, &new_connection->udid);\n\t\t*connection = new_connection;\n\t\treturn IDEVICE_E_SUCCESS;\n\t} else {\n\t\tdebug_info(\"Unknown connection type %d\", device->conn_type);\n\t}\n\n\treturn IDEVICE_E_UNKNOWN_ERROR;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"common/thread.h\"",
            "#include \"common/userpref.h\"",
            "#include \"idevice.h\"",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <usbmuxd.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "LIBIMOBILEDEVICE_API idevice_error_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nLIBIMOBILEDEVICE_API idevice_error_t idevice_connect(idevice_t device, uint16_t port, idevice_connection_t *connection)\n{\n\tif (!device) {\n\t\treturn IDEVICE_E_INVALID_ARG;\n\t}\n\n\tif (device->conn_type == CONNECTION_USBMUXD) {\n\t\tint sfd = usbmuxd_connect((uint32_t)(long)device->conn_data, port);\n\t\tif (sfd < 0) {\n\t\t\tdebug_info(\"ERROR: Connecting to usbmuxd failed: %d (%s)\", sfd, strerror(-sfd));\n\t\t\treturn IDEVICE_E_UNKNOWN_ERROR;\n\t\t}\n\t\tidevice_connection_t new_connection = (idevice_connection_t)malloc(sizeof(struct idevice_connection_private));\n\t\tnew_connection->type = CONNECTION_USBMUXD;\n\t\tnew_connection->data = (void*)(long)sfd;\n\t\tnew_connection->ssl_data = NULL;\n\t\tidevice_get_udid(device, &new_connection->udid);\n\t\t*connection = new_connection;\n\t\treturn IDEVICE_E_SUCCESS;\n\t} else {\n\t\tdebug_info(\"Unknown connection type %d\", device->conn_type);\n\t}\n\n\treturn IDEVICE_E_UNKNOWN_ERROR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name.sun_path"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "name.sun_path",
            "filename",
            "sizeof(name.sun_path)"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: socket: %s\\n\"",
            "__func__",
            "strerror(errno)"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "PF_LOCAL",
            "SOCK_STREAM",
            "0"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "socket_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/socket.c",
          "lines": "389-392",
          "snippet": "int socket_send(int fd, void *data, size_t length)\n{\n\treturn send(fd, data, length, 0);\n}",
          "includes": [
            "#include \"socket.h\"",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <windows.h>",
            "#include <winsock2.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"socket.h\"\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <windows.h>\n#include <winsock2.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdio.h>\n\nint socket_send(int fd, void *data, size_t length)\n{\n\treturn send(fd, data, length, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: File '%s' is not a socket!\\n\"",
            "__func__",
            "filename"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISSOCK",
          "args": [
            "fst.st_mode"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: stat '%s': %s\\n\"",
            "__func__",
            "filename",
            "strerror(errno)"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "filename",
            "&fst"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "mobilebackup_write_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
          "lines": "322-338",
          "snippet": "static void mobilebackup_write_status(const char *path, int status)\n{\n\tstruct stat st;\n\tplist_t status_plist = plist_new_dict();\n\tplist_dict_set_item(status_plist, \"Backup Success\", plist_new_bool(status));\n\tchar *file_path = mobilebackup_build_path(path, \"Status\", \".plist\");\n\n\tif (stat(file_path, &st) == 0)\n\t\tremove(file_path);\n\n\tplist_write_to_filename(status_plist, file_path, PLIST_FORMAT_XML);\n\n\tplist_free(status_plist);\n\tstatus_plist = NULL;\n\n\tfree(file_path);\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <unistd.h>",
            "#include <gcrypt.h>",
            "#include <openssl/sha.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void mobilebackup_write_status(const char *path, int status)\n{\n\tstruct stat st;\n\tplist_t status_plist = plist_new_dict();\n\tplist_dict_set_item(status_plist, \"Backup Success\", plist_new_bool(status));\n\tchar *file_path = mobilebackup_build_path(path, \"Status\", \".plist\");\n\n\tif (stat(file_path, &st) == 0)\n\t\tremove(file_path);\n\n\tplist_write_to_filename(status_plist, file_path, PLIST_FORMAT_XML);\n\n\tplist_free(status_plist);\n\tstatus_plist = NULL;\n\n\tfree(file_path);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"socket.h\"\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <windows.h>\n#include <winsock2.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdio.h>\n\nstatic int verbose = 0;\n\nint socket_connect_unix(const char *filename)\n{\n\tstruct sockaddr_un name;\n\tint sfd = -1;\n\tsize_t size;\n\tstruct stat fst;\n\n\t// check if socket file exists...\n\tif (stat(filename, &fst) != 0) {\n\t\tif (verbose >= 2)\n\t\t\tfprintf(stderr, \"%s: stat '%s': %s\\n\", __func__, filename,\n\t\t\t\t\tstrerror(errno));\n\t\treturn -1;\n\t}\n\t// ... and if it is a unix domain socket\n\tif (!S_ISSOCK(fst.st_mode)) {\n\t\tif (verbose >= 2)\n\t\t\tfprintf(stderr, \"%s: File '%s' is not a socket!\\n\", __func__,\n\t\t\t\t\tfilename);\n\t\treturn -1;\n\t}\n\t// make a new socket\n\tif ((sfd = socket(PF_LOCAL, SOCK_STREAM, 0)) < 0) {\n\t\tif (verbose >= 2)\n\t\t\tfprintf(stderr, \"%s: socket: %s\\n\", __func__, strerror(errno));\n\t\treturn -1;\n\t}\n\t// and connect to 'filename'\n\tname.sun_family = AF_LOCAL;\n\tstrncpy(name.sun_path, filename, sizeof(name.sun_path));\n\tname.sun_path[sizeof(name.sun_path) - 1] = 0;\n\n\tsize = (offsetof(struct sockaddr_un, sun_path)\n\t\t\t+ strlen(name.sun_path) + 1);\n\n\tif (connect(sfd, (struct sockaddr *) &name, size) < 0) {\n\t\tsocket_close(sfd);\n\t\tif (verbose >= 2)\n\t\t\tfprintf(stderr, \"%s: connect: %s\\n\", __func__,\n\t\t\t\t\tstrerror(errno));\n\t\treturn -1;\n\t}\n\n\treturn sfd;\n}"
  },
  {
    "function_name": "socket_create_unix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/socket.c",
    "lines": "53-97",
    "snippet": "int socket_create_unix(const char *filename)\n{\n\tstruct sockaddr_un name;\n\tint sock;\n\tsize_t size;\n\n\t// remove if still present\n\tunlink(filename);\n\n\t/* Create the socket. */\n\tsock = socket(PF_LOCAL, SOCK_STREAM, 0);\n\tif (sock < 0) {\n\t\tperror(\"socket\");\n\t\treturn -1;\n\t}\n\n\t/* Bind a name to the socket. */\n\tname.sun_family = AF_LOCAL;\n\tstrncpy(name.sun_path, filename, sizeof(name.sun_path));\n\tname.sun_path[sizeof(name.sun_path) - 1] = '\\0';\n\n\t/* The size of the address is\n\t   the offset of the start of the filename,\n\t   plus its length,\n\t   plus one for the terminating null byte.\n\t   Alternatively you can just do:\n\t   size = SUN_LEN (&name);\n\t */\n\tsize = (offsetof(struct sockaddr_un, sun_path)\n\t\t\t+ strlen(name.sun_path) + 1);\n\n\tif (bind(sock, (struct sockaddr *) &name, size) < 0) {\n\t\tperror(\"bind\");\n\t\tsocket_close(sock);\n\t\treturn -1;\n\t}\n\n\tif (listen(sock, 10) < 0) {\n\t\tperror(\"listen\");\n\t\tsocket_close(sock);\n\t\treturn -1;\n\t}\n\n\treturn sock;\n}",
    "includes": [
      "#include \"socket.h\"",
      "#include <arpa/inet.h>",
      "#include <netdb.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <windows.h>",
      "#include <winsock2.h>",
      "#include <sys/stat.h>",
      "#include <sys/time.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "socket_close",
          "args": [
            "sock"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "socket_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/socket.c",
          "lines": "346-352",
          "snippet": "int socket_close(int fd) {\n#ifdef WIN32\n\treturn closesocket(fd);\n#else\n\treturn close(fd);\n#endif\n}",
          "includes": [
            "#include \"socket.h\"",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <windows.h>",
            "#include <winsock2.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"socket.h\"\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <windows.h>\n#include <winsock2.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdio.h>\n\nint socket_close(int fd) {\n#ifdef WIN32\n\treturn closesocket(fd);\n#else\n\treturn close(fd);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"listen\""
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "listen",
          "args": [
            "sock",
            "10"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"bind\""
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bind",
          "args": [
            "sock",
            "(struct sockaddr *) &name",
            "size"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name.sun_path"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "name.sun_path",
            "filename",
            "sizeof(name.sun_path)"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"socket\""
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "PF_LOCAL",
            "SOCK_STREAM",
            "0"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "socket_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/socket.c",
          "lines": "389-392",
          "snippet": "int socket_send(int fd, void *data, size_t length)\n{\n\treturn send(fd, data, length, 0);\n}",
          "includes": [
            "#include \"socket.h\"",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <windows.h>",
            "#include <winsock2.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"socket.h\"\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <windows.h>\n#include <winsock2.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdio.h>\n\nint socket_send(int fd, void *data, size_t length)\n{\n\treturn send(fd, data, length, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "filename"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"socket.h\"\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <windows.h>\n#include <winsock2.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdio.h>\n\nint socket_create_unix(const char *filename)\n{\n\tstruct sockaddr_un name;\n\tint sock;\n\tsize_t size;\n\n\t// remove if still present\n\tunlink(filename);\n\n\t/* Create the socket. */\n\tsock = socket(PF_LOCAL, SOCK_STREAM, 0);\n\tif (sock < 0) {\n\t\tperror(\"socket\");\n\t\treturn -1;\n\t}\n\n\t/* Bind a name to the socket. */\n\tname.sun_family = AF_LOCAL;\n\tstrncpy(name.sun_path, filename, sizeof(name.sun_path));\n\tname.sun_path[sizeof(name.sun_path) - 1] = '\\0';\n\n\t/* The size of the address is\n\t   the offset of the start of the filename,\n\t   plus its length,\n\t   plus one for the terminating null byte.\n\t   Alternatively you can just do:\n\t   size = SUN_LEN (&name);\n\t */\n\tsize = (offsetof(struct sockaddr_un, sun_path)\n\t\t\t+ strlen(name.sun_path) + 1);\n\n\tif (bind(sock, (struct sockaddr *) &name, size) < 0) {\n\t\tperror(\"bind\");\n\t\tsocket_close(sock);\n\t\treturn -1;\n\t}\n\n\tif (listen(sock, 10) < 0) {\n\t\tperror(\"listen\");\n\t\tsocket_close(sock);\n\t\treturn -1;\n\t}\n\n\treturn sock;\n}"
  },
  {
    "function_name": "socket_set_verbose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/socket.c",
    "lines": "47-50",
    "snippet": "void socket_set_verbose(int level)\n{\n\tverbose = level;\n}",
    "includes": [
      "#include \"socket.h\"",
      "#include <arpa/inet.h>",
      "#include <netdb.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <windows.h>",
      "#include <winsock2.h>",
      "#include <sys/stat.h>",
      "#include <sys/time.h>",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int verbose = 0;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"socket.h\"\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <windows.h>\n#include <winsock2.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdio.h>\n\nstatic int verbose = 0;\n\nvoid socket_set_verbose(int level)\n{\n\tverbose = level;\n}"
  }
]