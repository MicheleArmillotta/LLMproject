[
  {
    "function_name": "idevice_connection_disable_ssl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
    "lines": "793-821",
    "snippet": "LIBIMOBILEDEVICE_API idevice_error_t idevice_connection_disable_ssl(idevice_connection_t connection)\n{\n\tif (!connection)\n\t\treturn IDEVICE_E_INVALID_ARG;\n\tif (!connection->ssl_data) {\n\t\t/* ignore if ssl is not enabled */\n\t\treturn IDEVICE_E_SUCCESS;\n\t}\n\n#ifdef HAVE_OPENSSL\n\tif (connection->ssl_data->session) {\n\t\t/* see: https://www.openssl.org/docs/ssl/SSL_shutdown.html#RETURN_VALUES */\n\t\tif (SSL_shutdown(connection->ssl_data->session) == 0) {\n\t\t\tSSL_shutdown(connection->ssl_data->session);\n\t\t}\n\t}\n#else\n\tif (connection->ssl_data->session) {\n\t\tgnutls_bye(connection->ssl_data->session, GNUTLS_SHUT_RDWR);\n\t}\n#endif\n\tinternal_ssl_cleanup(connection->ssl_data);\n\tfree(connection->ssl_data);\n\tconnection->ssl_data = NULL;\n\n\tdebug_info(\"SSL mode disabled\");\n\n\treturn IDEVICE_E_SUCCESS;\n}",
    "includes": [
      "#include \"common/debug.h\"",
      "#include \"common/thread.h\"",
      "#include \"common/userpref.h\"",
      "#include \"idevice.h\"",
      "#include <gnutls/gnutls.h>",
      "#include <openssl/ssl.h>",
      "#include <openssl/err.h>",
      "#include <usbmuxd.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "LIBIMOBILEDEVICE_API idevice_error_t"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"SSL mode disabled\""
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "connection->ssl_data"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "idevice_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
          "lines": "247-265",
          "snippet": "LIBIMOBILEDEVICE_API idevice_error_t idevice_free(idevice_t device)\n{\n\tif (!device)\n\t\treturn IDEVICE_E_INVALID_ARG;\n\tidevice_error_t ret = IDEVICE_E_UNKNOWN_ERROR;\n\n\tret = IDEVICE_E_SUCCESS;\n\n\tfree(device->udid);\n\n\tif (device->conn_type == CONNECTION_USBMUXD) {\n\t\tdevice->conn_data = 0;\n\t}\n\tif (device->conn_data) {\n\t\tfree(device->conn_data);\n\t}\n\tfree(device);\n\treturn ret;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"common/thread.h\"",
            "#include \"common/userpref.h\"",
            "#include \"idevice.h\"",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <usbmuxd.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "LIBIMOBILEDEVICE_API idevice_error_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nLIBIMOBILEDEVICE_API idevice_error_t idevice_free(idevice_t device)\n{\n\tif (!device)\n\t\treturn IDEVICE_E_INVALID_ARG;\n\tidevice_error_t ret = IDEVICE_E_UNKNOWN_ERROR;\n\n\tret = IDEVICE_E_SUCCESS;\n\n\tfree(device->udid);\n\n\tif (device->conn_type == CONNECTION_USBMUXD) {\n\t\tdevice->conn_data = 0;\n\t}\n\tif (device->conn_data) {\n\t\tfree(device->conn_data);\n\t}\n\tfree(device);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "internal_ssl_cleanup",
          "args": [
            "connection->ssl_data"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "internal_ssl_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
          "lines": "556-588",
          "snippet": "static void internal_ssl_cleanup(ssl_data_t ssl_data)\n{\n\tif (!ssl_data)\n\t\treturn;\n\n#ifdef HAVE_OPENSSL\n\tif (ssl_data->session) {\n\t\tSSL_free(ssl_data->session);\n\t}\n\tif (ssl_data->ctx) {\n\t\tSSL_CTX_free(ssl_data->ctx);\n\t}\n#else\n\tif (ssl_data->session) {\n\t\tgnutls_deinit(ssl_data->session);\n\t}\n\tif (ssl_data->certificate) {\n\t\tgnutls_certificate_free_credentials(ssl_data->certificate);\n\t}\n\tif (ssl_data->root_cert) {\n\t\tgnutls_x509_crt_deinit(ssl_data->root_cert);\n\t}\n\tif (ssl_data->host_cert) {\n\t\tgnutls_x509_crt_deinit(ssl_data->host_cert);\n\t}\n\tif (ssl_data->root_privkey) {\n\t\tgnutls_x509_privkey_deinit(ssl_data->root_privkey);\n\t}\n\tif (ssl_data->host_privkey) {\n\t\tgnutls_x509_privkey_deinit(ssl_data->host_privkey);\n\t}\n#endif\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"common/thread.h\"",
            "#include \"common/userpref.h\"",
            "#include \"idevice.h\"",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <usbmuxd.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nstatic void internal_ssl_cleanup(ssl_data_t ssl_data)\n{\n\tif (!ssl_data)\n\t\treturn;\n\n#ifdef HAVE_OPENSSL\n\tif (ssl_data->session) {\n\t\tSSL_free(ssl_data->session);\n\t}\n\tif (ssl_data->ctx) {\n\t\tSSL_CTX_free(ssl_data->ctx);\n\t}\n#else\n\tif (ssl_data->session) {\n\t\tgnutls_deinit(ssl_data->session);\n\t}\n\tif (ssl_data->certificate) {\n\t\tgnutls_certificate_free_credentials(ssl_data->certificate);\n\t}\n\tif (ssl_data->root_cert) {\n\t\tgnutls_x509_crt_deinit(ssl_data->root_cert);\n\t}\n\tif (ssl_data->host_cert) {\n\t\tgnutls_x509_crt_deinit(ssl_data->host_cert);\n\t}\n\tif (ssl_data->root_privkey) {\n\t\tgnutls_x509_privkey_deinit(ssl_data->root_privkey);\n\t}\n\tif (ssl_data->host_privkey) {\n\t\tgnutls_x509_privkey_deinit(ssl_data->host_privkey);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "gnutls_bye",
          "args": [
            "connection->ssl_data->session",
            "GNUTLS_SHUT_RDWR"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_shutdown",
          "args": [
            "connection->ssl_data->session"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_shutdown",
          "args": [
            "connection->ssl_data->session"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nLIBIMOBILEDEVICE_API idevice_error_t idevice_connection_disable_ssl(idevice_connection_t connection)\n{\n\tif (!connection)\n\t\treturn IDEVICE_E_INVALID_ARG;\n\tif (!connection->ssl_data) {\n\t\t/* ignore if ssl is not enabled */\n\t\treturn IDEVICE_E_SUCCESS;\n\t}\n\n#ifdef HAVE_OPENSSL\n\tif (connection->ssl_data->session) {\n\t\t/* see: https://www.openssl.org/docs/ssl/SSL_shutdown.html#RETURN_VALUES */\n\t\tif (SSL_shutdown(connection->ssl_data->session) == 0) {\n\t\t\tSSL_shutdown(connection->ssl_data->session);\n\t\t}\n\t}\n#else\n\tif (connection->ssl_data->session) {\n\t\tgnutls_bye(connection->ssl_data->session, GNUTLS_SHUT_RDWR);\n\t}\n#endif\n\tinternal_ssl_cleanup(connection->ssl_data);\n\tfree(connection->ssl_data);\n\tconnection->ssl_data = NULL;\n\n\tdebug_info(\"SSL mode disabled\");\n\n\treturn IDEVICE_E_SUCCESS;\n}"
  },
  {
    "function_name": "idevice_connection_enable_ssl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
    "lines": "649-791",
    "snippet": "LIBIMOBILEDEVICE_API idevice_error_t idevice_connection_enable_ssl(idevice_connection_t connection)\n{\n\tif (!connection || connection->ssl_data)\n\t\treturn IDEVICE_E_INVALID_ARG;\n\n\tidevice_error_t ret = IDEVICE_E_SSL_ERROR;\n\tuint32_t return_me = 0;\n\tplist_t pair_record = NULL;\n\n\tuserpref_read_pair_record(connection->udid, &pair_record);\n\tif (!pair_record) {\n\t\tdebug_info(\"ERROR: Failed enabling SSL. Unable to read pair record for udid %s.\", connection->udid);\n\t\treturn ret;\n\t}\n\n#ifdef HAVE_OPENSSL\n\tkey_data_t root_cert = { NULL, 0 };\n\tkey_data_t root_privkey = { NULL, 0 };\n\n\tpair_record_import_crt_with_name(pair_record, USERPREF_ROOT_CERTIFICATE_KEY, &root_cert);\n\tpair_record_import_key_with_name(pair_record, USERPREF_ROOT_PRIVATE_KEY_KEY, &root_privkey);\n\n\tif (pair_record)\n\t\tplist_free(pair_record);\n\n\tBIO *ssl_bio = BIO_new(BIO_s_socket());\n\tif (!ssl_bio) {\n\t\tdebug_info(\"ERROR: Could not create SSL bio.\");\n\t\treturn ret;\n\t}\n\tBIO_set_fd(ssl_bio, (int)(long)connection->data, BIO_NOCLOSE);\n\n\tSSL_CTX *ssl_ctx = SSL_CTX_new(SSLv3_method());\n\tif (ssl_ctx == NULL) {\n\t\tdebug_info(\"ERROR: Could not create SSL context.\");\n\t\tBIO_free(ssl_bio);\n\t\treturn ret;\n\t}\n\n\tBIO* membp;\n\tX509* rootCert = NULL;\n\tmembp = BIO_new_mem_buf(root_cert.data, root_cert.size);\n\tPEM_read_bio_X509(membp, &rootCert, NULL, NULL);\n\tBIO_free(membp);\n\tif (SSL_CTX_use_certificate(ssl_ctx, rootCert) != 1) {\n\t\tdebug_info(\"WARNING: Could not load RootCertificate\");\n\t}\n\tX509_free(rootCert);\n\tfree(root_cert.data);\n\n\tRSA* rootPrivKey = NULL;\n\tmembp = BIO_new_mem_buf(root_privkey.data, root_privkey.size);\n\tPEM_read_bio_RSAPrivateKey(membp, &rootPrivKey, NULL, NULL);\n\tBIO_free(membp);\n\tif (SSL_CTX_use_RSAPrivateKey(ssl_ctx, rootPrivKey) != 1) {\n\t\tdebug_info(\"WARNING: Could not load RootPrivateKey\");\n\t}\n\tRSA_free(rootPrivKey);\n\tfree(root_privkey.data);\n\n\tSSL *ssl = SSL_new(ssl_ctx);\n\tif (!ssl) {\n\t\tdebug_info(\"ERROR: Could not create SSL object\");\n\t\tBIO_free(ssl_bio);\n\t\tSSL_CTX_free(ssl_ctx);\n\t\treturn ret;\n\t}\n\tSSL_set_connect_state(ssl);\n\tSSL_set_verify(ssl, 0, ssl_verify_callback);\n\tSSL_set_bio(ssl, ssl_bio, ssl_bio);\n\n\treturn_me = SSL_do_handshake(ssl);\n\tif (return_me != 1) {\n\t\tdebug_info(\"ERROR in SSL_do_handshake: %s\", ssl_error_to_string(SSL_get_error(ssl, return_me)));\n\t\tSSL_free(ssl);\n\t\tSSL_CTX_free(ssl_ctx);\n\t} else {\n\t\tssl_data_t ssl_data_loc = (ssl_data_t)malloc(sizeof(struct ssl_data_private));\n\t\tssl_data_loc->session = ssl;\n\t\tssl_data_loc->ctx = ssl_ctx;\n\t\tconnection->ssl_data = ssl_data_loc;\n\t\tret = IDEVICE_E_SUCCESS;\n\t\tdebug_info(\"SSL mode enabled, cipher: %s\", SSL_get_cipher(ssl));\n\t}\n\t/* required for proper multi-thread clean up to prevent leaks */\n#ifdef HAVE_ERR_REMOVE_THREAD_STATE\n\tERR_remove_thread_state(NULL);\n#else\n\tERR_remove_state(0);\n#endif\n#else\n\tssl_data_t ssl_data_loc = (ssl_data_t)malloc(sizeof(struct ssl_data_private));\n\n\t/* Set up GnuTLS... */\n\tdebug_info(\"enabling SSL mode\");\n\terrno = 0;\n\tgnutls_certificate_allocate_credentials(&ssl_data_loc->certificate);\n\tgnutls_certificate_client_set_retrieve_function(ssl_data_loc->certificate, internal_cert_callback);\n\tgnutls_init(&ssl_data_loc->session, GNUTLS_CLIENT);\n\tgnutls_priority_set_direct(ssl_data_loc->session, \"NONE:+VERS-SSL3.0:+ANON-DH:+RSA:+AES-128-CBC:+AES-256-CBC:+SHA1:+MD5:+COMP-NULL\", NULL);\n\tgnutls_credentials_set(ssl_data_loc->session, GNUTLS_CRD_CERTIFICATE, ssl_data_loc->certificate);\n\tgnutls_session_set_ptr(ssl_data_loc->session, ssl_data_loc);\n\n\tgnutls_x509_crt_init(&ssl_data_loc->root_cert);\n\tgnutls_x509_crt_init(&ssl_data_loc->host_cert);\n\tgnutls_x509_privkey_init(&ssl_data_loc->root_privkey);\n\tgnutls_x509_privkey_init(&ssl_data_loc->host_privkey);\n\n\tpair_record_import_crt_with_name(pair_record, USERPREF_ROOT_CERTIFICATE_KEY, ssl_data_loc->root_cert);\n\tpair_record_import_crt_with_name(pair_record, USERPREF_HOST_CERTIFICATE_KEY, ssl_data_loc->host_cert);\n\tpair_record_import_key_with_name(pair_record, USERPREF_ROOT_PRIVATE_KEY_KEY, ssl_data_loc->root_privkey);\n\tpair_record_import_key_with_name(pair_record, USERPREF_HOST_PRIVATE_KEY_KEY, ssl_data_loc->host_privkey);\n\n\tif (pair_record)\n\t\tplist_free(pair_record);\n\n\tdebug_info(\"GnuTLS step 1...\");\n\tgnutls_transport_set_ptr(ssl_data_loc->session, (gnutls_transport_ptr_t)connection);\n\tdebug_info(\"GnuTLS step 2...\");\n\tgnutls_transport_set_push_function(ssl_data_loc->session, (gnutls_push_func) & internal_ssl_write);\n\tdebug_info(\"GnuTLS step 3...\");\n\tgnutls_transport_set_pull_function(ssl_data_loc->session, (gnutls_pull_func) & internal_ssl_read);\n\tdebug_info(\"GnuTLS step 4 -- now handshaking...\");\n\tif (errno) {\n\t\tdebug_info(\"WARNING: errno says %s before handshake!\", strerror(errno));\n\t}\n\treturn_me = gnutls_handshake(ssl_data_loc->session);\n\tdebug_info(\"GnuTLS handshake done...\");\n\n\tif (return_me != GNUTLS_E_SUCCESS) {\n\t\tinternal_ssl_cleanup(ssl_data_loc);\n\t\tfree(ssl_data_loc);\n\t\tdebug_info(\"GnuTLS reported something wrong.\");\n\t\tgnutls_perror(return_me);\n\t\tdebug_info(\"oh.. errno says %s\", strerror(errno));\n\t} else {\n\t\tconnection->ssl_data = ssl_data_loc;\n\t\tret = IDEVICE_E_SUCCESS;\n\t\tdebug_info(\"SSL mode enabled\");\n\t}\n#endif\n\treturn ret;\n}",
    "includes": [
      "#include \"common/debug.h\"",
      "#include \"common/thread.h\"",
      "#include \"common/userpref.h\"",
      "#include \"idevice.h\"",
      "#include <gnutls/gnutls.h>",
      "#include <openssl/ssl.h>",
      "#include <openssl/err.h>",
      "#include <usbmuxd.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define HAVE_ERR_REMOVE_THREAD_STATE 1"
    ],
    "globals_used": [
      "LIBIMOBILEDEVICE_API idevice_error_t"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"SSL mode enabled\""
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"oh.. errno says %s\"",
            "strerror(errno)"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_perror",
          "args": [
            "return_me"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"GnuTLS reported something wrong.\""
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ssl_data_loc"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "idevice_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
          "lines": "247-265",
          "snippet": "LIBIMOBILEDEVICE_API idevice_error_t idevice_free(idevice_t device)\n{\n\tif (!device)\n\t\treturn IDEVICE_E_INVALID_ARG;\n\tidevice_error_t ret = IDEVICE_E_UNKNOWN_ERROR;\n\n\tret = IDEVICE_E_SUCCESS;\n\n\tfree(device->udid);\n\n\tif (device->conn_type == CONNECTION_USBMUXD) {\n\t\tdevice->conn_data = 0;\n\t}\n\tif (device->conn_data) {\n\t\tfree(device->conn_data);\n\t}\n\tfree(device);\n\treturn ret;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"common/thread.h\"",
            "#include \"common/userpref.h\"",
            "#include \"idevice.h\"",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <usbmuxd.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "LIBIMOBILEDEVICE_API idevice_error_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nLIBIMOBILEDEVICE_API idevice_error_t idevice_free(idevice_t device)\n{\n\tif (!device)\n\t\treturn IDEVICE_E_INVALID_ARG;\n\tidevice_error_t ret = IDEVICE_E_UNKNOWN_ERROR;\n\n\tret = IDEVICE_E_SUCCESS;\n\n\tfree(device->udid);\n\n\tif (device->conn_type == CONNECTION_USBMUXD) {\n\t\tdevice->conn_data = 0;\n\t}\n\tif (device->conn_data) {\n\t\tfree(device->conn_data);\n\t}\n\tfree(device);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "internal_ssl_cleanup",
          "args": [
            "ssl_data_loc"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "internal_ssl_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
          "lines": "556-588",
          "snippet": "static void internal_ssl_cleanup(ssl_data_t ssl_data)\n{\n\tif (!ssl_data)\n\t\treturn;\n\n#ifdef HAVE_OPENSSL\n\tif (ssl_data->session) {\n\t\tSSL_free(ssl_data->session);\n\t}\n\tif (ssl_data->ctx) {\n\t\tSSL_CTX_free(ssl_data->ctx);\n\t}\n#else\n\tif (ssl_data->session) {\n\t\tgnutls_deinit(ssl_data->session);\n\t}\n\tif (ssl_data->certificate) {\n\t\tgnutls_certificate_free_credentials(ssl_data->certificate);\n\t}\n\tif (ssl_data->root_cert) {\n\t\tgnutls_x509_crt_deinit(ssl_data->root_cert);\n\t}\n\tif (ssl_data->host_cert) {\n\t\tgnutls_x509_crt_deinit(ssl_data->host_cert);\n\t}\n\tif (ssl_data->root_privkey) {\n\t\tgnutls_x509_privkey_deinit(ssl_data->root_privkey);\n\t}\n\tif (ssl_data->host_privkey) {\n\t\tgnutls_x509_privkey_deinit(ssl_data->host_privkey);\n\t}\n#endif\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"common/thread.h\"",
            "#include \"common/userpref.h\"",
            "#include \"idevice.h\"",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <usbmuxd.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nstatic void internal_ssl_cleanup(ssl_data_t ssl_data)\n{\n\tif (!ssl_data)\n\t\treturn;\n\n#ifdef HAVE_OPENSSL\n\tif (ssl_data->session) {\n\t\tSSL_free(ssl_data->session);\n\t}\n\tif (ssl_data->ctx) {\n\t\tSSL_CTX_free(ssl_data->ctx);\n\t}\n#else\n\tif (ssl_data->session) {\n\t\tgnutls_deinit(ssl_data->session);\n\t}\n\tif (ssl_data->certificate) {\n\t\tgnutls_certificate_free_credentials(ssl_data->certificate);\n\t}\n\tif (ssl_data->root_cert) {\n\t\tgnutls_x509_crt_deinit(ssl_data->root_cert);\n\t}\n\tif (ssl_data->host_cert) {\n\t\tgnutls_x509_crt_deinit(ssl_data->host_cert);\n\t}\n\tif (ssl_data->root_privkey) {\n\t\tgnutls_x509_privkey_deinit(ssl_data->root_privkey);\n\t}\n\tif (ssl_data->host_privkey) {\n\t\tgnutls_x509_privkey_deinit(ssl_data->host_privkey);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"GnuTLS handshake done...\""
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_handshake",
          "args": [
            "ssl_data_loc->session"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"WARNING: errno says %s before handshake!\"",
            "strerror(errno)"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"GnuTLS step 4 -- now handshaking...\""
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_transport_set_pull_function",
          "args": [
            "ssl_data_loc->session",
            "(gnutls_pull_func) & internal_ssl_read"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"GnuTLS step 3...\""
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_transport_set_push_function",
          "args": [
            "ssl_data_loc->session",
            "(gnutls_push_func) & internal_ssl_write"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"GnuTLS step 2...\""
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_transport_set_ptr",
          "args": [
            "ssl_data_loc->session",
            "(gnutls_transport_ptr_t)connection"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"GnuTLS step 1...\""
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_free",
          "args": [
            "pair_record"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pair_record_import_key_with_name",
          "args": [
            "pair_record",
            "USERPREF_HOST_PRIVATE_KEY_KEY",
            "ssl_data_loc->host_privkey"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "pair_record_import_key_with_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/userpref.c",
          "lines": "811-835",
          "snippet": "userpref_error_t pair_record_import_key_with_name(plist_t pair_record, const char* name, gnutls_x509_privkey_t key)\n#endif\n{\n#ifdef HAVE_OPENSSL\n\tif (!key)\n\t\treturn USERPREF_E_SUCCESS;\n#endif\n\tuserpref_error_t ret = USERPREF_E_INVALID_CONF;\n\n#ifdef HAVE_OPENSSL\n\t\tret = pair_record_get_item_as_key_data(pair_record, name, key);\n#else\n\t\tkey_data_t pem = { NULL, 0 };\n\t\tret = pair_record_get_item_as_key_data(pair_record, name, &pem);\n\t\tif (ret == USERPREF_E_SUCCESS && GNUTLS_E_SUCCESS == gnutls_x509_privkey_import(key, &pem, GNUTLS_X509_FMT_PEM))\n\t\t\tret = USERPREF_E_SUCCESS;\n\t\telse\n\t\t\tret = USERPREF_E_SSL_ERROR;\n\n\t\tif (pem.data)\n\t\t\tfree(pem.data);\n#endif\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"debug.h\"",
            "#include \"userpref.h\"",
            "#include <shlobj.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <libgen.h>",
            "#include <dirent.h>",
            "#include <libtasn1.h>",
            "#include <gcrypt.h>",
            "#include <gnutls/x509.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/x509v3.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/pem.h>",
            "#include <usbmuxd.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"debug.h\"\n#include \"userpref.h\"\n#include <shlobj.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <libtasn1.h>\n#include <gcrypt.h>\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/rsa.h>\n#include <openssl/pem.h>\n#include <usbmuxd.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <config.h>\n\nuserpref_error_t pair_record_import_key_with_name(plist_t pair_record, const char* name, gnutls_x509_privkey_t key)\n#endif\n{\n#ifdef HAVE_OPENSSL\n\tif (!key)\n\t\treturn USERPREF_E_SUCCESS;\n#endif\n\tuserpref_error_t ret = USERPREF_E_INVALID_CONF;\n\n#ifdef HAVE_OPENSSL\n\t\tret = pair_record_get_item_as_key_data(pair_record, name, key);\n#else\n\t\tkey_data_t pem = { NULL, 0 };\n\t\tret = pair_record_get_item_as_key_data(pair_record, name, &pem);\n\t\tif (ret == USERPREF_E_SUCCESS && GNUTLS_E_SUCCESS == gnutls_x509_privkey_import(key, &pem, GNUTLS_X509_FMT_PEM))\n\t\t\tret = USERPREF_E_SUCCESS;\n\t\telse\n\t\t\tret = USERPREF_E_SSL_ERROR;\n\n\t\tif (pem.data)\n\t\t\tfree(pem.data);\n#endif\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pair_record_import_crt_with_name",
          "args": [
            "pair_record",
            "USERPREF_HOST_CERTIFICATE_KEY",
            "ssl_data_loc->host_cert"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "pair_record_import_crt_with_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/userpref.c",
          "lines": "848-872",
          "snippet": "userpref_error_t pair_record_import_crt_with_name(plist_t pair_record, const char* name, gnutls_x509_crt_t cert)\n#endif\n{\n#ifdef HAVE_OPENSSL\n\tif (!cert)\n\t\treturn USERPREF_E_SUCCESS;\n#endif\n\tuserpref_error_t ret = USERPREF_E_INVALID_CONF;\n\n#ifdef HAVE_OPENSSL\n\t\tret = pair_record_get_item_as_key_data(pair_record, name, cert);\n#else\n\t\tkey_data_t pem = { NULL, 0 };\n\t\tret = pair_record_get_item_as_key_data(pair_record, name, &pem);\n\t\tif (ret == USERPREF_E_SUCCESS && GNUTLS_E_SUCCESS == gnutls_x509_crt_import(cert, &pem, GNUTLS_X509_FMT_PEM))\n\t\t\tret = USERPREF_E_SUCCESS;\n\t\telse\n\t\t\tret = USERPREF_E_SSL_ERROR;\n\n\t\tif (pem.data)\n\t\t\tfree(pem.data);\n#endif\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"debug.h\"",
            "#include \"userpref.h\"",
            "#include <shlobj.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <libgen.h>",
            "#include <dirent.h>",
            "#include <libtasn1.h>",
            "#include <gcrypt.h>",
            "#include <gnutls/x509.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/x509v3.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/pem.h>",
            "#include <usbmuxd.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"debug.h\"\n#include \"userpref.h\"\n#include <shlobj.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <libtasn1.h>\n#include <gcrypt.h>\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/rsa.h>\n#include <openssl/pem.h>\n#include <usbmuxd.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <config.h>\n\nuserpref_error_t pair_record_import_crt_with_name(plist_t pair_record, const char* name, gnutls_x509_crt_t cert)\n#endif\n{\n#ifdef HAVE_OPENSSL\n\tif (!cert)\n\t\treturn USERPREF_E_SUCCESS;\n#endif\n\tuserpref_error_t ret = USERPREF_E_INVALID_CONF;\n\n#ifdef HAVE_OPENSSL\n\t\tret = pair_record_get_item_as_key_data(pair_record, name, cert);\n#else\n\t\tkey_data_t pem = { NULL, 0 };\n\t\tret = pair_record_get_item_as_key_data(pair_record, name, &pem);\n\t\tif (ret == USERPREF_E_SUCCESS && GNUTLS_E_SUCCESS == gnutls_x509_crt_import(cert, &pem, GNUTLS_X509_FMT_PEM))\n\t\t\tret = USERPREF_E_SUCCESS;\n\t\telse\n\t\t\tret = USERPREF_E_SSL_ERROR;\n\n\t\tif (pem.data)\n\t\t\tfree(pem.data);\n#endif\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gnutls_x509_privkey_init",
          "args": [
            "&ssl_data_loc->host_privkey"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_privkey_init",
          "args": [
            "&ssl_data_loc->root_privkey"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_init",
          "args": [
            "&ssl_data_loc->host_cert"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_init",
          "args": [
            "&ssl_data_loc->root_cert"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_session_set_ptr",
          "args": [
            "ssl_data_loc->session",
            "ssl_data_loc"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_credentials_set",
          "args": [
            "ssl_data_loc->session",
            "GNUTLS_CRD_CERTIFICATE",
            "ssl_data_loc->certificate"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_priority_set_direct",
          "args": [
            "ssl_data_loc->session",
            "\"NONE:+VERS-SSL3.0:+ANON-DH:+RSA:+AES-128-CBC:+AES-256-CBC:+SHA1:+MD5:+COMP-NULL\"",
            "NULL"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_init",
          "args": [
            "&ssl_data_loc->session",
            "GNUTLS_CLIENT"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_certificate_client_set_retrieve_function",
          "args": [
            "ssl_data_loc->certificate",
            "internal_cert_callback"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_certificate_allocate_credentials",
          "args": [
            "&ssl_data_loc->certificate"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"enabling SSL mode\""
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(struct ssl_data_private)"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_remove_state",
          "args": [
            "0"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_remove_thread_state",
          "args": [
            "NULL"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"SSL mode enabled, cipher: %s\"",
            "SSL_get_cipher(ssl)"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_get_cipher",
          "args": [
            "ssl"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(struct ssl_data_private)"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_CTX_free",
          "args": [
            "ssl_ctx"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_free",
          "args": [
            "ssl"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"ERROR in SSL_do_handshake: %s\"",
            "ssl_error_to_string(SSL_get_error(ssl, return_me))"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssl_error_to_string",
          "args": [
            "SSL_get_error(ssl, return_me)"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "ssl_error_to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
          "lines": "597-621",
          "snippet": "static const char *ssl_error_to_string(int e)\n{\n\tswitch(e) {\n\t\tcase SSL_ERROR_NONE:\n\t\t\treturn \"SSL_ERROR_NONE\";\n\t\tcase SSL_ERROR_SSL:\n\t\t\treturn \"SSL_ERROR_SSL\";\n\t\tcase SSL_ERROR_WANT_READ:\n\t\t\treturn \"SSL_ERROR_WANT_READ\";\n\t\tcase SSL_ERROR_WANT_WRITE:\n\t\t\treturn \"SSL_ERROR_WANT_WRITE\";\n\t\tcase SSL_ERROR_WANT_X509_LOOKUP:\n\t\t\treturn \"SSL_ERROR_WANT_X509_LOOKUP\";\n\t\tcase SSL_ERROR_SYSCALL:\n\t\t\treturn \"SSL_ERROR_SYSCALL\";\n\t\tcase SSL_ERROR_ZERO_RETURN:\n\t\t\treturn \"SSL_ERROR_ZERO_RETURN\";\n\t\tcase SSL_ERROR_WANT_CONNECT:\n\t\t\treturn \"SSL_ERROR_WANT_CONNECT\";\n\t\tcase SSL_ERROR_WANT_ACCEPT:\n\t\t\treturn \"SSL_ERROR_WANT_ACCEPT\";\n\t\tdefault:\n\t\t\treturn \"UNKOWN_ERROR_VALUE\";\n\t}\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"common/thread.h\"",
            "#include \"common/userpref.h\"",
            "#include \"idevice.h\"",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <usbmuxd.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nstatic const char *ssl_error_to_string(int e)\n{\n\tswitch(e) {\n\t\tcase SSL_ERROR_NONE:\n\t\t\treturn \"SSL_ERROR_NONE\";\n\t\tcase SSL_ERROR_SSL:\n\t\t\treturn \"SSL_ERROR_SSL\";\n\t\tcase SSL_ERROR_WANT_READ:\n\t\t\treturn \"SSL_ERROR_WANT_READ\";\n\t\tcase SSL_ERROR_WANT_WRITE:\n\t\t\treturn \"SSL_ERROR_WANT_WRITE\";\n\t\tcase SSL_ERROR_WANT_X509_LOOKUP:\n\t\t\treturn \"SSL_ERROR_WANT_X509_LOOKUP\";\n\t\tcase SSL_ERROR_SYSCALL:\n\t\t\treturn \"SSL_ERROR_SYSCALL\";\n\t\tcase SSL_ERROR_ZERO_RETURN:\n\t\t\treturn \"SSL_ERROR_ZERO_RETURN\";\n\t\tcase SSL_ERROR_WANT_CONNECT:\n\t\t\treturn \"SSL_ERROR_WANT_CONNECT\";\n\t\tcase SSL_ERROR_WANT_ACCEPT:\n\t\t\treturn \"SSL_ERROR_WANT_ACCEPT\";\n\t\tdefault:\n\t\t\treturn \"UNKOWN_ERROR_VALUE\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SSL_get_error",
          "args": [
            "ssl",
            "return_me"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_do_handshake",
          "args": [
            "ssl"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_set_bio",
          "args": [
            "ssl",
            "ssl_bio",
            "ssl_bio"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_set_verify",
          "args": [
            "ssl",
            "0",
            "ssl_verify_callback"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_set_connect_state",
          "args": [
            "ssl"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_CTX_free",
          "args": [
            "ssl_ctx"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIO_free",
          "args": [
            "ssl_bio"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"ERROR: Could not create SSL object\""
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_new",
          "args": [
            "ssl_ctx"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RSA_free",
          "args": [
            "rootPrivKey"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"WARNING: Could not load RootPrivateKey\""
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_CTX_use_RSAPrivateKey",
          "args": [
            "ssl_ctx",
            "rootPrivKey"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIO_free",
          "args": [
            "membp"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PEM_read_bio_RSAPrivateKey",
          "args": [
            "membp",
            "&rootPrivKey",
            "NULL",
            "NULL"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIO_new_mem_buf",
          "args": [
            "root_privkey.data",
            "root_privkey.size"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X509_free",
          "args": [
            "rootCert"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"WARNING: Could not load RootCertificate\""
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_CTX_use_certificate",
          "args": [
            "ssl_ctx",
            "rootCert"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIO_free",
          "args": [
            "membp"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PEM_read_bio_X509",
          "args": [
            "membp",
            "&rootCert",
            "NULL",
            "NULL"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIO_new_mem_buf",
          "args": [
            "root_cert.data",
            "root_cert.size"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIO_free",
          "args": [
            "ssl_bio"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"ERROR: Could not create SSL context.\""
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_CTX_new",
          "args": [
            "SSLv3_method()"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSLv3_method",
          "args": [],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIO_set_fd",
          "args": [
            "ssl_bio",
            "(int)(long)connection->data",
            "BIO_NOCLOSE"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"ERROR: Could not create SSL bio.\""
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIO_new",
          "args": [
            "BIO_s_socket()"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIO_s_socket",
          "args": [],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_free",
          "args": [
            "pair_record"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"ERROR: Failed enabling SSL. Unable to read pair record for udid %s.\"",
            "connection->udid"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "userpref_read_pair_record",
          "args": [
            "connection->udid",
            "&pair_record"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "userpref_read_pair_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/userpref.c",
          "lines": "333-357",
          "snippet": "userpref_error_t userpref_read_pair_record(const char *udid, plist_t *pair_record)\n{\n\tchar* record_data = NULL;\n\tuint32_t record_size = 0;\n\n\tint res = usbmuxd_read_pair_record(udid, &record_data, &record_size);\n\n\tif (res < 0) {\n\t\tif (record_data)\n\t\t\tfree(record_data);\n\n\t\treturn USERPREF_E_INVALID_CONF;\n\t}\n\n\t*pair_record = NULL;\n\tif (memcmp(record_data, \"bplist00\", 8) == 0) {\n\t\tplist_from_bin(record_data, record_size, pair_record);\n\t} else {\n\t\tplist_from_xml(record_data, record_size, pair_record);\n\t}\n\n\tfree(record_data);\n\n\treturn res == 0 ? USERPREF_E_SUCCESS: USERPREF_E_UNKNOWN_ERROR;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include \"debug.h\"",
            "#include \"userpref.h\"",
            "#include <shlobj.h>",
            "#include <errno.h>",
            "#include <sys/stat.h>",
            "#include <libgen.h>",
            "#include <dirent.h>",
            "#include <libtasn1.h>",
            "#include <gcrypt.h>",
            "#include <gnutls/x509.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/x509v3.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/pem.h>",
            "#include <usbmuxd.h>",
            "#include <unistd.h>",
            "#include <pwd.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include \"debug.h\"\n#include \"userpref.h\"\n#include <shlobj.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <libtasn1.h>\n#include <gcrypt.h>\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/rsa.h>\n#include <openssl/pem.h>\n#include <usbmuxd.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <config.h>\n\nuserpref_error_t userpref_read_pair_record(const char *udid, plist_t *pair_record)\n{\n\tchar* record_data = NULL;\n\tuint32_t record_size = 0;\n\n\tint res = usbmuxd_read_pair_record(udid, &record_data, &record_size);\n\n\tif (res < 0) {\n\t\tif (record_data)\n\t\t\tfree(record_data);\n\n\t\treturn USERPREF_E_INVALID_CONF;\n\t}\n\n\t*pair_record = NULL;\n\tif (memcmp(record_data, \"bplist00\", 8) == 0) {\n\t\tplist_from_bin(record_data, record_size, pair_record);\n\t} else {\n\t\tplist_from_xml(record_data, record_size, pair_record);\n\t}\n\n\tfree(record_data);\n\n\treturn res == 0 ? USERPREF_E_SUCCESS: USERPREF_E_UNKNOWN_ERROR;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\n#define HAVE_ERR_REMOVE_THREAD_STATE 1\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nLIBIMOBILEDEVICE_API idevice_error_t idevice_connection_enable_ssl(idevice_connection_t connection)\n{\n\tif (!connection || connection->ssl_data)\n\t\treturn IDEVICE_E_INVALID_ARG;\n\n\tidevice_error_t ret = IDEVICE_E_SSL_ERROR;\n\tuint32_t return_me = 0;\n\tplist_t pair_record = NULL;\n\n\tuserpref_read_pair_record(connection->udid, &pair_record);\n\tif (!pair_record) {\n\t\tdebug_info(\"ERROR: Failed enabling SSL. Unable to read pair record for udid %s.\", connection->udid);\n\t\treturn ret;\n\t}\n\n#ifdef HAVE_OPENSSL\n\tkey_data_t root_cert = { NULL, 0 };\n\tkey_data_t root_privkey = { NULL, 0 };\n\n\tpair_record_import_crt_with_name(pair_record, USERPREF_ROOT_CERTIFICATE_KEY, &root_cert);\n\tpair_record_import_key_with_name(pair_record, USERPREF_ROOT_PRIVATE_KEY_KEY, &root_privkey);\n\n\tif (pair_record)\n\t\tplist_free(pair_record);\n\n\tBIO *ssl_bio = BIO_new(BIO_s_socket());\n\tif (!ssl_bio) {\n\t\tdebug_info(\"ERROR: Could not create SSL bio.\");\n\t\treturn ret;\n\t}\n\tBIO_set_fd(ssl_bio, (int)(long)connection->data, BIO_NOCLOSE);\n\n\tSSL_CTX *ssl_ctx = SSL_CTX_new(SSLv3_method());\n\tif (ssl_ctx == NULL) {\n\t\tdebug_info(\"ERROR: Could not create SSL context.\");\n\t\tBIO_free(ssl_bio);\n\t\treturn ret;\n\t}\n\n\tBIO* membp;\n\tX509* rootCert = NULL;\n\tmembp = BIO_new_mem_buf(root_cert.data, root_cert.size);\n\tPEM_read_bio_X509(membp, &rootCert, NULL, NULL);\n\tBIO_free(membp);\n\tif (SSL_CTX_use_certificate(ssl_ctx, rootCert) != 1) {\n\t\tdebug_info(\"WARNING: Could not load RootCertificate\");\n\t}\n\tX509_free(rootCert);\n\tfree(root_cert.data);\n\n\tRSA* rootPrivKey = NULL;\n\tmembp = BIO_new_mem_buf(root_privkey.data, root_privkey.size);\n\tPEM_read_bio_RSAPrivateKey(membp, &rootPrivKey, NULL, NULL);\n\tBIO_free(membp);\n\tif (SSL_CTX_use_RSAPrivateKey(ssl_ctx, rootPrivKey) != 1) {\n\t\tdebug_info(\"WARNING: Could not load RootPrivateKey\");\n\t}\n\tRSA_free(rootPrivKey);\n\tfree(root_privkey.data);\n\n\tSSL *ssl = SSL_new(ssl_ctx);\n\tif (!ssl) {\n\t\tdebug_info(\"ERROR: Could not create SSL object\");\n\t\tBIO_free(ssl_bio);\n\t\tSSL_CTX_free(ssl_ctx);\n\t\treturn ret;\n\t}\n\tSSL_set_connect_state(ssl);\n\tSSL_set_verify(ssl, 0, ssl_verify_callback);\n\tSSL_set_bio(ssl, ssl_bio, ssl_bio);\n\n\treturn_me = SSL_do_handshake(ssl);\n\tif (return_me != 1) {\n\t\tdebug_info(\"ERROR in SSL_do_handshake: %s\", ssl_error_to_string(SSL_get_error(ssl, return_me)));\n\t\tSSL_free(ssl);\n\t\tSSL_CTX_free(ssl_ctx);\n\t} else {\n\t\tssl_data_t ssl_data_loc = (ssl_data_t)malloc(sizeof(struct ssl_data_private));\n\t\tssl_data_loc->session = ssl;\n\t\tssl_data_loc->ctx = ssl_ctx;\n\t\tconnection->ssl_data = ssl_data_loc;\n\t\tret = IDEVICE_E_SUCCESS;\n\t\tdebug_info(\"SSL mode enabled, cipher: %s\", SSL_get_cipher(ssl));\n\t}\n\t/* required for proper multi-thread clean up to prevent leaks */\n#ifdef HAVE_ERR_REMOVE_THREAD_STATE\n\tERR_remove_thread_state(NULL);\n#else\n\tERR_remove_state(0);\n#endif\n#else\n\tssl_data_t ssl_data_loc = (ssl_data_t)malloc(sizeof(struct ssl_data_private));\n\n\t/* Set up GnuTLS... */\n\tdebug_info(\"enabling SSL mode\");\n\terrno = 0;\n\tgnutls_certificate_allocate_credentials(&ssl_data_loc->certificate);\n\tgnutls_certificate_client_set_retrieve_function(ssl_data_loc->certificate, internal_cert_callback);\n\tgnutls_init(&ssl_data_loc->session, GNUTLS_CLIENT);\n\tgnutls_priority_set_direct(ssl_data_loc->session, \"NONE:+VERS-SSL3.0:+ANON-DH:+RSA:+AES-128-CBC:+AES-256-CBC:+SHA1:+MD5:+COMP-NULL\", NULL);\n\tgnutls_credentials_set(ssl_data_loc->session, GNUTLS_CRD_CERTIFICATE, ssl_data_loc->certificate);\n\tgnutls_session_set_ptr(ssl_data_loc->session, ssl_data_loc);\n\n\tgnutls_x509_crt_init(&ssl_data_loc->root_cert);\n\tgnutls_x509_crt_init(&ssl_data_loc->host_cert);\n\tgnutls_x509_privkey_init(&ssl_data_loc->root_privkey);\n\tgnutls_x509_privkey_init(&ssl_data_loc->host_privkey);\n\n\tpair_record_import_crt_with_name(pair_record, USERPREF_ROOT_CERTIFICATE_KEY, ssl_data_loc->root_cert);\n\tpair_record_import_crt_with_name(pair_record, USERPREF_HOST_CERTIFICATE_KEY, ssl_data_loc->host_cert);\n\tpair_record_import_key_with_name(pair_record, USERPREF_ROOT_PRIVATE_KEY_KEY, ssl_data_loc->root_privkey);\n\tpair_record_import_key_with_name(pair_record, USERPREF_HOST_PRIVATE_KEY_KEY, ssl_data_loc->host_privkey);\n\n\tif (pair_record)\n\t\tplist_free(pair_record);\n\n\tdebug_info(\"GnuTLS step 1...\");\n\tgnutls_transport_set_ptr(ssl_data_loc->session, (gnutls_transport_ptr_t)connection);\n\tdebug_info(\"GnuTLS step 2...\");\n\tgnutls_transport_set_push_function(ssl_data_loc->session, (gnutls_push_func) & internal_ssl_write);\n\tdebug_info(\"GnuTLS step 3...\");\n\tgnutls_transport_set_pull_function(ssl_data_loc->session, (gnutls_pull_func) & internal_ssl_read);\n\tdebug_info(\"GnuTLS step 4 -- now handshaking...\");\n\tif (errno) {\n\t\tdebug_info(\"WARNING: errno says %s before handshake!\", strerror(errno));\n\t}\n\treturn_me = gnutls_handshake(ssl_data_loc->session);\n\tdebug_info(\"GnuTLS handshake done...\");\n\n\tif (return_me != GNUTLS_E_SUCCESS) {\n\t\tinternal_ssl_cleanup(ssl_data_loc);\n\t\tfree(ssl_data_loc);\n\t\tdebug_info(\"GnuTLS reported something wrong.\");\n\t\tgnutls_perror(return_me);\n\t\tdebug_info(\"oh.. errno says %s\", strerror(errno));\n\t} else {\n\t\tconnection->ssl_data = ssl_data_loc;\n\t\tret = IDEVICE_E_SUCCESS;\n\t\tdebug_info(\"SSL mode enabled\");\n\t}\n#endif\n\treturn ret;\n}"
  },
  {
    "function_name": "internal_cert_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
    "lines": "629-646",
    "snippet": "static int internal_cert_callback(gnutls_session_t session, const gnutls_datum_t * req_ca_rdn, int nreqs, const gnutls_pk_algorithm_t * sign_algos, int sign_algos_length, gnutls_retr_st * st)\n{\n\tint res = -1;\n\tgnutls_certificate_type_t type = gnutls_certificate_type_get(session);\n\tif (type == GNUTLS_CRT_X509) {\n\t\tssl_data_t ssl_data = (ssl_data_t)gnutls_session_get_ptr(session);\n\t\tif (ssl_data && ssl_data->host_privkey && ssl_data->host_cert) {\n\t\t\tdebug_info(\"Passing certificate\");\n\t\t\tst->type = type;\n\t\t\tst->ncerts = 1;\n\t\t\tst->cert.x509 = &ssl_data->host_cert;\n\t\t\tst->key.x509 = ssl_data->host_privkey;\n\t\t\tst->deinit_all = 0;\n\t\t\tres = 0;\n\t\t}\n\t}\n\treturn res;\n}",
    "includes": [
      "#include \"common/debug.h\"",
      "#include \"common/thread.h\"",
      "#include \"common/userpref.h\"",
      "#include \"idevice.h\"",
      "#include <gnutls/gnutls.h>",
      "#include <openssl/ssl.h>",
      "#include <openssl/err.h>",
      "#include <usbmuxd.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"Passing certificate\""
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_session_get_ptr",
          "args": [
            "session"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_certificate_type_get",
          "args": [
            "session"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nstatic int internal_cert_callback(gnutls_session_t session, const gnutls_datum_t * req_ca_rdn, int nreqs, const gnutls_pk_algorithm_t * sign_algos, int sign_algos_length, gnutls_retr_st * st)\n{\n\tint res = -1;\n\tgnutls_certificate_type_t type = gnutls_certificate_type_get(session);\n\tif (type == GNUTLS_CRT_X509) {\n\t\tssl_data_t ssl_data = (ssl_data_t)gnutls_session_get_ptr(session);\n\t\tif (ssl_data && ssl_data->host_privkey && ssl_data->host_cert) {\n\t\t\tdebug_info(\"Passing certificate\");\n\t\t\tst->type = type;\n\t\t\tst->ncerts = 1;\n\t\t\tst->cert.x509 = &ssl_data->host_cert;\n\t\t\tst->key.x509 = ssl_data->host_privkey;\n\t\t\tst->deinit_all = 0;\n\t\t\tres = 0;\n\t\t}\n\t}\n\treturn res;\n}"
  },
  {
    "function_name": "ssl_error_to_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
    "lines": "597-621",
    "snippet": "static const char *ssl_error_to_string(int e)\n{\n\tswitch(e) {\n\t\tcase SSL_ERROR_NONE:\n\t\t\treturn \"SSL_ERROR_NONE\";\n\t\tcase SSL_ERROR_SSL:\n\t\t\treturn \"SSL_ERROR_SSL\";\n\t\tcase SSL_ERROR_WANT_READ:\n\t\t\treturn \"SSL_ERROR_WANT_READ\";\n\t\tcase SSL_ERROR_WANT_WRITE:\n\t\t\treturn \"SSL_ERROR_WANT_WRITE\";\n\t\tcase SSL_ERROR_WANT_X509_LOOKUP:\n\t\t\treturn \"SSL_ERROR_WANT_X509_LOOKUP\";\n\t\tcase SSL_ERROR_SYSCALL:\n\t\t\treturn \"SSL_ERROR_SYSCALL\";\n\t\tcase SSL_ERROR_ZERO_RETURN:\n\t\t\treturn \"SSL_ERROR_ZERO_RETURN\";\n\t\tcase SSL_ERROR_WANT_CONNECT:\n\t\t\treturn \"SSL_ERROR_WANT_CONNECT\";\n\t\tcase SSL_ERROR_WANT_ACCEPT:\n\t\t\treturn \"SSL_ERROR_WANT_ACCEPT\";\n\t\tdefault:\n\t\t\treturn \"UNKOWN_ERROR_VALUE\";\n\t}\n}",
    "includes": [
      "#include \"common/debug.h\"",
      "#include \"common/thread.h\"",
      "#include \"common/userpref.h\"",
      "#include \"idevice.h\"",
      "#include <gnutls/gnutls.h>",
      "#include <openssl/ssl.h>",
      "#include <openssl/err.h>",
      "#include <usbmuxd.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nstatic const char *ssl_error_to_string(int e)\n{\n\tswitch(e) {\n\t\tcase SSL_ERROR_NONE:\n\t\t\treturn \"SSL_ERROR_NONE\";\n\t\tcase SSL_ERROR_SSL:\n\t\t\treturn \"SSL_ERROR_SSL\";\n\t\tcase SSL_ERROR_WANT_READ:\n\t\t\treturn \"SSL_ERROR_WANT_READ\";\n\t\tcase SSL_ERROR_WANT_WRITE:\n\t\t\treturn \"SSL_ERROR_WANT_WRITE\";\n\t\tcase SSL_ERROR_WANT_X509_LOOKUP:\n\t\t\treturn \"SSL_ERROR_WANT_X509_LOOKUP\";\n\t\tcase SSL_ERROR_SYSCALL:\n\t\t\treturn \"SSL_ERROR_SYSCALL\";\n\t\tcase SSL_ERROR_ZERO_RETURN:\n\t\t\treturn \"SSL_ERROR_ZERO_RETURN\";\n\t\tcase SSL_ERROR_WANT_CONNECT:\n\t\t\treturn \"SSL_ERROR_WANT_CONNECT\";\n\t\tcase SSL_ERROR_WANT_ACCEPT:\n\t\t\treturn \"SSL_ERROR_WANT_ACCEPT\";\n\t\tdefault:\n\t\t\treturn \"UNKOWN_ERROR_VALUE\";\n\t}\n}"
  },
  {
    "function_name": "ssl_verify_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
    "lines": "591-594",
    "snippet": "static int ssl_verify_callback(int ok, X509_STORE_CTX *ctx)\n{\n\treturn 1;\n}",
    "includes": [
      "#include \"common/debug.h\"",
      "#include \"common/thread.h\"",
      "#include \"common/userpref.h\"",
      "#include \"idevice.h\"",
      "#include <gnutls/gnutls.h>",
      "#include <openssl/ssl.h>",
      "#include <openssl/err.h>",
      "#include <usbmuxd.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nstatic int ssl_verify_callback(int ok, X509_STORE_CTX *ctx)\n{\n\treturn 1;\n}"
  },
  {
    "function_name": "internal_ssl_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
    "lines": "556-588",
    "snippet": "static void internal_ssl_cleanup(ssl_data_t ssl_data)\n{\n\tif (!ssl_data)\n\t\treturn;\n\n#ifdef HAVE_OPENSSL\n\tif (ssl_data->session) {\n\t\tSSL_free(ssl_data->session);\n\t}\n\tif (ssl_data->ctx) {\n\t\tSSL_CTX_free(ssl_data->ctx);\n\t}\n#else\n\tif (ssl_data->session) {\n\t\tgnutls_deinit(ssl_data->session);\n\t}\n\tif (ssl_data->certificate) {\n\t\tgnutls_certificate_free_credentials(ssl_data->certificate);\n\t}\n\tif (ssl_data->root_cert) {\n\t\tgnutls_x509_crt_deinit(ssl_data->root_cert);\n\t}\n\tif (ssl_data->host_cert) {\n\t\tgnutls_x509_crt_deinit(ssl_data->host_cert);\n\t}\n\tif (ssl_data->root_privkey) {\n\t\tgnutls_x509_privkey_deinit(ssl_data->root_privkey);\n\t}\n\tif (ssl_data->host_privkey) {\n\t\tgnutls_x509_privkey_deinit(ssl_data->host_privkey);\n\t}\n#endif\n}",
    "includes": [
      "#include \"common/debug.h\"",
      "#include \"common/thread.h\"",
      "#include \"common/userpref.h\"",
      "#include \"idevice.h\"",
      "#include <gnutls/gnutls.h>",
      "#include <openssl/ssl.h>",
      "#include <openssl/err.h>",
      "#include <usbmuxd.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gnutls_x509_privkey_deinit",
          "args": [
            "ssl_data->host_privkey"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_privkey_deinit",
          "args": [
            "ssl_data->root_privkey"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_deinit",
          "args": [
            "ssl_data->host_cert"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_deinit",
          "args": [
            "ssl_data->root_cert"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_certificate_free_credentials",
          "args": [
            "ssl_data->certificate"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_deinit",
          "args": [
            "ssl_data->session"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_CTX_free",
          "args": [
            "ssl_data->ctx"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_free",
          "args": [
            "ssl_data->session"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nstatic void internal_ssl_cleanup(ssl_data_t ssl_data)\n{\n\tif (!ssl_data)\n\t\treturn;\n\n#ifdef HAVE_OPENSSL\n\tif (ssl_data->session) {\n\t\tSSL_free(ssl_data->session);\n\t}\n\tif (ssl_data->ctx) {\n\t\tSSL_CTX_free(ssl_data->ctx);\n\t}\n#else\n\tif (ssl_data->session) {\n\t\tgnutls_deinit(ssl_data->session);\n\t}\n\tif (ssl_data->certificate) {\n\t\tgnutls_certificate_free_credentials(ssl_data->certificate);\n\t}\n\tif (ssl_data->root_cert) {\n\t\tgnutls_x509_crt_deinit(ssl_data->root_cert);\n\t}\n\tif (ssl_data->host_cert) {\n\t\tgnutls_x509_crt_deinit(ssl_data->host_cert);\n\t}\n\tif (ssl_data->root_privkey) {\n\t\tgnutls_x509_privkey_deinit(ssl_data->root_privkey);\n\t}\n\tif (ssl_data->host_privkey) {\n\t\tgnutls_x509_privkey_deinit(ssl_data->host_privkey);\n\t}\n#endif\n}"
  },
  {
    "function_name": "internal_ssl_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
    "lines": "538-550",
    "snippet": "static ssize_t internal_ssl_write(gnutls_transport_ptr_t transport, char *buffer, size_t length)\n{\n\tuint32_t bytes = 0;\n\tidevice_error_t res;\n\tidevice_connection_t connection = (idevice_connection_t)transport;\n\tdebug_info(\"pre-send length = %zi\", length);\n\tif ((res = internal_connection_send(connection, buffer, length, &bytes)) != IDEVICE_E_SUCCESS) {\n\t\tdebug_info(\"ERROR: internal_connection_send returned %d\", res);\n\t\treturn -1;\n\t}\n\tdebug_info(\"post-send sent %i bytes\", bytes);\n\treturn bytes;\n}",
    "includes": [
      "#include \"common/debug.h\"",
      "#include \"common/thread.h\"",
      "#include \"common/userpref.h\"",
      "#include \"idevice.h\"",
      "#include <gnutls/gnutls.h>",
      "#include <openssl/ssl.h>",
      "#include <openssl/err.h>",
      "#include <usbmuxd.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "LIBIMOBILEDEVICE_API idevice_error_t"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"post-send sent %i bytes\"",
            "bytes"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"ERROR: internal_connection_send returned %d\"",
            "res"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "internal_connection_send",
          "args": [
            "connection",
            "buffer",
            "length",
            "&bytes"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "internal_connection_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
          "lines": "323-341",
          "snippet": "static idevice_error_t internal_connection_send(idevice_connection_t connection, const char *data, uint32_t len, uint32_t *sent_bytes)\n{\n\tif (!connection || !data) {\n\t\treturn IDEVICE_E_INVALID_ARG;\n\t}\n\n\tif (connection->type == CONNECTION_USBMUXD) {\n\t\tint res = usbmuxd_send((int)(long)connection->data, data, len, sent_bytes);\n\t\tif (res < 0) {\n\t\t\tdebug_info(\"ERROR: usbmuxd_send returned %d (%s)\", res, strerror(-res));\n\t\t\treturn IDEVICE_E_UNKNOWN_ERROR;\n\t\t}\n\t\treturn IDEVICE_E_SUCCESS;\n\t} else {\n\t\tdebug_info(\"Unknown connection type %d\", connection->type);\n\t}\n\treturn IDEVICE_E_UNKNOWN_ERROR;\n\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"common/thread.h\"",
            "#include \"common/userpref.h\"",
            "#include \"idevice.h\"",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <usbmuxd.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "LIBIMOBILEDEVICE_API idevice_error_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nstatic idevice_error_t internal_connection_send(idevice_connection_t connection, const char *data, uint32_t len, uint32_t *sent_bytes)\n{\n\tif (!connection || !data) {\n\t\treturn IDEVICE_E_INVALID_ARG;\n\t}\n\n\tif (connection->type == CONNECTION_USBMUXD) {\n\t\tint res = usbmuxd_send((int)(long)connection->data, data, len, sent_bytes);\n\t\tif (res < 0) {\n\t\t\tdebug_info(\"ERROR: usbmuxd_send returned %d (%s)\", res, strerror(-res));\n\t\t\treturn IDEVICE_E_UNKNOWN_ERROR;\n\t\t}\n\t\treturn IDEVICE_E_SUCCESS;\n\t} else {\n\t\tdebug_info(\"Unknown connection type %d\", connection->type);\n\t}\n\treturn IDEVICE_E_UNKNOWN_ERROR;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"pre-send length = %zi\"",
            "length"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nstatic ssize_t internal_ssl_write(gnutls_transport_ptr_t transport, char *buffer, size_t length)\n{\n\tuint32_t bytes = 0;\n\tidevice_error_t res;\n\tidevice_connection_t connection = (idevice_connection_t)transport;\n\tdebug_info(\"pre-send length = %zi\", length);\n\tif ((res = internal_connection_send(connection, buffer, length, &bytes)) != IDEVICE_E_SUCCESS) {\n\t\tdebug_info(\"ERROR: internal_connection_send returned %d\", res);\n\t\treturn -1;\n\t}\n\tdebug_info(\"post-send sent %i bytes\", bytes);\n\treturn bytes;\n}"
  },
  {
    "function_name": "internal_ssl_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
    "lines": "493-533",
    "snippet": "static ssize_t internal_ssl_read(gnutls_transport_ptr_t transport, char *buffer, size_t length)\n{\n\tint bytes = 0, pos_start_fill = 0;\n\tsize_t tbytes = 0;\n\tint this_len = length;\n\tidevice_error_t res;\n\tidevice_connection_t connection = (idevice_connection_t)transport;\n\tchar *recv_buffer;\n\n\tdebug_info(\"pre-read client wants %zi bytes\", length);\n\n\trecv_buffer = (char *)malloc(sizeof(char) * this_len);\n\n\t/* repeat until we have the full data or an error occurs */\n\tdo {\n\t\tif ((res = internal_connection_receive(connection, recv_buffer, this_len, (uint32_t*)&bytes)) != IDEVICE_E_SUCCESS) {\n\t\t\tdebug_info(\"ERROR: idevice_connection_receive returned %d\", res);\n\t\t\treturn res;\n\t\t}\n\t\tdebug_info(\"post-read we got %i bytes\", bytes);\n\n\t\t/* increase read count */\n\t\ttbytes += bytes;\n\n\t\t/* fill the buffer with what we got right now */\n\t\tmemcpy(buffer + pos_start_fill, recv_buffer, bytes);\n\t\tpos_start_fill += bytes;\n\n\t\tif (tbytes >= length) {\n\t\t\tbreak;\n\t\t}\n\n\t\tthis_len = length - tbytes;\n\t\tdebug_info(\"re-read trying to read missing %i bytes\", this_len);\n\t} while (tbytes < length);\n\n\tif (recv_buffer) {\n\t\tfree(recv_buffer);\n\t}\n\treturn tbytes;\n}",
    "includes": [
      "#include \"common/debug.h\"",
      "#include \"common/thread.h\"",
      "#include \"common/userpref.h\"",
      "#include \"idevice.h\"",
      "#include <gnutls/gnutls.h>",
      "#include <openssl/ssl.h>",
      "#include <openssl/err.h>",
      "#include <usbmuxd.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "LIBIMOBILEDEVICE_API idevice_error_t"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "recv_buffer"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "idevice_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
          "lines": "247-265",
          "snippet": "LIBIMOBILEDEVICE_API idevice_error_t idevice_free(idevice_t device)\n{\n\tif (!device)\n\t\treturn IDEVICE_E_INVALID_ARG;\n\tidevice_error_t ret = IDEVICE_E_UNKNOWN_ERROR;\n\n\tret = IDEVICE_E_SUCCESS;\n\n\tfree(device->udid);\n\n\tif (device->conn_type == CONNECTION_USBMUXD) {\n\t\tdevice->conn_data = 0;\n\t}\n\tif (device->conn_data) {\n\t\tfree(device->conn_data);\n\t}\n\tfree(device);\n\treturn ret;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"common/thread.h\"",
            "#include \"common/userpref.h\"",
            "#include \"idevice.h\"",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <usbmuxd.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "LIBIMOBILEDEVICE_API idevice_error_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nLIBIMOBILEDEVICE_API idevice_error_t idevice_free(idevice_t device)\n{\n\tif (!device)\n\t\treturn IDEVICE_E_INVALID_ARG;\n\tidevice_error_t ret = IDEVICE_E_UNKNOWN_ERROR;\n\n\tret = IDEVICE_E_SUCCESS;\n\n\tfree(device->udid);\n\n\tif (device->conn_type == CONNECTION_USBMUXD) {\n\t\tdevice->conn_data = 0;\n\t}\n\tif (device->conn_data) {\n\t\tfree(device->conn_data);\n\t}\n\tfree(device);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"re-read trying to read missing %i bytes\"",
            "this_len"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer + pos_start_fill",
            "recv_buffer",
            "bytes"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"post-read we got %i bytes\"",
            "bytes"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"ERROR: idevice_connection_receive returned %d\"",
            "res"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "internal_connection_receive",
          "args": [
            "connection",
            "recv_buffer",
            "this_len",
            "(uint32_t*)&bytes"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "internal_connection_receive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
          "lines": "423-441",
          "snippet": "static idevice_error_t internal_connection_receive(idevice_connection_t connection, char *data, uint32_t len, uint32_t *recv_bytes)\n{\n\tif (!connection) {\n\t\treturn IDEVICE_E_INVALID_ARG;\n\t}\n\n\tif (connection->type == CONNECTION_USBMUXD) {\n\t\tint res = usbmuxd_recv((int)(long)connection->data, data, len, recv_bytes);\n\t\tif (res < 0) {\n\t\t\tdebug_info(\"ERROR: usbmuxd_recv returned %d (%s)\", res, strerror(-res));\n\t\t\treturn IDEVICE_E_UNKNOWN_ERROR;\n\t\t}\n\n\t\treturn IDEVICE_E_SUCCESS;\n\t} else {\n\t\tdebug_info(\"Unknown connection type %d\", connection->type);\n\t}\n\treturn IDEVICE_E_UNKNOWN_ERROR;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"common/thread.h\"",
            "#include \"common/userpref.h\"",
            "#include \"idevice.h\"",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <usbmuxd.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "LIBIMOBILEDEVICE_API idevice_error_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nstatic idevice_error_t internal_connection_receive(idevice_connection_t connection, char *data, uint32_t len, uint32_t *recv_bytes)\n{\n\tif (!connection) {\n\t\treturn IDEVICE_E_INVALID_ARG;\n\t}\n\n\tif (connection->type == CONNECTION_USBMUXD) {\n\t\tint res = usbmuxd_recv((int)(long)connection->data, data, len, recv_bytes);\n\t\tif (res < 0) {\n\t\t\tdebug_info(\"ERROR: usbmuxd_recv returned %d (%s)\", res, strerror(-res));\n\t\t\treturn IDEVICE_E_UNKNOWN_ERROR;\n\t\t}\n\n\t\treturn IDEVICE_E_SUCCESS;\n\t} else {\n\t\tdebug_info(\"Unknown connection type %d\", connection->type);\n\t}\n\treturn IDEVICE_E_UNKNOWN_ERROR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(char) * this_len"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"pre-read client wants %zi bytes\"",
            "length"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nstatic ssize_t internal_ssl_read(gnutls_transport_ptr_t transport, char *buffer, size_t length)\n{\n\tint bytes = 0, pos_start_fill = 0;\n\tsize_t tbytes = 0;\n\tint this_len = length;\n\tidevice_error_t res;\n\tidevice_connection_t connection = (idevice_connection_t)transport;\n\tchar *recv_buffer;\n\n\tdebug_info(\"pre-read client wants %zi bytes\", length);\n\n\trecv_buffer = (char *)malloc(sizeof(char) * this_len);\n\n\t/* repeat until we have the full data or an error occurs */\n\tdo {\n\t\tif ((res = internal_connection_receive(connection, recv_buffer, this_len, (uint32_t*)&bytes)) != IDEVICE_E_SUCCESS) {\n\t\t\tdebug_info(\"ERROR: idevice_connection_receive returned %d\", res);\n\t\t\treturn res;\n\t\t}\n\t\tdebug_info(\"post-read we got %i bytes\", bytes);\n\n\t\t/* increase read count */\n\t\ttbytes += bytes;\n\n\t\t/* fill the buffer with what we got right now */\n\t\tmemcpy(buffer + pos_start_fill, recv_buffer, bytes);\n\t\tpos_start_fill += bytes;\n\n\t\tif (tbytes >= length) {\n\t\t\tbreak;\n\t\t}\n\n\t\tthis_len = length - tbytes;\n\t\tdebug_info(\"re-read trying to read missing %i bytes\", this_len);\n\t} while (tbytes < length);\n\n\tif (recv_buffer) {\n\t\tfree(recv_buffer);\n\t}\n\treturn tbytes;\n}"
  },
  {
    "function_name": "idevice_get_udid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
    "lines": "480-487",
    "snippet": "LIBIMOBILEDEVICE_API idevice_error_t idevice_get_udid(idevice_t device, char **udid)\n{\n\tif (!device || !udid)\n\t\treturn IDEVICE_E_INVALID_ARG;\n\n\t*udid = strdup(device->udid);\n\treturn IDEVICE_E_SUCCESS;\n}",
    "includes": [
      "#include \"common/debug.h\"",
      "#include \"common/thread.h\"",
      "#include \"common/userpref.h\"",
      "#include \"idevice.h\"",
      "#include <gnutls/gnutls.h>",
      "#include <openssl/ssl.h>",
      "#include <openssl/err.h>",
      "#include <usbmuxd.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "LIBIMOBILEDEVICE_API idevice_error_t"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "device->udid"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nLIBIMOBILEDEVICE_API idevice_error_t idevice_get_udid(idevice_t device, char **udid)\n{\n\tif (!device || !udid)\n\t\treturn IDEVICE_E_INVALID_ARG;\n\n\t*udid = strdup(device->udid);\n\treturn IDEVICE_E_SUCCESS;\n}"
  },
  {
    "function_name": "idevice_get_handle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
    "lines": "466-478",
    "snippet": "LIBIMOBILEDEVICE_API idevice_error_t idevice_get_handle(idevice_t device, uint32_t *handle)\n{\n\tif (!device)\n\t\treturn IDEVICE_E_INVALID_ARG;\n\n\tif (device->conn_type == CONNECTION_USBMUXD) {\n\t\t*handle = (uint32_t)(long)device->conn_data;\n\t\treturn IDEVICE_E_SUCCESS;\n\t} else {\n\t\tdebug_info(\"Unknown connection type %d\", device->conn_type);\n\t}\n\treturn IDEVICE_E_UNKNOWN_ERROR;\n}",
    "includes": [
      "#include \"common/debug.h\"",
      "#include \"common/thread.h\"",
      "#include \"common/userpref.h\"",
      "#include \"idevice.h\"",
      "#include <gnutls/gnutls.h>",
      "#include <openssl/ssl.h>",
      "#include <openssl/err.h>",
      "#include <usbmuxd.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "LIBIMOBILEDEVICE_API idevice_error_t"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"Unknown connection type %d\"",
            "device->conn_type"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nLIBIMOBILEDEVICE_API idevice_error_t idevice_get_handle(idevice_t device, uint32_t *handle)\n{\n\tif (!device)\n\t\treturn IDEVICE_E_INVALID_ARG;\n\n\tif (device->conn_type == CONNECTION_USBMUXD) {\n\t\t*handle = (uint32_t)(long)device->conn_data;\n\t\treturn IDEVICE_E_SUCCESS;\n\t} else {\n\t\tdebug_info(\"Unknown connection type %d\", device->conn_type);\n\t}\n\treturn IDEVICE_E_UNKNOWN_ERROR;\n}"
  },
  {
    "function_name": "idevice_connection_receive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
    "lines": "443-464",
    "snippet": "LIBIMOBILEDEVICE_API idevice_error_t idevice_connection_receive(idevice_connection_t connection, char *data, uint32_t len, uint32_t *recv_bytes)\n{\n\tif (!connection || (connection->ssl_data && !connection->ssl_data->session)) {\n\t\treturn IDEVICE_E_INVALID_ARG;\n\t}\n\n\tif (connection->ssl_data) {\n#ifdef HAVE_OPENSSL\n\t\tint received = SSL_read(connection->ssl_data->session, (void*)data, (int)len);\n\t\tdebug_info(\"SSL_read %d, received %d\", len, received);\n#else\n\t\tssize_t received = gnutls_record_recv(connection->ssl_data->session, (void*)data, (size_t)len);\n#endif\n\t\tif (received > 0) {\n\t\t\t*recv_bytes = received;\n\t\t\treturn IDEVICE_E_SUCCESS;\n\t\t}\n\t\t*recv_bytes = 0;\n\t\treturn IDEVICE_E_SSL_ERROR;\n\t}\n\treturn internal_connection_receive(connection, data, len, recv_bytes);\n}",
    "includes": [
      "#include \"common/debug.h\"",
      "#include \"common/thread.h\"",
      "#include \"common/userpref.h\"",
      "#include \"idevice.h\"",
      "#include <gnutls/gnutls.h>",
      "#include <openssl/ssl.h>",
      "#include <openssl/err.h>",
      "#include <usbmuxd.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "LIBIMOBILEDEVICE_API idevice_error_t"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "internal_connection_receive",
          "args": [
            "connection",
            "data",
            "len",
            "recv_bytes"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "internal_connection_receive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
          "lines": "423-441",
          "snippet": "static idevice_error_t internal_connection_receive(idevice_connection_t connection, char *data, uint32_t len, uint32_t *recv_bytes)\n{\n\tif (!connection) {\n\t\treturn IDEVICE_E_INVALID_ARG;\n\t}\n\n\tif (connection->type == CONNECTION_USBMUXD) {\n\t\tint res = usbmuxd_recv((int)(long)connection->data, data, len, recv_bytes);\n\t\tif (res < 0) {\n\t\t\tdebug_info(\"ERROR: usbmuxd_recv returned %d (%s)\", res, strerror(-res));\n\t\t\treturn IDEVICE_E_UNKNOWN_ERROR;\n\t\t}\n\n\t\treturn IDEVICE_E_SUCCESS;\n\t} else {\n\t\tdebug_info(\"Unknown connection type %d\", connection->type);\n\t}\n\treturn IDEVICE_E_UNKNOWN_ERROR;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"common/thread.h\"",
            "#include \"common/userpref.h\"",
            "#include \"idevice.h\"",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <usbmuxd.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "LIBIMOBILEDEVICE_API idevice_error_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nstatic idevice_error_t internal_connection_receive(idevice_connection_t connection, char *data, uint32_t len, uint32_t *recv_bytes)\n{\n\tif (!connection) {\n\t\treturn IDEVICE_E_INVALID_ARG;\n\t}\n\n\tif (connection->type == CONNECTION_USBMUXD) {\n\t\tint res = usbmuxd_recv((int)(long)connection->data, data, len, recv_bytes);\n\t\tif (res < 0) {\n\t\t\tdebug_info(\"ERROR: usbmuxd_recv returned %d (%s)\", res, strerror(-res));\n\t\t\treturn IDEVICE_E_UNKNOWN_ERROR;\n\t\t}\n\n\t\treturn IDEVICE_E_SUCCESS;\n\t} else {\n\t\tdebug_info(\"Unknown connection type %d\", connection->type);\n\t}\n\treturn IDEVICE_E_UNKNOWN_ERROR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gnutls_record_recv",
          "args": [
            "connection->ssl_data->session",
            "(void*)data",
            "(size_t)len"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"SSL_read %d, received %d\"",
            "len",
            "received"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_read",
          "args": [
            "connection->ssl_data->session",
            "(void*)data",
            "(int)len"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nLIBIMOBILEDEVICE_API idevice_error_t idevice_connection_receive(idevice_connection_t connection, char *data, uint32_t len, uint32_t *recv_bytes)\n{\n\tif (!connection || (connection->ssl_data && !connection->ssl_data->session)) {\n\t\treturn IDEVICE_E_INVALID_ARG;\n\t}\n\n\tif (connection->ssl_data) {\n#ifdef HAVE_OPENSSL\n\t\tint received = SSL_read(connection->ssl_data->session, (void*)data, (int)len);\n\t\tdebug_info(\"SSL_read %d, received %d\", len, received);\n#else\n\t\tssize_t received = gnutls_record_recv(connection->ssl_data->session, (void*)data, (size_t)len);\n#endif\n\t\tif (received > 0) {\n\t\t\t*recv_bytes = received;\n\t\t\treturn IDEVICE_E_SUCCESS;\n\t\t}\n\t\t*recv_bytes = 0;\n\t\treturn IDEVICE_E_SSL_ERROR;\n\t}\n\treturn internal_connection_receive(connection, data, len, recv_bytes);\n}"
  },
  {
    "function_name": "internal_connection_receive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
    "lines": "423-441",
    "snippet": "static idevice_error_t internal_connection_receive(idevice_connection_t connection, char *data, uint32_t len, uint32_t *recv_bytes)\n{\n\tif (!connection) {\n\t\treturn IDEVICE_E_INVALID_ARG;\n\t}\n\n\tif (connection->type == CONNECTION_USBMUXD) {\n\t\tint res = usbmuxd_recv((int)(long)connection->data, data, len, recv_bytes);\n\t\tif (res < 0) {\n\t\t\tdebug_info(\"ERROR: usbmuxd_recv returned %d (%s)\", res, strerror(-res));\n\t\t\treturn IDEVICE_E_UNKNOWN_ERROR;\n\t\t}\n\n\t\treturn IDEVICE_E_SUCCESS;\n\t} else {\n\t\tdebug_info(\"Unknown connection type %d\", connection->type);\n\t}\n\treturn IDEVICE_E_UNKNOWN_ERROR;\n}",
    "includes": [
      "#include \"common/debug.h\"",
      "#include \"common/thread.h\"",
      "#include \"common/userpref.h\"",
      "#include \"idevice.h\"",
      "#include <gnutls/gnutls.h>",
      "#include <openssl/ssl.h>",
      "#include <openssl/err.h>",
      "#include <usbmuxd.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "LIBIMOBILEDEVICE_API idevice_error_t"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"Unknown connection type %d\"",
            "connection->type"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"ERROR: usbmuxd_recv returned %d (%s)\"",
            "res",
            "strerror(-res)"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "-res"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbmuxd_recv",
          "args": [
            "(int)(long)connection->data",
            "data",
            "len",
            "recv_bytes"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nstatic idevice_error_t internal_connection_receive(idevice_connection_t connection, char *data, uint32_t len, uint32_t *recv_bytes)\n{\n\tif (!connection) {\n\t\treturn IDEVICE_E_INVALID_ARG;\n\t}\n\n\tif (connection->type == CONNECTION_USBMUXD) {\n\t\tint res = usbmuxd_recv((int)(long)connection->data, data, len, recv_bytes);\n\t\tif (res < 0) {\n\t\t\tdebug_info(\"ERROR: usbmuxd_recv returned %d (%s)\", res, strerror(-res));\n\t\t\treturn IDEVICE_E_UNKNOWN_ERROR;\n\t\t}\n\n\t\treturn IDEVICE_E_SUCCESS;\n\t} else {\n\t\tdebug_info(\"Unknown connection type %d\", connection->type);\n\t}\n\treturn IDEVICE_E_UNKNOWN_ERROR;\n}"
  },
  {
    "function_name": "idevice_connection_receive_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
    "lines": "389-418",
    "snippet": "LIBIMOBILEDEVICE_API idevice_error_t idevice_connection_receive_timeout(idevice_connection_t connection, char *data, uint32_t len, uint32_t *recv_bytes, unsigned int timeout)\n{\n\tif (!connection || (connection->ssl_data && !connection->ssl_data->session)) {\n\t\treturn IDEVICE_E_INVALID_ARG;\n\t}\n\n\tif (connection->ssl_data) {\n\t\tuint32_t received = 0;\n\t\twhile (received < len) {\n#ifdef HAVE_OPENSSL\n\t\t\tint r = SSL_read(connection->ssl_data->session, (void*)((char*)(data+received)), (int)len-received);\n#else\n\t\t\tssize_t r = gnutls_record_recv(connection->ssl_data->session, (void*)(data+received), (size_t)len-received);\n#endif\n\t\t\tif (r > 0) {\n\t\t\t\treceived += r;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tdebug_info(\"SSL_read %d, received %d\", len, received);\n\t\tif (received > 0) {\n\t\t\t*recv_bytes = received;\n\t\t\treturn IDEVICE_E_SUCCESS;\n\t\t}\n\t\t*recv_bytes = 0;\n\t\treturn IDEVICE_E_SSL_ERROR;\n\t}\n\treturn internal_connection_receive_timeout(connection, data, len, recv_bytes, timeout);\n}",
    "includes": [
      "#include \"common/debug.h\"",
      "#include \"common/thread.h\"",
      "#include \"common/userpref.h\"",
      "#include \"idevice.h\"",
      "#include <gnutls/gnutls.h>",
      "#include <openssl/ssl.h>",
      "#include <openssl/err.h>",
      "#include <usbmuxd.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "LIBIMOBILEDEVICE_API idevice_error_t"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "internal_connection_receive_timeout",
          "args": [
            "connection",
            "data",
            "len",
            "recv_bytes",
            "timeout"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "internal_connection_receive_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
          "lines": "370-387",
          "snippet": "static idevice_error_t internal_connection_receive_timeout(idevice_connection_t connection, char *data, uint32_t len, uint32_t *recv_bytes, unsigned int timeout)\n{\n\tif (!connection) {\n\t\treturn IDEVICE_E_INVALID_ARG;\n\t}\n\n\tif (connection->type == CONNECTION_USBMUXD) {\n\t\tint res = usbmuxd_recv_timeout((int)(long)connection->data, data, len, recv_bytes, timeout);\n\t\tif (res < 0) {\n\t\t\tdebug_info(\"ERROR: usbmuxd_recv_timeout returned %d (%s)\", res, strerror(-res));\n\t\t\treturn IDEVICE_E_UNKNOWN_ERROR;\n\t\t}\n\t\treturn IDEVICE_E_SUCCESS;\n\t} else {\n\t\tdebug_info(\"Unknown connection type %d\", connection->type);\n\t}\n\treturn IDEVICE_E_UNKNOWN_ERROR;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"common/thread.h\"",
            "#include \"common/userpref.h\"",
            "#include \"idevice.h\"",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <usbmuxd.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "LIBIMOBILEDEVICE_API idevice_error_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nstatic idevice_error_t internal_connection_receive_timeout(idevice_connection_t connection, char *data, uint32_t len, uint32_t *recv_bytes, unsigned int timeout)\n{\n\tif (!connection) {\n\t\treturn IDEVICE_E_INVALID_ARG;\n\t}\n\n\tif (connection->type == CONNECTION_USBMUXD) {\n\t\tint res = usbmuxd_recv_timeout((int)(long)connection->data, data, len, recv_bytes, timeout);\n\t\tif (res < 0) {\n\t\t\tdebug_info(\"ERROR: usbmuxd_recv_timeout returned %d (%s)\", res, strerror(-res));\n\t\t\treturn IDEVICE_E_UNKNOWN_ERROR;\n\t\t}\n\t\treturn IDEVICE_E_SUCCESS;\n\t} else {\n\t\tdebug_info(\"Unknown connection type %d\", connection->type);\n\t}\n\treturn IDEVICE_E_UNKNOWN_ERROR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"SSL_read %d, received %d\"",
            "len",
            "received"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_record_recv",
          "args": [
            "connection->ssl_data->session",
            "(void*)(data+received)",
            "(size_t)len-received"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_read",
          "args": [
            "connection->ssl_data->session",
            "(void*)((char*)(data+received))",
            "(int)len-received"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nLIBIMOBILEDEVICE_API idevice_error_t idevice_connection_receive_timeout(idevice_connection_t connection, char *data, uint32_t len, uint32_t *recv_bytes, unsigned int timeout)\n{\n\tif (!connection || (connection->ssl_data && !connection->ssl_data->session)) {\n\t\treturn IDEVICE_E_INVALID_ARG;\n\t}\n\n\tif (connection->ssl_data) {\n\t\tuint32_t received = 0;\n\t\twhile (received < len) {\n#ifdef HAVE_OPENSSL\n\t\t\tint r = SSL_read(connection->ssl_data->session, (void*)((char*)(data+received)), (int)len-received);\n#else\n\t\t\tssize_t r = gnutls_record_recv(connection->ssl_data->session, (void*)(data+received), (size_t)len-received);\n#endif\n\t\t\tif (r > 0) {\n\t\t\t\treceived += r;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tdebug_info(\"SSL_read %d, received %d\", len, received);\n\t\tif (received > 0) {\n\t\t\t*recv_bytes = received;\n\t\t\treturn IDEVICE_E_SUCCESS;\n\t\t}\n\t\t*recv_bytes = 0;\n\t\treturn IDEVICE_E_SSL_ERROR;\n\t}\n\treturn internal_connection_receive_timeout(connection, data, len, recv_bytes, timeout);\n}"
  },
  {
    "function_name": "internal_connection_receive_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
    "lines": "370-387",
    "snippet": "static idevice_error_t internal_connection_receive_timeout(idevice_connection_t connection, char *data, uint32_t len, uint32_t *recv_bytes, unsigned int timeout)\n{\n\tif (!connection) {\n\t\treturn IDEVICE_E_INVALID_ARG;\n\t}\n\n\tif (connection->type == CONNECTION_USBMUXD) {\n\t\tint res = usbmuxd_recv_timeout((int)(long)connection->data, data, len, recv_bytes, timeout);\n\t\tif (res < 0) {\n\t\t\tdebug_info(\"ERROR: usbmuxd_recv_timeout returned %d (%s)\", res, strerror(-res));\n\t\t\treturn IDEVICE_E_UNKNOWN_ERROR;\n\t\t}\n\t\treturn IDEVICE_E_SUCCESS;\n\t} else {\n\t\tdebug_info(\"Unknown connection type %d\", connection->type);\n\t}\n\treturn IDEVICE_E_UNKNOWN_ERROR;\n}",
    "includes": [
      "#include \"common/debug.h\"",
      "#include \"common/thread.h\"",
      "#include \"common/userpref.h\"",
      "#include \"idevice.h\"",
      "#include <gnutls/gnutls.h>",
      "#include <openssl/ssl.h>",
      "#include <openssl/err.h>",
      "#include <usbmuxd.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "LIBIMOBILEDEVICE_API idevice_error_t"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"Unknown connection type %d\"",
            "connection->type"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"ERROR: usbmuxd_recv_timeout returned %d (%s)\"",
            "res",
            "strerror(-res)"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "-res"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbmuxd_recv_timeout",
          "args": [
            "(int)(long)connection->data",
            "data",
            "len",
            "recv_bytes",
            "timeout"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nstatic idevice_error_t internal_connection_receive_timeout(idevice_connection_t connection, char *data, uint32_t len, uint32_t *recv_bytes, unsigned int timeout)\n{\n\tif (!connection) {\n\t\treturn IDEVICE_E_INVALID_ARG;\n\t}\n\n\tif (connection->type == CONNECTION_USBMUXD) {\n\t\tint res = usbmuxd_recv_timeout((int)(long)connection->data, data, len, recv_bytes, timeout);\n\t\tif (res < 0) {\n\t\t\tdebug_info(\"ERROR: usbmuxd_recv_timeout returned %d (%s)\", res, strerror(-res));\n\t\t\treturn IDEVICE_E_UNKNOWN_ERROR;\n\t\t}\n\t\treturn IDEVICE_E_SUCCESS;\n\t} else {\n\t\tdebug_info(\"Unknown connection type %d\", connection->type);\n\t}\n\treturn IDEVICE_E_UNKNOWN_ERROR;\n}"
  },
  {
    "function_name": "idevice_connection_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
    "lines": "343-364",
    "snippet": "LIBIMOBILEDEVICE_API idevice_error_t idevice_connection_send(idevice_connection_t connection, const char *data, uint32_t len, uint32_t *sent_bytes)\n{\n\tif (!connection || !data || (connection->ssl_data && !connection->ssl_data->session)) {\n\t\treturn IDEVICE_E_INVALID_ARG;\n\t}\n\n\tif (connection->ssl_data) {\n#ifdef HAVE_OPENSSL\n\t\tint sent = SSL_write(connection->ssl_data->session, (const void*)data, (int)len);\n\t\tdebug_info(\"SSL_write %d, sent %d\", len, sent);\n#else\n\t\tssize_t sent = gnutls_record_send(connection->ssl_data->session, (void*)data, (size_t)len);\n#endif\n\t\tif ((uint32_t)sent == (uint32_t)len) {\n\t\t\t*sent_bytes = sent;\n\t\t\treturn IDEVICE_E_SUCCESS;\n\t\t}\n\t\t*sent_bytes = 0;\n\t\treturn IDEVICE_E_SSL_ERROR;\n\t}\n\treturn internal_connection_send(connection, data, len, sent_bytes);\n}",
    "includes": [
      "#include \"common/debug.h\"",
      "#include \"common/thread.h\"",
      "#include \"common/userpref.h\"",
      "#include \"idevice.h\"",
      "#include <gnutls/gnutls.h>",
      "#include <openssl/ssl.h>",
      "#include <openssl/err.h>",
      "#include <usbmuxd.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "LIBIMOBILEDEVICE_API idevice_error_t"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "internal_connection_send",
          "args": [
            "connection",
            "data",
            "len",
            "sent_bytes"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "internal_connection_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
          "lines": "323-341",
          "snippet": "static idevice_error_t internal_connection_send(idevice_connection_t connection, const char *data, uint32_t len, uint32_t *sent_bytes)\n{\n\tif (!connection || !data) {\n\t\treturn IDEVICE_E_INVALID_ARG;\n\t}\n\n\tif (connection->type == CONNECTION_USBMUXD) {\n\t\tint res = usbmuxd_send((int)(long)connection->data, data, len, sent_bytes);\n\t\tif (res < 0) {\n\t\t\tdebug_info(\"ERROR: usbmuxd_send returned %d (%s)\", res, strerror(-res));\n\t\t\treturn IDEVICE_E_UNKNOWN_ERROR;\n\t\t}\n\t\treturn IDEVICE_E_SUCCESS;\n\t} else {\n\t\tdebug_info(\"Unknown connection type %d\", connection->type);\n\t}\n\treturn IDEVICE_E_UNKNOWN_ERROR;\n\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"common/thread.h\"",
            "#include \"common/userpref.h\"",
            "#include \"idevice.h\"",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <usbmuxd.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "LIBIMOBILEDEVICE_API idevice_error_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nstatic idevice_error_t internal_connection_send(idevice_connection_t connection, const char *data, uint32_t len, uint32_t *sent_bytes)\n{\n\tif (!connection || !data) {\n\t\treturn IDEVICE_E_INVALID_ARG;\n\t}\n\n\tif (connection->type == CONNECTION_USBMUXD) {\n\t\tint res = usbmuxd_send((int)(long)connection->data, data, len, sent_bytes);\n\t\tif (res < 0) {\n\t\t\tdebug_info(\"ERROR: usbmuxd_send returned %d (%s)\", res, strerror(-res));\n\t\t\treturn IDEVICE_E_UNKNOWN_ERROR;\n\t\t}\n\t\treturn IDEVICE_E_SUCCESS;\n\t} else {\n\t\tdebug_info(\"Unknown connection type %d\", connection->type);\n\t}\n\treturn IDEVICE_E_UNKNOWN_ERROR;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "gnutls_record_send",
          "args": [
            "connection->ssl_data->session",
            "(void*)data",
            "(size_t)len"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"SSL_write %d, sent %d\"",
            "len",
            "sent"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_write",
          "args": [
            "connection->ssl_data->session",
            "(const void*)data",
            "(int)len"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nLIBIMOBILEDEVICE_API idevice_error_t idevice_connection_send(idevice_connection_t connection, const char *data, uint32_t len, uint32_t *sent_bytes)\n{\n\tif (!connection || !data || (connection->ssl_data && !connection->ssl_data->session)) {\n\t\treturn IDEVICE_E_INVALID_ARG;\n\t}\n\n\tif (connection->ssl_data) {\n#ifdef HAVE_OPENSSL\n\t\tint sent = SSL_write(connection->ssl_data->session, (const void*)data, (int)len);\n\t\tdebug_info(\"SSL_write %d, sent %d\", len, sent);\n#else\n\t\tssize_t sent = gnutls_record_send(connection->ssl_data->session, (void*)data, (size_t)len);\n#endif\n\t\tif ((uint32_t)sent == (uint32_t)len) {\n\t\t\t*sent_bytes = sent;\n\t\t\treturn IDEVICE_E_SUCCESS;\n\t\t}\n\t\t*sent_bytes = 0;\n\t\treturn IDEVICE_E_SSL_ERROR;\n\t}\n\treturn internal_connection_send(connection, data, len, sent_bytes);\n}"
  },
  {
    "function_name": "internal_connection_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
    "lines": "323-341",
    "snippet": "static idevice_error_t internal_connection_send(idevice_connection_t connection, const char *data, uint32_t len, uint32_t *sent_bytes)\n{\n\tif (!connection || !data) {\n\t\treturn IDEVICE_E_INVALID_ARG;\n\t}\n\n\tif (connection->type == CONNECTION_USBMUXD) {\n\t\tint res = usbmuxd_send((int)(long)connection->data, data, len, sent_bytes);\n\t\tif (res < 0) {\n\t\t\tdebug_info(\"ERROR: usbmuxd_send returned %d (%s)\", res, strerror(-res));\n\t\t\treturn IDEVICE_E_UNKNOWN_ERROR;\n\t\t}\n\t\treturn IDEVICE_E_SUCCESS;\n\t} else {\n\t\tdebug_info(\"Unknown connection type %d\", connection->type);\n\t}\n\treturn IDEVICE_E_UNKNOWN_ERROR;\n\n}",
    "includes": [
      "#include \"common/debug.h\"",
      "#include \"common/thread.h\"",
      "#include \"common/userpref.h\"",
      "#include \"idevice.h\"",
      "#include <gnutls/gnutls.h>",
      "#include <openssl/ssl.h>",
      "#include <openssl/err.h>",
      "#include <usbmuxd.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "LIBIMOBILEDEVICE_API idevice_error_t"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"Unknown connection type %d\"",
            "connection->type"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"ERROR: usbmuxd_send returned %d (%s)\"",
            "res",
            "strerror(-res)"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "-res"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbmuxd_send",
          "args": [
            "(int)(long)connection->data",
            "data",
            "len",
            "sent_bytes"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nstatic idevice_error_t internal_connection_send(idevice_connection_t connection, const char *data, uint32_t len, uint32_t *sent_bytes)\n{\n\tif (!connection || !data) {\n\t\treturn IDEVICE_E_INVALID_ARG;\n\t}\n\n\tif (connection->type == CONNECTION_USBMUXD) {\n\t\tint res = usbmuxd_send((int)(long)connection->data, data, len, sent_bytes);\n\t\tif (res < 0) {\n\t\t\tdebug_info(\"ERROR: usbmuxd_send returned %d (%s)\", res, strerror(-res));\n\t\t\treturn IDEVICE_E_UNKNOWN_ERROR;\n\t\t}\n\t\treturn IDEVICE_E_SUCCESS;\n\t} else {\n\t\tdebug_info(\"Unknown connection type %d\", connection->type);\n\t}\n\treturn IDEVICE_E_UNKNOWN_ERROR;\n\n}"
  },
  {
    "function_name": "idevice_disconnect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
    "lines": "293-318",
    "snippet": "LIBIMOBILEDEVICE_API idevice_error_t idevice_disconnect(idevice_connection_t connection)\n{\n\tif (!connection) {\n\t\treturn IDEVICE_E_INVALID_ARG;\n\t}\n\t/* shut down ssl if enabled */\n\tif (connection->ssl_data) {\n\t\tidevice_connection_disable_ssl(connection);\n\t}\n\tidevice_error_t result = IDEVICE_E_UNKNOWN_ERROR;\n\tif (connection->type == CONNECTION_USBMUXD) {\n\t\tusbmuxd_disconnect((int)(long)connection->data);\n\t\tconnection->data = NULL;\n\t\tresult = IDEVICE_E_SUCCESS;\n\t} else {\n\t\tdebug_info(\"Unknown connection type %d\", connection->type);\n\t}\n\n\tif (connection->udid)\n\t\tfree(connection->udid);\n\n\tfree(connection);\n\tconnection = NULL;\n\n\treturn result;\n}",
    "includes": [
      "#include \"common/debug.h\"",
      "#include \"common/thread.h\"",
      "#include \"common/userpref.h\"",
      "#include \"idevice.h\"",
      "#include <gnutls/gnutls.h>",
      "#include <openssl/ssl.h>",
      "#include <openssl/err.h>",
      "#include <usbmuxd.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "LIBIMOBILEDEVICE_API idevice_error_t"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "connection"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "idevice_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
          "lines": "247-265",
          "snippet": "LIBIMOBILEDEVICE_API idevice_error_t idevice_free(idevice_t device)\n{\n\tif (!device)\n\t\treturn IDEVICE_E_INVALID_ARG;\n\tidevice_error_t ret = IDEVICE_E_UNKNOWN_ERROR;\n\n\tret = IDEVICE_E_SUCCESS;\n\n\tfree(device->udid);\n\n\tif (device->conn_type == CONNECTION_USBMUXD) {\n\t\tdevice->conn_data = 0;\n\t}\n\tif (device->conn_data) {\n\t\tfree(device->conn_data);\n\t}\n\tfree(device);\n\treturn ret;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"common/thread.h\"",
            "#include \"common/userpref.h\"",
            "#include \"idevice.h\"",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <usbmuxd.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "LIBIMOBILEDEVICE_API idevice_error_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nLIBIMOBILEDEVICE_API idevice_error_t idevice_free(idevice_t device)\n{\n\tif (!device)\n\t\treturn IDEVICE_E_INVALID_ARG;\n\tidevice_error_t ret = IDEVICE_E_UNKNOWN_ERROR;\n\n\tret = IDEVICE_E_SUCCESS;\n\n\tfree(device->udid);\n\n\tif (device->conn_type == CONNECTION_USBMUXD) {\n\t\tdevice->conn_data = 0;\n\t}\n\tif (device->conn_data) {\n\t\tfree(device->conn_data);\n\t}\n\tfree(device);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"Unknown connection type %d\"",
            "connection->type"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbmuxd_disconnect",
          "args": [
            "(int)(long)connection->data"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idevice_connection_disable_ssl",
          "args": [
            "connection"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "idevice_connection_disable_ssl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
          "lines": "793-821",
          "snippet": "LIBIMOBILEDEVICE_API idevice_error_t idevice_connection_disable_ssl(idevice_connection_t connection)\n{\n\tif (!connection)\n\t\treturn IDEVICE_E_INVALID_ARG;\n\tif (!connection->ssl_data) {\n\t\t/* ignore if ssl is not enabled */\n\t\treturn IDEVICE_E_SUCCESS;\n\t}\n\n#ifdef HAVE_OPENSSL\n\tif (connection->ssl_data->session) {\n\t\t/* see: https://www.openssl.org/docs/ssl/SSL_shutdown.html#RETURN_VALUES */\n\t\tif (SSL_shutdown(connection->ssl_data->session) == 0) {\n\t\t\tSSL_shutdown(connection->ssl_data->session);\n\t\t}\n\t}\n#else\n\tif (connection->ssl_data->session) {\n\t\tgnutls_bye(connection->ssl_data->session, GNUTLS_SHUT_RDWR);\n\t}\n#endif\n\tinternal_ssl_cleanup(connection->ssl_data);\n\tfree(connection->ssl_data);\n\tconnection->ssl_data = NULL;\n\n\tdebug_info(\"SSL mode disabled\");\n\n\treturn IDEVICE_E_SUCCESS;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"common/thread.h\"",
            "#include \"common/userpref.h\"",
            "#include \"idevice.h\"",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <usbmuxd.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "LIBIMOBILEDEVICE_API idevice_error_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nLIBIMOBILEDEVICE_API idevice_error_t idevice_connection_disable_ssl(idevice_connection_t connection)\n{\n\tif (!connection)\n\t\treturn IDEVICE_E_INVALID_ARG;\n\tif (!connection->ssl_data) {\n\t\t/* ignore if ssl is not enabled */\n\t\treturn IDEVICE_E_SUCCESS;\n\t}\n\n#ifdef HAVE_OPENSSL\n\tif (connection->ssl_data->session) {\n\t\t/* see: https://www.openssl.org/docs/ssl/SSL_shutdown.html#RETURN_VALUES */\n\t\tif (SSL_shutdown(connection->ssl_data->session) == 0) {\n\t\t\tSSL_shutdown(connection->ssl_data->session);\n\t\t}\n\t}\n#else\n\tif (connection->ssl_data->session) {\n\t\tgnutls_bye(connection->ssl_data->session, GNUTLS_SHUT_RDWR);\n\t}\n#endif\n\tinternal_ssl_cleanup(connection->ssl_data);\n\tfree(connection->ssl_data);\n\tconnection->ssl_data = NULL;\n\n\tdebug_info(\"SSL mode disabled\");\n\n\treturn IDEVICE_E_SUCCESS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nLIBIMOBILEDEVICE_API idevice_error_t idevice_disconnect(idevice_connection_t connection)\n{\n\tif (!connection) {\n\t\treturn IDEVICE_E_INVALID_ARG;\n\t}\n\t/* shut down ssl if enabled */\n\tif (connection->ssl_data) {\n\t\tidevice_connection_disable_ssl(connection);\n\t}\n\tidevice_error_t result = IDEVICE_E_UNKNOWN_ERROR;\n\tif (connection->type == CONNECTION_USBMUXD) {\n\t\tusbmuxd_disconnect((int)(long)connection->data);\n\t\tconnection->data = NULL;\n\t\tresult = IDEVICE_E_SUCCESS;\n\t} else {\n\t\tdebug_info(\"Unknown connection type %d\", connection->type);\n\t}\n\n\tif (connection->udid)\n\t\tfree(connection->udid);\n\n\tfree(connection);\n\tconnection = NULL;\n\n\treturn result;\n}"
  },
  {
    "function_name": "idevice_connect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
    "lines": "267-291",
    "snippet": "LIBIMOBILEDEVICE_API idevice_error_t idevice_connect(idevice_t device, uint16_t port, idevice_connection_t *connection)\n{\n\tif (!device) {\n\t\treturn IDEVICE_E_INVALID_ARG;\n\t}\n\n\tif (device->conn_type == CONNECTION_USBMUXD) {\n\t\tint sfd = usbmuxd_connect((uint32_t)(long)device->conn_data, port);\n\t\tif (sfd < 0) {\n\t\t\tdebug_info(\"ERROR: Connecting to usbmuxd failed: %d (%s)\", sfd, strerror(-sfd));\n\t\t\treturn IDEVICE_E_UNKNOWN_ERROR;\n\t\t}\n\t\tidevice_connection_t new_connection = (idevice_connection_t)malloc(sizeof(struct idevice_connection_private));\n\t\tnew_connection->type = CONNECTION_USBMUXD;\n\t\tnew_connection->data = (void*)(long)sfd;\n\t\tnew_connection->ssl_data = NULL;\n\t\tidevice_get_udid(device, &new_connection->udid);\n\t\t*connection = new_connection;\n\t\treturn IDEVICE_E_SUCCESS;\n\t} else {\n\t\tdebug_info(\"Unknown connection type %d\", device->conn_type);\n\t}\n\n\treturn IDEVICE_E_UNKNOWN_ERROR;\n}",
    "includes": [
      "#include \"common/debug.h\"",
      "#include \"common/thread.h\"",
      "#include \"common/userpref.h\"",
      "#include \"idevice.h\"",
      "#include <gnutls/gnutls.h>",
      "#include <openssl/ssl.h>",
      "#include <openssl/err.h>",
      "#include <usbmuxd.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "LIBIMOBILEDEVICE_API idevice_error_t"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"Unknown connection type %d\"",
            "device->conn_type"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idevice_get_udid",
          "args": [
            "device",
            "&new_connection->udid"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "idevice_get_udid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
          "lines": "480-487",
          "snippet": "LIBIMOBILEDEVICE_API idevice_error_t idevice_get_udid(idevice_t device, char **udid)\n{\n\tif (!device || !udid)\n\t\treturn IDEVICE_E_INVALID_ARG;\n\n\t*udid = strdup(device->udid);\n\treturn IDEVICE_E_SUCCESS;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"common/thread.h\"",
            "#include \"common/userpref.h\"",
            "#include \"idevice.h\"",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <usbmuxd.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "LIBIMOBILEDEVICE_API idevice_error_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nLIBIMOBILEDEVICE_API idevice_error_t idevice_get_udid(idevice_t device, char **udid)\n{\n\tif (!device || !udid)\n\t\treturn IDEVICE_E_INVALID_ARG;\n\n\t*udid = strdup(device->udid);\n\treturn IDEVICE_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(struct idevice_connection_private)"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"ERROR: Connecting to usbmuxd failed: %d (%s)\"",
            "sfd",
            "strerror(-sfd)"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "-sfd"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbmuxd_connect",
          "args": [
            "(uint32_t)(long)device->conn_data",
            "port"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nLIBIMOBILEDEVICE_API idevice_error_t idevice_connect(idevice_t device, uint16_t port, idevice_connection_t *connection)\n{\n\tif (!device) {\n\t\treturn IDEVICE_E_INVALID_ARG;\n\t}\n\n\tif (device->conn_type == CONNECTION_USBMUXD) {\n\t\tint sfd = usbmuxd_connect((uint32_t)(long)device->conn_data, port);\n\t\tif (sfd < 0) {\n\t\t\tdebug_info(\"ERROR: Connecting to usbmuxd failed: %d (%s)\", sfd, strerror(-sfd));\n\t\t\treturn IDEVICE_E_UNKNOWN_ERROR;\n\t\t}\n\t\tidevice_connection_t new_connection = (idevice_connection_t)malloc(sizeof(struct idevice_connection_private));\n\t\tnew_connection->type = CONNECTION_USBMUXD;\n\t\tnew_connection->data = (void*)(long)sfd;\n\t\tnew_connection->ssl_data = NULL;\n\t\tidevice_get_udid(device, &new_connection->udid);\n\t\t*connection = new_connection;\n\t\treturn IDEVICE_E_SUCCESS;\n\t} else {\n\t\tdebug_info(\"Unknown connection type %d\", device->conn_type);\n\t}\n\n\treturn IDEVICE_E_UNKNOWN_ERROR;\n}"
  },
  {
    "function_name": "idevice_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
    "lines": "247-265",
    "snippet": "LIBIMOBILEDEVICE_API idevice_error_t idevice_free(idevice_t device)\n{\n\tif (!device)\n\t\treturn IDEVICE_E_INVALID_ARG;\n\tidevice_error_t ret = IDEVICE_E_UNKNOWN_ERROR;\n\n\tret = IDEVICE_E_SUCCESS;\n\n\tfree(device->udid);\n\n\tif (device->conn_type == CONNECTION_USBMUXD) {\n\t\tdevice->conn_data = 0;\n\t}\n\tif (device->conn_data) {\n\t\tfree(device->conn_data);\n\t}\n\tfree(device);\n\treturn ret;\n}",
    "includes": [
      "#include \"common/debug.h\"",
      "#include \"common/thread.h\"",
      "#include \"common/userpref.h\"",
      "#include \"idevice.h\"",
      "#include <gnutls/gnutls.h>",
      "#include <openssl/ssl.h>",
      "#include <openssl/err.h>",
      "#include <usbmuxd.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "LIBIMOBILEDEVICE_API idevice_error_t"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "device"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "idevice_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
          "lines": "247-265",
          "snippet": "LIBIMOBILEDEVICE_API idevice_error_t idevice_free(idevice_t device)\n{\n\tif (!device)\n\t\treturn IDEVICE_E_INVALID_ARG;\n\tidevice_error_t ret = IDEVICE_E_UNKNOWN_ERROR;\n\n\tret = IDEVICE_E_SUCCESS;\n\n\tfree(device->udid);\n\n\tif (device->conn_type == CONNECTION_USBMUXD) {\n\t\tdevice->conn_data = 0;\n\t}\n\tif (device->conn_data) {\n\t\tfree(device->conn_data);\n\t}\n\tfree(device);\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nLIBIMOBILEDEVICE_API idevice_error_t idevice_free(idevice_t device)\n{\n\tif (!device)\n\t\treturn IDEVICE_E_INVALID_ARG;\n\tidevice_error_t ret = IDEVICE_E_UNKNOWN_ERROR;\n\n\tret = IDEVICE_E_SUCCESS;\n\n\tfree(device->udid);\n\n\tif (device->conn_type == CONNECTION_USBMUXD) {\n\t\tdevice->conn_data = 0;\n\t}\n\tif (device->conn_data) {\n\t\tfree(device->conn_data);\n\t}\n\tfree(device);\n\treturn ret;\n}"
  },
  {
    "function_name": "idevice_new",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
    "lines": "230-245",
    "snippet": "LIBIMOBILEDEVICE_API idevice_error_t idevice_new(idevice_t * device, const char *udid)\n{\n\tusbmuxd_device_info_t muxdev;\n\tint res = usbmuxd_get_device_by_udid(udid, &muxdev);\n\tif (res > 0) {\n\t\tidevice_t dev = (idevice_t) malloc(sizeof(struct idevice_private));\n\t\tdev->udid = strdup(muxdev.udid);\n\t\tdev->conn_type = CONNECTION_USBMUXD;\n\t\tdev->conn_data = (void*)(long)muxdev.handle;\n\t\t*device = dev;\n\t\treturn IDEVICE_E_SUCCESS;\n\t}\n\t/* other connection types could follow here */\n\n\treturn IDEVICE_E_NO_DEVICE;\n}",
    "includes": [
      "#include \"common/debug.h\"",
      "#include \"common/thread.h\"",
      "#include \"common/userpref.h\"",
      "#include \"idevice.h\"",
      "#include <gnutls/gnutls.h>",
      "#include <openssl/ssl.h>",
      "#include <openssl/err.h>",
      "#include <usbmuxd.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "LIBIMOBILEDEVICE_API idevice_error_t"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "muxdev.udid"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(struct idevice_private)"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbmuxd_get_device_by_udid",
          "args": [
            "udid",
            "&muxdev"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nLIBIMOBILEDEVICE_API idevice_error_t idevice_new(idevice_t * device, const char *udid)\n{\n\tusbmuxd_device_info_t muxdev;\n\tint res = usbmuxd_get_device_by_udid(udid, &muxdev);\n\tif (res > 0) {\n\t\tidevice_t dev = (idevice_t) malloc(sizeof(struct idevice_private));\n\t\tdev->udid = strdup(muxdev.udid);\n\t\tdev->conn_type = CONNECTION_USBMUXD;\n\t\tdev->conn_data = (void*)(long)muxdev.handle;\n\t\t*device = dev;\n\t\treturn IDEVICE_E_SUCCESS;\n\t}\n\t/* other connection types could follow here */\n\n\treturn IDEVICE_E_NO_DEVICE;\n}"
  },
  {
    "function_name": "idevice_set_debug_level",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
    "lines": "225-228",
    "snippet": "LIBIMOBILEDEVICE_API void idevice_set_debug_level(int level)\n{\n\tinternal_set_debug_level(level);\n}",
    "includes": [
      "#include \"common/debug.h\"",
      "#include \"common/thread.h\"",
      "#include \"common/userpref.h\"",
      "#include \"idevice.h\"",
      "#include <gnutls/gnutls.h>",
      "#include <openssl/ssl.h>",
      "#include <openssl/err.h>",
      "#include <usbmuxd.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "internal_set_debug_level",
          "args": [
            "level"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "internal_set_debug_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/debug.c",
          "lines": "44-47",
          "snippet": "void internal_set_debug_level(int level)\n{\n\tdebug_level = level;\n}",
          "includes": [
            "#include \"asprintf.h\"",
            "#include \"src/idevice.h\"",
            "#include \"libimobiledevice/libimobiledevice.h\"",
            "#include \"debug.h\"",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int debug_level;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"asprintf.h\"\n#include \"src/idevice.h\"\n#include \"libimobiledevice/libimobiledevice.h\"\n#include \"debug.h\"\n#include <time.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int debug_level;\n\nvoid internal_set_debug_level(int level)\n{\n\tdebug_level = level;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API void idevice_set_debug_level(int level)\n{\n\tinternal_set_debug_level(level);\n}"
  },
  {
    "function_name": "idevice_device_list_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
    "lines": "212-223",
    "snippet": "LIBIMOBILEDEVICE_API idevice_error_t idevice_device_list_free(char **devices)\n{\n\tif (devices) {\n\t\tint i = 0;\n\t\twhile (devices[i]) {\n\t\t\tfree(devices[i]);\n\t\t\ti++;\n\t\t}\n\t\tfree(devices);\n\t}\n\treturn IDEVICE_E_SUCCESS;\n}",
    "includes": [
      "#include \"common/debug.h\"",
      "#include \"common/thread.h\"",
      "#include \"common/userpref.h\"",
      "#include \"idevice.h\"",
      "#include <gnutls/gnutls.h>",
      "#include <openssl/ssl.h>",
      "#include <openssl/err.h>",
      "#include <usbmuxd.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "LIBIMOBILEDEVICE_API idevice_error_t"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "devices"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "idevice_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
          "lines": "247-265",
          "snippet": "LIBIMOBILEDEVICE_API idevice_error_t idevice_free(idevice_t device)\n{\n\tif (!device)\n\t\treturn IDEVICE_E_INVALID_ARG;\n\tidevice_error_t ret = IDEVICE_E_UNKNOWN_ERROR;\n\n\tret = IDEVICE_E_SUCCESS;\n\n\tfree(device->udid);\n\n\tif (device->conn_type == CONNECTION_USBMUXD) {\n\t\tdevice->conn_data = 0;\n\t}\n\tif (device->conn_data) {\n\t\tfree(device->conn_data);\n\t}\n\tfree(device);\n\treturn ret;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"common/thread.h\"",
            "#include \"common/userpref.h\"",
            "#include \"idevice.h\"",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <usbmuxd.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "LIBIMOBILEDEVICE_API idevice_error_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nLIBIMOBILEDEVICE_API idevice_error_t idevice_free(idevice_t device)\n{\n\tif (!device)\n\t\treturn IDEVICE_E_INVALID_ARG;\n\tidevice_error_t ret = IDEVICE_E_UNKNOWN_ERROR;\n\n\tret = IDEVICE_E_SUCCESS;\n\n\tfree(device->udid);\n\n\tif (device->conn_type == CONNECTION_USBMUXD) {\n\t\tdevice->conn_data = 0;\n\t}\n\tif (device->conn_data) {\n\t\tfree(device->conn_data);\n\t}\n\tfree(device);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nLIBIMOBILEDEVICE_API idevice_error_t idevice_device_list_free(char **devices)\n{\n\tif (devices) {\n\t\tint i = 0;\n\t\twhile (devices[i]) {\n\t\t\tfree(devices[i]);\n\t\t\ti++;\n\t\t}\n\t\tfree(devices);\n\t}\n\treturn IDEVICE_E_SUCCESS;\n}"
  },
  {
    "function_name": "idevice_get_device_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
    "lines": "182-210",
    "snippet": "LIBIMOBILEDEVICE_API idevice_error_t idevice_get_device_list(char ***devices, int *count)\n{\n\tusbmuxd_device_info_t *dev_list;\n\n\t*devices = NULL;\n\t*count = 0;\n\n\tif (usbmuxd_get_device_list(&dev_list) < 0) {\n\t\tdebug_info(\"ERROR: usbmuxd is not running!\", __func__);\n\t\treturn IDEVICE_E_NO_DEVICE;\n\t}\n\n\tchar **newlist = NULL;\n\tint i, newcount = 0;\n\n\tfor (i = 0; dev_list[i].handle > 0; i++) {\n\t\tnewlist = realloc(*devices, sizeof(char*) * (newcount+1));\n\t\tnewlist[newcount++] = strdup(dev_list[i].udid);\n\t\t*devices = newlist;\n\t}\n\tusbmuxd_device_list_free(&dev_list);\n\n\t*count = newcount;\n\tnewlist = realloc(*devices, sizeof(char*) * (newcount+1));\n\tnewlist[newcount] = NULL;\n\t*devices = newlist;\n\n\treturn IDEVICE_E_SUCCESS;\n}",
    "includes": [
      "#include \"common/debug.h\"",
      "#include \"common/thread.h\"",
      "#include \"common/userpref.h\"",
      "#include \"idevice.h\"",
      "#include <gnutls/gnutls.h>",
      "#include <openssl/ssl.h>",
      "#include <openssl/err.h>",
      "#include <usbmuxd.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "LIBIMOBILEDEVICE_API idevice_error_t"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "*devices",
            "sizeof(char*) * (newcount+1)"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbmuxd_device_list_free",
          "args": [
            "&dev_list"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "dev_list[i].udid"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "*devices",
            "sizeof(char*) * (newcount+1)"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"ERROR: usbmuxd is not running!\"",
            "__func__"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbmuxd_get_device_list",
          "args": [
            "&dev_list"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nLIBIMOBILEDEVICE_API idevice_error_t idevice_get_device_list(char ***devices, int *count)\n{\n\tusbmuxd_device_info_t *dev_list;\n\n\t*devices = NULL;\n\t*count = 0;\n\n\tif (usbmuxd_get_device_list(&dev_list) < 0) {\n\t\tdebug_info(\"ERROR: usbmuxd is not running!\", __func__);\n\t\treturn IDEVICE_E_NO_DEVICE;\n\t}\n\n\tchar **newlist = NULL;\n\tint i, newcount = 0;\n\n\tfor (i = 0; dev_list[i].handle > 0; i++) {\n\t\tnewlist = realloc(*devices, sizeof(char*) * (newcount+1));\n\t\tnewlist[newcount++] = strdup(dev_list[i].udid);\n\t\t*devices = newlist;\n\t}\n\tusbmuxd_device_list_free(&dev_list);\n\n\t*count = newcount;\n\tnewlist = realloc(*devices, sizeof(char*) * (newcount+1));\n\tnewlist[newcount] = NULL;\n\t*devices = newlist;\n\n\treturn IDEVICE_E_SUCCESS;\n}"
  },
  {
    "function_name": "idevice_event_subscribe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
    "lines": "159-169",
    "snippet": "LIBIMOBILEDEVICE_API idevice_error_t idevice_event_subscribe(idevice_event_cb_t callback, void *user_data)\n{\n\tevent_cb = callback;\n\tint res = usbmuxd_subscribe(usbmux_event_cb, user_data);\n\tif (res != 0) {\n\t\tevent_cb = NULL;\n\t\tdebug_info(\"ERROR: usbmuxd_subscribe() returned %d!\", res);\n\t\treturn IDEVICE_E_UNKNOWN_ERROR;\n\t}\n\treturn IDEVICE_E_SUCCESS;\n}",
    "includes": [
      "#include \"common/debug.h\"",
      "#include \"common/thread.h\"",
      "#include \"common/userpref.h\"",
      "#include \"idevice.h\"",
      "#include <gnutls/gnutls.h>",
      "#include <openssl/ssl.h>",
      "#include <openssl/err.h>",
      "#include <usbmuxd.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static idevice_event_cb_t event_cb = NULL;",
      "LIBIMOBILEDEVICE_API idevice_error_t"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"ERROR: usbmuxd_subscribe() returned %d!\"",
            "res"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbmuxd_subscribe",
          "args": [
            "usbmux_event_cb",
            "user_data"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nstatic idevice_event_cb_t event_cb = NULL;\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nLIBIMOBILEDEVICE_API idevice_error_t idevice_event_subscribe(idevice_event_cb_t callback, void *user_data)\n{\n\tevent_cb = callback;\n\tint res = usbmuxd_subscribe(usbmux_event_cb, user_data);\n\tif (res != 0) {\n\t\tevent_cb = NULL;\n\t\tdebug_info(\"ERROR: usbmuxd_subscribe() returned %d!\", res);\n\t\treturn IDEVICE_E_UNKNOWN_ERROR;\n\t}\n\treturn IDEVICE_E_SUCCESS;\n}"
  },
  {
    "function_name": "usbmux_event_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
    "lines": "146-157",
    "snippet": "static void usbmux_event_cb(const usbmuxd_event_t *event, void *user_data)\n{\n\tidevice_event_t ev;\n\n\tev.event = event->event;\n\tev.udid = event->device.udid;\n\tev.conn_type = CONNECTION_USBMUXD;\n\n\tif (event_cb) {\n\t\tevent_cb(&ev, user_data);\n\t}\n}",
    "includes": [
      "#include \"common/debug.h\"",
      "#include \"common/thread.h\"",
      "#include \"common/userpref.h\"",
      "#include \"idevice.h\"",
      "#include <gnutls/gnutls.h>",
      "#include <openssl/ssl.h>",
      "#include <openssl/err.h>",
      "#include <usbmuxd.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static idevice_event_cb_t event_cb = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "event_cb",
          "args": [
            "&ev",
            "user_data"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "usbmux_event_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
          "lines": "146-157",
          "snippet": "static void usbmux_event_cb(const usbmuxd_event_t *event, void *user_data)\n{\n\tidevice_event_t ev;\n\n\tev.event = event->event;\n\tev.udid = event->device.udid;\n\tev.conn_type = CONNECTION_USBMUXD;\n\n\tif (event_cb) {\n\t\tevent_cb(&ev, user_data);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nstatic idevice_event_cb_t event_cb = NULL;\n\nstatic void usbmux_event_cb(const usbmuxd_event_t *event, void *user_data)\n{\n\tidevice_event_t ev;\n\n\tev.event = event->event;\n\tev.udid = event->device.udid;\n\tev.conn_type = CONNECTION_USBMUXD;\n\n\tif (event_cb) {\n\t\tevent_cb(&ev, user_data);\n\t}\n}"
  },
  {
    "function_name": "libimobiledevice_deinitialize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
    "lines": "138-141",
    "snippet": "static void __attribute__((destructor)) libimobiledevice_deinitialize(void)\n{\n\tthread_once(&deinit_once, internal_idevice_deinit);\n}",
    "includes": [
      "#include \"common/debug.h\"",
      "#include \"common/thread.h\"",
      "#include \"common/userpref.h\"",
      "#include \"idevice.h\"",
      "#include <gnutls/gnutls.h>",
      "#include <openssl/ssl.h>",
      "#include <openssl/err.h>",
      "#include <usbmuxd.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static thread_once_t deinit_once = THREAD_ONCE_INIT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "thread_once",
          "args": [
            "&deinit_once",
            "internal_idevice_deinit"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "thread_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "92-106",
          "snippet": "void thread_once(thread_once_t *once_control, void (*init_routine)(void))\n{\n#ifdef WIN32\n\twhile (InterlockedExchange(&(once_control->lock), 1) != 0) {\n\t\tSleep(1);\n\t}\n\tif (!once_control->state) {\n\t\tonce_control->state = 1;\n\t\tinit_routine();\n\t}\n\tInterlockedExchange(&(once_control->lock), 0);\n#else\n\tpthread_once(once_control, init_routine);\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nvoid thread_once(thread_once_t *once_control, void (*init_routine)(void))\n{\n#ifdef WIN32\n\twhile (InterlockedExchange(&(once_control->lock), 1) != 0) {\n\t\tSleep(1);\n\t}\n\tif (!once_control->state) {\n\t\tonce_control->state = 1;\n\t\tinit_routine();\n\t}\n\tInterlockedExchange(&(once_control->lock), 0);\n#else\n\tpthread_once(once_control, init_routine);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nstatic thread_once_t deinit_once = THREAD_ONCE_INIT;\n\nstatic void __attribute__((destructor)) libimobiledevice_deinitialize(void)\n{\n\tthread_once(&deinit_once, internal_idevice_deinit);\n}"
  },
  {
    "function_name": "libimobiledevice_initialize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
    "lines": "133-136",
    "snippet": "static void __attribute__((constructor)) libimobiledevice_initialize(void)\n{\n\tthread_once(&init_once, internal_idevice_init);\n}",
    "includes": [
      "#include \"common/debug.h\"",
      "#include \"common/thread.h\"",
      "#include \"common/userpref.h\"",
      "#include \"idevice.h\"",
      "#include <gnutls/gnutls.h>",
      "#include <openssl/ssl.h>",
      "#include <openssl/err.h>",
      "#include <usbmuxd.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static thread_once_t init_once = THREAD_ONCE_INIT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "thread_once",
          "args": [
            "&init_once",
            "internal_idevice_init"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "thread_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "92-106",
          "snippet": "void thread_once(thread_once_t *once_control, void (*init_routine)(void))\n{\n#ifdef WIN32\n\twhile (InterlockedExchange(&(once_control->lock), 1) != 0) {\n\t\tSleep(1);\n\t}\n\tif (!once_control->state) {\n\t\tonce_control->state = 1;\n\t\tinit_routine();\n\t}\n\tInterlockedExchange(&(once_control->lock), 0);\n#else\n\tpthread_once(once_control, init_routine);\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nvoid thread_once(thread_once_t *once_control, void (*init_routine)(void))\n{\n#ifdef WIN32\n\twhile (InterlockedExchange(&(once_control->lock), 1) != 0) {\n\t\tSleep(1);\n\t}\n\tif (!once_control->state) {\n\t\tonce_control->state = 1;\n\t\tinit_routine();\n\t}\n\tInterlockedExchange(&(once_control->lock), 0);\n#else\n\tpthread_once(once_control, init_routine);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nstatic thread_once_t init_once = THREAD_ONCE_INIT;\n\nstatic void __attribute__((constructor)) libimobiledevice_initialize(void)\n{\n\tthread_once(&init_once, internal_idevice_init);\n}"
  },
  {
    "function_name": "DllMain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
    "lines": "118-131",
    "snippet": "BOOL WINAPI DllMain(HINSTANCE hModule, DWORD dwReason, LPVOID lpReserved)\n{\n\tswitch (dwReason) {\n\tcase DLL_PROCESS_ATTACH:\n\t\tthread_once(&init_once,\tinternal_idevice_init);\n\t\tbreak;\n\tcase DLL_PROCESS_DETACH:\n\t\tthread_once(&deinit_once, internal_idevice_deinit);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"common/debug.h\"",
      "#include \"common/thread.h\"",
      "#include \"common/userpref.h\"",
      "#include \"idevice.h\"",
      "#include <gnutls/gnutls.h>",
      "#include <openssl/ssl.h>",
      "#include <openssl/err.h>",
      "#include <usbmuxd.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static thread_once_t init_once = THREAD_ONCE_INIT;",
      "static thread_once_t deinit_once = THREAD_ONCE_INIT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "thread_once",
          "args": [
            "&deinit_once",
            "internal_idevice_deinit"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "thread_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "92-106",
          "snippet": "void thread_once(thread_once_t *once_control, void (*init_routine)(void))\n{\n#ifdef WIN32\n\twhile (InterlockedExchange(&(once_control->lock), 1) != 0) {\n\t\tSleep(1);\n\t}\n\tif (!once_control->state) {\n\t\tonce_control->state = 1;\n\t\tinit_routine();\n\t}\n\tInterlockedExchange(&(once_control->lock), 0);\n#else\n\tpthread_once(once_control, init_routine);\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nvoid thread_once(thread_once_t *once_control, void (*init_routine)(void))\n{\n#ifdef WIN32\n\twhile (InterlockedExchange(&(once_control->lock), 1) != 0) {\n\t\tSleep(1);\n\t}\n\tif (!once_control->state) {\n\t\tonce_control->state = 1;\n\t\tinit_routine();\n\t}\n\tInterlockedExchange(&(once_control->lock), 0);\n#else\n\tpthread_once(once_control, init_routine);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nstatic thread_once_t init_once = THREAD_ONCE_INIT;\nstatic thread_once_t deinit_once = THREAD_ONCE_INIT;\n\nBOOL WINAPI DllMain(HINSTANCE hModule, DWORD dwReason, LPVOID lpReserved)\n{\n\tswitch (dwReason) {\n\tcase DLL_PROCESS_ATTACH:\n\t\tthread_once(&init_once,\tinternal_idevice_init);\n\t\tbreak;\n\tcase DLL_PROCESS_DETACH:\n\t\tthread_once(&deinit_once, internal_idevice_deinit);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "internal_idevice_deinit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
    "lines": "88-112",
    "snippet": "static void internal_idevice_deinit(void)\n{\n#ifdef HAVE_OPENSSL\n\tint i;\n\tif (mutex_buf) {\n\t\tCRYPTO_set_id_callback(NULL);\n\t\tCRYPTO_set_locking_callback(NULL);\n\t\tfor (i = 0; i < CRYPTO_num_locks(); i++)\n\t\t\tmutex_destroy(&mutex_buf[i]);\n\t\tfree(mutex_buf);\n\t\tmutex_buf = NULL;\n\t}\n\n\tEVP_cleanup();\n\tCRYPTO_cleanup_all_ex_data();\n\tsk_SSL_COMP_free(SSL_COMP_get_compression_methods());\n#ifdef HAVE_ERR_REMOVE_THREAD_STATE\n\tERR_remove_thread_state(NULL);\n#else\n\tERR_remove_state(0);\n#endif\n#else\n\tgnutls_global_deinit();\n#endif\n}",
    "includes": [
      "#include \"common/debug.h\"",
      "#include \"common/thread.h\"",
      "#include \"common/userpref.h\"",
      "#include \"idevice.h\"",
      "#include <gnutls/gnutls.h>",
      "#include <openssl/ssl.h>",
      "#include <openssl/err.h>",
      "#include <usbmuxd.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define HAVE_ERR_REMOVE_THREAD_STATE 1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gnutls_global_deinit",
          "args": [],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_remove_state",
          "args": [
            "0"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_remove_thread_state",
          "args": [
            "NULL"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sk_SSL_COMP_free",
          "args": [
            "SSL_COMP_get_compression_methods()"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_COMP_get_compression_methods",
          "args": [],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTO_cleanup_all_ex_data",
          "args": [],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_cleanup",
          "args": [],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "mutex_buf"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "idevice_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
          "lines": "247-265",
          "snippet": "LIBIMOBILEDEVICE_API idevice_error_t idevice_free(idevice_t device)\n{\n\tif (!device)\n\t\treturn IDEVICE_E_INVALID_ARG;\n\tidevice_error_t ret = IDEVICE_E_UNKNOWN_ERROR;\n\n\tret = IDEVICE_E_SUCCESS;\n\n\tfree(device->udid);\n\n\tif (device->conn_type == CONNECTION_USBMUXD) {\n\t\tdevice->conn_data = 0;\n\t}\n\tif (device->conn_data) {\n\t\tfree(device->conn_data);\n\t}\n\tfree(device);\n\treturn ret;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"common/thread.h\"",
            "#include \"common/userpref.h\"",
            "#include \"idevice.h\"",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <usbmuxd.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "LIBIMOBILEDEVICE_API idevice_error_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nLIBIMOBILEDEVICE_API idevice_error_t idevice_free(idevice_t device)\n{\n\tif (!device)\n\t\treturn IDEVICE_E_INVALID_ARG;\n\tidevice_error_t ret = IDEVICE_E_UNKNOWN_ERROR;\n\n\tret = IDEVICE_E_SUCCESS;\n\n\tfree(device->udid);\n\n\tif (device->conn_type == CONNECTION_USBMUXD) {\n\t\tdevice->conn_data = 0;\n\t}\n\tif (device->conn_data) {\n\t\tfree(device->conn_data);\n\t}\n\tfree(device);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_destroy",
          "args": [
            "&mutex_buf[i]"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "65-72",
          "snippet": "void mutex_destroy(mutex_t* mutex)\n{\n#ifdef WIN32\n\tDeleteCriticalSection(mutex);\n#else\n\tpthread_mutex_destroy(mutex);\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nvoid mutex_destroy(mutex_t* mutex)\n{\n#ifdef WIN32\n\tDeleteCriticalSection(mutex);\n#else\n\tpthread_mutex_destroy(mutex);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "CRYPTO_num_locks",
          "args": [],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTO_set_locking_callback",
          "args": [
            "NULL"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTO_set_id_callback",
          "args": [
            "NULL"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\n#define HAVE_ERR_REMOVE_THREAD_STATE 1\n\nstatic void internal_idevice_deinit(void)\n{\n#ifdef HAVE_OPENSSL\n\tint i;\n\tif (mutex_buf) {\n\t\tCRYPTO_set_id_callback(NULL);\n\t\tCRYPTO_set_locking_callback(NULL);\n\t\tfor (i = 0; i < CRYPTO_num_locks(); i++)\n\t\t\tmutex_destroy(&mutex_buf[i]);\n\t\tfree(mutex_buf);\n\t\tmutex_buf = NULL;\n\t}\n\n\tEVP_cleanup();\n\tCRYPTO_cleanup_all_ex_data();\n\tsk_SSL_COMP_free(SSL_COMP_get_compression_methods());\n#ifdef HAVE_ERR_REMOVE_THREAD_STATE\n\tERR_remove_thread_state(NULL);\n#else\n\tERR_remove_state(0);\n#endif\n#else\n\tgnutls_global_deinit();\n#endif\n}"
  },
  {
    "function_name": "internal_idevice_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
    "lines": "69-86",
    "snippet": "static void internal_idevice_init(void)\n{\n#ifdef HAVE_OPENSSL\n\tint i;\n\tSSL_library_init();\n\n\tmutex_buf = malloc(CRYPTO_num_locks() * sizeof(mutex_t));\n\tif (!mutex_buf)\n\t\treturn;\n\tfor (i = 0; i < CRYPTO_num_locks(); i++)\n\t\tmutex_init(&mutex_buf[i]);\n\n\tCRYPTO_set_id_callback(id_function);\n\tCRYPTO_set_locking_callback(locking_function);\n#else\n\tgnutls_global_init();\n#endif\n}",
    "includes": [
      "#include \"common/debug.h\"",
      "#include \"common/thread.h\"",
      "#include \"common/userpref.h\"",
      "#include \"idevice.h\"",
      "#include <gnutls/gnutls.h>",
      "#include <openssl/ssl.h>",
      "#include <openssl/err.h>",
      "#include <usbmuxd.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gnutls_global_init",
          "args": [],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTO_set_locking_callback",
          "args": [
            "locking_function"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTO_set_id_callback",
          "args": [
            "id_function"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&mutex_buf[i]"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "56-63",
          "snippet": "void mutex_init(mutex_t* mutex)\n{\n#ifdef WIN32\n\tInitializeCriticalSection(mutex);\n#else\n\tpthread_mutex_init(mutex, NULL);\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nvoid mutex_init(mutex_t* mutex)\n{\n#ifdef WIN32\n\tInitializeCriticalSection(mutex);\n#else\n\tpthread_mutex_init(mutex, NULL);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "CRYPTO_num_locks",
          "args": [],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "CRYPTO_num_locks() * sizeof(mutex_t)"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTO_num_locks",
          "args": [],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSL_library_init",
          "args": [],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nstatic void internal_idevice_init(void)\n{\n#ifdef HAVE_OPENSSL\n\tint i;\n\tSSL_library_init();\n\n\tmutex_buf = malloc(CRYPTO_num_locks() * sizeof(mutex_t));\n\tif (!mutex_buf)\n\t\treturn;\n\tfor (i = 0; i < CRYPTO_num_locks(); i++)\n\t\tmutex_init(&mutex_buf[i]);\n\n\tCRYPTO_set_id_callback(id_function);\n\tCRYPTO_set_locking_callback(locking_function);\n#else\n\tgnutls_global_init();\n#endif\n}"
  },
  {
    "function_name": "id_function",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
    "lines": "63-66",
    "snippet": "static unsigned long id_function(void)\n{\n\treturn ((unsigned long)THREAD_ID);\n}",
    "includes": [
      "#include \"common/debug.h\"",
      "#include \"common/thread.h\"",
      "#include \"common/userpref.h\"",
      "#include \"idevice.h\"",
      "#include <gnutls/gnutls.h>",
      "#include <openssl/ssl.h>",
      "#include <openssl/err.h>",
      "#include <usbmuxd.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nstatic unsigned long id_function(void)\n{\n\treturn ((unsigned long)THREAD_ID);\n}"
  },
  {
    "function_name": "locking_function",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
    "lines": "55-61",
    "snippet": "static void locking_function(int mode, int n, const char* file, int line)\n{\n\tif (mode & CRYPTO_LOCK)\n\t\tmutex_lock(&mutex_buf[n]);\n\telse\n\t\tmutex_unlock(&mutex_buf[n]);\n}",
    "includes": [
      "#include \"common/debug.h\"",
      "#include \"common/thread.h\"",
      "#include \"common/userpref.h\"",
      "#include \"idevice.h\"",
      "#include <gnutls/gnutls.h>",
      "#include <openssl/ssl.h>",
      "#include <openssl/err.h>",
      "#include <usbmuxd.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&mutex_buf[n]"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "83-90",
          "snippet": "void mutex_unlock(mutex_t* mutex)\n{\n#ifdef WIN32\n\tLeaveCriticalSection(mutex);\n#else\n\tpthread_mutex_unlock(mutex);\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nvoid mutex_unlock(mutex_t* mutex)\n{\n#ifdef WIN32\n\tLeaveCriticalSection(mutex);\n#else\n\tpthread_mutex_unlock(mutex);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&mutex_buf[n]"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "74-81",
          "snippet": "void mutex_lock(mutex_t* mutex)\n{\n#ifdef WIN32\n\tEnterCriticalSection(mutex);\n#else\n\tpthread_mutex_lock(mutex);\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nvoid mutex_lock(mutex_t* mutex)\n{\n#ifdef WIN32\n\tEnterCriticalSection(mutex);\n#else\n\tpthread_mutex_lock(mutex);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nstatic void locking_function(int mode, int n, const char* file, int line)\n{\n\tif (mode & CRYPTO_LOCK)\n\t\tmutex_lock(&mutex_buf[n]);\n\telse\n\t\tmutex_unlock(&mutex_buf[n]);\n}"
  }
]