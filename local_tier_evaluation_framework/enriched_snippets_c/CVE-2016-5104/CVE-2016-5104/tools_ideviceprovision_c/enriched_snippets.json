[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/ideviceprovision.c",
    "lines": "250-510",
    "snippet": "int main(int argc, char *argv[])\n{\n\tlockdownd_client_t client = NULL;\n\tlockdownd_error_t ldret = LOCKDOWN_E_UNKNOWN_ERROR;\n\tlockdownd_service_descriptor_t service = NULL;\n\tidevice_t device = NULL;\n\tidevice_error_t ret = IDEVICE_E_UNKNOWN_ERROR;\n\tint i;\n\tint op = -1;\n\tint output_xml = 0;\n\tconst char* udid = NULL;\n\tconst char* param = NULL;\n\n\t/* parse cmdline args */\n\tfor (i = 1; i < argc; i++) {\n\t\tif (!strcmp(argv[i], \"-d\") || !strcmp(argv[i], \"--debug\")) {\n\t\t\tidevice_set_debug_level(1);\n\t\t\tcontinue;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"-u\") || !strcmp(argv[i], \"--udid\")) {\n\t\t\ti++;\n\t\t\tif (!argv[i] || (strlen(argv[i]) != 40)) {\n\t\t\t\tprint_usage(argc, argv);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tudid = argv[i];\n\t\t\tcontinue;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"install\")) {\n\t\t\ti++;\n\t\t\tif (!argv[i] || (strlen(argv[i]) < 1)) {\n\t\t\t\tprint_usage(argc, argv);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tparam = argv[i];\n\t\t\top = OP_INSTALL;\n\t\t\tcontinue;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"list\")) {\n\t\t\top = OP_LIST;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"copy\")) {\n\t\t\ti++;\n\t\t\tif (!argv[i] || (strlen(argv[i]) < 1)) {\n\t\t\t\tprint_usage(argc, argv);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tparam = argv[i];\n\t\t\top = OP_COPY;\n\t\t\tcontinue;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"remove\")) {\n\t\t\ti++;\n\t\t\tif (!argv[i] || (strlen(argv[i]) < 1)) {\n\t\t\t\tprint_usage(argc, argv);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tparam = argv[i];\n\t\t\top = OP_REMOVE;\n\t\t\tcontinue;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"dump\")) {\n\t\t\ti++;\n\t\t\tif (!argv[i] || (strlen(argv[i]) < 1)) {\n\t\t\t\tprint_usage(argc, argv);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tparam = argv[i];\n\t\t\top = OP_DUMP;\n\t\t\tcontinue;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"-x\") || !strcmp(argv[i], \"--xml\")) {\n\t\t\toutput_xml = 1;\n\t\t\tcontinue;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"-h\") || !strcmp(argv[i], \"--help\")) {\n\t\t\tprint_usage(argc, argv);\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\tprint_usage(argc, argv);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif ((op == -1) || (op >= NUM_OPS)) {\n\t\tprint_usage(argc, argv);\n\t\treturn 0;\n\t}\n\n\tif (op == OP_DUMP) {\n\t\tint res = 0;\n\t\tunsigned char* profile_data = NULL;\n\t\tunsigned int profile_size = 0;\n\t\tif (profile_read_from_file(param, &profile_data, &profile_size) != 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tplist_t pdata = plist_new_data((char*)profile_data, profile_size);\n\t\tplist_t pl = profile_get_embedded_plist(pdata);\n\t\tplist_free(pdata);\n\t\tfree(profile_data);\n\n\t\tif (pl) {\n\t\t\tif (output_xml) {\n\t\t\t\tchar* xml = NULL;\n\t\t\t\tuint32_t xlen = 0;\n\t\t\t\tplist_to_xml(pl, &xml, &xlen);\n\t\t\t\tif (xml) {\n\t\t\t\t\tprintf(\"%s\\n\", xml);\n\t\t\t\t\tfree(xml);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (pl && (plist_get_node_type(pl) == PLIST_DICT)) {\n\t\t\t\t\tplist_print_to_stream(pl, stdout);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"ERROR: unexpected node type in profile plist (not PLIST_DICT)\\n\");\n\t\t\t\t\tres = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfprintf(stderr, \"ERROR: could not extract embedded plist from profile!\\n\");\n\t\t}\n\t\tplist_free(pl);\n\n\t\treturn res;\n\t}\n\n\tret = idevice_new(&device, udid);\n\tif (ret != IDEVICE_E_SUCCESS) {\n\t\tif (udid) {\n\t\t\tprintf(\"No device found with udid %s, is it plugged in?\\n\", udid);\n\t\t} else {\n\t\t\tprintf(\"No device found, is it plugged in?\\n\");\n\t\t}\n\t\treturn -1;\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS != (ldret = lockdownd_client_new_with_handshake(device, &client, \"ideviceprovision\"))) {\n\t\tfprintf(stderr, \"ERROR: Could not connect to lockdownd, error code %d\\n\", ldret);\n\t\tidevice_free(device);\n\t\treturn -1;\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS != lockdownd_start_service(client, \"com.apple.misagent\", &service)) {\n\t\tfprintf(stderr, \"Could not start service \\\"com.apple.misagent\\\"\\n\");\n\t\tlockdownd_client_free(client);\n\t\tidevice_free(device);\n\t\treturn -1;\n\t}\n\tlockdownd_client_free(client);\n\tclient = NULL;\n\n\tmisagent_client_t mis = NULL;\n\tif (misagent_client_new(device, service, &mis) != MISAGENT_E_SUCCESS) {\n\t\tfprintf(stderr, \"Could not connect to \\\"com.apple.misagent\\\" on device\\n\");\n\t\tif (service)\n\t\t\tlockdownd_service_descriptor_free(service);\n\t\tlockdownd_client_free(client);\n\t\tidevice_free(device);\n\t\treturn -1;\n\t}\n\n\tif (service)\n\t\tlockdownd_service_descriptor_free(service);\n\n\tswitch (op) {\n\t\tcase OP_INSTALL:\n\t\t{\n\t\t\tunsigned char* profile_data = NULL;\n\t\t\tunsigned int profile_size = 0;\n\t\t\tif (profile_read_from_file(param, &profile_data, &profile_size) != 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tuint64_t psize = profile_size;\n\t\t\tplist_t pdata = plist_new_data((const char*)profile_data, psize);\n\t\t\tfree(profile_data);\n\n\t\t\tif (misagent_install(mis, pdata) == MISAGENT_E_SUCCESS) {\n\t\t\t\tprintf(\"Profile '%s' installed successfully.\\n\", param);\n\t\t\t} else {\n\t\t\t\tint sc = misagent_get_status_code(mis);\n\t\t\t\tfprintf(stderr, \"Could not install profile '%s', status code: 0x%x\\n\", param, sc);\n\t\t\t}\n\t\t}\n\t\t\tbreak;\n\t\tcase OP_LIST:\n\t\tcase OP_COPY:\n\t\t{\n\t\t\tplist_t profiles = NULL;\n\t\t\tif (misagent_copy(mis, &profiles) == MISAGENT_E_SUCCESS) {\n\t\t\t\tuint32_t num_profiles = plist_array_get_size(profiles);\n\t\t\t\tprintf(\"Device has %d provisioning %s installed:\\n\", num_profiles, (num_profiles == 1) ? \"profile\" : \"profiles\");\n\t\t\t\tuint32_t j;\n\t\t\t\tfor (j = 0; j < num_profiles; j++) {\n\t\t\t\t\tchar* p_name = NULL;\n\t\t\t\t\tchar* p_uuid = NULL;\n\t\t\t\t\tplist_t profile = plist_array_get_item(profiles, j);\n\t\t\t\t\tplist_t pl = profile_get_embedded_plist(profile);\n\t\t\t\t\tif (pl && (plist_get_node_type(pl) == PLIST_DICT)) {\n\t\t\t\t\t\tplist_t node;\n\t\t\t\t\t\tnode = plist_dict_get_item(pl, \"Name\");\n\t\t\t\t\t\tif (node && (plist_get_node_type(node) == PLIST_STRING)) {\n\t\t\t\t\t\t\tplist_get_string_val(node, &p_name);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnode = plist_dict_get_item(pl, \"UUID\");\n\t\t\t\t\t\tif (node && (plist_get_node_type(node) == PLIST_STRING)) {\n\t\t\t\t\t\t\tplist_get_string_val(node, &p_uuid);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tprintf(\"%s - %s\\n\", (p_uuid) ? p_uuid : \"(unknown id)\", (p_name) ? p_name : \"(no name)\");\n\t\t\t\t\tif (op == OP_COPY) {\n\t\t\t\t\t\tchar pfname[512];\n\t\t\t\t\t\tif (p_uuid) {\n\t\t\t\t\t\t\tsprintf(pfname, \"%s/%s.mobileprovision\", param, p_uuid);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsprintf(pfname, \"%s/profile%d.mobileprovision\", param, j);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tFILE* f = fopen(pfname, \"wb\");\n\t\t\t\t\t\tif (f) {\n\t\t\t\t\t\t\tchar* dt = NULL;\n\t\t\t\t\t\t\tuint64_t ds = 0;\n\t\t\t\t\t\t\tplist_get_data_val(profile, &dt, &ds);\n\t\t\t\t\t\t\tfwrite(dt, 1, ds, f);\n\t\t\t\t\t\t\tfclose(f);\n\t\t\t\t\t\t\tprintf(\" => %s\\n\", pfname);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfprintf(stderr, \"Could not open '%s' for writing\\n\", pfname);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (p_uuid) {\n\t\t\t\t\t\tfree(p_uuid);\n\t\t\t\t\t}\n\t\t\t\t\tif (p_name) {\n\t\t\t\t\t\tfree(p_name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint sc = misagent_get_status_code(mis);\n\t\t\t\tfprintf(stderr, \"Could not get installed profiles from device, status code: 0x%x\\n\", sc);\n\t\t\t}\n\t\t}\n\t\t\tbreak;\n\t\tcase OP_REMOVE:\n\t\t\tif (misagent_remove(mis, param) == MISAGENT_E_SUCCESS) {\n\t\t\t\tprintf(\"Profile '%s' removed.\\n\", param);\n\t\t\t} else {\n\t\t\t\tint sc = misagent_get_status_code(mis);\n\t\t\t\tfprintf(stderr, \"Could not remove profile '%s', status code 0x%x\\n\", param, sc);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\tmisagent_client_free(mis);\n\n\tidevice_free(device);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"common/utils.h\"",
      "#include <libimobiledevice/misagent.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <arpa/inet.h>",
      "#include <windows.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "idevice_free",
          "args": [
            "device"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "idevice_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
          "lines": "247-265",
          "snippet": "LIBIMOBILEDEVICE_API idevice_error_t idevice_free(idevice_t device)\n{\n\tif (!device)\n\t\treturn IDEVICE_E_INVALID_ARG;\n\tidevice_error_t ret = IDEVICE_E_UNKNOWN_ERROR;\n\n\tret = IDEVICE_E_SUCCESS;\n\n\tfree(device->udid);\n\n\tif (device->conn_type == CONNECTION_USBMUXD) {\n\t\tdevice->conn_data = 0;\n\t}\n\tif (device->conn_data) {\n\t\tfree(device->conn_data);\n\t}\n\tfree(device);\n\treturn ret;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"common/thread.h\"",
            "#include \"common/userpref.h\"",
            "#include \"idevice.h\"",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <usbmuxd.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "LIBIMOBILEDEVICE_API idevice_error_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nLIBIMOBILEDEVICE_API idevice_error_t idevice_free(idevice_t device)\n{\n\tif (!device)\n\t\treturn IDEVICE_E_INVALID_ARG;\n\tidevice_error_t ret = IDEVICE_E_UNKNOWN_ERROR;\n\n\tret = IDEVICE_E_SUCCESS;\n\n\tfree(device->udid);\n\n\tif (device->conn_type == CONNECTION_USBMUXD) {\n\t\tdevice->conn_data = 0;\n\t}\n\tif (device->conn_data) {\n\t\tfree(device->conn_data);\n\t}\n\tfree(device);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "misagent_client_free",
          "args": [
            "mis"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "misagent_client_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/misagent.c",
          "lines": "113-126",
          "snippet": "LIBIMOBILEDEVICE_API misagent_error_t misagent_client_free(misagent_client_t client)\n{\n\tif (!client)\n\t\treturn MISAGENT_E_INVALID_ARG;\n\n\tmisagent_error_t err = MISAGENT_E_SUCCESS;\n\tif (client->parent && client->parent->parent) {\n\t\tmisagent_error(property_list_service_client_free(client->parent));\n\t}\n\tclient->parent = NULL;\n\tfree(client);\n\n\treturn err;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"property_list_service.h\"",
            "#include \"misagent.h\"",
            "#include <stdio.h>",
            "#include <plist/plist.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"property_list_service.h\"\n#include \"misagent.h\"\n#include <stdio.h>\n#include <plist/plist.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n\nLIBIMOBILEDEVICE_API misagent_error_t misagent_client_free(misagent_client_t client)\n{\n\tif (!client)\n\t\treturn MISAGENT_E_INVALID_ARG;\n\n\tmisagent_error_t err = MISAGENT_E_SUCCESS;\n\tif (client->parent && client->parent->parent) {\n\t\tmisagent_error(property_list_service_client_free(client->parent));\n\t}\n\tclient->parent = NULL;\n\tfree(client);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Could not remove profile '%s', status code 0x%x\\n\"",
            "param",
            "sc"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "misagent_get_status_code",
          "args": [
            "mis"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "misagent_get_status_code",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/misagent.c",
          "lines": "242-248",
          "snippet": "LIBIMOBILEDEVICE_API int misagent_get_status_code(misagent_client_t client)\n{\n\tif (!client) {\n\t\treturn -1;\n\t}\n\treturn client->last_error;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"property_list_service.h\"",
            "#include \"misagent.h\"",
            "#include <stdio.h>",
            "#include <plist/plist.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"property_list_service.h\"\n#include \"misagent.h\"\n#include <stdio.h>\n#include <plist/plist.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n\nLIBIMOBILEDEVICE_API int misagent_get_status_code(misagent_client_t client)\n{\n\tif (!client) {\n\t\treturn -1;\n\t}\n\treturn client->last_error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Profile '%s' removed.\\n\"",
            "param"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "asprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/include/asprintf.h",
          "lines": "23-31",
          "snippet": "static inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}",
          "includes": [
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <config.h>\n\nstatic inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "misagent_remove",
          "args": [
            "mis",
            "param"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "misagent_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/misagent.c",
          "lines": "205-240",
          "snippet": "LIBIMOBILEDEVICE_API misagent_error_t misagent_remove(misagent_client_t client, const char* profileID)\n{\n\tif (!client || !client->parent || !profileID)\n\t\treturn MISAGENT_E_INVALID_ARG;\n\n\tclient->last_error = MISAGENT_E_UNKNOWN_ERROR;\n\n\tplist_t dict = plist_new_dict();\n\tplist_dict_set_item(dict, \"MessageType\", plist_new_string(\"Remove\"));\n\tplist_dict_set_item(dict, \"ProfileID\", plist_new_string(profileID));\n\tplist_dict_set_item(dict, \"ProfileType\", plist_new_string(\"Provisioning\"));\n\n\tmisagent_error_t res = misagent_error(property_list_service_send_xml_plist(client->parent, dict));\n\tplist_free(dict);\n\tdict = NULL;\n\n\tif (res != MISAGENT_E_SUCCESS) {\n\t\tdebug_info(\"could not send plist, error %d\", res);\n\t\treturn res;\n\t}\n\n\tres = misagent_error(property_list_service_receive_plist(client->parent, &dict));\n\tif (res != MISAGENT_E_SUCCESS) {\n\t\tdebug_info(\"could not receive response, error %d\", res);\n\t\treturn res;\n\t}\n\tif (!dict) {\n\t\tdebug_info(\"could not get response plist\");\n\t\treturn MISAGENT_E_UNKNOWN_ERROR;\n\t}\n\n\tres = misagent_check_result(dict, &client->last_error);\n\tplist_free(dict);\n\n\treturn res;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"property_list_service.h\"",
            "#include \"misagent.h\"",
            "#include <stdio.h>",
            "#include <plist/plist.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"property_list_service.h\"\n#include \"misagent.h\"\n#include <stdio.h>\n#include <plist/plist.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n\nLIBIMOBILEDEVICE_API misagent_error_t misagent_remove(misagent_client_t client, const char* profileID)\n{\n\tif (!client || !client->parent || !profileID)\n\t\treturn MISAGENT_E_INVALID_ARG;\n\n\tclient->last_error = MISAGENT_E_UNKNOWN_ERROR;\n\n\tplist_t dict = plist_new_dict();\n\tplist_dict_set_item(dict, \"MessageType\", plist_new_string(\"Remove\"));\n\tplist_dict_set_item(dict, \"ProfileID\", plist_new_string(profileID));\n\tplist_dict_set_item(dict, \"ProfileType\", plist_new_string(\"Provisioning\"));\n\n\tmisagent_error_t res = misagent_error(property_list_service_send_xml_plist(client->parent, dict));\n\tplist_free(dict);\n\tdict = NULL;\n\n\tif (res != MISAGENT_E_SUCCESS) {\n\t\tdebug_info(\"could not send plist, error %d\", res);\n\t\treturn res;\n\t}\n\n\tres = misagent_error(property_list_service_receive_plist(client->parent, &dict));\n\tif (res != MISAGENT_E_SUCCESS) {\n\t\tdebug_info(\"could not receive response, error %d\", res);\n\t\treturn res;\n\t}\n\tif (!dict) {\n\t\tdebug_info(\"could not get response plist\");\n\t\treturn MISAGENT_E_UNKNOWN_ERROR;\n\t}\n\n\tres = misagent_check_result(dict, &client->last_error);\n\tplist_free(dict);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Could not get installed profiles from device, status code: 0x%x\\n\"",
            "sc"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "p_name"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "thread_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "39-44",
          "snippet": "void thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nvoid thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Could not open '%s' for writing\\n\"",
            "pfname"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fwrite",
          "args": [
            "dt",
            "1",
            "ds",
            "f"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_data_val",
          "args": [
            "profile",
            "&dt",
            "&ds"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "pfname",
            "\"wb\""
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_string_val",
          "args": [
            "node",
            "&p_uuid"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_node_type",
          "args": [
            "node"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "pl",
            "\"UUID\""
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_string_val",
          "args": [
            "node",
            "&p_name"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_node_type",
          "args": [
            "node"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "pl",
            "\"Name\""
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_node_type",
          "args": [
            "pl"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "profile_get_embedded_plist",
          "args": [
            "profile"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "profile_get_embedded_plist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/ideviceprovision.c",
          "lines": "112-202",
          "snippet": "static plist_t profile_get_embedded_plist(plist_t profile)\n{\n\tif (plist_get_node_type(profile) != PLIST_DATA) {\n\t\tfprintf(stderr, \"%s: unexpected plist node type for profile (PLIST_DATA expected)\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tchar* bbuf = NULL;\n\tuint64_t blen = 0;\n\tplist_get_data_val(profile, &bbuf, &blen);\n\tif (!bbuf) {\n\t\tfprintf(stderr, \"%s: could not get data value from plist node\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tunsigned char* pp = (unsigned char*)bbuf;\n\n\tif (*pp != ASN1_SEQUENCE) {\n\t\tfree(bbuf);\n\t\tfprintf(stderr, \"%s: unexpected profile data (0)\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tuint16_t slen = asn1_item_get_size(pp);\n\tif (slen+4 != (uint16_t)blen) {\n\t\tfree(bbuf);\n\t\tfprintf(stderr, \"%s: unexpected profile data (1)\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tasn1_next_item(&pp);\n\n\tif (*pp != ASN1_OBJECT_IDENTIFIER) {\n\t\tfree(bbuf);\n\t\tfprintf(stderr, \"%s: unexpected profile data (2)\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tasn1_skip_item(&pp);\n\n\tif (*pp != ASN1_CONTAINER) {\n\t\tfree(bbuf);\n\t\tfprintf(stderr, \"%s: unexpected profile data (3)\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tasn1_next_item(&pp);\n\n\tif (*pp != ASN1_SEQUENCE) {\n\t\tfree(bbuf);\n\t\tfprintf(stderr, \"%s: unexpected profile data (4)\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tasn1_next_item(&pp);\n\n\tint k = 0;\n\t// go to the 3rd element (skip 2)\n\twhile (k < 2) {\n\t\tasn1_skip_item(&pp);\n\t\tk++;\n\t}\n\tif (*pp != ASN1_SEQUENCE) {\n\t\tfree(bbuf);\n\t\tfprintf(stderr, \"%s: unexpected profile data (5)\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tasn1_next_item(&pp);\n\n\tif (*pp != ASN1_OBJECT_IDENTIFIER) {\n\t\tfree(bbuf);\n\t\tfprintf(stderr, \"%s: unexpected profile data (6)\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tasn1_skip_item(&pp);\n\n\tif (*pp != ASN1_CONTAINER) {\n\t\tfree(bbuf);\n\t\tfprintf(stderr, \"%s: unexpected profile data (7)\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tasn1_next_item(&pp);\n\n\tif (*pp != ASN1_OCTET_STRING) {\n\t\tfree(bbuf);\n\t\tfprintf(stderr, \"%s: unexpected profile data (8)\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tslen = asn1_item_get_size(pp);\n\tasn1_next_item(&pp);\n\n\tplist_t pl = NULL;\n\tplist_from_xml((char*)pp, slen, &pl);\n\tfree(bbuf);\n\n\treturn pl;\n}",
          "includes": [
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/misagent.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <arpa/inet.h>",
            "#include <windows.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define ASN1_OCTET_STRING 0x04",
            "#define ASN1_OBJECT_IDENTIFIER 0x06",
            "#define ASN1_CONTAINER 0xA0",
            "#define ASN1_SEQUENCE 0x30"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/utils.h\"\n#include <libimobiledevice/misagent.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <arpa/inet.h>\n#include <windows.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\n#define ASN1_OCTET_STRING 0x04\n#define ASN1_OBJECT_IDENTIFIER 0x06\n#define ASN1_CONTAINER 0xA0\n#define ASN1_SEQUENCE 0x30\n\nstatic plist_t profile_get_embedded_plist(plist_t profile)\n{\n\tif (plist_get_node_type(profile) != PLIST_DATA) {\n\t\tfprintf(stderr, \"%s: unexpected plist node type for profile (PLIST_DATA expected)\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tchar* bbuf = NULL;\n\tuint64_t blen = 0;\n\tplist_get_data_val(profile, &bbuf, &blen);\n\tif (!bbuf) {\n\t\tfprintf(stderr, \"%s: could not get data value from plist node\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tunsigned char* pp = (unsigned char*)bbuf;\n\n\tif (*pp != ASN1_SEQUENCE) {\n\t\tfree(bbuf);\n\t\tfprintf(stderr, \"%s: unexpected profile data (0)\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tuint16_t slen = asn1_item_get_size(pp);\n\tif (slen+4 != (uint16_t)blen) {\n\t\tfree(bbuf);\n\t\tfprintf(stderr, \"%s: unexpected profile data (1)\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tasn1_next_item(&pp);\n\n\tif (*pp != ASN1_OBJECT_IDENTIFIER) {\n\t\tfree(bbuf);\n\t\tfprintf(stderr, \"%s: unexpected profile data (2)\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tasn1_skip_item(&pp);\n\n\tif (*pp != ASN1_CONTAINER) {\n\t\tfree(bbuf);\n\t\tfprintf(stderr, \"%s: unexpected profile data (3)\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tasn1_next_item(&pp);\n\n\tif (*pp != ASN1_SEQUENCE) {\n\t\tfree(bbuf);\n\t\tfprintf(stderr, \"%s: unexpected profile data (4)\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tasn1_next_item(&pp);\n\n\tint k = 0;\n\t// go to the 3rd element (skip 2)\n\twhile (k < 2) {\n\t\tasn1_skip_item(&pp);\n\t\tk++;\n\t}\n\tif (*pp != ASN1_SEQUENCE) {\n\t\tfree(bbuf);\n\t\tfprintf(stderr, \"%s: unexpected profile data (5)\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tasn1_next_item(&pp);\n\n\tif (*pp != ASN1_OBJECT_IDENTIFIER) {\n\t\tfree(bbuf);\n\t\tfprintf(stderr, \"%s: unexpected profile data (6)\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tasn1_skip_item(&pp);\n\n\tif (*pp != ASN1_CONTAINER) {\n\t\tfree(bbuf);\n\t\tfprintf(stderr, \"%s: unexpected profile data (7)\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tasn1_next_item(&pp);\n\n\tif (*pp != ASN1_OCTET_STRING) {\n\t\tfree(bbuf);\n\t\tfprintf(stderr, \"%s: unexpected profile data (8)\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tslen = asn1_item_get_size(pp);\n\tasn1_next_item(&pp);\n\n\tplist_t pl = NULL;\n\tplist_from_xml((char*)pp, slen, &pl);\n\tfree(bbuf);\n\n\treturn pl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_array_get_item",
          "args": [
            "profiles",
            "j"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_array_get_size",
          "args": [
            "profiles"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "misagent_copy",
          "args": [
            "mis",
            "&profiles"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "misagent_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/misagent.c",
          "lines": "165-203",
          "snippet": "LIBIMOBILEDEVICE_API misagent_error_t misagent_copy(misagent_client_t client, plist_t* profiles)\n{\n\tif (!client || !client->parent || !profiles)\n\t\treturn MISAGENT_E_INVALID_ARG;\n\n\tclient->last_error = MISAGENT_E_UNKNOWN_ERROR;\n\n\tplist_t dict = plist_new_dict();\n\tplist_dict_set_item(dict, \"MessageType\", plist_new_string(\"Copy\"));\n\tplist_dict_set_item(dict, \"ProfileType\", plist_new_string(\"Provisioning\"));\n\n\tmisagent_error_t res = misagent_error(property_list_service_send_xml_plist(client->parent, dict));\n\tplist_free(dict);\n\tdict = NULL;\n\n\tif (res != MISAGENT_E_SUCCESS) {\n\t\tdebug_info(\"could not send plist, error %d\", res);\n\t\treturn res;\n\t}\n\n\tres = misagent_error(property_list_service_receive_plist(client->parent, &dict));\n\tif (res != MISAGENT_E_SUCCESS) {\n\t\tdebug_info(\"could not receive response, error %d\", res);\n\t\treturn res;\n\t}\n\tif (!dict) {\n\t\tdebug_info(\"could not get response plist\");\n\t\treturn MISAGENT_E_UNKNOWN_ERROR;\n\t}\n\n\tres = misagent_check_result(dict, &client->last_error);\n\tif (res == MISAGENT_E_SUCCESS) {\n\t\t*profiles = plist_copy(plist_dict_get_item(dict, \"Payload\"));\n\t}\n\tplist_free(dict);\n\n\treturn res;\n\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"property_list_service.h\"",
            "#include \"misagent.h\"",
            "#include <stdio.h>",
            "#include <plist/plist.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"property_list_service.h\"\n#include \"misagent.h\"\n#include <stdio.h>\n#include <plist/plist.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n\nLIBIMOBILEDEVICE_API misagent_error_t misagent_copy(misagent_client_t client, plist_t* profiles)\n{\n\tif (!client || !client->parent || !profiles)\n\t\treturn MISAGENT_E_INVALID_ARG;\n\n\tclient->last_error = MISAGENT_E_UNKNOWN_ERROR;\n\n\tplist_t dict = plist_new_dict();\n\tplist_dict_set_item(dict, \"MessageType\", plist_new_string(\"Copy\"));\n\tplist_dict_set_item(dict, \"ProfileType\", plist_new_string(\"Provisioning\"));\n\n\tmisagent_error_t res = misagent_error(property_list_service_send_xml_plist(client->parent, dict));\n\tplist_free(dict);\n\tdict = NULL;\n\n\tif (res != MISAGENT_E_SUCCESS) {\n\t\tdebug_info(\"could not send plist, error %d\", res);\n\t\treturn res;\n\t}\n\n\tres = misagent_error(property_list_service_receive_plist(client->parent, &dict));\n\tif (res != MISAGENT_E_SUCCESS) {\n\t\tdebug_info(\"could not receive response, error %d\", res);\n\t\treturn res;\n\t}\n\tif (!dict) {\n\t\tdebug_info(\"could not get response plist\");\n\t\treturn MISAGENT_E_UNKNOWN_ERROR;\n\t}\n\n\tres = misagent_check_result(dict, &client->last_error);\n\tif (res == MISAGENT_E_SUCCESS) {\n\t\t*profiles = plist_copy(plist_dict_get_item(dict, \"Payload\"));\n\t}\n\tplist_free(dict);\n\n\treturn res;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Could not install profile '%s', status code: 0x%x\\n\"",
            "param",
            "sc"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "misagent_install",
          "args": [
            "mis",
            "pdata"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "misagent_install",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/misagent.c",
          "lines": "128-163",
          "snippet": "LIBIMOBILEDEVICE_API misagent_error_t misagent_install(misagent_client_t client, plist_t profile)\n{\n\tif (!client || !client->parent || !profile || (plist_get_node_type(profile) != PLIST_DATA))\n\t\treturn MISAGENT_E_INVALID_ARG;\n\n\tclient->last_error = MISAGENT_E_UNKNOWN_ERROR;\n\n\tplist_t dict = plist_new_dict();\n\tplist_dict_set_item(dict, \"MessageType\", plist_new_string(\"Install\"));\n\tplist_dict_set_item(dict, \"Profile\", plist_copy(profile));\n\tplist_dict_set_item(dict, \"ProfileType\", plist_new_string(\"Provisioning\"));\n\n\tmisagent_error_t res = misagent_error(property_list_service_send_xml_plist(client->parent, dict));\n\tplist_free(dict);\n\tdict = NULL;\n\n\tif (res != MISAGENT_E_SUCCESS) {\n\t\tdebug_info(\"could not send plist, error %d\", res);\n\t\treturn res;\n\t}\n\n\tres = misagent_error(property_list_service_receive_plist(client->parent, &dict));\n\tif (res != MISAGENT_E_SUCCESS) {\n\t\tdebug_info(\"could not receive response, error %d\", res);\n\t\treturn res;\n\t}\n\tif (!dict) {\n\t\tdebug_info(\"could not get response plist\");\n\t\treturn MISAGENT_E_UNKNOWN_ERROR;\n\t}\n\n\tres = misagent_check_result(dict, &client->last_error);\n\tplist_free(dict);\n\n\treturn res;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"property_list_service.h\"",
            "#include \"misagent.h\"",
            "#include <stdio.h>",
            "#include <plist/plist.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"property_list_service.h\"\n#include \"misagent.h\"\n#include <stdio.h>\n#include <plist/plist.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n\nLIBIMOBILEDEVICE_API misagent_error_t misagent_install(misagent_client_t client, plist_t profile)\n{\n\tif (!client || !client->parent || !profile || (plist_get_node_type(profile) != PLIST_DATA))\n\t\treturn MISAGENT_E_INVALID_ARG;\n\n\tclient->last_error = MISAGENT_E_UNKNOWN_ERROR;\n\n\tplist_t dict = plist_new_dict();\n\tplist_dict_set_item(dict, \"MessageType\", plist_new_string(\"Install\"));\n\tplist_dict_set_item(dict, \"Profile\", plist_copy(profile));\n\tplist_dict_set_item(dict, \"ProfileType\", plist_new_string(\"Provisioning\"));\n\n\tmisagent_error_t res = misagent_error(property_list_service_send_xml_plist(client->parent, dict));\n\tplist_free(dict);\n\tdict = NULL;\n\n\tif (res != MISAGENT_E_SUCCESS) {\n\t\tdebug_info(\"could not send plist, error %d\", res);\n\t\treturn res;\n\t}\n\n\tres = misagent_error(property_list_service_receive_plist(client->parent, &dict));\n\tif (res != MISAGENT_E_SUCCESS) {\n\t\tdebug_info(\"could not receive response, error %d\", res);\n\t\treturn res;\n\t}\n\tif (!dict) {\n\t\tdebug_info(\"could not get response plist\");\n\t\treturn MISAGENT_E_UNKNOWN_ERROR;\n\t}\n\n\tres = misagent_check_result(dict, &client->last_error);\n\tplist_free(dict);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_new_data",
          "args": [
            "(const char*)profile_data",
            "psize"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "profile_read_from_file",
          "args": [
            "param",
            "&profile_data",
            "&profile_size"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "profile_read_from_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/ideviceprovision.c",
          "lines": "204-248",
          "snippet": "static int profile_read_from_file(const char* path, unsigned char **profile_data, unsigned int *profile_size)\n{\n\tFILE* f = fopen(path, \"rb\");\n\tif (!f) {\n\t\tfprintf(stderr, \"Could not open file '%s'\\n\", path);\n\t\treturn -1;\n\t}\n\tfseek(f, 0, SEEK_END);\n\tlong int size = ftell(f);\n\tfseek(f, 0, SEEK_SET);\n\n\tif (size >= 0x1000000) {\n\t\tfprintf(stderr, \"The file '%s' is too large for processing.\\n\", path);\n\t\tfclose(f);\n\t\treturn -1;\n\t}\n\n\tunsigned char* buf = malloc(size);\n\tif (!buf) {\n\t\tfprintf(stderr, \"Could not allocate memory...\\n\");\n\t\tfclose(f);\n\t\treturn -1;\n\t}\n\n\tlong int cur = 0;\n\twhile (cur < size) {\n\t\tssize_t r = fread(buf+cur, 1, 512, f);\n\t\tif (r <= 0) {\n\t\t\tbreak;\n\t\t}\n\t\tcur += r;\n\t}\n\tfclose(f);\n\n\tif (cur != size) {\n\t\tfree(buf);\n\t\tfprintf(stderr, \"Could not read in file '%s' (size %ld read %ld)\\n\", path, size, cur);\n\t\treturn -1;\n\t}\n\n\t*profile_data = buf;\n\t*profile_size = (unsigned int)size;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/misagent.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <arpa/inet.h>",
            "#include <windows.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/utils.h\"\n#include <libimobiledevice/misagent.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <arpa/inet.h>\n#include <windows.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int profile_read_from_file(const char* path, unsigned char **profile_data, unsigned int *profile_size)\n{\n\tFILE* f = fopen(path, \"rb\");\n\tif (!f) {\n\t\tfprintf(stderr, \"Could not open file '%s'\\n\", path);\n\t\treturn -1;\n\t}\n\tfseek(f, 0, SEEK_END);\n\tlong int size = ftell(f);\n\tfseek(f, 0, SEEK_SET);\n\n\tif (size >= 0x1000000) {\n\t\tfprintf(stderr, \"The file '%s' is too large for processing.\\n\", path);\n\t\tfclose(f);\n\t\treturn -1;\n\t}\n\n\tunsigned char* buf = malloc(size);\n\tif (!buf) {\n\t\tfprintf(stderr, \"Could not allocate memory...\\n\");\n\t\tfclose(f);\n\t\treturn -1;\n\t}\n\n\tlong int cur = 0;\n\twhile (cur < size) {\n\t\tssize_t r = fread(buf+cur, 1, 512, f);\n\t\tif (r <= 0) {\n\t\t\tbreak;\n\t\t}\n\t\tcur += r;\n\t}\n\tfclose(f);\n\n\tif (cur != size) {\n\t\tfree(buf);\n\t\tfprintf(stderr, \"Could not read in file '%s' (size %ld read %ld)\\n\", path, size, cur);\n\t\treturn -1;\n\t}\n\n\t*profile_data = buf;\n\t*profile_size = (unsigned int)size;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdownd_service_descriptor_free",
          "args": [
            "service"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "lockdownd_service_descriptor_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/lockdown.c",
          "lines": "1522-1528",
          "snippet": "LIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_service_descriptor_free(lockdownd_service_descriptor_t service)\n{\n\tif (service)\n\t\tfree(service);\n\n\treturn LOCKDOWN_E_SUCCESS;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/userpref.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"lockdown.h\"",
            "#include \"property_list_service.h\"",
            "#include <plist/plist.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/x509.h>",
            "#include <libtasn1.h>",
            "#include <openssl/x509v3.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/pem.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/userpref.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"lockdown.h\"\n#include \"property_list_service.h\"\n#include <plist/plist.h>\n#include <gnutls/crypto.h>\n#include <gnutls/x509.h>\n#include <libtasn1.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/pem.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_service_descriptor_free(lockdownd_service_descriptor_t service)\n{\n\tif (service)\n\t\tfree(service);\n\n\treturn LOCKDOWN_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdownd_client_free",
          "args": [
            "client"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "lockdownd_client_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/lockdown.c",
          "lines": "322-336",
          "snippet": "LIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_client_free(lockdownd_client_t client)\n{\n\tif (!client)\n\t\treturn LOCKDOWN_E_INVALID_ARG;\n\n\tlockdownd_error_t ret = LOCKDOWN_E_UNKNOWN_ERROR;\n\n\tif (client->session_id) {\n\t\tlockdownd_stop_session(client, client->session_id);\n\t}\n\n\tret = lockdownd_client_free_simple(client);\n\n\treturn ret;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/userpref.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"lockdown.h\"",
            "#include \"property_list_service.h\"",
            "#include <plist/plist.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/x509.h>",
            "#include <libtasn1.h>",
            "#include <openssl/x509v3.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/pem.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/userpref.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"lockdown.h\"\n#include \"property_list_service.h\"\n#include <plist/plist.h>\n#include <gnutls/crypto.h>\n#include <gnutls/x509.h>\n#include <libtasn1.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/pem.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_client_free(lockdownd_client_t client)\n{\n\tif (!client)\n\t\treturn LOCKDOWN_E_INVALID_ARG;\n\n\tlockdownd_error_t ret = LOCKDOWN_E_UNKNOWN_ERROR;\n\n\tif (client->session_id) {\n\t\tlockdownd_stop_session(client, client->session_id);\n\t}\n\n\tret = lockdownd_client_free_simple(client);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Could not connect to \\\"com.apple.misagent\\\" on device\\n\""
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "misagent_client_new",
          "args": [
            "device",
            "service",
            "&mis"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "misagent_client_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/misagent.c",
          "lines": "90-104",
          "snippet": "LIBIMOBILEDEVICE_API misagent_error_t misagent_client_new(idevice_t device, lockdownd_service_descriptor_t service, misagent_client_t *client)\n{\n\tproperty_list_service_client_t plistclient = NULL;\n\tmisagent_error_t err = misagent_error(property_list_service_client_new(device, service, &plistclient));\n\tif (err != MISAGENT_E_SUCCESS) {\n\t\treturn err;\n\t}\n\n\tmisagent_client_t client_loc = (misagent_client_t) malloc(sizeof(struct misagent_client_private));\n\tclient_loc->parent = plistclient;\n\tclient_loc->last_error = 0;\n\n\t*client = client_loc;\n\treturn MISAGENT_E_SUCCESS;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"property_list_service.h\"",
            "#include \"misagent.h\"",
            "#include <stdio.h>",
            "#include <plist/plist.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"property_list_service.h\"\n#include \"misagent.h\"\n#include <stdio.h>\n#include <plist/plist.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n\nLIBIMOBILEDEVICE_API misagent_error_t misagent_client_new(idevice_t device, lockdownd_service_descriptor_t service, misagent_client_t *client)\n{\n\tproperty_list_service_client_t plistclient = NULL;\n\tmisagent_error_t err = misagent_error(property_list_service_client_new(device, service, &plistclient));\n\tif (err != MISAGENT_E_SUCCESS) {\n\t\treturn err;\n\t}\n\n\tmisagent_client_t client_loc = (misagent_client_t) malloc(sizeof(struct misagent_client_private));\n\tclient_loc->parent = plistclient;\n\tclient_loc->last_error = 0;\n\n\t*client = client_loc;\n\treturn MISAGENT_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Could not start service \\\"com.apple.misagent\\\"\\n\""
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdownd_start_service",
          "args": [
            "client",
            "\"com.apple.misagent\"",
            "&service"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "lockdownd_start_service_with_escrow_bag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/lockdown.c",
          "lines": "1364-1367",
          "snippet": "LIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_start_service_with_escrow_bag(lockdownd_client_t client, const char *identifier, lockdownd_service_descriptor_t *service)\n{\n\treturn lockdownd_do_start_service(client, identifier, 1, service);\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/userpref.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"lockdown.h\"",
            "#include \"property_list_service.h\"",
            "#include <plist/plist.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/x509.h>",
            "#include <libtasn1.h>",
            "#include <openssl/x509v3.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/pem.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/userpref.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"lockdown.h\"\n#include \"property_list_service.h\"\n#include <plist/plist.h>\n#include <gnutls/crypto.h>\n#include <gnutls/x509.h>\n#include <libtasn1.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/pem.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_start_service_with_escrow_bag(lockdownd_client_t client, const char *identifier, lockdownd_service_descriptor_t *service)\n{\n\treturn lockdownd_do_start_service(client, identifier, 1, service);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"ERROR: Could not connect to lockdownd, error code %d\\n\"",
            "ldret"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdownd_client_new_with_handshake",
          "args": [
            "device",
            "&client",
            "\"ideviceprovision\""
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "lockdownd_client_new_with_handshake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/lockdown.c",
          "lines": "671-753",
          "snippet": "LIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_client_new_with_handshake(idevice_t device, lockdownd_client_t *client, const char *label)\n{\n\tif (!client)\n\t\treturn LOCKDOWN_E_INVALID_ARG;\n\n\tlockdownd_error_t ret = LOCKDOWN_E_SUCCESS;\n\tlockdownd_client_t client_loc = NULL;\n\tplist_t pair_record = NULL;\n\tchar *host_id = NULL;\n\tchar *type = NULL;\n\n\tret = lockdownd_client_new(device, &client_loc, label);\n\tif (LOCKDOWN_E_SUCCESS != ret) {\n\t\tdebug_info(\"failed to create lockdownd client.\");\n\t\treturn ret;\n\t}\n\n\t/* perform handshake */\n\tif (LOCKDOWN_E_SUCCESS != lockdownd_query_type(client_loc, &type)) {\n\t\tdebug_info(\"QueryType failed in the lockdownd client.\");\n\t\tret = LOCKDOWN_E_NOT_ENOUGH_DATA;\n\t} else {\n\t\tif (strcmp(\"com.apple.mobile.lockdown\", type)) {\n\t\t\tdebug_info(\"Warning QueryType request returned \\\"%s\\\".\", type);\n\t\t}\n\t}\n\tfree(type);\n\n\tuserpref_read_pair_record(client_loc->udid, &pair_record);\n\tif (pair_record) {\n\t\tpair_record_get_host_id(pair_record, &host_id);\n\t}\n\tif (LOCKDOWN_E_SUCCESS == ret && !host_id) {\n\t\tret = LOCKDOWN_E_INVALID_CONF;\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS == ret && !pair_record) {\n\t\t/* attempt pairing */\n\t\tret = lockdownd_pair(client_loc, NULL);\n\t}\n\n\tplist_free(pair_record);\n\tpair_record = NULL;\n\n\t/* in any case, we need to validate pairing to receive trusted host status */\n\tret = lockdownd_validate_pair(client_loc, NULL);\n\n\t/* if not paired yet, let's do it now */\n\tif (LOCKDOWN_E_INVALID_HOST_ID == ret) {\n\t\tfree(host_id);\n\t\thost_id = NULL;\n\t\tret = lockdownd_pair(client_loc, NULL);\n\t\tif (LOCKDOWN_E_SUCCESS == ret) {\n\t\t\tret = lockdownd_validate_pair(client_loc, NULL);\n\t\t} else if (LOCKDOWN_E_PAIRING_DIALOG_RESPONSE_PENDING == ret) {\n\t\t\tdebug_info(\"Device shows the pairing dialog.\");\n\t\t}\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS == ret) {\n\t\tif (!host_id) {\n\t\t\tuserpref_read_pair_record(client_loc->udid, &pair_record);\n\t\t\tif (pair_record) {\n\t\t\t\tpair_record_get_host_id(pair_record, &host_id);\n\t\t\t\tplist_free(pair_record);\n\t\t\t}\n\t\t}\n\n\t\tret = lockdownd_start_session(client_loc, host_id, NULL, NULL);\n\t\tif (LOCKDOWN_E_SUCCESS != ret) {\n\t\t\tdebug_info(\"Session opening failed.\");\n\t\t}\n\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS == ret) {\n\t\t*client = client_loc;\n\t} else {\n\t\tlockdownd_client_free(client_loc);\n\t}\n\tfree(host_id);\n\treturn ret;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/userpref.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"lockdown.h\"",
            "#include \"property_list_service.h\"",
            "#include <plist/plist.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/x509.h>",
            "#include <libtasn1.h>",
            "#include <openssl/x509v3.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/pem.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/userpref.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"lockdown.h\"\n#include \"property_list_service.h\"\n#include <plist/plist.h>\n#include <gnutls/crypto.h>\n#include <gnutls/x509.h>\n#include <libtasn1.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/pem.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_client_new_with_handshake(idevice_t device, lockdownd_client_t *client, const char *label)\n{\n\tif (!client)\n\t\treturn LOCKDOWN_E_INVALID_ARG;\n\n\tlockdownd_error_t ret = LOCKDOWN_E_SUCCESS;\n\tlockdownd_client_t client_loc = NULL;\n\tplist_t pair_record = NULL;\n\tchar *host_id = NULL;\n\tchar *type = NULL;\n\n\tret = lockdownd_client_new(device, &client_loc, label);\n\tif (LOCKDOWN_E_SUCCESS != ret) {\n\t\tdebug_info(\"failed to create lockdownd client.\");\n\t\treturn ret;\n\t}\n\n\t/* perform handshake */\n\tif (LOCKDOWN_E_SUCCESS != lockdownd_query_type(client_loc, &type)) {\n\t\tdebug_info(\"QueryType failed in the lockdownd client.\");\n\t\tret = LOCKDOWN_E_NOT_ENOUGH_DATA;\n\t} else {\n\t\tif (strcmp(\"com.apple.mobile.lockdown\", type)) {\n\t\t\tdebug_info(\"Warning QueryType request returned \\\"%s\\\".\", type);\n\t\t}\n\t}\n\tfree(type);\n\n\tuserpref_read_pair_record(client_loc->udid, &pair_record);\n\tif (pair_record) {\n\t\tpair_record_get_host_id(pair_record, &host_id);\n\t}\n\tif (LOCKDOWN_E_SUCCESS == ret && !host_id) {\n\t\tret = LOCKDOWN_E_INVALID_CONF;\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS == ret && !pair_record) {\n\t\t/* attempt pairing */\n\t\tret = lockdownd_pair(client_loc, NULL);\n\t}\n\n\tplist_free(pair_record);\n\tpair_record = NULL;\n\n\t/* in any case, we need to validate pairing to receive trusted host status */\n\tret = lockdownd_validate_pair(client_loc, NULL);\n\n\t/* if not paired yet, let's do it now */\n\tif (LOCKDOWN_E_INVALID_HOST_ID == ret) {\n\t\tfree(host_id);\n\t\thost_id = NULL;\n\t\tret = lockdownd_pair(client_loc, NULL);\n\t\tif (LOCKDOWN_E_SUCCESS == ret) {\n\t\t\tret = lockdownd_validate_pair(client_loc, NULL);\n\t\t} else if (LOCKDOWN_E_PAIRING_DIALOG_RESPONSE_PENDING == ret) {\n\t\t\tdebug_info(\"Device shows the pairing dialog.\");\n\t\t}\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS == ret) {\n\t\tif (!host_id) {\n\t\t\tuserpref_read_pair_record(client_loc->udid, &pair_record);\n\t\t\tif (pair_record) {\n\t\t\t\tpair_record_get_host_id(pair_record, &host_id);\n\t\t\t\tplist_free(pair_record);\n\t\t\t}\n\t\t}\n\n\t\tret = lockdownd_start_session(client_loc, host_id, NULL, NULL);\n\t\tif (LOCKDOWN_E_SUCCESS != ret) {\n\t\t\tdebug_info(\"Session opening failed.\");\n\t\t}\n\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS == ret) {\n\t\t*client = client_loc;\n\t} else {\n\t\tlockdownd_client_free(client_loc);\n\t}\n\tfree(host_id);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"No device found, is it plugged in?\\n\""
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idevice_new",
          "args": [
            "&device",
            "udid"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "idevice_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
          "lines": "230-245",
          "snippet": "LIBIMOBILEDEVICE_API idevice_error_t idevice_new(idevice_t * device, const char *udid)\n{\n\tusbmuxd_device_info_t muxdev;\n\tint res = usbmuxd_get_device_by_udid(udid, &muxdev);\n\tif (res > 0) {\n\t\tidevice_t dev = (idevice_t) malloc(sizeof(struct idevice_private));\n\t\tdev->udid = strdup(muxdev.udid);\n\t\tdev->conn_type = CONNECTION_USBMUXD;\n\t\tdev->conn_data = (void*)(long)muxdev.handle;\n\t\t*device = dev;\n\t\treturn IDEVICE_E_SUCCESS;\n\t}\n\t/* other connection types could follow here */\n\n\treturn IDEVICE_E_NO_DEVICE;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"common/thread.h\"",
            "#include \"common/userpref.h\"",
            "#include \"idevice.h\"",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <usbmuxd.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "LIBIMOBILEDEVICE_API idevice_error_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nLIBIMOBILEDEVICE_API idevice_error_t idevice_new(idevice_t * device, const char *udid)\n{\n\tusbmuxd_device_info_t muxdev;\n\tint res = usbmuxd_get_device_by_udid(udid, &muxdev);\n\tif (res > 0) {\n\t\tidevice_t dev = (idevice_t) malloc(sizeof(struct idevice_private));\n\t\tdev->udid = strdup(muxdev.udid);\n\t\tdev->conn_type = CONNECTION_USBMUXD;\n\t\tdev->conn_data = (void*)(long)muxdev.handle;\n\t\t*device = dev;\n\t\treturn IDEVICE_E_SUCCESS;\n\t}\n\t/* other connection types could follow here */\n\n\treturn IDEVICE_E_NO_DEVICE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_free",
          "args": [
            "pl"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"ERROR: could not extract embedded plist from profile!\\n\""
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"ERROR: unexpected node type in profile plist (not PLIST_DICT)\\n\""
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_print_to_stream",
          "args": [
            "pl",
            "stdout"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "plist_print_to_stream",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/utils.c",
          "lines": "466-483",
          "snippet": "void plist_print_to_stream(plist_t plist, FILE* stream)\n{\n\tint indent = 0;\n\n\tif (!plist || !stream)\n\t\treturn;\n\n\tswitch (plist_get_node_type(plist)) {\n\tcase PLIST_DICT:\n\t\tplist_dict_print_to_stream(plist, &indent, stream);\n\t\tbreak;\n\tcase PLIST_ARRAY:\n\t\tplist_array_print_to_stream(plist, &indent, stream);\n\t\tbreak;\n\tdefault:\n\t\tplist_node_print_to_stream(plist, &indent, stream);\n\t}\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include <ctype.h>",
            "#include <inttypes.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void plist_node_print_to_stream(plist_t node, int* indent_level, FILE* stream);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include <ctype.h>\n#include <inttypes.h>\n#include <sys/time.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic void plist_node_print_to_stream(plist_t node, int* indent_level, FILE* stream);\n\nvoid plist_print_to_stream(plist_t plist, FILE* stream)\n{\n\tint indent = 0;\n\n\tif (!plist || !stream)\n\t\treturn;\n\n\tswitch (plist_get_node_type(plist)) {\n\tcase PLIST_DICT:\n\t\tplist_dict_print_to_stream(plist, &indent, stream);\n\t\tbreak;\n\tcase PLIST_ARRAY:\n\t\tplist_array_print_to_stream(plist, &indent, stream);\n\t\tbreak;\n\tdefault:\n\t\tplist_node_print_to_stream(plist, &indent, stream);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_get_node_type",
          "args": [
            "pl"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_to_xml",
          "args": [
            "pl",
            "&xml",
            "&xlen"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_free",
          "args": [
            "pdata"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_data",
          "args": [
            "(char*)profile_data",
            "profile_size"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_usage",
          "args": [
            "argc",
            "argv"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "print_usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/ideviceprovision.c",
          "lines": "42-66",
          "snippet": "static void print_usage(int argc, char **argv)\n{\n\tchar *name = NULL;\n\n\tname = strrchr(argv[0], '/');\n\tprintf(\"Usage: %s [OPTIONS] COMMAND\\n\", (name ? name + 1: argv[0]));\n\tprintf(\"Manage provisioning profiles on a device.\\n\\n\");\n\tprintf(\" Where COMMAND is one of:\\n\");\n\tprintf(\"  install FILE\\tInstalls the provisioning profile specified by FILE.\\n\");\n\tprintf(\"              \\tA valid .mobileprovision file is expected.\\n\");\n\tprintf(\"  list\\t\\tGet a list of all provisioning profiles on the device.\\n\");\n\tprintf(\"  copy PATH\\tRetrieves all provisioning profiles from the device and\\n\");\n\tprintf(\"           \\tstores them into the existing directory specified by PATH.\\n\");\n\tprintf(\"           \\tThe files will be stored as UUID.mobileprovision\\n\");\n\tprintf(\"  remove UUID\\tRemoves the provisioning profile identified by UUID.\\n\");\n\tprintf(\"  dump FILE\\tPrints detailed information about the provisioning profile\\n\");\n\tprintf(\"           \\tspecified by FILE.\\n\\n\");\n\tprintf(\" The following OPTIONS are accepted:\\n\");\n\tprintf(\"  -d, --debug      enable communication debugging\\n\");\n\tprintf(\"  -u, --udid UDID  target specific device by its 40-digit device UDID\\n\");\n\tprintf(\"  -x, --xml        print XML output when using the 'dump' command\\n\");\n\tprintf(\"  -h, --help       prints usage information\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"Homepage: <\" PACKAGE_URL \">\\n\");\n}",
          "includes": [
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/misagent.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <arpa/inet.h>",
            "#include <windows.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/utils.h\"\n#include <libimobiledevice/misagent.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <arpa/inet.h>\n#include <windows.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void print_usage(int argc, char **argv)\n{\n\tchar *name = NULL;\n\n\tname = strrchr(argv[0], '/');\n\tprintf(\"Usage: %s [OPTIONS] COMMAND\\n\", (name ? name + 1: argv[0]));\n\tprintf(\"Manage provisioning profiles on a device.\\n\\n\");\n\tprintf(\" Where COMMAND is one of:\\n\");\n\tprintf(\"  install FILE\\tInstalls the provisioning profile specified by FILE.\\n\");\n\tprintf(\"              \\tA valid .mobileprovision file is expected.\\n\");\n\tprintf(\"  list\\t\\tGet a list of all provisioning profiles on the device.\\n\");\n\tprintf(\"  copy PATH\\tRetrieves all provisioning profiles from the device and\\n\");\n\tprintf(\"           \\tstores them into the existing directory specified by PATH.\\n\");\n\tprintf(\"           \\tThe files will be stored as UUID.mobileprovision\\n\");\n\tprintf(\"  remove UUID\\tRemoves the provisioning profile identified by UUID.\\n\");\n\tprintf(\"  dump FILE\\tPrints detailed information about the provisioning profile\\n\");\n\tprintf(\"           \\tspecified by FILE.\\n\\n\");\n\tprintf(\" The following OPTIONS are accepted:\\n\");\n\tprintf(\"  -d, --debug      enable communication debugging\\n\");\n\tprintf(\"  -u, --udid UDID  target specific device by its 40-digit device UDID\\n\");\n\tprintf(\"  -x, --xml        print XML output when using the 'dump' command\\n\");\n\tprintf(\"  -h, --help       prints usage information\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"Homepage: <\" PACKAGE_URL \">\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"--help\""
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "plist_strcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
          "lines": "296-309",
          "snippet": "static int plist_strcmp(plist_t node, const char *str)\n{\n\tchar *buffer = NULL;\n\tint ret = 0;\n\n\tif (plist_get_node_type(node) != PLIST_STRING)\n\t\treturn ret;\n\n\tplist_get_string_val(node, &buffer);\n\tret = strcmp(buffer, str);\n\tfree(buffer);\n\n\treturn ret;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <unistd.h>",
            "#include <gcrypt.h>",
            "#include <openssl/sha.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int plist_strcmp(plist_t node, const char *str)\n{\n\tchar *buffer = NULL;\n\tint ret = 0;\n\n\tif (plist_get_node_type(node) != PLIST_STRING)\n\t\treturn ret;\n\n\tplist_get_string_val(node, &buffer);\n\tret = strcmp(buffer, str);\n\tfree(buffer);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "argv[i]"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "argv[i]"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "argv[i]"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "argv[i]"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "argv[i]"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idevice_set_debug_level",
          "args": [
            "1"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "idevice_set_debug_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
          "lines": "225-228",
          "snippet": "LIBIMOBILEDEVICE_API void idevice_set_debug_level(int level)\n{\n\tinternal_set_debug_level(level);\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"common/thread.h\"",
            "#include \"common/userpref.h\"",
            "#include \"idevice.h\"",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <usbmuxd.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API void idevice_set_debug_level(int level)\n{\n\tinternal_set_debug_level(level);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common/utils.h\"\n#include <libimobiledevice/misagent.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <arpa/inet.h>\n#include <windows.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nint main(int argc, char *argv[])\n{\n\tlockdownd_client_t client = NULL;\n\tlockdownd_error_t ldret = LOCKDOWN_E_UNKNOWN_ERROR;\n\tlockdownd_service_descriptor_t service = NULL;\n\tidevice_t device = NULL;\n\tidevice_error_t ret = IDEVICE_E_UNKNOWN_ERROR;\n\tint i;\n\tint op = -1;\n\tint output_xml = 0;\n\tconst char* udid = NULL;\n\tconst char* param = NULL;\n\n\t/* parse cmdline args */\n\tfor (i = 1; i < argc; i++) {\n\t\tif (!strcmp(argv[i], \"-d\") || !strcmp(argv[i], \"--debug\")) {\n\t\t\tidevice_set_debug_level(1);\n\t\t\tcontinue;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"-u\") || !strcmp(argv[i], \"--udid\")) {\n\t\t\ti++;\n\t\t\tif (!argv[i] || (strlen(argv[i]) != 40)) {\n\t\t\t\tprint_usage(argc, argv);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tudid = argv[i];\n\t\t\tcontinue;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"install\")) {\n\t\t\ti++;\n\t\t\tif (!argv[i] || (strlen(argv[i]) < 1)) {\n\t\t\t\tprint_usage(argc, argv);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tparam = argv[i];\n\t\t\top = OP_INSTALL;\n\t\t\tcontinue;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"list\")) {\n\t\t\top = OP_LIST;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"copy\")) {\n\t\t\ti++;\n\t\t\tif (!argv[i] || (strlen(argv[i]) < 1)) {\n\t\t\t\tprint_usage(argc, argv);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tparam = argv[i];\n\t\t\top = OP_COPY;\n\t\t\tcontinue;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"remove\")) {\n\t\t\ti++;\n\t\t\tif (!argv[i] || (strlen(argv[i]) < 1)) {\n\t\t\t\tprint_usage(argc, argv);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tparam = argv[i];\n\t\t\top = OP_REMOVE;\n\t\t\tcontinue;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"dump\")) {\n\t\t\ti++;\n\t\t\tif (!argv[i] || (strlen(argv[i]) < 1)) {\n\t\t\t\tprint_usage(argc, argv);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tparam = argv[i];\n\t\t\top = OP_DUMP;\n\t\t\tcontinue;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"-x\") || !strcmp(argv[i], \"--xml\")) {\n\t\t\toutput_xml = 1;\n\t\t\tcontinue;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"-h\") || !strcmp(argv[i], \"--help\")) {\n\t\t\tprint_usage(argc, argv);\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\tprint_usage(argc, argv);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif ((op == -1) || (op >= NUM_OPS)) {\n\t\tprint_usage(argc, argv);\n\t\treturn 0;\n\t}\n\n\tif (op == OP_DUMP) {\n\t\tint res = 0;\n\t\tunsigned char* profile_data = NULL;\n\t\tunsigned int profile_size = 0;\n\t\tif (profile_read_from_file(param, &profile_data, &profile_size) != 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tplist_t pdata = plist_new_data((char*)profile_data, profile_size);\n\t\tplist_t pl = profile_get_embedded_plist(pdata);\n\t\tplist_free(pdata);\n\t\tfree(profile_data);\n\n\t\tif (pl) {\n\t\t\tif (output_xml) {\n\t\t\t\tchar* xml = NULL;\n\t\t\t\tuint32_t xlen = 0;\n\t\t\t\tplist_to_xml(pl, &xml, &xlen);\n\t\t\t\tif (xml) {\n\t\t\t\t\tprintf(\"%s\\n\", xml);\n\t\t\t\t\tfree(xml);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (pl && (plist_get_node_type(pl) == PLIST_DICT)) {\n\t\t\t\t\tplist_print_to_stream(pl, stdout);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"ERROR: unexpected node type in profile plist (not PLIST_DICT)\\n\");\n\t\t\t\t\tres = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfprintf(stderr, \"ERROR: could not extract embedded plist from profile!\\n\");\n\t\t}\n\t\tplist_free(pl);\n\n\t\treturn res;\n\t}\n\n\tret = idevice_new(&device, udid);\n\tif (ret != IDEVICE_E_SUCCESS) {\n\t\tif (udid) {\n\t\t\tprintf(\"No device found with udid %s, is it plugged in?\\n\", udid);\n\t\t} else {\n\t\t\tprintf(\"No device found, is it plugged in?\\n\");\n\t\t}\n\t\treturn -1;\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS != (ldret = lockdownd_client_new_with_handshake(device, &client, \"ideviceprovision\"))) {\n\t\tfprintf(stderr, \"ERROR: Could not connect to lockdownd, error code %d\\n\", ldret);\n\t\tidevice_free(device);\n\t\treturn -1;\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS != lockdownd_start_service(client, \"com.apple.misagent\", &service)) {\n\t\tfprintf(stderr, \"Could not start service \\\"com.apple.misagent\\\"\\n\");\n\t\tlockdownd_client_free(client);\n\t\tidevice_free(device);\n\t\treturn -1;\n\t}\n\tlockdownd_client_free(client);\n\tclient = NULL;\n\n\tmisagent_client_t mis = NULL;\n\tif (misagent_client_new(device, service, &mis) != MISAGENT_E_SUCCESS) {\n\t\tfprintf(stderr, \"Could not connect to \\\"com.apple.misagent\\\" on device\\n\");\n\t\tif (service)\n\t\t\tlockdownd_service_descriptor_free(service);\n\t\tlockdownd_client_free(client);\n\t\tidevice_free(device);\n\t\treturn -1;\n\t}\n\n\tif (service)\n\t\tlockdownd_service_descriptor_free(service);\n\n\tswitch (op) {\n\t\tcase OP_INSTALL:\n\t\t{\n\t\t\tunsigned char* profile_data = NULL;\n\t\t\tunsigned int profile_size = 0;\n\t\t\tif (profile_read_from_file(param, &profile_data, &profile_size) != 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tuint64_t psize = profile_size;\n\t\t\tplist_t pdata = plist_new_data((const char*)profile_data, psize);\n\t\t\tfree(profile_data);\n\n\t\t\tif (misagent_install(mis, pdata) == MISAGENT_E_SUCCESS) {\n\t\t\t\tprintf(\"Profile '%s' installed successfully.\\n\", param);\n\t\t\t} else {\n\t\t\t\tint sc = misagent_get_status_code(mis);\n\t\t\t\tfprintf(stderr, \"Could not install profile '%s', status code: 0x%x\\n\", param, sc);\n\t\t\t}\n\t\t}\n\t\t\tbreak;\n\t\tcase OP_LIST:\n\t\tcase OP_COPY:\n\t\t{\n\t\t\tplist_t profiles = NULL;\n\t\t\tif (misagent_copy(mis, &profiles) == MISAGENT_E_SUCCESS) {\n\t\t\t\tuint32_t num_profiles = plist_array_get_size(profiles);\n\t\t\t\tprintf(\"Device has %d provisioning %s installed:\\n\", num_profiles, (num_profiles == 1) ? \"profile\" : \"profiles\");\n\t\t\t\tuint32_t j;\n\t\t\t\tfor (j = 0; j < num_profiles; j++) {\n\t\t\t\t\tchar* p_name = NULL;\n\t\t\t\t\tchar* p_uuid = NULL;\n\t\t\t\t\tplist_t profile = plist_array_get_item(profiles, j);\n\t\t\t\t\tplist_t pl = profile_get_embedded_plist(profile);\n\t\t\t\t\tif (pl && (plist_get_node_type(pl) == PLIST_DICT)) {\n\t\t\t\t\t\tplist_t node;\n\t\t\t\t\t\tnode = plist_dict_get_item(pl, \"Name\");\n\t\t\t\t\t\tif (node && (plist_get_node_type(node) == PLIST_STRING)) {\n\t\t\t\t\t\t\tplist_get_string_val(node, &p_name);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnode = plist_dict_get_item(pl, \"UUID\");\n\t\t\t\t\t\tif (node && (plist_get_node_type(node) == PLIST_STRING)) {\n\t\t\t\t\t\t\tplist_get_string_val(node, &p_uuid);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tprintf(\"%s - %s\\n\", (p_uuid) ? p_uuid : \"(unknown id)\", (p_name) ? p_name : \"(no name)\");\n\t\t\t\t\tif (op == OP_COPY) {\n\t\t\t\t\t\tchar pfname[512];\n\t\t\t\t\t\tif (p_uuid) {\n\t\t\t\t\t\t\tsprintf(pfname, \"%s/%s.mobileprovision\", param, p_uuid);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsprintf(pfname, \"%s/profile%d.mobileprovision\", param, j);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tFILE* f = fopen(pfname, \"wb\");\n\t\t\t\t\t\tif (f) {\n\t\t\t\t\t\t\tchar* dt = NULL;\n\t\t\t\t\t\t\tuint64_t ds = 0;\n\t\t\t\t\t\t\tplist_get_data_val(profile, &dt, &ds);\n\t\t\t\t\t\t\tfwrite(dt, 1, ds, f);\n\t\t\t\t\t\t\tfclose(f);\n\t\t\t\t\t\t\tprintf(\" => %s\\n\", pfname);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfprintf(stderr, \"Could not open '%s' for writing\\n\", pfname);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (p_uuid) {\n\t\t\t\t\t\tfree(p_uuid);\n\t\t\t\t\t}\n\t\t\t\t\tif (p_name) {\n\t\t\t\t\t\tfree(p_name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint sc = misagent_get_status_code(mis);\n\t\t\t\tfprintf(stderr, \"Could not get installed profiles from device, status code: 0x%x\\n\", sc);\n\t\t\t}\n\t\t}\n\t\t\tbreak;\n\t\tcase OP_REMOVE:\n\t\t\tif (misagent_remove(mis, param) == MISAGENT_E_SUCCESS) {\n\t\t\t\tprintf(\"Profile '%s' removed.\\n\", param);\n\t\t\t} else {\n\t\t\t\tint sc = misagent_get_status_code(mis);\n\t\t\t\tfprintf(stderr, \"Could not remove profile '%s', status code 0x%x\\n\", param, sc);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\tmisagent_client_free(mis);\n\n\tidevice_free(device);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "profile_read_from_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/ideviceprovision.c",
    "lines": "204-248",
    "snippet": "static int profile_read_from_file(const char* path, unsigned char **profile_data, unsigned int *profile_size)\n{\n\tFILE* f = fopen(path, \"rb\");\n\tif (!f) {\n\t\tfprintf(stderr, \"Could not open file '%s'\\n\", path);\n\t\treturn -1;\n\t}\n\tfseek(f, 0, SEEK_END);\n\tlong int size = ftell(f);\n\tfseek(f, 0, SEEK_SET);\n\n\tif (size >= 0x1000000) {\n\t\tfprintf(stderr, \"The file '%s' is too large for processing.\\n\", path);\n\t\tfclose(f);\n\t\treturn -1;\n\t}\n\n\tunsigned char* buf = malloc(size);\n\tif (!buf) {\n\t\tfprintf(stderr, \"Could not allocate memory...\\n\");\n\t\tfclose(f);\n\t\treturn -1;\n\t}\n\n\tlong int cur = 0;\n\twhile (cur < size) {\n\t\tssize_t r = fread(buf+cur, 1, 512, f);\n\t\tif (r <= 0) {\n\t\t\tbreak;\n\t\t}\n\t\tcur += r;\n\t}\n\tfclose(f);\n\n\tif (cur != size) {\n\t\tfree(buf);\n\t\tfprintf(stderr, \"Could not read in file '%s' (size %ld read %ld)\\n\", path, size, cur);\n\t\treturn -1;\n\t}\n\n\t*profile_data = buf;\n\t*profile_size = (unsigned int)size;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"common/utils.h\"",
      "#include <libimobiledevice/misagent.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <arpa/inet.h>",
      "#include <windows.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Could not read in file '%s' (size %ld read %ld)\\n\"",
            "path",
            "size",
            "cur"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "buf"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "thread_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "39-44",
          "snippet": "void thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nvoid thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fread",
          "args": [
            "buf+cur",
            "1",
            "512",
            "f"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Could not allocate memory...\\n\""
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "size"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"The file '%s' is too large for processing.\\n\"",
            "path"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fseek",
          "args": [
            "f",
            "0",
            "SEEK_SET"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftell",
          "args": [
            "f"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fseek",
          "args": [
            "f",
            "0",
            "SEEK_END"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Could not open file '%s'\\n\"",
            "path"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "path",
            "\"rb\""
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common/utils.h\"\n#include <libimobiledevice/misagent.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <arpa/inet.h>\n#include <windows.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int profile_read_from_file(const char* path, unsigned char **profile_data, unsigned int *profile_size)\n{\n\tFILE* f = fopen(path, \"rb\");\n\tif (!f) {\n\t\tfprintf(stderr, \"Could not open file '%s'\\n\", path);\n\t\treturn -1;\n\t}\n\tfseek(f, 0, SEEK_END);\n\tlong int size = ftell(f);\n\tfseek(f, 0, SEEK_SET);\n\n\tif (size >= 0x1000000) {\n\t\tfprintf(stderr, \"The file '%s' is too large for processing.\\n\", path);\n\t\tfclose(f);\n\t\treturn -1;\n\t}\n\n\tunsigned char* buf = malloc(size);\n\tif (!buf) {\n\t\tfprintf(stderr, \"Could not allocate memory...\\n\");\n\t\tfclose(f);\n\t\treturn -1;\n\t}\n\n\tlong int cur = 0;\n\twhile (cur < size) {\n\t\tssize_t r = fread(buf+cur, 1, 512, f);\n\t\tif (r <= 0) {\n\t\t\tbreak;\n\t\t}\n\t\tcur += r;\n\t}\n\tfclose(f);\n\n\tif (cur != size) {\n\t\tfree(buf);\n\t\tfprintf(stderr, \"Could not read in file '%s' (size %ld read %ld)\\n\", path, size, cur);\n\t\treturn -1;\n\t}\n\n\t*profile_data = buf;\n\t*profile_size = (unsigned int)size;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "profile_get_embedded_plist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/ideviceprovision.c",
    "lines": "112-202",
    "snippet": "static plist_t profile_get_embedded_plist(plist_t profile)\n{\n\tif (plist_get_node_type(profile) != PLIST_DATA) {\n\t\tfprintf(stderr, \"%s: unexpected plist node type for profile (PLIST_DATA expected)\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tchar* bbuf = NULL;\n\tuint64_t blen = 0;\n\tplist_get_data_val(profile, &bbuf, &blen);\n\tif (!bbuf) {\n\t\tfprintf(stderr, \"%s: could not get data value from plist node\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tunsigned char* pp = (unsigned char*)bbuf;\n\n\tif (*pp != ASN1_SEQUENCE) {\n\t\tfree(bbuf);\n\t\tfprintf(stderr, \"%s: unexpected profile data (0)\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tuint16_t slen = asn1_item_get_size(pp);\n\tif (slen+4 != (uint16_t)blen) {\n\t\tfree(bbuf);\n\t\tfprintf(stderr, \"%s: unexpected profile data (1)\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tasn1_next_item(&pp);\n\n\tif (*pp != ASN1_OBJECT_IDENTIFIER) {\n\t\tfree(bbuf);\n\t\tfprintf(stderr, \"%s: unexpected profile data (2)\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tasn1_skip_item(&pp);\n\n\tif (*pp != ASN1_CONTAINER) {\n\t\tfree(bbuf);\n\t\tfprintf(stderr, \"%s: unexpected profile data (3)\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tasn1_next_item(&pp);\n\n\tif (*pp != ASN1_SEQUENCE) {\n\t\tfree(bbuf);\n\t\tfprintf(stderr, \"%s: unexpected profile data (4)\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tasn1_next_item(&pp);\n\n\tint k = 0;\n\t// go to the 3rd element (skip 2)\n\twhile (k < 2) {\n\t\tasn1_skip_item(&pp);\n\t\tk++;\n\t}\n\tif (*pp != ASN1_SEQUENCE) {\n\t\tfree(bbuf);\n\t\tfprintf(stderr, \"%s: unexpected profile data (5)\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tasn1_next_item(&pp);\n\n\tif (*pp != ASN1_OBJECT_IDENTIFIER) {\n\t\tfree(bbuf);\n\t\tfprintf(stderr, \"%s: unexpected profile data (6)\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tasn1_skip_item(&pp);\n\n\tif (*pp != ASN1_CONTAINER) {\n\t\tfree(bbuf);\n\t\tfprintf(stderr, \"%s: unexpected profile data (7)\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tasn1_next_item(&pp);\n\n\tif (*pp != ASN1_OCTET_STRING) {\n\t\tfree(bbuf);\n\t\tfprintf(stderr, \"%s: unexpected profile data (8)\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tslen = asn1_item_get_size(pp);\n\tasn1_next_item(&pp);\n\n\tplist_t pl = NULL;\n\tplist_from_xml((char*)pp, slen, &pl);\n\tfree(bbuf);\n\n\treturn pl;\n}",
    "includes": [
      "#include \"common/utils.h\"",
      "#include <libimobiledevice/misagent.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <arpa/inet.h>",
      "#include <windows.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define ASN1_OCTET_STRING 0x04",
      "#define ASN1_OBJECT_IDENTIFIER 0x06",
      "#define ASN1_CONTAINER 0xA0",
      "#define ASN1_SEQUENCE 0x30"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "bbuf"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "thread_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "39-44",
          "snippet": "void thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nvoid thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_from_xml",
          "args": [
            "(char*)pp",
            "slen",
            "&pl"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asn1_next_item",
          "args": [
            "&pp"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "asn1_next_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/ideviceprovision.c",
          "lines": "82-89",
          "snippet": "static void asn1_next_item(unsigned char** p)\n{\n\tif (*(*p+1) & 0x80) {\n\t\t*p += 4;\n\t} else {\n\t\t*p += 3;\n\t}\n}",
          "includes": [
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/misagent.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <arpa/inet.h>",
            "#include <windows.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/utils.h\"\n#include <libimobiledevice/misagent.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <arpa/inet.h>\n#include <windows.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void asn1_next_item(unsigned char** p)\n{\n\tif (*(*p+1) & 0x80) {\n\t\t*p += 4;\n\t} else {\n\t\t*p += 3;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "asn1_item_get_size",
          "args": [
            "pp"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "asn1_item_get_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/ideviceprovision.c",
          "lines": "91-103",
          "snippet": "static int asn1_item_get_size(unsigned char* p)\n{\n\tint res = 0;\n\tif (*(p+1) & 0x80) {\n\t\tuint16_t ws = 0;\n\t\tmemcpy(&ws, p+2, 2);\n\t\tws = ntohs(ws);\n\t\tres = ws;\n\t} else {\n\t\tres = (int) *(p+1);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/misagent.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <arpa/inet.h>",
            "#include <windows.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/utils.h\"\n#include <libimobiledevice/misagent.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <arpa/inet.h>\n#include <windows.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int asn1_item_get_size(unsigned char* p)\n{\n\tint res = 0;\n\tif (*(p+1) & 0x80) {\n\t\tuint16_t ws = 0;\n\t\tmemcpy(&ws, p+2, 2);\n\t\tws = ntohs(ws);\n\t\tres = ws;\n\t} else {\n\t\tres = (int) *(p+1);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: unexpected profile data (8)\\n\"",
            "__func__"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: unexpected profile data (7)\\n\"",
            "__func__"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asn1_skip_item",
          "args": [
            "&pp"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "asn1_skip_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/ideviceprovision.c",
          "lines": "105-110",
          "snippet": "static void asn1_skip_item(unsigned char** p)\n{\n\tint sz = asn1_item_get_size(*p);\n\t*p += 2;\n\t*p += sz;\n}",
          "includes": [
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/misagent.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <arpa/inet.h>",
            "#include <windows.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/utils.h\"\n#include <libimobiledevice/misagent.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <arpa/inet.h>\n#include <windows.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void asn1_skip_item(unsigned char** p)\n{\n\tint sz = asn1_item_get_size(*p);\n\t*p += 2;\n\t*p += sz;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: unexpected profile data (6)\\n\"",
            "__func__"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: unexpected profile data (5)\\n\"",
            "__func__"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: unexpected profile data (4)\\n\"",
            "__func__"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: unexpected profile data (3)\\n\"",
            "__func__"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: unexpected profile data (2)\\n\"",
            "__func__"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: unexpected profile data (1)\\n\"",
            "__func__"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: unexpected profile data (0)\\n\"",
            "__func__"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: could not get data value from plist node\\n\"",
            "__func__"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_data_val",
          "args": [
            "profile",
            "&bbuf",
            "&blen"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: unexpected plist node type for profile (PLIST_DATA expected)\\n\"",
            "__func__"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_node_type",
          "args": [
            "profile"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common/utils.h\"\n#include <libimobiledevice/misagent.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <arpa/inet.h>\n#include <windows.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\n#define ASN1_OCTET_STRING 0x04\n#define ASN1_OBJECT_IDENTIFIER 0x06\n#define ASN1_CONTAINER 0xA0\n#define ASN1_SEQUENCE 0x30\n\nstatic plist_t profile_get_embedded_plist(plist_t profile)\n{\n\tif (plist_get_node_type(profile) != PLIST_DATA) {\n\t\tfprintf(stderr, \"%s: unexpected plist node type for profile (PLIST_DATA expected)\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tchar* bbuf = NULL;\n\tuint64_t blen = 0;\n\tplist_get_data_val(profile, &bbuf, &blen);\n\tif (!bbuf) {\n\t\tfprintf(stderr, \"%s: could not get data value from plist node\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tunsigned char* pp = (unsigned char*)bbuf;\n\n\tif (*pp != ASN1_SEQUENCE) {\n\t\tfree(bbuf);\n\t\tfprintf(stderr, \"%s: unexpected profile data (0)\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tuint16_t slen = asn1_item_get_size(pp);\n\tif (slen+4 != (uint16_t)blen) {\n\t\tfree(bbuf);\n\t\tfprintf(stderr, \"%s: unexpected profile data (1)\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tasn1_next_item(&pp);\n\n\tif (*pp != ASN1_OBJECT_IDENTIFIER) {\n\t\tfree(bbuf);\n\t\tfprintf(stderr, \"%s: unexpected profile data (2)\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tasn1_skip_item(&pp);\n\n\tif (*pp != ASN1_CONTAINER) {\n\t\tfree(bbuf);\n\t\tfprintf(stderr, \"%s: unexpected profile data (3)\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tasn1_next_item(&pp);\n\n\tif (*pp != ASN1_SEQUENCE) {\n\t\tfree(bbuf);\n\t\tfprintf(stderr, \"%s: unexpected profile data (4)\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tasn1_next_item(&pp);\n\n\tint k = 0;\n\t// go to the 3rd element (skip 2)\n\twhile (k < 2) {\n\t\tasn1_skip_item(&pp);\n\t\tk++;\n\t}\n\tif (*pp != ASN1_SEQUENCE) {\n\t\tfree(bbuf);\n\t\tfprintf(stderr, \"%s: unexpected profile data (5)\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tasn1_next_item(&pp);\n\n\tif (*pp != ASN1_OBJECT_IDENTIFIER) {\n\t\tfree(bbuf);\n\t\tfprintf(stderr, \"%s: unexpected profile data (6)\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tasn1_skip_item(&pp);\n\n\tif (*pp != ASN1_CONTAINER) {\n\t\tfree(bbuf);\n\t\tfprintf(stderr, \"%s: unexpected profile data (7)\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tasn1_next_item(&pp);\n\n\tif (*pp != ASN1_OCTET_STRING) {\n\t\tfree(bbuf);\n\t\tfprintf(stderr, \"%s: unexpected profile data (8)\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tslen = asn1_item_get_size(pp);\n\tasn1_next_item(&pp);\n\n\tplist_t pl = NULL;\n\tplist_from_xml((char*)pp, slen, &pl);\n\tfree(bbuf);\n\n\treturn pl;\n}"
  },
  {
    "function_name": "asn1_skip_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/ideviceprovision.c",
    "lines": "105-110",
    "snippet": "static void asn1_skip_item(unsigned char** p)\n{\n\tint sz = asn1_item_get_size(*p);\n\t*p += 2;\n\t*p += sz;\n}",
    "includes": [
      "#include \"common/utils.h\"",
      "#include <libimobiledevice/misagent.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <arpa/inet.h>",
      "#include <windows.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "asn1_item_get_size",
          "args": [
            "*p"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "asn1_item_get_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/ideviceprovision.c",
          "lines": "91-103",
          "snippet": "static int asn1_item_get_size(unsigned char* p)\n{\n\tint res = 0;\n\tif (*(p+1) & 0x80) {\n\t\tuint16_t ws = 0;\n\t\tmemcpy(&ws, p+2, 2);\n\t\tws = ntohs(ws);\n\t\tres = ws;\n\t} else {\n\t\tres = (int) *(p+1);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/misagent.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <arpa/inet.h>",
            "#include <windows.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/utils.h\"\n#include <libimobiledevice/misagent.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <arpa/inet.h>\n#include <windows.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int asn1_item_get_size(unsigned char* p)\n{\n\tint res = 0;\n\tif (*(p+1) & 0x80) {\n\t\tuint16_t ws = 0;\n\t\tmemcpy(&ws, p+2, 2);\n\t\tws = ntohs(ws);\n\t\tres = ws;\n\t} else {\n\t\tres = (int) *(p+1);\n\t}\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common/utils.h\"\n#include <libimobiledevice/misagent.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <arpa/inet.h>\n#include <windows.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void asn1_skip_item(unsigned char** p)\n{\n\tint sz = asn1_item_get_size(*p);\n\t*p += 2;\n\t*p += sz;\n}"
  },
  {
    "function_name": "asn1_item_get_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/ideviceprovision.c",
    "lines": "91-103",
    "snippet": "static int asn1_item_get_size(unsigned char* p)\n{\n\tint res = 0;\n\tif (*(p+1) & 0x80) {\n\t\tuint16_t ws = 0;\n\t\tmemcpy(&ws, p+2, 2);\n\t\tws = ntohs(ws);\n\t\tres = ws;\n\t} else {\n\t\tres = (int) *(p+1);\n\t}\n\treturn res;\n}",
    "includes": [
      "#include \"common/utils.h\"",
      "#include <libimobiledevice/misagent.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <arpa/inet.h>",
      "#include <windows.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "ws"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&ws",
            "p+2",
            "2"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common/utils.h\"\n#include <libimobiledevice/misagent.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <arpa/inet.h>\n#include <windows.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int asn1_item_get_size(unsigned char* p)\n{\n\tint res = 0;\n\tif (*(p+1) & 0x80) {\n\t\tuint16_t ws = 0;\n\t\tmemcpy(&ws, p+2, 2);\n\t\tws = ntohs(ws);\n\t\tres = ws;\n\t} else {\n\t\tres = (int) *(p+1);\n\t}\n\treturn res;\n}"
  },
  {
    "function_name": "asn1_next_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/ideviceprovision.c",
    "lines": "82-89",
    "snippet": "static void asn1_next_item(unsigned char** p)\n{\n\tif (*(*p+1) & 0x80) {\n\t\t*p += 4;\n\t} else {\n\t\t*p += 3;\n\t}\n}",
    "includes": [
      "#include \"common/utils.h\"",
      "#include <libimobiledevice/misagent.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <arpa/inet.h>",
      "#include <windows.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"common/utils.h\"\n#include <libimobiledevice/misagent.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <arpa/inet.h>\n#include <windows.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void asn1_next_item(unsigned char** p)\n{\n\tif (*(*p+1) & 0x80) {\n\t\t*p += 4;\n\t} else {\n\t\t*p += 3;\n\t}\n}"
  },
  {
    "function_name": "print_usage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/ideviceprovision.c",
    "lines": "42-66",
    "snippet": "static void print_usage(int argc, char **argv)\n{\n\tchar *name = NULL;\n\n\tname = strrchr(argv[0], '/');\n\tprintf(\"Usage: %s [OPTIONS] COMMAND\\n\", (name ? name + 1: argv[0]));\n\tprintf(\"Manage provisioning profiles on a device.\\n\\n\");\n\tprintf(\" Where COMMAND is one of:\\n\");\n\tprintf(\"  install FILE\\tInstalls the provisioning profile specified by FILE.\\n\");\n\tprintf(\"              \\tA valid .mobileprovision file is expected.\\n\");\n\tprintf(\"  list\\t\\tGet a list of all provisioning profiles on the device.\\n\");\n\tprintf(\"  copy PATH\\tRetrieves all provisioning profiles from the device and\\n\");\n\tprintf(\"           \\tstores them into the existing directory specified by PATH.\\n\");\n\tprintf(\"           \\tThe files will be stored as UUID.mobileprovision\\n\");\n\tprintf(\"  remove UUID\\tRemoves the provisioning profile identified by UUID.\\n\");\n\tprintf(\"  dump FILE\\tPrints detailed information about the provisioning profile\\n\");\n\tprintf(\"           \\tspecified by FILE.\\n\\n\");\n\tprintf(\" The following OPTIONS are accepted:\\n\");\n\tprintf(\"  -d, --debug      enable communication debugging\\n\");\n\tprintf(\"  -u, --udid UDID  target specific device by its 40-digit device UDID\\n\");\n\tprintf(\"  -x, --xml        print XML output when using the 'dump' command\\n\");\n\tprintf(\"  -h, --help       prints usage information\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"Homepage: <\" PACKAGE_URL \">\\n\");\n}",
    "includes": [
      "#include \"common/utils.h\"",
      "#include <libimobiledevice/misagent.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <arpa/inet.h>",
      "#include <windows.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Homepage: <\" PACKAGE_URL \">\\n\""
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  -h, --help       prints usage information\\n\""
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  -x, --xml        print XML output when using the 'dump' command\\n\""
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  -u, --udid UDID  target specific device by its 40-digit device UDID\\n\""
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  -d, --debug      enable communication debugging\\n\""
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" The following OPTIONS are accepted:\\n\""
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"           \\tspecified by FILE.\\n\\n\""
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  dump FILE\\tPrints detailed information about the provisioning profile\\n\""
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  remove UUID\\tRemoves the provisioning profile identified by UUID.\\n\""
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"           \\tThe files will be stored as UUID.mobileprovision\\n\""
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"           \\tstores them into the existing directory specified by PATH.\\n\""
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  copy PATH\\tRetrieves all provisioning profiles from the device and\\n\""
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  list\\t\\tGet a list of all provisioning profiles on the device.\\n\""
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"              \\tA valid .mobileprovision file is expected.\\n\""
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  install FILE\\tInstalls the provisioning profile specified by FILE.\\n\""
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" Where COMMAND is one of:\\n\""
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Manage provisioning profiles on a device.\\n\\n\""
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Usage: %s [OPTIONS] COMMAND\\n\"",
            "(name ? name + 1: argv[0])"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "asprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/include/asprintf.h",
          "lines": "23-31",
          "snippet": "static inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}",
          "includes": [
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <config.h>\n\nstatic inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "argv[0]",
            "'/'"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common/utils.h\"\n#include <libimobiledevice/misagent.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <arpa/inet.h>\n#include <windows.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void print_usage(int argc, char **argv)\n{\n\tchar *name = NULL;\n\n\tname = strrchr(argv[0], '/');\n\tprintf(\"Usage: %s [OPTIONS] COMMAND\\n\", (name ? name + 1: argv[0]));\n\tprintf(\"Manage provisioning profiles on a device.\\n\\n\");\n\tprintf(\" Where COMMAND is one of:\\n\");\n\tprintf(\"  install FILE\\tInstalls the provisioning profile specified by FILE.\\n\");\n\tprintf(\"              \\tA valid .mobileprovision file is expected.\\n\");\n\tprintf(\"  list\\t\\tGet a list of all provisioning profiles on the device.\\n\");\n\tprintf(\"  copy PATH\\tRetrieves all provisioning profiles from the device and\\n\");\n\tprintf(\"           \\tstores them into the existing directory specified by PATH.\\n\");\n\tprintf(\"           \\tThe files will be stored as UUID.mobileprovision\\n\");\n\tprintf(\"  remove UUID\\tRemoves the provisioning profile identified by UUID.\\n\");\n\tprintf(\"  dump FILE\\tPrints detailed information about the provisioning profile\\n\");\n\tprintf(\"           \\tspecified by FILE.\\n\\n\");\n\tprintf(\" The following OPTIONS are accepted:\\n\");\n\tprintf(\"  -d, --debug      enable communication debugging\\n\");\n\tprintf(\"  -u, --udid UDID  target specific device by its 40-digit device UDID\\n\");\n\tprintf(\"  -x, --xml        print XML output when using the 'dump' command\\n\");\n\tprintf(\"  -h, --help       prints usage information\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"Homepage: <\" PACKAGE_URL \">\\n\");\n}"
  }
]