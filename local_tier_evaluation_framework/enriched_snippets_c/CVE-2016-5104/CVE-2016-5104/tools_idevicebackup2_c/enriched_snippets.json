[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
    "lines": "1149-2224",
    "snippet": "int main(int argc, char *argv[])\n{\n\tidevice_error_t ret = IDEVICE_E_UNKNOWN_ERROR;\n\tlockdownd_error_t ldret = LOCKDOWN_E_UNKNOWN_ERROR;\n\tint i;\n\tchar* udid = NULL;\n\tchar* source_udid = NULL;\n\tlockdownd_service_descriptor_t service = NULL;\n\tint cmd = -1;\n\tint cmd_flags = 0;\n\tint is_full_backup = 0;\n\tint result_code = -1;\n\tchar* backup_directory = NULL;\n\tint interactive_mode = 0;\n\tchar* backup_password = NULL;\n\tchar* newpw = NULL;\n\tstruct stat st;\n\tplist_t node_tmp = NULL;\n\tplist_t info_plist = NULL;\n\tplist_t opts = NULL;\n\tmobilebackup2_error_t err;\n\n\t/* we need to exit cleanly on running backups and restores or we cause havok */\n\tsignal(SIGINT, clean_exit);\n\tsignal(SIGTERM, clean_exit);\n#ifndef WIN32\n\tsignal(SIGQUIT, clean_exit);\n\tsignal(SIGPIPE, SIG_IGN);\n#endif\n\n\t/* parse cmdline args */\n\tfor (i = 1; i < argc; i++) {\n\t\tif (!strcmp(argv[i], \"-d\") || !strcmp(argv[i], \"--debug\")) {\n\t\t\tidevice_set_debug_level(1);\n\t\t\tcontinue;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"-u\") || !strcmp(argv[i], \"--udid\")) {\n\t\t\ti++;\n\t\t\tif (!argv[i] || (strlen(argv[i]) != 40)) {\n\t\t\t\tprint_usage(argc, argv);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tudid = strdup(argv[i]);\n\t\t\tcontinue;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"-s\") || !strcmp(argv[i], \"--source\")) {\n\t\t\ti++;\n\t\t\tif (!argv[i] || (strlen(argv[i]) != 40)) {\n\t\t\t\tprint_usage(argc, argv);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tsource_udid = strdup(argv[i]);\n\t\t\tcontinue;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"-i\") || !strcmp(argv[i], \"--interactive\")) {\n\t\t\tinteractive_mode = 1;\n\t\t\tcontinue;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"-h\") || !strcmp(argv[i], \"--help\")) {\n\t\t\tprint_usage(argc, argv);\n\t\t\treturn 0;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"backup\")) {\n\t\t\tcmd = CMD_BACKUP;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"restore\")) {\n\t\t\tcmd = CMD_RESTORE;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"--system\")) {\n\t\t\tcmd_flags |= CMD_FLAG_RESTORE_SYSTEM_FILES;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"--reboot\")) {\n\t\t\tcmd_flags |= CMD_FLAG_RESTORE_REBOOT;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"--copy\")) {\n\t\t\tcmd_flags |= CMD_FLAG_RESTORE_COPY_BACKUP;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"--settings\")) {\n\t\t\tcmd_flags |= CMD_FLAG_RESTORE_SETTINGS;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"--remove\")) {\n\t\t\tcmd_flags |= CMD_FLAG_RESTORE_REMOVE_ITEMS;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"--password\")) {\n\t\t\ti++;\n\t\t\tif (!argv[i]) {\n\t\t\t\tprint_usage(argc, argv);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (backup_password)\n\t\t\t\tfree(backup_password);\n\t\t\tbackup_password = strdup(argv[i]);\n\t\t\tcontinue;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"cloud\")) {\n\t\t\tcmd = CMD_CLOUD;\n\t\t\ti++;\n\t\t\tif (!argv[i]) {\n\t\t\t\tprintf(\"No argument given for cloud command; requires either 'on' or 'off'.\\n\");\n\t\t\t\tprint_usage(argc, argv);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (!strcmp(argv[i], \"on\")) {\n\t\t\t\tcmd_flags |= CMD_FLAG_CLOUD_ENABLE;\n\t\t\t} else if (!strcmp(argv[i], \"off\")) {\n\t\t\t\tcmd_flags |= CMD_FLAG_CLOUD_DISABLE;\n\t\t\t} else {\n\t\t\t\tprintf(\"Invalid argument '%s' for cloud command; must be either 'on' or 'off'.\\n\", argv[i]);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"--full\")) {\n\t\t\tcmd_flags |= CMD_FLAG_FORCE_FULL_BACKUP;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"info\")) {\n\t\t\tcmd = CMD_INFO;\n\t\t\tverbose = 0;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"list\")) {\n\t\t\tcmd = CMD_LIST;\n\t\t\tverbose = 0;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"unback\")) {\n\t\t\tcmd = CMD_UNBACK;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"encryption\")) {\n\t\t\tcmd = CMD_CHANGEPW;\n\t\t\ti++;\n\t\t\tif (!argv[i]) {\n\t\t\t\tprintf(\"No argument given for encryption command; requires either 'on' or 'off'.\\n\");\n\t\t\t\tprint_usage(argc, argv);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (!strcmp(argv[i], \"on\")) {\n\t\t\t\tcmd_flags |= CMD_FLAG_ENCRYPTION_ENABLE;\n\t\t\t} else if (!strcmp(argv[i], \"off\")) {\n\t\t\t\tcmd_flags |= CMD_FLAG_ENCRYPTION_DISABLE;\n\t\t\t} else {\n\t\t\t\tprintf(\"Invalid argument '%s' for encryption command; must be either 'on' or 'off'.\\n\", argv[i]);\n\t\t\t}\n\t\t\t// check if a password was given on the command line\n\t\t\tif (newpw) {\n\t\t\t\tfree(newpw);\n\t\t\t\tnewpw = NULL;\n\t\t\t}\n\t\t\tif (backup_password) {\n\t\t\t\tfree(backup_password);\n\t\t\t\tbackup_password = NULL;\n\t\t\t}\n\t\t\ti++;\n\t\t\tif (argv[i]) {\n\t\t\t\tif (cmd_flags & CMD_FLAG_ENCRYPTION_ENABLE) {\n\t\t\t\t\tnewpw = strdup(argv[i]);\n\t\t\t\t} else if (cmd_flags & CMD_FLAG_ENCRYPTION_DISABLE) {\n\t\t\t\t\tbackup_password = strdup(argv[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"changepw\")) {\n\t\t\tcmd = CMD_CHANGEPW;\n\t\t\tcmd_flags |= CMD_FLAG_ENCRYPTION_CHANGEPW;\n\t\t\t// check if passwords were given on command line\n\t\t\tif (newpw) {\n\t\t\t\tfree(newpw);\n\t\t\t\tnewpw = NULL;\n\t\t\t}\n\t\t\tif (backup_password) {\n\t\t\t\tfree(backup_password);\n\t\t\t\tbackup_password = NULL;\n\t\t\t}\n\t\t\ti++;\n\t\t\tif (argv[i]) {\n\t\t\t\tbackup_password = strdup(argv[i]);\n\t\t\t\ti++;\n\t\t\t\tif (!argv[i]) {\n\t\t\t\t\tprintf(\"Old and new passwords have to be passed as arguments for the changepw command\\n\");\n\t\t\t\t\tprint_usage(argc, argv);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tnewpw = strdup(argv[i]);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\telse if (backup_directory == NULL) {\n\t\t\tbackup_directory = argv[i];\n\t\t}\n\t\telse {\n\t\t\tprint_usage(argc, argv);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* verify options */\n\tif (cmd == -1) {\n\t\tprintf(\"No command specified.\\n\");\n\t\tprint_usage(argc, argv);\n\t\treturn -1;\n\t}\n\n\tif (cmd == CMD_CHANGEPW || cmd == CMD_CLOUD) {\n\t\tbackup_directory = (char*)\".this_folder_is_not_present_on_purpose\";\n\t} else {\n\t\tif (backup_directory == NULL) {\n\t\t\tprintf(\"No target backup directory specified.\\n\");\n\t\t\tprint_usage(argc, argv);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* verify if passed backup directory exists */\n\t\tif (stat(backup_directory, &st) != 0) {\n\t\t\tprintf(\"ERROR: Backup directory \\\"%s\\\" does not exist!\\n\", backup_directory);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tidevice_t device = NULL;\n\tif (udid) {\n\t\tret = idevice_new(&device, udid);\n\t\tif (ret != IDEVICE_E_SUCCESS) {\n\t\t\tprintf(\"No device found with udid %s, is it plugged in?\\n\", udid);\n\t\t\treturn -1;\n\t\t}\n\t}\n\telse\n\t{\n\t\tret = idevice_new(&device, NULL);\n\t\tif (ret != IDEVICE_E_SUCCESS) {\n\t\t\tprintf(\"No device found, is it plugged in?\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tidevice_get_udid(device, &udid);\n\t}\n\n\tif (!source_udid) {\n\t\tsource_udid = strdup(udid);\n\t}\n\n\tuint8_t is_encrypted = 0;\n\tchar *info_path = NULL;\n\tif (cmd == CMD_CHANGEPW) {\n\t\tif (!interactive_mode && !backup_password && !newpw) {\n\t\t\tidevice_free(device);\n\t\t\tprintf(\"ERROR: Can't get password input in non-interactive mode. Either pass password(s) on the command line, or enable interactive mode with -i or --interactive.\\n\");\n\t\t\treturn -1;\n\t\t}\n\t} else if (cmd != CMD_CLOUD) {\n\t\t/* backup directory must contain an Info.plist */\n\t\tinfo_path = string_build_path(backup_directory, source_udid, \"Info.plist\", NULL);\n\t\tif (cmd == CMD_RESTORE || cmd == CMD_UNBACK) {\n\t\t\tif (stat(info_path, &st) != 0) {\n\t\t\t\tidevice_free(device);\n\t\t\t\tfree(info_path);\n\t\t\t\tprintf(\"ERROR: Backup directory \\\"%s\\\" is invalid. No Info.plist found for UDID %s.\\n\", backup_directory, source_udid);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tchar* manifest_path = string_build_path(backup_directory, source_udid, \"Manifest.plist\", NULL);\n\t\t\tif (stat(manifest_path, &st) != 0) {\n\t\t\t\tfree(info_path);\n\t\t\t}\n\t\t\tplist_t manifest_plist = NULL;\n\t\t\tplist_read_from_filename(&manifest_plist, manifest_path);\n\t\t\tif (!manifest_plist) {\n\t\t\t\tidevice_free(device);\n\t\t\t\tfree(info_path);\n\t\t\t\tfree(manifest_path);\n\t\t\t\tprintf(\"ERROR: Backup directory \\\"%s\\\" is invalid. No Manifest.plist found for UDID %s.\\n\", backup_directory, source_udid);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tnode_tmp = plist_dict_get_item(manifest_plist, \"IsEncrypted\");\n\t\t\tif (node_tmp && (plist_get_node_type(node_tmp) == PLIST_BOOLEAN)) {\n\t\t\t\tplist_get_bool_val(node_tmp, &is_encrypted);\n\t\t\t}\n\t\t\tplist_free(manifest_plist);\n\t\t\tfree(manifest_path);\n\t\t}\n\t\tPRINT_VERBOSE(1, \"Backup directory is \\\"%s\\\"\\n\", backup_directory);\n\t}\n\n\tif (cmd != CMD_CLOUD && is_encrypted) {\n\t\tPRINT_VERBOSE(1, \"This is an encrypted backup.\\n\");\n\t\tif (backup_password == NULL) {\n\t\t\tif (interactive_mode) {\n\t\t\t\tbackup_password = ask_for_password(\"Enter backup password\", 0);\n\t\t\t}\n\t\t\tif (!backup_password || (strlen(backup_password) == 0)) {\n\t\t\t\tif (backup_password) {\n\t\t\t\t\tfree(backup_password);\n\t\t\t\t}\n\t\t\t\tidevice_free(device);\n\t\t\t\tif (cmd == CMD_RESTORE) {\n\t\t\t\t\tprintf(\"ERROR: a backup password is required to restore an encrypted backup. Cannot continue.\\n\");\n\t\t\t\t} else if (cmd == CMD_UNBACK) {\n\t\t\t\t\tprintf(\"ERROR: a backup password is required to unback an encrypted backup. Cannot continue.\\n\");\n\t\t\t\t}\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tlockdownd_client_t lockdown = NULL;\n\tif (LOCKDOWN_E_SUCCESS != (ldret = lockdownd_client_new_with_handshake(device, &lockdown, \"idevicebackup2\"))) {\n\t\tprintf(\"ERROR: Could not connect to lockdownd, error code %d\\n\", ldret);\n\t\tidevice_free(device);\n\t\treturn -1;\n\t}\n\n\t/* start notification_proxy */\n\tnp_client_t np = NULL;\n\tldret = lockdownd_start_service(lockdown, NP_SERVICE_NAME, &service);\n\tif ((ldret == LOCKDOWN_E_SUCCESS) && service && service->port) {\n\t\tnp_client_new(device, service, &np);\n\t\tnp_set_notify_callback(np, notify_cb, NULL);\n\t\tconst char *noties[5] = {\n\t\t\tNP_SYNC_CANCEL_REQUEST,\n\t\t\tNP_SYNC_SUSPEND_REQUEST,\n\t\t\tNP_SYNC_RESUME_REQUEST,\n\t\t\tNP_BACKUP_DOMAIN_CHANGED,\n\t\t\tNULL\n\t\t};\n\t\tnp_observe_notifications(np, noties);\n\t} else {\n\t\tprintf(\"ERROR: Could not start service %s.\\n\", NP_SERVICE_NAME);\n\t}\n\n\tafc_client_t afc = NULL;\n\tif (cmd == CMD_BACKUP) {\n\t\t/* start AFC, we need this for the lock file */\n\t\tservice->port = 0;\n\t\tservice->ssl_enabled = 0;\n\t\tldret = lockdownd_start_service(lockdown, AFC_SERVICE_NAME, &service);\n\t\tif ((ldret == LOCKDOWN_E_SUCCESS) && service->port) {\n\t\t\tafc_client_new(device, service, &afc);\n\t\t}\n\t}\n\n\tif (service) {\n\t\tlockdownd_service_descriptor_free(service);\n\t\tservice = NULL;\n\t}\n\n\t/* start mobilebackup service and retrieve port */\n\tmobilebackup2_client_t mobilebackup2 = NULL;\n\tldret = lockdownd_start_service_with_escrow_bag(lockdown, MOBILEBACKUP2_SERVICE_NAME, &service);\n\tif ((ldret == LOCKDOWN_E_SUCCESS) && service && service->port) {\n\t\tPRINT_VERBOSE(1, \"Started \\\"%s\\\" service on port %d.\\n\", MOBILEBACKUP2_SERVICE_NAME, service->port);\n\t\tmobilebackup2_client_new(device, service, &mobilebackup2);\n\n\t\tif (service) {\n\t\t\tlockdownd_service_descriptor_free(service);\n\t\t\tservice = NULL;\n\t\t}\n\n\t\t/* send Hello message */\n\t\tdouble local_versions[2] = {2.0, 2.1};\n\t\tdouble remote_version = 0.0;\n\t\terr = mobilebackup2_version_exchange(mobilebackup2, local_versions, 2, &remote_version);\n\t\tif (err != MOBILEBACKUP2_E_SUCCESS) {\n\t\t\tprintf(\"Could not perform backup protocol version exchange, error code %d\\n\", err);\n\t\t\tcmd = CMD_LEAVE;\n\t\t\tgoto checkpoint;\n\t\t}\n\n\t\tPRINT_VERBOSE(1, \"Negotiated Protocol Version %.1f\\n\", remote_version);\n\n\t\t/* check abort conditions */\n\t\tif (quit_flag > 0) {\n\t\t\tPRINT_VERBOSE(1, \"Aborting as requested by user...\\n\");\n\t\t\tcmd = CMD_LEAVE;\n\t\t\tgoto checkpoint;\n\t\t}\n\n\t\t/* verify existing Info.plist */\n\t\tif (info_path && (stat(info_path, &st) == 0) && cmd != CMD_CLOUD) {\n\t\t\tPRINT_VERBOSE(1, \"Reading Info.plist from backup.\\n\");\n\t\t\tplist_read_from_filename(&info_plist, info_path);\n\n\t\t\tif (!info_plist) {\n\t\t\t\tprintf(\"Could not read Info.plist\\n\");\n\t\t\t\tis_full_backup = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tif (cmd == CMD_RESTORE) {\n\t\t\t\tprintf(\"Aborting restore. Info.plist is missing.\\n\");\n\t\t\t\tcmd = CMD_LEAVE;\n\t\t\t} else {\n\t\t\t\tis_full_backup = 1;\n\t\t\t}\n\t\t}\n\n\t\tuint64_t lockfile = 0;\n\t\tif (cmd == CMD_BACKUP) {\n\t\t\tdo_post_notification(device, NP_SYNC_WILL_START);\n\t\t\tafc_file_open(afc, \"/com.apple.itunes.lock_sync\", AFC_FOPEN_RW, &lockfile);\n\t\t}\n\t\tif (lockfile) {\n\t\t\tafc_error_t aerr;\n\t\t\tdo_post_notification(device, NP_SYNC_LOCK_REQUEST);\n\t\t\tfor (i = 0; i < LOCK_ATTEMPTS; i++) {\n\t\t\t\taerr = afc_file_lock(afc, lockfile, AFC_LOCK_EX);\n\t\t\t\tif (aerr == AFC_E_SUCCESS) {\n\t\t\t\t\tdo_post_notification(device, NP_SYNC_DID_START);\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (aerr == AFC_E_OP_WOULD_BLOCK) {\n\t\t\t\t\tusleep(LOCK_WAIT);\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"ERROR: could not lock file! error code: %d\\n\", aerr);\n\t\t\t\t\tafc_file_close(afc, lockfile);\n\t\t\t\t\tlockfile = 0;\n\t\t\t\t\tcmd = CMD_LEAVE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == LOCK_ATTEMPTS) {\n\t\t\t\tfprintf(stderr, \"ERROR: timeout while locking for sync\\n\");\n\t\t\t\tafc_file_close(afc, lockfile);\n\t\t\t\tlockfile = 0;\n\t\t\t\tcmd = CMD_LEAVE;\n\t\t\t}\n\t\t}\n\t\tuint8_t willEncrypt = 0;\n\t\tnode_tmp = NULL;\n\t\tlockdownd_get_value(lockdown, \"com.apple.mobile.backup\", \"WillEncrypt\", &node_tmp);\n\t\tif (node_tmp) {\n\t\t\tif (plist_get_node_type(node_tmp) == PLIST_BOOLEAN) {\n\t\t\t\tplist_get_bool_val(node_tmp, &willEncrypt);\n\t\t\t}\n\t\t\tplist_free(node_tmp);\n\t\t\tnode_tmp = NULL;\n\t\t}\n\ncheckpoint:\n\n\t\tswitch(cmd) {\n\t\t\tcase CMD_CLOUD:\n\t\t\topts = plist_new_dict();\n\t\t\tplist_dict_set_item(opts, \"CloudBackupState\", plist_new_bool(cmd_flags & CMD_FLAG_CLOUD_ENABLE ? 1: 0));\n\t\t\terr = mobilebackup2_send_request(mobilebackup2, \"EnableCloudBackup\", udid, source_udid, opts);\n\t\t\tplist_free(opts);\n\t\t\topts = NULL;\n\t\t\tif (err != MOBILEBACKUP2_E_SUCCESS) {\n\t\t\t\tprintf(\"Error setting cloud backup state on device, error code %d\\n\", err);\n\t\t\t\tcmd = CMD_LEAVE;\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase CMD_BACKUP:\n\t\t\tPRINT_VERBOSE(1, \"Starting backup...\\n\");\n\n\t\t\t/* make sure backup device sub-directory exists */\n\t\t\tchar* devbackupdir = string_build_path(backup_directory, source_udid, NULL);\n\t\t\t__mkdir(devbackupdir, 0755);\n\t\t\tfree(devbackupdir);\n\n\t\t\tif (strcmp(source_udid, udid) != 0) {\n\t\t\t\t/* handle different source backup directory */\n\t\t\t\t// make sure target backup device sub-directory exists\n\t\t\t\tdevbackupdir = string_build_path(backup_directory, udid, NULL);\n\t\t\t\t__mkdir(devbackupdir, 0755);\n\t\t\t\tfree(devbackupdir);\n\n\t\t\t\t// use Info.plist path in target backup folder */\n\t\t\t\tfree(info_path);\n\t\t\t\tinfo_path = string_build_path(backup_directory, udid, \"Info.plist\", NULL);\n\t\t\t}\n\n\t\t\t/* TODO: check domain com.apple.mobile.backup key RequiresEncrypt and WillEncrypt with lockdown */\n\t\t\t/* TODO: verify battery on AC enough battery remaining */\n\n\t\t\t/* re-create Info.plist (Device infos, IC-Info.sidb, photos, app_ids, iTunesPrefs) */\n\t\t\tif (info_plist) {\n\t\t\t\tplist_free(info_plist);\n\t\t\t\tinfo_plist = NULL;\n\t\t\t}\n\t\t\tinfo_plist = mobilebackup_factory_info_plist_new(udid, lockdown, afc);\n\t\t\tremove(info_path);\n\t\t\tplist_write_to_filename(info_plist, info_path, PLIST_FORMAT_XML);\n\t\t\tfree(info_path);\n\n\t\t\tplist_free(info_plist);\n\t\t\tinfo_plist = NULL;\n\n\t\t\tif (cmd_flags & CMD_FLAG_FORCE_FULL_BACKUP) {\n\t\t\t\tPRINT_VERBOSE(1, \"Enforcing full backup from device.\\n\");\n\t\t\t\topts = plist_new_dict();\n\t\t\t\tplist_dict_set_item(opts, \"ForceFullBackup\", plist_new_bool(1));\n\t\t\t}\n\t\t\t/* request backup from device with manifest from last backup */\n\t\t\tif (willEncrypt) {\n\t\t\t\tPRINT_VERBOSE(1, \"Backup will be encrypted.\\n\");\n\t\t\t} else {\n\t\t\t\tPRINT_VERBOSE(1, \"Backup will be unencrypted.\\n\");\n\t\t\t}\n\t\t\tPRINT_VERBOSE(1, \"Requesting backup from device...\\n\");\n\t\t\terr = mobilebackup2_send_request(mobilebackup2, \"Backup\", udid, source_udid, opts);\n\t\t\tif (opts)\n\t\t\t\tplist_free(opts);\n\t\t\tif (err == MOBILEBACKUP2_E_SUCCESS) {\n\t\t\t\tif (is_full_backup) {\n\t\t\t\t\tPRINT_VERBOSE(1, \"Full backup mode.\\n\");\n\t\t\t\t}\telse {\n\t\t\t\t\tPRINT_VERBOSE(1, \"Incremental backup mode.\\n\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (err == MOBILEBACKUP2_E_BAD_VERSION) {\n\t\t\t\t\tprintf(\"ERROR: Could not start backup process: backup protocol version mismatch!\\n\");\n\t\t\t\t} else if (err == MOBILEBACKUP2_E_REPLY_NOT_OK) {\n\t\t\t\t\tprintf(\"ERROR: Could not start backup process: device refused to start the backup process.\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tprintf(\"ERROR: Could not start backup process: unspecified error occured\\n\");\n\t\t\t\t}\n\t\t\t\tcmd = CMD_LEAVE;\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase CMD_RESTORE:\n\t\t\t/* TODO: verify battery on AC enough battery remaining */\n\n\t\t\t/* verify if Status.plist says we read from an successful backup */\n\t\t\tif (!mb2_status_check_snapshot_state(backup_directory, source_udid, \"finished\")) {\n\t\t\t\tprintf(\"ERROR: Cannot ensure we restore from a successful backup. Aborting.\\n\");\n\t\t\t\tcmd = CMD_LEAVE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tPRINT_VERBOSE(1, \"Starting Restore...\\n\");\n\n\t\t\topts = plist_new_dict();\n\t\t\tplist_dict_set_item(opts, \"RestoreSystemFiles\", plist_new_bool(cmd_flags & CMD_FLAG_RESTORE_SYSTEM_FILES));\n\t\t\tPRINT_VERBOSE(1, \"Restoring system files: %s\\n\", (cmd_flags & CMD_FLAG_RESTORE_SYSTEM_FILES ? \"Yes\":\"No\"));\n\t\t\tif ((cmd_flags & CMD_FLAG_RESTORE_REBOOT) == 0)\n\t\t\t\tplist_dict_set_item(opts, \"RestoreShouldReboot\", plist_new_bool(0));\n\t\t\tPRINT_VERBOSE(1, \"Rebooting after restore: %s\\n\", (cmd_flags & CMD_FLAG_RESTORE_REBOOT ? \"Yes\":\"No\"));\n\t\t\tif ((cmd_flags & CMD_FLAG_RESTORE_COPY_BACKUP) == 0)\n\t\t\t\tplist_dict_set_item(opts, \"RestoreDontCopyBackup\", plist_new_bool(1));\n\t\t\tPRINT_VERBOSE(1, \"Don't copy backup: %s\\n\", ((cmd_flags & CMD_FLAG_RESTORE_COPY_BACKUP) == 0 ? \"Yes\":\"No\"));\n\t\t\tplist_dict_set_item(opts, \"RestorePreserveSettings\", plist_new_bool((cmd_flags & CMD_FLAG_RESTORE_SETTINGS) == 0));\n\t\t\tPRINT_VERBOSE(1, \"Preserve settings of device: %s\\n\", ((cmd_flags & CMD_FLAG_RESTORE_SETTINGS) == 0 ? \"Yes\":\"No\"));\n\t\t\tif (cmd_flags & CMD_FLAG_RESTORE_REMOVE_ITEMS)\n\t\t\t\tplist_dict_set_item(opts, \"RemoveItemsNotRestored\", plist_new_bool(1));\n\t\t\t\tPRINT_VERBOSE(1, \"Remove items that are not restored: %s\\n\", ((cmd_flags & CMD_FLAG_RESTORE_REMOVE_ITEMS) ? \"Yes\":\"No\"));\n\t\t\tif (backup_password != NULL) {\n\t\t\t\tplist_dict_set_item(opts, \"Password\", plist_new_string(backup_password));\n\t\t\t}\n\t\t\tPRINT_VERBOSE(1, \"Backup password: %s\\n\", (backup_password == NULL ? \"No\":\"Yes\"));\n\n\t\t\terr = mobilebackup2_send_request(mobilebackup2, \"Restore\", udid, source_udid, opts);\n\t\t\tplist_free(opts);\n\t\t\tif (err != MOBILEBACKUP2_E_SUCCESS) {\n\t\t\t\tif (err == MOBILEBACKUP2_E_BAD_VERSION) {\n\t\t\t\t\tprintf(\"ERROR: Could not start restore process: backup protocol version mismatch!\\n\");\n\t\t\t\t} else if (err == MOBILEBACKUP2_E_REPLY_NOT_OK) {\n\t\t\t\t\tprintf(\"ERROR: Could not start restore process: device refused to start the restore process.\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tprintf(\"ERROR: Could not start restore process: unspecified error occured\\n\");\n\t\t\t\t}\n\t\t\t\tcmd = CMD_LEAVE;\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase CMD_INFO:\n\t\t\tPRINT_VERBOSE(1, \"Requesting backup info from device...\\n\");\n\t\t\terr = mobilebackup2_send_request(mobilebackup2, \"Info\", udid, source_udid, NULL);\n\t\t\tif (err != MOBILEBACKUP2_E_SUCCESS) {\n\t\t\t\tprintf(\"Error requesting backup info from device, error code %d\\n\", err);\n\t\t\t\tcmd = CMD_LEAVE;\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase CMD_LIST:\n\t\t\tPRINT_VERBOSE(1, \"Requesting backup list from device...\\n\");\n\t\t\terr = mobilebackup2_send_request(mobilebackup2, \"List\", udid, source_udid, NULL);\n\t\t\tif (err != MOBILEBACKUP2_E_SUCCESS) {\n\t\t\t\tprintf(\"Error requesting backup list from device, error code %d\\n\", err);\n\t\t\t\tcmd = CMD_LEAVE;\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase CMD_UNBACK:\n\t\t\tPRINT_VERBOSE(1, \"Starting to unpack backup...\\n\");\n\t\t\tif (backup_password != NULL) {\n\t\t\t\topts = plist_new_dict();\n\t\t\t\tplist_dict_set_item(opts, \"Password\", plist_new_string(backup_password));\n\t\t\t}\n\t\t\tPRINT_VERBOSE(1, \"Backup password: %s\\n\", (backup_password == NULL ? \"No\":\"Yes\"));\n\t\t\terr = mobilebackup2_send_request(mobilebackup2, \"Unback\", udid, source_udid, opts);\n\t\t\tif (backup_password !=NULL) {\n\t\t\t\tplist_free(opts);\n\t\t\t}\n\t\t\tif (err != MOBILEBACKUP2_E_SUCCESS) {\n\t\t\t\tprintf(\"Error requesting unback operation from device, error code %d\\n\", err);\n\t\t\t\tcmd = CMD_LEAVE;\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase CMD_CHANGEPW:\n\t\t\topts = plist_new_dict();\n\t\t\tplist_dict_set_item(opts, \"TargetIdentifier\", plist_new_string(udid));\n\t\t\tif (cmd_flags & CMD_FLAG_ENCRYPTION_ENABLE) {\n\t\t\t\tif (!willEncrypt) {\n\t\t\t\t\tif (!newpw) {\n\t\t\t\t\t\tnewpw = ask_for_password(\"Enter new backup password\", 1);\n\t\t\t\t\t}\n\t\t\t\t\tif (!newpw) {\n\t\t\t\t\t\tprintf(\"No backup password given. Aborting.\\n\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tprintf(\"ERROR: Backup encryption is already enabled. Aborting.\\n\");\n\t\t\t\t\tcmd = CMD_LEAVE;\n\t\t\t\t\tif (newpw) {\n\t\t\t\t\t\tfree(newpw);\n\t\t\t\t\t\tnewpw = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (cmd_flags & CMD_FLAG_ENCRYPTION_DISABLE) {\n\t\t\t\tif (willEncrypt) {\n\t\t\t\t\tif (!backup_password) {\n\t\t\t\t\t\tbackup_password = ask_for_password(\"Enter current backup password\", 0);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tprintf(\"ERROR: Backup encryption is not enabled. Aborting.\\n\");\n\t\t\t\t\tcmd = CMD_LEAVE;\n\t\t\t\t\tif (backup_password) {\n\t\t\t\t\t\tfree(backup_password);\n\t\t\t\t\t\tbackup_password = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (cmd_flags & CMD_FLAG_ENCRYPTION_CHANGEPW) {\n\t\t\t\tif (willEncrypt) {\n\t\t\t\t\tif (!backup_password) {\n\t\t\t\t\t\tbackup_password = ask_for_password(\"Enter old backup password\", 0);\n\t\t\t\t\t\tnewpw = ask_for_password(\"Enter new backup password\", 1);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tprintf(\"ERROR: Backup encryption is not enabled so can't change password. Aborting.\\n\");\n\t\t\t\t\tcmd = CMD_LEAVE;\n\t\t\t\t\tif (newpw) {\n\t\t\t\t\t\tfree(newpw);\n\t\t\t\t\t\tnewpw = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif (backup_password) {\n\t\t\t\t\t\tfree(backup_password);\n\t\t\t\t\t\tbackup_password = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (newpw) {\n\t\t\t\tplist_dict_set_item(opts, \"NewPassword\", plist_new_string(newpw));\n\t\t\t}\n\t\t\tif (backup_password) {\n\t\t\t\tplist_dict_set_item(opts, \"OldPassword\", plist_new_string(backup_password));\n\t\t\t}\n\t\t\tif (newpw || backup_password) {\n\t\t\t\tmobilebackup2_send_message(mobilebackup2, \"ChangePassword\", opts);\n\t\t\t\t/*if (cmd_flags & CMD_FLAG_ENCRYPTION_ENABLE) {\n\t\t\t\t\tint retr = 10;\n\t\t\t\t\twhile ((retr-- >= 0) && !backup_domain_changed) {\n\t\t\t\t\t\tsleep(1);\n\t\t\t\t\t}\n\t\t\t\t}*/\n\t\t\t} else {\n\t\t\t\tcmd = CMD_LEAVE;\n\t\t\t}\n\t\t\tplist_free(opts);\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\t/* close down the lockdown connection as it is no longer needed */\n\t\tif (lockdown) {\n\t\t\tlockdownd_client_free(lockdown);\n\t\t\tlockdown = NULL;\n\t\t}\n\n\t\tif (cmd != CMD_LEAVE) {\n\t\t\t/* reset operation success status */\n\t\t\tint operation_ok = 0;\n\t\t\tplist_t message = NULL;\n\n\t\t\tchar *dlmsg = NULL;\n\t\t\tint file_count = 0;\n\t\t\tint errcode = 0;\n\t\t\tconst char *errdesc = NULL;\n\n\t\t\t/* process series of DLMessage* operations */\n\t\t\tdo {\n\t\t\t\tif (dlmsg) {\n\t\t\t\t\tfree(dlmsg);\n\t\t\t\t\tdlmsg = NULL;\n\t\t\t\t}\n\t\t\t\tmobilebackup2_receive_message(mobilebackup2, &message, &dlmsg);\n\t\t\t\tif (!message || !dlmsg) {\n\t\t\t\t\tPRINT_VERBOSE(1, \"Device is not ready yet. Going to try again in 2 seconds...\\n\");\n\t\t\t\t\tsleep(2);\n\t\t\t\t\tgoto files_out;\n\t\t\t\t}\n\n\t\t\t\tif (!strcmp(dlmsg, \"DLMessageDownloadFiles\")) {\n\t\t\t\t\t/* device wants to download files from the computer */\n\t\t\t\t\tmb2_set_overall_progress_from_message(message, dlmsg);\n\t\t\t\t\tmb2_handle_send_files(mobilebackup2, message, backup_directory);\n\t\t\t\t} else if (!strcmp(dlmsg, \"DLMessageUploadFiles\")) {\n\t\t\t\t\t/* device wants to send files to the computer */\n\t\t\t\t\tmb2_set_overall_progress_from_message(message, dlmsg);\n\t\t\t\t\tfile_count += mb2_handle_receive_files(mobilebackup2, message, backup_directory);\n\t\t\t\t} else if (!strcmp(dlmsg, \"DLMessageGetFreeDiskSpace\")) {\n\t\t\t\t\t/* device wants to know how much disk space is available on the computer */\n\t\t\t\t\tuint64_t freespace = 0;\n\t\t\t\t\tint res = -1;\n#ifdef WIN32\n\t\t\t\t\tif (GetDiskFreeSpaceEx(backup_directory, (PULARGE_INTEGER)&freespace, NULL, NULL)) {\n\t\t\t\t\t\tres = 0;\n\t\t\t\t\t}\n#else\n\t\t\t\t\tstruct statvfs fs;\n\t\t\t\t\tmemset(&fs, '\\0', sizeof(fs));\n\t\t\t\t\tres = statvfs(backup_directory, &fs);\n\t\t\t\t\tif (res == 0) {\n\t\t\t\t\t\tfreespace = (uint64_t)fs.f_bavail * (uint64_t)fs.f_bsize;\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tplist_t freespace_item = plist_new_uint(freespace);\n\t\t\t\t\tmobilebackup2_send_status_response(mobilebackup2, res, NULL, freespace_item);\n\t\t\t\t\tplist_free(freespace_item);\n\t\t\t\t} else if (!strcmp(dlmsg, \"DLContentsOfDirectory\")) {\n\t\t\t\t\t/* list directory contents */\n\t\t\t\t\tmb2_handle_list_directory(mobilebackup2, message, backup_directory);\n\t\t\t\t} else if (!strcmp(dlmsg, \"DLMessageCreateDirectory\")) {\n\t\t\t\t\t/* make a directory */\n\t\t\t\t\tmb2_handle_make_directory(mobilebackup2, message, backup_directory);\n\t\t\t\t} else if (!strcmp(dlmsg, \"DLMessageMoveFiles\") || !strcmp(dlmsg, \"DLMessageMoveItems\")) {\n\t\t\t\t\t/* perform a series of rename operations */\n\t\t\t\t\tmb2_set_overall_progress_from_message(message, dlmsg);\n\t\t\t\t\tplist_t moves = plist_array_get_item(message, 1);\n\t\t\t\t\tuint32_t cnt = plist_dict_get_size(moves);\n\t\t\t\t\tPRINT_VERBOSE(1, \"Moving %d file%s\\n\", cnt, (cnt == 1) ? \"\" : \"s\");\n\t\t\t\t\tplist_dict_iter iter = NULL;\n\t\t\t\t\tplist_dict_new_iter(moves, &iter);\n\t\t\t\t\terrcode = 0;\n\t\t\t\t\terrdesc = NULL;\n\t\t\t\t\tif (iter) {\n\t\t\t\t\t\tchar *key = NULL;\n\t\t\t\t\t\tplist_t val = NULL;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tplist_dict_next_item(moves, iter, &key, &val);\n\t\t\t\t\t\t\tif (key && (plist_get_node_type(val) == PLIST_STRING)) {\n\t\t\t\t\t\t\t\tchar *str = NULL;\n\t\t\t\t\t\t\t\tplist_get_string_val(val, &str);\n\t\t\t\t\t\t\t\tif (str) {\n\t\t\t\t\t\t\t\t\tchar *newpath = string_build_path(backup_directory, str, NULL);\n\t\t\t\t\t\t\t\t\tfree(str);\n\t\t\t\t\t\t\t\t\tchar *oldpath = string_build_path(backup_directory, key, NULL);\n\n#ifdef WIN32\n\t\t\t\t\t\t\t\t\tif ((stat(newpath, &st) == 0) && S_ISDIR(st.st_mode))\n\t\t\t\t\t\t\t\t\t\tRemoveDirectory(newpath);\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\tDeleteFile(newpath);\n#else\n\t\t\t\t\t\t\t\t\tremove(newpath);\n#endif\n\t\t\t\t\t\t\t\t\tif (rename(oldpath, newpath) < 0) {\n\t\t\t\t\t\t\t\t\t\tprintf(\"Renameing '%s' to '%s' failed: %s (%d)\\n\", oldpath, newpath, strerror(errno), errno);\n\t\t\t\t\t\t\t\t\t\terrcode = errno_to_device_error(errno);\n\t\t\t\t\t\t\t\t\t\terrdesc = strerror(errno);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tfree(oldpath);\n\t\t\t\t\t\t\t\t\tfree(newpath);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfree(key);\n\t\t\t\t\t\t\t\tkey = NULL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} while (val);\n\t\t\t\t\t\tfree(iter);\n\t\t\t\t\t} else {\n\t\t\t\t\t\terrcode = -1;\n\t\t\t\t\t\terrdesc = \"Could not create dict iterator\";\n\t\t\t\t\t\tprintf(\"Could not create dict iterator\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tplist_t empty_dict = plist_new_dict();\n\t\t\t\t\terr = mobilebackup2_send_status_response(mobilebackup2, errcode, errdesc, empty_dict);\n\t\t\t\t\tplist_free(empty_dict);\n\t\t\t\t\tif (err != MOBILEBACKUP2_E_SUCCESS) {\n\t\t\t\t\t\tprintf(\"Could not send status response, error %d\\n\", err);\n\t\t\t\t\t}\n\t\t\t\t} else if (!strcmp(dlmsg, \"DLMessageRemoveFiles\") || !strcmp(dlmsg, \"DLMessageRemoveItems\")) {\n\t\t\t\t\tmb2_set_overall_progress_from_message(message, dlmsg);\n\t\t\t\t\tplist_t removes = plist_array_get_item(message, 1);\n\t\t\t\t\tuint32_t cnt = plist_array_get_size(removes);\n\t\t\t\t\tPRINT_VERBOSE(1, \"Removing %d file%s\\n\", cnt, (cnt == 1) ? \"\" : \"s\");\n\t\t\t\t\tuint32_t ii = 0;\n\t\t\t\t\terrcode = 0;\n\t\t\t\t\terrdesc = NULL;\n\t\t\t\t\tfor (ii = 0; ii < cnt; ii++) {\n\t\t\t\t\t\tplist_t val = plist_array_get_item(removes, ii);\n\t\t\t\t\t\tif (plist_get_node_type(val) == PLIST_STRING) {\n\t\t\t\t\t\t\tchar *str = NULL;\n\t\t\t\t\t\t\tplist_get_string_val(val, &str);\n\t\t\t\t\t\t\tif (str) {\n\t\t\t\t\t\t\t\tconst char *checkfile = strchr(str, '/');\n\t\t\t\t\t\t\t\tint suppress_warning = 0;\n\t\t\t\t\t\t\t\tif (checkfile) {\n\t\t\t\t\t\t\t\t\tif (strcmp(checkfile+1, \"Manifest.mbdx\") == 0) {\n\t\t\t\t\t\t\t\t\t\tsuppress_warning = 1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tchar *newpath = string_build_path(backup_directory, str, NULL);\n\t\t\t\t\t\t\t\tfree(str);\n#ifdef WIN32\n\t\t\t\t\t\t\t\tint res = 0;\n\t\t\t\t\t\t\t\tif ((stat(newpath, &st) == 0) && S_ISDIR(st.st_mode))\n\t\t\t\t\t\t\t\t\tres = RemoveDirectory(newpath);\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tres = DeleteFile(newpath);\n\t\t\t\t\t\t\t\tif (!res) {\n\t\t\t\t\t\t\t\t\tint e = win32err_to_errno(GetLastError());\n\t\t\t\t\t\t\t\t\tif (!suppress_warning)\n\t\t\t\t\t\t\t\t\t\tprintf(\"Could not remove '%s': %s (%d)\\n\", newpath, strerror(e), e);\n\t\t\t\t\t\t\t\t\terrcode = errno_to_device_error(e);\n\t\t\t\t\t\t\t\t\terrdesc = strerror(e);\n\t\t\t\t\t\t\t\t}\n#else\n\t\t\t\t\t\t\t\tif (remove(newpath) < 0) {\n\t\t\t\t\t\t\t\t\tif (!suppress_warning)\n\t\t\t\t\t\t\t\t\t\tprintf(\"Could not remove '%s': %s (%d)\\n\", newpath, strerror(errno), errno);\n\t\t\t\t\t\t\t\t\terrcode = errno_to_device_error(errno);\n\t\t\t\t\t\t\t\t\terrdesc = strerror(errno);\n\t\t\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t\t\t\tfree(newpath);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tplist_t empty_dict = plist_new_dict();\n\t\t\t\t\terr = mobilebackup2_send_status_response(mobilebackup2, errcode, errdesc, empty_dict);\n\t\t\t\t\tplist_free(empty_dict);\n\t\t\t\t\tif (err != MOBILEBACKUP2_E_SUCCESS) {\n\t\t\t\t\t\tprintf(\"Could not send status response, error %d\\n\", err);\n\t\t\t\t\t}\n\t\t\t\t} else if (!strcmp(dlmsg, \"DLMessageCopyItem\")) {\n\t\t\t\t\tplist_t srcpath = plist_array_get_item(message, 1);\n\t\t\t\t\tplist_t dstpath = plist_array_get_item(message, 2);\n\t\t\t\t\terrcode = 0;\n\t\t\t\t\terrdesc = NULL;\n\t\t\t\t\tif ((plist_get_node_type(srcpath) == PLIST_STRING) && (plist_get_node_type(dstpath) == PLIST_STRING)) {\n\t\t\t\t\t\tchar *src = NULL;\n\t\t\t\t\t\tchar *dst = NULL;\n\t\t\t\t\t\tplist_get_string_val(srcpath, &src);\n\t\t\t\t\t\tplist_get_string_val(dstpath, &dst);\n\t\t\t\t\t\tif (src && dst) {\n\t\t\t\t\t\t\tchar *oldpath = string_build_path(backup_directory, src, NULL);\n\t\t\t\t\t\t\tchar *newpath = string_build_path(backup_directory, dst, NULL);\n\n\t\t\t\t\t\t\tPRINT_VERBOSE(1, \"Copying '%s' to '%s'\\n\", src, dst);\n\n\t\t\t\t\t\t\t/* check that src exists */\n\t\t\t\t\t\t\tif ((stat(oldpath, &st) == 0) && S_ISDIR(st.st_mode)) {\n\t\t\t\t\t\t\t\tmb2_copy_directory_by_path(oldpath, newpath);\n\t\t\t\t\t\t\t} else if ((stat(oldpath, &st) == 0) && S_ISREG(st.st_mode)) {\n\t\t\t\t\t\t\t\tmb2_copy_file_by_path(oldpath, newpath);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfree(newpath);\n\t\t\t\t\t\t\tfree(oldpath);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree(src);\n\t\t\t\t\t\tfree(dst);\n\t\t\t\t\t}\n\t\t\t\t\tplist_t empty_dict = plist_new_dict();\n\t\t\t\t\terr = mobilebackup2_send_status_response(mobilebackup2, errcode, errdesc, empty_dict);\n\t\t\t\t\tplist_free(empty_dict);\n\t\t\t\t\tif (err != MOBILEBACKUP2_E_SUCCESS) {\n\t\t\t\t\t\tprintf(\"Could not send status response, error %d\\n\", err);\n\t\t\t\t\t}\n\t\t\t\t} else if (!strcmp(dlmsg, \"DLMessageDisconnect\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (!strcmp(dlmsg, \"DLMessageProcessMessage\")) {\n\t\t\t\t\tnode_tmp = plist_array_get_item(message, 1);\n\t\t\t\t\tif (plist_get_node_type(node_tmp) != PLIST_DICT) {\n\t\t\t\t\t\tprintf(\"Unknown message received!\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tplist_t nn;\n\t\t\t\t\tint error_code = -1;\n\t\t\t\t\tnn = plist_dict_get_item(node_tmp, \"ErrorCode\");\n\t\t\t\t\tif (nn && (plist_get_node_type(nn) == PLIST_UINT)) {\n\t\t\t\t\t\tuint64_t ec = 0;\n\t\t\t\t\t\tplist_get_uint_val(nn, &ec);\n\t\t\t\t\t\terror_code = (uint32_t)ec;\n\t\t\t\t\t\tif (error_code == 0) {\n\t\t\t\t\t\t\toperation_ok = 1;\n\t\t\t\t\t\t\tresult_code = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult_code = -error_code;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tnn = plist_dict_get_item(node_tmp, \"ErrorDescription\");\n\t\t\t\t\tchar *str = NULL;\n\t\t\t\t\tif (nn && (plist_get_node_type(nn) == PLIST_STRING)) {\n\t\t\t\t\t\tplist_get_string_val(nn, &str);\n\t\t\t\t\t}\n\t\t\t\t\tif (error_code != 0) {\n\t\t\t\t\t\tif (str) {\n\t\t\t\t\t\t\tprintf(\"ErrorCode %d: %s\\n\", error_code, str);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tprintf(\"ErrorCode %d: (Unknown)\\n\", error_code);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (str) {\n\t\t\t\t\t\tfree(str);\n\t\t\t\t\t}\n\t\t\t\t\tnn = plist_dict_get_item(node_tmp, \"Content\");\n\t\t\t\t\tif (nn && (plist_get_node_type(nn) == PLIST_STRING)) {\n\t\t\t\t\t\tstr = NULL;\n\t\t\t\t\t\tplist_get_string_val(nn, &str);\n\t\t\t\t\t\tPRINT_VERBOSE(1, \"Content:\\n\");\n\t\t\t\t\t\tprintf(\"%s\", str);\n\t\t\t\t\t\tfree(str);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* print status */\n\t\t\t\tif (overall_progress > 0) {\n\t\t\t\t\tprint_progress_real(overall_progress, 0);\n\t\t\t\t\tPRINT_VERBOSE(1, \" Finished\\n\");\n\t\t\t\t}\n\nfiles_out:\n\t\t\t\tif (message)\n\t\t\t\t\tplist_free(message);\n\t\t\t\tmessage = NULL;\n\t\t\t\tif (dlmsg)\n\t\t\t\t\tfree(dlmsg);\n\t\t\t\tdlmsg = NULL;\n\n\t\t\t\tif (quit_flag > 0) {\n\t\t\t\t\t/* need to cancel the backup here */\n\t\t\t\t\t//mobilebackup_send_error(mobilebackup, \"Cancelling DLSendFile\");\n\n\t\t\t\t\t/* remove any atomic Manifest.plist.tmp */\n\n\t\t\t\t\t/*manifest_path = mobilebackup_build_path(backup_directory, \"Manifest\", \".plist.tmp\");\n\t\t\t\t\tif (stat(manifest_path, &st) == 0)\n\t\t\t\t\t\tremove(manifest_path);*/\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (1);\n\n\t\t\t/* report operation status to user */\n\t\t\tswitch (cmd) {\n\t\t\t\tcase CMD_CLOUD:\n\t\t\t\tif (cmd_flags & CMD_FLAG_CLOUD_ENABLE) {\n\t\t\t\t\tif (operation_ok) {\n\t\t\t\t\t\tPRINT_VERBOSE(1, \"Cloud backup has been enabled successfully.\\n\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tPRINT_VERBOSE(1, \"Could not enable cloud backup.\\n\");\n\t\t\t\t\t}\n\t\t\t\t} else if (cmd_flags & CMD_FLAG_CLOUD_DISABLE) {\n\t\t\t\t\tif (operation_ok) {\n\t\t\t\t\t\tPRINT_VERBOSE(1, \"Cloud backup has been disabled successfully.\\n\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tPRINT_VERBOSE(1, \"Could not disable cloud backup.\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\tcase CMD_BACKUP:\n\t\t\t\t\tPRINT_VERBOSE(1, \"Received %d files from device.\\n\", file_count);\n\t\t\t\t\tif (operation_ok && mb2_status_check_snapshot_state(backup_directory, udid, \"finished\")) {\n\t\t\t\t\t\tPRINT_VERBOSE(1, \"Backup Successful.\\n\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (quit_flag) {\n\t\t\t\t\t\t\tPRINT_VERBOSE(1, \"Backup Aborted.\\n\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tPRINT_VERBOSE(1, \"Backup Failed (Error Code %d).\\n\", -result_code);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\tcase CMD_UNBACK:\n\t\t\t\tif (quit_flag) {\n\t\t\t\t\tPRINT_VERBOSE(1, \"Unback Aborted.\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tPRINT_VERBOSE(1, \"The files can now be found in the \\\"_unback_\\\" directory.\\n\");\n\t\t\t\t\tPRINT_VERBOSE(1, \"Unback Successful.\\n\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\tcase CMD_CHANGEPW:\n\t\t\t\tif (cmd_flags & CMD_FLAG_ENCRYPTION_ENABLE) {\n\t\t\t\t\tif (operation_ok) {\n\t\t\t\t\t\tPRINT_VERBOSE(1, \"Backup encryption has been enabled successfully.\\n\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tPRINT_VERBOSE(1, \"Could not enable backup encryption.\\n\");\n\t\t\t\t\t}\n\t\t\t\t} else if (cmd_flags & CMD_FLAG_ENCRYPTION_DISABLE) {\n\t\t\t\t\tif (operation_ok) {\n\t\t\t\t\t\tPRINT_VERBOSE(1, \"Backup encryption has been disabled successfully.\\n\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tPRINT_VERBOSE(1, \"Could not disable backup encryption.\\n\");\n\t\t\t\t\t}\n\t\t\t\t} else if (cmd_flags & CMD_FLAG_ENCRYPTION_CHANGEPW) {\n\t\t\t\t\tif (operation_ok) {\n\t\t\t\t\t\tPRINT_VERBOSE(1, \"Backup encryption password has been changed successfully.\\n\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tPRINT_VERBOSE(1, \"Could not change backup encryption password.\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\tcase CMD_RESTORE:\n\t\t\t\tif (cmd_flags & CMD_FLAG_RESTORE_REBOOT)\n\t\t\t\t\tPRINT_VERBOSE(1, \"The device should reboot now.\\n\");\n\t\t\t\tif (operation_ok) {\n\t\t\t\t\tPRINT_VERBOSE(1, \"Restore Successful.\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tPRINT_VERBOSE(1, \"Restore Failed (Error Code %d).\\n\", -result_code);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\tcase CMD_INFO:\n\t\t\t\tcase CMD_LIST:\n\t\t\t\tcase CMD_LEAVE:\n\t\t\t\tdefault:\n\t\t\t\tif (quit_flag) {\n\t\t\t\t\tPRINT_VERBOSE(1, \"Operation Aborted.\\n\");\n\t\t\t\t} else if (cmd == CMD_LEAVE) {\n\t\t\t\t\tPRINT_VERBOSE(1, \"Operation Failed.\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tPRINT_VERBOSE(1, \"Operation Successful.\\n\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (lockfile) {\n\t\t\tafc_file_lock(afc, lockfile, AFC_LOCK_UN);\n\t\t\tafc_file_close(afc, lockfile);\n\t\t\tlockfile = 0;\n\t\t\tif (cmd == CMD_BACKUP)\n\t\t\t\tdo_post_notification(device, NP_SYNC_DID_FINISH);\n\t\t}\n\t} else {\n\t\tprintf(\"ERROR: Could not start service %s.\\n\", MOBILEBACKUP2_SERVICE_NAME);\n\t\tlockdownd_client_free(lockdown);\n\t\tlockdown = NULL;\n\t}\n\n\tif (lockdown) {\n\t\tlockdownd_client_free(lockdown);\n\t\tlockdown = NULL;\n\t}\n\n\tif (mobilebackup2) {\n\t\tmobilebackup2_client_free(mobilebackup2);\n\t\tmobilebackup2 = NULL;\n\t}\n\n\tif (afc) {\n\t\tafc_client_free(afc);\n\t\tafc = NULL;\n\t}\n\n\tif (np) {\n\t\tnp_client_free(np);\n\t\tnp = NULL;\n\t}\n\n\tidevice_free(device);\n\tdevice = NULL;\n\n\tif (backup_password) {\n\t\tfree(backup_password);\n\t}\n\n\tif (udid) {\n\t\tfree(udid);\n\t\tudid = NULL;\n\t}\n\tif (source_udid) {\n\t\tfree(source_udid);\n\t\tsource_udid = NULL;\n\t}\n\n\treturn result_code;\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <sys/statvfs.h>",
      "#include <termios.h>",
      "#include <conio.h>",
      "#include <windows.h>",
      "#include <endianness.h>",
      "#include \"common/utils.h\"",
      "#include <libimobiledevice/afc.h>",
      "#include <libimobiledevice/notification_proxy.h>",
      "#include <libimobiledevice/mobilebackup2.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <libgen.h>",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define LOCK_WAIT 200000",
      "#define LOCK_ATTEMPTS 50"
    ],
    "globals_used": [
      "static int verbose = 1;",
      "static int quit_flag = 0;",
      "static int backup_domain_changed = 0;",
      "static double overall_progress = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "source_udid"
          ],
          "line": 2219
        },
        "resolved": true,
        "details": {
          "function_name": "thread_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "39-44",
          "snippet": "void thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nvoid thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "idevice_free",
          "args": [
            "device"
          ],
          "line": 2207
        },
        "resolved": true,
        "details": {
          "function_name": "idevice_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
          "lines": "247-265",
          "snippet": "LIBIMOBILEDEVICE_API idevice_error_t idevice_free(idevice_t device)\n{\n\tif (!device)\n\t\treturn IDEVICE_E_INVALID_ARG;\n\tidevice_error_t ret = IDEVICE_E_UNKNOWN_ERROR;\n\n\tret = IDEVICE_E_SUCCESS;\n\n\tfree(device->udid);\n\n\tif (device->conn_type == CONNECTION_USBMUXD) {\n\t\tdevice->conn_data = 0;\n\t}\n\tif (device->conn_data) {\n\t\tfree(device->conn_data);\n\t}\n\tfree(device);\n\treturn ret;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"common/thread.h\"",
            "#include \"common/userpref.h\"",
            "#include \"idevice.h\"",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <usbmuxd.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "LIBIMOBILEDEVICE_API idevice_error_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nLIBIMOBILEDEVICE_API idevice_error_t idevice_free(idevice_t device)\n{\n\tif (!device)\n\t\treturn IDEVICE_E_INVALID_ARG;\n\tidevice_error_t ret = IDEVICE_E_UNKNOWN_ERROR;\n\n\tret = IDEVICE_E_SUCCESS;\n\n\tfree(device->udid);\n\n\tif (device->conn_type == CONNECTION_USBMUXD) {\n\t\tdevice->conn_data = 0;\n\t}\n\tif (device->conn_data) {\n\t\tfree(device->conn_data);\n\t}\n\tfree(device);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "np_client_free",
          "args": [
            "np"
          ],
          "line": 2203
        },
        "resolved": true,
        "details": {
          "function_name": "np_client_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/notification_proxy.c",
          "lines": "114-166",
          "snippet": "LIBIMOBILEDEVICE_API np_error_t np_client_free(np_client_t client)\n{\n\tplist_t dict;\n\tproperty_list_service_client_t parent;\n\n\tif (!client)\n\t\treturn NP_E_INVALID_ARG;\n\n\tdict = plist_new_dict();\n\tplist_dict_set_item(dict,\"Command\", plist_new_string(\"Shutdown\"));\n\tproperty_list_service_send_xml_plist(client->parent, dict);\n\tplist_free(dict);\n\n\tparent = client->parent;\n\t/* notifies the client->notifier thread that it should terminate */\n\tclient->parent = NULL;\n\n\tif (client->notifier) {\n\t\tdebug_info(\"joining np callback\");\n\t\tthread_join(client->notifier);\n\t\tthread_free(client->notifier);\n\t\tclient->notifier = (thread_t)NULL;\n\t} else {\n\t\tdict = NULL;\n\t\tproperty_list_service_receive_plist(parent, &dict);\n\t\tif (dict) {\n#ifndef STRIP_DEBUG_CODE\n\t\t\tchar *cmd_value = NULL;\n\t\t\tplist_t cmd_value_node = plist_dict_get_item(dict, \"Command\");\n\t\t\tif (plist_get_node_type(cmd_value_node) == PLIST_STRING) {\n\t\t\t\tplist_get_string_val(cmd_value_node, &cmd_value);\n\t\t\t}\n\t\t\tif (cmd_value && !strcmp(cmd_value, \"ProxyDeath\")) {\n\t\t\t\t// this is the expected answer\n\t\t\t} else {\n\t\t\t\tdebug_info(\"Did not get ProxyDeath but:\");\n\t\t\t\tdebug_plist(dict);\n\t\t\t}\n\t\t\tif (cmd_value) {\n\t\t\t\tfree(cmd_value);\n\t\t\t}\n#endif\n\t\t\tplist_free(dict);\n\t\t}\n\t}\n\n\tproperty_list_service_client_free(parent);\n\n\tmutex_destroy(&client->mutex);\n\tfree(client);\n\n\treturn NP_E_SUCCESS;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"property_list_service.h\"",
            "#include \"notification_proxy.h\"",
            "#include <plist/plist.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"property_list_service.h\"\n#include \"notification_proxy.h\"\n#include <plist/plist.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n\nLIBIMOBILEDEVICE_API np_error_t np_client_free(np_client_t client)\n{\n\tplist_t dict;\n\tproperty_list_service_client_t parent;\n\n\tif (!client)\n\t\treturn NP_E_INVALID_ARG;\n\n\tdict = plist_new_dict();\n\tplist_dict_set_item(dict,\"Command\", plist_new_string(\"Shutdown\"));\n\tproperty_list_service_send_xml_plist(client->parent, dict);\n\tplist_free(dict);\n\n\tparent = client->parent;\n\t/* notifies the client->notifier thread that it should terminate */\n\tclient->parent = NULL;\n\n\tif (client->notifier) {\n\t\tdebug_info(\"joining np callback\");\n\t\tthread_join(client->notifier);\n\t\tthread_free(client->notifier);\n\t\tclient->notifier = (thread_t)NULL;\n\t} else {\n\t\tdict = NULL;\n\t\tproperty_list_service_receive_plist(parent, &dict);\n\t\tif (dict) {\n#ifndef STRIP_DEBUG_CODE\n\t\t\tchar *cmd_value = NULL;\n\t\t\tplist_t cmd_value_node = plist_dict_get_item(dict, \"Command\");\n\t\t\tif (plist_get_node_type(cmd_value_node) == PLIST_STRING) {\n\t\t\t\tplist_get_string_val(cmd_value_node, &cmd_value);\n\t\t\t}\n\t\t\tif (cmd_value && !strcmp(cmd_value, \"ProxyDeath\")) {\n\t\t\t\t// this is the expected answer\n\t\t\t} else {\n\t\t\t\tdebug_info(\"Did not get ProxyDeath but:\");\n\t\t\t\tdebug_plist(dict);\n\t\t\t}\n\t\t\tif (cmd_value) {\n\t\t\t\tfree(cmd_value);\n\t\t\t}\n#endif\n\t\t\tplist_free(dict);\n\t\t}\n\t}\n\n\tproperty_list_service_client_free(parent);\n\n\tmutex_destroy(&client->mutex);\n\tfree(client);\n\n\treturn NP_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afc_client_free",
          "args": [
            "afc"
          ],
          "line": 2198
        },
        "resolved": true,
        "details": {
          "function_name": "afc_client_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "125-138",
          "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_client_free(afc_client_t client)\n{\n\tif (!client || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tif (client->free_parent && client->parent) {\n\t\tservice_client_free(client->parent);\n\t\tclient->parent = NULL;\n\t}\n\tfree(client->afc_packet);\n\tmutex_destroy(&client->mutex);\n\tfree(client);\n\treturn AFC_E_SUCCESS;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_client_free(afc_client_t client)\n{\n\tif (!client || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tif (client->free_parent && client->parent) {\n\t\tservice_client_free(client->parent);\n\t\tclient->parent = NULL;\n\t}\n\tfree(client->afc_packet);\n\tmutex_destroy(&client->mutex);\n\tfree(client);\n\treturn AFC_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mobilebackup2_client_free",
          "args": [
            "mobilebackup2"
          ],
          "line": 2193
        },
        "resolved": true,
        "details": {
          "function_name": "mobilebackup2_client_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/mobilebackup2.c",
          "lines": "99-110",
          "snippet": "LIBIMOBILEDEVICE_API mobilebackup2_error_t mobilebackup2_client_free(mobilebackup2_client_t client)\n{\n\tif (!client)\n\t\treturn MOBILEBACKUP2_E_INVALID_ARG;\n\tmobilebackup2_error_t err = MOBILEBACKUP2_E_SUCCESS;\n\tif (client->parent) {\n\t\tdevice_link_service_disconnect(client->parent, NULL);\n\t\terr = mobilebackup2_error(device_link_service_client_free(client->parent));\n\t}\n\tfree(client);\n\treturn err;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"device_link_service.h\"",
            "#include \"mobilebackup2.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <plist/plist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"device_link_service.h\"\n#include \"mobilebackup2.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <plist/plist.h>\n\nLIBIMOBILEDEVICE_API mobilebackup2_error_t mobilebackup2_client_free(mobilebackup2_client_t client)\n{\n\tif (!client)\n\t\treturn MOBILEBACKUP2_E_INVALID_ARG;\n\tmobilebackup2_error_t err = MOBILEBACKUP2_E_SUCCESS;\n\tif (client->parent) {\n\t\tdevice_link_service_disconnect(client->parent, NULL);\n\t\terr = mobilebackup2_error(device_link_service_client_free(client->parent));\n\t}\n\tfree(client);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdownd_client_free",
          "args": [
            "lockdown"
          ],
          "line": 2188
        },
        "resolved": true,
        "details": {
          "function_name": "lockdownd_client_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/lockdown.c",
          "lines": "322-336",
          "snippet": "LIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_client_free(lockdownd_client_t client)\n{\n\tif (!client)\n\t\treturn LOCKDOWN_E_INVALID_ARG;\n\n\tlockdownd_error_t ret = LOCKDOWN_E_UNKNOWN_ERROR;\n\n\tif (client->session_id) {\n\t\tlockdownd_stop_session(client, client->session_id);\n\t}\n\n\tret = lockdownd_client_free_simple(client);\n\n\treturn ret;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/userpref.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"lockdown.h\"",
            "#include \"property_list_service.h\"",
            "#include <plist/plist.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/x509.h>",
            "#include <libtasn1.h>",
            "#include <openssl/x509v3.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/pem.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/userpref.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"lockdown.h\"\n#include \"property_list_service.h\"\n#include <plist/plist.h>\n#include <gnutls/crypto.h>\n#include <gnutls/x509.h>\n#include <libtasn1.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/pem.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_client_free(lockdownd_client_t client)\n{\n\tif (!client)\n\t\treturn LOCKDOWN_E_INVALID_ARG;\n\n\tlockdownd_error_t ret = LOCKDOWN_E_UNKNOWN_ERROR;\n\n\tif (client->session_id) {\n\t\tlockdownd_stop_session(client, client->session_id);\n\t}\n\n\tret = lockdownd_client_free_simple(client);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ERROR: Could not start service %s.\\n\"",
            "MOBILEBACKUP2_SERVICE_NAME"
          ],
          "line": 2182
        },
        "resolved": true,
        "details": {
          "function_name": "asprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/include/asprintf.h",
          "lines": "23-31",
          "snippet": "static inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}",
          "includes": [
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <config.h>\n\nstatic inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_post_notification",
          "args": [
            "device",
            "NP_SYNC_DID_FINISH"
          ],
          "line": 2179
        },
        "resolved": true,
        "details": {
          "function_name": "do_post_notification",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
          "lines": "330-357",
          "snippet": "static void do_post_notification(idevice_t device, const char *notification)\n{\n\tlockdownd_service_descriptor_t service = NULL;\n\tnp_client_t np;\n\n\tlockdownd_client_t lockdown = NULL;\n\n\tif (lockdownd_client_new_with_handshake(device, &lockdown, \"idevicebackup2\") != LOCKDOWN_E_SUCCESS) {\n\t\treturn;\n\t}\n\n\tlockdownd_start_service(lockdown, NP_SERVICE_NAME, &service);\n\tif (service && service->port) {\n\t\tnp_client_new(device, service, &np);\n\t\tif (np) {\n\t\t\tnp_post_notification(np, notification);\n\t\t\tnp_client_free(np);\n\t\t}\n\t} else {\n\t\tprintf(\"Could not start %s\\n\", NP_SERVICE_NAME);\n\t}\n\n\tif (service) {\n\t\tlockdownd_service_descriptor_free(service);\n\t\tservice = NULL;\n\t}\n\tlockdownd_client_free(lockdown);\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <sys/statvfs.h>",
            "#include <termios.h>",
            "#include <conio.h>",
            "#include <windows.h>",
            "#include <endianness.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup2.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <libgen.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void do_post_notification(idevice_t device, const char *notification)\n{\n\tlockdownd_service_descriptor_t service = NULL;\n\tnp_client_t np;\n\n\tlockdownd_client_t lockdown = NULL;\n\n\tif (lockdownd_client_new_with_handshake(device, &lockdown, \"idevicebackup2\") != LOCKDOWN_E_SUCCESS) {\n\t\treturn;\n\t}\n\n\tlockdownd_start_service(lockdown, NP_SERVICE_NAME, &service);\n\tif (service && service->port) {\n\t\tnp_client_new(device, service, &np);\n\t\tif (np) {\n\t\t\tnp_post_notification(np, notification);\n\t\t\tnp_client_free(np);\n\t\t}\n\t} else {\n\t\tprintf(\"Could not start %s\\n\", NP_SERVICE_NAME);\n\t}\n\n\tif (service) {\n\t\tlockdownd_service_descriptor_free(service);\n\t\tservice = NULL;\n\t}\n\tlockdownd_client_free(lockdown);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afc_file_close",
          "args": [
            "afc",
            "lockfile"
          ],
          "line": 2176
        },
        "resolved": true,
        "details": {
          "function_name": "afc_file_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "749-775",
          "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_file_close(afc_client_t client, uint64_t handle)\n{\n\tuint32_t bytes = 0;\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tif (!client || (handle == 0))\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_lock(client);\n\n\tdebug_info(\"File handle %i\", handle);\n\n\t/* Send command */\n\tret = afc_dispatch_packet(client, AFC_OP_FILE_CLOSE, (const char*)&handle, 8, NULL, 0, &bytes);\n\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_UNKNOWN_ERROR;\n\t}\n\n\t/* Receive the response */\n\tret = afc_receive_data(client, NULL, &bytes);\n\n\tafc_unlock(client);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_file_close(afc_client_t client, uint64_t handle)\n{\n\tuint32_t bytes = 0;\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tif (!client || (handle == 0))\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_lock(client);\n\n\tdebug_info(\"File handle %i\", handle);\n\n\t/* Send command */\n\tret = afc_dispatch_packet(client, AFC_OP_FILE_CLOSE, (const char*)&handle, 8, NULL, 0, &bytes);\n\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_UNKNOWN_ERROR;\n\t}\n\n\t/* Receive the response */\n\tret = afc_receive_data(client, NULL, &bytes);\n\n\tafc_unlock(client);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afc_file_lock",
          "args": [
            "afc",
            "lockfile",
            "AFC_LOCK_UN"
          ],
          "line": 2175
        },
        "resolved": true,
        "details": {
          "function_name": "afc_file_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "777-809",
          "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_file_lock(afc_client_t client, uint64_t handle, afc_lock_op_t operation)\n{\n\tuint32_t bytes = 0;\n\tstruct {\n\t\tuint64_t handle;\n\t\tuint64_t op;\n\t} lockinfo;\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tif (!client || (handle == 0))\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_lock(client);\n\n\tdebug_info(\"file handle %i\", handle);\n\n\t/* Send command */\n\tlockinfo.handle = handle;\n\tlockinfo.op = htole64(operation);\n\tret = afc_dispatch_packet(client, AFC_OP_FILE_LOCK, (const char*)&lockinfo, sizeof(lockinfo), NULL, 0, &bytes);\n\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\tdebug_info(\"could not send lock command\");\n\t\treturn AFC_E_UNKNOWN_ERROR;\n\t}\n\t/* Receive the response */\n\tret = afc_receive_data(client, NULL, &bytes);\n\n\tafc_unlock(client);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_file_lock(afc_client_t client, uint64_t handle, afc_lock_op_t operation)\n{\n\tuint32_t bytes = 0;\n\tstruct {\n\t\tuint64_t handle;\n\t\tuint64_t op;\n\t} lockinfo;\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tif (!client || (handle == 0))\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_lock(client);\n\n\tdebug_info(\"file handle %i\", handle);\n\n\t/* Send command */\n\tlockinfo.handle = handle;\n\tlockinfo.op = htole64(operation);\n\tret = afc_dispatch_packet(client, AFC_OP_FILE_LOCK, (const char*)&lockinfo, sizeof(lockinfo), NULL, 0, &bytes);\n\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\tdebug_info(\"could not send lock command\");\n\t\treturn AFC_E_UNKNOWN_ERROR;\n\t}\n\t/* Receive the response */\n\tret = afc_receive_data(client, NULL, &bytes);\n\n\tafc_unlock(client);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"Operation Successful.\\n\""
          ],
          "line": 2169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"Operation Failed.\\n\""
          ],
          "line": 2167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"Operation Aborted.\\n\""
          ],
          "line": 2165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"Restore Failed (Error Code %d).\\n\"",
            "-result_code"
          ],
          "line": 2157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"Restore Successful.\\n\""
          ],
          "line": 2155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"The device should reboot now.\\n\""
          ],
          "line": 2153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"Could not change backup encryption password.\\n\""
          ],
          "line": 2147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"Backup encryption password has been changed successfully.\\n\""
          ],
          "line": 2145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"Could not disable backup encryption.\\n\""
          ],
          "line": 2141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"Backup encryption has been disabled successfully.\\n\""
          ],
          "line": 2139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"Could not enable backup encryption.\\n\""
          ],
          "line": 2135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"Backup encryption has been enabled successfully.\\n\""
          ],
          "line": 2133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"Unback Successful.\\n\""
          ],
          "line": 2127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"The files can now be found in the \\\"_unback_\\\" directory.\\n\""
          ],
          "line": 2126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"Unback Aborted.\\n\""
          ],
          "line": 2124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"Backup Failed (Error Code %d).\\n\"",
            "-result_code"
          ],
          "line": 2118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"Backup Aborted.\\n\""
          ],
          "line": 2116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"Backup Successful.\\n\""
          ],
          "line": 2113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb2_status_check_snapshot_state",
          "args": [
            "backup_directory",
            "udid",
            "\"finished\""
          ],
          "line": 2112
        },
        "resolved": true,
        "details": {
          "function_name": "mb2_status_check_snapshot_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
          "lines": "303-328",
          "snippet": "static int mb2_status_check_snapshot_state(const char *path, const char *udid, const char *matches)\n{\n\tint ret = -1;\n\tplist_t status_plist = NULL;\n\tchar *file_path = string_build_path(path, udid, \"Status.plist\", NULL);\n\n\tplist_read_from_filename(&status_plist, file_path);\n\tfree(file_path);\n\tif (!status_plist) {\n\t\tprintf(\"Could not read Status.plist!\\n\");\n\t\treturn ret;\n\t}\n\tplist_t node = plist_dict_get_item(status_plist, \"SnapshotState\");\n\tif (node && (plist_get_node_type(node) == PLIST_STRING)) {\n\t\tchar* sval = NULL;\n\t\tplist_get_string_val(node, &sval);\n\t\tif (sval) {\n\t\t\tret = (strcmp(sval, matches) == 0) ? 1 : 0;\n\t\t\tfree(sval);\n\t\t}\n\t} else {\n\t\tprintf(\"%s: ERROR could not get SnapshotState key from Status.plist!\\n\", __func__);\n\t}\n\tplist_free(status_plist);\n\treturn ret;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <sys/statvfs.h>",
            "#include <termios.h>",
            "#include <conio.h>",
            "#include <windows.h>",
            "#include <endianness.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup2.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <libgen.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int mb2_status_check_snapshot_state(const char *path, const char *udid, const char *matches)\n{\n\tint ret = -1;\n\tplist_t status_plist = NULL;\n\tchar *file_path = string_build_path(path, udid, \"Status.plist\", NULL);\n\n\tplist_read_from_filename(&status_plist, file_path);\n\tfree(file_path);\n\tif (!status_plist) {\n\t\tprintf(\"Could not read Status.plist!\\n\");\n\t\treturn ret;\n\t}\n\tplist_t node = plist_dict_get_item(status_plist, \"SnapshotState\");\n\tif (node && (plist_get_node_type(node) == PLIST_STRING)) {\n\t\tchar* sval = NULL;\n\t\tplist_get_string_val(node, &sval);\n\t\tif (sval) {\n\t\t\tret = (strcmp(sval, matches) == 0) ? 1 : 0;\n\t\t\tfree(sval);\n\t\t}\n\t} else {\n\t\tprintf(\"%s: ERROR could not get SnapshotState key from Status.plist!\\n\", __func__);\n\t}\n\tplist_free(status_plist);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"Received %d files from device.\\n\"",
            "file_count"
          ],
          "line": 2111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"Could not disable cloud backup.\\n\""
          ],
          "line": 2106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"Cloud backup has been disabled successfully.\\n\""
          ],
          "line": 2104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"Could not enable cloud backup.\\n\""
          ],
          "line": 2100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"Cloud backup has been enabled successfully.\\n\""
          ],
          "line": 2098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_free",
          "args": [
            "message"
          ],
          "line": 2074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\" Finished\\n\""
          ],
          "line": 2069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_progress_real",
          "args": [
            "overall_progress",
            "0"
          ],
          "line": 2068
        },
        "resolved": true,
        "details": {
          "function_name": "print_progress_real",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
          "lines": "359-377",
          "snippet": "static void print_progress_real(double progress, int flush)\n{\n\tint i = 0;\n\tPRINT_VERBOSE(1, \"\\r[\");\n\tfor(i = 0; i < 50; i++) {\n\t\tif(i < progress / 2) {\n\t\t\tPRINT_VERBOSE(1, \"=\");\n\t\t} else {\n\t\t\tPRINT_VERBOSE(1, \" \");\n\t\t}\n\t}\n\tPRINT_VERBOSE(1, \"] %3.0f%%\", progress);\n\n\tif (flush > 0) {\n\t\tfflush(stdout);\n\t\tif (progress == 100)\n\t\t\tPRINT_VERBOSE(1, \"\\n\");\n\t}\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <sys/statvfs.h>",
            "#include <termios.h>",
            "#include <conio.h>",
            "#include <windows.h>",
            "#include <endianness.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup2.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <libgen.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void print_progress_real(double progress, int flush)\n{\n\tint i = 0;\n\tPRINT_VERBOSE(1, \"\\r[\");\n\tfor(i = 0; i < 50; i++) {\n\t\tif(i < progress / 2) {\n\t\t\tPRINT_VERBOSE(1, \"=\");\n\t\t} else {\n\t\t\tPRINT_VERBOSE(1, \" \");\n\t\t}\n\t}\n\tPRINT_VERBOSE(1, \"] %3.0f%%\", progress);\n\n\tif (flush > 0) {\n\t\tfflush(stdout);\n\t\tif (progress == 100)\n\t\t\tPRINT_VERBOSE(1, \"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"Content:\\n\""
          ],
          "line": 2059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_string_val",
          "args": [
            "nn",
            "&str"
          ],
          "line": 2058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_node_type",
          "args": [
            "nn"
          ],
          "line": 2056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "node_tmp",
            "\"Content\""
          ],
          "line": 2055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_string_val",
          "args": [
            "nn",
            "&str"
          ],
          "line": 2043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_node_type",
          "args": [
            "nn"
          ],
          "line": 2042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "node_tmp",
            "\"ErrorDescription\""
          ],
          "line": 2040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_uint_val",
          "args": [
            "nn",
            "&ec"
          ],
          "line": 2031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_node_type",
          "args": [
            "nn"
          ],
          "line": 2029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "node_tmp",
            "\"ErrorCode\""
          ],
          "line": 2028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Unknown message received!\\n\""
          ],
          "line": 2024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_node_type",
          "args": [
            "node_tmp"
          ],
          "line": 2023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_array_get_item",
          "args": [
            "message",
            "1"
          ],
          "line": 2022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "dlmsg",
            "\"DLMessageProcessMessage\""
          ],
          "line": 2021
        },
        "resolved": true,
        "details": {
          "function_name": "plist_strcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
          "lines": "296-309",
          "snippet": "static int plist_strcmp(plist_t node, const char *str)\n{\n\tchar *buffer = NULL;\n\tint ret = 0;\n\n\tif (plist_get_node_type(node) != PLIST_STRING)\n\t\treturn ret;\n\n\tplist_get_string_val(node, &buffer);\n\tret = strcmp(buffer, str);\n\tfree(buffer);\n\n\treturn ret;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <unistd.h>",
            "#include <gcrypt.h>",
            "#include <openssl/sha.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int plist_strcmp(plist_t node, const char *str)\n{\n\tchar *buffer = NULL;\n\tint ret = 0;\n\n\tif (plist_get_node_type(node) != PLIST_STRING)\n\t\treturn ret;\n\n\tplist_get_string_val(node, &buffer);\n\tret = strcmp(buffer, str);\n\tfree(buffer);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_free",
          "args": [
            "empty_dict"
          ],
          "line": 2015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mobilebackup2_send_status_response",
          "args": [
            "mobilebackup2",
            "errcode",
            "errdesc",
            "empty_dict"
          ],
          "line": 2014
        },
        "resolved": true,
        "details": {
          "function_name": "mobilebackup2_send_status_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/mobilebackup2.c",
          "lines": "357-380",
          "snippet": "LIBIMOBILEDEVICE_API mobilebackup2_error_t mobilebackup2_send_status_response(mobilebackup2_client_t client, int status_code, const char *status1, plist_t status2)\n{\n\tif (!client || !client->parent)\n\t\treturn MOBILEBACKUP2_E_INVALID_ARG;\n\n\tplist_t array = plist_new_array();\n\tplist_array_append_item(array, plist_new_string(\"DLMessageStatusResponse\"));\n\tplist_array_append_item(array, plist_new_uint(status_code));\n\tif (status1) {\n\t\tplist_array_append_item(array, plist_new_string(status1));\n\t} else {\n\t\tplist_array_append_item(array, plist_new_string(\"___EmptyParameterString___\"));\n\t}\n\tif (status2) {\n\t\tplist_array_append_item(array, plist_copy(status2));\n\t} else {\n\t\tplist_array_append_item(array, plist_new_string(\"___EmptyParameterString___\"));\n\t}\n\n\tmobilebackup2_error_t err = mobilebackup2_error(device_link_service_send(client->parent, array));\n\tplist_free(array);\n\n\treturn err;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"device_link_service.h\"",
            "#include \"mobilebackup2.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <plist/plist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"device_link_service.h\"\n#include \"mobilebackup2.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <plist/plist.h>\n\nLIBIMOBILEDEVICE_API mobilebackup2_error_t mobilebackup2_send_status_response(mobilebackup2_client_t client, int status_code, const char *status1, plist_t status2)\n{\n\tif (!client || !client->parent)\n\t\treturn MOBILEBACKUP2_E_INVALID_ARG;\n\n\tplist_t array = plist_new_array();\n\tplist_array_append_item(array, plist_new_string(\"DLMessageStatusResponse\"));\n\tplist_array_append_item(array, plist_new_uint(status_code));\n\tif (status1) {\n\t\tplist_array_append_item(array, plist_new_string(status1));\n\t} else {\n\t\tplist_array_append_item(array, plist_new_string(\"___EmptyParameterString___\"));\n\t}\n\tif (status2) {\n\t\tplist_array_append_item(array, plist_copy(status2));\n\t} else {\n\t\tplist_array_append_item(array, plist_new_string(\"___EmptyParameterString___\"));\n\t}\n\n\tmobilebackup2_error_t err = mobilebackup2_error(device_link_service_send(client->parent, array));\n\tplist_free(array);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_new_dict",
          "args": [],
          "line": 2013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb2_copy_file_by_path",
          "args": [
            "oldpath",
            "newpath"
          ],
          "line": 2004
        },
        "resolved": true,
        "details": {
          "function_name": "mb2_copy_file_by_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
          "lines": "962-992",
          "snippet": "static void mb2_copy_file_by_path(const char *src, const char *dst)\n{\n\tFILE *from, *to;\n\tchar buf[BUFSIZ];\n\tsize_t length;\n\n\t/* open source file */\n\tif ((from = fopen(src, \"rb\")) == NULL) {\n\t\tprintf(\"Cannot open source path '%s'.\\n\", src);\n\t\treturn;\n\t}\n\n\t/* open destination file */\n\tif ((to = fopen(dst, \"wb\")) == NULL) {\n\t\tprintf(\"Cannot open destination file '%s'.\\n\", dst);\n\t\treturn;\n\t}\n\n\t/* copy the file */\n\twhile ((length = fread(buf, 1, BUFSIZ, from)) != 0) {\n\t\tfwrite(buf, 1, length, to);\n\t}\n\n\tif(fclose(from) == EOF) {\n\t\tprintf(\"Error closing source file.\\n\");\n\t}\n\n\tif(fclose(to) == EOF) {\n\t\tprintf(\"Error closing destination file.\\n\");\n\t}\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <sys/statvfs.h>",
            "#include <termios.h>",
            "#include <conio.h>",
            "#include <windows.h>",
            "#include <endianness.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup2.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <libgen.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void mb2_copy_file_by_path(const char *src, const char *dst)\n{\n\tFILE *from, *to;\n\tchar buf[BUFSIZ];\n\tsize_t length;\n\n\t/* open source file */\n\tif ((from = fopen(src, \"rb\")) == NULL) {\n\t\tprintf(\"Cannot open source path '%s'.\\n\", src);\n\t\treturn;\n\t}\n\n\t/* open destination file */\n\tif ((to = fopen(dst, \"wb\")) == NULL) {\n\t\tprintf(\"Cannot open destination file '%s'.\\n\", dst);\n\t\treturn;\n\t}\n\n\t/* copy the file */\n\twhile ((length = fread(buf, 1, BUFSIZ, from)) != 0) {\n\t\tfwrite(buf, 1, length, to);\n\t}\n\n\tif(fclose(from) == EOF) {\n\t\tprintf(\"Error closing source file.\\n\");\n\t}\n\n\tif(fclose(to) == EOF) {\n\t\tprintf(\"Error closing destination file.\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "st.st_mode"
          ],
          "line": 2003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "oldpath",
            "&st"
          ],
          "line": 2003
        },
        "resolved": true,
        "details": {
          "function_name": "mobilebackup_write_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
          "lines": "322-338",
          "snippet": "static void mobilebackup_write_status(const char *path, int status)\n{\n\tstruct stat st;\n\tplist_t status_plist = plist_new_dict();\n\tplist_dict_set_item(status_plist, \"Backup Success\", plist_new_bool(status));\n\tchar *file_path = mobilebackup_build_path(path, \"Status\", \".plist\");\n\n\tif (stat(file_path, &st) == 0)\n\t\tremove(file_path);\n\n\tplist_write_to_filename(status_plist, file_path, PLIST_FORMAT_XML);\n\n\tplist_free(status_plist);\n\tstatus_plist = NULL;\n\n\tfree(file_path);\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <unistd.h>",
            "#include <gcrypt.h>",
            "#include <openssl/sha.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void mobilebackup_write_status(const char *path, int status)\n{\n\tstruct stat st;\n\tplist_t status_plist = plist_new_dict();\n\tplist_dict_set_item(status_plist, \"Backup Success\", plist_new_bool(status));\n\tchar *file_path = mobilebackup_build_path(path, \"Status\", \".plist\");\n\n\tif (stat(file_path, &st) == 0)\n\t\tremove(file_path);\n\n\tplist_write_to_filename(status_plist, file_path, PLIST_FORMAT_XML);\n\n\tplist_free(status_plist);\n\tstatus_plist = NULL;\n\n\tfree(file_path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb2_copy_directory_by_path",
          "args": [
            "oldpath",
            "newpath"
          ],
          "line": 2002
        },
        "resolved": true,
        "details": {
          "function_name": "mb2_copy_directory_by_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
          "lines": "994-1037",
          "snippet": "static void mb2_copy_directory_by_path(const char *src, const char *dst)\n{\n\tif (!src || !dst) {\n\t\treturn;\n\t}\n\n\tstruct stat st;\n\n\t/* if src does not exist */\n\tif ((stat(src, &st) < 0) || !S_ISDIR(st.st_mode)) {\n\t\tprintf(\"ERROR: Source directory does not exist '%s': %s (%d)\\n\", src, strerror(errno), errno);\n\t\treturn;\n\t}\n\n\t/* if dst directory does not exist */\n\tif ((stat(dst, &st) < 0) || !S_ISDIR(st.st_mode)) {\n\t\t/* create it */\n\t\tif (mkdir_with_parents(dst, 0755) < 0) {\n\t\t\tprintf(\"ERROR: Unable to create destination directory '%s': %s (%d)\\n\", dst, strerror(errno), errno);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* loop over src directory contents */\n\tDIR *cur_dir = opendir(src);\n\tif (cur_dir) {\n\t\tstruct dirent* ep;\n\t\twhile ((ep = readdir(cur_dir))) {\n\t\t\tif ((strcmp(ep->d_name, \".\") == 0) || (strcmp(ep->d_name, \"..\") == 0)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tchar *srcpath = string_build_path(src, ep->d_name, NULL);\n\t\t\tchar *dstpath = string_build_path(dst, ep->d_name, NULL);\n\t\t\tif (srcpath && dstpath) {\n\t\t\t\t/* copy file */\n\t\t\t\tmb2_copy_file_by_path(srcpath, dstpath);\n\n\t\t\t\tfree(srcpath);\n\t\t\t\tfree(dstpath);\n\t\t\t}\n\t\t}\n\t\tclosedir(cur_dir);\n\t}\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <sys/statvfs.h>",
            "#include <termios.h>",
            "#include <conio.h>",
            "#include <windows.h>",
            "#include <endianness.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup2.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <libgen.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void mb2_copy_directory_by_path(const char *src, const char *dst)\n{\n\tif (!src || !dst) {\n\t\treturn;\n\t}\n\n\tstruct stat st;\n\n\t/* if src does not exist */\n\tif ((stat(src, &st) < 0) || !S_ISDIR(st.st_mode)) {\n\t\tprintf(\"ERROR: Source directory does not exist '%s': %s (%d)\\n\", src, strerror(errno), errno);\n\t\treturn;\n\t}\n\n\t/* if dst directory does not exist */\n\tif ((stat(dst, &st) < 0) || !S_ISDIR(st.st_mode)) {\n\t\t/* create it */\n\t\tif (mkdir_with_parents(dst, 0755) < 0) {\n\t\t\tprintf(\"ERROR: Unable to create destination directory '%s': %s (%d)\\n\", dst, strerror(errno), errno);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* loop over src directory contents */\n\tDIR *cur_dir = opendir(src);\n\tif (cur_dir) {\n\t\tstruct dirent* ep;\n\t\twhile ((ep = readdir(cur_dir))) {\n\t\t\tif ((strcmp(ep->d_name, \".\") == 0) || (strcmp(ep->d_name, \"..\") == 0)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tchar *srcpath = string_build_path(src, ep->d_name, NULL);\n\t\t\tchar *dstpath = string_build_path(dst, ep->d_name, NULL);\n\t\t\tif (srcpath && dstpath) {\n\t\t\t\t/* copy file */\n\t\t\t\tmb2_copy_file_by_path(srcpath, dstpath);\n\n\t\t\t\tfree(srcpath);\n\t\t\t\tfree(dstpath);\n\t\t\t}\n\t\t}\n\t\tclosedir(cur_dir);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "st.st_mode"
          ],
          "line": 2001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"Copying '%s' to '%s'\\n\"",
            "src",
            "dst"
          ],
          "line": 1998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "string_build_path",
          "args": [
            "backup_directory",
            "dst",
            "NULL"
          ],
          "line": 1996
        },
        "resolved": true,
        "details": {
          "function_name": "string_build_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/utils.c",
          "lines": "114-140",
          "snippet": "char *string_build_path(const char *elem, ...)\n{\n\tif (!elem)\n\t\treturn NULL;\n\tva_list args;\n\tint len = strlen(elem)+1;\n\tva_start(args, elem);\n\tchar *arg = va_arg(args, char*);\n\twhile (arg) {\n\t\tlen += strlen(arg)+1;\n\t\targ = va_arg(args, char*);\n\t}\n\tva_end(args);\n\n\tchar* out = (char*)malloc(len);\n\tstrcpy(out, elem);\n\n\tva_start(args, elem);\n\targ = va_arg(args, char*);\n\twhile (arg) {\n\t\tstrcat(out, \"/\");\n\t\tstrcat(out, arg);\n\t\targ = va_arg(args, char*);\n\t}\n\tva_end(args);\n\treturn out;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include <ctype.h>",
            "#include <inttypes.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include <ctype.h>\n#include <inttypes.h>\n#include <sys/time.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <config.h>\n\nchar *string_build_path(const char *elem, ...)\n{\n\tif (!elem)\n\t\treturn NULL;\n\tva_list args;\n\tint len = strlen(elem)+1;\n\tva_start(args, elem);\n\tchar *arg = va_arg(args, char*);\n\twhile (arg) {\n\t\tlen += strlen(arg)+1;\n\t\targ = va_arg(args, char*);\n\t}\n\tva_end(args);\n\n\tchar* out = (char*)malloc(len);\n\tstrcpy(out, elem);\n\n\tva_start(args, elem);\n\targ = va_arg(args, char*);\n\twhile (arg) {\n\t\tstrcat(out, \"/\");\n\t\tstrcat(out, arg);\n\t\targ = va_arg(args, char*);\n\t}\n\tva_end(args);\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_get_string_val",
          "args": [
            "dstpath",
            "&dst"
          ],
          "line": 1993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_string_val",
          "args": [
            "srcpath",
            "&src"
          ],
          "line": 1992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_node_type",
          "args": [
            "dstpath"
          ],
          "line": 1989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_node_type",
          "args": [
            "srcpath"
          ],
          "line": 1989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_array_get_item",
          "args": [
            "message",
            "2"
          ],
          "line": 1986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_array_get_item",
          "args": [
            "message",
            "1"
          ],
          "line": 1985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_free",
          "args": [
            "empty_dict"
          ],
          "line": 1980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_dict",
          "args": [],
          "line": 1978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errno_to_device_error",
          "args": [
            "errno"
          ],
          "line": 1970
        },
        "resolved": true,
        "details": {
          "function_name": "errno_to_device_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
          "lines": "441-451",
          "snippet": "static int errno_to_device_error(int errno_value)\n{\n\tswitch (errno_value) {\n\t\tcase ENOENT:\n\t\t\treturn -6;\n\t\tcase EEXIST:\n\t\t\treturn -7;\n\t\tdefault:\n\t\t\treturn -errno_value;\n\t}\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <sys/statvfs.h>",
            "#include <termios.h>",
            "#include <conio.h>",
            "#include <windows.h>",
            "#include <endianness.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup2.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <libgen.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int errno_to_device_error(int errno_value)\n{\n\tswitch (errno_value) {\n\t\tcase ENOENT:\n\t\t\treturn -6;\n\t\tcase EEXIST:\n\t\t\treturn -7;\n\t\tdefault:\n\t\t\treturn -errno_value;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove",
          "args": [
            "newpath"
          ],
          "line": 1967
        },
        "resolved": true,
        "details": {
          "function_name": "str_remove_spaces",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/lockdown.c",
          "lines": "1443-1453",
          "snippet": "static void str_remove_spaces(char *source)\n{\n\tchar *dest = source;\n\twhile (*source != 0) {\n\t\tif (!isspace(*source)) {\n\t\t\t*dest++ = *source; /* copy */\n\t\t}\n\t\tsource++;\n\t}\n\t*dest = 0;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/userpref.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"lockdown.h\"",
            "#include \"property_list_service.h\"",
            "#include <plist/plist.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/x509.h>",
            "#include <libtasn1.h>",
            "#include <openssl/x509v3.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/pem.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/userpref.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"lockdown.h\"\n#include \"property_list_service.h\"\n#include <plist/plist.h>\n#include <gnutls/crypto.h>\n#include <gnutls/x509.h>\n#include <libtasn1.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/pem.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nstatic void str_remove_spaces(char *source)\n{\n\tchar *dest = source;\n\twhile (*source != 0) {\n\t\tif (!isspace(*source)) {\n\t\t\t*dest++ = *source; /* copy */\n\t\t}\n\t\tsource++;\n\t}\n\t*dest = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "e"
          ],
          "line": 1964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "e"
          ],
          "line": 1962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "win32err_to_errno",
          "args": [
            "GetLastError()"
          ],
          "line": 1960
        },
        "resolved": true,
        "details": {
          "function_name": "win32err_to_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
          "lines": "454-464",
          "snippet": "static int win32err_to_errno(int err_value)\n{\n\tswitch (err_value) {\n\t\tcase ERROR_FILE_NOT_FOUND:\n\t\t\treturn ENOENT;\n\t\tcase ERROR_ALREADY_EXISTS:\n\t\t\treturn EEXIST;\n\t\tdefault:\n\t\t\treturn EFAULT;\n\t}\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <sys/statvfs.h>",
            "#include <termios.h>",
            "#include <conio.h>",
            "#include <windows.h>",
            "#include <endianness.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup2.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <libgen.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int win32err_to_errno(int err_value)\n{\n\tswitch (err_value) {\n\t\tcase ERROR_FILE_NOT_FOUND:\n\t\t\treturn ENOENT;\n\t\tcase ERROR_ALREADY_EXISTS:\n\t\t\treturn EEXIST;\n\t\tdefault:\n\t\t\treturn EFAULT;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetLastError",
          "args": [],
          "line": 1960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DeleteFile",
          "args": [
            "newpath"
          ],
          "line": 1958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RemoveDirectory",
          "args": [
            "newpath"
          ],
          "line": 1956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "st.st_mode"
          ],
          "line": 1955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "str",
            "'/'"
          ],
          "line": 1944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_string_val",
          "args": [
            "val",
            "&str"
          ],
          "line": 1942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_node_type",
          "args": [
            "val"
          ],
          "line": 1940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_array_get_item",
          "args": [
            "removes",
            "ii"
          ],
          "line": 1939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"Removing %d file%s\\n\"",
            "cnt",
            "(cnt == 1) ? \"\" : \"s\""
          ],
          "line": 1934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_array_get_size",
          "args": [
            "removes"
          ],
          "line": 1933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_array_get_item",
          "args": [
            "message",
            "1"
          ],
          "line": 1932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb2_set_overall_progress_from_message",
          "args": [
            "message",
            "dlmsg"
          ],
          "line": 1931
        },
        "resolved": true,
        "details": {
          "function_name": "mb2_set_overall_progress_from_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
          "lines": "411-430",
          "snippet": "static void mb2_set_overall_progress_from_message(plist_t message, char* identifier)\n{\n\tplist_t node = NULL;\n\tdouble progress = 0.0;\n\n\tif (!strcmp(identifier, \"DLMessageDownloadFiles\")) {\n\t\tnode = plist_array_get_item(message, 3);\n\t} else if (!strcmp(identifier, \"DLMessageUploadFiles\")) {\n\t\tnode = plist_array_get_item(message, 2);\n\t} else if (!strcmp(identifier, \"DLMessageMoveFiles\") || !strcmp(identifier, \"DLMessageMoveItems\")) {\n\t\tnode = plist_array_get_item(message, 3);\n\t} else if (!strcmp(identifier, \"DLMessageRemoveFiles\") || !strcmp(identifier, \"DLMessageRemoveItems\")) {\n\t\tnode = plist_array_get_item(message, 3);\n\t}\n\n\tif (node != NULL) {\n\t\tplist_get_real_val(node, &progress);\n\t\tmb2_set_overall_progress(progress);\n\t}\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <sys/statvfs.h>",
            "#include <termios.h>",
            "#include <conio.h>",
            "#include <windows.h>",
            "#include <endianness.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup2.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <libgen.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void mb2_set_overall_progress_from_message(plist_t message, char* identifier)\n{\n\tplist_t node = NULL;\n\tdouble progress = 0.0;\n\n\tif (!strcmp(identifier, \"DLMessageDownloadFiles\")) {\n\t\tnode = plist_array_get_item(message, 3);\n\t} else if (!strcmp(identifier, \"DLMessageUploadFiles\")) {\n\t\tnode = plist_array_get_item(message, 2);\n\t} else if (!strcmp(identifier, \"DLMessageMoveFiles\") || !strcmp(identifier, \"DLMessageMoveItems\")) {\n\t\tnode = plist_array_get_item(message, 3);\n\t} else if (!strcmp(identifier, \"DLMessageRemoveFiles\") || !strcmp(identifier, \"DLMessageRemoveItems\")) {\n\t\tnode = plist_array_get_item(message, 3);\n\t}\n\n\tif (node != NULL) {\n\t\tplist_get_real_val(node, &progress);\n\t\tmb2_set_overall_progress(progress);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_free",
          "args": [
            "empty_dict"
          ],
          "line": 1926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_dict",
          "args": [],
          "line": 1924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Could not create dict iterator\\n\""
          ],
          "line": 1922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rename",
          "args": [
            "oldpath",
            "newpath"
          ],
          "line": 1905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DeleteFile",
          "args": [
            "newpath"
          ],
          "line": 1901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RemoveDirectory",
          "args": [
            "newpath"
          ],
          "line": 1899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "st.st_mode"
          ],
          "line": 1898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_string_val",
          "args": [
            "val",
            "&str"
          ],
          "line": 1891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_node_type",
          "args": [
            "val"
          ],
          "line": 1889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_next_item",
          "args": [
            "moves",
            "iter",
            "&key",
            "&val"
          ],
          "line": 1888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_new_iter",
          "args": [
            "moves",
            "&iter"
          ],
          "line": 1881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"Moving %d file%s\\n\"",
            "cnt",
            "(cnt == 1) ? \"\" : \"s\""
          ],
          "line": 1879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_size",
          "args": [
            "moves"
          ],
          "line": 1878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_array_get_item",
          "args": [
            "message",
            "1"
          ],
          "line": 1877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb2_handle_make_directory",
          "args": [
            "mobilebackup2",
            "message",
            "backup_directory"
          ],
          "line": 1873
        },
        "resolved": true,
        "details": {
          "function_name": "mb2_handle_make_directory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
          "lines": "935-960",
          "snippet": "static void mb2_handle_make_directory(mobilebackup2_client_t mobilebackup2, plist_t message, const char *backup_dir)\n{\n\tif (!message || (plist_get_node_type(message) != PLIST_ARRAY) || plist_array_get_size(message) < 2 || !backup_dir) return;\n\n\tplist_t dir = plist_array_get_item(message, 1);\n\tchar *str = NULL;\n\tint errcode = 0;\n\tchar *errdesc = NULL;\n\tplist_get_string_val(dir, &str);\n\n\tchar *newpath = string_build_path(backup_dir, str, NULL);\n\tfree(str);\n\n\tif (mkdir_with_parents(newpath, 0755) < 0) {\n\t\terrdesc = strerror(errno);\n\t\tif (errno != EEXIST) {\n\t\t\tprintf(\"mkdir: %s (%d)\\n\", errdesc, errno);\n\t\t}\n\t\terrcode = errno_to_device_error(errno);\n\t}\n\tfree(newpath);\n\tmobilebackup2_error_t err = mobilebackup2_send_status_response(mobilebackup2, errcode, errdesc, NULL);\n\tif (err != MOBILEBACKUP2_E_SUCCESS) {\n\t\tprintf(\"Could not send status response, error %d\\n\", err);\n\t}\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <sys/statvfs.h>",
            "#include <termios.h>",
            "#include <conio.h>",
            "#include <windows.h>",
            "#include <endianness.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup2.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <libgen.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void mb2_handle_make_directory(mobilebackup2_client_t mobilebackup2, plist_t message, const char *backup_dir)\n{\n\tif (!message || (plist_get_node_type(message) != PLIST_ARRAY) || plist_array_get_size(message) < 2 || !backup_dir) return;\n\n\tplist_t dir = plist_array_get_item(message, 1);\n\tchar *str = NULL;\n\tint errcode = 0;\n\tchar *errdesc = NULL;\n\tplist_get_string_val(dir, &str);\n\n\tchar *newpath = string_build_path(backup_dir, str, NULL);\n\tfree(str);\n\n\tif (mkdir_with_parents(newpath, 0755) < 0) {\n\t\terrdesc = strerror(errno);\n\t\tif (errno != EEXIST) {\n\t\t\tprintf(\"mkdir: %s (%d)\\n\", errdesc, errno);\n\t\t}\n\t\terrcode = errno_to_device_error(errno);\n\t}\n\tfree(newpath);\n\tmobilebackup2_error_t err = mobilebackup2_send_status_response(mobilebackup2, errcode, errdesc, NULL);\n\tif (err != MOBILEBACKUP2_E_SUCCESS) {\n\t\tprintf(\"Could not send status response, error %d\\n\", err);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb2_handle_list_directory",
          "args": [
            "mobilebackup2",
            "message",
            "backup_directory"
          ],
          "line": 1870
        },
        "resolved": true,
        "details": {
          "function_name": "mb2_handle_list_directory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
          "lines": "877-933",
          "snippet": "static void mb2_handle_list_directory(mobilebackup2_client_t mobilebackup2, plist_t message, const char *backup_dir)\n{\n\tif (!message || (plist_get_node_type(message) != PLIST_ARRAY) || plist_array_get_size(message) < 2 || !backup_dir) return;\n\n\tplist_t node = plist_array_get_item(message, 1);\n\tchar *str = NULL;\n\tif (plist_get_node_type(node) == PLIST_STRING) {\n\t\tplist_get_string_val(node, &str);\n\t}\n\tif (!str) {\n\t\tprintf(\"ERROR: Malformed DLContentsOfDirectory message\\n\");\n\t\t// TODO error handling\n\t\treturn;\n\t}\n\n\tchar *path = string_build_path(backup_dir, str, NULL);\n\tfree(str);\n\n\tplist_t dirlist = plist_new_dict();\n\n\tDIR* cur_dir = opendir(path);\n\tif (cur_dir) {\n\t\tstruct dirent* ep;\n\t\twhile ((ep = readdir(cur_dir))) {\n\t\t\tif ((strcmp(ep->d_name, \".\") == 0) || (strcmp(ep->d_name, \"..\") == 0)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tchar *fpath = string_build_path(path, ep->d_name, NULL);\n\t\t\tif (fpath) {\n\t\t\t\tplist_t fdict = plist_new_dict();\n\t\t\t\tstruct stat st;\n\t\t\t\tstat(fpath, &st);\n\t\t\t\tconst char *ftype = \"DLFileTypeUnknown\";\n\t\t\t\tif (S_ISDIR(st.st_mode)) {\n\t\t\t\t\tftype = \"DLFileTypeDirectory\";\n\t\t\t\t} else if (S_ISREG(st.st_mode)) {\n\t\t\t\t\tftype = \"DLFileTypeRegular\";\n\t\t\t\t}\n\t\t\t\tplist_dict_set_item(fdict, \"DLFileType\", plist_new_string(ftype));\n\t\t\t\tplist_dict_set_item(fdict, \"DLFileSize\", plist_new_uint(st.st_size));\n\t\t\t\tplist_dict_set_item(fdict, \"DLFileModificationDate\", plist_new_date(st.st_mtime, 0));\n\n\t\t\t\tplist_dict_set_item(dirlist, ep->d_name, fdict);\n\t\t\t\tfree(fpath);\n\t\t\t}\n\t\t}\n\t\tclosedir(cur_dir);\n\t}\n\tfree(path);\n\n\t/* TODO error handling */\n\tmobilebackup2_error_t err = mobilebackup2_send_status_response(mobilebackup2, 0, NULL, dirlist);\n\tplist_free(dirlist);\n\tif (err != MOBILEBACKUP2_E_SUCCESS) {\n\t\tprintf(\"Could not send status response, error %d\\n\", err);\n\t}\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <sys/statvfs.h>",
            "#include <termios.h>",
            "#include <conio.h>",
            "#include <windows.h>",
            "#include <endianness.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup2.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <libgen.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void mb2_handle_list_directory(mobilebackup2_client_t mobilebackup2, plist_t message, const char *backup_dir)\n{\n\tif (!message || (plist_get_node_type(message) != PLIST_ARRAY) || plist_array_get_size(message) < 2 || !backup_dir) return;\n\n\tplist_t node = plist_array_get_item(message, 1);\n\tchar *str = NULL;\n\tif (plist_get_node_type(node) == PLIST_STRING) {\n\t\tplist_get_string_val(node, &str);\n\t}\n\tif (!str) {\n\t\tprintf(\"ERROR: Malformed DLContentsOfDirectory message\\n\");\n\t\t// TODO error handling\n\t\treturn;\n\t}\n\n\tchar *path = string_build_path(backup_dir, str, NULL);\n\tfree(str);\n\n\tplist_t dirlist = plist_new_dict();\n\n\tDIR* cur_dir = opendir(path);\n\tif (cur_dir) {\n\t\tstruct dirent* ep;\n\t\twhile ((ep = readdir(cur_dir))) {\n\t\t\tif ((strcmp(ep->d_name, \".\") == 0) || (strcmp(ep->d_name, \"..\") == 0)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tchar *fpath = string_build_path(path, ep->d_name, NULL);\n\t\t\tif (fpath) {\n\t\t\t\tplist_t fdict = plist_new_dict();\n\t\t\t\tstruct stat st;\n\t\t\t\tstat(fpath, &st);\n\t\t\t\tconst char *ftype = \"DLFileTypeUnknown\";\n\t\t\t\tif (S_ISDIR(st.st_mode)) {\n\t\t\t\t\tftype = \"DLFileTypeDirectory\";\n\t\t\t\t} else if (S_ISREG(st.st_mode)) {\n\t\t\t\t\tftype = \"DLFileTypeRegular\";\n\t\t\t\t}\n\t\t\t\tplist_dict_set_item(fdict, \"DLFileType\", plist_new_string(ftype));\n\t\t\t\tplist_dict_set_item(fdict, \"DLFileSize\", plist_new_uint(st.st_size));\n\t\t\t\tplist_dict_set_item(fdict, \"DLFileModificationDate\", plist_new_date(st.st_mtime, 0));\n\n\t\t\t\tplist_dict_set_item(dirlist, ep->d_name, fdict);\n\t\t\t\tfree(fpath);\n\t\t\t}\n\t\t}\n\t\tclosedir(cur_dir);\n\t}\n\tfree(path);\n\n\t/* TODO error handling */\n\tmobilebackup2_error_t err = mobilebackup2_send_status_response(mobilebackup2, 0, NULL, dirlist);\n\tplist_free(dirlist);\n\tif (err != MOBILEBACKUP2_E_SUCCESS) {\n\t\tprintf(\"Could not send status response, error %d\\n\", err);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_free",
          "args": [
            "freespace_item"
          ],
          "line": 1867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_uint",
          "args": [
            "freespace"
          ],
          "line": 1865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "statvfs",
          "args": [
            "backup_directory",
            "&fs"
          ],
          "line": 1860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&fs",
            "'\\0'",
            "sizeof(fs)"
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDiskFreeSpaceEx",
          "args": [
            "backup_directory",
            "(PULARGE_INTEGER)&freespace",
            "NULL",
            "NULL"
          ],
          "line": 1854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb2_handle_receive_files",
          "args": [
            "mobilebackup2",
            "message",
            "backup_directory"
          ],
          "line": 1848
        },
        "resolved": true,
        "details": {
          "function_name": "mb2_handle_receive_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
          "lines": "711-875",
          "snippet": "static int mb2_handle_receive_files(mobilebackup2_client_t mobilebackup2, plist_t message, const char *backup_dir)\n{\n\tuint64_t backup_real_size = 0;\n\tuint64_t backup_total_size = 0;\n\tuint32_t blocksize;\n\tuint32_t bdone;\n\tuint32_t rlen;\n\tuint32_t nlen = 0;\n\tuint32_t r;\n\tchar buf[32768];\n\tchar *fname = NULL;\n\tchar *dname = NULL;\n\tchar *bname = NULL;\n\tchar code = 0;\n\tchar last_code = 0;\n\tplist_t node = NULL;\n\tFILE *f = NULL;\n\tunsigned int file_count = 0;\n\n\tif (!message || (plist_get_node_type(message) != PLIST_ARRAY) || plist_array_get_size(message) < 4 || !backup_dir) return 0;\n\n\tnode = plist_array_get_item(message, 3);\n\tif (plist_get_node_type(node) == PLIST_UINT) {\n\t\tplist_get_uint_val(node, &backup_total_size);\n\t}\n\tif (backup_total_size > 0) {\n\t\tPRINT_VERBOSE(1, \"Receiving files\\n\");\n\t}\n\n\tdo {\n\t\tif (quit_flag)\n\t\t\tbreak;\n\n\t\tnlen = mb2_receive_filename(mobilebackup2, &dname);\n\t\tif (nlen == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tnlen = mb2_receive_filename(mobilebackup2, &fname);\n\t\tif (!nlen) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (bname != NULL) {\n\t\t\tfree(bname);\n\t\t\tbname = NULL;\n\t\t}\n\n\t\tbname = string_build_path(backup_dir, fname, NULL);\n\n\t\tif (fname != NULL) {\n\t\t\tfree(fname);\n\t\t\tfname = NULL;\n\t\t}\n\n\t\tr = 0;\n\t\tnlen = 0;\n\t\tmobilebackup2_receive_raw(mobilebackup2, (char*)&nlen, 4, &r);\n\t\tif (r != 4) {\n\t\t\tprintf(\"ERROR: %s: could not receive code length!\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\t\tnlen = be32toh(nlen);\n\n\t\tlast_code = code;\n\t\tcode = 0;\n\n\t\tmobilebackup2_receive_raw(mobilebackup2, &code, 1, &r);\n\t\tif (r != 1) {\n\t\t\tprintf(\"ERROR: %s: could not receive code!\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* TODO remove this */\n\t\tif ((code != CODE_SUCCESS) && (code != CODE_FILE_DATA) && (code != CODE_ERROR_REMOTE)) {\n\t\t\tPRINT_VERBOSE(1, \"Found new flag %02x\\n\", code);\n\t\t}\n\n\t\tremove(bname);\n\t\tf = fopen(bname, \"wb\");\n\t\twhile (f && (code == CODE_FILE_DATA)) {\n\t\t\tblocksize = nlen-1;\n\t\t\tbdone = 0;\n\t\t\trlen = 0;\n\t\t\twhile (bdone < blocksize) {\n\t\t\t\tif ((blocksize - bdone) < sizeof(buf)) {\n\t\t\t\t\trlen = blocksize - bdone;\n\t\t\t\t} else {\n\t\t\t\t\trlen = sizeof(buf);\n\t\t\t\t}\n\t\t\t\tmobilebackup2_receive_raw(mobilebackup2, buf, rlen, &r);\n\t\t\t\tif ((int)r <= 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfwrite(buf, 1, r, f);\n\t\t\t\tbdone += r;\n\t\t\t}\n\t\t\tif (bdone == blocksize) {\n\t\t\t\tbackup_real_size += blocksize;\n\t\t\t}\n\t\t\tif (backup_total_size > 0) {\n\t\t\t\tprint_progress(backup_real_size, backup_total_size);\n\t\t\t}\n\t\t\tif (quit_flag)\n\t\t\t\tbreak;\n\t\t\tnlen = 0;\n\t\t\tmobilebackup2_receive_raw(mobilebackup2, (char*)&nlen, 4, &r);\n\t\t\tnlen = be32toh(nlen);\n\t\t\tif (nlen > 0) {\n\t\t\t\tlast_code = code;\n\t\t\t\tmobilebackup2_receive_raw(mobilebackup2, &code, 1, &r);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (f) {\n\t\t\tfclose(f);\n\t\t\tfile_count++;\n\t\t} else {\n\t\t\tprintf(\"Error opening '%s' for writing: %s\\n\", bname, strerror(errno));\n\t\t}\n\t\tif (nlen == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\t/* check if an error message was received */\n\t\tif (code == CODE_ERROR_REMOTE) {\n\t\t\t/* error message */\n\t\t\tchar *msg = (char*)malloc(nlen);\n\t\t\tmobilebackup2_receive_raw(mobilebackup2, msg, nlen-1, &r);\n\t\t\tmsg[r] = 0;\n\t\t\t/* If sent using CODE_FILE_DATA, end marker will be CODE_ERROR_REMOTE which is not an error! */\n\t\t\tif (last_code != CODE_FILE_DATA) {\n\t\t\t\tfprintf(stdout, \"\\nReceived an error message from device: %s\\n\", msg);\n\t\t\t}\n\t\t\tfree(msg);\n\t\t}\n\t} while (1);\n\n\tif (fname != NULL)\n\t\tfree(fname);\n\n\t/* if there are leftovers to read, finish up cleanly */\n\tif ((int)nlen-1 > 0) {\n\t\tPRINT_VERBOSE(1, \"\\nDiscarding current data hunk.\\n\");\n\t\tfname = (char*)malloc(nlen-1);\n\t\tmobilebackup2_receive_raw(mobilebackup2, fname, nlen-1, &r);\n\t\tfree(fname);\n\t\tremove(bname);\n\t}\n\n\t/* clean up */\n\tif (bname != NULL)\n\t\tfree(bname);\n\n\tif (dname != NULL)\n\t\tfree(dname);\n\n\t// TODO error handling?!\n\tplist_t empty_plist = plist_new_dict();\n\tmobilebackup2_send_status_response(mobilebackup2, 0, NULL, empty_plist);\n\tplist_free(empty_plist);\n\n\treturn file_count;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <sys/statvfs.h>",
            "#include <termios.h>",
            "#include <conio.h>",
            "#include <windows.h>",
            "#include <endianness.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup2.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <libgen.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define CODE_FILE_DATA 0x0c",
            "#define CODE_ERROR_REMOTE 0x0b",
            "#define CODE_SUCCESS 0x00"
          ],
          "globals_used": [
            "static int quit_flag = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\n#define CODE_FILE_DATA 0x0c\n#define CODE_ERROR_REMOTE 0x0b\n#define CODE_SUCCESS 0x00\n\nstatic int quit_flag = 0;\n\nstatic int mb2_handle_receive_files(mobilebackup2_client_t mobilebackup2, plist_t message, const char *backup_dir)\n{\n\tuint64_t backup_real_size = 0;\n\tuint64_t backup_total_size = 0;\n\tuint32_t blocksize;\n\tuint32_t bdone;\n\tuint32_t rlen;\n\tuint32_t nlen = 0;\n\tuint32_t r;\n\tchar buf[32768];\n\tchar *fname = NULL;\n\tchar *dname = NULL;\n\tchar *bname = NULL;\n\tchar code = 0;\n\tchar last_code = 0;\n\tplist_t node = NULL;\n\tFILE *f = NULL;\n\tunsigned int file_count = 0;\n\n\tif (!message || (plist_get_node_type(message) != PLIST_ARRAY) || plist_array_get_size(message) < 4 || !backup_dir) return 0;\n\n\tnode = plist_array_get_item(message, 3);\n\tif (plist_get_node_type(node) == PLIST_UINT) {\n\t\tplist_get_uint_val(node, &backup_total_size);\n\t}\n\tif (backup_total_size > 0) {\n\t\tPRINT_VERBOSE(1, \"Receiving files\\n\");\n\t}\n\n\tdo {\n\t\tif (quit_flag)\n\t\t\tbreak;\n\n\t\tnlen = mb2_receive_filename(mobilebackup2, &dname);\n\t\tif (nlen == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tnlen = mb2_receive_filename(mobilebackup2, &fname);\n\t\tif (!nlen) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (bname != NULL) {\n\t\t\tfree(bname);\n\t\t\tbname = NULL;\n\t\t}\n\n\t\tbname = string_build_path(backup_dir, fname, NULL);\n\n\t\tif (fname != NULL) {\n\t\t\tfree(fname);\n\t\t\tfname = NULL;\n\t\t}\n\n\t\tr = 0;\n\t\tnlen = 0;\n\t\tmobilebackup2_receive_raw(mobilebackup2, (char*)&nlen, 4, &r);\n\t\tif (r != 4) {\n\t\t\tprintf(\"ERROR: %s: could not receive code length!\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\t\tnlen = be32toh(nlen);\n\n\t\tlast_code = code;\n\t\tcode = 0;\n\n\t\tmobilebackup2_receive_raw(mobilebackup2, &code, 1, &r);\n\t\tif (r != 1) {\n\t\t\tprintf(\"ERROR: %s: could not receive code!\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* TODO remove this */\n\t\tif ((code != CODE_SUCCESS) && (code != CODE_FILE_DATA) && (code != CODE_ERROR_REMOTE)) {\n\t\t\tPRINT_VERBOSE(1, \"Found new flag %02x\\n\", code);\n\t\t}\n\n\t\tremove(bname);\n\t\tf = fopen(bname, \"wb\");\n\t\twhile (f && (code == CODE_FILE_DATA)) {\n\t\t\tblocksize = nlen-1;\n\t\t\tbdone = 0;\n\t\t\trlen = 0;\n\t\t\twhile (bdone < blocksize) {\n\t\t\t\tif ((blocksize - bdone) < sizeof(buf)) {\n\t\t\t\t\trlen = blocksize - bdone;\n\t\t\t\t} else {\n\t\t\t\t\trlen = sizeof(buf);\n\t\t\t\t}\n\t\t\t\tmobilebackup2_receive_raw(mobilebackup2, buf, rlen, &r);\n\t\t\t\tif ((int)r <= 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfwrite(buf, 1, r, f);\n\t\t\t\tbdone += r;\n\t\t\t}\n\t\t\tif (bdone == blocksize) {\n\t\t\t\tbackup_real_size += blocksize;\n\t\t\t}\n\t\t\tif (backup_total_size > 0) {\n\t\t\t\tprint_progress(backup_real_size, backup_total_size);\n\t\t\t}\n\t\t\tif (quit_flag)\n\t\t\t\tbreak;\n\t\t\tnlen = 0;\n\t\t\tmobilebackup2_receive_raw(mobilebackup2, (char*)&nlen, 4, &r);\n\t\t\tnlen = be32toh(nlen);\n\t\t\tif (nlen > 0) {\n\t\t\t\tlast_code = code;\n\t\t\t\tmobilebackup2_receive_raw(mobilebackup2, &code, 1, &r);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (f) {\n\t\t\tfclose(f);\n\t\t\tfile_count++;\n\t\t} else {\n\t\t\tprintf(\"Error opening '%s' for writing: %s\\n\", bname, strerror(errno));\n\t\t}\n\t\tif (nlen == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\t/* check if an error message was received */\n\t\tif (code == CODE_ERROR_REMOTE) {\n\t\t\t/* error message */\n\t\t\tchar *msg = (char*)malloc(nlen);\n\t\t\tmobilebackup2_receive_raw(mobilebackup2, msg, nlen-1, &r);\n\t\t\tmsg[r] = 0;\n\t\t\t/* If sent using CODE_FILE_DATA, end marker will be CODE_ERROR_REMOTE which is not an error! */\n\t\t\tif (last_code != CODE_FILE_DATA) {\n\t\t\t\tfprintf(stdout, \"\\nReceived an error message from device: %s\\n\", msg);\n\t\t\t}\n\t\t\tfree(msg);\n\t\t}\n\t} while (1);\n\n\tif (fname != NULL)\n\t\tfree(fname);\n\n\t/* if there are leftovers to read, finish up cleanly */\n\tif ((int)nlen-1 > 0) {\n\t\tPRINT_VERBOSE(1, \"\\nDiscarding current data hunk.\\n\");\n\t\tfname = (char*)malloc(nlen-1);\n\t\tmobilebackup2_receive_raw(mobilebackup2, fname, nlen-1, &r);\n\t\tfree(fname);\n\t\tremove(bname);\n\t}\n\n\t/* clean up */\n\tif (bname != NULL)\n\t\tfree(bname);\n\n\tif (dname != NULL)\n\t\tfree(dname);\n\n\t// TODO error handling?!\n\tplist_t empty_plist = plist_new_dict();\n\tmobilebackup2_send_status_response(mobilebackup2, 0, NULL, empty_plist);\n\tplist_free(empty_plist);\n\n\treturn file_count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb2_handle_send_files",
          "args": [
            "mobilebackup2",
            "message",
            "backup_directory"
          ],
          "line": 1844
        },
        "resolved": true,
        "details": {
          "function_name": "mb2_handle_send_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
          "lines": "620-663",
          "snippet": "static void mb2_handle_send_files(mobilebackup2_client_t mobilebackup2, plist_t message, const char *backup_dir)\n{\n\tuint32_t cnt;\n\tuint32_t i = 0;\n\tuint32_t sent;\n\tplist_t errplist = NULL;\n\n\tif (!message || (plist_get_node_type(message) != PLIST_ARRAY) || (plist_array_get_size(message) < 2) || !backup_dir) return;\n\n\tplist_t files = plist_array_get_item(message, 1);\n\tcnt = plist_array_get_size(files);\n\n\tfor (i = 0; i < cnt; i++) {\n\t\tplist_t val = plist_array_get_item(files, i);\n\t\tif (plist_get_node_type(val) != PLIST_STRING) {\n\t\t\tcontinue;\n\t\t}\n\t\tchar *str = NULL;\n\t\tplist_get_string_val(val, &str);\n\t\tif (!str)\n\t\t\tcontinue;\n\n\t\tif (mb2_handle_send_file(mobilebackup2, backup_dir, str, &errplist) < 0) {\n\t\t\tfree(str);\n\t\t\t//printf(\"Error when sending file '%s' to device\\n\", str);\n\t\t\t// TODO: perhaps we can continue, we've got a multi status response?!\n\t\t\tbreak;\n\t\t}\n\t\tfree(str);\n\t}\n\n\t/* send terminating 0 dword */\n\tuint32_t zero = 0;\n\tmobilebackup2_send_raw(mobilebackup2, (char*)&zero, 4, &sent);\n\n\tif (!errplist) {\n\t\tplist_t emptydict = plist_new_dict();\n\t\tmobilebackup2_send_status_response(mobilebackup2, 0, NULL, emptydict);\n\t\tplist_free(emptydict);\n\t} else {\n\t\tmobilebackup2_send_status_response(mobilebackup2, -13, \"Multi status\", errplist);\n\t\tplist_free(errplist);\n\t}\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <sys/statvfs.h>",
            "#include <termios.h>",
            "#include <conio.h>",
            "#include <windows.h>",
            "#include <endianness.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup2.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <libgen.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void mb2_handle_send_files(mobilebackup2_client_t mobilebackup2, plist_t message, const char *backup_dir)\n{\n\tuint32_t cnt;\n\tuint32_t i = 0;\n\tuint32_t sent;\n\tplist_t errplist = NULL;\n\n\tif (!message || (plist_get_node_type(message) != PLIST_ARRAY) || (plist_array_get_size(message) < 2) || !backup_dir) return;\n\n\tplist_t files = plist_array_get_item(message, 1);\n\tcnt = plist_array_get_size(files);\n\n\tfor (i = 0; i < cnt; i++) {\n\t\tplist_t val = plist_array_get_item(files, i);\n\t\tif (plist_get_node_type(val) != PLIST_STRING) {\n\t\t\tcontinue;\n\t\t}\n\t\tchar *str = NULL;\n\t\tplist_get_string_val(val, &str);\n\t\tif (!str)\n\t\t\tcontinue;\n\n\t\tif (mb2_handle_send_file(mobilebackup2, backup_dir, str, &errplist) < 0) {\n\t\t\tfree(str);\n\t\t\t//printf(\"Error when sending file '%s' to device\\n\", str);\n\t\t\t// TODO: perhaps we can continue, we've got a multi status response?!\n\t\t\tbreak;\n\t\t}\n\t\tfree(str);\n\t}\n\n\t/* send terminating 0 dword */\n\tuint32_t zero = 0;\n\tmobilebackup2_send_raw(mobilebackup2, (char*)&zero, 4, &sent);\n\n\tif (!errplist) {\n\t\tplist_t emptydict = plist_new_dict();\n\t\tmobilebackup2_send_status_response(mobilebackup2, 0, NULL, emptydict);\n\t\tplist_free(emptydict);\n\t} else {\n\t\tmobilebackup2_send_status_response(mobilebackup2, -13, \"Multi status\", errplist);\n\t\tplist_free(errplist);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sleep",
          "args": [
            "2"
          ],
          "line": 1837
        },
        "resolved": true,
        "details": {
          "function_name": "diagnostics_relay_sleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/diagnostics_relay.c",
          "lines": "199-229",
          "snippet": "LIBIMOBILEDEVICE_API diagnostics_relay_error_t diagnostics_relay_sleep(diagnostics_relay_client_t client)\n{\n\tif (!client)\n\t\treturn DIAGNOSTICS_RELAY_E_INVALID_ARG;\n\n\tdiagnostics_relay_error_t ret = DIAGNOSTICS_RELAY_E_UNKNOWN_ERROR;\n\n\tplist_t dict = plist_new_dict();\n\n\tplist_dict_set_item(dict,\"Request\", plist_new_string(\"Sleep\"));\n\tret = diagnostics_relay_send(client, dict);\n\tplist_free(dict);\n\tdict = NULL;\n\n\tret = diagnostics_relay_receive(client, &dict);\n\tif (!dict) {\n\t\treturn DIAGNOSTICS_RELAY_E_PLIST_ERROR;\n\t}\n\n\tint check = diagnostics_relay_check_result(dict);\n\tif (check == RESULT_SUCCESS) {\n\t\tret = DIAGNOSTICS_RELAY_E_SUCCESS;\n\t} else if (check == RESULT_UNKNOWN_REQUEST) {\n\t\tret = DIAGNOSTICS_RELAY_E_UNKNOWN_REQUEST;\n\t} else {\n\t\tret = DIAGNOSTICS_RELAY_E_UNKNOWN_ERROR;\n\t}\n\n\tplist_free(dict);\n\treturn ret;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"property_list_service.h\"",
            "#include \"diagnostics_relay.h\"",
            "#include <stdlib.h>",
            "#include <string.h>"
          ],
          "macros_used": [
            "#define RESULT_UNKNOWN_REQUEST 2",
            "#define RESULT_SUCCESS 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"property_list_service.h\"\n#include \"diagnostics_relay.h\"\n#include <stdlib.h>\n#include <string.h>\n\n#define RESULT_UNKNOWN_REQUEST 2\n#define RESULT_SUCCESS 0\n\nLIBIMOBILEDEVICE_API diagnostics_relay_error_t diagnostics_relay_sleep(diagnostics_relay_client_t client)\n{\n\tif (!client)\n\t\treturn DIAGNOSTICS_RELAY_E_INVALID_ARG;\n\n\tdiagnostics_relay_error_t ret = DIAGNOSTICS_RELAY_E_UNKNOWN_ERROR;\n\n\tplist_t dict = plist_new_dict();\n\n\tplist_dict_set_item(dict,\"Request\", plist_new_string(\"Sleep\"));\n\tret = diagnostics_relay_send(client, dict);\n\tplist_free(dict);\n\tdict = NULL;\n\n\tret = diagnostics_relay_receive(client, &dict);\n\tif (!dict) {\n\t\treturn DIAGNOSTICS_RELAY_E_PLIST_ERROR;\n\t}\n\n\tint check = diagnostics_relay_check_result(dict);\n\tif (check == RESULT_SUCCESS) {\n\t\tret = DIAGNOSTICS_RELAY_E_SUCCESS;\n\t} else if (check == RESULT_UNKNOWN_REQUEST) {\n\t\tret = DIAGNOSTICS_RELAY_E_UNKNOWN_REQUEST;\n\t} else {\n\t\tret = DIAGNOSTICS_RELAY_E_UNKNOWN_ERROR;\n\t}\n\n\tplist_free(dict);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"Device is not ready yet. Going to try again in 2 seconds...\\n\""
          ],
          "line": 1836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mobilebackup2_receive_message",
          "args": [
            "mobilebackup2",
            "&message",
            "&dlmsg"
          ],
          "line": 1834
        },
        "resolved": true,
        "details": {
          "function_name": "mobilebackup2_receive_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/mobilebackup2.c",
          "lines": "210-213",
          "snippet": "LIBIMOBILEDEVICE_API mobilebackup2_error_t mobilebackup2_receive_message(mobilebackup2_client_t client, plist_t *msg_plist, char **dlmessage)\n{\n\treturn mobilebackup2_error(device_link_service_receive_message(client->parent, msg_plist, dlmessage));\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"device_link_service.h\"",
            "#include \"mobilebackup2.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <plist/plist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"device_link_service.h\"\n#include \"mobilebackup2.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <plist/plist.h>\n\nLIBIMOBILEDEVICE_API mobilebackup2_error_t mobilebackup2_receive_message(mobilebackup2_client_t client, plist_t *msg_plist, char **dlmessage)\n{\n\treturn mobilebackup2_error(device_link_service_receive_message(client->parent, msg_plist, dlmessage));\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_free",
          "args": [
            "opts"
          ],
          "line": 1806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mobilebackup2_send_message",
          "args": [
            "mobilebackup2",
            "\"ChangePassword\"",
            "opts"
          ],
          "line": 1796
        },
        "resolved": true,
        "details": {
          "function_name": "mobilebackup2_send_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/mobilebackup2.c",
          "lines": "112-142",
          "snippet": "LIBIMOBILEDEVICE_API mobilebackup2_error_t mobilebackup2_send_message(mobilebackup2_client_t client, const char *message, plist_t options)\n{\n\tif (!client || !client->parent || (!message && !options))\n\t\treturn MOBILEBACKUP2_E_INVALID_ARG;\n\n\tif (options && (plist_get_node_type(options) != PLIST_DICT)) {\n\t\treturn MOBILEBACKUP2_E_INVALID_ARG;\n\t}\n\n\tmobilebackup2_error_t err;\n\n\tif (message) {\n\t\tplist_t dict = NULL;\n\t\tif (options) {\n\t\t\tdict = plist_copy(options);\n\t\t} else {\n\t\t\tdict = plist_new_dict();\n\t\t}\n\t\tplist_dict_set_item(dict, \"MessageName\", plist_new_string(message));\n\n\t\t/* send it as DLMessageProcessMessage */\n\t\terr = mobilebackup2_error(device_link_service_send_process_message(client->parent, dict));\n\t\tplist_free(dict);\n\t} else {\n\t\terr = mobilebackup2_error(device_link_service_send_process_message(client->parent, options));\n\t}\n\tif (err != MOBILEBACKUP2_E_SUCCESS) {\n\t\tdebug_info(\"ERROR: Could not send message '%s' (%d)!\", message, err);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"device_link_service.h\"",
            "#include \"mobilebackup2.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <plist/plist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"device_link_service.h\"\n#include \"mobilebackup2.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <plist/plist.h>\n\nLIBIMOBILEDEVICE_API mobilebackup2_error_t mobilebackup2_send_message(mobilebackup2_client_t client, const char *message, plist_t options)\n{\n\tif (!client || !client->parent || (!message && !options))\n\t\treturn MOBILEBACKUP2_E_INVALID_ARG;\n\n\tif (options && (plist_get_node_type(options) != PLIST_DICT)) {\n\t\treturn MOBILEBACKUP2_E_INVALID_ARG;\n\t}\n\n\tmobilebackup2_error_t err;\n\n\tif (message) {\n\t\tplist_t dict = NULL;\n\t\tif (options) {\n\t\t\tdict = plist_copy(options);\n\t\t} else {\n\t\t\tdict = plist_new_dict();\n\t\t}\n\t\tplist_dict_set_item(dict, \"MessageName\", plist_new_string(message));\n\n\t\t/* send it as DLMessageProcessMessage */\n\t\terr = mobilebackup2_error(device_link_service_send_process_message(client->parent, dict));\n\t\tplist_free(dict);\n\t} else {\n\t\terr = mobilebackup2_error(device_link_service_send_process_message(client->parent, options));\n\t}\n\tif (err != MOBILEBACKUP2_E_SUCCESS) {\n\t\tdebug_info(\"ERROR: Could not send message '%s' (%d)!\", message, err);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "opts",
            "\"OldPassword\"",
            "plist_new_string(backup_password)"
          ],
          "line": 1793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_string",
          "args": [
            "backup_password"
          ],
          "line": 1793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "opts",
            "\"NewPassword\"",
            "plist_new_string(newpw)"
          ],
          "line": 1790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_string",
          "args": [
            "newpw"
          ],
          "line": 1790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ERROR: Backup encryption is not enabled so can't change password. Aborting.\\n\""
          ],
          "line": 1777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ask_for_password",
          "args": [
            "\"Enter new backup password\"",
            "1"
          ],
          "line": 1774
        },
        "resolved": true,
        "details": {
          "function_name": "ask_for_password",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
          "lines": "1080-1103",
          "snippet": "static char* ask_for_password(const char* msg, int type_again)\n{\n\tchar pwbuf[256];\n\n\tfprintf(stderr, \"%s: \", msg);\n\tfflush(stderr);\n\tget_hidden_input(pwbuf, 256);\n\tfputc('\\n', stderr);\n\n\tif (type_again) {\n\t\tchar pwrep[256];\n\n\t\tfprintf(stderr, \"%s (repeat): \", msg);\n\t\tfflush(stderr);\n\t\tget_hidden_input(pwrep, 256);\n\t\tfputc('\\n', stderr);\n\n\t\tif (strcmp(pwbuf, pwrep) != 0) {\n\t\t\tprintf(\"ERROR: passwords don't match\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn strdup(pwbuf);\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <sys/statvfs.h>",
            "#include <termios.h>",
            "#include <conio.h>",
            "#include <windows.h>",
            "#include <endianness.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup2.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <libgen.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic char* ask_for_password(const char* msg, int type_again)\n{\n\tchar pwbuf[256];\n\n\tfprintf(stderr, \"%s: \", msg);\n\tfflush(stderr);\n\tget_hidden_input(pwbuf, 256);\n\tfputc('\\n', stderr);\n\n\tif (type_again) {\n\t\tchar pwrep[256];\n\n\t\tfprintf(stderr, \"%s (repeat): \", msg);\n\t\tfflush(stderr);\n\t\tget_hidden_input(pwrep, 256);\n\t\tfputc('\\n', stderr);\n\n\t\tif (strcmp(pwbuf, pwrep) != 0) {\n\t\t\tprintf(\"ERROR: passwords don't match\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn strdup(pwbuf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ERROR: Backup encryption is not enabled. Aborting.\\n\""
          ],
          "line": 1763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ERROR: Backup encryption is already enabled. Aborting.\\n\""
          ],
          "line": 1750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"No backup password given. Aborting.\\n\""
          ],
          "line": 1747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "opts",
            "\"TargetIdentifier\"",
            "plist_new_string(udid)"
          ],
          "line": 1740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_string",
          "args": [
            "udid"
          ],
          "line": 1740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_dict",
          "args": [],
          "line": 1739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_free",
          "args": [
            "opts"
          ],
          "line": 1731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mobilebackup2_send_request",
          "args": [
            "mobilebackup2",
            "\"Unback\"",
            "udid",
            "source_udid",
            "opts"
          ],
          "line": 1729
        },
        "resolved": true,
        "details": {
          "function_name": "mobilebackup2_send_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/mobilebackup2.c",
          "lines": "326-355",
          "snippet": "LIBIMOBILEDEVICE_API mobilebackup2_error_t mobilebackup2_send_request(mobilebackup2_client_t client, const char *request, const char *target_identifier, const char *source_identifier, plist_t options)\n{\n\tif (!client || !client->parent || !request || !target_identifier)\n\t\treturn MOBILEBACKUP2_E_INVALID_ARG;\n\n\tplist_t dict = plist_new_dict();\n\tplist_dict_set_item(dict, \"TargetIdentifier\", plist_new_string(target_identifier));\n\tif (source_identifier) {\n\t\tplist_dict_set_item(dict, \"SourceIdentifier\", plist_new_string(source_identifier));\n\t}\n\tif (options) {\n\t\tplist_dict_set_item(dict, \"Options\", plist_copy(options));\n\t}\n\tif (!strcmp(request, \"Unback\") && options) {\n\t\tplist_t node = plist_dict_get_item(options, \"Password\");\n\t\tif (node) {\n\t\t\tplist_dict_set_item(dict, \"Password\", plist_copy(node));\n\t\t}\n\t}\n\tif (!strcmp(request, \"EnableCloudBackup\") && options) {\n\t\tplist_t node = plist_dict_get_item(options, \"CloudBackupState\");\n\t\tif (node) {\n\t\t\tplist_dict_set_item(dict, \"CloudBackupState\", plist_copy(node));\n\t\t}\n\t}\n\tmobilebackup2_error_t err = mobilebackup2_send_message(client, request, dict);\n\tplist_free(dict);\n\n\treturn err;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"device_link_service.h\"",
            "#include \"mobilebackup2.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <plist/plist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"device_link_service.h\"\n#include \"mobilebackup2.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <plist/plist.h>\n\nLIBIMOBILEDEVICE_API mobilebackup2_error_t mobilebackup2_send_request(mobilebackup2_client_t client, const char *request, const char *target_identifier, const char *source_identifier, plist_t options)\n{\n\tif (!client || !client->parent || !request || !target_identifier)\n\t\treturn MOBILEBACKUP2_E_INVALID_ARG;\n\n\tplist_t dict = plist_new_dict();\n\tplist_dict_set_item(dict, \"TargetIdentifier\", plist_new_string(target_identifier));\n\tif (source_identifier) {\n\t\tplist_dict_set_item(dict, \"SourceIdentifier\", plist_new_string(source_identifier));\n\t}\n\tif (options) {\n\t\tplist_dict_set_item(dict, \"Options\", plist_copy(options));\n\t}\n\tif (!strcmp(request, \"Unback\") && options) {\n\t\tplist_t node = plist_dict_get_item(options, \"Password\");\n\t\tif (node) {\n\t\t\tplist_dict_set_item(dict, \"Password\", plist_copy(node));\n\t\t}\n\t}\n\tif (!strcmp(request, \"EnableCloudBackup\") && options) {\n\t\tplist_t node = plist_dict_get_item(options, \"CloudBackupState\");\n\t\tif (node) {\n\t\t\tplist_dict_set_item(dict, \"CloudBackupState\", plist_copy(node));\n\t\t}\n\t}\n\tmobilebackup2_error_t err = mobilebackup2_send_message(client, request, dict);\n\tplist_free(dict);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"Backup password: %s\\n\"",
            "(backup_password == NULL ? \"No\":\"Yes\")"
          ],
          "line": 1728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "opts",
            "\"Password\"",
            "plist_new_string(backup_password)"
          ],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_string",
          "args": [
            "backup_password"
          ],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_dict",
          "args": [],
          "line": 1725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"Starting to unpack backup...\\n\""
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"Requesting backup list from device...\\n\""
          ],
          "line": 1715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"Requesting backup info from device...\\n\""
          ],
          "line": 1707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ERROR: Could not start restore process: unspecified error occured\\n\""
          ],
          "line": 1701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ERROR: Could not start restore process: device refused to start the restore process.\\n\""
          ],
          "line": 1699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ERROR: Could not start restore process: backup protocol version mismatch!\\n\""
          ],
          "line": 1697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_free",
          "args": [
            "opts"
          ],
          "line": 1694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"Backup password: %s\\n\"",
            "(backup_password == NULL ? \"No\":\"Yes\")"
          ],
          "line": 1691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "opts",
            "\"Password\"",
            "plist_new_string(backup_password)"
          ],
          "line": 1689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_string",
          "args": [
            "backup_password"
          ],
          "line": 1689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"Remove items that are not restored: %s\\n\"",
            "((cmd_flags & CMD_FLAG_RESTORE_REMOVE_ITEMS) ? \"Yes\":\"No\")"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "opts",
            "\"RemoveItemsNotRestored\"",
            "plist_new_bool(1)"
          ],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_bool",
          "args": [
            "1"
          ],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"Preserve settings of device: %s\\n\"",
            "((cmd_flags & CMD_FLAG_RESTORE_SETTINGS) == 0 ? \"Yes\":\"No\")"
          ],
          "line": 1684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "opts",
            "\"RestorePreserveSettings\"",
            "plist_new_bool((cmd_flags & CMD_FLAG_RESTORE_SETTINGS) == 0)"
          ],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_bool",
          "args": [
            "(cmd_flags & CMD_FLAG_RESTORE_SETTINGS) == 0"
          ],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"Don't copy backup: %s\\n\"",
            "((cmd_flags & CMD_FLAG_RESTORE_COPY_BACKUP) == 0 ? \"Yes\":\"No\")"
          ],
          "line": 1682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "opts",
            "\"RestoreDontCopyBackup\"",
            "plist_new_bool(1)"
          ],
          "line": 1681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_bool",
          "args": [
            "1"
          ],
          "line": 1681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"Rebooting after restore: %s\\n\"",
            "(cmd_flags & CMD_FLAG_RESTORE_REBOOT ? \"Yes\":\"No\")"
          ],
          "line": 1679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "opts",
            "\"RestoreShouldReboot\"",
            "plist_new_bool(0)"
          ],
          "line": 1678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_bool",
          "args": [
            "0"
          ],
          "line": 1678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"Restoring system files: %s\\n\"",
            "(cmd_flags & CMD_FLAG_RESTORE_SYSTEM_FILES ? \"Yes\":\"No\")"
          ],
          "line": 1676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "opts",
            "\"RestoreSystemFiles\"",
            "plist_new_bool(cmd_flags & CMD_FLAG_RESTORE_SYSTEM_FILES)"
          ],
          "line": 1675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_bool",
          "args": [
            "cmd_flags & CMD_FLAG_RESTORE_SYSTEM_FILES"
          ],
          "line": 1675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_dict",
          "args": [],
          "line": 1674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"Starting Restore...\\n\""
          ],
          "line": 1672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ERROR: Cannot ensure we restore from a successful backup. Aborting.\\n\""
          ],
          "line": 1667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ERROR: Could not start backup process: unspecified error occured\\n\""
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ERROR: Could not start backup process: device refused to start the backup process.\\n\""
          ],
          "line": 1655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ERROR: Could not start backup process: backup protocol version mismatch!\\n\""
          ],
          "line": 1653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"Incremental backup mode.\\n\""
          ],
          "line": 1649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"Full backup mode.\\n\""
          ],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_free",
          "args": [
            "opts"
          ],
          "line": 1644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"Requesting backup from device...\\n\""
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"Backup will be unencrypted.\\n\""
          ],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"Backup will be encrypted.\\n\""
          ],
          "line": 1637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "opts",
            "\"ForceFullBackup\"",
            "plist_new_bool(1)"
          ],
          "line": 1633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_bool",
          "args": [
            "1"
          ],
          "line": 1633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_dict",
          "args": [],
          "line": 1632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"Enforcing full backup from device.\\n\""
          ],
          "line": 1631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_free",
          "args": [
            "info_plist"
          ],
          "line": 1627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_write_to_filename",
          "args": [
            "info_plist",
            "info_path",
            "PLIST_FORMAT_XML"
          ],
          "line": 1624
        },
        "resolved": true,
        "details": {
          "function_name": "plist_write_to_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/utils.c",
          "lines": "270-290",
          "snippet": "int plist_write_to_filename(plist_t plist, const char *filename, enum plist_format_t format)\n{\n\tchar *buffer = NULL;\n\tuint32_t length;\n\n\tif (!plist || !filename)\n\t\treturn 0;\n\n\tif (format == PLIST_FORMAT_XML)\n\t\tplist_to_xml(plist, &buffer, &length);\n\telse if (format == PLIST_FORMAT_BINARY)\n\t\tplist_to_bin(plist, &buffer, &length);\n\telse\n\t\treturn 0;\n\n\tbuffer_write_to_filename(filename, buffer, length);\n\n\tfree(buffer);\n\n\treturn 1;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include <ctype.h>",
            "#include <inttypes.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include <ctype.h>\n#include <inttypes.h>\n#include <sys/time.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <config.h>\n\nint plist_write_to_filename(plist_t plist, const char *filename, enum plist_format_t format)\n{\n\tchar *buffer = NULL;\n\tuint32_t length;\n\n\tif (!plist || !filename)\n\t\treturn 0;\n\n\tif (format == PLIST_FORMAT_XML)\n\t\tplist_to_xml(plist, &buffer, &length);\n\telse if (format == PLIST_FORMAT_BINARY)\n\t\tplist_to_bin(plist, &buffer, &length);\n\telse\n\t\treturn 0;\n\n\tbuffer_write_to_filename(filename, buffer, length);\n\n\tfree(buffer);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mobilebackup_factory_info_plist_new",
          "args": [
            "udid",
            "lockdown",
            "afc"
          ],
          "line": 1622
        },
        "resolved": true,
        "details": {
          "function_name": "mobilebackup_factory_info_plist_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
          "lines": "195-301",
          "snippet": "static plist_t mobilebackup_factory_info_plist_new(const char* udid, lockdownd_client_t lockdown, afc_client_t afc)\n{\n\t/* gather data from lockdown */\n\tplist_t value_node = NULL;\n\tplist_t root_node = NULL;\n\tchar *udid_uppercase = NULL;\n\n\tplist_t ret = plist_new_dict();\n\n\t/* get basic device information in one go */\n\tlockdownd_get_value(lockdown, NULL, NULL, &root_node);\n\n\t/* set fields we understand */\n\tvalue_node = plist_dict_get_item(root_node, \"BuildVersion\");\n\tplist_dict_set_item(ret, \"Build Version\", plist_copy(value_node));\n\n\tvalue_node = plist_dict_get_item(root_node, \"DeviceName\");\n\tplist_dict_set_item(ret, \"Device Name\", plist_copy(value_node));\n\tplist_dict_set_item(ret, \"Display Name\", plist_copy(value_node));\n\n\t/* FIXME: How is the GUID generated? */\n\tplist_dict_set_item(ret, \"GUID\", plist_new_string(\"---\"));\n\n\tvalue_node = plist_dict_get_item(root_node, \"IntegratedCircuitCardIdentity\");\n\tif (value_node)\n\t\tplist_dict_set_item(ret, \"ICCID\", plist_copy(value_node));\n\n\tvalue_node = plist_dict_get_item(root_node, \"InternationalMobileEquipmentIdentity\");\n\tif (value_node)\n\t\tplist_dict_set_item(ret, \"IMEI\", plist_copy(value_node));\n\n\tplist_dict_set_item(ret, \"Last Backup Date\", plist_new_date(time(NULL), 0));\n\n\tvalue_node = plist_dict_get_item(root_node, \"PhoneNumber\");\n\tif (value_node && (plist_get_node_type(value_node) == PLIST_STRING)) {\n\t\tplist_dict_set_item(ret, \"Phone Number\", plist_copy(value_node));\n\t}\n\n\tvalue_node = plist_dict_get_item(root_node, \"ProductType\");\n\tplist_dict_set_item(ret, \"Product Type\", plist_copy(value_node));\n\n\tvalue_node = plist_dict_get_item(root_node, \"ProductVersion\");\n\tplist_dict_set_item(ret, \"Product Version\", plist_copy(value_node));\n\n\tvalue_node = plist_dict_get_item(root_node, \"SerialNumber\");\n\tplist_dict_set_item(ret, \"Serial Number\", plist_copy(value_node));\n\n\t/* FIXME Sync Settings? */\n\n\tvalue_node = plist_dict_get_item(root_node, \"UniqueDeviceID\");\n\tplist_dict_set_item(ret, \"Target Identifier\", plist_new_string(udid));\n\n\tplist_dict_set_item(ret, \"Target Type\", plist_new_string(\"Device\"));\n\n\t/* uppercase */\n\tudid_uppercase = string_toupper((char*)udid);\n\tplist_dict_set_item(ret, \"Unique Identifier\", plist_new_string(udid_uppercase));\n\tfree(udid_uppercase);\n\n\tchar *data_buf = NULL;\n\tuint64_t data_size = 0;\n\tmobilebackup_afc_get_file_contents(afc, \"/Books/iBooksData2.plist\", &data_buf, &data_size);\n\tif (data_buf) {\n\t\tplist_dict_set_item(ret, \"iBooks Data 2\", plist_new_data(data_buf, data_size));\n\t\tfree(data_buf);\n\t}\n\n\tplist_t files = plist_new_dict();\n\tconst char *itunesfiles[] = {\n\t\t\"ApertureAlbumPrefs\",\n\t\t\"IC-Info.sidb\",\n\t\t\"IC-Info.sidv\",\n\t\t\"PhotosFolderAlbums\",\n\t\t\"PhotosFolderName\",\n\t\t\"PhotosFolderPrefs\",\n\t\t\"iPhotoAlbumPrefs\",\n\t\t\"iTunesApplicationIDs\",\n\t\t\"iTunesPrefs\",\n\t\t\"iTunesPrefs.plist\",\n\t\tNULL\n\t};\n\tint i = 0;\n\tfor (i = 0; itunesfiles[i]; i++) {\n\t\tdata_buf = NULL;\n\t\tdata_size = 0;\n\t\tchar *fname = (char*)malloc(strlen(\"/iTunes_Control/iTunes/\") + strlen(itunesfiles[i]) + 1);\n\t\tstrcpy(fname, \"/iTunes_Control/iTunes/\");\n\t\tstrcat(fname, itunesfiles[i]);\n\t\tmobilebackup_afc_get_file_contents(afc, fname, &data_buf, &data_size);\n\t\tfree(fname);\n\t\tif (data_buf) {\n\t\t\tplist_dict_set_item(files, itunesfiles[i], plist_new_data(data_buf, data_size));\n\t\t\tfree(data_buf);\n\t\t}\n\t}\n\tplist_dict_set_item(ret, \"iTunes Files\", files);\n\n\tplist_t itunes_settings = NULL;\n\tlockdownd_get_value(lockdown, \"com.apple.iTunes\", NULL, &itunes_settings);\n\tplist_dict_set_item(ret, \"iTunes Settings\", itunes_settings ? itunes_settings : plist_new_dict());\n\n\tplist_dict_set_item(ret, \"iTunes Version\", plist_new_string(\"10.0.1\"));\n\n\tplist_free(root_node);\n\n\treturn ret;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <sys/statvfs.h>",
            "#include <termios.h>",
            "#include <conio.h>",
            "#include <windows.h>",
            "#include <endianness.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup2.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <libgen.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic plist_t mobilebackup_factory_info_plist_new(const char* udid, lockdownd_client_t lockdown, afc_client_t afc)\n{\n\t/* gather data from lockdown */\n\tplist_t value_node = NULL;\n\tplist_t root_node = NULL;\n\tchar *udid_uppercase = NULL;\n\n\tplist_t ret = plist_new_dict();\n\n\t/* get basic device information in one go */\n\tlockdownd_get_value(lockdown, NULL, NULL, &root_node);\n\n\t/* set fields we understand */\n\tvalue_node = plist_dict_get_item(root_node, \"BuildVersion\");\n\tplist_dict_set_item(ret, \"Build Version\", plist_copy(value_node));\n\n\tvalue_node = plist_dict_get_item(root_node, \"DeviceName\");\n\tplist_dict_set_item(ret, \"Device Name\", plist_copy(value_node));\n\tplist_dict_set_item(ret, \"Display Name\", plist_copy(value_node));\n\n\t/* FIXME: How is the GUID generated? */\n\tplist_dict_set_item(ret, \"GUID\", plist_new_string(\"---\"));\n\n\tvalue_node = plist_dict_get_item(root_node, \"IntegratedCircuitCardIdentity\");\n\tif (value_node)\n\t\tplist_dict_set_item(ret, \"ICCID\", plist_copy(value_node));\n\n\tvalue_node = plist_dict_get_item(root_node, \"InternationalMobileEquipmentIdentity\");\n\tif (value_node)\n\t\tplist_dict_set_item(ret, \"IMEI\", plist_copy(value_node));\n\n\tplist_dict_set_item(ret, \"Last Backup Date\", plist_new_date(time(NULL), 0));\n\n\tvalue_node = plist_dict_get_item(root_node, \"PhoneNumber\");\n\tif (value_node && (plist_get_node_type(value_node) == PLIST_STRING)) {\n\t\tplist_dict_set_item(ret, \"Phone Number\", plist_copy(value_node));\n\t}\n\n\tvalue_node = plist_dict_get_item(root_node, \"ProductType\");\n\tplist_dict_set_item(ret, \"Product Type\", plist_copy(value_node));\n\n\tvalue_node = plist_dict_get_item(root_node, \"ProductVersion\");\n\tplist_dict_set_item(ret, \"Product Version\", plist_copy(value_node));\n\n\tvalue_node = plist_dict_get_item(root_node, \"SerialNumber\");\n\tplist_dict_set_item(ret, \"Serial Number\", plist_copy(value_node));\n\n\t/* FIXME Sync Settings? */\n\n\tvalue_node = plist_dict_get_item(root_node, \"UniqueDeviceID\");\n\tplist_dict_set_item(ret, \"Target Identifier\", plist_new_string(udid));\n\n\tplist_dict_set_item(ret, \"Target Type\", plist_new_string(\"Device\"));\n\n\t/* uppercase */\n\tudid_uppercase = string_toupper((char*)udid);\n\tplist_dict_set_item(ret, \"Unique Identifier\", plist_new_string(udid_uppercase));\n\tfree(udid_uppercase);\n\n\tchar *data_buf = NULL;\n\tuint64_t data_size = 0;\n\tmobilebackup_afc_get_file_contents(afc, \"/Books/iBooksData2.plist\", &data_buf, &data_size);\n\tif (data_buf) {\n\t\tplist_dict_set_item(ret, \"iBooks Data 2\", plist_new_data(data_buf, data_size));\n\t\tfree(data_buf);\n\t}\n\n\tplist_t files = plist_new_dict();\n\tconst char *itunesfiles[] = {\n\t\t\"ApertureAlbumPrefs\",\n\t\t\"IC-Info.sidb\",\n\t\t\"IC-Info.sidv\",\n\t\t\"PhotosFolderAlbums\",\n\t\t\"PhotosFolderName\",\n\t\t\"PhotosFolderPrefs\",\n\t\t\"iPhotoAlbumPrefs\",\n\t\t\"iTunesApplicationIDs\",\n\t\t\"iTunesPrefs\",\n\t\t\"iTunesPrefs.plist\",\n\t\tNULL\n\t};\n\tint i = 0;\n\tfor (i = 0; itunesfiles[i]; i++) {\n\t\tdata_buf = NULL;\n\t\tdata_size = 0;\n\t\tchar *fname = (char*)malloc(strlen(\"/iTunes_Control/iTunes/\") + strlen(itunesfiles[i]) + 1);\n\t\tstrcpy(fname, \"/iTunes_Control/iTunes/\");\n\t\tstrcat(fname, itunesfiles[i]);\n\t\tmobilebackup_afc_get_file_contents(afc, fname, &data_buf, &data_size);\n\t\tfree(fname);\n\t\tif (data_buf) {\n\t\t\tplist_dict_set_item(files, itunesfiles[i], plist_new_data(data_buf, data_size));\n\t\t\tfree(data_buf);\n\t\t}\n\t}\n\tplist_dict_set_item(ret, \"iTunes Files\", files);\n\n\tplist_t itunes_settings = NULL;\n\tlockdownd_get_value(lockdown, \"com.apple.iTunes\", NULL, &itunes_settings);\n\tplist_dict_set_item(ret, \"iTunes Settings\", itunes_settings ? itunes_settings : plist_new_dict());\n\n\tplist_dict_set_item(ret, \"iTunes Version\", plist_new_string(\"10.0.1\"));\n\n\tplist_free(root_node);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_free",
          "args": [
            "info_plist"
          ],
          "line": 1619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mkdir",
          "args": [
            "devbackupdir",
            "0755"
          ],
          "line": 1606
        },
        "resolved": true,
        "details": {
          "function_name": "__mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
          "lines": "163-170",
          "snippet": "static int __mkdir(const char* path, int mode)\n{\n#ifdef WIN32\n\treturn mkdir(path);\n#else\n\treturn mkdir(path, mode);\n#endif\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <sys/statvfs.h>",
            "#include <termios.h>",
            "#include <conio.h>",
            "#include <windows.h>",
            "#include <endianness.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup2.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <libgen.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int __mkdir(const char* path, int mode)\n{\n#ifdef WIN32\n\treturn mkdir(path);\n#else\n\treturn mkdir(path, mode);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"Starting backup...\\n\""
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_free",
          "args": [
            "opts"
          ],
          "line": 1587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "opts",
            "\"CloudBackupState\"",
            "plist_new_bool(cmd_flags & CMD_FLAG_CLOUD_ENABLE ? 1: 0)"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_bool",
          "args": [
            "cmd_flags & CMD_FLAG_CLOUD_ENABLE ? 1: 0"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_dict",
          "args": [],
          "line": 1584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_free",
          "args": [
            "node_tmp"
          ],
          "line": 1576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_bool_val",
          "args": [
            "node_tmp",
            "&willEncrypt"
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_node_type",
          "args": [
            "node_tmp"
          ],
          "line": 1573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdownd_get_value",
          "args": [
            "lockdown",
            "\"com.apple.mobile.backup\"",
            "\"WillEncrypt\"",
            "&node_tmp"
          ],
          "line": 1571
        },
        "resolved": true,
        "details": {
          "function_name": "lockdownd_get_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/lockdown.c",
          "lines": "426-478",
          "snippet": "LIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_get_value(lockdownd_client_t client, const char *domain, const char *key, plist_t *value)\n{\n\tif (!client)\n\t\treturn LOCKDOWN_E_INVALID_ARG;\n\n\tplist_t dict = NULL;\n\tlockdownd_error_t ret = LOCKDOWN_E_UNKNOWN_ERROR;\n\n\t/* setup request plist */\n\tdict = plist_new_dict();\n\tplist_dict_add_label(dict, client->label);\n\tif (domain) {\n\t\tplist_dict_set_item(dict,\"Domain\", plist_new_string(domain));\n\t}\n\tif (key) {\n\t\tplist_dict_set_item(dict,\"Key\", plist_new_string(key));\n\t}\n\tplist_dict_set_item(dict,\"Request\", plist_new_string(\"GetValue\"));\n\n\t/* send to device */\n\tret = lockdownd_send(client, dict);\n\n\tplist_free(dict);\n\tdict = NULL;\n\n\tif (ret != LOCKDOWN_E_SUCCESS)\n\t\treturn ret;\n\n\t/* Now get device's answer */\n\tret = lockdownd_receive(client, &dict);\n\tif (ret != LOCKDOWN_E_SUCCESS)\n\t\treturn ret;\n\n\tret = lockdown_check_result(dict, \"GetValue\");\n\tif (ret == LOCKDOWN_E_SUCCESS) {\n\t\tdebug_info(\"success\");\n\t}\n\n\tif (ret != LOCKDOWN_E_SUCCESS) {\n\t\tplist_free(dict);\n\t\treturn ret;\n\t}\n\n\tplist_t value_node = plist_dict_get_item(dict, \"Value\");\n\n\tif (value_node) {\n\t\tdebug_info(\"has a value\");\n\t\t*value = plist_copy(value_node);\n\t}\n\n\tplist_free(dict);\n\treturn ret;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/userpref.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"lockdown.h\"",
            "#include \"property_list_service.h\"",
            "#include <plist/plist.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/x509.h>",
            "#include <libtasn1.h>",
            "#include <openssl/x509v3.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/pem.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/userpref.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"lockdown.h\"\n#include \"property_list_service.h\"\n#include <plist/plist.h>\n#include <gnutls/crypto.h>\n#include <gnutls/x509.h>\n#include <libtasn1.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/pem.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_get_value(lockdownd_client_t client, const char *domain, const char *key, plist_t *value)\n{\n\tif (!client)\n\t\treturn LOCKDOWN_E_INVALID_ARG;\n\n\tplist_t dict = NULL;\n\tlockdownd_error_t ret = LOCKDOWN_E_UNKNOWN_ERROR;\n\n\t/* setup request plist */\n\tdict = plist_new_dict();\n\tplist_dict_add_label(dict, client->label);\n\tif (domain) {\n\t\tplist_dict_set_item(dict,\"Domain\", plist_new_string(domain));\n\t}\n\tif (key) {\n\t\tplist_dict_set_item(dict,\"Key\", plist_new_string(key));\n\t}\n\tplist_dict_set_item(dict,\"Request\", plist_new_string(\"GetValue\"));\n\n\t/* send to device */\n\tret = lockdownd_send(client, dict);\n\n\tplist_free(dict);\n\tdict = NULL;\n\n\tif (ret != LOCKDOWN_E_SUCCESS)\n\t\treturn ret;\n\n\t/* Now get device's answer */\n\tret = lockdownd_receive(client, &dict);\n\tif (ret != LOCKDOWN_E_SUCCESS)\n\t\treturn ret;\n\n\tret = lockdown_check_result(dict, \"GetValue\");\n\tif (ret == LOCKDOWN_E_SUCCESS) {\n\t\tdebug_info(\"success\");\n\t}\n\n\tif (ret != LOCKDOWN_E_SUCCESS) {\n\t\tplist_free(dict);\n\t\treturn ret;\n\t}\n\n\tplist_t value_node = plist_dict_get_item(dict, \"Value\");\n\n\tif (value_node) {\n\t\tdebug_info(\"has a value\");\n\t\t*value = plist_copy(value_node);\n\t}\n\n\tplist_free(dict);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"ERROR: timeout while locking for sync\\n\""
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"ERROR: could not lock file! error code: %d\\n\"",
            "aerr"
          ],
          "line": 1556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "LOCK_WAIT"
          ],
          "line": 1553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afc_file_open",
          "args": [
            "afc",
            "\"/com.apple.itunes.lock_sync\"",
            "AFC_FOPEN_RW",
            "&lockfile"
          ],
          "line": 1542
        },
        "resolved": true,
        "details": {
          "function_name": "afc_file_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "616-662",
          "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_file_open(afc_client_t client, const char *filename, afc_file_mode_t file_mode, uint64_t *handle)\n{\n\tif (!client || !client->parent || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tuint64_t file_mode_loc = htole64(file_mode);\n\tuint32_t bytes = 0;\n\tchar *data = (char *) malloc(sizeof(char) * (8 + strlen(filename) + 1));\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\t/* set handle to 0 so in case an error occurs, the handle is invalid */\n\t*handle = 0;\n\n\tafc_lock(client);\n\n\t/* Send command */\n\tmemcpy(data, &file_mode_loc, 8);\n\tmemcpy(data + 8, filename, strlen(filename));\n\tdata[8 + strlen(filename)] = '\\0';\n\tret = afc_dispatch_packet(client, AFC_OP_FILE_OPEN, data, 8 + strlen(filename) + 1, NULL, 0, &bytes);\n\tfree(data);\n\n\tif (ret != AFC_E_SUCCESS) {\n\t\tdebug_info(\"Didn't receive a response to the command\");\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\t/* Receive the data */\n\tdata = NULL;\n\tret = afc_receive_data(client, &data, &bytes);\n\tif ((ret == AFC_E_SUCCESS) && (bytes > 0) && data) {\n\t\tafc_unlock(client);\n\n\t\t/* Get the file handle */\n\t\tmemcpy(handle, data, sizeof(uint64_t));\n\t\tfree(data);\n\t\treturn ret;\n\t}\n\t/* in case memory was allocated but no data received or an error occurred */\n\tfree(data);\n\n\tdebug_info(\"Didn't get any further data\");\n\n\tafc_unlock(client);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_file_open(afc_client_t client, const char *filename, afc_file_mode_t file_mode, uint64_t *handle)\n{\n\tif (!client || !client->parent || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tuint64_t file_mode_loc = htole64(file_mode);\n\tuint32_t bytes = 0;\n\tchar *data = (char *) malloc(sizeof(char) * (8 + strlen(filename) + 1));\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\t/* set handle to 0 so in case an error occurs, the handle is invalid */\n\t*handle = 0;\n\n\tafc_lock(client);\n\n\t/* Send command */\n\tmemcpy(data, &file_mode_loc, 8);\n\tmemcpy(data + 8, filename, strlen(filename));\n\tdata[8 + strlen(filename)] = '\\0';\n\tret = afc_dispatch_packet(client, AFC_OP_FILE_OPEN, data, 8 + strlen(filename) + 1, NULL, 0, &bytes);\n\tfree(data);\n\n\tif (ret != AFC_E_SUCCESS) {\n\t\tdebug_info(\"Didn't receive a response to the command\");\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\t/* Receive the data */\n\tdata = NULL;\n\tret = afc_receive_data(client, &data, &bytes);\n\tif ((ret == AFC_E_SUCCESS) && (bytes > 0) && data) {\n\t\tafc_unlock(client);\n\n\t\t/* Get the file handle */\n\t\tmemcpy(handle, data, sizeof(uint64_t));\n\t\tfree(data);\n\t\treturn ret;\n\t}\n\t/* in case memory was allocated but no data received or an error occurred */\n\tfree(data);\n\n\tdebug_info(\"Didn't get any further data\");\n\n\tafc_unlock(client);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Aborting restore. Info.plist is missing.\\n\""
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Could not read Info.plist\\n\""
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_read_from_filename",
          "args": [
            "&info_plist",
            "info_path"
          ],
          "line": 1524
        },
        "resolved": true,
        "details": {
          "function_name": "plist_read_from_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/utils.c",
          "lines": "245-268",
          "snippet": "int plist_read_from_filename(plist_t *plist, const char *filename)\n{\n\tchar *buffer = NULL;\n\tuint64_t length;\n\n\tif (!filename)\n\t\treturn 0;\n\n\tbuffer_read_from_filename(filename, &buffer, &length);\n\n\tif (!buffer) {\n\t\treturn 0;\n\t}\n\n\tif ((length > 8) && (memcmp(buffer, \"bplist00\", 8) == 0)) {\n\t\tplist_from_bin(buffer, length, plist);\n\t} else {\n\t\tplist_from_xml(buffer, length, plist);\n\t}\n\n\tfree(buffer);\n\n\treturn 1;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include <ctype.h>",
            "#include <inttypes.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include <ctype.h>\n#include <inttypes.h>\n#include <sys/time.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <config.h>\n\nint plist_read_from_filename(plist_t *plist, const char *filename)\n{\n\tchar *buffer = NULL;\n\tuint64_t length;\n\n\tif (!filename)\n\t\treturn 0;\n\n\tbuffer_read_from_filename(filename, &buffer, &length);\n\n\tif (!buffer) {\n\t\treturn 0;\n\t}\n\n\tif ((length > 8) && (memcmp(buffer, \"bplist00\", 8) == 0)) {\n\t\tplist_from_bin(buffer, length, plist);\n\t} else {\n\t\tplist_from_xml(buffer, length, plist);\n\t}\n\n\tfree(buffer);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"Reading Info.plist from backup.\\n\""
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"Aborting as requested by user...\\n\""
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"Negotiated Protocol Version %.1f\\n\"",
            "remote_version"
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mobilebackup2_version_exchange",
          "args": [
            "mobilebackup2",
            "local_versions",
            "2",
            "&remote_version"
          ],
          "line": 1505
        },
        "resolved": true,
        "details": {
          "function_name": "mobilebackup2_version_exchange",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/mobilebackup2.c",
          "lines": "268-324",
          "snippet": "LIBIMOBILEDEVICE_API mobilebackup2_error_t mobilebackup2_version_exchange(mobilebackup2_client_t client, double local_versions[], char count, double *remote_version)\n{\n\tint i;\n\n\tif (!client || !client->parent)\n\t\treturn MOBILEBACKUP2_E_INVALID_ARG;\n\n\tplist_t dict = plist_new_dict();\n\tplist_t array = plist_new_array();\n\tfor (i = 0; i < count; i++) {\n\t\tplist_array_append_item(array, plist_new_real(local_versions[i]));\n\t}\n\tplist_dict_set_item(dict, \"SupportedProtocolVersions\", array);\n\n\tmobilebackup2_error_t err = mobilebackup2_send_message(client, \"Hello\", dict);\n\tplist_free(dict);\n\n\tif (err != MOBILEBACKUP2_E_SUCCESS)\n\t\tgoto leave;\n\n\tdict = NULL;\n\terr = internal_mobilebackup2_receive_message(client, \"Response\", &dict);\n\tif (err != MOBILEBACKUP2_E_SUCCESS)\n\t\tgoto leave;\n\n\t/* check if we received an error */\n\tplist_t node = plist_dict_get_item(dict, \"ErrorCode\");\n\tif (!node || (plist_get_node_type(node) != PLIST_UINT)) {\n\t\terr = MOBILEBACKUP2_E_PLIST_ERROR;\n\t\tgoto leave;\n\t}\n\n\tuint64_t val = 0;\n\tplist_get_uint_val(node, &val);\n\tif (val != 0) {\n\t\tif (val == 1) {\n\t\t\terr = MOBILEBACKUP2_E_NO_COMMON_VERSION;\n\t\t} else {\n\t\t\terr = MOBILEBACKUP2_E_REPLY_NOT_OK;\n\t\t}\n\t\tgoto leave;\n\t}\n\n\t/* retrieve the protocol version of the device */\n\tnode = plist_dict_get_item(dict, \"ProtocolVersion\");\n\tif (!node || (plist_get_node_type(node) != PLIST_REAL)) {\n\t\terr = MOBILEBACKUP2_E_PLIST_ERROR;\n\t\tgoto leave;\n\t}\n\n\t*remote_version = 0.0;\n\tplist_get_real_val(node, remote_version);\nleave:\n\tif (dict)\n\t\tplist_free(dict);\n\treturn err;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"device_link_service.h\"",
            "#include \"mobilebackup2.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <plist/plist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"device_link_service.h\"\n#include \"mobilebackup2.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <plist/plist.h>\n\nLIBIMOBILEDEVICE_API mobilebackup2_error_t mobilebackup2_version_exchange(mobilebackup2_client_t client, double local_versions[], char count, double *remote_version)\n{\n\tint i;\n\n\tif (!client || !client->parent)\n\t\treturn MOBILEBACKUP2_E_INVALID_ARG;\n\n\tplist_t dict = plist_new_dict();\n\tplist_t array = plist_new_array();\n\tfor (i = 0; i < count; i++) {\n\t\tplist_array_append_item(array, plist_new_real(local_versions[i]));\n\t}\n\tplist_dict_set_item(dict, \"SupportedProtocolVersions\", array);\n\n\tmobilebackup2_error_t err = mobilebackup2_send_message(client, \"Hello\", dict);\n\tplist_free(dict);\n\n\tif (err != MOBILEBACKUP2_E_SUCCESS)\n\t\tgoto leave;\n\n\tdict = NULL;\n\terr = internal_mobilebackup2_receive_message(client, \"Response\", &dict);\n\tif (err != MOBILEBACKUP2_E_SUCCESS)\n\t\tgoto leave;\n\n\t/* check if we received an error */\n\tplist_t node = plist_dict_get_item(dict, \"ErrorCode\");\n\tif (!node || (plist_get_node_type(node) != PLIST_UINT)) {\n\t\terr = MOBILEBACKUP2_E_PLIST_ERROR;\n\t\tgoto leave;\n\t}\n\n\tuint64_t val = 0;\n\tplist_get_uint_val(node, &val);\n\tif (val != 0) {\n\t\tif (val == 1) {\n\t\t\terr = MOBILEBACKUP2_E_NO_COMMON_VERSION;\n\t\t} else {\n\t\t\terr = MOBILEBACKUP2_E_REPLY_NOT_OK;\n\t\t}\n\t\tgoto leave;\n\t}\n\n\t/* retrieve the protocol version of the device */\n\tnode = plist_dict_get_item(dict, \"ProtocolVersion\");\n\tif (!node || (plist_get_node_type(node) != PLIST_REAL)) {\n\t\terr = MOBILEBACKUP2_E_PLIST_ERROR;\n\t\tgoto leave;\n\t}\n\n\t*remote_version = 0.0;\n\tplist_get_real_val(node, remote_version);\nleave:\n\tif (dict)\n\t\tplist_free(dict);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdownd_service_descriptor_free",
          "args": [
            "service"
          ],
          "line": 1498
        },
        "resolved": true,
        "details": {
          "function_name": "lockdownd_service_descriptor_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/lockdown.c",
          "lines": "1522-1528",
          "snippet": "LIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_service_descriptor_free(lockdownd_service_descriptor_t service)\n{\n\tif (service)\n\t\tfree(service);\n\n\treturn LOCKDOWN_E_SUCCESS;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/userpref.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"lockdown.h\"",
            "#include \"property_list_service.h\"",
            "#include <plist/plist.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/x509.h>",
            "#include <libtasn1.h>",
            "#include <openssl/x509v3.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/pem.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/userpref.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"lockdown.h\"\n#include \"property_list_service.h\"\n#include <plist/plist.h>\n#include <gnutls/crypto.h>\n#include <gnutls/x509.h>\n#include <libtasn1.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/pem.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_service_descriptor_free(lockdownd_service_descriptor_t service)\n{\n\tif (service)\n\t\tfree(service);\n\n\treturn LOCKDOWN_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mobilebackup2_client_new",
          "args": [
            "device",
            "service",
            "&mobilebackup2"
          ],
          "line": 1495
        },
        "resolved": true,
        "details": {
          "function_name": "mobilebackup2_client_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/mobilebackup2.c",
          "lines": "64-90",
          "snippet": "LIBIMOBILEDEVICE_API mobilebackup2_error_t mobilebackup2_client_new(idevice_t device, lockdownd_service_descriptor_t service,\n\t\t\t\t\t\tmobilebackup2_client_t * client)\n{\n\tif (!device || !service || service->port == 0 || !client || *client)\n\t\treturn MOBILEBACKUP2_E_INVALID_ARG;\n\n\tdevice_link_service_client_t dlclient = NULL;\n\tmobilebackup2_error_t ret = mobilebackup2_error(device_link_service_client_new(device, service, &dlclient));\n\tif (ret != MOBILEBACKUP2_E_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tmobilebackup2_client_t client_loc = (mobilebackup2_client_t) malloc(sizeof(struct mobilebackup2_client_private));\n\tclient_loc->parent = dlclient;\n\n\t/* perform handshake */\n\tret = mobilebackup2_error(device_link_service_version_exchange(dlclient, MBACKUP2_VERSION_INT1, MBACKUP2_VERSION_INT2));\n\tif (ret != MOBILEBACKUP2_E_SUCCESS) {\n\t\tdebug_info(\"version exchange failed, error %d\", ret);\n\t\tmobilebackup2_client_free(client_loc);\n\t\treturn ret;\n\t}\n\n\t*client = client_loc;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"device_link_service.h\"",
            "#include \"mobilebackup2.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <plist/plist.h>"
          ],
          "macros_used": [
            "#define MBACKUP2_VERSION_INT2 0",
            "#define MBACKUP2_VERSION_INT1 300"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"device_link_service.h\"\n#include \"mobilebackup2.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <plist/plist.h>\n\n#define MBACKUP2_VERSION_INT2 0\n#define MBACKUP2_VERSION_INT1 300\n\nLIBIMOBILEDEVICE_API mobilebackup2_error_t mobilebackup2_client_new(idevice_t device, lockdownd_service_descriptor_t service,\n\t\t\t\t\t\tmobilebackup2_client_t * client)\n{\n\tif (!device || !service || service->port == 0 || !client || *client)\n\t\treturn MOBILEBACKUP2_E_INVALID_ARG;\n\n\tdevice_link_service_client_t dlclient = NULL;\n\tmobilebackup2_error_t ret = mobilebackup2_error(device_link_service_client_new(device, service, &dlclient));\n\tif (ret != MOBILEBACKUP2_E_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tmobilebackup2_client_t client_loc = (mobilebackup2_client_t) malloc(sizeof(struct mobilebackup2_client_private));\n\tclient_loc->parent = dlclient;\n\n\t/* perform handshake */\n\tret = mobilebackup2_error(device_link_service_version_exchange(dlclient, MBACKUP2_VERSION_INT1, MBACKUP2_VERSION_INT2));\n\tif (ret != MOBILEBACKUP2_E_SUCCESS) {\n\t\tdebug_info(\"version exchange failed, error %d\", ret);\n\t\tmobilebackup2_client_free(client_loc);\n\t\treturn ret;\n\t}\n\n\t*client = client_loc;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"Started \\\"%s\\\" service on port %d.\\n\"",
            "MOBILEBACKUP2_SERVICE_NAME",
            "service->port"
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdownd_start_service_with_escrow_bag",
          "args": [
            "lockdown",
            "MOBILEBACKUP2_SERVICE_NAME",
            "&service"
          ],
          "line": 1492
        },
        "resolved": true,
        "details": {
          "function_name": "lockdownd_start_service_with_escrow_bag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/lockdown.c",
          "lines": "1364-1367",
          "snippet": "LIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_start_service_with_escrow_bag(lockdownd_client_t client, const char *identifier, lockdownd_service_descriptor_t *service)\n{\n\treturn lockdownd_do_start_service(client, identifier, 1, service);\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/userpref.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"lockdown.h\"",
            "#include \"property_list_service.h\"",
            "#include <plist/plist.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/x509.h>",
            "#include <libtasn1.h>",
            "#include <openssl/x509v3.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/pem.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/userpref.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"lockdown.h\"\n#include \"property_list_service.h\"\n#include <plist/plist.h>\n#include <gnutls/crypto.h>\n#include <gnutls/x509.h>\n#include <libtasn1.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/pem.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_start_service_with_escrow_bag(lockdownd_client_t client, const char *identifier, lockdownd_service_descriptor_t *service)\n{\n\treturn lockdownd_do_start_service(client, identifier, 1, service);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afc_client_new",
          "args": [
            "device",
            "service",
            "&afc"
          ],
          "line": 1481
        },
        "resolved": true,
        "details": {
          "function_name": "afc_client_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "99-116",
          "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_client_new(idevice_t device, lockdownd_service_descriptor_t service, afc_client_t * client)\n{\n\tif (!device || !service || service->port == 0)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tservice_client_t parent = NULL;\n\tif (service_client_new(device, service, &parent) != SERVICE_E_SUCCESS) {\n\t\treturn AFC_E_MUX_ERROR;\n\t}\n\n\tafc_error_t err = afc_client_new_with_service_client(parent, client);\n\tif (err != AFC_E_SUCCESS) {\n\t\tservice_client_free(parent);\n\t} else {\n\t\t(*client)->free_parent = 1;\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_client_new(idevice_t device, lockdownd_service_descriptor_t service, afc_client_t * client)\n{\n\tif (!device || !service || service->port == 0)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tservice_client_t parent = NULL;\n\tif (service_client_new(device, service, &parent) != SERVICE_E_SUCCESS) {\n\t\treturn AFC_E_MUX_ERROR;\n\t}\n\n\tafc_error_t err = afc_client_new_with_service_client(parent, client);\n\tif (err != AFC_E_SUCCESS) {\n\t\tservice_client_free(parent);\n\t} else {\n\t\t(*client)->free_parent = 1;\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "np_observe_notifications",
          "args": [
            "np",
            "noties"
          ],
          "line": 1469
        },
        "resolved": true,
        "details": {
          "function_name": "np_observe_notifications",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/notification_proxy.c",
          "lines": "210-233",
          "snippet": "LIBIMOBILEDEVICE_API np_error_t np_observe_notifications(np_client_t client, const char **notification_spec)\n{\n\tint i = 0;\n\tnp_error_t res = NP_E_UNKNOWN_ERROR;\n\tconst char **notifications = notification_spec;\n\n\tif (!client) {\n\t\treturn NP_E_INVALID_ARG;\n\t}\n\n\tif (!notifications) {\n\t\treturn NP_E_INVALID_ARG;\n\t}\n\n\twhile (notifications[i]) {\n\t\tres = np_observe_notification(client, notifications[i]);\n\t\tif (res != NP_E_SUCCESS) {\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\n\treturn res;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"property_list_service.h\"",
            "#include \"notification_proxy.h\"",
            "#include <plist/plist.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"property_list_service.h\"\n#include \"notification_proxy.h\"\n#include <plist/plist.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n\nLIBIMOBILEDEVICE_API np_error_t np_observe_notifications(np_client_t client, const char **notification_spec)\n{\n\tint i = 0;\n\tnp_error_t res = NP_E_UNKNOWN_ERROR;\n\tconst char **notifications = notification_spec;\n\n\tif (!client) {\n\t\treturn NP_E_INVALID_ARG;\n\t}\n\n\tif (!notifications) {\n\t\treturn NP_E_INVALID_ARG;\n\t}\n\n\twhile (notifications[i]) {\n\t\tres = np_observe_notification(client, notifications[i]);\n\t\tif (res != NP_E_SUCCESS) {\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "np_set_notify_callback",
          "args": [
            "np",
            "notify_cb",
            "NULL"
          ],
          "line": 1461
        },
        "resolved": true,
        "details": {
          "function_name": "np_set_notify_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/notification_proxy.c",
          "lines": "339-374",
          "snippet": "LIBIMOBILEDEVICE_API np_error_t np_set_notify_callback( np_client_t client, np_notify_cb_t notify_cb, void *user_data )\n{\n\tif (!client)\n\t\treturn NP_E_INVALID_ARG;\n\n\tnp_error_t res = NP_E_UNKNOWN_ERROR;\n\n\tnp_lock(client);\n\tif (client->notifier) {\n\t\tdebug_info(\"callback already set, removing\");\n\t\tproperty_list_service_client_t parent = client->parent;\n\t\tclient->parent = NULL;\n\t\tthread_join(client->notifier);\n\t\tthread_free(client->notifier);\n\t\tclient->notifier = (thread_t)NULL;\n\t\tclient->parent = parent;\n\t}\n\n\tif (notify_cb) {\n\t\tstruct np_thread *npt = (struct np_thread*)malloc(sizeof(struct np_thread));\n\t\tif (npt) {\n\t\t\tnpt->client = client;\n\t\t\tnpt->cbfunc = notify_cb;\n\t\t\tnpt->user_data = user_data;\n\n\t\t\tif (thread_new(&client->notifier, np_notifier, npt) == 0) {\n\t\t\t\tres = NP_E_SUCCESS;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tdebug_info(\"no callback set\");\n\t}\n\tnp_unlock(client);\n\n\treturn res;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"property_list_service.h\"",
            "#include \"notification_proxy.h\"",
            "#include <plist/plist.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"property_list_service.h\"\n#include \"notification_proxy.h\"\n#include <plist/plist.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n\nLIBIMOBILEDEVICE_API np_error_t np_set_notify_callback( np_client_t client, np_notify_cb_t notify_cb, void *user_data )\n{\n\tif (!client)\n\t\treturn NP_E_INVALID_ARG;\n\n\tnp_error_t res = NP_E_UNKNOWN_ERROR;\n\n\tnp_lock(client);\n\tif (client->notifier) {\n\t\tdebug_info(\"callback already set, removing\");\n\t\tproperty_list_service_client_t parent = client->parent;\n\t\tclient->parent = NULL;\n\t\tthread_join(client->notifier);\n\t\tthread_free(client->notifier);\n\t\tclient->notifier = (thread_t)NULL;\n\t\tclient->parent = parent;\n\t}\n\n\tif (notify_cb) {\n\t\tstruct np_thread *npt = (struct np_thread*)malloc(sizeof(struct np_thread));\n\t\tif (npt) {\n\t\t\tnpt->client = client;\n\t\t\tnpt->cbfunc = notify_cb;\n\t\t\tnpt->user_data = user_data;\n\n\t\t\tif (thread_new(&client->notifier, np_notifier, npt) == 0) {\n\t\t\t\tres = NP_E_SUCCESS;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tdebug_info(\"no callback set\");\n\t}\n\tnp_unlock(client);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "np_client_new",
          "args": [
            "device",
            "service",
            "&np"
          ],
          "line": 1460
        },
        "resolved": true,
        "details": {
          "function_name": "np_client_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/notification_proxy.c",
          "lines": "89-105",
          "snippet": "LIBIMOBILEDEVICE_API np_error_t np_client_new(idevice_t device, lockdownd_service_descriptor_t service, np_client_t *client)\n{\n\tproperty_list_service_client_t plistclient = NULL;\n\tnp_error_t err = np_error(property_list_service_client_new(device, service, &plistclient));\n\tif (err != NP_E_SUCCESS) {\n\t\treturn err;\n\t}\n\n\tnp_client_t client_loc = (np_client_t) malloc(sizeof(struct np_client_private));\n\tclient_loc->parent = plistclient;\n\n\tmutex_init(&client_loc->mutex);\n\tclient_loc->notifier = (thread_t)NULL;\n\n\t*client = client_loc;\n\treturn NP_E_SUCCESS;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"property_list_service.h\"",
            "#include \"notification_proxy.h\"",
            "#include <plist/plist.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"property_list_service.h\"\n#include \"notification_proxy.h\"\n#include <plist/plist.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n\nLIBIMOBILEDEVICE_API np_error_t np_client_new(idevice_t device, lockdownd_service_descriptor_t service, np_client_t *client)\n{\n\tproperty_list_service_client_t plistclient = NULL;\n\tnp_error_t err = np_error(property_list_service_client_new(device, service, &plistclient));\n\tif (err != NP_E_SUCCESS) {\n\t\treturn err;\n\t}\n\n\tnp_client_t client_loc = (np_client_t) malloc(sizeof(struct np_client_private));\n\tclient_loc->parent = plistclient;\n\n\tmutex_init(&client_loc->mutex);\n\tclient_loc->notifier = (thread_t)NULL;\n\n\t*client = client_loc;\n\treturn NP_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdownd_client_new_with_handshake",
          "args": [
            "device",
            "&lockdown",
            "\"idevicebackup2\""
          ],
          "line": 1450
        },
        "resolved": true,
        "details": {
          "function_name": "lockdownd_client_new_with_handshake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/lockdown.c",
          "lines": "671-753",
          "snippet": "LIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_client_new_with_handshake(idevice_t device, lockdownd_client_t *client, const char *label)\n{\n\tif (!client)\n\t\treturn LOCKDOWN_E_INVALID_ARG;\n\n\tlockdownd_error_t ret = LOCKDOWN_E_SUCCESS;\n\tlockdownd_client_t client_loc = NULL;\n\tplist_t pair_record = NULL;\n\tchar *host_id = NULL;\n\tchar *type = NULL;\n\n\tret = lockdownd_client_new(device, &client_loc, label);\n\tif (LOCKDOWN_E_SUCCESS != ret) {\n\t\tdebug_info(\"failed to create lockdownd client.\");\n\t\treturn ret;\n\t}\n\n\t/* perform handshake */\n\tif (LOCKDOWN_E_SUCCESS != lockdownd_query_type(client_loc, &type)) {\n\t\tdebug_info(\"QueryType failed in the lockdownd client.\");\n\t\tret = LOCKDOWN_E_NOT_ENOUGH_DATA;\n\t} else {\n\t\tif (strcmp(\"com.apple.mobile.lockdown\", type)) {\n\t\t\tdebug_info(\"Warning QueryType request returned \\\"%s\\\".\", type);\n\t\t}\n\t}\n\tfree(type);\n\n\tuserpref_read_pair_record(client_loc->udid, &pair_record);\n\tif (pair_record) {\n\t\tpair_record_get_host_id(pair_record, &host_id);\n\t}\n\tif (LOCKDOWN_E_SUCCESS == ret && !host_id) {\n\t\tret = LOCKDOWN_E_INVALID_CONF;\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS == ret && !pair_record) {\n\t\t/* attempt pairing */\n\t\tret = lockdownd_pair(client_loc, NULL);\n\t}\n\n\tplist_free(pair_record);\n\tpair_record = NULL;\n\n\t/* in any case, we need to validate pairing to receive trusted host status */\n\tret = lockdownd_validate_pair(client_loc, NULL);\n\n\t/* if not paired yet, let's do it now */\n\tif (LOCKDOWN_E_INVALID_HOST_ID == ret) {\n\t\tfree(host_id);\n\t\thost_id = NULL;\n\t\tret = lockdownd_pair(client_loc, NULL);\n\t\tif (LOCKDOWN_E_SUCCESS == ret) {\n\t\t\tret = lockdownd_validate_pair(client_loc, NULL);\n\t\t} else if (LOCKDOWN_E_PAIRING_DIALOG_RESPONSE_PENDING == ret) {\n\t\t\tdebug_info(\"Device shows the pairing dialog.\");\n\t\t}\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS == ret) {\n\t\tif (!host_id) {\n\t\t\tuserpref_read_pair_record(client_loc->udid, &pair_record);\n\t\t\tif (pair_record) {\n\t\t\t\tpair_record_get_host_id(pair_record, &host_id);\n\t\t\t\tplist_free(pair_record);\n\t\t\t}\n\t\t}\n\n\t\tret = lockdownd_start_session(client_loc, host_id, NULL, NULL);\n\t\tif (LOCKDOWN_E_SUCCESS != ret) {\n\t\t\tdebug_info(\"Session opening failed.\");\n\t\t}\n\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS == ret) {\n\t\t*client = client_loc;\n\t} else {\n\t\tlockdownd_client_free(client_loc);\n\t}\n\tfree(host_id);\n\treturn ret;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/userpref.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"lockdown.h\"",
            "#include \"property_list_service.h\"",
            "#include <plist/plist.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/x509.h>",
            "#include <libtasn1.h>",
            "#include <openssl/x509v3.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/pem.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/userpref.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"lockdown.h\"\n#include \"property_list_service.h\"\n#include <plist/plist.h>\n#include <gnutls/crypto.h>\n#include <gnutls/x509.h>\n#include <libtasn1.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/pem.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_client_new_with_handshake(idevice_t device, lockdownd_client_t *client, const char *label)\n{\n\tif (!client)\n\t\treturn LOCKDOWN_E_INVALID_ARG;\n\n\tlockdownd_error_t ret = LOCKDOWN_E_SUCCESS;\n\tlockdownd_client_t client_loc = NULL;\n\tplist_t pair_record = NULL;\n\tchar *host_id = NULL;\n\tchar *type = NULL;\n\n\tret = lockdownd_client_new(device, &client_loc, label);\n\tif (LOCKDOWN_E_SUCCESS != ret) {\n\t\tdebug_info(\"failed to create lockdownd client.\");\n\t\treturn ret;\n\t}\n\n\t/* perform handshake */\n\tif (LOCKDOWN_E_SUCCESS != lockdownd_query_type(client_loc, &type)) {\n\t\tdebug_info(\"QueryType failed in the lockdownd client.\");\n\t\tret = LOCKDOWN_E_NOT_ENOUGH_DATA;\n\t} else {\n\t\tif (strcmp(\"com.apple.mobile.lockdown\", type)) {\n\t\t\tdebug_info(\"Warning QueryType request returned \\\"%s\\\".\", type);\n\t\t}\n\t}\n\tfree(type);\n\n\tuserpref_read_pair_record(client_loc->udid, &pair_record);\n\tif (pair_record) {\n\t\tpair_record_get_host_id(pair_record, &host_id);\n\t}\n\tif (LOCKDOWN_E_SUCCESS == ret && !host_id) {\n\t\tret = LOCKDOWN_E_INVALID_CONF;\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS == ret && !pair_record) {\n\t\t/* attempt pairing */\n\t\tret = lockdownd_pair(client_loc, NULL);\n\t}\n\n\tplist_free(pair_record);\n\tpair_record = NULL;\n\n\t/* in any case, we need to validate pairing to receive trusted host status */\n\tret = lockdownd_validate_pair(client_loc, NULL);\n\n\t/* if not paired yet, let's do it now */\n\tif (LOCKDOWN_E_INVALID_HOST_ID == ret) {\n\t\tfree(host_id);\n\t\thost_id = NULL;\n\t\tret = lockdownd_pair(client_loc, NULL);\n\t\tif (LOCKDOWN_E_SUCCESS == ret) {\n\t\t\tret = lockdownd_validate_pair(client_loc, NULL);\n\t\t} else if (LOCKDOWN_E_PAIRING_DIALOG_RESPONSE_PENDING == ret) {\n\t\t\tdebug_info(\"Device shows the pairing dialog.\");\n\t\t}\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS == ret) {\n\t\tif (!host_id) {\n\t\t\tuserpref_read_pair_record(client_loc->udid, &pair_record);\n\t\t\tif (pair_record) {\n\t\t\t\tpair_record_get_host_id(pair_record, &host_id);\n\t\t\t\tplist_free(pair_record);\n\t\t\t}\n\t\t}\n\n\t\tret = lockdownd_start_session(client_loc, host_id, NULL, NULL);\n\t\tif (LOCKDOWN_E_SUCCESS != ret) {\n\t\t\tdebug_info(\"Session opening failed.\");\n\t\t}\n\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS == ret) {\n\t\t*client = client_loc;\n\t} else {\n\t\tlockdownd_client_free(client_loc);\n\t}\n\tfree(host_id);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ERROR: a backup password is required to unback an encrypted backup. Cannot continue.\\n\""
          ],
          "line": 1442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ERROR: a backup password is required to restore an encrypted backup. Cannot continue.\\n\""
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "backup_password"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"This is an encrypted backup.\\n\""
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"Backup directory is \\\"%s\\\"\\n\"",
            "backup_directory"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_free",
          "args": [
            "manifest_plist"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_bool_val",
          "args": [
            "node_tmp",
            "&is_encrypted"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_node_type",
          "args": [
            "node_tmp"
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "manifest_plist",
            "\"IsEncrypted\""
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ERROR: Can't get password input in non-interactive mode. Either pass password(s) on the command line, or enable interactive mode with -i or --interactive.\\n\""
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "udid"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idevice_get_udid",
          "args": [
            "device",
            "&udid"
          ],
          "line": 1380
        },
        "resolved": true,
        "details": {
          "function_name": "idevice_get_udid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
          "lines": "480-487",
          "snippet": "LIBIMOBILEDEVICE_API idevice_error_t idevice_get_udid(idevice_t device, char **udid)\n{\n\tif (!device || !udid)\n\t\treturn IDEVICE_E_INVALID_ARG;\n\n\t*udid = strdup(device->udid);\n\treturn IDEVICE_E_SUCCESS;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"common/thread.h\"",
            "#include \"common/userpref.h\"",
            "#include \"idevice.h\"",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <usbmuxd.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "LIBIMOBILEDEVICE_API idevice_error_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nLIBIMOBILEDEVICE_API idevice_error_t idevice_get_udid(idevice_t device, char **udid)\n{\n\tif (!device || !udid)\n\t\treturn IDEVICE_E_INVALID_ARG;\n\n\t*udid = strdup(device->udid);\n\treturn IDEVICE_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"No device found, is it plugged in?\\n\""
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idevice_new",
          "args": [
            "&device",
            "NULL"
          ],
          "line": 1375
        },
        "resolved": true,
        "details": {
          "function_name": "idevice_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
          "lines": "230-245",
          "snippet": "LIBIMOBILEDEVICE_API idevice_error_t idevice_new(idevice_t * device, const char *udid)\n{\n\tusbmuxd_device_info_t muxdev;\n\tint res = usbmuxd_get_device_by_udid(udid, &muxdev);\n\tif (res > 0) {\n\t\tidevice_t dev = (idevice_t) malloc(sizeof(struct idevice_private));\n\t\tdev->udid = strdup(muxdev.udid);\n\t\tdev->conn_type = CONNECTION_USBMUXD;\n\t\tdev->conn_data = (void*)(long)muxdev.handle;\n\t\t*device = dev;\n\t\treturn IDEVICE_E_SUCCESS;\n\t}\n\t/* other connection types could follow here */\n\n\treturn IDEVICE_E_NO_DEVICE;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"common/thread.h\"",
            "#include \"common/userpref.h\"",
            "#include \"idevice.h\"",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <usbmuxd.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "LIBIMOBILEDEVICE_API idevice_error_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nLIBIMOBILEDEVICE_API idevice_error_t idevice_new(idevice_t * device, const char *udid)\n{\n\tusbmuxd_device_info_t muxdev;\n\tint res = usbmuxd_get_device_by_udid(udid, &muxdev);\n\tif (res > 0) {\n\t\tidevice_t dev = (idevice_t) malloc(sizeof(struct idevice_private));\n\t\tdev->udid = strdup(muxdev.udid);\n\t\tdev->conn_type = CONNECTION_USBMUXD;\n\t\tdev->conn_data = (void*)(long)muxdev.handle;\n\t\t*device = dev;\n\t\treturn IDEVICE_E_SUCCESS;\n\t}\n\t/* other connection types could follow here */\n\n\treturn IDEVICE_E_NO_DEVICE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_usage",
          "args": [
            "argc",
            "argv"
          ],
          "line": 1354
        },
        "resolved": true,
        "details": {
          "function_name": "print_usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
          "lines": "1114-1147",
          "snippet": "static void print_usage(int argc, char **argv)\n{\n\tchar *name = NULL;\n\tname = strrchr(argv[0], '/');\n\tprintf(\"Usage: %s [OPTIONS] CMD [CMDOPTIONS] DIRECTORY\\n\", (name ? name + 1: argv[0]));\n\tprintf(\"Create or restore backup from the current or specified directory.\\n\\n\");\n\tprintf(\"commands:\\n\");\n\tprintf(\"  backup\\tcreate backup for the device\\n\");\n\tprintf(\"    --full\\t\\tforce full backup from device.\\n\");\n\tprintf(\"  restore\\trestore last backup to the device\\n\");\n\tprintf(\"    --system\\t\\trestore system files, too.\\n\");\n\tprintf(\"    --reboot\\t\\treboot the system when done.\\n\");\n\tprintf(\"    --copy\\t\\tcreate a copy of backup folder before restoring.\\n\");\n\tprintf(\"    --settings\\t\\trestore device settings from the backup.\\n\");\n\tprintf(\"    --remove\\t\\tremove items which are not being restored\\n\");\n\tprintf(\"    --password PWD\\tsupply the password of the source backup\\n\");\n\tprintf(\"  info\\t\\tshow details about last completed backup of device\\n\");\n\tprintf(\"  list\\t\\tlist files of last completed backup in CSV format\\n\");\n\tprintf(\"  unback\\tunpack a completed backup in DIRECTORY/_unback_/\\n\");\n\tprintf(\"  encryption on|off [PWD]\\tenable or disable backup encryption\\n\");\n\tprintf(\"    NOTE: password will be requested in interactive mode if omitted\\n\");\n\tprintf(\"  changepw [OLD NEW]  change backup password on target device\\n\");\n\tprintf(\"    NOTE: passwords will be requested in interactive mode if omitted\\n\");\n\tprintf(\"  cloud on|off\\tenable or disable cloud use (requires iCloud account)\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"options:\\n\");\n\tprintf(\"  -d, --debug\\t\\tenable communication debugging\\n\");\n\tprintf(\"  -u, --udid UDID\\ttarget specific device by its 40-digit device UDID\\n\");\n\tprintf(\"  -s, --source UDID\\tuse backup data from device specified by UDID\\n\");\n\tprintf(\"  -i, --interactive\\trequest passwords interactively\\n\");\n\tprintf(\"  -h, --help\\t\\tprints usage information\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"Homepage: <\" PACKAGE_URL \">\\n\");\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <sys/statvfs.h>",
            "#include <termios.h>",
            "#include <conio.h>",
            "#include <windows.h>",
            "#include <endianness.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup2.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <libgen.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void print_usage(int argc, char **argv)\n{\n\tchar *name = NULL;\n\tname = strrchr(argv[0], '/');\n\tprintf(\"Usage: %s [OPTIONS] CMD [CMDOPTIONS] DIRECTORY\\n\", (name ? name + 1: argv[0]));\n\tprintf(\"Create or restore backup from the current or specified directory.\\n\\n\");\n\tprintf(\"commands:\\n\");\n\tprintf(\"  backup\\tcreate backup for the device\\n\");\n\tprintf(\"    --full\\t\\tforce full backup from device.\\n\");\n\tprintf(\"  restore\\trestore last backup to the device\\n\");\n\tprintf(\"    --system\\t\\trestore system files, too.\\n\");\n\tprintf(\"    --reboot\\t\\treboot the system when done.\\n\");\n\tprintf(\"    --copy\\t\\tcreate a copy of backup folder before restoring.\\n\");\n\tprintf(\"    --settings\\t\\trestore device settings from the backup.\\n\");\n\tprintf(\"    --remove\\t\\tremove items which are not being restored\\n\");\n\tprintf(\"    --password PWD\\tsupply the password of the source backup\\n\");\n\tprintf(\"  info\\t\\tshow details about last completed backup of device\\n\");\n\tprintf(\"  list\\t\\tlist files of last completed backup in CSV format\\n\");\n\tprintf(\"  unback\\tunpack a completed backup in DIRECTORY/_unback_/\\n\");\n\tprintf(\"  encryption on|off [PWD]\\tenable or disable backup encryption\\n\");\n\tprintf(\"    NOTE: password will be requested in interactive mode if omitted\\n\");\n\tprintf(\"  changepw [OLD NEW]  change backup password on target device\\n\");\n\tprintf(\"    NOTE: passwords will be requested in interactive mode if omitted\\n\");\n\tprintf(\"  cloud on|off\\tenable or disable cloud use (requires iCloud account)\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"options:\\n\");\n\tprintf(\"  -d, --debug\\t\\tenable communication debugging\\n\");\n\tprintf(\"  -u, --udid UDID\\ttarget specific device by its 40-digit device UDID\\n\");\n\tprintf(\"  -s, --source UDID\\tuse backup data from device specified by UDID\\n\");\n\tprintf(\"  -i, --interactive\\trequest passwords interactively\\n\");\n\tprintf(\"  -h, --help\\t\\tprints usage information\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"Homepage: <\" PACKAGE_URL \">\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"No target backup directory specified.\\n\""
          ],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"No command specified.\\n\""
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[i]"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Old and new passwords have to be passed as arguments for the changepw command\\n\""
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[i]"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[i]"
          ],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[i]"
          ],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"No argument given for encryption command; requires either 'on' or 'off'.\\n\""
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"No argument given for cloud command; requires either 'on' or 'off'.\\n\""
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[i]"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[i]"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "argv[i]"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[i]"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "argv[i]"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idevice_set_debug_level",
          "args": [
            "1"
          ],
          "line": 1182
        },
        "resolved": true,
        "details": {
          "function_name": "idevice_set_debug_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
          "lines": "225-228",
          "snippet": "LIBIMOBILEDEVICE_API void idevice_set_debug_level(int level)\n{\n\tinternal_set_debug_level(level);\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"common/thread.h\"",
            "#include \"common/userpref.h\"",
            "#include \"idevice.h\"",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <usbmuxd.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API void idevice_set_debug_level(int level)\n{\n\tinternal_set_debug_level(level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGPIPE",
            "SIG_IGN"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGQUIT",
            "clean_exit"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGTERM",
            "clean_exit"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGINT",
            "clean_exit"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\n#define LOCK_WAIT 200000\n#define LOCK_ATTEMPTS 50\n\nstatic int verbose = 1;\nstatic int quit_flag = 0;\nstatic int backup_domain_changed = 0;\nstatic double overall_progress = 0;\n\nint main(int argc, char *argv[])\n{\n\tidevice_error_t ret = IDEVICE_E_UNKNOWN_ERROR;\n\tlockdownd_error_t ldret = LOCKDOWN_E_UNKNOWN_ERROR;\n\tint i;\n\tchar* udid = NULL;\n\tchar* source_udid = NULL;\n\tlockdownd_service_descriptor_t service = NULL;\n\tint cmd = -1;\n\tint cmd_flags = 0;\n\tint is_full_backup = 0;\n\tint result_code = -1;\n\tchar* backup_directory = NULL;\n\tint interactive_mode = 0;\n\tchar* backup_password = NULL;\n\tchar* newpw = NULL;\n\tstruct stat st;\n\tplist_t node_tmp = NULL;\n\tplist_t info_plist = NULL;\n\tplist_t opts = NULL;\n\tmobilebackup2_error_t err;\n\n\t/* we need to exit cleanly on running backups and restores or we cause havok */\n\tsignal(SIGINT, clean_exit);\n\tsignal(SIGTERM, clean_exit);\n#ifndef WIN32\n\tsignal(SIGQUIT, clean_exit);\n\tsignal(SIGPIPE, SIG_IGN);\n#endif\n\n\t/* parse cmdline args */\n\tfor (i = 1; i < argc; i++) {\n\t\tif (!strcmp(argv[i], \"-d\") || !strcmp(argv[i], \"--debug\")) {\n\t\t\tidevice_set_debug_level(1);\n\t\t\tcontinue;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"-u\") || !strcmp(argv[i], \"--udid\")) {\n\t\t\ti++;\n\t\t\tif (!argv[i] || (strlen(argv[i]) != 40)) {\n\t\t\t\tprint_usage(argc, argv);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tudid = strdup(argv[i]);\n\t\t\tcontinue;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"-s\") || !strcmp(argv[i], \"--source\")) {\n\t\t\ti++;\n\t\t\tif (!argv[i] || (strlen(argv[i]) != 40)) {\n\t\t\t\tprint_usage(argc, argv);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tsource_udid = strdup(argv[i]);\n\t\t\tcontinue;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"-i\") || !strcmp(argv[i], \"--interactive\")) {\n\t\t\tinteractive_mode = 1;\n\t\t\tcontinue;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"-h\") || !strcmp(argv[i], \"--help\")) {\n\t\t\tprint_usage(argc, argv);\n\t\t\treturn 0;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"backup\")) {\n\t\t\tcmd = CMD_BACKUP;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"restore\")) {\n\t\t\tcmd = CMD_RESTORE;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"--system\")) {\n\t\t\tcmd_flags |= CMD_FLAG_RESTORE_SYSTEM_FILES;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"--reboot\")) {\n\t\t\tcmd_flags |= CMD_FLAG_RESTORE_REBOOT;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"--copy\")) {\n\t\t\tcmd_flags |= CMD_FLAG_RESTORE_COPY_BACKUP;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"--settings\")) {\n\t\t\tcmd_flags |= CMD_FLAG_RESTORE_SETTINGS;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"--remove\")) {\n\t\t\tcmd_flags |= CMD_FLAG_RESTORE_REMOVE_ITEMS;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"--password\")) {\n\t\t\ti++;\n\t\t\tif (!argv[i]) {\n\t\t\t\tprint_usage(argc, argv);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (backup_password)\n\t\t\t\tfree(backup_password);\n\t\t\tbackup_password = strdup(argv[i]);\n\t\t\tcontinue;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"cloud\")) {\n\t\t\tcmd = CMD_CLOUD;\n\t\t\ti++;\n\t\t\tif (!argv[i]) {\n\t\t\t\tprintf(\"No argument given for cloud command; requires either 'on' or 'off'.\\n\");\n\t\t\t\tprint_usage(argc, argv);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (!strcmp(argv[i], \"on\")) {\n\t\t\t\tcmd_flags |= CMD_FLAG_CLOUD_ENABLE;\n\t\t\t} else if (!strcmp(argv[i], \"off\")) {\n\t\t\t\tcmd_flags |= CMD_FLAG_CLOUD_DISABLE;\n\t\t\t} else {\n\t\t\t\tprintf(\"Invalid argument '%s' for cloud command; must be either 'on' or 'off'.\\n\", argv[i]);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"--full\")) {\n\t\t\tcmd_flags |= CMD_FLAG_FORCE_FULL_BACKUP;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"info\")) {\n\t\t\tcmd = CMD_INFO;\n\t\t\tverbose = 0;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"list\")) {\n\t\t\tcmd = CMD_LIST;\n\t\t\tverbose = 0;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"unback\")) {\n\t\t\tcmd = CMD_UNBACK;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"encryption\")) {\n\t\t\tcmd = CMD_CHANGEPW;\n\t\t\ti++;\n\t\t\tif (!argv[i]) {\n\t\t\t\tprintf(\"No argument given for encryption command; requires either 'on' or 'off'.\\n\");\n\t\t\t\tprint_usage(argc, argv);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (!strcmp(argv[i], \"on\")) {\n\t\t\t\tcmd_flags |= CMD_FLAG_ENCRYPTION_ENABLE;\n\t\t\t} else if (!strcmp(argv[i], \"off\")) {\n\t\t\t\tcmd_flags |= CMD_FLAG_ENCRYPTION_DISABLE;\n\t\t\t} else {\n\t\t\t\tprintf(\"Invalid argument '%s' for encryption command; must be either 'on' or 'off'.\\n\", argv[i]);\n\t\t\t}\n\t\t\t// check if a password was given on the command line\n\t\t\tif (newpw) {\n\t\t\t\tfree(newpw);\n\t\t\t\tnewpw = NULL;\n\t\t\t}\n\t\t\tif (backup_password) {\n\t\t\t\tfree(backup_password);\n\t\t\t\tbackup_password = NULL;\n\t\t\t}\n\t\t\ti++;\n\t\t\tif (argv[i]) {\n\t\t\t\tif (cmd_flags & CMD_FLAG_ENCRYPTION_ENABLE) {\n\t\t\t\t\tnewpw = strdup(argv[i]);\n\t\t\t\t} else if (cmd_flags & CMD_FLAG_ENCRYPTION_DISABLE) {\n\t\t\t\t\tbackup_password = strdup(argv[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"changepw\")) {\n\t\t\tcmd = CMD_CHANGEPW;\n\t\t\tcmd_flags |= CMD_FLAG_ENCRYPTION_CHANGEPW;\n\t\t\t// check if passwords were given on command line\n\t\t\tif (newpw) {\n\t\t\t\tfree(newpw);\n\t\t\t\tnewpw = NULL;\n\t\t\t}\n\t\t\tif (backup_password) {\n\t\t\t\tfree(backup_password);\n\t\t\t\tbackup_password = NULL;\n\t\t\t}\n\t\t\ti++;\n\t\t\tif (argv[i]) {\n\t\t\t\tbackup_password = strdup(argv[i]);\n\t\t\t\ti++;\n\t\t\t\tif (!argv[i]) {\n\t\t\t\t\tprintf(\"Old and new passwords have to be passed as arguments for the changepw command\\n\");\n\t\t\t\t\tprint_usage(argc, argv);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tnewpw = strdup(argv[i]);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\telse if (backup_directory == NULL) {\n\t\t\tbackup_directory = argv[i];\n\t\t}\n\t\telse {\n\t\t\tprint_usage(argc, argv);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* verify options */\n\tif (cmd == -1) {\n\t\tprintf(\"No command specified.\\n\");\n\t\tprint_usage(argc, argv);\n\t\treturn -1;\n\t}\n\n\tif (cmd == CMD_CHANGEPW || cmd == CMD_CLOUD) {\n\t\tbackup_directory = (char*)\".this_folder_is_not_present_on_purpose\";\n\t} else {\n\t\tif (backup_directory == NULL) {\n\t\t\tprintf(\"No target backup directory specified.\\n\");\n\t\t\tprint_usage(argc, argv);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* verify if passed backup directory exists */\n\t\tif (stat(backup_directory, &st) != 0) {\n\t\t\tprintf(\"ERROR: Backup directory \\\"%s\\\" does not exist!\\n\", backup_directory);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tidevice_t device = NULL;\n\tif (udid) {\n\t\tret = idevice_new(&device, udid);\n\t\tif (ret != IDEVICE_E_SUCCESS) {\n\t\t\tprintf(\"No device found with udid %s, is it plugged in?\\n\", udid);\n\t\t\treturn -1;\n\t\t}\n\t}\n\telse\n\t{\n\t\tret = idevice_new(&device, NULL);\n\t\tif (ret != IDEVICE_E_SUCCESS) {\n\t\t\tprintf(\"No device found, is it plugged in?\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tidevice_get_udid(device, &udid);\n\t}\n\n\tif (!source_udid) {\n\t\tsource_udid = strdup(udid);\n\t}\n\n\tuint8_t is_encrypted = 0;\n\tchar *info_path = NULL;\n\tif (cmd == CMD_CHANGEPW) {\n\t\tif (!interactive_mode && !backup_password && !newpw) {\n\t\t\tidevice_free(device);\n\t\t\tprintf(\"ERROR: Can't get password input in non-interactive mode. Either pass password(s) on the command line, or enable interactive mode with -i or --interactive.\\n\");\n\t\t\treturn -1;\n\t\t}\n\t} else if (cmd != CMD_CLOUD) {\n\t\t/* backup directory must contain an Info.plist */\n\t\tinfo_path = string_build_path(backup_directory, source_udid, \"Info.plist\", NULL);\n\t\tif (cmd == CMD_RESTORE || cmd == CMD_UNBACK) {\n\t\t\tif (stat(info_path, &st) != 0) {\n\t\t\t\tidevice_free(device);\n\t\t\t\tfree(info_path);\n\t\t\t\tprintf(\"ERROR: Backup directory \\\"%s\\\" is invalid. No Info.plist found for UDID %s.\\n\", backup_directory, source_udid);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tchar* manifest_path = string_build_path(backup_directory, source_udid, \"Manifest.plist\", NULL);\n\t\t\tif (stat(manifest_path, &st) != 0) {\n\t\t\t\tfree(info_path);\n\t\t\t}\n\t\t\tplist_t manifest_plist = NULL;\n\t\t\tplist_read_from_filename(&manifest_plist, manifest_path);\n\t\t\tif (!manifest_plist) {\n\t\t\t\tidevice_free(device);\n\t\t\t\tfree(info_path);\n\t\t\t\tfree(manifest_path);\n\t\t\t\tprintf(\"ERROR: Backup directory \\\"%s\\\" is invalid. No Manifest.plist found for UDID %s.\\n\", backup_directory, source_udid);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tnode_tmp = plist_dict_get_item(manifest_plist, \"IsEncrypted\");\n\t\t\tif (node_tmp && (plist_get_node_type(node_tmp) == PLIST_BOOLEAN)) {\n\t\t\t\tplist_get_bool_val(node_tmp, &is_encrypted);\n\t\t\t}\n\t\t\tplist_free(manifest_plist);\n\t\t\tfree(manifest_path);\n\t\t}\n\t\tPRINT_VERBOSE(1, \"Backup directory is \\\"%s\\\"\\n\", backup_directory);\n\t}\n\n\tif (cmd != CMD_CLOUD && is_encrypted) {\n\t\tPRINT_VERBOSE(1, \"This is an encrypted backup.\\n\");\n\t\tif (backup_password == NULL) {\n\t\t\tif (interactive_mode) {\n\t\t\t\tbackup_password = ask_for_password(\"Enter backup password\", 0);\n\t\t\t}\n\t\t\tif (!backup_password || (strlen(backup_password) == 0)) {\n\t\t\t\tif (backup_password) {\n\t\t\t\t\tfree(backup_password);\n\t\t\t\t}\n\t\t\t\tidevice_free(device);\n\t\t\t\tif (cmd == CMD_RESTORE) {\n\t\t\t\t\tprintf(\"ERROR: a backup password is required to restore an encrypted backup. Cannot continue.\\n\");\n\t\t\t\t} else if (cmd == CMD_UNBACK) {\n\t\t\t\t\tprintf(\"ERROR: a backup password is required to unback an encrypted backup. Cannot continue.\\n\");\n\t\t\t\t}\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tlockdownd_client_t lockdown = NULL;\n\tif (LOCKDOWN_E_SUCCESS != (ldret = lockdownd_client_new_with_handshake(device, &lockdown, \"idevicebackup2\"))) {\n\t\tprintf(\"ERROR: Could not connect to lockdownd, error code %d\\n\", ldret);\n\t\tidevice_free(device);\n\t\treturn -1;\n\t}\n\n\t/* start notification_proxy */\n\tnp_client_t np = NULL;\n\tldret = lockdownd_start_service(lockdown, NP_SERVICE_NAME, &service);\n\tif ((ldret == LOCKDOWN_E_SUCCESS) && service && service->port) {\n\t\tnp_client_new(device, service, &np);\n\t\tnp_set_notify_callback(np, notify_cb, NULL);\n\t\tconst char *noties[5] = {\n\t\t\tNP_SYNC_CANCEL_REQUEST,\n\t\t\tNP_SYNC_SUSPEND_REQUEST,\n\t\t\tNP_SYNC_RESUME_REQUEST,\n\t\t\tNP_BACKUP_DOMAIN_CHANGED,\n\t\t\tNULL\n\t\t};\n\t\tnp_observe_notifications(np, noties);\n\t} else {\n\t\tprintf(\"ERROR: Could not start service %s.\\n\", NP_SERVICE_NAME);\n\t}\n\n\tafc_client_t afc = NULL;\n\tif (cmd == CMD_BACKUP) {\n\t\t/* start AFC, we need this for the lock file */\n\t\tservice->port = 0;\n\t\tservice->ssl_enabled = 0;\n\t\tldret = lockdownd_start_service(lockdown, AFC_SERVICE_NAME, &service);\n\t\tif ((ldret == LOCKDOWN_E_SUCCESS) && service->port) {\n\t\t\tafc_client_new(device, service, &afc);\n\t\t}\n\t}\n\n\tif (service) {\n\t\tlockdownd_service_descriptor_free(service);\n\t\tservice = NULL;\n\t}\n\n\t/* start mobilebackup service and retrieve port */\n\tmobilebackup2_client_t mobilebackup2 = NULL;\n\tldret = lockdownd_start_service_with_escrow_bag(lockdown, MOBILEBACKUP2_SERVICE_NAME, &service);\n\tif ((ldret == LOCKDOWN_E_SUCCESS) && service && service->port) {\n\t\tPRINT_VERBOSE(1, \"Started \\\"%s\\\" service on port %d.\\n\", MOBILEBACKUP2_SERVICE_NAME, service->port);\n\t\tmobilebackup2_client_new(device, service, &mobilebackup2);\n\n\t\tif (service) {\n\t\t\tlockdownd_service_descriptor_free(service);\n\t\t\tservice = NULL;\n\t\t}\n\n\t\t/* send Hello message */\n\t\tdouble local_versions[2] = {2.0, 2.1};\n\t\tdouble remote_version = 0.0;\n\t\terr = mobilebackup2_version_exchange(mobilebackup2, local_versions, 2, &remote_version);\n\t\tif (err != MOBILEBACKUP2_E_SUCCESS) {\n\t\t\tprintf(\"Could not perform backup protocol version exchange, error code %d\\n\", err);\n\t\t\tcmd = CMD_LEAVE;\n\t\t\tgoto checkpoint;\n\t\t}\n\n\t\tPRINT_VERBOSE(1, \"Negotiated Protocol Version %.1f\\n\", remote_version);\n\n\t\t/* check abort conditions */\n\t\tif (quit_flag > 0) {\n\t\t\tPRINT_VERBOSE(1, \"Aborting as requested by user...\\n\");\n\t\t\tcmd = CMD_LEAVE;\n\t\t\tgoto checkpoint;\n\t\t}\n\n\t\t/* verify existing Info.plist */\n\t\tif (info_path && (stat(info_path, &st) == 0) && cmd != CMD_CLOUD) {\n\t\t\tPRINT_VERBOSE(1, \"Reading Info.plist from backup.\\n\");\n\t\t\tplist_read_from_filename(&info_plist, info_path);\n\n\t\t\tif (!info_plist) {\n\t\t\t\tprintf(\"Could not read Info.plist\\n\");\n\t\t\t\tis_full_backup = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tif (cmd == CMD_RESTORE) {\n\t\t\t\tprintf(\"Aborting restore. Info.plist is missing.\\n\");\n\t\t\t\tcmd = CMD_LEAVE;\n\t\t\t} else {\n\t\t\t\tis_full_backup = 1;\n\t\t\t}\n\t\t}\n\n\t\tuint64_t lockfile = 0;\n\t\tif (cmd == CMD_BACKUP) {\n\t\t\tdo_post_notification(device, NP_SYNC_WILL_START);\n\t\t\tafc_file_open(afc, \"/com.apple.itunes.lock_sync\", AFC_FOPEN_RW, &lockfile);\n\t\t}\n\t\tif (lockfile) {\n\t\t\tafc_error_t aerr;\n\t\t\tdo_post_notification(device, NP_SYNC_LOCK_REQUEST);\n\t\t\tfor (i = 0; i < LOCK_ATTEMPTS; i++) {\n\t\t\t\taerr = afc_file_lock(afc, lockfile, AFC_LOCK_EX);\n\t\t\t\tif (aerr == AFC_E_SUCCESS) {\n\t\t\t\t\tdo_post_notification(device, NP_SYNC_DID_START);\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (aerr == AFC_E_OP_WOULD_BLOCK) {\n\t\t\t\t\tusleep(LOCK_WAIT);\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"ERROR: could not lock file! error code: %d\\n\", aerr);\n\t\t\t\t\tafc_file_close(afc, lockfile);\n\t\t\t\t\tlockfile = 0;\n\t\t\t\t\tcmd = CMD_LEAVE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == LOCK_ATTEMPTS) {\n\t\t\t\tfprintf(stderr, \"ERROR: timeout while locking for sync\\n\");\n\t\t\t\tafc_file_close(afc, lockfile);\n\t\t\t\tlockfile = 0;\n\t\t\t\tcmd = CMD_LEAVE;\n\t\t\t}\n\t\t}\n\t\tuint8_t willEncrypt = 0;\n\t\tnode_tmp = NULL;\n\t\tlockdownd_get_value(lockdown, \"com.apple.mobile.backup\", \"WillEncrypt\", &node_tmp);\n\t\tif (node_tmp) {\n\t\t\tif (plist_get_node_type(node_tmp) == PLIST_BOOLEAN) {\n\t\t\t\tplist_get_bool_val(node_tmp, &willEncrypt);\n\t\t\t}\n\t\t\tplist_free(node_tmp);\n\t\t\tnode_tmp = NULL;\n\t\t}\n\ncheckpoint:\n\n\t\tswitch(cmd) {\n\t\t\tcase CMD_CLOUD:\n\t\t\topts = plist_new_dict();\n\t\t\tplist_dict_set_item(opts, \"CloudBackupState\", plist_new_bool(cmd_flags & CMD_FLAG_CLOUD_ENABLE ? 1: 0));\n\t\t\terr = mobilebackup2_send_request(mobilebackup2, \"EnableCloudBackup\", udid, source_udid, opts);\n\t\t\tplist_free(opts);\n\t\t\topts = NULL;\n\t\t\tif (err != MOBILEBACKUP2_E_SUCCESS) {\n\t\t\t\tprintf(\"Error setting cloud backup state on device, error code %d\\n\", err);\n\t\t\t\tcmd = CMD_LEAVE;\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase CMD_BACKUP:\n\t\t\tPRINT_VERBOSE(1, \"Starting backup...\\n\");\n\n\t\t\t/* make sure backup device sub-directory exists */\n\t\t\tchar* devbackupdir = string_build_path(backup_directory, source_udid, NULL);\n\t\t\t__mkdir(devbackupdir, 0755);\n\t\t\tfree(devbackupdir);\n\n\t\t\tif (strcmp(source_udid, udid) != 0) {\n\t\t\t\t/* handle different source backup directory */\n\t\t\t\t// make sure target backup device sub-directory exists\n\t\t\t\tdevbackupdir = string_build_path(backup_directory, udid, NULL);\n\t\t\t\t__mkdir(devbackupdir, 0755);\n\t\t\t\tfree(devbackupdir);\n\n\t\t\t\t// use Info.plist path in target backup folder */\n\t\t\t\tfree(info_path);\n\t\t\t\tinfo_path = string_build_path(backup_directory, udid, \"Info.plist\", NULL);\n\t\t\t}\n\n\t\t\t/* TODO: check domain com.apple.mobile.backup key RequiresEncrypt and WillEncrypt with lockdown */\n\t\t\t/* TODO: verify battery on AC enough battery remaining */\n\n\t\t\t/* re-create Info.plist (Device infos, IC-Info.sidb, photos, app_ids, iTunesPrefs) */\n\t\t\tif (info_plist) {\n\t\t\t\tplist_free(info_plist);\n\t\t\t\tinfo_plist = NULL;\n\t\t\t}\n\t\t\tinfo_plist = mobilebackup_factory_info_plist_new(udid, lockdown, afc);\n\t\t\tremove(info_path);\n\t\t\tplist_write_to_filename(info_plist, info_path, PLIST_FORMAT_XML);\n\t\t\tfree(info_path);\n\n\t\t\tplist_free(info_plist);\n\t\t\tinfo_plist = NULL;\n\n\t\t\tif (cmd_flags & CMD_FLAG_FORCE_FULL_BACKUP) {\n\t\t\t\tPRINT_VERBOSE(1, \"Enforcing full backup from device.\\n\");\n\t\t\t\topts = plist_new_dict();\n\t\t\t\tplist_dict_set_item(opts, \"ForceFullBackup\", plist_new_bool(1));\n\t\t\t}\n\t\t\t/* request backup from device with manifest from last backup */\n\t\t\tif (willEncrypt) {\n\t\t\t\tPRINT_VERBOSE(1, \"Backup will be encrypted.\\n\");\n\t\t\t} else {\n\t\t\t\tPRINT_VERBOSE(1, \"Backup will be unencrypted.\\n\");\n\t\t\t}\n\t\t\tPRINT_VERBOSE(1, \"Requesting backup from device...\\n\");\n\t\t\terr = mobilebackup2_send_request(mobilebackup2, \"Backup\", udid, source_udid, opts);\n\t\t\tif (opts)\n\t\t\t\tplist_free(opts);\n\t\t\tif (err == MOBILEBACKUP2_E_SUCCESS) {\n\t\t\t\tif (is_full_backup) {\n\t\t\t\t\tPRINT_VERBOSE(1, \"Full backup mode.\\n\");\n\t\t\t\t}\telse {\n\t\t\t\t\tPRINT_VERBOSE(1, \"Incremental backup mode.\\n\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (err == MOBILEBACKUP2_E_BAD_VERSION) {\n\t\t\t\t\tprintf(\"ERROR: Could not start backup process: backup protocol version mismatch!\\n\");\n\t\t\t\t} else if (err == MOBILEBACKUP2_E_REPLY_NOT_OK) {\n\t\t\t\t\tprintf(\"ERROR: Could not start backup process: device refused to start the backup process.\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tprintf(\"ERROR: Could not start backup process: unspecified error occured\\n\");\n\t\t\t\t}\n\t\t\t\tcmd = CMD_LEAVE;\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase CMD_RESTORE:\n\t\t\t/* TODO: verify battery on AC enough battery remaining */\n\n\t\t\t/* verify if Status.plist says we read from an successful backup */\n\t\t\tif (!mb2_status_check_snapshot_state(backup_directory, source_udid, \"finished\")) {\n\t\t\t\tprintf(\"ERROR: Cannot ensure we restore from a successful backup. Aborting.\\n\");\n\t\t\t\tcmd = CMD_LEAVE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tPRINT_VERBOSE(1, \"Starting Restore...\\n\");\n\n\t\t\topts = plist_new_dict();\n\t\t\tplist_dict_set_item(opts, \"RestoreSystemFiles\", plist_new_bool(cmd_flags & CMD_FLAG_RESTORE_SYSTEM_FILES));\n\t\t\tPRINT_VERBOSE(1, \"Restoring system files: %s\\n\", (cmd_flags & CMD_FLAG_RESTORE_SYSTEM_FILES ? \"Yes\":\"No\"));\n\t\t\tif ((cmd_flags & CMD_FLAG_RESTORE_REBOOT) == 0)\n\t\t\t\tplist_dict_set_item(opts, \"RestoreShouldReboot\", plist_new_bool(0));\n\t\t\tPRINT_VERBOSE(1, \"Rebooting after restore: %s\\n\", (cmd_flags & CMD_FLAG_RESTORE_REBOOT ? \"Yes\":\"No\"));\n\t\t\tif ((cmd_flags & CMD_FLAG_RESTORE_COPY_BACKUP) == 0)\n\t\t\t\tplist_dict_set_item(opts, \"RestoreDontCopyBackup\", plist_new_bool(1));\n\t\t\tPRINT_VERBOSE(1, \"Don't copy backup: %s\\n\", ((cmd_flags & CMD_FLAG_RESTORE_COPY_BACKUP) == 0 ? \"Yes\":\"No\"));\n\t\t\tplist_dict_set_item(opts, \"RestorePreserveSettings\", plist_new_bool((cmd_flags & CMD_FLAG_RESTORE_SETTINGS) == 0));\n\t\t\tPRINT_VERBOSE(1, \"Preserve settings of device: %s\\n\", ((cmd_flags & CMD_FLAG_RESTORE_SETTINGS) == 0 ? \"Yes\":\"No\"));\n\t\t\tif (cmd_flags & CMD_FLAG_RESTORE_REMOVE_ITEMS)\n\t\t\t\tplist_dict_set_item(opts, \"RemoveItemsNotRestored\", plist_new_bool(1));\n\t\t\t\tPRINT_VERBOSE(1, \"Remove items that are not restored: %s\\n\", ((cmd_flags & CMD_FLAG_RESTORE_REMOVE_ITEMS) ? \"Yes\":\"No\"));\n\t\t\tif (backup_password != NULL) {\n\t\t\t\tplist_dict_set_item(opts, \"Password\", plist_new_string(backup_password));\n\t\t\t}\n\t\t\tPRINT_VERBOSE(1, \"Backup password: %s\\n\", (backup_password == NULL ? \"No\":\"Yes\"));\n\n\t\t\terr = mobilebackup2_send_request(mobilebackup2, \"Restore\", udid, source_udid, opts);\n\t\t\tplist_free(opts);\n\t\t\tif (err != MOBILEBACKUP2_E_SUCCESS) {\n\t\t\t\tif (err == MOBILEBACKUP2_E_BAD_VERSION) {\n\t\t\t\t\tprintf(\"ERROR: Could not start restore process: backup protocol version mismatch!\\n\");\n\t\t\t\t} else if (err == MOBILEBACKUP2_E_REPLY_NOT_OK) {\n\t\t\t\t\tprintf(\"ERROR: Could not start restore process: device refused to start the restore process.\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tprintf(\"ERROR: Could not start restore process: unspecified error occured\\n\");\n\t\t\t\t}\n\t\t\t\tcmd = CMD_LEAVE;\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase CMD_INFO:\n\t\t\tPRINT_VERBOSE(1, \"Requesting backup info from device...\\n\");\n\t\t\terr = mobilebackup2_send_request(mobilebackup2, \"Info\", udid, source_udid, NULL);\n\t\t\tif (err != MOBILEBACKUP2_E_SUCCESS) {\n\t\t\t\tprintf(\"Error requesting backup info from device, error code %d\\n\", err);\n\t\t\t\tcmd = CMD_LEAVE;\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase CMD_LIST:\n\t\t\tPRINT_VERBOSE(1, \"Requesting backup list from device...\\n\");\n\t\t\terr = mobilebackup2_send_request(mobilebackup2, \"List\", udid, source_udid, NULL);\n\t\t\tif (err != MOBILEBACKUP2_E_SUCCESS) {\n\t\t\t\tprintf(\"Error requesting backup list from device, error code %d\\n\", err);\n\t\t\t\tcmd = CMD_LEAVE;\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase CMD_UNBACK:\n\t\t\tPRINT_VERBOSE(1, \"Starting to unpack backup...\\n\");\n\t\t\tif (backup_password != NULL) {\n\t\t\t\topts = plist_new_dict();\n\t\t\t\tplist_dict_set_item(opts, \"Password\", plist_new_string(backup_password));\n\t\t\t}\n\t\t\tPRINT_VERBOSE(1, \"Backup password: %s\\n\", (backup_password == NULL ? \"No\":\"Yes\"));\n\t\t\terr = mobilebackup2_send_request(mobilebackup2, \"Unback\", udid, source_udid, opts);\n\t\t\tif (backup_password !=NULL) {\n\t\t\t\tplist_free(opts);\n\t\t\t}\n\t\t\tif (err != MOBILEBACKUP2_E_SUCCESS) {\n\t\t\t\tprintf(\"Error requesting unback operation from device, error code %d\\n\", err);\n\t\t\t\tcmd = CMD_LEAVE;\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase CMD_CHANGEPW:\n\t\t\topts = plist_new_dict();\n\t\t\tplist_dict_set_item(opts, \"TargetIdentifier\", plist_new_string(udid));\n\t\t\tif (cmd_flags & CMD_FLAG_ENCRYPTION_ENABLE) {\n\t\t\t\tif (!willEncrypt) {\n\t\t\t\t\tif (!newpw) {\n\t\t\t\t\t\tnewpw = ask_for_password(\"Enter new backup password\", 1);\n\t\t\t\t\t}\n\t\t\t\t\tif (!newpw) {\n\t\t\t\t\t\tprintf(\"No backup password given. Aborting.\\n\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tprintf(\"ERROR: Backup encryption is already enabled. Aborting.\\n\");\n\t\t\t\t\tcmd = CMD_LEAVE;\n\t\t\t\t\tif (newpw) {\n\t\t\t\t\t\tfree(newpw);\n\t\t\t\t\t\tnewpw = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (cmd_flags & CMD_FLAG_ENCRYPTION_DISABLE) {\n\t\t\t\tif (willEncrypt) {\n\t\t\t\t\tif (!backup_password) {\n\t\t\t\t\t\tbackup_password = ask_for_password(\"Enter current backup password\", 0);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tprintf(\"ERROR: Backup encryption is not enabled. Aborting.\\n\");\n\t\t\t\t\tcmd = CMD_LEAVE;\n\t\t\t\t\tif (backup_password) {\n\t\t\t\t\t\tfree(backup_password);\n\t\t\t\t\t\tbackup_password = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (cmd_flags & CMD_FLAG_ENCRYPTION_CHANGEPW) {\n\t\t\t\tif (willEncrypt) {\n\t\t\t\t\tif (!backup_password) {\n\t\t\t\t\t\tbackup_password = ask_for_password(\"Enter old backup password\", 0);\n\t\t\t\t\t\tnewpw = ask_for_password(\"Enter new backup password\", 1);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tprintf(\"ERROR: Backup encryption is not enabled so can't change password. Aborting.\\n\");\n\t\t\t\t\tcmd = CMD_LEAVE;\n\t\t\t\t\tif (newpw) {\n\t\t\t\t\t\tfree(newpw);\n\t\t\t\t\t\tnewpw = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif (backup_password) {\n\t\t\t\t\t\tfree(backup_password);\n\t\t\t\t\t\tbackup_password = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (newpw) {\n\t\t\t\tplist_dict_set_item(opts, \"NewPassword\", plist_new_string(newpw));\n\t\t\t}\n\t\t\tif (backup_password) {\n\t\t\t\tplist_dict_set_item(opts, \"OldPassword\", plist_new_string(backup_password));\n\t\t\t}\n\t\t\tif (newpw || backup_password) {\n\t\t\t\tmobilebackup2_send_message(mobilebackup2, \"ChangePassword\", opts);\n\t\t\t\t/*if (cmd_flags & CMD_FLAG_ENCRYPTION_ENABLE) {\n\t\t\t\t\tint retr = 10;\n\t\t\t\t\twhile ((retr-- >= 0) && !backup_domain_changed) {\n\t\t\t\t\t\tsleep(1);\n\t\t\t\t\t}\n\t\t\t\t}*/\n\t\t\t} else {\n\t\t\t\tcmd = CMD_LEAVE;\n\t\t\t}\n\t\t\tplist_free(opts);\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\t/* close down the lockdown connection as it is no longer needed */\n\t\tif (lockdown) {\n\t\t\tlockdownd_client_free(lockdown);\n\t\t\tlockdown = NULL;\n\t\t}\n\n\t\tif (cmd != CMD_LEAVE) {\n\t\t\t/* reset operation success status */\n\t\t\tint operation_ok = 0;\n\t\t\tplist_t message = NULL;\n\n\t\t\tchar *dlmsg = NULL;\n\t\t\tint file_count = 0;\n\t\t\tint errcode = 0;\n\t\t\tconst char *errdesc = NULL;\n\n\t\t\t/* process series of DLMessage* operations */\n\t\t\tdo {\n\t\t\t\tif (dlmsg) {\n\t\t\t\t\tfree(dlmsg);\n\t\t\t\t\tdlmsg = NULL;\n\t\t\t\t}\n\t\t\t\tmobilebackup2_receive_message(mobilebackup2, &message, &dlmsg);\n\t\t\t\tif (!message || !dlmsg) {\n\t\t\t\t\tPRINT_VERBOSE(1, \"Device is not ready yet. Going to try again in 2 seconds...\\n\");\n\t\t\t\t\tsleep(2);\n\t\t\t\t\tgoto files_out;\n\t\t\t\t}\n\n\t\t\t\tif (!strcmp(dlmsg, \"DLMessageDownloadFiles\")) {\n\t\t\t\t\t/* device wants to download files from the computer */\n\t\t\t\t\tmb2_set_overall_progress_from_message(message, dlmsg);\n\t\t\t\t\tmb2_handle_send_files(mobilebackup2, message, backup_directory);\n\t\t\t\t} else if (!strcmp(dlmsg, \"DLMessageUploadFiles\")) {\n\t\t\t\t\t/* device wants to send files to the computer */\n\t\t\t\t\tmb2_set_overall_progress_from_message(message, dlmsg);\n\t\t\t\t\tfile_count += mb2_handle_receive_files(mobilebackup2, message, backup_directory);\n\t\t\t\t} else if (!strcmp(dlmsg, \"DLMessageGetFreeDiskSpace\")) {\n\t\t\t\t\t/* device wants to know how much disk space is available on the computer */\n\t\t\t\t\tuint64_t freespace = 0;\n\t\t\t\t\tint res = -1;\n#ifdef WIN32\n\t\t\t\t\tif (GetDiskFreeSpaceEx(backup_directory, (PULARGE_INTEGER)&freespace, NULL, NULL)) {\n\t\t\t\t\t\tres = 0;\n\t\t\t\t\t}\n#else\n\t\t\t\t\tstruct statvfs fs;\n\t\t\t\t\tmemset(&fs, '\\0', sizeof(fs));\n\t\t\t\t\tres = statvfs(backup_directory, &fs);\n\t\t\t\t\tif (res == 0) {\n\t\t\t\t\t\tfreespace = (uint64_t)fs.f_bavail * (uint64_t)fs.f_bsize;\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tplist_t freespace_item = plist_new_uint(freespace);\n\t\t\t\t\tmobilebackup2_send_status_response(mobilebackup2, res, NULL, freespace_item);\n\t\t\t\t\tplist_free(freespace_item);\n\t\t\t\t} else if (!strcmp(dlmsg, \"DLContentsOfDirectory\")) {\n\t\t\t\t\t/* list directory contents */\n\t\t\t\t\tmb2_handle_list_directory(mobilebackup2, message, backup_directory);\n\t\t\t\t} else if (!strcmp(dlmsg, \"DLMessageCreateDirectory\")) {\n\t\t\t\t\t/* make a directory */\n\t\t\t\t\tmb2_handle_make_directory(mobilebackup2, message, backup_directory);\n\t\t\t\t} else if (!strcmp(dlmsg, \"DLMessageMoveFiles\") || !strcmp(dlmsg, \"DLMessageMoveItems\")) {\n\t\t\t\t\t/* perform a series of rename operations */\n\t\t\t\t\tmb2_set_overall_progress_from_message(message, dlmsg);\n\t\t\t\t\tplist_t moves = plist_array_get_item(message, 1);\n\t\t\t\t\tuint32_t cnt = plist_dict_get_size(moves);\n\t\t\t\t\tPRINT_VERBOSE(1, \"Moving %d file%s\\n\", cnt, (cnt == 1) ? \"\" : \"s\");\n\t\t\t\t\tplist_dict_iter iter = NULL;\n\t\t\t\t\tplist_dict_new_iter(moves, &iter);\n\t\t\t\t\terrcode = 0;\n\t\t\t\t\terrdesc = NULL;\n\t\t\t\t\tif (iter) {\n\t\t\t\t\t\tchar *key = NULL;\n\t\t\t\t\t\tplist_t val = NULL;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tplist_dict_next_item(moves, iter, &key, &val);\n\t\t\t\t\t\t\tif (key && (plist_get_node_type(val) == PLIST_STRING)) {\n\t\t\t\t\t\t\t\tchar *str = NULL;\n\t\t\t\t\t\t\t\tplist_get_string_val(val, &str);\n\t\t\t\t\t\t\t\tif (str) {\n\t\t\t\t\t\t\t\t\tchar *newpath = string_build_path(backup_directory, str, NULL);\n\t\t\t\t\t\t\t\t\tfree(str);\n\t\t\t\t\t\t\t\t\tchar *oldpath = string_build_path(backup_directory, key, NULL);\n\n#ifdef WIN32\n\t\t\t\t\t\t\t\t\tif ((stat(newpath, &st) == 0) && S_ISDIR(st.st_mode))\n\t\t\t\t\t\t\t\t\t\tRemoveDirectory(newpath);\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\tDeleteFile(newpath);\n#else\n\t\t\t\t\t\t\t\t\tremove(newpath);\n#endif\n\t\t\t\t\t\t\t\t\tif (rename(oldpath, newpath) < 0) {\n\t\t\t\t\t\t\t\t\t\tprintf(\"Renameing '%s' to '%s' failed: %s (%d)\\n\", oldpath, newpath, strerror(errno), errno);\n\t\t\t\t\t\t\t\t\t\terrcode = errno_to_device_error(errno);\n\t\t\t\t\t\t\t\t\t\terrdesc = strerror(errno);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tfree(oldpath);\n\t\t\t\t\t\t\t\t\tfree(newpath);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfree(key);\n\t\t\t\t\t\t\t\tkey = NULL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} while (val);\n\t\t\t\t\t\tfree(iter);\n\t\t\t\t\t} else {\n\t\t\t\t\t\terrcode = -1;\n\t\t\t\t\t\terrdesc = \"Could not create dict iterator\";\n\t\t\t\t\t\tprintf(\"Could not create dict iterator\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tplist_t empty_dict = plist_new_dict();\n\t\t\t\t\terr = mobilebackup2_send_status_response(mobilebackup2, errcode, errdesc, empty_dict);\n\t\t\t\t\tplist_free(empty_dict);\n\t\t\t\t\tif (err != MOBILEBACKUP2_E_SUCCESS) {\n\t\t\t\t\t\tprintf(\"Could not send status response, error %d\\n\", err);\n\t\t\t\t\t}\n\t\t\t\t} else if (!strcmp(dlmsg, \"DLMessageRemoveFiles\") || !strcmp(dlmsg, \"DLMessageRemoveItems\")) {\n\t\t\t\t\tmb2_set_overall_progress_from_message(message, dlmsg);\n\t\t\t\t\tplist_t removes = plist_array_get_item(message, 1);\n\t\t\t\t\tuint32_t cnt = plist_array_get_size(removes);\n\t\t\t\t\tPRINT_VERBOSE(1, \"Removing %d file%s\\n\", cnt, (cnt == 1) ? \"\" : \"s\");\n\t\t\t\t\tuint32_t ii = 0;\n\t\t\t\t\terrcode = 0;\n\t\t\t\t\terrdesc = NULL;\n\t\t\t\t\tfor (ii = 0; ii < cnt; ii++) {\n\t\t\t\t\t\tplist_t val = plist_array_get_item(removes, ii);\n\t\t\t\t\t\tif (plist_get_node_type(val) == PLIST_STRING) {\n\t\t\t\t\t\t\tchar *str = NULL;\n\t\t\t\t\t\t\tplist_get_string_val(val, &str);\n\t\t\t\t\t\t\tif (str) {\n\t\t\t\t\t\t\t\tconst char *checkfile = strchr(str, '/');\n\t\t\t\t\t\t\t\tint suppress_warning = 0;\n\t\t\t\t\t\t\t\tif (checkfile) {\n\t\t\t\t\t\t\t\t\tif (strcmp(checkfile+1, \"Manifest.mbdx\") == 0) {\n\t\t\t\t\t\t\t\t\t\tsuppress_warning = 1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tchar *newpath = string_build_path(backup_directory, str, NULL);\n\t\t\t\t\t\t\t\tfree(str);\n#ifdef WIN32\n\t\t\t\t\t\t\t\tint res = 0;\n\t\t\t\t\t\t\t\tif ((stat(newpath, &st) == 0) && S_ISDIR(st.st_mode))\n\t\t\t\t\t\t\t\t\tres = RemoveDirectory(newpath);\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tres = DeleteFile(newpath);\n\t\t\t\t\t\t\t\tif (!res) {\n\t\t\t\t\t\t\t\t\tint e = win32err_to_errno(GetLastError());\n\t\t\t\t\t\t\t\t\tif (!suppress_warning)\n\t\t\t\t\t\t\t\t\t\tprintf(\"Could not remove '%s': %s (%d)\\n\", newpath, strerror(e), e);\n\t\t\t\t\t\t\t\t\terrcode = errno_to_device_error(e);\n\t\t\t\t\t\t\t\t\terrdesc = strerror(e);\n\t\t\t\t\t\t\t\t}\n#else\n\t\t\t\t\t\t\t\tif (remove(newpath) < 0) {\n\t\t\t\t\t\t\t\t\tif (!suppress_warning)\n\t\t\t\t\t\t\t\t\t\tprintf(\"Could not remove '%s': %s (%d)\\n\", newpath, strerror(errno), errno);\n\t\t\t\t\t\t\t\t\terrcode = errno_to_device_error(errno);\n\t\t\t\t\t\t\t\t\terrdesc = strerror(errno);\n\t\t\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t\t\t\tfree(newpath);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tplist_t empty_dict = plist_new_dict();\n\t\t\t\t\terr = mobilebackup2_send_status_response(mobilebackup2, errcode, errdesc, empty_dict);\n\t\t\t\t\tplist_free(empty_dict);\n\t\t\t\t\tif (err != MOBILEBACKUP2_E_SUCCESS) {\n\t\t\t\t\t\tprintf(\"Could not send status response, error %d\\n\", err);\n\t\t\t\t\t}\n\t\t\t\t} else if (!strcmp(dlmsg, \"DLMessageCopyItem\")) {\n\t\t\t\t\tplist_t srcpath = plist_array_get_item(message, 1);\n\t\t\t\t\tplist_t dstpath = plist_array_get_item(message, 2);\n\t\t\t\t\terrcode = 0;\n\t\t\t\t\terrdesc = NULL;\n\t\t\t\t\tif ((plist_get_node_type(srcpath) == PLIST_STRING) && (plist_get_node_type(dstpath) == PLIST_STRING)) {\n\t\t\t\t\t\tchar *src = NULL;\n\t\t\t\t\t\tchar *dst = NULL;\n\t\t\t\t\t\tplist_get_string_val(srcpath, &src);\n\t\t\t\t\t\tplist_get_string_val(dstpath, &dst);\n\t\t\t\t\t\tif (src && dst) {\n\t\t\t\t\t\t\tchar *oldpath = string_build_path(backup_directory, src, NULL);\n\t\t\t\t\t\t\tchar *newpath = string_build_path(backup_directory, dst, NULL);\n\n\t\t\t\t\t\t\tPRINT_VERBOSE(1, \"Copying '%s' to '%s'\\n\", src, dst);\n\n\t\t\t\t\t\t\t/* check that src exists */\n\t\t\t\t\t\t\tif ((stat(oldpath, &st) == 0) && S_ISDIR(st.st_mode)) {\n\t\t\t\t\t\t\t\tmb2_copy_directory_by_path(oldpath, newpath);\n\t\t\t\t\t\t\t} else if ((stat(oldpath, &st) == 0) && S_ISREG(st.st_mode)) {\n\t\t\t\t\t\t\t\tmb2_copy_file_by_path(oldpath, newpath);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfree(newpath);\n\t\t\t\t\t\t\tfree(oldpath);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree(src);\n\t\t\t\t\t\tfree(dst);\n\t\t\t\t\t}\n\t\t\t\t\tplist_t empty_dict = plist_new_dict();\n\t\t\t\t\terr = mobilebackup2_send_status_response(mobilebackup2, errcode, errdesc, empty_dict);\n\t\t\t\t\tplist_free(empty_dict);\n\t\t\t\t\tif (err != MOBILEBACKUP2_E_SUCCESS) {\n\t\t\t\t\t\tprintf(\"Could not send status response, error %d\\n\", err);\n\t\t\t\t\t}\n\t\t\t\t} else if (!strcmp(dlmsg, \"DLMessageDisconnect\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (!strcmp(dlmsg, \"DLMessageProcessMessage\")) {\n\t\t\t\t\tnode_tmp = plist_array_get_item(message, 1);\n\t\t\t\t\tif (plist_get_node_type(node_tmp) != PLIST_DICT) {\n\t\t\t\t\t\tprintf(\"Unknown message received!\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tplist_t nn;\n\t\t\t\t\tint error_code = -1;\n\t\t\t\t\tnn = plist_dict_get_item(node_tmp, \"ErrorCode\");\n\t\t\t\t\tif (nn && (plist_get_node_type(nn) == PLIST_UINT)) {\n\t\t\t\t\t\tuint64_t ec = 0;\n\t\t\t\t\t\tplist_get_uint_val(nn, &ec);\n\t\t\t\t\t\terror_code = (uint32_t)ec;\n\t\t\t\t\t\tif (error_code == 0) {\n\t\t\t\t\t\t\toperation_ok = 1;\n\t\t\t\t\t\t\tresult_code = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult_code = -error_code;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tnn = plist_dict_get_item(node_tmp, \"ErrorDescription\");\n\t\t\t\t\tchar *str = NULL;\n\t\t\t\t\tif (nn && (plist_get_node_type(nn) == PLIST_STRING)) {\n\t\t\t\t\t\tplist_get_string_val(nn, &str);\n\t\t\t\t\t}\n\t\t\t\t\tif (error_code != 0) {\n\t\t\t\t\t\tif (str) {\n\t\t\t\t\t\t\tprintf(\"ErrorCode %d: %s\\n\", error_code, str);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tprintf(\"ErrorCode %d: (Unknown)\\n\", error_code);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (str) {\n\t\t\t\t\t\tfree(str);\n\t\t\t\t\t}\n\t\t\t\t\tnn = plist_dict_get_item(node_tmp, \"Content\");\n\t\t\t\t\tif (nn && (plist_get_node_type(nn) == PLIST_STRING)) {\n\t\t\t\t\t\tstr = NULL;\n\t\t\t\t\t\tplist_get_string_val(nn, &str);\n\t\t\t\t\t\tPRINT_VERBOSE(1, \"Content:\\n\");\n\t\t\t\t\t\tprintf(\"%s\", str);\n\t\t\t\t\t\tfree(str);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* print status */\n\t\t\t\tif (overall_progress > 0) {\n\t\t\t\t\tprint_progress_real(overall_progress, 0);\n\t\t\t\t\tPRINT_VERBOSE(1, \" Finished\\n\");\n\t\t\t\t}\n\nfiles_out:\n\t\t\t\tif (message)\n\t\t\t\t\tplist_free(message);\n\t\t\t\tmessage = NULL;\n\t\t\t\tif (dlmsg)\n\t\t\t\t\tfree(dlmsg);\n\t\t\t\tdlmsg = NULL;\n\n\t\t\t\tif (quit_flag > 0) {\n\t\t\t\t\t/* need to cancel the backup here */\n\t\t\t\t\t//mobilebackup_send_error(mobilebackup, \"Cancelling DLSendFile\");\n\n\t\t\t\t\t/* remove any atomic Manifest.plist.tmp */\n\n\t\t\t\t\t/*manifest_path = mobilebackup_build_path(backup_directory, \"Manifest\", \".plist.tmp\");\n\t\t\t\t\tif (stat(manifest_path, &st) == 0)\n\t\t\t\t\t\tremove(manifest_path);*/\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (1);\n\n\t\t\t/* report operation status to user */\n\t\t\tswitch (cmd) {\n\t\t\t\tcase CMD_CLOUD:\n\t\t\t\tif (cmd_flags & CMD_FLAG_CLOUD_ENABLE) {\n\t\t\t\t\tif (operation_ok) {\n\t\t\t\t\t\tPRINT_VERBOSE(1, \"Cloud backup has been enabled successfully.\\n\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tPRINT_VERBOSE(1, \"Could not enable cloud backup.\\n\");\n\t\t\t\t\t}\n\t\t\t\t} else if (cmd_flags & CMD_FLAG_CLOUD_DISABLE) {\n\t\t\t\t\tif (operation_ok) {\n\t\t\t\t\t\tPRINT_VERBOSE(1, \"Cloud backup has been disabled successfully.\\n\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tPRINT_VERBOSE(1, \"Could not disable cloud backup.\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\tcase CMD_BACKUP:\n\t\t\t\t\tPRINT_VERBOSE(1, \"Received %d files from device.\\n\", file_count);\n\t\t\t\t\tif (operation_ok && mb2_status_check_snapshot_state(backup_directory, udid, \"finished\")) {\n\t\t\t\t\t\tPRINT_VERBOSE(1, \"Backup Successful.\\n\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (quit_flag) {\n\t\t\t\t\t\t\tPRINT_VERBOSE(1, \"Backup Aborted.\\n\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tPRINT_VERBOSE(1, \"Backup Failed (Error Code %d).\\n\", -result_code);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\tcase CMD_UNBACK:\n\t\t\t\tif (quit_flag) {\n\t\t\t\t\tPRINT_VERBOSE(1, \"Unback Aborted.\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tPRINT_VERBOSE(1, \"The files can now be found in the \\\"_unback_\\\" directory.\\n\");\n\t\t\t\t\tPRINT_VERBOSE(1, \"Unback Successful.\\n\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\tcase CMD_CHANGEPW:\n\t\t\t\tif (cmd_flags & CMD_FLAG_ENCRYPTION_ENABLE) {\n\t\t\t\t\tif (operation_ok) {\n\t\t\t\t\t\tPRINT_VERBOSE(1, \"Backup encryption has been enabled successfully.\\n\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tPRINT_VERBOSE(1, \"Could not enable backup encryption.\\n\");\n\t\t\t\t\t}\n\t\t\t\t} else if (cmd_flags & CMD_FLAG_ENCRYPTION_DISABLE) {\n\t\t\t\t\tif (operation_ok) {\n\t\t\t\t\t\tPRINT_VERBOSE(1, \"Backup encryption has been disabled successfully.\\n\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tPRINT_VERBOSE(1, \"Could not disable backup encryption.\\n\");\n\t\t\t\t\t}\n\t\t\t\t} else if (cmd_flags & CMD_FLAG_ENCRYPTION_CHANGEPW) {\n\t\t\t\t\tif (operation_ok) {\n\t\t\t\t\t\tPRINT_VERBOSE(1, \"Backup encryption password has been changed successfully.\\n\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tPRINT_VERBOSE(1, \"Could not change backup encryption password.\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\tcase CMD_RESTORE:\n\t\t\t\tif (cmd_flags & CMD_FLAG_RESTORE_REBOOT)\n\t\t\t\t\tPRINT_VERBOSE(1, \"The device should reboot now.\\n\");\n\t\t\t\tif (operation_ok) {\n\t\t\t\t\tPRINT_VERBOSE(1, \"Restore Successful.\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tPRINT_VERBOSE(1, \"Restore Failed (Error Code %d).\\n\", -result_code);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\tcase CMD_INFO:\n\t\t\t\tcase CMD_LIST:\n\t\t\t\tcase CMD_LEAVE:\n\t\t\t\tdefault:\n\t\t\t\tif (quit_flag) {\n\t\t\t\t\tPRINT_VERBOSE(1, \"Operation Aborted.\\n\");\n\t\t\t\t} else if (cmd == CMD_LEAVE) {\n\t\t\t\t\tPRINT_VERBOSE(1, \"Operation Failed.\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tPRINT_VERBOSE(1, \"Operation Successful.\\n\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (lockfile) {\n\t\t\tafc_file_lock(afc, lockfile, AFC_LOCK_UN);\n\t\t\tafc_file_close(afc, lockfile);\n\t\t\tlockfile = 0;\n\t\t\tif (cmd == CMD_BACKUP)\n\t\t\t\tdo_post_notification(device, NP_SYNC_DID_FINISH);\n\t\t}\n\t} else {\n\t\tprintf(\"ERROR: Could not start service %s.\\n\", MOBILEBACKUP2_SERVICE_NAME);\n\t\tlockdownd_client_free(lockdown);\n\t\tlockdown = NULL;\n\t}\n\n\tif (lockdown) {\n\t\tlockdownd_client_free(lockdown);\n\t\tlockdown = NULL;\n\t}\n\n\tif (mobilebackup2) {\n\t\tmobilebackup2_client_free(mobilebackup2);\n\t\tmobilebackup2 = NULL;\n\t}\n\n\tif (afc) {\n\t\tafc_client_free(afc);\n\t\tafc = NULL;\n\t}\n\n\tif (np) {\n\t\tnp_client_free(np);\n\t\tnp = NULL;\n\t}\n\n\tidevice_free(device);\n\tdevice = NULL;\n\n\tif (backup_password) {\n\t\tfree(backup_password);\n\t}\n\n\tif (udid) {\n\t\tfree(udid);\n\t\tudid = NULL;\n\t}\n\tif (source_udid) {\n\t\tfree(source_udid);\n\t\tsource_udid = NULL;\n\t}\n\n\treturn result_code;\n}"
  },
  {
    "function_name": "print_usage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
    "lines": "1114-1147",
    "snippet": "static void print_usage(int argc, char **argv)\n{\n\tchar *name = NULL;\n\tname = strrchr(argv[0], '/');\n\tprintf(\"Usage: %s [OPTIONS] CMD [CMDOPTIONS] DIRECTORY\\n\", (name ? name + 1: argv[0]));\n\tprintf(\"Create or restore backup from the current or specified directory.\\n\\n\");\n\tprintf(\"commands:\\n\");\n\tprintf(\"  backup\\tcreate backup for the device\\n\");\n\tprintf(\"    --full\\t\\tforce full backup from device.\\n\");\n\tprintf(\"  restore\\trestore last backup to the device\\n\");\n\tprintf(\"    --system\\t\\trestore system files, too.\\n\");\n\tprintf(\"    --reboot\\t\\treboot the system when done.\\n\");\n\tprintf(\"    --copy\\t\\tcreate a copy of backup folder before restoring.\\n\");\n\tprintf(\"    --settings\\t\\trestore device settings from the backup.\\n\");\n\tprintf(\"    --remove\\t\\tremove items which are not being restored\\n\");\n\tprintf(\"    --password PWD\\tsupply the password of the source backup\\n\");\n\tprintf(\"  info\\t\\tshow details about last completed backup of device\\n\");\n\tprintf(\"  list\\t\\tlist files of last completed backup in CSV format\\n\");\n\tprintf(\"  unback\\tunpack a completed backup in DIRECTORY/_unback_/\\n\");\n\tprintf(\"  encryption on|off [PWD]\\tenable or disable backup encryption\\n\");\n\tprintf(\"    NOTE: password will be requested in interactive mode if omitted\\n\");\n\tprintf(\"  changepw [OLD NEW]  change backup password on target device\\n\");\n\tprintf(\"    NOTE: passwords will be requested in interactive mode if omitted\\n\");\n\tprintf(\"  cloud on|off\\tenable or disable cloud use (requires iCloud account)\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"options:\\n\");\n\tprintf(\"  -d, --debug\\t\\tenable communication debugging\\n\");\n\tprintf(\"  -u, --udid UDID\\ttarget specific device by its 40-digit device UDID\\n\");\n\tprintf(\"  -s, --source UDID\\tuse backup data from device specified by UDID\\n\");\n\tprintf(\"  -i, --interactive\\trequest passwords interactively\\n\");\n\tprintf(\"  -h, --help\\t\\tprints usage information\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"Homepage: <\" PACKAGE_URL \">\\n\");\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <sys/statvfs.h>",
      "#include <termios.h>",
      "#include <conio.h>",
      "#include <windows.h>",
      "#include <endianness.h>",
      "#include \"common/utils.h\"",
      "#include <libimobiledevice/afc.h>",
      "#include <libimobiledevice/notification_proxy.h>",
      "#include <libimobiledevice/mobilebackup2.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <libgen.h>",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Homepage: <\" PACKAGE_URL \">\\n\""
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  -h, --help\\t\\tprints usage information\\n\""
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  -i, --interactive\\trequest passwords interactively\\n\""
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  -s, --source UDID\\tuse backup data from device specified by UDID\\n\""
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  -u, --udid UDID\\ttarget specific device by its 40-digit device UDID\\n\""
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  -d, --debug\\t\\tenable communication debugging\\n\""
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"options:\\n\""
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  cloud on|off\\tenable or disable cloud use (requires iCloud account)\\n\""
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"    NOTE: passwords will be requested in interactive mode if omitted\\n\""
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  changepw [OLD NEW]  change backup password on target device\\n\""
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"    NOTE: password will be requested in interactive mode if omitted\\n\""
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  encryption on|off [PWD]\\tenable or disable backup encryption\\n\""
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  unback\\tunpack a completed backup in DIRECTORY/_unback_/\\n\""
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  list\\t\\tlist files of last completed backup in CSV format\\n\""
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  info\\t\\tshow details about last completed backup of device\\n\""
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"    --password PWD\\tsupply the password of the source backup\\n\""
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"    --remove\\t\\tremove items which are not being restored\\n\""
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"    --settings\\t\\trestore device settings from the backup.\\n\""
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"    --copy\\t\\tcreate a copy of backup folder before restoring.\\n\""
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"    --reboot\\t\\treboot the system when done.\\n\""
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"    --system\\t\\trestore system files, too.\\n\""
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  restore\\trestore last backup to the device\\n\""
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"    --full\\t\\tforce full backup from device.\\n\""
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  backup\\tcreate backup for the device\\n\""
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"commands:\\n\""
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Create or restore backup from the current or specified directory.\\n\\n\""
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Usage: %s [OPTIONS] CMD [CMDOPTIONS] DIRECTORY\\n\"",
            "(name ? name + 1: argv[0])"
          ],
          "line": 1118
        },
        "resolved": true,
        "details": {
          "function_name": "asprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/include/asprintf.h",
          "lines": "23-31",
          "snippet": "static inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}",
          "includes": [
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <config.h>\n\nstatic inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "argv[0]",
            "'/'"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void print_usage(int argc, char **argv)\n{\n\tchar *name = NULL;\n\tname = strrchr(argv[0], '/');\n\tprintf(\"Usage: %s [OPTIONS] CMD [CMDOPTIONS] DIRECTORY\\n\", (name ? name + 1: argv[0]));\n\tprintf(\"Create or restore backup from the current or specified directory.\\n\\n\");\n\tprintf(\"commands:\\n\");\n\tprintf(\"  backup\\tcreate backup for the device\\n\");\n\tprintf(\"    --full\\t\\tforce full backup from device.\\n\");\n\tprintf(\"  restore\\trestore last backup to the device\\n\");\n\tprintf(\"    --system\\t\\trestore system files, too.\\n\");\n\tprintf(\"    --reboot\\t\\treboot the system when done.\\n\");\n\tprintf(\"    --copy\\t\\tcreate a copy of backup folder before restoring.\\n\");\n\tprintf(\"    --settings\\t\\trestore device settings from the backup.\\n\");\n\tprintf(\"    --remove\\t\\tremove items which are not being restored\\n\");\n\tprintf(\"    --password PWD\\tsupply the password of the source backup\\n\");\n\tprintf(\"  info\\t\\tshow details about last completed backup of device\\n\");\n\tprintf(\"  list\\t\\tlist files of last completed backup in CSV format\\n\");\n\tprintf(\"  unback\\tunpack a completed backup in DIRECTORY/_unback_/\\n\");\n\tprintf(\"  encryption on|off [PWD]\\tenable or disable backup encryption\\n\");\n\tprintf(\"    NOTE: password will be requested in interactive mode if omitted\\n\");\n\tprintf(\"  changepw [OLD NEW]  change backup password on target device\\n\");\n\tprintf(\"    NOTE: passwords will be requested in interactive mode if omitted\\n\");\n\tprintf(\"  cloud on|off\\tenable or disable cloud use (requires iCloud account)\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"options:\\n\");\n\tprintf(\"  -d, --debug\\t\\tenable communication debugging\\n\");\n\tprintf(\"  -u, --udid UDID\\ttarget specific device by its 40-digit device UDID\\n\");\n\tprintf(\"  -s, --source UDID\\tuse backup data from device specified by UDID\\n\");\n\tprintf(\"  -i, --interactive\\trequest passwords interactively\\n\");\n\tprintf(\"  -h, --help\\t\\tprints usage information\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"Homepage: <\" PACKAGE_URL \">\\n\");\n}"
  },
  {
    "function_name": "clean_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
    "lines": "1108-1112",
    "snippet": "static void clean_exit(int sig)\n{\n\tfprintf(stderr, \"Exiting...\\n\");\n\tquit_flag++;\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <sys/statvfs.h>",
      "#include <termios.h>",
      "#include <conio.h>",
      "#include <windows.h>",
      "#include <endianness.h>",
      "#include \"common/utils.h\"",
      "#include <libimobiledevice/afc.h>",
      "#include <libimobiledevice/notification_proxy.h>",
      "#include <libimobiledevice/mobilebackup2.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <libgen.h>",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int quit_flag = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Exiting...\\n\""
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int quit_flag = 0;\n\nstatic void clean_exit(int sig)\n{\n\tfprintf(stderr, \"Exiting...\\n\");\n\tquit_flag++;\n}"
  },
  {
    "function_name": "ask_for_password",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
    "lines": "1080-1103",
    "snippet": "static char* ask_for_password(const char* msg, int type_again)\n{\n\tchar pwbuf[256];\n\n\tfprintf(stderr, \"%s: \", msg);\n\tfflush(stderr);\n\tget_hidden_input(pwbuf, 256);\n\tfputc('\\n', stderr);\n\n\tif (type_again) {\n\t\tchar pwrep[256];\n\n\t\tfprintf(stderr, \"%s (repeat): \", msg);\n\t\tfflush(stderr);\n\t\tget_hidden_input(pwrep, 256);\n\t\tfputc('\\n', stderr);\n\n\t\tif (strcmp(pwbuf, pwrep) != 0) {\n\t\t\tprintf(\"ERROR: passwords don't match\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn strdup(pwbuf);\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <sys/statvfs.h>",
      "#include <termios.h>",
      "#include <conio.h>",
      "#include <windows.h>",
      "#include <endianness.h>",
      "#include \"common/utils.h\"",
      "#include <libimobiledevice/afc.h>",
      "#include <libimobiledevice/notification_proxy.h>",
      "#include <libimobiledevice/mobilebackup2.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <libgen.h>",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "pwbuf"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ERROR: passwords don't match\\n\""
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "pwbuf",
            "pwrep"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "plist_strcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
          "lines": "296-309",
          "snippet": "static int plist_strcmp(plist_t node, const char *str)\n{\n\tchar *buffer = NULL;\n\tint ret = 0;\n\n\tif (plist_get_node_type(node) != PLIST_STRING)\n\t\treturn ret;\n\n\tplist_get_string_val(node, &buffer);\n\tret = strcmp(buffer, str);\n\tfree(buffer);\n\n\treturn ret;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <unistd.h>",
            "#include <gcrypt.h>",
            "#include <openssl/sha.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int plist_strcmp(plist_t node, const char *str)\n{\n\tchar *buffer = NULL;\n\tint ret = 0;\n\n\tif (plist_get_node_type(node) != PLIST_STRING)\n\t\treturn ret;\n\n\tplist_get_string_val(node, &buffer);\n\tret = strcmp(buffer, str);\n\tfree(buffer);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fputc",
          "args": [
            "'\\n'",
            "stderr"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_hidden_input",
          "args": [
            "pwrep",
            "256"
          ],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "get_hidden_input",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
          "lines": "1058-1078",
          "snippet": "static void get_hidden_input(char *buf, int maxlen)\n{\n\tint pwlen = 0;\n\tint c;\n\n\twhile ((c = my_getch())) {\n\t\tif ((c == '\\r') || (c == '\\n')) {\n\t\t\tbreak;\n\t\t} else if (isprint(c)) {\n\t\t\tif (pwlen < maxlen-1)\n\t\t\t\tbuf[pwlen++] = c;\n\t\t\tfputc('*', stderr);\n\t\t} else if (c == BS_CC) {\n\t\t\tif (pwlen > 0) {\n\t\t\t\tfputs(\"\\b \\b\", stderr);\n\t\t\t\tpwlen--;\n\t\t\t}\n\t\t}\n\t}\n\tbuf[pwlen] = 0;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <sys/statvfs.h>",
            "#include <termios.h>",
            "#include <conio.h>",
            "#include <windows.h>",
            "#include <endianness.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup2.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <libgen.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define BS_CC 0x7f",
            "#define my_getch getch",
            "#define BS_CC '\\b'"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\n#define BS_CC 0x7f\n#define my_getch getch\n#define BS_CC '\\b'\n\nstatic void get_hidden_input(char *buf, int maxlen)\n{\n\tint pwlen = 0;\n\tint c;\n\n\twhile ((c = my_getch())) {\n\t\tif ((c == '\\r') || (c == '\\n')) {\n\t\t\tbreak;\n\t\t} else if (isprint(c)) {\n\t\t\tif (pwlen < maxlen-1)\n\t\t\t\tbuf[pwlen++] = c;\n\t\t\tfputc('*', stderr);\n\t\t} else if (c == BS_CC) {\n\t\t\tif (pwlen > 0) {\n\t\t\t\tfputs(\"\\b \\b\", stderr);\n\t\t\t\tpwlen--;\n\t\t\t}\n\t\t}\n\t}\n\tbuf[pwlen] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stderr"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s (repeat): \"",
            "msg"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fputc",
          "args": [
            "'\\n'",
            "stderr"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stderr"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: \"",
            "msg"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic char* ask_for_password(const char* msg, int type_again)\n{\n\tchar pwbuf[256];\n\n\tfprintf(stderr, \"%s: \", msg);\n\tfflush(stderr);\n\tget_hidden_input(pwbuf, 256);\n\tfputc('\\n', stderr);\n\n\tif (type_again) {\n\t\tchar pwrep[256];\n\n\t\tfprintf(stderr, \"%s (repeat): \", msg);\n\t\tfflush(stderr);\n\t\tget_hidden_input(pwrep, 256);\n\t\tfputc('\\n', stderr);\n\n\t\tif (strcmp(pwbuf, pwrep) != 0) {\n\t\t\tprintf(\"ERROR: passwords don't match\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn strdup(pwbuf);\n}"
  },
  {
    "function_name": "get_hidden_input",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
    "lines": "1058-1078",
    "snippet": "static void get_hidden_input(char *buf, int maxlen)\n{\n\tint pwlen = 0;\n\tint c;\n\n\twhile ((c = my_getch())) {\n\t\tif ((c == '\\r') || (c == '\\n')) {\n\t\t\tbreak;\n\t\t} else if (isprint(c)) {\n\t\t\tif (pwlen < maxlen-1)\n\t\t\t\tbuf[pwlen++] = c;\n\t\t\tfputc('*', stderr);\n\t\t} else if (c == BS_CC) {\n\t\t\tif (pwlen > 0) {\n\t\t\t\tfputs(\"\\b \\b\", stderr);\n\t\t\t\tpwlen--;\n\t\t\t}\n\t\t}\n\t}\n\tbuf[pwlen] = 0;\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <sys/statvfs.h>",
      "#include <termios.h>",
      "#include <conio.h>",
      "#include <windows.h>",
      "#include <endianness.h>",
      "#include \"common/utils.h\"",
      "#include <libimobiledevice/afc.h>",
      "#include <libimobiledevice/notification_proxy.h>",
      "#include <libimobiledevice/mobilebackup2.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <libgen.h>",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define BS_CC 0x7f",
      "#define my_getch getch",
      "#define BS_CC '\\b'"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fputs",
          "args": [
            "\"\\b \\b\"",
            "stderr"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fputc",
          "args": [
            "'*'",
            "stderr"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isprint",
          "args": [
            "c"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "my_getch",
          "args": [],
          "line": 1063
        },
        "resolved": true,
        "details": {
          "function_name": "my_getch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
          "lines": "1044-1055",
          "snippet": "static int my_getch(void)\n{\n\tstruct termios oldt, newt;\n\tint ch;\n\ttcgetattr(STDIN_FILENO, &oldt);\n\tnewt = oldt;\n\tnewt.c_lflag &= ~(ICANON | ECHO);\n\ttcsetattr(STDIN_FILENO, TCSANOW, &newt);\n\tch = getchar();\n\ttcsetattr(STDIN_FILENO, TCSANOW, &oldt);\n\treturn ch;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <sys/statvfs.h>",
            "#include <termios.h>",
            "#include <conio.h>",
            "#include <windows.h>",
            "#include <endianness.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup2.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <libgen.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define my_getch getch"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\n#define my_getch getch\n\nstatic int my_getch(void)\n{\n\tstruct termios oldt, newt;\n\tint ch;\n\ttcgetattr(STDIN_FILENO, &oldt);\n\tnewt = oldt;\n\tnewt.c_lflag &= ~(ICANON | ECHO);\n\ttcsetattr(STDIN_FILENO, TCSANOW, &newt);\n\tch = getchar();\n\ttcsetattr(STDIN_FILENO, TCSANOW, &oldt);\n\treturn ch;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\n#define BS_CC 0x7f\n#define my_getch getch\n#define BS_CC '\\b'\n\nstatic void get_hidden_input(char *buf, int maxlen)\n{\n\tint pwlen = 0;\n\tint c;\n\n\twhile ((c = my_getch())) {\n\t\tif ((c == '\\r') || (c == '\\n')) {\n\t\t\tbreak;\n\t\t} else if (isprint(c)) {\n\t\t\tif (pwlen < maxlen-1)\n\t\t\t\tbuf[pwlen++] = c;\n\t\t\tfputc('*', stderr);\n\t\t} else if (c == BS_CC) {\n\t\t\tif (pwlen > 0) {\n\t\t\t\tfputs(\"\\b \\b\", stderr);\n\t\t\t\tpwlen--;\n\t\t\t}\n\t\t}\n\t}\n\tbuf[pwlen] = 0;\n}"
  },
  {
    "function_name": "my_getch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
    "lines": "1044-1055",
    "snippet": "static int my_getch(void)\n{\n\tstruct termios oldt, newt;\n\tint ch;\n\ttcgetattr(STDIN_FILENO, &oldt);\n\tnewt = oldt;\n\tnewt.c_lflag &= ~(ICANON | ECHO);\n\ttcsetattr(STDIN_FILENO, TCSANOW, &newt);\n\tch = getchar();\n\ttcsetattr(STDIN_FILENO, TCSANOW, &oldt);\n\treturn ch;\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <sys/statvfs.h>",
      "#include <termios.h>",
      "#include <conio.h>",
      "#include <windows.h>",
      "#include <endianness.h>",
      "#include \"common/utils.h\"",
      "#include <libimobiledevice/afc.h>",
      "#include <libimobiledevice/notification_proxy.h>",
      "#include <libimobiledevice/mobilebackup2.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <libgen.h>",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define my_getch getch"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tcsetattr",
          "args": [
            "STDIN_FILENO",
            "TCSANOW",
            "&oldt"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getchar",
          "args": [],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcsetattr",
          "args": [
            "STDIN_FILENO",
            "TCSANOW",
            "&newt"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcgetattr",
          "args": [
            "STDIN_FILENO",
            "&oldt"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\n#define my_getch getch\n\nstatic int my_getch(void)\n{\n\tstruct termios oldt, newt;\n\tint ch;\n\ttcgetattr(STDIN_FILENO, &oldt);\n\tnewt = oldt;\n\tnewt.c_lflag &= ~(ICANON | ECHO);\n\ttcsetattr(STDIN_FILENO, TCSANOW, &newt);\n\tch = getchar();\n\ttcsetattr(STDIN_FILENO, TCSANOW, &oldt);\n\treturn ch;\n}"
  },
  {
    "function_name": "mb2_copy_directory_by_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
    "lines": "994-1037",
    "snippet": "static void mb2_copy_directory_by_path(const char *src, const char *dst)\n{\n\tif (!src || !dst) {\n\t\treturn;\n\t}\n\n\tstruct stat st;\n\n\t/* if src does not exist */\n\tif ((stat(src, &st) < 0) || !S_ISDIR(st.st_mode)) {\n\t\tprintf(\"ERROR: Source directory does not exist '%s': %s (%d)\\n\", src, strerror(errno), errno);\n\t\treturn;\n\t}\n\n\t/* if dst directory does not exist */\n\tif ((stat(dst, &st) < 0) || !S_ISDIR(st.st_mode)) {\n\t\t/* create it */\n\t\tif (mkdir_with_parents(dst, 0755) < 0) {\n\t\t\tprintf(\"ERROR: Unable to create destination directory '%s': %s (%d)\\n\", dst, strerror(errno), errno);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* loop over src directory contents */\n\tDIR *cur_dir = opendir(src);\n\tif (cur_dir) {\n\t\tstruct dirent* ep;\n\t\twhile ((ep = readdir(cur_dir))) {\n\t\t\tif ((strcmp(ep->d_name, \".\") == 0) || (strcmp(ep->d_name, \"..\") == 0)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tchar *srcpath = string_build_path(src, ep->d_name, NULL);\n\t\t\tchar *dstpath = string_build_path(dst, ep->d_name, NULL);\n\t\t\tif (srcpath && dstpath) {\n\t\t\t\t/* copy file */\n\t\t\t\tmb2_copy_file_by_path(srcpath, dstpath);\n\n\t\t\t\tfree(srcpath);\n\t\t\t\tfree(dstpath);\n\t\t\t}\n\t\t}\n\t\tclosedir(cur_dir);\n\t}\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <sys/statvfs.h>",
      "#include <termios.h>",
      "#include <conio.h>",
      "#include <windows.h>",
      "#include <endianness.h>",
      "#include \"common/utils.h\"",
      "#include <libimobiledevice/afc.h>",
      "#include <libimobiledevice/notification_proxy.h>",
      "#include <libimobiledevice/mobilebackup2.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <libgen.h>",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "cur_dir"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "dstpath"
          ],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "thread_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "39-44",
          "snippet": "void thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nvoid thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb2_copy_file_by_path",
          "args": [
            "srcpath",
            "dstpath"
          ],
          "line": 1029
        },
        "resolved": true,
        "details": {
          "function_name": "mb2_copy_file_by_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
          "lines": "962-992",
          "snippet": "static void mb2_copy_file_by_path(const char *src, const char *dst)\n{\n\tFILE *from, *to;\n\tchar buf[BUFSIZ];\n\tsize_t length;\n\n\t/* open source file */\n\tif ((from = fopen(src, \"rb\")) == NULL) {\n\t\tprintf(\"Cannot open source path '%s'.\\n\", src);\n\t\treturn;\n\t}\n\n\t/* open destination file */\n\tif ((to = fopen(dst, \"wb\")) == NULL) {\n\t\tprintf(\"Cannot open destination file '%s'.\\n\", dst);\n\t\treturn;\n\t}\n\n\t/* copy the file */\n\twhile ((length = fread(buf, 1, BUFSIZ, from)) != 0) {\n\t\tfwrite(buf, 1, length, to);\n\t}\n\n\tif(fclose(from) == EOF) {\n\t\tprintf(\"Error closing source file.\\n\");\n\t}\n\n\tif(fclose(to) == EOF) {\n\t\tprintf(\"Error closing destination file.\\n\");\n\t}\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <sys/statvfs.h>",
            "#include <termios.h>",
            "#include <conio.h>",
            "#include <windows.h>",
            "#include <endianness.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup2.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <libgen.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void mb2_copy_file_by_path(const char *src, const char *dst)\n{\n\tFILE *from, *to;\n\tchar buf[BUFSIZ];\n\tsize_t length;\n\n\t/* open source file */\n\tif ((from = fopen(src, \"rb\")) == NULL) {\n\t\tprintf(\"Cannot open source path '%s'.\\n\", src);\n\t\treturn;\n\t}\n\n\t/* open destination file */\n\tif ((to = fopen(dst, \"wb\")) == NULL) {\n\t\tprintf(\"Cannot open destination file '%s'.\\n\", dst);\n\t\treturn;\n\t}\n\n\t/* copy the file */\n\twhile ((length = fread(buf, 1, BUFSIZ, from)) != 0) {\n\t\tfwrite(buf, 1, length, to);\n\t}\n\n\tif(fclose(from) == EOF) {\n\t\tprintf(\"Error closing source file.\\n\");\n\t}\n\n\tif(fclose(to) == EOF) {\n\t\tprintf(\"Error closing destination file.\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "string_build_path",
          "args": [
            "dst",
            "ep->d_name",
            "NULL"
          ],
          "line": 1026
        },
        "resolved": true,
        "details": {
          "function_name": "string_build_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/utils.c",
          "lines": "114-140",
          "snippet": "char *string_build_path(const char *elem, ...)\n{\n\tif (!elem)\n\t\treturn NULL;\n\tva_list args;\n\tint len = strlen(elem)+1;\n\tva_start(args, elem);\n\tchar *arg = va_arg(args, char*);\n\twhile (arg) {\n\t\tlen += strlen(arg)+1;\n\t\targ = va_arg(args, char*);\n\t}\n\tva_end(args);\n\n\tchar* out = (char*)malloc(len);\n\tstrcpy(out, elem);\n\n\tva_start(args, elem);\n\targ = va_arg(args, char*);\n\twhile (arg) {\n\t\tstrcat(out, \"/\");\n\t\tstrcat(out, arg);\n\t\targ = va_arg(args, char*);\n\t}\n\tva_end(args);\n\treturn out;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include <ctype.h>",
            "#include <inttypes.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include <ctype.h>\n#include <inttypes.h>\n#include <sys/time.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <config.h>\n\nchar *string_build_path(const char *elem, ...)\n{\n\tif (!elem)\n\t\treturn NULL;\n\tva_list args;\n\tint len = strlen(elem)+1;\n\tva_start(args, elem);\n\tchar *arg = va_arg(args, char*);\n\twhile (arg) {\n\t\tlen += strlen(arg)+1;\n\t\targ = va_arg(args, char*);\n\t}\n\tva_end(args);\n\n\tchar* out = (char*)malloc(len);\n\tstrcpy(out, elem);\n\n\tva_start(args, elem);\n\targ = va_arg(args, char*);\n\twhile (arg) {\n\t\tstrcat(out, \"/\");\n\t\tstrcat(out, arg);\n\t\targ = va_arg(args, char*);\n\t}\n\tva_end(args);\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ep->d_name",
            "\"..\""
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "plist_strcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
          "lines": "296-309",
          "snippet": "static int plist_strcmp(plist_t node, const char *str)\n{\n\tchar *buffer = NULL;\n\tint ret = 0;\n\n\tif (plist_get_node_type(node) != PLIST_STRING)\n\t\treturn ret;\n\n\tplist_get_string_val(node, &buffer);\n\tret = strcmp(buffer, str);\n\tfree(buffer);\n\n\treturn ret;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <unistd.h>",
            "#include <gcrypt.h>",
            "#include <openssl/sha.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int plist_strcmp(plist_t node, const char *str)\n{\n\tchar *buffer = NULL;\n\tint ret = 0;\n\n\tif (plist_get_node_type(node) != PLIST_STRING)\n\t\treturn ret;\n\n\tplist_get_string_val(node, &buffer);\n\tret = strcmp(buffer, str);\n\tfree(buffer);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "readdir",
          "args": [
            "cur_dir"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opendir",
          "args": [
            "src"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ERROR: Unable to create destination directory '%s': %s (%d)\\n\"",
            "dst",
            "strerror(errno)",
            "errno"
          ],
          "line": 1012
        },
        "resolved": true,
        "details": {
          "function_name": "asprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/include/asprintf.h",
          "lines": "23-31",
          "snippet": "static inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}",
          "includes": [
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <config.h>\n\nstatic inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir_with_parents",
          "args": [
            "dst",
            "0755"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir_with_parents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
          "lines": "172-193",
          "snippet": "static int mkdir_with_parents(const char *dir, int mode)\n{\n\tif (!dir) return -1;\n\tif (__mkdir(dir, mode) == 0) {\n\t\treturn 0;\n\t} else {\n\t\tif (errno == EEXIST) return 0;\n\t}\n\tint res;\n\tchar *parent = strdup(dir);\n\tchar *parentdir = dirname(parent);\n\tif (parentdir) {\n\t\tres = mkdir_with_parents(parentdir, mode);\n\t} else {\n\t\tres = -1;\n\t}\n\tfree(parent);\n\tif (res == 0) {\n\t\tmkdir_with_parents(dir, mode);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <sys/statvfs.h>",
            "#include <termios.h>",
            "#include <conio.h>",
            "#include <windows.h>",
            "#include <endianness.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup2.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <libgen.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int mkdir_with_parents(const char *dir, int mode)\n{\n\tif (!dir) return -1;\n\tif (__mkdir(dir, mode) == 0) {\n\t\treturn 0;\n\t} else {\n\t\tif (errno == EEXIST) return 0;\n\t}\n\tint res;\n\tchar *parent = strdup(dir);\n\tchar *parentdir = dirname(parent);\n\tif (parentdir) {\n\t\tres = mkdir_with_parents(parentdir, mode);\n\t} else {\n\t\tres = -1;\n\t}\n\tfree(parent);\n\tif (res == 0) {\n\t\tmkdir_with_parents(dir, mode);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "st.st_mode"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "dst",
            "&st"
          ],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "mobilebackup_write_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
          "lines": "322-338",
          "snippet": "static void mobilebackup_write_status(const char *path, int status)\n{\n\tstruct stat st;\n\tplist_t status_plist = plist_new_dict();\n\tplist_dict_set_item(status_plist, \"Backup Success\", plist_new_bool(status));\n\tchar *file_path = mobilebackup_build_path(path, \"Status\", \".plist\");\n\n\tif (stat(file_path, &st) == 0)\n\t\tremove(file_path);\n\n\tplist_write_to_filename(status_plist, file_path, PLIST_FORMAT_XML);\n\n\tplist_free(status_plist);\n\tstatus_plist = NULL;\n\n\tfree(file_path);\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <unistd.h>",
            "#include <gcrypt.h>",
            "#include <openssl/sha.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void mobilebackup_write_status(const char *path, int status)\n{\n\tstruct stat st;\n\tplist_t status_plist = plist_new_dict();\n\tplist_dict_set_item(status_plist, \"Backup Success\", plist_new_bool(status));\n\tchar *file_path = mobilebackup_build_path(path, \"Status\", \".plist\");\n\n\tif (stat(file_path, &st) == 0)\n\t\tremove(file_path);\n\n\tplist_write_to_filename(status_plist, file_path, PLIST_FORMAT_XML);\n\n\tplist_free(status_plist);\n\tstatus_plist = NULL;\n\n\tfree(file_path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "st.st_mode"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void mb2_copy_directory_by_path(const char *src, const char *dst)\n{\n\tif (!src || !dst) {\n\t\treturn;\n\t}\n\n\tstruct stat st;\n\n\t/* if src does not exist */\n\tif ((stat(src, &st) < 0) || !S_ISDIR(st.st_mode)) {\n\t\tprintf(\"ERROR: Source directory does not exist '%s': %s (%d)\\n\", src, strerror(errno), errno);\n\t\treturn;\n\t}\n\n\t/* if dst directory does not exist */\n\tif ((stat(dst, &st) < 0) || !S_ISDIR(st.st_mode)) {\n\t\t/* create it */\n\t\tif (mkdir_with_parents(dst, 0755) < 0) {\n\t\t\tprintf(\"ERROR: Unable to create destination directory '%s': %s (%d)\\n\", dst, strerror(errno), errno);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* loop over src directory contents */\n\tDIR *cur_dir = opendir(src);\n\tif (cur_dir) {\n\t\tstruct dirent* ep;\n\t\twhile ((ep = readdir(cur_dir))) {\n\t\t\tif ((strcmp(ep->d_name, \".\") == 0) || (strcmp(ep->d_name, \"..\") == 0)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tchar *srcpath = string_build_path(src, ep->d_name, NULL);\n\t\t\tchar *dstpath = string_build_path(dst, ep->d_name, NULL);\n\t\t\tif (srcpath && dstpath) {\n\t\t\t\t/* copy file */\n\t\t\t\tmb2_copy_file_by_path(srcpath, dstpath);\n\n\t\t\t\tfree(srcpath);\n\t\t\t\tfree(dstpath);\n\t\t\t}\n\t\t}\n\t\tclosedir(cur_dir);\n\t}\n}"
  },
  {
    "function_name": "mb2_copy_file_by_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
    "lines": "962-992",
    "snippet": "static void mb2_copy_file_by_path(const char *src, const char *dst)\n{\n\tFILE *from, *to;\n\tchar buf[BUFSIZ];\n\tsize_t length;\n\n\t/* open source file */\n\tif ((from = fopen(src, \"rb\")) == NULL) {\n\t\tprintf(\"Cannot open source path '%s'.\\n\", src);\n\t\treturn;\n\t}\n\n\t/* open destination file */\n\tif ((to = fopen(dst, \"wb\")) == NULL) {\n\t\tprintf(\"Cannot open destination file '%s'.\\n\", dst);\n\t\treturn;\n\t}\n\n\t/* copy the file */\n\twhile ((length = fread(buf, 1, BUFSIZ, from)) != 0) {\n\t\tfwrite(buf, 1, length, to);\n\t}\n\n\tif(fclose(from) == EOF) {\n\t\tprintf(\"Error closing source file.\\n\");\n\t}\n\n\tif(fclose(to) == EOF) {\n\t\tprintf(\"Error closing destination file.\\n\");\n\t}\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <sys/statvfs.h>",
      "#include <termios.h>",
      "#include <conio.h>",
      "#include <windows.h>",
      "#include <endianness.h>",
      "#include \"common/utils.h\"",
      "#include <libimobiledevice/afc.h>",
      "#include <libimobiledevice/notification_proxy.h>",
      "#include <libimobiledevice/mobilebackup2.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <libgen.h>",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Error closing destination file.\\n\""
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "to"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Error closing source file.\\n\""
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "from"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fwrite",
          "args": [
            "buf",
            "1",
            "length",
            "to"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fread",
          "args": [
            "buf",
            "1",
            "BUFSIZ",
            "from"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Cannot open destination file '%s'.\\n\"",
            "dst"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "asprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/include/asprintf.h",
          "lines": "23-31",
          "snippet": "static inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}",
          "includes": [
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <config.h>\n\nstatic inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "dst",
            "\"wb\""
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "src",
            "\"rb\""
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void mb2_copy_file_by_path(const char *src, const char *dst)\n{\n\tFILE *from, *to;\n\tchar buf[BUFSIZ];\n\tsize_t length;\n\n\t/* open source file */\n\tif ((from = fopen(src, \"rb\")) == NULL) {\n\t\tprintf(\"Cannot open source path '%s'.\\n\", src);\n\t\treturn;\n\t}\n\n\t/* open destination file */\n\tif ((to = fopen(dst, \"wb\")) == NULL) {\n\t\tprintf(\"Cannot open destination file '%s'.\\n\", dst);\n\t\treturn;\n\t}\n\n\t/* copy the file */\n\twhile ((length = fread(buf, 1, BUFSIZ, from)) != 0) {\n\t\tfwrite(buf, 1, length, to);\n\t}\n\n\tif(fclose(from) == EOF) {\n\t\tprintf(\"Error closing source file.\\n\");\n\t}\n\n\tif(fclose(to) == EOF) {\n\t\tprintf(\"Error closing destination file.\\n\");\n\t}\n}"
  },
  {
    "function_name": "mb2_handle_make_directory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
    "lines": "935-960",
    "snippet": "static void mb2_handle_make_directory(mobilebackup2_client_t mobilebackup2, plist_t message, const char *backup_dir)\n{\n\tif (!message || (plist_get_node_type(message) != PLIST_ARRAY) || plist_array_get_size(message) < 2 || !backup_dir) return;\n\n\tplist_t dir = plist_array_get_item(message, 1);\n\tchar *str = NULL;\n\tint errcode = 0;\n\tchar *errdesc = NULL;\n\tplist_get_string_val(dir, &str);\n\n\tchar *newpath = string_build_path(backup_dir, str, NULL);\n\tfree(str);\n\n\tif (mkdir_with_parents(newpath, 0755) < 0) {\n\t\terrdesc = strerror(errno);\n\t\tif (errno != EEXIST) {\n\t\t\tprintf(\"mkdir: %s (%d)\\n\", errdesc, errno);\n\t\t}\n\t\terrcode = errno_to_device_error(errno);\n\t}\n\tfree(newpath);\n\tmobilebackup2_error_t err = mobilebackup2_send_status_response(mobilebackup2, errcode, errdesc, NULL);\n\tif (err != MOBILEBACKUP2_E_SUCCESS) {\n\t\tprintf(\"Could not send status response, error %d\\n\", err);\n\t}\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <sys/statvfs.h>",
      "#include <termios.h>",
      "#include <conio.h>",
      "#include <windows.h>",
      "#include <endianness.h>",
      "#include \"common/utils.h\"",
      "#include <libimobiledevice/afc.h>",
      "#include <libimobiledevice/notification_proxy.h>",
      "#include <libimobiledevice/mobilebackup2.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <libgen.h>",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Could not send status response, error %d\\n\"",
            "err"
          ],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "asprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/include/asprintf.h",
          "lines": "23-31",
          "snippet": "static inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}",
          "includes": [
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <config.h>\n\nstatic inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mobilebackup2_send_status_response",
          "args": [
            "mobilebackup2",
            "errcode",
            "errdesc",
            "NULL"
          ],
          "line": 956
        },
        "resolved": true,
        "details": {
          "function_name": "mobilebackup2_send_status_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/mobilebackup2.c",
          "lines": "357-380",
          "snippet": "LIBIMOBILEDEVICE_API mobilebackup2_error_t mobilebackup2_send_status_response(mobilebackup2_client_t client, int status_code, const char *status1, plist_t status2)\n{\n\tif (!client || !client->parent)\n\t\treturn MOBILEBACKUP2_E_INVALID_ARG;\n\n\tplist_t array = plist_new_array();\n\tplist_array_append_item(array, plist_new_string(\"DLMessageStatusResponse\"));\n\tplist_array_append_item(array, plist_new_uint(status_code));\n\tif (status1) {\n\t\tplist_array_append_item(array, plist_new_string(status1));\n\t} else {\n\t\tplist_array_append_item(array, plist_new_string(\"___EmptyParameterString___\"));\n\t}\n\tif (status2) {\n\t\tplist_array_append_item(array, plist_copy(status2));\n\t} else {\n\t\tplist_array_append_item(array, plist_new_string(\"___EmptyParameterString___\"));\n\t}\n\n\tmobilebackup2_error_t err = mobilebackup2_error(device_link_service_send(client->parent, array));\n\tplist_free(array);\n\n\treturn err;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"device_link_service.h\"",
            "#include \"mobilebackup2.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <plist/plist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"device_link_service.h\"\n#include \"mobilebackup2.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <plist/plist.h>\n\nLIBIMOBILEDEVICE_API mobilebackup2_error_t mobilebackup2_send_status_response(mobilebackup2_client_t client, int status_code, const char *status1, plist_t status2)\n{\n\tif (!client || !client->parent)\n\t\treturn MOBILEBACKUP2_E_INVALID_ARG;\n\n\tplist_t array = plist_new_array();\n\tplist_array_append_item(array, plist_new_string(\"DLMessageStatusResponse\"));\n\tplist_array_append_item(array, plist_new_uint(status_code));\n\tif (status1) {\n\t\tplist_array_append_item(array, plist_new_string(status1));\n\t} else {\n\t\tplist_array_append_item(array, plist_new_string(\"___EmptyParameterString___\"));\n\t}\n\tif (status2) {\n\t\tplist_array_append_item(array, plist_copy(status2));\n\t} else {\n\t\tplist_array_append_item(array, plist_new_string(\"___EmptyParameterString___\"));\n\t}\n\n\tmobilebackup2_error_t err = mobilebackup2_error(device_link_service_send(client->parent, array));\n\tplist_free(array);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "newpath"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "thread_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "39-44",
          "snippet": "void thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nvoid thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "errno_to_device_error",
          "args": [
            "errno"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "errno_to_device_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
          "lines": "441-451",
          "snippet": "static int errno_to_device_error(int errno_value)\n{\n\tswitch (errno_value) {\n\t\tcase ENOENT:\n\t\t\treturn -6;\n\t\tcase EEXIST:\n\t\t\treturn -7;\n\t\tdefault:\n\t\t\treturn -errno_value;\n\t}\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <sys/statvfs.h>",
            "#include <termios.h>",
            "#include <conio.h>",
            "#include <windows.h>",
            "#include <endianness.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup2.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <libgen.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int errno_to_device_error(int errno_value)\n{\n\tswitch (errno_value) {\n\t\tcase ENOENT:\n\t\t\treturn -6;\n\t\tcase EEXIST:\n\t\t\treturn -7;\n\t\tdefault:\n\t\t\treturn -errno_value;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir_with_parents",
          "args": [
            "newpath",
            "0755"
          ],
          "line": 948
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir_with_parents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
          "lines": "172-193",
          "snippet": "static int mkdir_with_parents(const char *dir, int mode)\n{\n\tif (!dir) return -1;\n\tif (__mkdir(dir, mode) == 0) {\n\t\treturn 0;\n\t} else {\n\t\tif (errno == EEXIST) return 0;\n\t}\n\tint res;\n\tchar *parent = strdup(dir);\n\tchar *parentdir = dirname(parent);\n\tif (parentdir) {\n\t\tres = mkdir_with_parents(parentdir, mode);\n\t} else {\n\t\tres = -1;\n\t}\n\tfree(parent);\n\tif (res == 0) {\n\t\tmkdir_with_parents(dir, mode);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <sys/statvfs.h>",
            "#include <termios.h>",
            "#include <conio.h>",
            "#include <windows.h>",
            "#include <endianness.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup2.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <libgen.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int mkdir_with_parents(const char *dir, int mode)\n{\n\tif (!dir) return -1;\n\tif (__mkdir(dir, mode) == 0) {\n\t\treturn 0;\n\t} else {\n\t\tif (errno == EEXIST) return 0;\n\t}\n\tint res;\n\tchar *parent = strdup(dir);\n\tchar *parentdir = dirname(parent);\n\tif (parentdir) {\n\t\tres = mkdir_with_parents(parentdir, mode);\n\t} else {\n\t\tres = -1;\n\t}\n\tfree(parent);\n\tif (res == 0) {\n\t\tmkdir_with_parents(dir, mode);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "string_build_path",
          "args": [
            "backup_dir",
            "str",
            "NULL"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "string_build_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/utils.c",
          "lines": "114-140",
          "snippet": "char *string_build_path(const char *elem, ...)\n{\n\tif (!elem)\n\t\treturn NULL;\n\tva_list args;\n\tint len = strlen(elem)+1;\n\tva_start(args, elem);\n\tchar *arg = va_arg(args, char*);\n\twhile (arg) {\n\t\tlen += strlen(arg)+1;\n\t\targ = va_arg(args, char*);\n\t}\n\tva_end(args);\n\n\tchar* out = (char*)malloc(len);\n\tstrcpy(out, elem);\n\n\tva_start(args, elem);\n\targ = va_arg(args, char*);\n\twhile (arg) {\n\t\tstrcat(out, \"/\");\n\t\tstrcat(out, arg);\n\t\targ = va_arg(args, char*);\n\t}\n\tva_end(args);\n\treturn out;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include <ctype.h>",
            "#include <inttypes.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include <ctype.h>\n#include <inttypes.h>\n#include <sys/time.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <config.h>\n\nchar *string_build_path(const char *elem, ...)\n{\n\tif (!elem)\n\t\treturn NULL;\n\tva_list args;\n\tint len = strlen(elem)+1;\n\tva_start(args, elem);\n\tchar *arg = va_arg(args, char*);\n\twhile (arg) {\n\t\tlen += strlen(arg)+1;\n\t\targ = va_arg(args, char*);\n\t}\n\tva_end(args);\n\n\tchar* out = (char*)malloc(len);\n\tstrcpy(out, elem);\n\n\tva_start(args, elem);\n\targ = va_arg(args, char*);\n\twhile (arg) {\n\t\tstrcat(out, \"/\");\n\t\tstrcat(out, arg);\n\t\targ = va_arg(args, char*);\n\t}\n\tva_end(args);\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_get_string_val",
          "args": [
            "dir",
            "&str"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_array_get_item",
          "args": [
            "message",
            "1"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_array_get_size",
          "args": [
            "message"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_node_type",
          "args": [
            "message"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void mb2_handle_make_directory(mobilebackup2_client_t mobilebackup2, plist_t message, const char *backup_dir)\n{\n\tif (!message || (plist_get_node_type(message) != PLIST_ARRAY) || plist_array_get_size(message) < 2 || !backup_dir) return;\n\n\tplist_t dir = plist_array_get_item(message, 1);\n\tchar *str = NULL;\n\tint errcode = 0;\n\tchar *errdesc = NULL;\n\tplist_get_string_val(dir, &str);\n\n\tchar *newpath = string_build_path(backup_dir, str, NULL);\n\tfree(str);\n\n\tif (mkdir_with_parents(newpath, 0755) < 0) {\n\t\terrdesc = strerror(errno);\n\t\tif (errno != EEXIST) {\n\t\t\tprintf(\"mkdir: %s (%d)\\n\", errdesc, errno);\n\t\t}\n\t\terrcode = errno_to_device_error(errno);\n\t}\n\tfree(newpath);\n\tmobilebackup2_error_t err = mobilebackup2_send_status_response(mobilebackup2, errcode, errdesc, NULL);\n\tif (err != MOBILEBACKUP2_E_SUCCESS) {\n\t\tprintf(\"Could not send status response, error %d\\n\", err);\n\t}\n}"
  },
  {
    "function_name": "mb2_handle_list_directory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
    "lines": "877-933",
    "snippet": "static void mb2_handle_list_directory(mobilebackup2_client_t mobilebackup2, plist_t message, const char *backup_dir)\n{\n\tif (!message || (plist_get_node_type(message) != PLIST_ARRAY) || plist_array_get_size(message) < 2 || !backup_dir) return;\n\n\tplist_t node = plist_array_get_item(message, 1);\n\tchar *str = NULL;\n\tif (plist_get_node_type(node) == PLIST_STRING) {\n\t\tplist_get_string_val(node, &str);\n\t}\n\tif (!str) {\n\t\tprintf(\"ERROR: Malformed DLContentsOfDirectory message\\n\");\n\t\t// TODO error handling\n\t\treturn;\n\t}\n\n\tchar *path = string_build_path(backup_dir, str, NULL);\n\tfree(str);\n\n\tplist_t dirlist = plist_new_dict();\n\n\tDIR* cur_dir = opendir(path);\n\tif (cur_dir) {\n\t\tstruct dirent* ep;\n\t\twhile ((ep = readdir(cur_dir))) {\n\t\t\tif ((strcmp(ep->d_name, \".\") == 0) || (strcmp(ep->d_name, \"..\") == 0)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tchar *fpath = string_build_path(path, ep->d_name, NULL);\n\t\t\tif (fpath) {\n\t\t\t\tplist_t fdict = plist_new_dict();\n\t\t\t\tstruct stat st;\n\t\t\t\tstat(fpath, &st);\n\t\t\t\tconst char *ftype = \"DLFileTypeUnknown\";\n\t\t\t\tif (S_ISDIR(st.st_mode)) {\n\t\t\t\t\tftype = \"DLFileTypeDirectory\";\n\t\t\t\t} else if (S_ISREG(st.st_mode)) {\n\t\t\t\t\tftype = \"DLFileTypeRegular\";\n\t\t\t\t}\n\t\t\t\tplist_dict_set_item(fdict, \"DLFileType\", plist_new_string(ftype));\n\t\t\t\tplist_dict_set_item(fdict, \"DLFileSize\", plist_new_uint(st.st_size));\n\t\t\t\tplist_dict_set_item(fdict, \"DLFileModificationDate\", plist_new_date(st.st_mtime, 0));\n\n\t\t\t\tplist_dict_set_item(dirlist, ep->d_name, fdict);\n\t\t\t\tfree(fpath);\n\t\t\t}\n\t\t}\n\t\tclosedir(cur_dir);\n\t}\n\tfree(path);\n\n\t/* TODO error handling */\n\tmobilebackup2_error_t err = mobilebackup2_send_status_response(mobilebackup2, 0, NULL, dirlist);\n\tplist_free(dirlist);\n\tif (err != MOBILEBACKUP2_E_SUCCESS) {\n\t\tprintf(\"Could not send status response, error %d\\n\", err);\n\t}\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <sys/statvfs.h>",
      "#include <termios.h>",
      "#include <conio.h>",
      "#include <windows.h>",
      "#include <endianness.h>",
      "#include \"common/utils.h\"",
      "#include <libimobiledevice/afc.h>",
      "#include <libimobiledevice/notification_proxy.h>",
      "#include <libimobiledevice/mobilebackup2.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <libgen.h>",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Could not send status response, error %d\\n\"",
            "err"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "asprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/include/asprintf.h",
          "lines": "23-31",
          "snippet": "static inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}",
          "includes": [
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <config.h>\n\nstatic inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_free",
          "args": [
            "dirlist"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mobilebackup2_send_status_response",
          "args": [
            "mobilebackup2",
            "0",
            "NULL",
            "dirlist"
          ],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "mobilebackup2_send_status_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/mobilebackup2.c",
          "lines": "357-380",
          "snippet": "LIBIMOBILEDEVICE_API mobilebackup2_error_t mobilebackup2_send_status_response(mobilebackup2_client_t client, int status_code, const char *status1, plist_t status2)\n{\n\tif (!client || !client->parent)\n\t\treturn MOBILEBACKUP2_E_INVALID_ARG;\n\n\tplist_t array = plist_new_array();\n\tplist_array_append_item(array, plist_new_string(\"DLMessageStatusResponse\"));\n\tplist_array_append_item(array, plist_new_uint(status_code));\n\tif (status1) {\n\t\tplist_array_append_item(array, plist_new_string(status1));\n\t} else {\n\t\tplist_array_append_item(array, plist_new_string(\"___EmptyParameterString___\"));\n\t}\n\tif (status2) {\n\t\tplist_array_append_item(array, plist_copy(status2));\n\t} else {\n\t\tplist_array_append_item(array, plist_new_string(\"___EmptyParameterString___\"));\n\t}\n\n\tmobilebackup2_error_t err = mobilebackup2_error(device_link_service_send(client->parent, array));\n\tplist_free(array);\n\n\treturn err;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"device_link_service.h\"",
            "#include \"mobilebackup2.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <plist/plist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"device_link_service.h\"\n#include \"mobilebackup2.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <plist/plist.h>\n\nLIBIMOBILEDEVICE_API mobilebackup2_error_t mobilebackup2_send_status_response(mobilebackup2_client_t client, int status_code, const char *status1, plist_t status2)\n{\n\tif (!client || !client->parent)\n\t\treturn MOBILEBACKUP2_E_INVALID_ARG;\n\n\tplist_t array = plist_new_array();\n\tplist_array_append_item(array, plist_new_string(\"DLMessageStatusResponse\"));\n\tplist_array_append_item(array, plist_new_uint(status_code));\n\tif (status1) {\n\t\tplist_array_append_item(array, plist_new_string(status1));\n\t} else {\n\t\tplist_array_append_item(array, plist_new_string(\"___EmptyParameterString___\"));\n\t}\n\tif (status2) {\n\t\tplist_array_append_item(array, plist_copy(status2));\n\t} else {\n\t\tplist_array_append_item(array, plist_new_string(\"___EmptyParameterString___\"));\n\t}\n\n\tmobilebackup2_error_t err = mobilebackup2_error(device_link_service_send(client->parent, array));\n\tplist_free(array);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "path"
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "thread_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "39-44",
          "snippet": "void thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nvoid thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "cur_dir"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "dirlist",
            "ep->d_name",
            "fdict"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "fdict",
            "\"DLFileModificationDate\"",
            "plist_new_date(st.st_mtime, 0)"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_date",
          "args": [
            "st.st_mtime",
            "0"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "fdict",
            "\"DLFileSize\"",
            "plist_new_uint(st.st_size)"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_uint",
          "args": [
            "st.st_size"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "fdict",
            "\"DLFileType\"",
            "plist_new_string(ftype)"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_string",
          "args": [
            "ftype"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "st.st_mode"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "st.st_mode"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "fpath",
            "&st"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "mobilebackup_write_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
          "lines": "322-338",
          "snippet": "static void mobilebackup_write_status(const char *path, int status)\n{\n\tstruct stat st;\n\tplist_t status_plist = plist_new_dict();\n\tplist_dict_set_item(status_plist, \"Backup Success\", plist_new_bool(status));\n\tchar *file_path = mobilebackup_build_path(path, \"Status\", \".plist\");\n\n\tif (stat(file_path, &st) == 0)\n\t\tremove(file_path);\n\n\tplist_write_to_filename(status_plist, file_path, PLIST_FORMAT_XML);\n\n\tplist_free(status_plist);\n\tstatus_plist = NULL;\n\n\tfree(file_path);\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <unistd.h>",
            "#include <gcrypt.h>",
            "#include <openssl/sha.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void mobilebackup_write_status(const char *path, int status)\n{\n\tstruct stat st;\n\tplist_t status_plist = plist_new_dict();\n\tplist_dict_set_item(status_plist, \"Backup Success\", plist_new_bool(status));\n\tchar *file_path = mobilebackup_build_path(path, \"Status\", \".plist\");\n\n\tif (stat(file_path, &st) == 0)\n\t\tremove(file_path);\n\n\tplist_write_to_filename(status_plist, file_path, PLIST_FORMAT_XML);\n\n\tplist_free(status_plist);\n\tstatus_plist = NULL;\n\n\tfree(file_path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_new_dict",
          "args": [],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "string_build_path",
          "args": [
            "path",
            "ep->d_name",
            "NULL"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "string_build_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/utils.c",
          "lines": "114-140",
          "snippet": "char *string_build_path(const char *elem, ...)\n{\n\tif (!elem)\n\t\treturn NULL;\n\tva_list args;\n\tint len = strlen(elem)+1;\n\tva_start(args, elem);\n\tchar *arg = va_arg(args, char*);\n\twhile (arg) {\n\t\tlen += strlen(arg)+1;\n\t\targ = va_arg(args, char*);\n\t}\n\tva_end(args);\n\n\tchar* out = (char*)malloc(len);\n\tstrcpy(out, elem);\n\n\tva_start(args, elem);\n\targ = va_arg(args, char*);\n\twhile (arg) {\n\t\tstrcat(out, \"/\");\n\t\tstrcat(out, arg);\n\t\targ = va_arg(args, char*);\n\t}\n\tva_end(args);\n\treturn out;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include <ctype.h>",
            "#include <inttypes.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include <ctype.h>\n#include <inttypes.h>\n#include <sys/time.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <config.h>\n\nchar *string_build_path(const char *elem, ...)\n{\n\tif (!elem)\n\t\treturn NULL;\n\tva_list args;\n\tint len = strlen(elem)+1;\n\tva_start(args, elem);\n\tchar *arg = va_arg(args, char*);\n\twhile (arg) {\n\t\tlen += strlen(arg)+1;\n\t\targ = va_arg(args, char*);\n\t}\n\tva_end(args);\n\n\tchar* out = (char*)malloc(len);\n\tstrcpy(out, elem);\n\n\tva_start(args, elem);\n\targ = va_arg(args, char*);\n\twhile (arg) {\n\t\tstrcat(out, \"/\");\n\t\tstrcat(out, arg);\n\t\targ = va_arg(args, char*);\n\t}\n\tva_end(args);\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ep->d_name",
            "\"..\""
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "plist_strcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
          "lines": "296-309",
          "snippet": "static int plist_strcmp(plist_t node, const char *str)\n{\n\tchar *buffer = NULL;\n\tint ret = 0;\n\n\tif (plist_get_node_type(node) != PLIST_STRING)\n\t\treturn ret;\n\n\tplist_get_string_val(node, &buffer);\n\tret = strcmp(buffer, str);\n\tfree(buffer);\n\n\treturn ret;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <unistd.h>",
            "#include <gcrypt.h>",
            "#include <openssl/sha.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int plist_strcmp(plist_t node, const char *str)\n{\n\tchar *buffer = NULL;\n\tint ret = 0;\n\n\tif (plist_get_node_type(node) != PLIST_STRING)\n\t\treturn ret;\n\n\tplist_get_string_val(node, &buffer);\n\tret = strcmp(buffer, str);\n\tfree(buffer);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "readdir",
          "args": [
            "cur_dir"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opendir",
          "args": [
            "path"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_dict",
          "args": [],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ERROR: Malformed DLContentsOfDirectory message\\n\""
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_string_val",
          "args": [
            "node",
            "&str"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_node_type",
          "args": [
            "node"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_array_get_item",
          "args": [
            "message",
            "1"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_array_get_size",
          "args": [
            "message"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_node_type",
          "args": [
            "message"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void mb2_handle_list_directory(mobilebackup2_client_t mobilebackup2, plist_t message, const char *backup_dir)\n{\n\tif (!message || (plist_get_node_type(message) != PLIST_ARRAY) || plist_array_get_size(message) < 2 || !backup_dir) return;\n\n\tplist_t node = plist_array_get_item(message, 1);\n\tchar *str = NULL;\n\tif (plist_get_node_type(node) == PLIST_STRING) {\n\t\tplist_get_string_val(node, &str);\n\t}\n\tif (!str) {\n\t\tprintf(\"ERROR: Malformed DLContentsOfDirectory message\\n\");\n\t\t// TODO error handling\n\t\treturn;\n\t}\n\n\tchar *path = string_build_path(backup_dir, str, NULL);\n\tfree(str);\n\n\tplist_t dirlist = plist_new_dict();\n\n\tDIR* cur_dir = opendir(path);\n\tif (cur_dir) {\n\t\tstruct dirent* ep;\n\t\twhile ((ep = readdir(cur_dir))) {\n\t\t\tif ((strcmp(ep->d_name, \".\") == 0) || (strcmp(ep->d_name, \"..\") == 0)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tchar *fpath = string_build_path(path, ep->d_name, NULL);\n\t\t\tif (fpath) {\n\t\t\t\tplist_t fdict = plist_new_dict();\n\t\t\t\tstruct stat st;\n\t\t\t\tstat(fpath, &st);\n\t\t\t\tconst char *ftype = \"DLFileTypeUnknown\";\n\t\t\t\tif (S_ISDIR(st.st_mode)) {\n\t\t\t\t\tftype = \"DLFileTypeDirectory\";\n\t\t\t\t} else if (S_ISREG(st.st_mode)) {\n\t\t\t\t\tftype = \"DLFileTypeRegular\";\n\t\t\t\t}\n\t\t\t\tplist_dict_set_item(fdict, \"DLFileType\", plist_new_string(ftype));\n\t\t\t\tplist_dict_set_item(fdict, \"DLFileSize\", plist_new_uint(st.st_size));\n\t\t\t\tplist_dict_set_item(fdict, \"DLFileModificationDate\", plist_new_date(st.st_mtime, 0));\n\n\t\t\t\tplist_dict_set_item(dirlist, ep->d_name, fdict);\n\t\t\t\tfree(fpath);\n\t\t\t}\n\t\t}\n\t\tclosedir(cur_dir);\n\t}\n\tfree(path);\n\n\t/* TODO error handling */\n\tmobilebackup2_error_t err = mobilebackup2_send_status_response(mobilebackup2, 0, NULL, dirlist);\n\tplist_free(dirlist);\n\tif (err != MOBILEBACKUP2_E_SUCCESS) {\n\t\tprintf(\"Could not send status response, error %d\\n\", err);\n\t}\n}"
  },
  {
    "function_name": "mb2_handle_receive_files",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
    "lines": "711-875",
    "snippet": "static int mb2_handle_receive_files(mobilebackup2_client_t mobilebackup2, plist_t message, const char *backup_dir)\n{\n\tuint64_t backup_real_size = 0;\n\tuint64_t backup_total_size = 0;\n\tuint32_t blocksize;\n\tuint32_t bdone;\n\tuint32_t rlen;\n\tuint32_t nlen = 0;\n\tuint32_t r;\n\tchar buf[32768];\n\tchar *fname = NULL;\n\tchar *dname = NULL;\n\tchar *bname = NULL;\n\tchar code = 0;\n\tchar last_code = 0;\n\tplist_t node = NULL;\n\tFILE *f = NULL;\n\tunsigned int file_count = 0;\n\n\tif (!message || (plist_get_node_type(message) != PLIST_ARRAY) || plist_array_get_size(message) < 4 || !backup_dir) return 0;\n\n\tnode = plist_array_get_item(message, 3);\n\tif (plist_get_node_type(node) == PLIST_UINT) {\n\t\tplist_get_uint_val(node, &backup_total_size);\n\t}\n\tif (backup_total_size > 0) {\n\t\tPRINT_VERBOSE(1, \"Receiving files\\n\");\n\t}\n\n\tdo {\n\t\tif (quit_flag)\n\t\t\tbreak;\n\n\t\tnlen = mb2_receive_filename(mobilebackup2, &dname);\n\t\tif (nlen == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tnlen = mb2_receive_filename(mobilebackup2, &fname);\n\t\tif (!nlen) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (bname != NULL) {\n\t\t\tfree(bname);\n\t\t\tbname = NULL;\n\t\t}\n\n\t\tbname = string_build_path(backup_dir, fname, NULL);\n\n\t\tif (fname != NULL) {\n\t\t\tfree(fname);\n\t\t\tfname = NULL;\n\t\t}\n\n\t\tr = 0;\n\t\tnlen = 0;\n\t\tmobilebackup2_receive_raw(mobilebackup2, (char*)&nlen, 4, &r);\n\t\tif (r != 4) {\n\t\t\tprintf(\"ERROR: %s: could not receive code length!\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\t\tnlen = be32toh(nlen);\n\n\t\tlast_code = code;\n\t\tcode = 0;\n\n\t\tmobilebackup2_receive_raw(mobilebackup2, &code, 1, &r);\n\t\tif (r != 1) {\n\t\t\tprintf(\"ERROR: %s: could not receive code!\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* TODO remove this */\n\t\tif ((code != CODE_SUCCESS) && (code != CODE_FILE_DATA) && (code != CODE_ERROR_REMOTE)) {\n\t\t\tPRINT_VERBOSE(1, \"Found new flag %02x\\n\", code);\n\t\t}\n\n\t\tremove(bname);\n\t\tf = fopen(bname, \"wb\");\n\t\twhile (f && (code == CODE_FILE_DATA)) {\n\t\t\tblocksize = nlen-1;\n\t\t\tbdone = 0;\n\t\t\trlen = 0;\n\t\t\twhile (bdone < blocksize) {\n\t\t\t\tif ((blocksize - bdone) < sizeof(buf)) {\n\t\t\t\t\trlen = blocksize - bdone;\n\t\t\t\t} else {\n\t\t\t\t\trlen = sizeof(buf);\n\t\t\t\t}\n\t\t\t\tmobilebackup2_receive_raw(mobilebackup2, buf, rlen, &r);\n\t\t\t\tif ((int)r <= 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfwrite(buf, 1, r, f);\n\t\t\t\tbdone += r;\n\t\t\t}\n\t\t\tif (bdone == blocksize) {\n\t\t\t\tbackup_real_size += blocksize;\n\t\t\t}\n\t\t\tif (backup_total_size > 0) {\n\t\t\t\tprint_progress(backup_real_size, backup_total_size);\n\t\t\t}\n\t\t\tif (quit_flag)\n\t\t\t\tbreak;\n\t\t\tnlen = 0;\n\t\t\tmobilebackup2_receive_raw(mobilebackup2, (char*)&nlen, 4, &r);\n\t\t\tnlen = be32toh(nlen);\n\t\t\tif (nlen > 0) {\n\t\t\t\tlast_code = code;\n\t\t\t\tmobilebackup2_receive_raw(mobilebackup2, &code, 1, &r);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (f) {\n\t\t\tfclose(f);\n\t\t\tfile_count++;\n\t\t} else {\n\t\t\tprintf(\"Error opening '%s' for writing: %s\\n\", bname, strerror(errno));\n\t\t}\n\t\tif (nlen == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\t/* check if an error message was received */\n\t\tif (code == CODE_ERROR_REMOTE) {\n\t\t\t/* error message */\n\t\t\tchar *msg = (char*)malloc(nlen);\n\t\t\tmobilebackup2_receive_raw(mobilebackup2, msg, nlen-1, &r);\n\t\t\tmsg[r] = 0;\n\t\t\t/* If sent using CODE_FILE_DATA, end marker will be CODE_ERROR_REMOTE which is not an error! */\n\t\t\tif (last_code != CODE_FILE_DATA) {\n\t\t\t\tfprintf(stdout, \"\\nReceived an error message from device: %s\\n\", msg);\n\t\t\t}\n\t\t\tfree(msg);\n\t\t}\n\t} while (1);\n\n\tif (fname != NULL)\n\t\tfree(fname);\n\n\t/* if there are leftovers to read, finish up cleanly */\n\tif ((int)nlen-1 > 0) {\n\t\tPRINT_VERBOSE(1, \"\\nDiscarding current data hunk.\\n\");\n\t\tfname = (char*)malloc(nlen-1);\n\t\tmobilebackup2_receive_raw(mobilebackup2, fname, nlen-1, &r);\n\t\tfree(fname);\n\t\tremove(bname);\n\t}\n\n\t/* clean up */\n\tif (bname != NULL)\n\t\tfree(bname);\n\n\tif (dname != NULL)\n\t\tfree(dname);\n\n\t// TODO error handling?!\n\tplist_t empty_plist = plist_new_dict();\n\tmobilebackup2_send_status_response(mobilebackup2, 0, NULL, empty_plist);\n\tplist_free(empty_plist);\n\n\treturn file_count;\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <sys/statvfs.h>",
      "#include <termios.h>",
      "#include <conio.h>",
      "#include <windows.h>",
      "#include <endianness.h>",
      "#include \"common/utils.h\"",
      "#include <libimobiledevice/afc.h>",
      "#include <libimobiledevice/notification_proxy.h>",
      "#include <libimobiledevice/mobilebackup2.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <libgen.h>",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define CODE_FILE_DATA 0x0c",
      "#define CODE_ERROR_REMOTE 0x0b",
      "#define CODE_SUCCESS 0x00"
    ],
    "globals_used": [
      "static int quit_flag = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "plist_free",
          "args": [
            "empty_plist"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mobilebackup2_send_status_response",
          "args": [
            "mobilebackup2",
            "0",
            "NULL",
            "empty_plist"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "mobilebackup2_send_status_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/mobilebackup2.c",
          "lines": "357-380",
          "snippet": "LIBIMOBILEDEVICE_API mobilebackup2_error_t mobilebackup2_send_status_response(mobilebackup2_client_t client, int status_code, const char *status1, plist_t status2)\n{\n\tif (!client || !client->parent)\n\t\treturn MOBILEBACKUP2_E_INVALID_ARG;\n\n\tplist_t array = plist_new_array();\n\tplist_array_append_item(array, plist_new_string(\"DLMessageStatusResponse\"));\n\tplist_array_append_item(array, plist_new_uint(status_code));\n\tif (status1) {\n\t\tplist_array_append_item(array, plist_new_string(status1));\n\t} else {\n\t\tplist_array_append_item(array, plist_new_string(\"___EmptyParameterString___\"));\n\t}\n\tif (status2) {\n\t\tplist_array_append_item(array, plist_copy(status2));\n\t} else {\n\t\tplist_array_append_item(array, plist_new_string(\"___EmptyParameterString___\"));\n\t}\n\n\tmobilebackup2_error_t err = mobilebackup2_error(device_link_service_send(client->parent, array));\n\tplist_free(array);\n\n\treturn err;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"device_link_service.h\"",
            "#include \"mobilebackup2.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <plist/plist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"device_link_service.h\"\n#include \"mobilebackup2.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <plist/plist.h>\n\nLIBIMOBILEDEVICE_API mobilebackup2_error_t mobilebackup2_send_status_response(mobilebackup2_client_t client, int status_code, const char *status1, plist_t status2)\n{\n\tif (!client || !client->parent)\n\t\treturn MOBILEBACKUP2_E_INVALID_ARG;\n\n\tplist_t array = plist_new_array();\n\tplist_array_append_item(array, plist_new_string(\"DLMessageStatusResponse\"));\n\tplist_array_append_item(array, plist_new_uint(status_code));\n\tif (status1) {\n\t\tplist_array_append_item(array, plist_new_string(status1));\n\t} else {\n\t\tplist_array_append_item(array, plist_new_string(\"___EmptyParameterString___\"));\n\t}\n\tif (status2) {\n\t\tplist_array_append_item(array, plist_copy(status2));\n\t} else {\n\t\tplist_array_append_item(array, plist_new_string(\"___EmptyParameterString___\"));\n\t}\n\n\tmobilebackup2_error_t err = mobilebackup2_error(device_link_service_send(client->parent, array));\n\tplist_free(array);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_new_dict",
          "args": [],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "dname"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "thread_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "39-44",
          "snippet": "void thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nvoid thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove",
          "args": [
            "bname"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "str_remove_spaces",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/lockdown.c",
          "lines": "1443-1453",
          "snippet": "static void str_remove_spaces(char *source)\n{\n\tchar *dest = source;\n\twhile (*source != 0) {\n\t\tif (!isspace(*source)) {\n\t\t\t*dest++ = *source; /* copy */\n\t\t}\n\t\tsource++;\n\t}\n\t*dest = 0;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/userpref.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"lockdown.h\"",
            "#include \"property_list_service.h\"",
            "#include <plist/plist.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/x509.h>",
            "#include <libtasn1.h>",
            "#include <openssl/x509v3.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/pem.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/userpref.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"lockdown.h\"\n#include \"property_list_service.h\"\n#include <plist/plist.h>\n#include <gnutls/crypto.h>\n#include <gnutls/x509.h>\n#include <libtasn1.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/pem.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nstatic void str_remove_spaces(char *source)\n{\n\tchar *dest = source;\n\twhile (*source != 0) {\n\t\tif (!isspace(*source)) {\n\t\t\t*dest++ = *source; /* copy */\n\t\t}\n\t\tsource++;\n\t}\n\t*dest = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mobilebackup2_receive_raw",
          "args": [
            "mobilebackup2",
            "fname",
            "nlen-1",
            "&r"
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "mobilebackup2_receive_raw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/mobilebackup2.c",
          "lines": "241-266",
          "snippet": "LIBIMOBILEDEVICE_API mobilebackup2_error_t mobilebackup2_receive_raw(mobilebackup2_client_t client, char *data, uint32_t length, uint32_t *bytes)\n{\n\tif (!client || !client->parent || !data || (length == 0) || !bytes)\n\t\treturn MOBILEBACKUP2_E_INVALID_ARG;\n\n\tservice_client_t raw = client->parent->parent->parent;\n\n\t*bytes = 0;\n\n\tint bytes_loc = 0;\n\tuint32_t received = 0;\n\tdo {\n\t\tbytes_loc = 0;\n\t\tservice_receive(raw, data+received, length-received, (uint32_t*)&bytes_loc);\n\t\tif (bytes_loc <= 0) break;\n\t\treceived += bytes_loc;\n\t} while (received < length);\n\tif (received > 0) {\n\t\t*bytes = received;\n\t\treturn MOBILEBACKUP2_E_SUCCESS;\n\t} else if (received == 0) {\n\t\treturn MOBILEBACKUP2_E_SUCCESS;\n\t} else {\n\t\treturn MOBILEBACKUP2_E_MUX_ERROR;\n\t}\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"device_link_service.h\"",
            "#include \"mobilebackup2.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <plist/plist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"device_link_service.h\"\n#include \"mobilebackup2.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <plist/plist.h>\n\nLIBIMOBILEDEVICE_API mobilebackup2_error_t mobilebackup2_receive_raw(mobilebackup2_client_t client, char *data, uint32_t length, uint32_t *bytes)\n{\n\tif (!client || !client->parent || !data || (length == 0) || !bytes)\n\t\treturn MOBILEBACKUP2_E_INVALID_ARG;\n\n\tservice_client_t raw = client->parent->parent->parent;\n\n\t*bytes = 0;\n\n\tint bytes_loc = 0;\n\tuint32_t received = 0;\n\tdo {\n\t\tbytes_loc = 0;\n\t\tservice_receive(raw, data+received, length-received, (uint32_t*)&bytes_loc);\n\t\tif (bytes_loc <= 0) break;\n\t\treceived += bytes_loc;\n\t} while (received < length);\n\tif (received > 0) {\n\t\t*bytes = received;\n\t\treturn MOBILEBACKUP2_E_SUCCESS;\n\t} else if (received == 0) {\n\t\treturn MOBILEBACKUP2_E_SUCCESS;\n\t} else {\n\t\treturn MOBILEBACKUP2_E_MUX_ERROR;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "nlen-1"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"\\nDiscarding current data hunk.\\n\""
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"\\nReceived an error message from device: %s\\n\"",
            "msg"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "nlen"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Error opening '%s' for writing: %s\\n\"",
            "bname",
            "strerror(errno)"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "asprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/include/asprintf.h",
          "lines": "23-31",
          "snippet": "static inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}",
          "includes": [
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <config.h>\n\nstatic inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32toh",
          "args": [
            "nlen"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_progress",
          "args": [
            "backup_real_size",
            "backup_total_size"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "print_progress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
          "lines": "379-401",
          "snippet": "static void print_progress(uint64_t current, uint64_t total)\n{\n\tchar *format_size = NULL;\n\tdouble progress = ((double)current/(double)total)*100;\n\tif (progress < 0)\n\t\treturn;\n\n\tif (progress > 100)\n\t\tprogress = 100;\n\n\tprint_progress_real((double)progress, 0);\n\n\tformat_size = string_format_size(current);\n\tPRINT_VERBOSE(1, \" (%s\", format_size);\n\tfree(format_size);\n\tformat_size = string_format_size(total);\n\tPRINT_VERBOSE(1, \"/%s)     \", format_size);\n\tfree(format_size);\n\n\tfflush(stdout);\n\tif (progress == 100)\n\t\tPRINT_VERBOSE(1, \"\\n\");\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <sys/statvfs.h>",
            "#include <termios.h>",
            "#include <conio.h>",
            "#include <windows.h>",
            "#include <endianness.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup2.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <libgen.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void print_progress(uint64_t current, uint64_t total)\n{\n\tchar *format_size = NULL;\n\tdouble progress = ((double)current/(double)total)*100;\n\tif (progress < 0)\n\t\treturn;\n\n\tif (progress > 100)\n\t\tprogress = 100;\n\n\tprint_progress_real((double)progress, 0);\n\n\tformat_size = string_format_size(current);\n\tPRINT_VERBOSE(1, \" (%s\", format_size);\n\tfree(format_size);\n\tformat_size = string_format_size(total);\n\tPRINT_VERBOSE(1, \"/%s)     \", format_size);\n\tfree(format_size);\n\n\tfflush(stdout);\n\tif (progress == 100)\n\t\tPRINT_VERBOSE(1, \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fwrite",
          "args": [
            "buf",
            "1",
            "r",
            "f"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "bname",
            "\"wb\""
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"Found new flag %02x\\n\"",
            "code"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32toh",
          "args": [
            "nlen"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "string_build_path",
          "args": [
            "backup_dir",
            "fname",
            "NULL"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "string_build_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/utils.c",
          "lines": "114-140",
          "snippet": "char *string_build_path(const char *elem, ...)\n{\n\tif (!elem)\n\t\treturn NULL;\n\tva_list args;\n\tint len = strlen(elem)+1;\n\tva_start(args, elem);\n\tchar *arg = va_arg(args, char*);\n\twhile (arg) {\n\t\tlen += strlen(arg)+1;\n\t\targ = va_arg(args, char*);\n\t}\n\tva_end(args);\n\n\tchar* out = (char*)malloc(len);\n\tstrcpy(out, elem);\n\n\tva_start(args, elem);\n\targ = va_arg(args, char*);\n\twhile (arg) {\n\t\tstrcat(out, \"/\");\n\t\tstrcat(out, arg);\n\t\targ = va_arg(args, char*);\n\t}\n\tva_end(args);\n\treturn out;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include <ctype.h>",
            "#include <inttypes.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include <ctype.h>\n#include <inttypes.h>\n#include <sys/time.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <config.h>\n\nchar *string_build_path(const char *elem, ...)\n{\n\tif (!elem)\n\t\treturn NULL;\n\tva_list args;\n\tint len = strlen(elem)+1;\n\tva_start(args, elem);\n\tchar *arg = va_arg(args, char*);\n\twhile (arg) {\n\t\tlen += strlen(arg)+1;\n\t\targ = va_arg(args, char*);\n\t}\n\tva_end(args);\n\n\tchar* out = (char*)malloc(len);\n\tstrcpy(out, elem);\n\n\tva_start(args, elem);\n\targ = va_arg(args, char*);\n\twhile (arg) {\n\t\tstrcat(out, \"/\");\n\t\tstrcat(out, arg);\n\t\targ = va_arg(args, char*);\n\t}\n\tva_end(args);\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb2_receive_filename",
          "args": [
            "mobilebackup2",
            "&fname"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "mb2_receive_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
          "lines": "665-709",
          "snippet": "static int mb2_receive_filename(mobilebackup2_client_t mobilebackup2, char** filename)\n{\n\tuint32_t nlen = 0;\n\tuint32_t rlen = 0;\n\n\tdo {\n\t\tnlen = 0;\n\t\trlen = 0;\n\t\tmobilebackup2_receive_raw(mobilebackup2, (char*)&nlen, 4, &rlen);\n\t\tnlen = be32toh(nlen);\n\n\t\tif ((nlen == 0) && (rlen == 4)) {\n\t\t\t// a zero length means no more files to receive\n\t\t\treturn 0;\n\t\t} else if(rlen == 0) {\n\t\t\t// device needs more time, waiting...\n\t\t\tcontinue;\n\t\t} else if (nlen > 4096) {\n\t\t\t// filename length is too large\n\t\t\tprintf(\"ERROR: %s: too large filename length (%d)!\\n\", __func__, nlen);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (*filename != NULL) {\n\t\t\tfree(*filename);\n\t\t\t*filename = NULL;\n\t\t}\n\n\t\t*filename = (char*)malloc(nlen+1);\n\n\t\trlen = 0;\n\t\tmobilebackup2_receive_raw(mobilebackup2, *filename, nlen, &rlen);\n\t\tif (rlen != nlen) {\n\t\t\tprintf(\"ERROR: %s: could not read filename\\n\", __func__);\n\t\t\treturn 0;\n\t\t}\n\n\t\tchar* p = *filename;\n\t\tp[rlen] = 0;\n\n\t\tbreak;\n\t} while(1 && !quit_flag);\n\n\treturn nlen;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <sys/statvfs.h>",
            "#include <termios.h>",
            "#include <conio.h>",
            "#include <windows.h>",
            "#include <endianness.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup2.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <libgen.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int quit_flag = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int quit_flag = 0;\n\nstatic int mb2_receive_filename(mobilebackup2_client_t mobilebackup2, char** filename)\n{\n\tuint32_t nlen = 0;\n\tuint32_t rlen = 0;\n\n\tdo {\n\t\tnlen = 0;\n\t\trlen = 0;\n\t\tmobilebackup2_receive_raw(mobilebackup2, (char*)&nlen, 4, &rlen);\n\t\tnlen = be32toh(nlen);\n\n\t\tif ((nlen == 0) && (rlen == 4)) {\n\t\t\t// a zero length means no more files to receive\n\t\t\treturn 0;\n\t\t} else if(rlen == 0) {\n\t\t\t// device needs more time, waiting...\n\t\t\tcontinue;\n\t\t} else if (nlen > 4096) {\n\t\t\t// filename length is too large\n\t\t\tprintf(\"ERROR: %s: too large filename length (%d)!\\n\", __func__, nlen);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (*filename != NULL) {\n\t\t\tfree(*filename);\n\t\t\t*filename = NULL;\n\t\t}\n\n\t\t*filename = (char*)malloc(nlen+1);\n\n\t\trlen = 0;\n\t\tmobilebackup2_receive_raw(mobilebackup2, *filename, nlen, &rlen);\n\t\tif (rlen != nlen) {\n\t\t\tprintf(\"ERROR: %s: could not read filename\\n\", __func__);\n\t\t\treturn 0;\n\t\t}\n\n\t\tchar* p = *filename;\n\t\tp[rlen] = 0;\n\n\t\tbreak;\n\t} while(1 && !quit_flag);\n\n\treturn nlen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"Receiving files\\n\""
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_uint_val",
          "args": [
            "node",
            "&backup_total_size"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_node_type",
          "args": [
            "node"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_array_get_item",
          "args": [
            "message",
            "3"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_array_get_size",
          "args": [
            "message"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_node_type",
          "args": [
            "message"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\n#define CODE_FILE_DATA 0x0c\n#define CODE_ERROR_REMOTE 0x0b\n#define CODE_SUCCESS 0x00\n\nstatic int quit_flag = 0;\n\nstatic int mb2_handle_receive_files(mobilebackup2_client_t mobilebackup2, plist_t message, const char *backup_dir)\n{\n\tuint64_t backup_real_size = 0;\n\tuint64_t backup_total_size = 0;\n\tuint32_t blocksize;\n\tuint32_t bdone;\n\tuint32_t rlen;\n\tuint32_t nlen = 0;\n\tuint32_t r;\n\tchar buf[32768];\n\tchar *fname = NULL;\n\tchar *dname = NULL;\n\tchar *bname = NULL;\n\tchar code = 0;\n\tchar last_code = 0;\n\tplist_t node = NULL;\n\tFILE *f = NULL;\n\tunsigned int file_count = 0;\n\n\tif (!message || (plist_get_node_type(message) != PLIST_ARRAY) || plist_array_get_size(message) < 4 || !backup_dir) return 0;\n\n\tnode = plist_array_get_item(message, 3);\n\tif (plist_get_node_type(node) == PLIST_UINT) {\n\t\tplist_get_uint_val(node, &backup_total_size);\n\t}\n\tif (backup_total_size > 0) {\n\t\tPRINT_VERBOSE(1, \"Receiving files\\n\");\n\t}\n\n\tdo {\n\t\tif (quit_flag)\n\t\t\tbreak;\n\n\t\tnlen = mb2_receive_filename(mobilebackup2, &dname);\n\t\tif (nlen == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tnlen = mb2_receive_filename(mobilebackup2, &fname);\n\t\tif (!nlen) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (bname != NULL) {\n\t\t\tfree(bname);\n\t\t\tbname = NULL;\n\t\t}\n\n\t\tbname = string_build_path(backup_dir, fname, NULL);\n\n\t\tif (fname != NULL) {\n\t\t\tfree(fname);\n\t\t\tfname = NULL;\n\t\t}\n\n\t\tr = 0;\n\t\tnlen = 0;\n\t\tmobilebackup2_receive_raw(mobilebackup2, (char*)&nlen, 4, &r);\n\t\tif (r != 4) {\n\t\t\tprintf(\"ERROR: %s: could not receive code length!\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\t\tnlen = be32toh(nlen);\n\n\t\tlast_code = code;\n\t\tcode = 0;\n\n\t\tmobilebackup2_receive_raw(mobilebackup2, &code, 1, &r);\n\t\tif (r != 1) {\n\t\t\tprintf(\"ERROR: %s: could not receive code!\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* TODO remove this */\n\t\tif ((code != CODE_SUCCESS) && (code != CODE_FILE_DATA) && (code != CODE_ERROR_REMOTE)) {\n\t\t\tPRINT_VERBOSE(1, \"Found new flag %02x\\n\", code);\n\t\t}\n\n\t\tremove(bname);\n\t\tf = fopen(bname, \"wb\");\n\t\twhile (f && (code == CODE_FILE_DATA)) {\n\t\t\tblocksize = nlen-1;\n\t\t\tbdone = 0;\n\t\t\trlen = 0;\n\t\t\twhile (bdone < blocksize) {\n\t\t\t\tif ((blocksize - bdone) < sizeof(buf)) {\n\t\t\t\t\trlen = blocksize - bdone;\n\t\t\t\t} else {\n\t\t\t\t\trlen = sizeof(buf);\n\t\t\t\t}\n\t\t\t\tmobilebackup2_receive_raw(mobilebackup2, buf, rlen, &r);\n\t\t\t\tif ((int)r <= 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfwrite(buf, 1, r, f);\n\t\t\t\tbdone += r;\n\t\t\t}\n\t\t\tif (bdone == blocksize) {\n\t\t\t\tbackup_real_size += blocksize;\n\t\t\t}\n\t\t\tif (backup_total_size > 0) {\n\t\t\t\tprint_progress(backup_real_size, backup_total_size);\n\t\t\t}\n\t\t\tif (quit_flag)\n\t\t\t\tbreak;\n\t\t\tnlen = 0;\n\t\t\tmobilebackup2_receive_raw(mobilebackup2, (char*)&nlen, 4, &r);\n\t\t\tnlen = be32toh(nlen);\n\t\t\tif (nlen > 0) {\n\t\t\t\tlast_code = code;\n\t\t\t\tmobilebackup2_receive_raw(mobilebackup2, &code, 1, &r);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (f) {\n\t\t\tfclose(f);\n\t\t\tfile_count++;\n\t\t} else {\n\t\t\tprintf(\"Error opening '%s' for writing: %s\\n\", bname, strerror(errno));\n\t\t}\n\t\tif (nlen == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\t/* check if an error message was received */\n\t\tif (code == CODE_ERROR_REMOTE) {\n\t\t\t/* error message */\n\t\t\tchar *msg = (char*)malloc(nlen);\n\t\t\tmobilebackup2_receive_raw(mobilebackup2, msg, nlen-1, &r);\n\t\t\tmsg[r] = 0;\n\t\t\t/* If sent using CODE_FILE_DATA, end marker will be CODE_ERROR_REMOTE which is not an error! */\n\t\t\tif (last_code != CODE_FILE_DATA) {\n\t\t\t\tfprintf(stdout, \"\\nReceived an error message from device: %s\\n\", msg);\n\t\t\t}\n\t\t\tfree(msg);\n\t\t}\n\t} while (1);\n\n\tif (fname != NULL)\n\t\tfree(fname);\n\n\t/* if there are leftovers to read, finish up cleanly */\n\tif ((int)nlen-1 > 0) {\n\t\tPRINT_VERBOSE(1, \"\\nDiscarding current data hunk.\\n\");\n\t\tfname = (char*)malloc(nlen-1);\n\t\tmobilebackup2_receive_raw(mobilebackup2, fname, nlen-1, &r);\n\t\tfree(fname);\n\t\tremove(bname);\n\t}\n\n\t/* clean up */\n\tif (bname != NULL)\n\t\tfree(bname);\n\n\tif (dname != NULL)\n\t\tfree(dname);\n\n\t// TODO error handling?!\n\tplist_t empty_plist = plist_new_dict();\n\tmobilebackup2_send_status_response(mobilebackup2, 0, NULL, empty_plist);\n\tplist_free(empty_plist);\n\n\treturn file_count;\n}"
  },
  {
    "function_name": "mb2_receive_filename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
    "lines": "665-709",
    "snippet": "static int mb2_receive_filename(mobilebackup2_client_t mobilebackup2, char** filename)\n{\n\tuint32_t nlen = 0;\n\tuint32_t rlen = 0;\n\n\tdo {\n\t\tnlen = 0;\n\t\trlen = 0;\n\t\tmobilebackup2_receive_raw(mobilebackup2, (char*)&nlen, 4, &rlen);\n\t\tnlen = be32toh(nlen);\n\n\t\tif ((nlen == 0) && (rlen == 4)) {\n\t\t\t// a zero length means no more files to receive\n\t\t\treturn 0;\n\t\t} else if(rlen == 0) {\n\t\t\t// device needs more time, waiting...\n\t\t\tcontinue;\n\t\t} else if (nlen > 4096) {\n\t\t\t// filename length is too large\n\t\t\tprintf(\"ERROR: %s: too large filename length (%d)!\\n\", __func__, nlen);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (*filename != NULL) {\n\t\t\tfree(*filename);\n\t\t\t*filename = NULL;\n\t\t}\n\n\t\t*filename = (char*)malloc(nlen+1);\n\n\t\trlen = 0;\n\t\tmobilebackup2_receive_raw(mobilebackup2, *filename, nlen, &rlen);\n\t\tif (rlen != nlen) {\n\t\t\tprintf(\"ERROR: %s: could not read filename\\n\", __func__);\n\t\t\treturn 0;\n\t\t}\n\n\t\tchar* p = *filename;\n\t\tp[rlen] = 0;\n\n\t\tbreak;\n\t} while(1 && !quit_flag);\n\n\treturn nlen;\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <sys/statvfs.h>",
      "#include <termios.h>",
      "#include <conio.h>",
      "#include <windows.h>",
      "#include <endianness.h>",
      "#include \"common/utils.h\"",
      "#include <libimobiledevice/afc.h>",
      "#include <libimobiledevice/notification_proxy.h>",
      "#include <libimobiledevice/mobilebackup2.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <libgen.h>",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int quit_flag = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ERROR: %s: could not read filename\\n\"",
            "__func__"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "asprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/include/asprintf.h",
          "lines": "23-31",
          "snippet": "static inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}",
          "includes": [
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <config.h>\n\nstatic inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mobilebackup2_receive_raw",
          "args": [
            "mobilebackup2",
            "*filename",
            "nlen",
            "&rlen"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "mobilebackup2_receive_raw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/mobilebackup2.c",
          "lines": "241-266",
          "snippet": "LIBIMOBILEDEVICE_API mobilebackup2_error_t mobilebackup2_receive_raw(mobilebackup2_client_t client, char *data, uint32_t length, uint32_t *bytes)\n{\n\tif (!client || !client->parent || !data || (length == 0) || !bytes)\n\t\treturn MOBILEBACKUP2_E_INVALID_ARG;\n\n\tservice_client_t raw = client->parent->parent->parent;\n\n\t*bytes = 0;\n\n\tint bytes_loc = 0;\n\tuint32_t received = 0;\n\tdo {\n\t\tbytes_loc = 0;\n\t\tservice_receive(raw, data+received, length-received, (uint32_t*)&bytes_loc);\n\t\tif (bytes_loc <= 0) break;\n\t\treceived += bytes_loc;\n\t} while (received < length);\n\tif (received > 0) {\n\t\t*bytes = received;\n\t\treturn MOBILEBACKUP2_E_SUCCESS;\n\t} else if (received == 0) {\n\t\treturn MOBILEBACKUP2_E_SUCCESS;\n\t} else {\n\t\treturn MOBILEBACKUP2_E_MUX_ERROR;\n\t}\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"device_link_service.h\"",
            "#include \"mobilebackup2.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <plist/plist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"device_link_service.h\"\n#include \"mobilebackup2.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <plist/plist.h>\n\nLIBIMOBILEDEVICE_API mobilebackup2_error_t mobilebackup2_receive_raw(mobilebackup2_client_t client, char *data, uint32_t length, uint32_t *bytes)\n{\n\tif (!client || !client->parent || !data || (length == 0) || !bytes)\n\t\treturn MOBILEBACKUP2_E_INVALID_ARG;\n\n\tservice_client_t raw = client->parent->parent->parent;\n\n\t*bytes = 0;\n\n\tint bytes_loc = 0;\n\tuint32_t received = 0;\n\tdo {\n\t\tbytes_loc = 0;\n\t\tservice_receive(raw, data+received, length-received, (uint32_t*)&bytes_loc);\n\t\tif (bytes_loc <= 0) break;\n\t\treceived += bytes_loc;\n\t} while (received < length);\n\tif (received > 0) {\n\t\t*bytes = received;\n\t\treturn MOBILEBACKUP2_E_SUCCESS;\n\t} else if (received == 0) {\n\t\treturn MOBILEBACKUP2_E_SUCCESS;\n\t} else {\n\t\treturn MOBILEBACKUP2_E_MUX_ERROR;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "nlen+1"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "*filename"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "thread_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "39-44",
          "snippet": "void thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nvoid thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32toh",
          "args": [
            "nlen"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int quit_flag = 0;\n\nstatic int mb2_receive_filename(mobilebackup2_client_t mobilebackup2, char** filename)\n{\n\tuint32_t nlen = 0;\n\tuint32_t rlen = 0;\n\n\tdo {\n\t\tnlen = 0;\n\t\trlen = 0;\n\t\tmobilebackup2_receive_raw(mobilebackup2, (char*)&nlen, 4, &rlen);\n\t\tnlen = be32toh(nlen);\n\n\t\tif ((nlen == 0) && (rlen == 4)) {\n\t\t\t// a zero length means no more files to receive\n\t\t\treturn 0;\n\t\t} else if(rlen == 0) {\n\t\t\t// device needs more time, waiting...\n\t\t\tcontinue;\n\t\t} else if (nlen > 4096) {\n\t\t\t// filename length is too large\n\t\t\tprintf(\"ERROR: %s: too large filename length (%d)!\\n\", __func__, nlen);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (*filename != NULL) {\n\t\t\tfree(*filename);\n\t\t\t*filename = NULL;\n\t\t}\n\n\t\t*filename = (char*)malloc(nlen+1);\n\n\t\trlen = 0;\n\t\tmobilebackup2_receive_raw(mobilebackup2, *filename, nlen, &rlen);\n\t\tif (rlen != nlen) {\n\t\t\tprintf(\"ERROR: %s: could not read filename\\n\", __func__);\n\t\t\treturn 0;\n\t\t}\n\n\t\tchar* p = *filename;\n\t\tp[rlen] = 0;\n\n\t\tbreak;\n\t} while(1 && !quit_flag);\n\n\treturn nlen;\n}"
  },
  {
    "function_name": "mb2_handle_send_files",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
    "lines": "620-663",
    "snippet": "static void mb2_handle_send_files(mobilebackup2_client_t mobilebackup2, plist_t message, const char *backup_dir)\n{\n\tuint32_t cnt;\n\tuint32_t i = 0;\n\tuint32_t sent;\n\tplist_t errplist = NULL;\n\n\tif (!message || (plist_get_node_type(message) != PLIST_ARRAY) || (plist_array_get_size(message) < 2) || !backup_dir) return;\n\n\tplist_t files = plist_array_get_item(message, 1);\n\tcnt = plist_array_get_size(files);\n\n\tfor (i = 0; i < cnt; i++) {\n\t\tplist_t val = plist_array_get_item(files, i);\n\t\tif (plist_get_node_type(val) != PLIST_STRING) {\n\t\t\tcontinue;\n\t\t}\n\t\tchar *str = NULL;\n\t\tplist_get_string_val(val, &str);\n\t\tif (!str)\n\t\t\tcontinue;\n\n\t\tif (mb2_handle_send_file(mobilebackup2, backup_dir, str, &errplist) < 0) {\n\t\t\tfree(str);\n\t\t\t//printf(\"Error when sending file '%s' to device\\n\", str);\n\t\t\t// TODO: perhaps we can continue, we've got a multi status response?!\n\t\t\tbreak;\n\t\t}\n\t\tfree(str);\n\t}\n\n\t/* send terminating 0 dword */\n\tuint32_t zero = 0;\n\tmobilebackup2_send_raw(mobilebackup2, (char*)&zero, 4, &sent);\n\n\tif (!errplist) {\n\t\tplist_t emptydict = plist_new_dict();\n\t\tmobilebackup2_send_status_response(mobilebackup2, 0, NULL, emptydict);\n\t\tplist_free(emptydict);\n\t} else {\n\t\tmobilebackup2_send_status_response(mobilebackup2, -13, \"Multi status\", errplist);\n\t\tplist_free(errplist);\n\t}\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <sys/statvfs.h>",
      "#include <termios.h>",
      "#include <conio.h>",
      "#include <windows.h>",
      "#include <endianness.h>",
      "#include \"common/utils.h\"",
      "#include <libimobiledevice/afc.h>",
      "#include <libimobiledevice/notification_proxy.h>",
      "#include <libimobiledevice/mobilebackup2.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <libgen.h>",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "plist_free",
          "args": [
            "errplist"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mobilebackup2_send_status_response",
          "args": [
            "mobilebackup2",
            "-13",
            "\"Multi status\"",
            "errplist"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "mobilebackup2_send_status_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/mobilebackup2.c",
          "lines": "357-380",
          "snippet": "LIBIMOBILEDEVICE_API mobilebackup2_error_t mobilebackup2_send_status_response(mobilebackup2_client_t client, int status_code, const char *status1, plist_t status2)\n{\n\tif (!client || !client->parent)\n\t\treturn MOBILEBACKUP2_E_INVALID_ARG;\n\n\tplist_t array = plist_new_array();\n\tplist_array_append_item(array, plist_new_string(\"DLMessageStatusResponse\"));\n\tplist_array_append_item(array, plist_new_uint(status_code));\n\tif (status1) {\n\t\tplist_array_append_item(array, plist_new_string(status1));\n\t} else {\n\t\tplist_array_append_item(array, plist_new_string(\"___EmptyParameterString___\"));\n\t}\n\tif (status2) {\n\t\tplist_array_append_item(array, plist_copy(status2));\n\t} else {\n\t\tplist_array_append_item(array, plist_new_string(\"___EmptyParameterString___\"));\n\t}\n\n\tmobilebackup2_error_t err = mobilebackup2_error(device_link_service_send(client->parent, array));\n\tplist_free(array);\n\n\treturn err;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"device_link_service.h\"",
            "#include \"mobilebackup2.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <plist/plist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"device_link_service.h\"\n#include \"mobilebackup2.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <plist/plist.h>\n\nLIBIMOBILEDEVICE_API mobilebackup2_error_t mobilebackup2_send_status_response(mobilebackup2_client_t client, int status_code, const char *status1, plist_t status2)\n{\n\tif (!client || !client->parent)\n\t\treturn MOBILEBACKUP2_E_INVALID_ARG;\n\n\tplist_t array = plist_new_array();\n\tplist_array_append_item(array, plist_new_string(\"DLMessageStatusResponse\"));\n\tplist_array_append_item(array, plist_new_uint(status_code));\n\tif (status1) {\n\t\tplist_array_append_item(array, plist_new_string(status1));\n\t} else {\n\t\tplist_array_append_item(array, plist_new_string(\"___EmptyParameterString___\"));\n\t}\n\tif (status2) {\n\t\tplist_array_append_item(array, plist_copy(status2));\n\t} else {\n\t\tplist_array_append_item(array, plist_new_string(\"___EmptyParameterString___\"));\n\t}\n\n\tmobilebackup2_error_t err = mobilebackup2_error(device_link_service_send(client->parent, array));\n\tplist_free(array);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_free",
          "args": [
            "emptydict"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_dict",
          "args": [],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mobilebackup2_send_raw",
          "args": [
            "mobilebackup2",
            "(char*)&zero",
            "4",
            "&sent"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "mobilebackup2_send_raw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/mobilebackup2.c",
          "lines": "215-239",
          "snippet": "LIBIMOBILEDEVICE_API mobilebackup2_error_t mobilebackup2_send_raw(mobilebackup2_client_t client, const char *data, uint32_t length, uint32_t *bytes)\n{\n\tif (!client || !client->parent || !data || (length == 0) || !bytes)\n\t\treturn MOBILEBACKUP2_E_INVALID_ARG;\n\n\t*bytes = 0;\n\n\tservice_client_t raw = client->parent->parent->parent;\n\n\tint bytes_loc = 0;\n\tuint32_t sent = 0;\n\tdo {\n\t\tbytes_loc = 0;\n\t\tservice_send(raw, data+sent, length-sent, (uint32_t*)&bytes_loc);\n\t\tif (bytes_loc <= 0)\n\t\t\tbreak;\n\t\tsent += bytes_loc;\n\t} while (sent < length);\n\tif (sent > 0) {\n\t\t*bytes = sent;\n\t\treturn MOBILEBACKUP2_E_SUCCESS;\n\t} else {\n\t\treturn MOBILEBACKUP2_E_MUX_ERROR;\n\t}\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"device_link_service.h\"",
            "#include \"mobilebackup2.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <plist/plist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"device_link_service.h\"\n#include \"mobilebackup2.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <plist/plist.h>\n\nLIBIMOBILEDEVICE_API mobilebackup2_error_t mobilebackup2_send_raw(mobilebackup2_client_t client, const char *data, uint32_t length, uint32_t *bytes)\n{\n\tif (!client || !client->parent || !data || (length == 0) || !bytes)\n\t\treturn MOBILEBACKUP2_E_INVALID_ARG;\n\n\t*bytes = 0;\n\n\tservice_client_t raw = client->parent->parent->parent;\n\n\tint bytes_loc = 0;\n\tuint32_t sent = 0;\n\tdo {\n\t\tbytes_loc = 0;\n\t\tservice_send(raw, data+sent, length-sent, (uint32_t*)&bytes_loc);\n\t\tif (bytes_loc <= 0)\n\t\t\tbreak;\n\t\tsent += bytes_loc;\n\t} while (sent < length);\n\tif (sent > 0) {\n\t\t*bytes = sent;\n\t\treturn MOBILEBACKUP2_E_SUCCESS;\n\t} else {\n\t\treturn MOBILEBACKUP2_E_MUX_ERROR;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "str"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "thread_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "39-44",
          "snippet": "void thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nvoid thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb2_handle_send_file",
          "args": [
            "mobilebackup2",
            "backup_dir",
            "str",
            "&errplist"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_string_val",
          "args": [
            "val",
            "&str"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_node_type",
          "args": [
            "val"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_array_get_item",
          "args": [
            "files",
            "i"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_array_get_size",
          "args": [
            "files"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_array_get_item",
          "args": [
            "message",
            "1"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_array_get_size",
          "args": [
            "message"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_node_type",
          "args": [
            "message"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void mb2_handle_send_files(mobilebackup2_client_t mobilebackup2, plist_t message, const char *backup_dir)\n{\n\tuint32_t cnt;\n\tuint32_t i = 0;\n\tuint32_t sent;\n\tplist_t errplist = NULL;\n\n\tif (!message || (plist_get_node_type(message) != PLIST_ARRAY) || (plist_array_get_size(message) < 2) || !backup_dir) return;\n\n\tplist_t files = plist_array_get_item(message, 1);\n\tcnt = plist_array_get_size(files);\n\n\tfor (i = 0; i < cnt; i++) {\n\t\tplist_t val = plist_array_get_item(files, i);\n\t\tif (plist_get_node_type(val) != PLIST_STRING) {\n\t\t\tcontinue;\n\t\t}\n\t\tchar *str = NULL;\n\t\tplist_get_string_val(val, &str);\n\t\tif (!str)\n\t\t\tcontinue;\n\n\t\tif (mb2_handle_send_file(mobilebackup2, backup_dir, str, &errplist) < 0) {\n\t\t\tfree(str);\n\t\t\t//printf(\"Error when sending file '%s' to device\\n\", str);\n\t\t\t// TODO: perhaps we can continue, we've got a multi status response?!\n\t\t\tbreak;\n\t\t}\n\t\tfree(str);\n\t}\n\n\t/* send terminating 0 dword */\n\tuint32_t zero = 0;\n\tmobilebackup2_send_raw(mobilebackup2, (char*)&zero, 4, &sent);\n\n\tif (!errplist) {\n\t\tplist_t emptydict = plist_new_dict();\n\t\tmobilebackup2_send_status_response(mobilebackup2, 0, NULL, emptydict);\n\t\tplist_free(emptydict);\n\t} else {\n\t\tmobilebackup2_send_status_response(mobilebackup2, -13, \"Multi status\", errplist);\n\t\tplist_free(errplist);\n\t}\n}"
  },
  {
    "function_name": "win32err_to_errno",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
    "lines": "454-464",
    "snippet": "static int win32err_to_errno(int err_value)\n{\n\tswitch (err_value) {\n\t\tcase ERROR_FILE_NOT_FOUND:\n\t\t\treturn ENOENT;\n\t\tcase ERROR_ALREADY_EXISTS:\n\t\t\treturn EEXIST;\n\t\tdefault:\n\t\t\treturn EFAULT;\n\t}\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <sys/statvfs.h>",
      "#include <termios.h>",
      "#include <conio.h>",
      "#include <windows.h>",
      "#include <endianness.h>",
      "#include \"common/utils.h\"",
      "#include <libimobiledevice/afc.h>",
      "#include <libimobiledevice/notification_proxy.h>",
      "#include <libimobiledevice/mobilebackup2.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <libgen.h>",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int win32err_to_errno(int err_value)\n{\n\tswitch (err_value) {\n\t\tcase ERROR_FILE_NOT_FOUND:\n\t\t\treturn ENOENT;\n\t\tcase ERROR_ALREADY_EXISTS:\n\t\t\treturn EEXIST;\n\t\tdefault:\n\t\t\treturn EFAULT;\n\t}\n}"
  },
  {
    "function_name": "errno_to_device_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
    "lines": "441-451",
    "snippet": "static int errno_to_device_error(int errno_value)\n{\n\tswitch (errno_value) {\n\t\tcase ENOENT:\n\t\t\treturn -6;\n\t\tcase EEXIST:\n\t\t\treturn -7;\n\t\tdefault:\n\t\t\treturn -errno_value;\n\t}\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <sys/statvfs.h>",
      "#include <termios.h>",
      "#include <conio.h>",
      "#include <windows.h>",
      "#include <endianness.h>",
      "#include \"common/utils.h\"",
      "#include <libimobiledevice/afc.h>",
      "#include <libimobiledevice/notification_proxy.h>",
      "#include <libimobiledevice/mobilebackup2.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <libgen.h>",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int errno_to_device_error(int errno_value)\n{\n\tswitch (errno_value) {\n\t\tcase ENOENT:\n\t\t\treturn -6;\n\t\tcase EEXIST:\n\t\t\treturn -7;\n\t\tdefault:\n\t\t\treturn -errno_value;\n\t}\n}"
  },
  {
    "function_name": "mb2_multi_status_add_file_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
    "lines": "432-439",
    "snippet": "static void mb2_multi_status_add_file_error(plist_t status_dict, const char *path, int error_code, const char *error_message)\n{\n\tif (!status_dict) return;\n\tplist_t filedict = plist_new_dict();\n\tplist_dict_set_item(filedict, \"DLFileErrorString\", plist_new_string(error_message));\n\tplist_dict_set_item(filedict, \"DLFileErrorCode\", plist_new_uint(error_code));\n\tplist_dict_set_item(status_dict, path, filedict);\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <sys/statvfs.h>",
      "#include <termios.h>",
      "#include <conio.h>",
      "#include <windows.h>",
      "#include <endianness.h>",
      "#include \"common/utils.h\"",
      "#include <libimobiledevice/afc.h>",
      "#include <libimobiledevice/notification_proxy.h>",
      "#include <libimobiledevice/mobilebackup2.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <libgen.h>",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "status_dict",
            "path",
            "filedict"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "filedict",
            "\"DLFileErrorCode\"",
            "plist_new_uint(error_code)"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_uint",
          "args": [
            "error_code"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "filedict",
            "\"DLFileErrorString\"",
            "plist_new_string(error_message)"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_string",
          "args": [
            "error_message"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_dict",
          "args": [],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void mb2_multi_status_add_file_error(plist_t status_dict, const char *path, int error_code, const char *error_message)\n{\n\tif (!status_dict) return;\n\tplist_t filedict = plist_new_dict();\n\tplist_dict_set_item(filedict, \"DLFileErrorString\", plist_new_string(error_message));\n\tplist_dict_set_item(filedict, \"DLFileErrorCode\", plist_new_uint(error_code));\n\tplist_dict_set_item(status_dict, path, filedict);\n}"
  },
  {
    "function_name": "mb2_set_overall_progress_from_message",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
    "lines": "411-430",
    "snippet": "static void mb2_set_overall_progress_from_message(plist_t message, char* identifier)\n{\n\tplist_t node = NULL;\n\tdouble progress = 0.0;\n\n\tif (!strcmp(identifier, \"DLMessageDownloadFiles\")) {\n\t\tnode = plist_array_get_item(message, 3);\n\t} else if (!strcmp(identifier, \"DLMessageUploadFiles\")) {\n\t\tnode = plist_array_get_item(message, 2);\n\t} else if (!strcmp(identifier, \"DLMessageMoveFiles\") || !strcmp(identifier, \"DLMessageMoveItems\")) {\n\t\tnode = plist_array_get_item(message, 3);\n\t} else if (!strcmp(identifier, \"DLMessageRemoveFiles\") || !strcmp(identifier, \"DLMessageRemoveItems\")) {\n\t\tnode = plist_array_get_item(message, 3);\n\t}\n\n\tif (node != NULL) {\n\t\tplist_get_real_val(node, &progress);\n\t\tmb2_set_overall_progress(progress);\n\t}\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <sys/statvfs.h>",
      "#include <termios.h>",
      "#include <conio.h>",
      "#include <windows.h>",
      "#include <endianness.h>",
      "#include \"common/utils.h\"",
      "#include <libimobiledevice/afc.h>",
      "#include <libimobiledevice/notification_proxy.h>",
      "#include <libimobiledevice/mobilebackup2.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <libgen.h>",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mb2_set_overall_progress",
          "args": [
            "progress"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "mb2_set_overall_progress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
          "lines": "405-409",
          "snippet": "static void mb2_set_overall_progress(double progress)\n{\n\tif (progress > 0.0)\n\t\toverall_progress = progress;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <sys/statvfs.h>",
            "#include <termios.h>",
            "#include <conio.h>",
            "#include <windows.h>",
            "#include <endianness.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup2.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <libgen.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static double overall_progress = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic double overall_progress = 0;\n\nstatic void mb2_set_overall_progress(double progress)\n{\n\tif (progress > 0.0)\n\t\toverall_progress = progress;\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_get_real_val",
          "args": [
            "node",
            "&progress"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_array_get_item",
          "args": [
            "message",
            "3"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "identifier",
            "\"DLMessageRemoveItems\""
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "plist_strcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
          "lines": "296-309",
          "snippet": "static int plist_strcmp(plist_t node, const char *str)\n{\n\tchar *buffer = NULL;\n\tint ret = 0;\n\n\tif (plist_get_node_type(node) != PLIST_STRING)\n\t\treturn ret;\n\n\tplist_get_string_val(node, &buffer);\n\tret = strcmp(buffer, str);\n\tfree(buffer);\n\n\treturn ret;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <unistd.h>",
            "#include <gcrypt.h>",
            "#include <openssl/sha.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int plist_strcmp(plist_t node, const char *str)\n{\n\tchar *buffer = NULL;\n\tint ret = 0;\n\n\tif (plist_get_node_type(node) != PLIST_STRING)\n\t\treturn ret;\n\n\tplist_get_string_val(node, &buffer);\n\tret = strcmp(buffer, str);\n\tfree(buffer);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_array_get_item",
          "args": [
            "message",
            "3"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_array_get_item",
          "args": [
            "message",
            "2"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_array_get_item",
          "args": [
            "message",
            "3"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void mb2_set_overall_progress_from_message(plist_t message, char* identifier)\n{\n\tplist_t node = NULL;\n\tdouble progress = 0.0;\n\n\tif (!strcmp(identifier, \"DLMessageDownloadFiles\")) {\n\t\tnode = plist_array_get_item(message, 3);\n\t} else if (!strcmp(identifier, \"DLMessageUploadFiles\")) {\n\t\tnode = plist_array_get_item(message, 2);\n\t} else if (!strcmp(identifier, \"DLMessageMoveFiles\") || !strcmp(identifier, \"DLMessageMoveItems\")) {\n\t\tnode = plist_array_get_item(message, 3);\n\t} else if (!strcmp(identifier, \"DLMessageRemoveFiles\") || !strcmp(identifier, \"DLMessageRemoveItems\")) {\n\t\tnode = plist_array_get_item(message, 3);\n\t}\n\n\tif (node != NULL) {\n\t\tplist_get_real_val(node, &progress);\n\t\tmb2_set_overall_progress(progress);\n\t}\n}"
  },
  {
    "function_name": "mb2_set_overall_progress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
    "lines": "405-409",
    "snippet": "static void mb2_set_overall_progress(double progress)\n{\n\tif (progress > 0.0)\n\t\toverall_progress = progress;\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <sys/statvfs.h>",
      "#include <termios.h>",
      "#include <conio.h>",
      "#include <windows.h>",
      "#include <endianness.h>",
      "#include \"common/utils.h\"",
      "#include <libimobiledevice/afc.h>",
      "#include <libimobiledevice/notification_proxy.h>",
      "#include <libimobiledevice/mobilebackup2.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <libgen.h>",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static double overall_progress = 0;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic double overall_progress = 0;\n\nstatic void mb2_set_overall_progress(double progress)\n{\n\tif (progress > 0.0)\n\t\toverall_progress = progress;\n}"
  },
  {
    "function_name": "print_progress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
    "lines": "379-401",
    "snippet": "static void print_progress(uint64_t current, uint64_t total)\n{\n\tchar *format_size = NULL;\n\tdouble progress = ((double)current/(double)total)*100;\n\tif (progress < 0)\n\t\treturn;\n\n\tif (progress > 100)\n\t\tprogress = 100;\n\n\tprint_progress_real((double)progress, 0);\n\n\tformat_size = string_format_size(current);\n\tPRINT_VERBOSE(1, \" (%s\", format_size);\n\tfree(format_size);\n\tformat_size = string_format_size(total);\n\tPRINT_VERBOSE(1, \"/%s)     \", format_size);\n\tfree(format_size);\n\n\tfflush(stdout);\n\tif (progress == 100)\n\t\tPRINT_VERBOSE(1, \"\\n\");\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <sys/statvfs.h>",
      "#include <termios.h>",
      "#include <conio.h>",
      "#include <windows.h>",
      "#include <endianness.h>",
      "#include \"common/utils.h\"",
      "#include <libimobiledevice/afc.h>",
      "#include <libimobiledevice/notification_proxy.h>",
      "#include <libimobiledevice/mobilebackup2.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <libgen.h>",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"\\n\""
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stdout"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "format_size"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "thread_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "39-44",
          "snippet": "void thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nvoid thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"/%s)     \"",
            "format_size"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "string_format_size",
          "args": [
            "total"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "string_format_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/utils.c",
          "lines": "142-162",
          "snippet": "char *string_format_size(uint64_t size)\n{\n\tchar buf[80];\n\tdouble sz;\n\tif (size >= 1000000000000LL) {\n\t\tsz = ((double)size / 1000000000000.0f);\n\t\tsprintf(buf, \"%0.1f TB\", sz);\n\t} else if (size >= 1000000000LL) {\n\t\tsz = ((double)size / 1000000000.0f);\n\t\tsprintf(buf, \"%0.1f GB\", sz);\n\t} else if (size >= 1000000LL) {\n\t\tsz = ((double)size / 1000000.0f);\n\t\tsprintf(buf, \"%0.1f MB\", sz);\n\t} else if (size >= 1000LL) {\n\t\tsz = ((double)size / 1000.0f);\n\t\tsprintf(buf, \"%0.1f KB\", sz);\n\t} else {\n\t\tsprintf(buf, \"%d Bytes\", (int)size);\n\t}\n\treturn strdup(buf);\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include <ctype.h>",
            "#include <inttypes.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include <ctype.h>\n#include <inttypes.h>\n#include <sys/time.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <config.h>\n\nchar *string_format_size(uint64_t size)\n{\n\tchar buf[80];\n\tdouble sz;\n\tif (size >= 1000000000000LL) {\n\t\tsz = ((double)size / 1000000000000.0f);\n\t\tsprintf(buf, \"%0.1f TB\", sz);\n\t} else if (size >= 1000000000LL) {\n\t\tsz = ((double)size / 1000000000.0f);\n\t\tsprintf(buf, \"%0.1f GB\", sz);\n\t} else if (size >= 1000000LL) {\n\t\tsz = ((double)size / 1000000.0f);\n\t\tsprintf(buf, \"%0.1f MB\", sz);\n\t} else if (size >= 1000LL) {\n\t\tsz = ((double)size / 1000.0f);\n\t\tsprintf(buf, \"%0.1f KB\", sz);\n\t} else {\n\t\tsprintf(buf, \"%d Bytes\", (int)size);\n\t}\n\treturn strdup(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\" (%s\"",
            "format_size"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_progress_real",
          "args": [
            "(double)progress",
            "0"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "print_progress_real",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
          "lines": "359-377",
          "snippet": "static void print_progress_real(double progress, int flush)\n{\n\tint i = 0;\n\tPRINT_VERBOSE(1, \"\\r[\");\n\tfor(i = 0; i < 50; i++) {\n\t\tif(i < progress / 2) {\n\t\t\tPRINT_VERBOSE(1, \"=\");\n\t\t} else {\n\t\t\tPRINT_VERBOSE(1, \" \");\n\t\t}\n\t}\n\tPRINT_VERBOSE(1, \"] %3.0f%%\", progress);\n\n\tif (flush > 0) {\n\t\tfflush(stdout);\n\t\tif (progress == 100)\n\t\t\tPRINT_VERBOSE(1, \"\\n\");\n\t}\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <sys/statvfs.h>",
            "#include <termios.h>",
            "#include <conio.h>",
            "#include <windows.h>",
            "#include <endianness.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup2.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <libgen.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void print_progress_real(double progress, int flush)\n{\n\tint i = 0;\n\tPRINT_VERBOSE(1, \"\\r[\");\n\tfor(i = 0; i < 50; i++) {\n\t\tif(i < progress / 2) {\n\t\t\tPRINT_VERBOSE(1, \"=\");\n\t\t} else {\n\t\t\tPRINT_VERBOSE(1, \" \");\n\t\t}\n\t}\n\tPRINT_VERBOSE(1, \"] %3.0f%%\", progress);\n\n\tif (flush > 0) {\n\t\tfflush(stdout);\n\t\tif (progress == 100)\n\t\t\tPRINT_VERBOSE(1, \"\\n\");\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void print_progress(uint64_t current, uint64_t total)\n{\n\tchar *format_size = NULL;\n\tdouble progress = ((double)current/(double)total)*100;\n\tif (progress < 0)\n\t\treturn;\n\n\tif (progress > 100)\n\t\tprogress = 100;\n\n\tprint_progress_real((double)progress, 0);\n\n\tformat_size = string_format_size(current);\n\tPRINT_VERBOSE(1, \" (%s\", format_size);\n\tfree(format_size);\n\tformat_size = string_format_size(total);\n\tPRINT_VERBOSE(1, \"/%s)     \", format_size);\n\tfree(format_size);\n\n\tfflush(stdout);\n\tif (progress == 100)\n\t\tPRINT_VERBOSE(1, \"\\n\");\n}"
  },
  {
    "function_name": "print_progress_real",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
    "lines": "359-377",
    "snippet": "static void print_progress_real(double progress, int flush)\n{\n\tint i = 0;\n\tPRINT_VERBOSE(1, \"\\r[\");\n\tfor(i = 0; i < 50; i++) {\n\t\tif(i < progress / 2) {\n\t\t\tPRINT_VERBOSE(1, \"=\");\n\t\t} else {\n\t\t\tPRINT_VERBOSE(1, \" \");\n\t\t}\n\t}\n\tPRINT_VERBOSE(1, \"] %3.0f%%\", progress);\n\n\tif (flush > 0) {\n\t\tfflush(stdout);\n\t\tif (progress == 100)\n\t\t\tPRINT_VERBOSE(1, \"\\n\");\n\t}\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <sys/statvfs.h>",
      "#include <termios.h>",
      "#include <conio.h>",
      "#include <windows.h>",
      "#include <endianness.h>",
      "#include \"common/utils.h\"",
      "#include <libimobiledevice/afc.h>",
      "#include <libimobiledevice/notification_proxy.h>",
      "#include <libimobiledevice/mobilebackup2.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <libgen.h>",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"\\n\""
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stdout"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"] %3.0f%%\"",
            "progress"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\" \""
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"=\""
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"\\r[\""
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void print_progress_real(double progress, int flush)\n{\n\tint i = 0;\n\tPRINT_VERBOSE(1, \"\\r[\");\n\tfor(i = 0; i < 50; i++) {\n\t\tif(i < progress / 2) {\n\t\t\tPRINT_VERBOSE(1, \"=\");\n\t\t} else {\n\t\t\tPRINT_VERBOSE(1, \" \");\n\t\t}\n\t}\n\tPRINT_VERBOSE(1, \"] %3.0f%%\", progress);\n\n\tif (flush > 0) {\n\t\tfflush(stdout);\n\t\tif (progress == 100)\n\t\t\tPRINT_VERBOSE(1, \"\\n\");\n\t}\n}"
  },
  {
    "function_name": "do_post_notification",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
    "lines": "330-357",
    "snippet": "static void do_post_notification(idevice_t device, const char *notification)\n{\n\tlockdownd_service_descriptor_t service = NULL;\n\tnp_client_t np;\n\n\tlockdownd_client_t lockdown = NULL;\n\n\tif (lockdownd_client_new_with_handshake(device, &lockdown, \"idevicebackup2\") != LOCKDOWN_E_SUCCESS) {\n\t\treturn;\n\t}\n\n\tlockdownd_start_service(lockdown, NP_SERVICE_NAME, &service);\n\tif (service && service->port) {\n\t\tnp_client_new(device, service, &np);\n\t\tif (np) {\n\t\t\tnp_post_notification(np, notification);\n\t\t\tnp_client_free(np);\n\t\t}\n\t} else {\n\t\tprintf(\"Could not start %s\\n\", NP_SERVICE_NAME);\n\t}\n\n\tif (service) {\n\t\tlockdownd_service_descriptor_free(service);\n\t\tservice = NULL;\n\t}\n\tlockdownd_client_free(lockdown);\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <sys/statvfs.h>",
      "#include <termios.h>",
      "#include <conio.h>",
      "#include <windows.h>",
      "#include <endianness.h>",
      "#include \"common/utils.h\"",
      "#include <libimobiledevice/afc.h>",
      "#include <libimobiledevice/notification_proxy.h>",
      "#include <libimobiledevice/mobilebackup2.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <libgen.h>",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdownd_client_free",
          "args": [
            "lockdown"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "lockdownd_client_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/lockdown.c",
          "lines": "322-336",
          "snippet": "LIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_client_free(lockdownd_client_t client)\n{\n\tif (!client)\n\t\treturn LOCKDOWN_E_INVALID_ARG;\n\n\tlockdownd_error_t ret = LOCKDOWN_E_UNKNOWN_ERROR;\n\n\tif (client->session_id) {\n\t\tlockdownd_stop_session(client, client->session_id);\n\t}\n\n\tret = lockdownd_client_free_simple(client);\n\n\treturn ret;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/userpref.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"lockdown.h\"",
            "#include \"property_list_service.h\"",
            "#include <plist/plist.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/x509.h>",
            "#include <libtasn1.h>",
            "#include <openssl/x509v3.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/pem.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/userpref.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"lockdown.h\"\n#include \"property_list_service.h\"\n#include <plist/plist.h>\n#include <gnutls/crypto.h>\n#include <gnutls/x509.h>\n#include <libtasn1.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/pem.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_client_free(lockdownd_client_t client)\n{\n\tif (!client)\n\t\treturn LOCKDOWN_E_INVALID_ARG;\n\n\tlockdownd_error_t ret = LOCKDOWN_E_UNKNOWN_ERROR;\n\n\tif (client->session_id) {\n\t\tlockdownd_stop_session(client, client->session_id);\n\t}\n\n\tret = lockdownd_client_free_simple(client);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdownd_service_descriptor_free",
          "args": [
            "service"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "lockdownd_service_descriptor_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/lockdown.c",
          "lines": "1522-1528",
          "snippet": "LIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_service_descriptor_free(lockdownd_service_descriptor_t service)\n{\n\tif (service)\n\t\tfree(service);\n\n\treturn LOCKDOWN_E_SUCCESS;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/userpref.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"lockdown.h\"",
            "#include \"property_list_service.h\"",
            "#include <plist/plist.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/x509.h>",
            "#include <libtasn1.h>",
            "#include <openssl/x509v3.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/pem.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/userpref.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"lockdown.h\"\n#include \"property_list_service.h\"\n#include <plist/plist.h>\n#include <gnutls/crypto.h>\n#include <gnutls/x509.h>\n#include <libtasn1.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/pem.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_service_descriptor_free(lockdownd_service_descriptor_t service)\n{\n\tif (service)\n\t\tfree(service);\n\n\treturn LOCKDOWN_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Could not start %s\\n\"",
            "NP_SERVICE_NAME"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "asprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/include/asprintf.h",
          "lines": "23-31",
          "snippet": "static inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}",
          "includes": [
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <config.h>\n\nstatic inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "np_client_free",
          "args": [
            "np"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "np_client_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/notification_proxy.c",
          "lines": "114-166",
          "snippet": "LIBIMOBILEDEVICE_API np_error_t np_client_free(np_client_t client)\n{\n\tplist_t dict;\n\tproperty_list_service_client_t parent;\n\n\tif (!client)\n\t\treturn NP_E_INVALID_ARG;\n\n\tdict = plist_new_dict();\n\tplist_dict_set_item(dict,\"Command\", plist_new_string(\"Shutdown\"));\n\tproperty_list_service_send_xml_plist(client->parent, dict);\n\tplist_free(dict);\n\n\tparent = client->parent;\n\t/* notifies the client->notifier thread that it should terminate */\n\tclient->parent = NULL;\n\n\tif (client->notifier) {\n\t\tdebug_info(\"joining np callback\");\n\t\tthread_join(client->notifier);\n\t\tthread_free(client->notifier);\n\t\tclient->notifier = (thread_t)NULL;\n\t} else {\n\t\tdict = NULL;\n\t\tproperty_list_service_receive_plist(parent, &dict);\n\t\tif (dict) {\n#ifndef STRIP_DEBUG_CODE\n\t\t\tchar *cmd_value = NULL;\n\t\t\tplist_t cmd_value_node = plist_dict_get_item(dict, \"Command\");\n\t\t\tif (plist_get_node_type(cmd_value_node) == PLIST_STRING) {\n\t\t\t\tplist_get_string_val(cmd_value_node, &cmd_value);\n\t\t\t}\n\t\t\tif (cmd_value && !strcmp(cmd_value, \"ProxyDeath\")) {\n\t\t\t\t// this is the expected answer\n\t\t\t} else {\n\t\t\t\tdebug_info(\"Did not get ProxyDeath but:\");\n\t\t\t\tdebug_plist(dict);\n\t\t\t}\n\t\t\tif (cmd_value) {\n\t\t\t\tfree(cmd_value);\n\t\t\t}\n#endif\n\t\t\tplist_free(dict);\n\t\t}\n\t}\n\n\tproperty_list_service_client_free(parent);\n\n\tmutex_destroy(&client->mutex);\n\tfree(client);\n\n\treturn NP_E_SUCCESS;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"property_list_service.h\"",
            "#include \"notification_proxy.h\"",
            "#include <plist/plist.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"property_list_service.h\"\n#include \"notification_proxy.h\"\n#include <plist/plist.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n\nLIBIMOBILEDEVICE_API np_error_t np_client_free(np_client_t client)\n{\n\tplist_t dict;\n\tproperty_list_service_client_t parent;\n\n\tif (!client)\n\t\treturn NP_E_INVALID_ARG;\n\n\tdict = plist_new_dict();\n\tplist_dict_set_item(dict,\"Command\", plist_new_string(\"Shutdown\"));\n\tproperty_list_service_send_xml_plist(client->parent, dict);\n\tplist_free(dict);\n\n\tparent = client->parent;\n\t/* notifies the client->notifier thread that it should terminate */\n\tclient->parent = NULL;\n\n\tif (client->notifier) {\n\t\tdebug_info(\"joining np callback\");\n\t\tthread_join(client->notifier);\n\t\tthread_free(client->notifier);\n\t\tclient->notifier = (thread_t)NULL;\n\t} else {\n\t\tdict = NULL;\n\t\tproperty_list_service_receive_plist(parent, &dict);\n\t\tif (dict) {\n#ifndef STRIP_DEBUG_CODE\n\t\t\tchar *cmd_value = NULL;\n\t\t\tplist_t cmd_value_node = plist_dict_get_item(dict, \"Command\");\n\t\t\tif (plist_get_node_type(cmd_value_node) == PLIST_STRING) {\n\t\t\t\tplist_get_string_val(cmd_value_node, &cmd_value);\n\t\t\t}\n\t\t\tif (cmd_value && !strcmp(cmd_value, \"ProxyDeath\")) {\n\t\t\t\t// this is the expected answer\n\t\t\t} else {\n\t\t\t\tdebug_info(\"Did not get ProxyDeath but:\");\n\t\t\t\tdebug_plist(dict);\n\t\t\t}\n\t\t\tif (cmd_value) {\n\t\t\t\tfree(cmd_value);\n\t\t\t}\n#endif\n\t\t\tplist_free(dict);\n\t\t}\n\t}\n\n\tproperty_list_service_client_free(parent);\n\n\tmutex_destroy(&client->mutex);\n\tfree(client);\n\n\treturn NP_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "np_post_notification",
          "args": [
            "np",
            "notification"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "np_post_notification",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/notification_proxy.c",
          "lines": "168-187",
          "snippet": "LIBIMOBILEDEVICE_API np_error_t np_post_notification(np_client_t client, const char *notification)\n{\n\tif (!client || !notification) {\n\t\treturn NP_E_INVALID_ARG;\n\t}\n\tnp_lock(client);\n\n\tplist_t dict = plist_new_dict();\n\tplist_dict_set_item(dict,\"Command\", plist_new_string(\"PostNotification\"));\n\tplist_dict_set_item(dict,\"Name\", plist_new_string(notification));\n\n\tnp_error_t res = np_error(property_list_service_send_xml_plist(client->parent, dict));\n\tplist_free(dict);\n\n\tif (res != NP_E_SUCCESS) {\n\t\tdebug_info(\"Error sending XML plist to device!\");\n\t}\n\tnp_unlock(client);\n\treturn res;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"property_list_service.h\"",
            "#include \"notification_proxy.h\"",
            "#include <plist/plist.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"property_list_service.h\"\n#include \"notification_proxy.h\"\n#include <plist/plist.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n\nLIBIMOBILEDEVICE_API np_error_t np_post_notification(np_client_t client, const char *notification)\n{\n\tif (!client || !notification) {\n\t\treturn NP_E_INVALID_ARG;\n\t}\n\tnp_lock(client);\n\n\tplist_t dict = plist_new_dict();\n\tplist_dict_set_item(dict,\"Command\", plist_new_string(\"PostNotification\"));\n\tplist_dict_set_item(dict,\"Name\", plist_new_string(notification));\n\n\tnp_error_t res = np_error(property_list_service_send_xml_plist(client->parent, dict));\n\tplist_free(dict);\n\n\tif (res != NP_E_SUCCESS) {\n\t\tdebug_info(\"Error sending XML plist to device!\");\n\t}\n\tnp_unlock(client);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "np_client_new",
          "args": [
            "device",
            "service",
            "&np"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "np_client_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/notification_proxy.c",
          "lines": "89-105",
          "snippet": "LIBIMOBILEDEVICE_API np_error_t np_client_new(idevice_t device, lockdownd_service_descriptor_t service, np_client_t *client)\n{\n\tproperty_list_service_client_t plistclient = NULL;\n\tnp_error_t err = np_error(property_list_service_client_new(device, service, &plistclient));\n\tif (err != NP_E_SUCCESS) {\n\t\treturn err;\n\t}\n\n\tnp_client_t client_loc = (np_client_t) malloc(sizeof(struct np_client_private));\n\tclient_loc->parent = plistclient;\n\n\tmutex_init(&client_loc->mutex);\n\tclient_loc->notifier = (thread_t)NULL;\n\n\t*client = client_loc;\n\treturn NP_E_SUCCESS;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"property_list_service.h\"",
            "#include \"notification_proxy.h\"",
            "#include <plist/plist.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"property_list_service.h\"\n#include \"notification_proxy.h\"\n#include <plist/plist.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n\nLIBIMOBILEDEVICE_API np_error_t np_client_new(idevice_t device, lockdownd_service_descriptor_t service, np_client_t *client)\n{\n\tproperty_list_service_client_t plistclient = NULL;\n\tnp_error_t err = np_error(property_list_service_client_new(device, service, &plistclient));\n\tif (err != NP_E_SUCCESS) {\n\t\treturn err;\n\t}\n\n\tnp_client_t client_loc = (np_client_t) malloc(sizeof(struct np_client_private));\n\tclient_loc->parent = plistclient;\n\n\tmutex_init(&client_loc->mutex);\n\tclient_loc->notifier = (thread_t)NULL;\n\n\t*client = client_loc;\n\treturn NP_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdownd_start_service",
          "args": [
            "lockdown",
            "NP_SERVICE_NAME",
            "&service"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "lockdownd_start_service_with_escrow_bag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/lockdown.c",
          "lines": "1364-1367",
          "snippet": "LIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_start_service_with_escrow_bag(lockdownd_client_t client, const char *identifier, lockdownd_service_descriptor_t *service)\n{\n\treturn lockdownd_do_start_service(client, identifier, 1, service);\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/userpref.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"lockdown.h\"",
            "#include \"property_list_service.h\"",
            "#include <plist/plist.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/x509.h>",
            "#include <libtasn1.h>",
            "#include <openssl/x509v3.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/pem.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/userpref.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"lockdown.h\"\n#include \"property_list_service.h\"\n#include <plist/plist.h>\n#include <gnutls/crypto.h>\n#include <gnutls/x509.h>\n#include <libtasn1.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/pem.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_start_service_with_escrow_bag(lockdownd_client_t client, const char *identifier, lockdownd_service_descriptor_t *service)\n{\n\treturn lockdownd_do_start_service(client, identifier, 1, service);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdownd_client_new_with_handshake",
          "args": [
            "device",
            "&lockdown",
            "\"idevicebackup2\""
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "lockdownd_client_new_with_handshake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/lockdown.c",
          "lines": "671-753",
          "snippet": "LIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_client_new_with_handshake(idevice_t device, lockdownd_client_t *client, const char *label)\n{\n\tif (!client)\n\t\treturn LOCKDOWN_E_INVALID_ARG;\n\n\tlockdownd_error_t ret = LOCKDOWN_E_SUCCESS;\n\tlockdownd_client_t client_loc = NULL;\n\tplist_t pair_record = NULL;\n\tchar *host_id = NULL;\n\tchar *type = NULL;\n\n\tret = lockdownd_client_new(device, &client_loc, label);\n\tif (LOCKDOWN_E_SUCCESS != ret) {\n\t\tdebug_info(\"failed to create lockdownd client.\");\n\t\treturn ret;\n\t}\n\n\t/* perform handshake */\n\tif (LOCKDOWN_E_SUCCESS != lockdownd_query_type(client_loc, &type)) {\n\t\tdebug_info(\"QueryType failed in the lockdownd client.\");\n\t\tret = LOCKDOWN_E_NOT_ENOUGH_DATA;\n\t} else {\n\t\tif (strcmp(\"com.apple.mobile.lockdown\", type)) {\n\t\t\tdebug_info(\"Warning QueryType request returned \\\"%s\\\".\", type);\n\t\t}\n\t}\n\tfree(type);\n\n\tuserpref_read_pair_record(client_loc->udid, &pair_record);\n\tif (pair_record) {\n\t\tpair_record_get_host_id(pair_record, &host_id);\n\t}\n\tif (LOCKDOWN_E_SUCCESS == ret && !host_id) {\n\t\tret = LOCKDOWN_E_INVALID_CONF;\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS == ret && !pair_record) {\n\t\t/* attempt pairing */\n\t\tret = lockdownd_pair(client_loc, NULL);\n\t}\n\n\tplist_free(pair_record);\n\tpair_record = NULL;\n\n\t/* in any case, we need to validate pairing to receive trusted host status */\n\tret = lockdownd_validate_pair(client_loc, NULL);\n\n\t/* if not paired yet, let's do it now */\n\tif (LOCKDOWN_E_INVALID_HOST_ID == ret) {\n\t\tfree(host_id);\n\t\thost_id = NULL;\n\t\tret = lockdownd_pair(client_loc, NULL);\n\t\tif (LOCKDOWN_E_SUCCESS == ret) {\n\t\t\tret = lockdownd_validate_pair(client_loc, NULL);\n\t\t} else if (LOCKDOWN_E_PAIRING_DIALOG_RESPONSE_PENDING == ret) {\n\t\t\tdebug_info(\"Device shows the pairing dialog.\");\n\t\t}\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS == ret) {\n\t\tif (!host_id) {\n\t\t\tuserpref_read_pair_record(client_loc->udid, &pair_record);\n\t\t\tif (pair_record) {\n\t\t\t\tpair_record_get_host_id(pair_record, &host_id);\n\t\t\t\tplist_free(pair_record);\n\t\t\t}\n\t\t}\n\n\t\tret = lockdownd_start_session(client_loc, host_id, NULL, NULL);\n\t\tif (LOCKDOWN_E_SUCCESS != ret) {\n\t\t\tdebug_info(\"Session opening failed.\");\n\t\t}\n\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS == ret) {\n\t\t*client = client_loc;\n\t} else {\n\t\tlockdownd_client_free(client_loc);\n\t}\n\tfree(host_id);\n\treturn ret;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/userpref.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"lockdown.h\"",
            "#include \"property_list_service.h\"",
            "#include <plist/plist.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/x509.h>",
            "#include <libtasn1.h>",
            "#include <openssl/x509v3.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/pem.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/userpref.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"lockdown.h\"\n#include \"property_list_service.h\"\n#include <plist/plist.h>\n#include <gnutls/crypto.h>\n#include <gnutls/x509.h>\n#include <libtasn1.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/pem.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_client_new_with_handshake(idevice_t device, lockdownd_client_t *client, const char *label)\n{\n\tif (!client)\n\t\treturn LOCKDOWN_E_INVALID_ARG;\n\n\tlockdownd_error_t ret = LOCKDOWN_E_SUCCESS;\n\tlockdownd_client_t client_loc = NULL;\n\tplist_t pair_record = NULL;\n\tchar *host_id = NULL;\n\tchar *type = NULL;\n\n\tret = lockdownd_client_new(device, &client_loc, label);\n\tif (LOCKDOWN_E_SUCCESS != ret) {\n\t\tdebug_info(\"failed to create lockdownd client.\");\n\t\treturn ret;\n\t}\n\n\t/* perform handshake */\n\tif (LOCKDOWN_E_SUCCESS != lockdownd_query_type(client_loc, &type)) {\n\t\tdebug_info(\"QueryType failed in the lockdownd client.\");\n\t\tret = LOCKDOWN_E_NOT_ENOUGH_DATA;\n\t} else {\n\t\tif (strcmp(\"com.apple.mobile.lockdown\", type)) {\n\t\t\tdebug_info(\"Warning QueryType request returned \\\"%s\\\".\", type);\n\t\t}\n\t}\n\tfree(type);\n\n\tuserpref_read_pair_record(client_loc->udid, &pair_record);\n\tif (pair_record) {\n\t\tpair_record_get_host_id(pair_record, &host_id);\n\t}\n\tif (LOCKDOWN_E_SUCCESS == ret && !host_id) {\n\t\tret = LOCKDOWN_E_INVALID_CONF;\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS == ret && !pair_record) {\n\t\t/* attempt pairing */\n\t\tret = lockdownd_pair(client_loc, NULL);\n\t}\n\n\tplist_free(pair_record);\n\tpair_record = NULL;\n\n\t/* in any case, we need to validate pairing to receive trusted host status */\n\tret = lockdownd_validate_pair(client_loc, NULL);\n\n\t/* if not paired yet, let's do it now */\n\tif (LOCKDOWN_E_INVALID_HOST_ID == ret) {\n\t\tfree(host_id);\n\t\thost_id = NULL;\n\t\tret = lockdownd_pair(client_loc, NULL);\n\t\tif (LOCKDOWN_E_SUCCESS == ret) {\n\t\t\tret = lockdownd_validate_pair(client_loc, NULL);\n\t\t} else if (LOCKDOWN_E_PAIRING_DIALOG_RESPONSE_PENDING == ret) {\n\t\t\tdebug_info(\"Device shows the pairing dialog.\");\n\t\t}\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS == ret) {\n\t\tif (!host_id) {\n\t\t\tuserpref_read_pair_record(client_loc->udid, &pair_record);\n\t\t\tif (pair_record) {\n\t\t\t\tpair_record_get_host_id(pair_record, &host_id);\n\t\t\t\tplist_free(pair_record);\n\t\t\t}\n\t\t}\n\n\t\tret = lockdownd_start_session(client_loc, host_id, NULL, NULL);\n\t\tif (LOCKDOWN_E_SUCCESS != ret) {\n\t\t\tdebug_info(\"Session opening failed.\");\n\t\t}\n\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS == ret) {\n\t\t*client = client_loc;\n\t} else {\n\t\tlockdownd_client_free(client_loc);\n\t}\n\tfree(host_id);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void do_post_notification(idevice_t device, const char *notification)\n{\n\tlockdownd_service_descriptor_t service = NULL;\n\tnp_client_t np;\n\n\tlockdownd_client_t lockdown = NULL;\n\n\tif (lockdownd_client_new_with_handshake(device, &lockdown, \"idevicebackup2\") != LOCKDOWN_E_SUCCESS) {\n\t\treturn;\n\t}\n\n\tlockdownd_start_service(lockdown, NP_SERVICE_NAME, &service);\n\tif (service && service->port) {\n\t\tnp_client_new(device, service, &np);\n\t\tif (np) {\n\t\t\tnp_post_notification(np, notification);\n\t\t\tnp_client_free(np);\n\t\t}\n\t} else {\n\t\tprintf(\"Could not start %s\\n\", NP_SERVICE_NAME);\n\t}\n\n\tif (service) {\n\t\tlockdownd_service_descriptor_free(service);\n\t\tservice = NULL;\n\t}\n\tlockdownd_client_free(lockdown);\n}"
  },
  {
    "function_name": "mb2_status_check_snapshot_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
    "lines": "303-328",
    "snippet": "static int mb2_status_check_snapshot_state(const char *path, const char *udid, const char *matches)\n{\n\tint ret = -1;\n\tplist_t status_plist = NULL;\n\tchar *file_path = string_build_path(path, udid, \"Status.plist\", NULL);\n\n\tplist_read_from_filename(&status_plist, file_path);\n\tfree(file_path);\n\tif (!status_plist) {\n\t\tprintf(\"Could not read Status.plist!\\n\");\n\t\treturn ret;\n\t}\n\tplist_t node = plist_dict_get_item(status_plist, \"SnapshotState\");\n\tif (node && (plist_get_node_type(node) == PLIST_STRING)) {\n\t\tchar* sval = NULL;\n\t\tplist_get_string_val(node, &sval);\n\t\tif (sval) {\n\t\t\tret = (strcmp(sval, matches) == 0) ? 1 : 0;\n\t\t\tfree(sval);\n\t\t}\n\t} else {\n\t\tprintf(\"%s: ERROR could not get SnapshotState key from Status.plist!\\n\", __func__);\n\t}\n\tplist_free(status_plist);\n\treturn ret;\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <sys/statvfs.h>",
      "#include <termios.h>",
      "#include <conio.h>",
      "#include <windows.h>",
      "#include <endianness.h>",
      "#include \"common/utils.h\"",
      "#include <libimobiledevice/afc.h>",
      "#include <libimobiledevice/notification_proxy.h>",
      "#include <libimobiledevice/mobilebackup2.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <libgen.h>",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "plist_free",
          "args": [
            "status_plist"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: ERROR could not get SnapshotState key from Status.plist!\\n\"",
            "__func__"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "asprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/include/asprintf.h",
          "lines": "23-31",
          "snippet": "static inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}",
          "includes": [
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <config.h>\n\nstatic inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "sval"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "thread_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "39-44",
          "snippet": "void thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nvoid thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "sval",
            "matches"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "plist_strcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
          "lines": "296-309",
          "snippet": "static int plist_strcmp(plist_t node, const char *str)\n{\n\tchar *buffer = NULL;\n\tint ret = 0;\n\n\tif (plist_get_node_type(node) != PLIST_STRING)\n\t\treturn ret;\n\n\tplist_get_string_val(node, &buffer);\n\tret = strcmp(buffer, str);\n\tfree(buffer);\n\n\treturn ret;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <unistd.h>",
            "#include <gcrypt.h>",
            "#include <openssl/sha.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int plist_strcmp(plist_t node, const char *str)\n{\n\tchar *buffer = NULL;\n\tint ret = 0;\n\n\tif (plist_get_node_type(node) != PLIST_STRING)\n\t\treturn ret;\n\n\tplist_get_string_val(node, &buffer);\n\tret = strcmp(buffer, str);\n\tfree(buffer);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_get_string_val",
          "args": [
            "node",
            "&sval"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_node_type",
          "args": [
            "node"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "status_plist",
            "\"SnapshotState\""
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Could not read Status.plist!\\n\""
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_read_from_filename",
          "args": [
            "&status_plist",
            "file_path"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "plist_read_from_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/utils.c",
          "lines": "245-268",
          "snippet": "int plist_read_from_filename(plist_t *plist, const char *filename)\n{\n\tchar *buffer = NULL;\n\tuint64_t length;\n\n\tif (!filename)\n\t\treturn 0;\n\n\tbuffer_read_from_filename(filename, &buffer, &length);\n\n\tif (!buffer) {\n\t\treturn 0;\n\t}\n\n\tif ((length > 8) && (memcmp(buffer, \"bplist00\", 8) == 0)) {\n\t\tplist_from_bin(buffer, length, plist);\n\t} else {\n\t\tplist_from_xml(buffer, length, plist);\n\t}\n\n\tfree(buffer);\n\n\treturn 1;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include <ctype.h>",
            "#include <inttypes.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include <ctype.h>\n#include <inttypes.h>\n#include <sys/time.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <config.h>\n\nint plist_read_from_filename(plist_t *plist, const char *filename)\n{\n\tchar *buffer = NULL;\n\tuint64_t length;\n\n\tif (!filename)\n\t\treturn 0;\n\n\tbuffer_read_from_filename(filename, &buffer, &length);\n\n\tif (!buffer) {\n\t\treturn 0;\n\t}\n\n\tif ((length > 8) && (memcmp(buffer, \"bplist00\", 8) == 0)) {\n\t\tplist_from_bin(buffer, length, plist);\n\t} else {\n\t\tplist_from_xml(buffer, length, plist);\n\t}\n\n\tfree(buffer);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "string_build_path",
          "args": [
            "path",
            "udid",
            "\"Status.plist\"",
            "NULL"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "string_build_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/utils.c",
          "lines": "114-140",
          "snippet": "char *string_build_path(const char *elem, ...)\n{\n\tif (!elem)\n\t\treturn NULL;\n\tva_list args;\n\tint len = strlen(elem)+1;\n\tva_start(args, elem);\n\tchar *arg = va_arg(args, char*);\n\twhile (arg) {\n\t\tlen += strlen(arg)+1;\n\t\targ = va_arg(args, char*);\n\t}\n\tva_end(args);\n\n\tchar* out = (char*)malloc(len);\n\tstrcpy(out, elem);\n\n\tva_start(args, elem);\n\targ = va_arg(args, char*);\n\twhile (arg) {\n\t\tstrcat(out, \"/\");\n\t\tstrcat(out, arg);\n\t\targ = va_arg(args, char*);\n\t}\n\tva_end(args);\n\treturn out;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include <ctype.h>",
            "#include <inttypes.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include <ctype.h>\n#include <inttypes.h>\n#include <sys/time.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <config.h>\n\nchar *string_build_path(const char *elem, ...)\n{\n\tif (!elem)\n\t\treturn NULL;\n\tva_list args;\n\tint len = strlen(elem)+1;\n\tva_start(args, elem);\n\tchar *arg = va_arg(args, char*);\n\twhile (arg) {\n\t\tlen += strlen(arg)+1;\n\t\targ = va_arg(args, char*);\n\t}\n\tva_end(args);\n\n\tchar* out = (char*)malloc(len);\n\tstrcpy(out, elem);\n\n\tva_start(args, elem);\n\targ = va_arg(args, char*);\n\twhile (arg) {\n\t\tstrcat(out, \"/\");\n\t\tstrcat(out, arg);\n\t\targ = va_arg(args, char*);\n\t}\n\tva_end(args);\n\treturn out;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int mb2_status_check_snapshot_state(const char *path, const char *udid, const char *matches)\n{\n\tint ret = -1;\n\tplist_t status_plist = NULL;\n\tchar *file_path = string_build_path(path, udid, \"Status.plist\", NULL);\n\n\tplist_read_from_filename(&status_plist, file_path);\n\tfree(file_path);\n\tif (!status_plist) {\n\t\tprintf(\"Could not read Status.plist!\\n\");\n\t\treturn ret;\n\t}\n\tplist_t node = plist_dict_get_item(status_plist, \"SnapshotState\");\n\tif (node && (plist_get_node_type(node) == PLIST_STRING)) {\n\t\tchar* sval = NULL;\n\t\tplist_get_string_val(node, &sval);\n\t\tif (sval) {\n\t\t\tret = (strcmp(sval, matches) == 0) ? 1 : 0;\n\t\t\tfree(sval);\n\t\t}\n\t} else {\n\t\tprintf(\"%s: ERROR could not get SnapshotState key from Status.plist!\\n\", __func__);\n\t}\n\tplist_free(status_plist);\n\treturn ret;\n}"
  },
  {
    "function_name": "mobilebackup_factory_info_plist_new",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
    "lines": "195-301",
    "snippet": "static plist_t mobilebackup_factory_info_plist_new(const char* udid, lockdownd_client_t lockdown, afc_client_t afc)\n{\n\t/* gather data from lockdown */\n\tplist_t value_node = NULL;\n\tplist_t root_node = NULL;\n\tchar *udid_uppercase = NULL;\n\n\tplist_t ret = plist_new_dict();\n\n\t/* get basic device information in one go */\n\tlockdownd_get_value(lockdown, NULL, NULL, &root_node);\n\n\t/* set fields we understand */\n\tvalue_node = plist_dict_get_item(root_node, \"BuildVersion\");\n\tplist_dict_set_item(ret, \"Build Version\", plist_copy(value_node));\n\n\tvalue_node = plist_dict_get_item(root_node, \"DeviceName\");\n\tplist_dict_set_item(ret, \"Device Name\", plist_copy(value_node));\n\tplist_dict_set_item(ret, \"Display Name\", plist_copy(value_node));\n\n\t/* FIXME: How is the GUID generated? */\n\tplist_dict_set_item(ret, \"GUID\", plist_new_string(\"---\"));\n\n\tvalue_node = plist_dict_get_item(root_node, \"IntegratedCircuitCardIdentity\");\n\tif (value_node)\n\t\tplist_dict_set_item(ret, \"ICCID\", plist_copy(value_node));\n\n\tvalue_node = plist_dict_get_item(root_node, \"InternationalMobileEquipmentIdentity\");\n\tif (value_node)\n\t\tplist_dict_set_item(ret, \"IMEI\", plist_copy(value_node));\n\n\tplist_dict_set_item(ret, \"Last Backup Date\", plist_new_date(time(NULL), 0));\n\n\tvalue_node = plist_dict_get_item(root_node, \"PhoneNumber\");\n\tif (value_node && (plist_get_node_type(value_node) == PLIST_STRING)) {\n\t\tplist_dict_set_item(ret, \"Phone Number\", plist_copy(value_node));\n\t}\n\n\tvalue_node = plist_dict_get_item(root_node, \"ProductType\");\n\tplist_dict_set_item(ret, \"Product Type\", plist_copy(value_node));\n\n\tvalue_node = plist_dict_get_item(root_node, \"ProductVersion\");\n\tplist_dict_set_item(ret, \"Product Version\", plist_copy(value_node));\n\n\tvalue_node = plist_dict_get_item(root_node, \"SerialNumber\");\n\tplist_dict_set_item(ret, \"Serial Number\", plist_copy(value_node));\n\n\t/* FIXME Sync Settings? */\n\n\tvalue_node = plist_dict_get_item(root_node, \"UniqueDeviceID\");\n\tplist_dict_set_item(ret, \"Target Identifier\", plist_new_string(udid));\n\n\tplist_dict_set_item(ret, \"Target Type\", plist_new_string(\"Device\"));\n\n\t/* uppercase */\n\tudid_uppercase = string_toupper((char*)udid);\n\tplist_dict_set_item(ret, \"Unique Identifier\", plist_new_string(udid_uppercase));\n\tfree(udid_uppercase);\n\n\tchar *data_buf = NULL;\n\tuint64_t data_size = 0;\n\tmobilebackup_afc_get_file_contents(afc, \"/Books/iBooksData2.plist\", &data_buf, &data_size);\n\tif (data_buf) {\n\t\tplist_dict_set_item(ret, \"iBooks Data 2\", plist_new_data(data_buf, data_size));\n\t\tfree(data_buf);\n\t}\n\n\tplist_t files = plist_new_dict();\n\tconst char *itunesfiles[] = {\n\t\t\"ApertureAlbumPrefs\",\n\t\t\"IC-Info.sidb\",\n\t\t\"IC-Info.sidv\",\n\t\t\"PhotosFolderAlbums\",\n\t\t\"PhotosFolderName\",\n\t\t\"PhotosFolderPrefs\",\n\t\t\"iPhotoAlbumPrefs\",\n\t\t\"iTunesApplicationIDs\",\n\t\t\"iTunesPrefs\",\n\t\t\"iTunesPrefs.plist\",\n\t\tNULL\n\t};\n\tint i = 0;\n\tfor (i = 0; itunesfiles[i]; i++) {\n\t\tdata_buf = NULL;\n\t\tdata_size = 0;\n\t\tchar *fname = (char*)malloc(strlen(\"/iTunes_Control/iTunes/\") + strlen(itunesfiles[i]) + 1);\n\t\tstrcpy(fname, \"/iTunes_Control/iTunes/\");\n\t\tstrcat(fname, itunesfiles[i]);\n\t\tmobilebackup_afc_get_file_contents(afc, fname, &data_buf, &data_size);\n\t\tfree(fname);\n\t\tif (data_buf) {\n\t\t\tplist_dict_set_item(files, itunesfiles[i], plist_new_data(data_buf, data_size));\n\t\t\tfree(data_buf);\n\t\t}\n\t}\n\tplist_dict_set_item(ret, \"iTunes Files\", files);\n\n\tplist_t itunes_settings = NULL;\n\tlockdownd_get_value(lockdown, \"com.apple.iTunes\", NULL, &itunes_settings);\n\tplist_dict_set_item(ret, \"iTunes Settings\", itunes_settings ? itunes_settings : plist_new_dict());\n\n\tplist_dict_set_item(ret, \"iTunes Version\", plist_new_string(\"10.0.1\"));\n\n\tplist_free(root_node);\n\n\treturn ret;\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <sys/statvfs.h>",
      "#include <termios.h>",
      "#include <conio.h>",
      "#include <windows.h>",
      "#include <endianness.h>",
      "#include \"common/utils.h\"",
      "#include <libimobiledevice/afc.h>",
      "#include <libimobiledevice/notification_proxy.h>",
      "#include <libimobiledevice/mobilebackup2.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <libgen.h>",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "plist_free",
          "args": [
            "root_node"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "ret",
            "\"iTunes Version\"",
            "plist_new_string(\"10.0.1\")"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_string",
          "args": [
            "\"10.0.1\""
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "ret",
            "\"iTunes Settings\"",
            "itunes_settings ? itunes_settings : plist_new_dict()"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_dict",
          "args": [],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdownd_get_value",
          "args": [
            "lockdown",
            "\"com.apple.iTunes\"",
            "NULL",
            "&itunes_settings"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "lockdownd_get_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/lockdown.c",
          "lines": "426-478",
          "snippet": "LIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_get_value(lockdownd_client_t client, const char *domain, const char *key, plist_t *value)\n{\n\tif (!client)\n\t\treturn LOCKDOWN_E_INVALID_ARG;\n\n\tplist_t dict = NULL;\n\tlockdownd_error_t ret = LOCKDOWN_E_UNKNOWN_ERROR;\n\n\t/* setup request plist */\n\tdict = plist_new_dict();\n\tplist_dict_add_label(dict, client->label);\n\tif (domain) {\n\t\tplist_dict_set_item(dict,\"Domain\", plist_new_string(domain));\n\t}\n\tif (key) {\n\t\tplist_dict_set_item(dict,\"Key\", plist_new_string(key));\n\t}\n\tplist_dict_set_item(dict,\"Request\", plist_new_string(\"GetValue\"));\n\n\t/* send to device */\n\tret = lockdownd_send(client, dict);\n\n\tplist_free(dict);\n\tdict = NULL;\n\n\tif (ret != LOCKDOWN_E_SUCCESS)\n\t\treturn ret;\n\n\t/* Now get device's answer */\n\tret = lockdownd_receive(client, &dict);\n\tif (ret != LOCKDOWN_E_SUCCESS)\n\t\treturn ret;\n\n\tret = lockdown_check_result(dict, \"GetValue\");\n\tif (ret == LOCKDOWN_E_SUCCESS) {\n\t\tdebug_info(\"success\");\n\t}\n\n\tif (ret != LOCKDOWN_E_SUCCESS) {\n\t\tplist_free(dict);\n\t\treturn ret;\n\t}\n\n\tplist_t value_node = plist_dict_get_item(dict, \"Value\");\n\n\tif (value_node) {\n\t\tdebug_info(\"has a value\");\n\t\t*value = plist_copy(value_node);\n\t}\n\n\tplist_free(dict);\n\treturn ret;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/userpref.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"lockdown.h\"",
            "#include \"property_list_service.h\"",
            "#include <plist/plist.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/x509.h>",
            "#include <libtasn1.h>",
            "#include <openssl/x509v3.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/pem.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/userpref.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"lockdown.h\"\n#include \"property_list_service.h\"\n#include <plist/plist.h>\n#include <gnutls/crypto.h>\n#include <gnutls/x509.h>\n#include <libtasn1.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/pem.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_get_value(lockdownd_client_t client, const char *domain, const char *key, plist_t *value)\n{\n\tif (!client)\n\t\treturn LOCKDOWN_E_INVALID_ARG;\n\n\tplist_t dict = NULL;\n\tlockdownd_error_t ret = LOCKDOWN_E_UNKNOWN_ERROR;\n\n\t/* setup request plist */\n\tdict = plist_new_dict();\n\tplist_dict_add_label(dict, client->label);\n\tif (domain) {\n\t\tplist_dict_set_item(dict,\"Domain\", plist_new_string(domain));\n\t}\n\tif (key) {\n\t\tplist_dict_set_item(dict,\"Key\", plist_new_string(key));\n\t}\n\tplist_dict_set_item(dict,\"Request\", plist_new_string(\"GetValue\"));\n\n\t/* send to device */\n\tret = lockdownd_send(client, dict);\n\n\tplist_free(dict);\n\tdict = NULL;\n\n\tif (ret != LOCKDOWN_E_SUCCESS)\n\t\treturn ret;\n\n\t/* Now get device's answer */\n\tret = lockdownd_receive(client, &dict);\n\tif (ret != LOCKDOWN_E_SUCCESS)\n\t\treturn ret;\n\n\tret = lockdown_check_result(dict, \"GetValue\");\n\tif (ret == LOCKDOWN_E_SUCCESS) {\n\t\tdebug_info(\"success\");\n\t}\n\n\tif (ret != LOCKDOWN_E_SUCCESS) {\n\t\tplist_free(dict);\n\t\treturn ret;\n\t}\n\n\tplist_t value_node = plist_dict_get_item(dict, \"Value\");\n\n\tif (value_node) {\n\t\tdebug_info(\"has a value\");\n\t\t*value = plist_copy(value_node);\n\t}\n\n\tplist_free(dict);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "ret",
            "\"iTunes Files\"",
            "files"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "data_buf"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "thread_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "39-44",
          "snippet": "void thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nvoid thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "files",
            "itunesfiles[i]",
            "plist_new_data(data_buf, data_size)"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_data",
          "args": [
            "data_buf",
            "data_size"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mobilebackup_afc_get_file_contents",
          "args": [
            "afc",
            "fname",
            "&data_buf",
            "&data_size"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "mobilebackup_afc_get_file_contents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
          "lines": "112-161",
          "snippet": "static void mobilebackup_afc_get_file_contents(afc_client_t afc, const char *filename, char **data, uint64_t *size)\n{\n\tif (!afc || !data || !size) {\n\t\treturn;\n\t}\n\n\tchar **fileinfo = NULL;\n\tuint32_t fsize = 0;\n\n\tafc_get_file_info(afc, filename, &fileinfo);\n\tif (!fileinfo) {\n\t\treturn;\n\t}\n\tint i;\n\tfor (i = 0; fileinfo[i]; i+=2) {\n\t\tif (!strcmp(fileinfo[i], \"st_size\")) {\n\t\t\tfsize = atol(fileinfo[i+1]);\n\t\t\tbreak;\n\t\t}\n\t}\n\tafc_dictionary_free(fileinfo);\n\n\tif (fsize == 0) {\n\t\treturn;\n\t}\n\n\tuint64_t f = 0;\n\tafc_file_open(afc, filename, AFC_FOPEN_RDONLY, &f);\n\tif (!f) {\n\t\treturn;\n\t}\n\tchar *buf = (char*)malloc((uint32_t)fsize);\n\tuint32_t done = 0;\n\twhile (done < fsize) {\n\t\tuint32_t bread = 0;\n\t\tafc_file_read(afc, f, buf+done, 65536, &bread);\n\t\tif (bread > 0) {\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t\tdone += bread;\n\t}\n\tif (done == fsize) {\n\t\t*size = fsize;\n\t\t*data = buf;\n\t} else {\n\t\tfree(buf);\n\t}\n\tafc_file_close(afc, f);\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <sys/statvfs.h>",
            "#include <termios.h>",
            "#include <conio.h>",
            "#include <windows.h>",
            "#include <endianness.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup2.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <libgen.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void mobilebackup_afc_get_file_contents(afc_client_t afc, const char *filename, char **data, uint64_t *size)\n{\n\tif (!afc || !data || !size) {\n\t\treturn;\n\t}\n\n\tchar **fileinfo = NULL;\n\tuint32_t fsize = 0;\n\n\tafc_get_file_info(afc, filename, &fileinfo);\n\tif (!fileinfo) {\n\t\treturn;\n\t}\n\tint i;\n\tfor (i = 0; fileinfo[i]; i+=2) {\n\t\tif (!strcmp(fileinfo[i], \"st_size\")) {\n\t\t\tfsize = atol(fileinfo[i+1]);\n\t\t\tbreak;\n\t\t}\n\t}\n\tafc_dictionary_free(fileinfo);\n\n\tif (fsize == 0) {\n\t\treturn;\n\t}\n\n\tuint64_t f = 0;\n\tafc_file_open(afc, filename, AFC_FOPEN_RDONLY, &f);\n\tif (!f) {\n\t\treturn;\n\t}\n\tchar *buf = (char*)malloc((uint32_t)fsize);\n\tuint32_t done = 0;\n\twhile (done < fsize) {\n\t\tuint32_t bread = 0;\n\t\tafc_file_read(afc, f, buf+done, 65536, &bread);\n\t\tif (bread > 0) {\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t\tdone += bread;\n\t}\n\tif (done == fsize) {\n\t\t*size = fsize;\n\t\t*data = buf;\n\t} else {\n\t\tfree(buf);\n\t}\n\tafc_file_close(afc, f);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "fname",
            "itunesfiles[i]"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fname",
            "\"/iTunes_Control/iTunes/\""
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(\"/iTunes_Control/iTunes/\") + strlen(itunesfiles[i]) + 1"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "itunesfiles[i]"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"/iTunes_Control/iTunes/\""
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_dict",
          "args": [],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "ret",
            "\"iBooks Data 2\"",
            "plist_new_data(data_buf, data_size)"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_data",
          "args": [
            "data_buf",
            "data_size"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "ret",
            "\"Unique Identifier\"",
            "plist_new_string(udid_uppercase)"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_string",
          "args": [
            "udid_uppercase"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "string_toupper",
          "args": [
            "(char*)udid"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "string_toupper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/utils.c",
          "lines": "164-172",
          "snippet": "char *string_toupper(char* str)\n{\n\tchar *res = strdup(str);\n\tunsigned int i;\n\tfor (i = 0; i < strlen(res); i++) {\n\t\tres[i] = toupper(res[i]);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include <ctype.h>",
            "#include <inttypes.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include <ctype.h>\n#include <inttypes.h>\n#include <sys/time.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <config.h>\n\nchar *string_toupper(char* str)\n{\n\tchar *res = strdup(str);\n\tunsigned int i;\n\tfor (i = 0; i < strlen(res); i++) {\n\t\tres[i] = toupper(res[i]);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "ret",
            "\"Target Type\"",
            "plist_new_string(\"Device\")"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_string",
          "args": [
            "\"Device\""
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "ret",
            "\"Target Identifier\"",
            "plist_new_string(udid)"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_string",
          "args": [
            "udid"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "root_node",
            "\"UniqueDeviceID\""
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "ret",
            "\"Serial Number\"",
            "plist_copy(value_node)"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_copy",
          "args": [
            "value_node"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "root_node",
            "\"SerialNumber\""
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "ret",
            "\"Product Version\"",
            "plist_copy(value_node)"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_copy",
          "args": [
            "value_node"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "root_node",
            "\"ProductVersion\""
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "ret",
            "\"Product Type\"",
            "plist_copy(value_node)"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_copy",
          "args": [
            "value_node"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "root_node",
            "\"ProductType\""
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "ret",
            "\"Phone Number\"",
            "plist_copy(value_node)"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_copy",
          "args": [
            "value_node"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_node_type",
          "args": [
            "value_node"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "root_node",
            "\"PhoneNumber\""
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "ret",
            "\"Last Backup Date\"",
            "plist_new_date(time(NULL), 0)"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_date",
          "args": [
            "time(NULL)",
            "0"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "ret",
            "\"IMEI\"",
            "plist_copy(value_node)"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_copy",
          "args": [
            "value_node"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "root_node",
            "\"InternationalMobileEquipmentIdentity\""
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "ret",
            "\"ICCID\"",
            "plist_copy(value_node)"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_copy",
          "args": [
            "value_node"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "root_node",
            "\"IntegratedCircuitCardIdentity\""
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "ret",
            "\"GUID\"",
            "plist_new_string(\"---\")"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_string",
          "args": [
            "\"---\""
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "ret",
            "\"Display Name\"",
            "plist_copy(value_node)"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_copy",
          "args": [
            "value_node"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "ret",
            "\"Device Name\"",
            "plist_copy(value_node)"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_copy",
          "args": [
            "value_node"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "root_node",
            "\"DeviceName\""
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_set_item",
          "args": [
            "ret",
            "\"Build Version\"",
            "plist_copy(value_node)"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_copy",
          "args": [
            "value_node"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "root_node",
            "\"BuildVersion\""
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_new_dict",
          "args": [],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic plist_t mobilebackup_factory_info_plist_new(const char* udid, lockdownd_client_t lockdown, afc_client_t afc)\n{\n\t/* gather data from lockdown */\n\tplist_t value_node = NULL;\n\tplist_t root_node = NULL;\n\tchar *udid_uppercase = NULL;\n\n\tplist_t ret = plist_new_dict();\n\n\t/* get basic device information in one go */\n\tlockdownd_get_value(lockdown, NULL, NULL, &root_node);\n\n\t/* set fields we understand */\n\tvalue_node = plist_dict_get_item(root_node, \"BuildVersion\");\n\tplist_dict_set_item(ret, \"Build Version\", plist_copy(value_node));\n\n\tvalue_node = plist_dict_get_item(root_node, \"DeviceName\");\n\tplist_dict_set_item(ret, \"Device Name\", plist_copy(value_node));\n\tplist_dict_set_item(ret, \"Display Name\", plist_copy(value_node));\n\n\t/* FIXME: How is the GUID generated? */\n\tplist_dict_set_item(ret, \"GUID\", plist_new_string(\"---\"));\n\n\tvalue_node = plist_dict_get_item(root_node, \"IntegratedCircuitCardIdentity\");\n\tif (value_node)\n\t\tplist_dict_set_item(ret, \"ICCID\", plist_copy(value_node));\n\n\tvalue_node = plist_dict_get_item(root_node, \"InternationalMobileEquipmentIdentity\");\n\tif (value_node)\n\t\tplist_dict_set_item(ret, \"IMEI\", plist_copy(value_node));\n\n\tplist_dict_set_item(ret, \"Last Backup Date\", plist_new_date(time(NULL), 0));\n\n\tvalue_node = plist_dict_get_item(root_node, \"PhoneNumber\");\n\tif (value_node && (plist_get_node_type(value_node) == PLIST_STRING)) {\n\t\tplist_dict_set_item(ret, \"Phone Number\", plist_copy(value_node));\n\t}\n\n\tvalue_node = plist_dict_get_item(root_node, \"ProductType\");\n\tplist_dict_set_item(ret, \"Product Type\", plist_copy(value_node));\n\n\tvalue_node = plist_dict_get_item(root_node, \"ProductVersion\");\n\tplist_dict_set_item(ret, \"Product Version\", plist_copy(value_node));\n\n\tvalue_node = plist_dict_get_item(root_node, \"SerialNumber\");\n\tplist_dict_set_item(ret, \"Serial Number\", plist_copy(value_node));\n\n\t/* FIXME Sync Settings? */\n\n\tvalue_node = plist_dict_get_item(root_node, \"UniqueDeviceID\");\n\tplist_dict_set_item(ret, \"Target Identifier\", plist_new_string(udid));\n\n\tplist_dict_set_item(ret, \"Target Type\", plist_new_string(\"Device\"));\n\n\t/* uppercase */\n\tudid_uppercase = string_toupper((char*)udid);\n\tplist_dict_set_item(ret, \"Unique Identifier\", plist_new_string(udid_uppercase));\n\tfree(udid_uppercase);\n\n\tchar *data_buf = NULL;\n\tuint64_t data_size = 0;\n\tmobilebackup_afc_get_file_contents(afc, \"/Books/iBooksData2.plist\", &data_buf, &data_size);\n\tif (data_buf) {\n\t\tplist_dict_set_item(ret, \"iBooks Data 2\", plist_new_data(data_buf, data_size));\n\t\tfree(data_buf);\n\t}\n\n\tplist_t files = plist_new_dict();\n\tconst char *itunesfiles[] = {\n\t\t\"ApertureAlbumPrefs\",\n\t\t\"IC-Info.sidb\",\n\t\t\"IC-Info.sidv\",\n\t\t\"PhotosFolderAlbums\",\n\t\t\"PhotosFolderName\",\n\t\t\"PhotosFolderPrefs\",\n\t\t\"iPhotoAlbumPrefs\",\n\t\t\"iTunesApplicationIDs\",\n\t\t\"iTunesPrefs\",\n\t\t\"iTunesPrefs.plist\",\n\t\tNULL\n\t};\n\tint i = 0;\n\tfor (i = 0; itunesfiles[i]; i++) {\n\t\tdata_buf = NULL;\n\t\tdata_size = 0;\n\t\tchar *fname = (char*)malloc(strlen(\"/iTunes_Control/iTunes/\") + strlen(itunesfiles[i]) + 1);\n\t\tstrcpy(fname, \"/iTunes_Control/iTunes/\");\n\t\tstrcat(fname, itunesfiles[i]);\n\t\tmobilebackup_afc_get_file_contents(afc, fname, &data_buf, &data_size);\n\t\tfree(fname);\n\t\tif (data_buf) {\n\t\t\tplist_dict_set_item(files, itunesfiles[i], plist_new_data(data_buf, data_size));\n\t\t\tfree(data_buf);\n\t\t}\n\t}\n\tplist_dict_set_item(ret, \"iTunes Files\", files);\n\n\tplist_t itunes_settings = NULL;\n\tlockdownd_get_value(lockdown, \"com.apple.iTunes\", NULL, &itunes_settings);\n\tplist_dict_set_item(ret, \"iTunes Settings\", itunes_settings ? itunes_settings : plist_new_dict());\n\n\tplist_dict_set_item(ret, \"iTunes Version\", plist_new_string(\"10.0.1\"));\n\n\tplist_free(root_node);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "mkdir_with_parents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
    "lines": "172-193",
    "snippet": "static int mkdir_with_parents(const char *dir, int mode)\n{\n\tif (!dir) return -1;\n\tif (__mkdir(dir, mode) == 0) {\n\t\treturn 0;\n\t} else {\n\t\tif (errno == EEXIST) return 0;\n\t}\n\tint res;\n\tchar *parent = strdup(dir);\n\tchar *parentdir = dirname(parent);\n\tif (parentdir) {\n\t\tres = mkdir_with_parents(parentdir, mode);\n\t} else {\n\t\tres = -1;\n\t}\n\tfree(parent);\n\tif (res == 0) {\n\t\tmkdir_with_parents(dir, mode);\n\t}\n\treturn res;\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <sys/statvfs.h>",
      "#include <termios.h>",
      "#include <conio.h>",
      "#include <windows.h>",
      "#include <endianness.h>",
      "#include \"common/utils.h\"",
      "#include <libimobiledevice/afc.h>",
      "#include <libimobiledevice/notification_proxy.h>",
      "#include <libimobiledevice/mobilebackup2.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <libgen.h>",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mkdir_with_parents",
          "args": [
            "dir",
            "mode"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir_with_parents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
          "lines": "172-193",
          "snippet": "static int mkdir_with_parents(const char *dir, int mode)\n{\n\tif (!dir) return -1;\n\tif (__mkdir(dir, mode) == 0) {\n\t\treturn 0;\n\t} else {\n\t\tif (errno == EEXIST) return 0;\n\t}\n\tint res;\n\tchar *parent = strdup(dir);\n\tchar *parentdir = dirname(parent);\n\tif (parentdir) {\n\t\tres = mkdir_with_parents(parentdir, mode);\n\t} else {\n\t\tres = -1;\n\t}\n\tfree(parent);\n\tif (res == 0) {\n\t\tmkdir_with_parents(dir, mode);\n\t}\n\treturn res;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "parent"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "thread_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "39-44",
          "snippet": "void thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nvoid thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "dirname",
          "args": [
            "parent"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "dir"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mkdir",
          "args": [
            "dir",
            "mode"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "__mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
          "lines": "163-170",
          "snippet": "static int __mkdir(const char* path, int mode)\n{\n#ifdef WIN32\n\treturn mkdir(path);\n#else\n\treturn mkdir(path, mode);\n#endif\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <sys/statvfs.h>",
            "#include <termios.h>",
            "#include <conio.h>",
            "#include <windows.h>",
            "#include <endianness.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup2.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <libgen.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int __mkdir(const char* path, int mode)\n{\n#ifdef WIN32\n\treturn mkdir(path);\n#else\n\treturn mkdir(path, mode);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int mkdir_with_parents(const char *dir, int mode)\n{\n\tif (!dir) return -1;\n\tif (__mkdir(dir, mode) == 0) {\n\t\treturn 0;\n\t} else {\n\t\tif (errno == EEXIST) return 0;\n\t}\n\tint res;\n\tchar *parent = strdup(dir);\n\tchar *parentdir = dirname(parent);\n\tif (parentdir) {\n\t\tres = mkdir_with_parents(parentdir, mode);\n\t} else {\n\t\tres = -1;\n\t}\n\tfree(parent);\n\tif (res == 0) {\n\t\tmkdir_with_parents(dir, mode);\n\t}\n\treturn res;\n}"
  },
  {
    "function_name": "__mkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
    "lines": "163-170",
    "snippet": "static int __mkdir(const char* path, int mode)\n{\n#ifdef WIN32\n\treturn mkdir(path);\n#else\n\treturn mkdir(path, mode);\n#endif\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <sys/statvfs.h>",
      "#include <termios.h>",
      "#include <conio.h>",
      "#include <windows.h>",
      "#include <endianness.h>",
      "#include \"common/utils.h\"",
      "#include <libimobiledevice/afc.h>",
      "#include <libimobiledevice/notification_proxy.h>",
      "#include <libimobiledevice/mobilebackup2.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <libgen.h>",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "path",
            "mode"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "mkdir_with_parents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
          "lines": "172-193",
          "snippet": "static int mkdir_with_parents(const char *dir, int mode)\n{\n\tif (!dir) return -1;\n\tif (__mkdir(dir, mode) == 0) {\n\t\treturn 0;\n\t} else {\n\t\tif (errno == EEXIST) return 0;\n\t}\n\tint res;\n\tchar *parent = strdup(dir);\n\tchar *parentdir = dirname(parent);\n\tif (parentdir) {\n\t\tres = mkdir_with_parents(parentdir, mode);\n\t} else {\n\t\tres = -1;\n\t}\n\tfree(parent);\n\tif (res == 0) {\n\t\tmkdir_with_parents(dir, mode);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <sys/statvfs.h>",
            "#include <termios.h>",
            "#include <conio.h>",
            "#include <windows.h>",
            "#include <endianness.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup2.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <libgen.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int mkdir_with_parents(const char *dir, int mode)\n{\n\tif (!dir) return -1;\n\tif (__mkdir(dir, mode) == 0) {\n\t\treturn 0;\n\t} else {\n\t\tif (errno == EEXIST) return 0;\n\t}\n\tint res;\n\tchar *parent = strdup(dir);\n\tchar *parentdir = dirname(parent);\n\tif (parentdir) {\n\t\tres = mkdir_with_parents(parentdir, mode);\n\t} else {\n\t\tres = -1;\n\t}\n\tfree(parent);\n\tif (res == 0) {\n\t\tmkdir_with_parents(dir, mode);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "path"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int __mkdir(const char* path, int mode)\n{\n#ifdef WIN32\n\treturn mkdir(path);\n#else\n\treturn mkdir(path, mode);\n#endif\n}"
  },
  {
    "function_name": "mobilebackup_afc_get_file_contents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
    "lines": "112-161",
    "snippet": "static void mobilebackup_afc_get_file_contents(afc_client_t afc, const char *filename, char **data, uint64_t *size)\n{\n\tif (!afc || !data || !size) {\n\t\treturn;\n\t}\n\n\tchar **fileinfo = NULL;\n\tuint32_t fsize = 0;\n\n\tafc_get_file_info(afc, filename, &fileinfo);\n\tif (!fileinfo) {\n\t\treturn;\n\t}\n\tint i;\n\tfor (i = 0; fileinfo[i]; i+=2) {\n\t\tif (!strcmp(fileinfo[i], \"st_size\")) {\n\t\t\tfsize = atol(fileinfo[i+1]);\n\t\t\tbreak;\n\t\t}\n\t}\n\tafc_dictionary_free(fileinfo);\n\n\tif (fsize == 0) {\n\t\treturn;\n\t}\n\n\tuint64_t f = 0;\n\tafc_file_open(afc, filename, AFC_FOPEN_RDONLY, &f);\n\tif (!f) {\n\t\treturn;\n\t}\n\tchar *buf = (char*)malloc((uint32_t)fsize);\n\tuint32_t done = 0;\n\twhile (done < fsize) {\n\t\tuint32_t bread = 0;\n\t\tafc_file_read(afc, f, buf+done, 65536, &bread);\n\t\tif (bread > 0) {\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t\tdone += bread;\n\t}\n\tif (done == fsize) {\n\t\t*size = fsize;\n\t\t*data = buf;\n\t} else {\n\t\tfree(buf);\n\t}\n\tafc_file_close(afc, f);\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <sys/statvfs.h>",
      "#include <termios.h>",
      "#include <conio.h>",
      "#include <windows.h>",
      "#include <endianness.h>",
      "#include \"common/utils.h\"",
      "#include <libimobiledevice/afc.h>",
      "#include <libimobiledevice/notification_proxy.h>",
      "#include <libimobiledevice/mobilebackup2.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <libgen.h>",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "afc_file_close",
          "args": [
            "afc",
            "f"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "afc_file_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "749-775",
          "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_file_close(afc_client_t client, uint64_t handle)\n{\n\tuint32_t bytes = 0;\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tif (!client || (handle == 0))\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_lock(client);\n\n\tdebug_info(\"File handle %i\", handle);\n\n\t/* Send command */\n\tret = afc_dispatch_packet(client, AFC_OP_FILE_CLOSE, (const char*)&handle, 8, NULL, 0, &bytes);\n\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_UNKNOWN_ERROR;\n\t}\n\n\t/* Receive the response */\n\tret = afc_receive_data(client, NULL, &bytes);\n\n\tafc_unlock(client);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_file_close(afc_client_t client, uint64_t handle)\n{\n\tuint32_t bytes = 0;\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tif (!client || (handle == 0))\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_lock(client);\n\n\tdebug_info(\"File handle %i\", handle);\n\n\t/* Send command */\n\tret = afc_dispatch_packet(client, AFC_OP_FILE_CLOSE, (const char*)&handle, 8, NULL, 0, &bytes);\n\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_UNKNOWN_ERROR;\n\t}\n\n\t/* Receive the response */\n\tret = afc_receive_data(client, NULL, &bytes);\n\n\tafc_unlock(client);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "buf"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "thread_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "39-44",
          "snippet": "void thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nvoid thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "afc_file_read",
          "args": [
            "afc",
            "f",
            "buf+done",
            "65536",
            "&bread"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "afc_file_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "664-715",
          "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_file_read(afc_client_t client, uint64_t handle, char *data, uint32_t length, uint32_t *bytes_read)\n{\n\tchar *input = NULL;\n\tuint32_t current_count = 0, bytes_loc = 0;\n\tafc_error_t ret = AFC_E_SUCCESS;\n\n\tif (!client || !client->afc_packet || !client->parent || handle == 0)\n\t\treturn AFC_E_INVALID_ARG;\n\tdebug_info(\"called for length %i\", length);\n\n\tafc_lock(client);\n\n\t/* Send the read command */\n\tstruct {\n\t\tuint64_t handle;\n\t\tuint64_t size;\n\t} readinfo;\n\treadinfo.handle = handle;\n\treadinfo.size = htole64(length);\n\tret = afc_dispatch_packet(client, AFC_OP_FILE_READ, (const char*)&readinfo, sizeof(readinfo), NULL, 0, &bytes_loc);\n\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\t/* Receive the data */\n\tret = afc_receive_data(client, &input, &bytes_loc);\n\tdebug_info(\"afc_receive_data returned error: %d\", ret);\n\tdebug_info(\"bytes returned: %i\", bytes_loc);\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn ret;\n\t} else if (bytes_loc == 0) {\n\t\tif (input)\n\t\t\tfree(input);\n\t\tafc_unlock(client);\n\t\t*bytes_read = current_count;\n\t\t/* FIXME: check that's actually a success */\n\t\treturn ret;\n\t} else {\n\t\tif (input) {\n\t\t\tdebug_info(\"%d\", bytes_loc);\n\t\t\tmemcpy(data + current_count, input, (bytes_loc > length) ? length : bytes_loc);\n\t\t\tfree(input);\n\t\t\tinput = NULL;\n\t\t\tcurrent_count += (bytes_loc > length) ? length : bytes_loc;\n\t\t}\n\t}\n\tafc_unlock(client);\n\t*bytes_read = current_count;\n\treturn ret;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_file_read(afc_client_t client, uint64_t handle, char *data, uint32_t length, uint32_t *bytes_read)\n{\n\tchar *input = NULL;\n\tuint32_t current_count = 0, bytes_loc = 0;\n\tafc_error_t ret = AFC_E_SUCCESS;\n\n\tif (!client || !client->afc_packet || !client->parent || handle == 0)\n\t\treturn AFC_E_INVALID_ARG;\n\tdebug_info(\"called for length %i\", length);\n\n\tafc_lock(client);\n\n\t/* Send the read command */\n\tstruct {\n\t\tuint64_t handle;\n\t\tuint64_t size;\n\t} readinfo;\n\treadinfo.handle = handle;\n\treadinfo.size = htole64(length);\n\tret = afc_dispatch_packet(client, AFC_OP_FILE_READ, (const char*)&readinfo, sizeof(readinfo), NULL, 0, &bytes_loc);\n\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\t/* Receive the data */\n\tret = afc_receive_data(client, &input, &bytes_loc);\n\tdebug_info(\"afc_receive_data returned error: %d\", ret);\n\tdebug_info(\"bytes returned: %i\", bytes_loc);\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn ret;\n\t} else if (bytes_loc == 0) {\n\t\tif (input)\n\t\t\tfree(input);\n\t\tafc_unlock(client);\n\t\t*bytes_read = current_count;\n\t\t/* FIXME: check that's actually a success */\n\t\treturn ret;\n\t} else {\n\t\tif (input) {\n\t\t\tdebug_info(\"%d\", bytes_loc);\n\t\t\tmemcpy(data + current_count, input, (bytes_loc > length) ? length : bytes_loc);\n\t\t\tfree(input);\n\t\t\tinput = NULL;\n\t\t\tcurrent_count += (bytes_loc > length) ? length : bytes_loc;\n\t\t}\n\t}\n\tafc_unlock(client);\n\t*bytes_read = current_count;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "(uint32_t)fsize"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afc_file_open",
          "args": [
            "afc",
            "filename",
            "AFC_FOPEN_RDONLY",
            "&f"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "afc_file_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "616-662",
          "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_file_open(afc_client_t client, const char *filename, afc_file_mode_t file_mode, uint64_t *handle)\n{\n\tif (!client || !client->parent || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tuint64_t file_mode_loc = htole64(file_mode);\n\tuint32_t bytes = 0;\n\tchar *data = (char *) malloc(sizeof(char) * (8 + strlen(filename) + 1));\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\t/* set handle to 0 so in case an error occurs, the handle is invalid */\n\t*handle = 0;\n\n\tafc_lock(client);\n\n\t/* Send command */\n\tmemcpy(data, &file_mode_loc, 8);\n\tmemcpy(data + 8, filename, strlen(filename));\n\tdata[8 + strlen(filename)] = '\\0';\n\tret = afc_dispatch_packet(client, AFC_OP_FILE_OPEN, data, 8 + strlen(filename) + 1, NULL, 0, &bytes);\n\tfree(data);\n\n\tif (ret != AFC_E_SUCCESS) {\n\t\tdebug_info(\"Didn't receive a response to the command\");\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\t/* Receive the data */\n\tdata = NULL;\n\tret = afc_receive_data(client, &data, &bytes);\n\tif ((ret == AFC_E_SUCCESS) && (bytes > 0) && data) {\n\t\tafc_unlock(client);\n\n\t\t/* Get the file handle */\n\t\tmemcpy(handle, data, sizeof(uint64_t));\n\t\tfree(data);\n\t\treturn ret;\n\t}\n\t/* in case memory was allocated but no data received or an error occurred */\n\tfree(data);\n\n\tdebug_info(\"Didn't get any further data\");\n\n\tafc_unlock(client);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_file_open(afc_client_t client, const char *filename, afc_file_mode_t file_mode, uint64_t *handle)\n{\n\tif (!client || !client->parent || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tuint64_t file_mode_loc = htole64(file_mode);\n\tuint32_t bytes = 0;\n\tchar *data = (char *) malloc(sizeof(char) * (8 + strlen(filename) + 1));\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\t/* set handle to 0 so in case an error occurs, the handle is invalid */\n\t*handle = 0;\n\n\tafc_lock(client);\n\n\t/* Send command */\n\tmemcpy(data, &file_mode_loc, 8);\n\tmemcpy(data + 8, filename, strlen(filename));\n\tdata[8 + strlen(filename)] = '\\0';\n\tret = afc_dispatch_packet(client, AFC_OP_FILE_OPEN, data, 8 + strlen(filename) + 1, NULL, 0, &bytes);\n\tfree(data);\n\n\tif (ret != AFC_E_SUCCESS) {\n\t\tdebug_info(\"Didn't receive a response to the command\");\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\t/* Receive the data */\n\tdata = NULL;\n\tret = afc_receive_data(client, &data, &bytes);\n\tif ((ret == AFC_E_SUCCESS) && (bytes > 0) && data) {\n\t\tafc_unlock(client);\n\n\t\t/* Get the file handle */\n\t\tmemcpy(handle, data, sizeof(uint64_t));\n\t\tfree(data);\n\t\treturn ret;\n\t}\n\t/* in case memory was allocated but no data received or an error occurred */\n\tfree(data);\n\n\tdebug_info(\"Didn't get any further data\");\n\n\tafc_unlock(client);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afc_dictionary_free",
          "args": [
            "fileinfo"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "afc_dictionary_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "1025-1038",
          "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_dictionary_free(char **dictionary)\n{\n\tint i = 0;\n\n\tif (!dictionary)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tfor (i = 0; dictionary[i]; i++) {\n\t\tfree(dictionary[i]);\n\t}\n\tfree(dictionary);\n\n\treturn AFC_E_SUCCESS;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_dictionary_free(char **dictionary)\n{\n\tint i = 0;\n\n\tif (!dictionary)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tfor (i = 0; dictionary[i]; i++) {\n\t\tfree(dictionary[i]);\n\t}\n\tfree(dictionary);\n\n\treturn AFC_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atol",
          "args": [
            "fileinfo[i+1]"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "fileinfo[i]",
            "\"st_size\""
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "plist_strcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
          "lines": "296-309",
          "snippet": "static int plist_strcmp(plist_t node, const char *str)\n{\n\tchar *buffer = NULL;\n\tint ret = 0;\n\n\tif (plist_get_node_type(node) != PLIST_STRING)\n\t\treturn ret;\n\n\tplist_get_string_val(node, &buffer);\n\tret = strcmp(buffer, str);\n\tfree(buffer);\n\n\treturn ret;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <unistd.h>",
            "#include <gcrypt.h>",
            "#include <openssl/sha.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int plist_strcmp(plist_t node, const char *str)\n{\n\tchar *buffer = NULL;\n\tint ret = 0;\n\n\tif (plist_get_node_type(node) != PLIST_STRING)\n\t\treturn ret;\n\n\tplist_get_string_val(node, &buffer);\n\tret = strcmp(buffer, str);\n\tfree(buffer);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afc_get_file_info",
          "args": [
            "afc",
            "filename",
            "&fileinfo"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "afc_get_file_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "586-614",
          "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_get_file_info(afc_client_t client, const char *path, char ***file_information)\n{\n\tchar *received = NULL;\n\tuint32_t bytes = 0;\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tif (!client || !path || !file_information)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_lock(client);\n\n\t/* Send command */\n\tret = afc_dispatch_packet(client, AFC_OP_GET_FILE_INFO, path, strlen(path)+1, NULL, 0, &bytes);\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\n\t/* Receive data */\n\tret = afc_receive_data(client, &received, &bytes);\n\tif (received) {\n\t\t*file_information = make_strings_list(received, bytes);\n\t\tfree(received);\n\t}\n\n\tafc_unlock(client);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_get_file_info(afc_client_t client, const char *path, char ***file_information)\n{\n\tchar *received = NULL;\n\tuint32_t bytes = 0;\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tif (!client || !path || !file_information)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_lock(client);\n\n\t/* Send command */\n\tret = afc_dispatch_packet(client, AFC_OP_GET_FILE_INFO, path, strlen(path)+1, NULL, 0, &bytes);\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\n\t/* Receive data */\n\tret = afc_receive_data(client, &received, &bytes);\n\tif (received) {\n\t\t*file_information = make_strings_list(received, bytes);\n\t\tfree(received);\n\t}\n\n\tafc_unlock(client);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void mobilebackup_afc_get_file_contents(afc_client_t afc, const char *filename, char **data, uint64_t *size)\n{\n\tif (!afc || !data || !size) {\n\t\treturn;\n\t}\n\n\tchar **fileinfo = NULL;\n\tuint32_t fsize = 0;\n\n\tafc_get_file_info(afc, filename, &fileinfo);\n\tif (!fileinfo) {\n\t\treturn;\n\t}\n\tint i;\n\tfor (i = 0; fileinfo[i]; i+=2) {\n\t\tif (!strcmp(fileinfo[i], \"st_size\")) {\n\t\t\tfsize = atol(fileinfo[i+1]);\n\t\t\tbreak;\n\t\t}\n\t}\n\tafc_dictionary_free(fileinfo);\n\n\tif (fsize == 0) {\n\t\treturn;\n\t}\n\n\tuint64_t f = 0;\n\tafc_file_open(afc, filename, AFC_FOPEN_RDONLY, &f);\n\tif (!f) {\n\t\treturn;\n\t}\n\tchar *buf = (char*)malloc((uint32_t)fsize);\n\tuint32_t done = 0;\n\twhile (done < fsize) {\n\t\tuint32_t bread = 0;\n\t\tafc_file_read(afc, f, buf+done, 65536, &bread);\n\t\tif (bread > 0) {\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t\tdone += bread;\n\t}\n\tif (done == fsize) {\n\t\t*size = fsize;\n\t\t*data = buf;\n\t} else {\n\t\tfree(buf);\n\t}\n\tafc_file_close(afc, f);\n}"
  },
  {
    "function_name": "notify_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
    "lines": "97-110",
    "snippet": "static void notify_cb(const char *notification, void *userdata)\n{\n\tif (strlen(notification) == 0) {\n\t\treturn;\n\t}\n\tif (!strcmp(notification, NP_SYNC_CANCEL_REQUEST)) {\n\t\tPRINT_VERBOSE(1, \"User has cancelled the backup process on the device.\\n\");\n\t\tquit_flag++;\n\t} else if (!strcmp(notification, NP_BACKUP_DOMAIN_CHANGED)) {\n\t\tbackup_domain_changed = 1;\n\t} else {\n\t\tPRINT_VERBOSE(1, \"Unhandled notification '%s' (TODO: implement)\\n\", notification);\n\t}\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <sys/statvfs.h>",
      "#include <termios.h>",
      "#include <conio.h>",
      "#include <windows.h>",
      "#include <endianness.h>",
      "#include \"common/utils.h\"",
      "#include <libimobiledevice/afc.h>",
      "#include <libimobiledevice/notification_proxy.h>",
      "#include <libimobiledevice/mobilebackup2.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <time.h>",
      "#include <ctype.h>",
      "#include <libgen.h>",
      "#include <dirent.h>",
      "#include <unistd.h>",
      "#include <signal.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int quit_flag = 0;",
      "static int backup_domain_changed = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"Unhandled notification '%s' (TODO: implement)\\n\"",
            "notification"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "notification",
            "NP_BACKUP_DOMAIN_CHANGED"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "plist_strcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
          "lines": "296-309",
          "snippet": "static int plist_strcmp(plist_t node, const char *str)\n{\n\tchar *buffer = NULL;\n\tint ret = 0;\n\n\tif (plist_get_node_type(node) != PLIST_STRING)\n\t\treturn ret;\n\n\tplist_get_string_val(node, &buffer);\n\tret = strcmp(buffer, str);\n\tfree(buffer);\n\n\treturn ret;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <unistd.h>",
            "#include <gcrypt.h>",
            "#include <openssl/sha.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int plist_strcmp(plist_t node, const char *str)\n{\n\tchar *buffer = NULL;\n\tint ret = 0;\n\n\tif (plist_get_node_type(node) != PLIST_STRING)\n\t\treturn ret;\n\n\tplist_get_string_val(node, &buffer);\n\tret = strcmp(buffer, str);\n\tfree(buffer);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINT_VERBOSE",
          "args": [
            "1",
            "\"User has cancelled the backup process on the device.\\n\""
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "notification"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int quit_flag = 0;\nstatic int backup_domain_changed = 0;\n\nstatic void notify_cb(const char *notification, void *userdata)\n{\n\tif (strlen(notification) == 0) {\n\t\treturn;\n\t}\n\tif (!strcmp(notification, NP_SYNC_CANCEL_REQUEST)) {\n\t\tPRINT_VERBOSE(1, \"User has cancelled the backup process on the device.\\n\");\n\t\tquit_flag++;\n\t} else if (!strcmp(notification, NP_BACKUP_DOMAIN_CHANGED)) {\n\t\tbackup_domain_changed = 1;\n\t} else {\n\t\tPRINT_VERBOSE(1, \"Unhandled notification '%s' (TODO: implement)\\n\", notification);\n\t}\n}"
  }
]