[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicedebugserverproxy.c",
    "lines": "240-388",
    "snippet": "int main(int argc, char *argv[])\n{\n\tidevice_error_t ret = IDEVICE_E_UNKNOWN_ERROR;\n\tidevice_t device = NULL;\n\tthread_info_t *thread_list = NULL;\n\tconst char* udid = NULL;\n\tuint16_t local_port = 0;\n\tint server_fd;\n\tint result = EXIT_SUCCESS;\n\tint i;\n\n#ifndef WIN32\n\tstruct sigaction sa;\n\tstruct sigaction si;\n\tmemset(&sa, '\\0', sizeof(struct sigaction));\n\tmemset(&si, '\\0', sizeof(struct sigaction));\n\n\tsa.sa_handler = clean_exit;\n\tsigemptyset(&sa.sa_mask);\n\n\tsi.sa_handler = SIG_IGN;\n\tsigemptyset(&si.sa_mask);\n\n\tsigaction(SIGINT, &sa, NULL);\n\tsigaction(SIGTERM, &sa, NULL);\n\tsigaction(SIGQUIT, &sa, NULL);\n\tsigaction(SIGPIPE, &si, NULL);\n#else\n\t/* bind signals */\n\tsignal(SIGINT, clean_exit);\n\tsignal(SIGTERM, clean_exit);\n#endif\n\n\t/* parse cmdline arguments */\n\tfor (i = 1; i < argc; i++) {\n\t\tif (!strcmp(argv[i], \"-d\") || !strcmp(argv[i], \"--debug\")) {\n\t\t\tdebug_mode = 1;\n\t\t\tidevice_set_debug_level(1);\n\t\t\tsocket_set_verbose(3);\n\t\t\tcontinue;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"-u\") || !strcmp(argv[i], \"--udid\")) {\n\t\t\ti++;\n\t\t\tif (!argv[i] || (strlen(argv[i]) != 40)) {\n\t\t\t\tprint_usage(argc, argv);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tudid = argv[i];\n\t\t\tcontinue;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"-h\") || !strcmp(argv[i], \"--help\")) {\n\t\t\tprint_usage(argc, argv);\n\t\t\treturn EXIT_SUCCESS;\n\t\t}\n\t\telse if (atoi(argv[i]) > 0) {\n\t\t\tlocal_port = atoi(argv[i]);\n\t\t\tcontinue;\n\t\t}\n\t\telse {\n\t\t\tprint_usage(argc, argv);\n\t\t\treturn EXIT_SUCCESS;\n\t\t}\n\t}\n\n\t/* a PORT is mandatory */\n\tif (!local_port) {\n\t\tfprintf(stderr, \"Please specify a PORT.\\n\");\n\t\tprint_usage(argc, argv);\n\t\tgoto leave_cleanup;\n\t}\n\n\t/* start services and connect to device */\n\tret = idevice_new(&device, udid);\n\tif (ret != IDEVICE_E_SUCCESS) {\n\t\tif (udid) {\n\t\t\tfprintf(stderr, \"No device found with udid %s, is it plugged in?\\n\", udid);\n\t\t} else {\n\t\t\tfprintf(stderr, \"No device found, is it plugged in?\\n\");\n\t\t}\n\t\tresult = EXIT_FAILURE;\n\t\tgoto leave_cleanup;\n\t}\n\n\t/* create local socket */\n\tserver_fd = socket_create(local_port);\n\tif (server_fd < 0) {\n\t\tfprintf(stderr, \"Could not create socket\\n\");\n\t\tresult = EXIT_FAILURE;\n\t\tgoto leave_cleanup;\n\t}\n\n\twhile (!quit_flag) {\n\t\tdebug(\"%s: Waiting for connection on local port %d\\n\", __func__, local_port);\n\n\t\t/* wait for client */\n\t\tint client_fd = socket_accept(server_fd, local_port);\n\t\tif (client_fd < 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdebug(\"%s: Handling new client connection...\\n\", __func__);\n\n\t\tthread_info_t *el = (thread_info_t*)malloc(sizeof(thread_info_t));\n\t\tif (!el) {\n\t\t\tfprintf(stderr, \"Out of memory\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tel->next = NULL;\n\n\t\tif (thread_list) {\n\t\t\tthread_list->next = el;\n\t\t} else {\n\t\t\tthread_list = el;\n\t\t}\n\n\t\tsocket_info_t *sinfo = (socket_info_t*)malloc(sizeof(socket_info_t));\n\t\tif (!sinfo) {\n\t\t\tfprintf(stderr, \"Out of memory\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tsinfo->client_fd = client_fd;\n\t\tsinfo->device = device;\n\n\t\tif (thread_new(&(el->th), connection_handler, (void*)sinfo) != 0) {\n\t\t\tfprintf(stderr, \"Could not start connection handler.\\n\");\n\t\t\tsocket_shutdown(server_fd, SHUT_RDWR);\n\t\t\tsocket_close(server_fd);\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tdebug(\"%s: Shutting down debugserver proxy...\\n\", __func__);\n\n\t/* join and clean up threads */\n\twhile (thread_list) {\n\t\tthread_info_t *el = thread_list;\n\t\tthread_join(el->th);\n\t\tthread_free(el->th);\n\t\tthread_list = el->next;\n\t\tfree(el);\n\t}\n\nleave_cleanup:\n\tif (device) {\n\t\tidevice_free(device);\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include \"common/thread.h\"",
      "#include \"common/socket.h\"",
      "#include <libimobiledevice/debugserver.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <signal.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int debug_mode = 0;",
      "static int quit_flag = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "idevice_free",
          "args": [
            "device"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "idevice_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
          "lines": "247-265",
          "snippet": "LIBIMOBILEDEVICE_API idevice_error_t idevice_free(idevice_t device)\n{\n\tif (!device)\n\t\treturn IDEVICE_E_INVALID_ARG;\n\tidevice_error_t ret = IDEVICE_E_UNKNOWN_ERROR;\n\n\tret = IDEVICE_E_SUCCESS;\n\n\tfree(device->udid);\n\n\tif (device->conn_type == CONNECTION_USBMUXD) {\n\t\tdevice->conn_data = 0;\n\t}\n\tif (device->conn_data) {\n\t\tfree(device->conn_data);\n\t}\n\tfree(device);\n\treturn ret;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"common/thread.h\"",
            "#include \"common/userpref.h\"",
            "#include \"idevice.h\"",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <usbmuxd.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "LIBIMOBILEDEVICE_API idevice_error_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nLIBIMOBILEDEVICE_API idevice_error_t idevice_free(idevice_t device)\n{\n\tif (!device)\n\t\treturn IDEVICE_E_INVALID_ARG;\n\tidevice_error_t ret = IDEVICE_E_UNKNOWN_ERROR;\n\n\tret = IDEVICE_E_SUCCESS;\n\n\tfree(device->udid);\n\n\tif (device->conn_type == CONNECTION_USBMUXD) {\n\t\tdevice->conn_data = 0;\n\t}\n\tif (device->conn_data) {\n\t\tfree(device->conn_data);\n\t}\n\tfree(device);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "el"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "thread_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "39-44",
          "snippet": "void thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nvoid thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "thread_join",
          "args": [
            "el->th"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "thread_join",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "46-54",
          "snippet": "void thread_join(thread_t thread)\n{\n\t/* wait for thread to complete */\n#ifdef WIN32\n\tWaitForSingleObject(thread, INFINITE);\n#else\n\tpthread_join(thread, NULL);\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nvoid thread_join(thread_t thread)\n{\n\t/* wait for thread to complete */\n#ifdef WIN32\n\tWaitForSingleObject(thread, INFINITE);\n#else\n\tpthread_join(thread, NULL);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s: Shutting down debugserver proxy...\\n\"",
            "__func__"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "debug_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/debug.c",
          "lines": "101-134",
          "snippet": "void debug_buffer(const char *data, const int length)\n{\n#ifndef STRIP_DEBUG_CODE\n\tint i;\n\tint j;\n\tunsigned char c;\n\n\tif (debug_level) {\n\t\tfor (i = 0; i < length; i += 16) {\n\t\t\tfprintf(stderr, \"%04x: \", i);\n\t\t\tfor (j = 0; j < 16; j++) {\n\t\t\t\tif (i + j >= length) {\n\t\t\t\t\tfprintf(stderr, \"   \");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"%02x \", *(data + i + j) & 0xff);\n\t\t\t}\n\t\t\tfprintf(stderr, \"  | \");\n\t\t\tfor (j = 0; j < 16; j++) {\n\t\t\t\tif (i + j >= length)\n\t\t\t\t\tbreak;\n\t\t\t\tc = *(data + i + j);\n\t\t\t\tif ((c < 32) || (c > 127)) {\n\t\t\t\t\tfprintf(stderr, \".\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"%c\", c);\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t}\n\t\tfprintf(stderr, \"\\n\");\n\t}\n#endif\n}",
          "includes": [
            "#include \"asprintf.h\"",
            "#include \"src/idevice.h\"",
            "#include \"libimobiledevice/libimobiledevice.h\"",
            "#include \"debug.h\"",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int debug_level;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"asprintf.h\"\n#include \"src/idevice.h\"\n#include \"libimobiledevice/libimobiledevice.h\"\n#include \"debug.h\"\n#include <time.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int debug_level;\n\nvoid debug_buffer(const char *data, const int length)\n{\n#ifndef STRIP_DEBUG_CODE\n\tint i;\n\tint j;\n\tunsigned char c;\n\n\tif (debug_level) {\n\t\tfor (i = 0; i < length; i += 16) {\n\t\t\tfprintf(stderr, \"%04x: \", i);\n\t\t\tfor (j = 0; j < 16; j++) {\n\t\t\t\tif (i + j >= length) {\n\t\t\t\t\tfprintf(stderr, \"   \");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"%02x \", *(data + i + j) & 0xff);\n\t\t\t}\n\t\t\tfprintf(stderr, \"  | \");\n\t\t\tfor (j = 0; j < 16; j++) {\n\t\t\t\tif (i + j >= length)\n\t\t\t\t\tbreak;\n\t\t\t\tc = *(data + i + j);\n\t\t\t\tif ((c < 32) || (c > 127)) {\n\t\t\t\t\tfprintf(stderr, \".\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"%c\", c);\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t}\n\t\tfprintf(stderr, \"\\n\");\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "socket_close",
          "args": [
            "server_fd"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "socket_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/socket.c",
          "lines": "346-352",
          "snippet": "int socket_close(int fd) {\n#ifdef WIN32\n\treturn closesocket(fd);\n#else\n\treturn close(fd);\n#endif\n}",
          "includes": [
            "#include \"socket.h\"",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <windows.h>",
            "#include <winsock2.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"socket.h\"\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <windows.h>\n#include <winsock2.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdio.h>\n\nint socket_close(int fd) {\n#ifdef WIN32\n\treturn closesocket(fd);\n#else\n\treturn close(fd);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "socket_shutdown",
          "args": [
            "server_fd",
            "SHUT_RDWR"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "socket_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/socket.c",
          "lines": "341-344",
          "snippet": "int socket_shutdown(int fd, int how)\n{\n\treturn shutdown(fd, how);\n}",
          "includes": [
            "#include \"socket.h\"",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <windows.h>",
            "#include <winsock2.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"socket.h\"\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <windows.h>\n#include <winsock2.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdio.h>\n\nint socket_shutdown(int fd, int how)\n{\n\treturn shutdown(fd, how);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Could not start connection handler.\\n\""
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread_new",
          "args": [
            "&(el->th)",
            "connection_handler",
            "(void*)sinfo"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "thread_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "24-37",
          "snippet": "int thread_new(thread_t *thread, thread_func_t thread_func, void* data)\n{\n#ifdef WIN32\n\tHANDLE th = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)thread_func, data, 0, NULL);\n\tif (th == NULL) {\n\t\treturn -1;\n\t}\n\t*thread = th;\n\treturn 0;\n#else\n\tint res = pthread_create(thread, NULL, thread_func, data);\n\treturn res;\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nint thread_new(thread_t *thread, thread_func_t thread_func, void* data)\n{\n#ifdef WIN32\n\tHANDLE th = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)thread_func, data, 0, NULL);\n\tif (th == NULL) {\n\t\treturn -1;\n\t}\n\t*thread = th;\n\treturn 0;\n#else\n\tint res = pthread_create(thread, NULL, thread_func, data);\n\treturn res;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "clean_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicedebugserverproxy.c",
          "lines": "60-64",
          "snippet": "static void clean_exit(int sig)\n{\n\tfprintf(stderr, \"Exiting...\\n\");\n\tquit_flag++;\n}",
          "includes": [
            "#include \"common/thread.h\"",
            "#include \"common/socket.h\"",
            "#include <libimobiledevice/debugserver.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int quit_flag = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common/thread.h\"\n#include \"common/socket.h\"\n#include <libimobiledevice/debugserver.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <signal.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int quit_flag = 0;\n\nstatic void clean_exit(int sig)\n{\n\tfprintf(stderr, \"Exiting...\\n\");\n\tquit_flag++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Out of memory\\n\""
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(socket_info_t)"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Out of memory\\n\""
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(thread_info_t)"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket_accept",
          "args": [
            "server_fd",
            "local_port"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "socket_accept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/socket.c",
          "lines": "320-339",
          "snippet": "int socket_accept(int fd, uint16_t port)\n{\n#ifdef WIN32\n\tint addr_len;\n#else\n\tsocklen_t addr_len;\n#endif\n\tint result;\n\tstruct sockaddr_in addr;\n\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.sin_family = AF_INET;\n\taddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\taddr.sin_port = htons(port);\n\n\taddr_len = sizeof(addr);\n\tresult = accept(fd, (struct sockaddr*)&addr, &addr_len);\n\n\treturn result;\n}",
          "includes": [
            "#include \"socket.h\"",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <windows.h>",
            "#include <winsock2.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"socket.h\"\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <windows.h>\n#include <winsock2.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdio.h>\n\nint socket_accept(int fd, uint16_t port)\n{\n#ifdef WIN32\n\tint addr_len;\n#else\n\tsocklen_t addr_len;\n#endif\n\tint result;\n\tstruct sockaddr_in addr;\n\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.sin_family = AF_INET;\n\taddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\taddr.sin_port = htons(port);\n\n\taddr_len = sizeof(addr);\n\tresult = accept(fd, (struct sockaddr*)&addr, &addr_len);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s: Waiting for connection on local port %d\\n\"",
            "__func__",
            "local_port"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "debugserver_client_handle_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicedebug.c",
          "lines": "105-178",
          "snippet": "static debugserver_error_t debugserver_client_handle_response(debugserver_client_t client, char** response, int send_reply)\n{\n\tdebugserver_error_t dres = DEBUGSERVER_E_SUCCESS;\n\tdebugserver_command_t command = NULL;\n\tchar* o = NULL;\n\tchar* r = *response;\n\n\tif (r[0] == 'O') {\n\t\t/* stdout/stderr */\n\t\tdebugserver_decode_string(r + 1, strlen(r) - 1, &o);\n\t\tprintf(\"%s\", o);\n\t\tfflush(stdout);\n\t\tif (o != NULL) {\n\t\t\tfree(o);\n\t\t\to = NULL;\n\t\t}\n\n\t\tfree(*response);\n\t\t*response = NULL;\n\n\t\tif (!send_reply)\n\t\t\treturn dres;\n\n\t\t/* send reply */\n\t\tdebugserver_command_new(\"OK\", 0, NULL, &command);\n\t\tdres = debugserver_client_send_command(client, command, response);\n\t\tdebug_info(\"result: %d\", dres);\n\t\tdebugserver_command_free(command);\n\t\tcommand = NULL;\n\t} else if (r[0] == 'T') {\n\t\t/* thread stopped information */\n\t\tdebug_info(\"Thread stopped. Details:\\n%s\", r + 1);\n\n\t\tfree(*response);\n\t\t*response = NULL;\n\n\t\tif (!send_reply)\n\t\t\treturn dres;\n\n\t\tdres = DEBUGSERVER_E_UNKNOWN_ERROR;\n\t} else if (r[0] == 'E' || r[0] == 'W') {\n\t\tprintf(\"%s: %s\\n\", (r[0] == 'E' ? \"ERROR\": \"WARNING\") , r + 1);\n\n\t\tfree(*response);\n\t\t*response = NULL;\n\n\t\tif (!send_reply)\n\t\t\treturn dres;\n\n\t\t/* send reply */\n\t\tdebugserver_command_new(\"OK\", 0, NULL, &command);\n\t\tdres = debugserver_client_send_command(client, command, response);\n\t\tdebug_info(\"result: %d\", dres);\n\t\tdebugserver_command_free(command);\n\t\tcommand = NULL;\n\t} else if (r && strlen(r) == 0) {\n\t\tif (!send_reply)\n\t\t\treturn dres;\n\n\t\tfree(*response);\n\t\t*response = NULL;\n\n\t\t/* no command */\n\t\tdebugserver_command_new(\"OK\", 0, NULL, &command);\n\t\tdres = debugserver_client_send_command(client, command, response);\n\t\tdebug_info(\"result: %d\", dres);\n\t\tdebugserver_command_free(command);\n\t\tcommand = NULL;\n\t} else {\n\t\tdebug_info(\"ERROR: unhandled response\", r);\n\t}\n\n\treturn dres;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include <plist/plist.h>",
            "#include <libimobiledevice/debugserver.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <libimobiledevice/installation_proxy.h>",
            "#include <windows.h>",
            "#include <libgen.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include <plist/plist.h>\n#include <libimobiledevice/debugserver.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <libimobiledevice/installation_proxy.h>\n#include <windows.h>\n#include <libgen.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <config.h>\n\nstatic debugserver_error_t debugserver_client_handle_response(debugserver_client_t client, char** response, int send_reply)\n{\n\tdebugserver_error_t dres = DEBUGSERVER_E_SUCCESS;\n\tdebugserver_command_t command = NULL;\n\tchar* o = NULL;\n\tchar* r = *response;\n\n\tif (r[0] == 'O') {\n\t\t/* stdout/stderr */\n\t\tdebugserver_decode_string(r + 1, strlen(r) - 1, &o);\n\t\tprintf(\"%s\", o);\n\t\tfflush(stdout);\n\t\tif (o != NULL) {\n\t\t\tfree(o);\n\t\t\to = NULL;\n\t\t}\n\n\t\tfree(*response);\n\t\t*response = NULL;\n\n\t\tif (!send_reply)\n\t\t\treturn dres;\n\n\t\t/* send reply */\n\t\tdebugserver_command_new(\"OK\", 0, NULL, &command);\n\t\tdres = debugserver_client_send_command(client, command, response);\n\t\tdebug_info(\"result: %d\", dres);\n\t\tdebugserver_command_free(command);\n\t\tcommand = NULL;\n\t} else if (r[0] == 'T') {\n\t\t/* thread stopped information */\n\t\tdebug_info(\"Thread stopped. Details:\\n%s\", r + 1);\n\n\t\tfree(*response);\n\t\t*response = NULL;\n\n\t\tif (!send_reply)\n\t\t\treturn dres;\n\n\t\tdres = DEBUGSERVER_E_UNKNOWN_ERROR;\n\t} else if (r[0] == 'E' || r[0] == 'W') {\n\t\tprintf(\"%s: %s\\n\", (r[0] == 'E' ? \"ERROR\": \"WARNING\") , r + 1);\n\n\t\tfree(*response);\n\t\t*response = NULL;\n\n\t\tif (!send_reply)\n\t\t\treturn dres;\n\n\t\t/* send reply */\n\t\tdebugserver_command_new(\"OK\", 0, NULL, &command);\n\t\tdres = debugserver_client_send_command(client, command, response);\n\t\tdebug_info(\"result: %d\", dres);\n\t\tdebugserver_command_free(command);\n\t\tcommand = NULL;\n\t} else if (r && strlen(r) == 0) {\n\t\tif (!send_reply)\n\t\t\treturn dres;\n\n\t\tfree(*response);\n\t\t*response = NULL;\n\n\t\t/* no command */\n\t\tdebugserver_command_new(\"OK\", 0, NULL, &command);\n\t\tdres = debugserver_client_send_command(client, command, response);\n\t\tdebug_info(\"result: %d\", dres);\n\t\tdebugserver_command_free(command);\n\t\tcommand = NULL;\n\t} else {\n\t\tdebug_info(\"ERROR: unhandled response\", r);\n\t}\n\n\treturn dres;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Could not create socket\\n\""
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket_create",
          "args": [
            "local_port"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "socket_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/socket.c",
          "lines": "146-191",
          "snippet": "int socket_create(uint16_t port)\n{\n\tint sfd = -1;\n\tint yes = 1;\n#ifdef WIN32\n\tWSADATA wsa_data;\n\tif (!wsa_init) {\n\t\tif (WSAStartup(MAKEWORD(2,2), &wsa_data) != ERROR_SUCCESS) {\n\t\t\tfprintf(stderr, \"WSAStartup failed!\\n\");\n\t\t\tExitProcess(-1);\n\t\t}\n\t\twsa_init = 1;\n\t}\n#endif\n\tstruct sockaddr_in saddr;\n\n\tif (0 > (sfd = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP))) {\n\t\tperror(\"socket()\");\n\t\treturn -1;\n\t}\n\n\tif (setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void*)&yes, sizeof(int)) == -1) {\n\t\tperror(\"setsockopt()\");\n\t\tsocket_close(sfd);\n\t\treturn -1;\n\t}\n\n\tmemset((void *) &saddr, 0, sizeof(saddr));\n\tsaddr.sin_family = AF_INET;\n\tsaddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\tsaddr.sin_port = htons(port);\n\n\tif (0 > bind(sfd, (struct sockaddr *) &saddr, sizeof(saddr))) {\n\t\tperror(\"bind()\");\n\t\tsocket_close(sfd);\n\t\treturn -1;\n\t}\n\n\tif (listen(sfd, 1) == -1) {\n\t\tperror(\"listen()\");\n\t\tsocket_close(sfd);\n\t\treturn -1;\n\t}\n\n\treturn sfd;\n}",
          "includes": [
            "#include \"socket.h\"",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <windows.h>",
            "#include <winsock2.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"socket.h\"\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <windows.h>\n#include <winsock2.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdio.h>\n\nint socket_create(uint16_t port)\n{\n\tint sfd = -1;\n\tint yes = 1;\n#ifdef WIN32\n\tWSADATA wsa_data;\n\tif (!wsa_init) {\n\t\tif (WSAStartup(MAKEWORD(2,2), &wsa_data) != ERROR_SUCCESS) {\n\t\t\tfprintf(stderr, \"WSAStartup failed!\\n\");\n\t\t\tExitProcess(-1);\n\t\t}\n\t\twsa_init = 1;\n\t}\n#endif\n\tstruct sockaddr_in saddr;\n\n\tif (0 > (sfd = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP))) {\n\t\tperror(\"socket()\");\n\t\treturn -1;\n\t}\n\n\tif (setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void*)&yes, sizeof(int)) == -1) {\n\t\tperror(\"setsockopt()\");\n\t\tsocket_close(sfd);\n\t\treturn -1;\n\t}\n\n\tmemset((void *) &saddr, 0, sizeof(saddr));\n\tsaddr.sin_family = AF_INET;\n\tsaddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\tsaddr.sin_port = htons(port);\n\n\tif (0 > bind(sfd, (struct sockaddr *) &saddr, sizeof(saddr))) {\n\t\tperror(\"bind()\");\n\t\tsocket_close(sfd);\n\t\treturn -1;\n\t}\n\n\tif (listen(sfd, 1) == -1) {\n\t\tperror(\"listen()\");\n\t\tsocket_close(sfd);\n\t\treturn -1;\n\t}\n\n\treturn sfd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"No device found, is it plugged in?\\n\""
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"No device found with udid %s, is it plugged in?\\n\"",
            "udid"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idevice_new",
          "args": [
            "&device",
            "udid"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "idevice_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
          "lines": "230-245",
          "snippet": "LIBIMOBILEDEVICE_API idevice_error_t idevice_new(idevice_t * device, const char *udid)\n{\n\tusbmuxd_device_info_t muxdev;\n\tint res = usbmuxd_get_device_by_udid(udid, &muxdev);\n\tif (res > 0) {\n\t\tidevice_t dev = (idevice_t) malloc(sizeof(struct idevice_private));\n\t\tdev->udid = strdup(muxdev.udid);\n\t\tdev->conn_type = CONNECTION_USBMUXD;\n\t\tdev->conn_data = (void*)(long)muxdev.handle;\n\t\t*device = dev;\n\t\treturn IDEVICE_E_SUCCESS;\n\t}\n\t/* other connection types could follow here */\n\n\treturn IDEVICE_E_NO_DEVICE;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"common/thread.h\"",
            "#include \"common/userpref.h\"",
            "#include \"idevice.h\"",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <usbmuxd.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "LIBIMOBILEDEVICE_API idevice_error_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nLIBIMOBILEDEVICE_API idevice_error_t idevice_new(idevice_t * device, const char *udid)\n{\n\tusbmuxd_device_info_t muxdev;\n\tint res = usbmuxd_get_device_by_udid(udid, &muxdev);\n\tif (res > 0) {\n\t\tidevice_t dev = (idevice_t) malloc(sizeof(struct idevice_private));\n\t\tdev->udid = strdup(muxdev.udid);\n\t\tdev->conn_type = CONNECTION_USBMUXD;\n\t\tdev->conn_data = (void*)(long)muxdev.handle;\n\t\t*device = dev;\n\t\treturn IDEVICE_E_SUCCESS;\n\t}\n\t/* other connection types could follow here */\n\n\treturn IDEVICE_E_NO_DEVICE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_usage",
          "args": [
            "argc",
            "argv"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "print_usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicedebugserverproxy.c",
          "lines": "66-78",
          "snippet": "static void print_usage(int argc, char **argv)\n{\n\tchar *name = NULL;\n\n\tname = strrchr(argv[0], '/');\n\tprintf(\"Usage: %s [OPTIONS] <PORT>\\n\", (name ? name + 1: argv[0]));\n\tprintf(\"Proxy debugserver connection from device to a local socket at PORT.\\n\\n\");\n\tprintf(\"  -d, --debug\\t\\tenable communication debugging\\n\");\n\tprintf(\"  -u, --udid UDID\\ttarget specific device by its 40-digit device UDID\\n\");\n\tprintf(\"  -h, --help\\t\\tprints usage information\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"Homepage: <\" PACKAGE_URL \">\\n\");\n}",
          "includes": [
            "#include \"common/thread.h\"",
            "#include \"common/socket.h\"",
            "#include <libimobiledevice/debugserver.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/thread.h\"\n#include \"common/socket.h\"\n#include <libimobiledevice/debugserver.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <signal.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void print_usage(int argc, char **argv)\n{\n\tchar *name = NULL;\n\n\tname = strrchr(argv[0], '/');\n\tprintf(\"Usage: %s [OPTIONS] <PORT>\\n\", (name ? name + 1: argv[0]));\n\tprintf(\"Proxy debugserver connection from device to a local socket at PORT.\\n\\n\");\n\tprintf(\"  -d, --debug\\t\\tenable communication debugging\\n\");\n\tprintf(\"  -u, --udid UDID\\ttarget specific device by its 40-digit device UDID\\n\");\n\tprintf(\"  -h, --help\\t\\tprints usage information\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"Homepage: <\" PACKAGE_URL \">\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Please specify a PORT.\\n\""
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "argv[i]"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "argv[i]"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"--help\""
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "plist_strcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
          "lines": "296-309",
          "snippet": "static int plist_strcmp(plist_t node, const char *str)\n{\n\tchar *buffer = NULL;\n\tint ret = 0;\n\n\tif (plist_get_node_type(node) != PLIST_STRING)\n\t\treturn ret;\n\n\tplist_get_string_val(node, &buffer);\n\tret = strcmp(buffer, str);\n\tfree(buffer);\n\n\treturn ret;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <unistd.h>",
            "#include <gcrypt.h>",
            "#include <openssl/sha.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int plist_strcmp(plist_t node, const char *str)\n{\n\tchar *buffer = NULL;\n\tint ret = 0;\n\n\tif (plist_get_node_type(node) != PLIST_STRING)\n\t\treturn ret;\n\n\tplist_get_string_val(node, &buffer);\n\tret = strcmp(buffer, str);\n\tfree(buffer);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "argv[i]"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket_set_verbose",
          "args": [
            "3"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "socket_set_verbose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/socket.c",
          "lines": "47-50",
          "snippet": "void socket_set_verbose(int level)\n{\n\tverbose = level;\n}",
          "includes": [
            "#include \"socket.h\"",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <windows.h>",
            "#include <winsock2.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int verbose = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"socket.h\"\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <windows.h>\n#include <winsock2.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdio.h>\n\nstatic int verbose = 0;\n\nvoid socket_set_verbose(int level)\n{\n\tverbose = level;\n}"
        }
      },
      {
        "call_info": {
          "callee": "idevice_set_debug_level",
          "args": [
            "1"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "idevice_set_debug_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
          "lines": "225-228",
          "snippet": "LIBIMOBILEDEVICE_API void idevice_set_debug_level(int level)\n{\n\tinternal_set_debug_level(level);\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"common/thread.h\"",
            "#include \"common/userpref.h\"",
            "#include \"idevice.h\"",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <usbmuxd.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API void idevice_set_debug_level(int level)\n{\n\tinternal_set_debug_level(level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGTERM",
            "clean_exit"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGINT",
            "clean_exit"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaction",
          "args": [
            "SIGPIPE",
            "&si",
            "NULL"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaction",
          "args": [
            "SIGQUIT",
            "&sa",
            "NULL"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaction",
          "args": [
            "SIGTERM",
            "&sa",
            "NULL"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaction",
          "args": [
            "SIGINT",
            "&sa",
            "NULL"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigemptyset",
          "args": [
            "&si.sa_mask"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigemptyset",
          "args": [
            "&sa.sa_mask"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&si",
            "'\\0'",
            "sizeof(struct sigaction)"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&sa",
            "'\\0'",
            "sizeof(struct sigaction)"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common/thread.h\"\n#include \"common/socket.h\"\n#include <libimobiledevice/debugserver.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <signal.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int debug_mode = 0;\nstatic int quit_flag = 0;\n\nint main(int argc, char *argv[])\n{\n\tidevice_error_t ret = IDEVICE_E_UNKNOWN_ERROR;\n\tidevice_t device = NULL;\n\tthread_info_t *thread_list = NULL;\n\tconst char* udid = NULL;\n\tuint16_t local_port = 0;\n\tint server_fd;\n\tint result = EXIT_SUCCESS;\n\tint i;\n\n#ifndef WIN32\n\tstruct sigaction sa;\n\tstruct sigaction si;\n\tmemset(&sa, '\\0', sizeof(struct sigaction));\n\tmemset(&si, '\\0', sizeof(struct sigaction));\n\n\tsa.sa_handler = clean_exit;\n\tsigemptyset(&sa.sa_mask);\n\n\tsi.sa_handler = SIG_IGN;\n\tsigemptyset(&si.sa_mask);\n\n\tsigaction(SIGINT, &sa, NULL);\n\tsigaction(SIGTERM, &sa, NULL);\n\tsigaction(SIGQUIT, &sa, NULL);\n\tsigaction(SIGPIPE, &si, NULL);\n#else\n\t/* bind signals */\n\tsignal(SIGINT, clean_exit);\n\tsignal(SIGTERM, clean_exit);\n#endif\n\n\t/* parse cmdline arguments */\n\tfor (i = 1; i < argc; i++) {\n\t\tif (!strcmp(argv[i], \"-d\") || !strcmp(argv[i], \"--debug\")) {\n\t\t\tdebug_mode = 1;\n\t\t\tidevice_set_debug_level(1);\n\t\t\tsocket_set_verbose(3);\n\t\t\tcontinue;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"-u\") || !strcmp(argv[i], \"--udid\")) {\n\t\t\ti++;\n\t\t\tif (!argv[i] || (strlen(argv[i]) != 40)) {\n\t\t\t\tprint_usage(argc, argv);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tudid = argv[i];\n\t\t\tcontinue;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"-h\") || !strcmp(argv[i], \"--help\")) {\n\t\t\tprint_usage(argc, argv);\n\t\t\treturn EXIT_SUCCESS;\n\t\t}\n\t\telse if (atoi(argv[i]) > 0) {\n\t\t\tlocal_port = atoi(argv[i]);\n\t\t\tcontinue;\n\t\t}\n\t\telse {\n\t\t\tprint_usage(argc, argv);\n\t\t\treturn EXIT_SUCCESS;\n\t\t}\n\t}\n\n\t/* a PORT is mandatory */\n\tif (!local_port) {\n\t\tfprintf(stderr, \"Please specify a PORT.\\n\");\n\t\tprint_usage(argc, argv);\n\t\tgoto leave_cleanup;\n\t}\n\n\t/* start services and connect to device */\n\tret = idevice_new(&device, udid);\n\tif (ret != IDEVICE_E_SUCCESS) {\n\t\tif (udid) {\n\t\t\tfprintf(stderr, \"No device found with udid %s, is it plugged in?\\n\", udid);\n\t\t} else {\n\t\t\tfprintf(stderr, \"No device found, is it plugged in?\\n\");\n\t\t}\n\t\tresult = EXIT_FAILURE;\n\t\tgoto leave_cleanup;\n\t}\n\n\t/* create local socket */\n\tserver_fd = socket_create(local_port);\n\tif (server_fd < 0) {\n\t\tfprintf(stderr, \"Could not create socket\\n\");\n\t\tresult = EXIT_FAILURE;\n\t\tgoto leave_cleanup;\n\t}\n\n\twhile (!quit_flag) {\n\t\tdebug(\"%s: Waiting for connection on local port %d\\n\", __func__, local_port);\n\n\t\t/* wait for client */\n\t\tint client_fd = socket_accept(server_fd, local_port);\n\t\tif (client_fd < 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdebug(\"%s: Handling new client connection...\\n\", __func__);\n\n\t\tthread_info_t *el = (thread_info_t*)malloc(sizeof(thread_info_t));\n\t\tif (!el) {\n\t\t\tfprintf(stderr, \"Out of memory\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tel->next = NULL;\n\n\t\tif (thread_list) {\n\t\t\tthread_list->next = el;\n\t\t} else {\n\t\t\tthread_list = el;\n\t\t}\n\n\t\tsocket_info_t *sinfo = (socket_info_t*)malloc(sizeof(socket_info_t));\n\t\tif (!sinfo) {\n\t\t\tfprintf(stderr, \"Out of memory\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tsinfo->client_fd = client_fd;\n\t\tsinfo->device = device;\n\n\t\tif (thread_new(&(el->th), connection_handler, (void*)sinfo) != 0) {\n\t\t\tfprintf(stderr, \"Could not start connection handler.\\n\");\n\t\t\tsocket_shutdown(server_fd, SHUT_RDWR);\n\t\t\tsocket_close(server_fd);\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tdebug(\"%s: Shutting down debugserver proxy...\\n\", __func__);\n\n\t/* join and clean up threads */\n\twhile (thread_list) {\n\t\tthread_info_t *el = thread_list;\n\t\tthread_join(el->th);\n\t\tthread_free(el->th);\n\t\tthread_list = el->next;\n\t\tfree(el);\n\t}\n\nleave_cleanup:\n\tif (device) {\n\t\tidevice_free(device);\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "connection_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicedebugserverproxy.c",
    "lines": "204-238",
    "snippet": "static void* connection_handler(void* data)\n{\n\tdebugserver_error_t derr = DEBUGSERVER_E_SUCCESS;\n\tsocket_info_t* socket_info = (socket_info_t*)data;\n\tthread_t ctod;\n\n\tdebug(\"%s: client_fd = %d\\n\", __func__, socket_info->client_fd);\n\n\tderr = debugserver_client_start_service(socket_info->device, &socket_info->debugserver_client, \"idevicedebugserverproxy\");\n\tif (derr != DEBUGSERVER_E_SUCCESS) {\n\t\tfprintf(stderr, \"Could not start debugserver on device!\\nPlease make sure to mount a developer disk image first.\\n\");\n\t\treturn NULL;\n\t}\n\n\t/* spawn client to device thread */\n\tsocket_info->stop_ctod = 0;\n\tif (thread_new(&ctod, thread_client_to_device, data) != 0) {\n\t\tfprintf(stderr, \"Failed to start client to device thread...\\n\");\n\t}\n\n\t/* join the fun */\n\tthread_join(ctod);\n\tthread_free(ctod);\n\n\tdebug(\"%s: shutting down...\\n\", __func__);\n\n\tdebugserver_client_free(socket_info->debugserver_client);\n\tsocket_info->debugserver_client = NULL;\n\n\t/* shutdown client socket */\n\tsocket_shutdown(socket_info->client_fd, SHUT_RDWR);\n\tsocket_close(socket_info->client_fd);\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"common/thread.h\"",
      "#include \"common/socket.h\"",
      "#include <libimobiledevice/debugserver.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <signal.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "socket_close",
          "args": [
            "socket_info->client_fd"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "socket_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/socket.c",
          "lines": "346-352",
          "snippet": "int socket_close(int fd) {\n#ifdef WIN32\n\treturn closesocket(fd);\n#else\n\treturn close(fd);\n#endif\n}",
          "includes": [
            "#include \"socket.h\"",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <windows.h>",
            "#include <winsock2.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"socket.h\"\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <windows.h>\n#include <winsock2.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdio.h>\n\nint socket_close(int fd) {\n#ifdef WIN32\n\treturn closesocket(fd);\n#else\n\treturn close(fd);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "socket_shutdown",
          "args": [
            "socket_info->client_fd",
            "SHUT_RDWR"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "socket_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/socket.c",
          "lines": "341-344",
          "snippet": "int socket_shutdown(int fd, int how)\n{\n\treturn shutdown(fd, how);\n}",
          "includes": [
            "#include \"socket.h\"",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <windows.h>",
            "#include <winsock2.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"socket.h\"\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <windows.h>\n#include <winsock2.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdio.h>\n\nint socket_shutdown(int fd, int how)\n{\n\treturn shutdown(fd, how);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugserver_client_free",
          "args": [
            "socket_info->debugserver_client"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "debugserver_client_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/debugserver.c",
          "lines": "98-108",
          "snippet": "LIBIMOBILEDEVICE_API debugserver_error_t debugserver_client_free(debugserver_client_t client)\n{\n\tif (!client)\n\t\treturn DEBUGSERVER_E_INVALID_ARG;\n\n\tdebugserver_error_t err = debugserver_error(service_client_free(client->parent));\n\tclient->parent = NULL;\n\tfree(client);\n\n\treturn err;\n}",
          "includes": [
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/debug.h\"",
            "#include \"lockdown.h\"",
            "#include \"debugserver.h\"",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/debug.h\"\n#include \"lockdown.h\"\n#include \"debugserver.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API debugserver_error_t debugserver_client_free(debugserver_client_t client)\n{\n\tif (!client)\n\t\treturn DEBUGSERVER_E_INVALID_ARG;\n\n\tdebugserver_error_t err = debugserver_error(service_client_free(client->parent));\n\tclient->parent = NULL;\n\tfree(client);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s: shutting down...\\n\"",
            "__func__"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "debug_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/debug.c",
          "lines": "101-134",
          "snippet": "void debug_buffer(const char *data, const int length)\n{\n#ifndef STRIP_DEBUG_CODE\n\tint i;\n\tint j;\n\tunsigned char c;\n\n\tif (debug_level) {\n\t\tfor (i = 0; i < length; i += 16) {\n\t\t\tfprintf(stderr, \"%04x: \", i);\n\t\t\tfor (j = 0; j < 16; j++) {\n\t\t\t\tif (i + j >= length) {\n\t\t\t\t\tfprintf(stderr, \"   \");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"%02x \", *(data + i + j) & 0xff);\n\t\t\t}\n\t\t\tfprintf(stderr, \"  | \");\n\t\t\tfor (j = 0; j < 16; j++) {\n\t\t\t\tif (i + j >= length)\n\t\t\t\t\tbreak;\n\t\t\t\tc = *(data + i + j);\n\t\t\t\tif ((c < 32) || (c > 127)) {\n\t\t\t\t\tfprintf(stderr, \".\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"%c\", c);\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t}\n\t\tfprintf(stderr, \"\\n\");\n\t}\n#endif\n}",
          "includes": [
            "#include \"asprintf.h\"",
            "#include \"src/idevice.h\"",
            "#include \"libimobiledevice/libimobiledevice.h\"",
            "#include \"debug.h\"",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int debug_level;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"asprintf.h\"\n#include \"src/idevice.h\"\n#include \"libimobiledevice/libimobiledevice.h\"\n#include \"debug.h\"\n#include <time.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int debug_level;\n\nvoid debug_buffer(const char *data, const int length)\n{\n#ifndef STRIP_DEBUG_CODE\n\tint i;\n\tint j;\n\tunsigned char c;\n\n\tif (debug_level) {\n\t\tfor (i = 0; i < length; i += 16) {\n\t\t\tfprintf(stderr, \"%04x: \", i);\n\t\t\tfor (j = 0; j < 16; j++) {\n\t\t\t\tif (i + j >= length) {\n\t\t\t\t\tfprintf(stderr, \"   \");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"%02x \", *(data + i + j) & 0xff);\n\t\t\t}\n\t\t\tfprintf(stderr, \"  | \");\n\t\t\tfor (j = 0; j < 16; j++) {\n\t\t\t\tif (i + j >= length)\n\t\t\t\t\tbreak;\n\t\t\t\tc = *(data + i + j);\n\t\t\t\tif ((c < 32) || (c > 127)) {\n\t\t\t\t\tfprintf(stderr, \".\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"%c\", c);\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t}\n\t\tfprintf(stderr, \"\\n\");\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "thread_free",
          "args": [
            "ctod"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "thread_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "39-44",
          "snippet": "void thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nvoid thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "thread_join",
          "args": [
            "ctod"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "thread_join",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "46-54",
          "snippet": "void thread_join(thread_t thread)\n{\n\t/* wait for thread to complete */\n#ifdef WIN32\n\tWaitForSingleObject(thread, INFINITE);\n#else\n\tpthread_join(thread, NULL);\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nvoid thread_join(thread_t thread)\n{\n\t/* wait for thread to complete */\n#ifdef WIN32\n\tWaitForSingleObject(thread, INFINITE);\n#else\n\tpthread_join(thread, NULL);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Failed to start client to device thread...\\n\""
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread_new",
          "args": [
            "&ctod",
            "thread_client_to_device",
            "data"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "thread_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "24-37",
          "snippet": "int thread_new(thread_t *thread, thread_func_t thread_func, void* data)\n{\n#ifdef WIN32\n\tHANDLE th = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)thread_func, data, 0, NULL);\n\tif (th == NULL) {\n\t\treturn -1;\n\t}\n\t*thread = th;\n\treturn 0;\n#else\n\tint res = pthread_create(thread, NULL, thread_func, data);\n\treturn res;\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nint thread_new(thread_t *thread, thread_func_t thread_func, void* data)\n{\n#ifdef WIN32\n\tHANDLE th = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)thread_func, data, 0, NULL);\n\tif (th == NULL) {\n\t\treturn -1;\n\t}\n\t*thread = th;\n\treturn 0;\n#else\n\tint res = pthread_create(thread, NULL, thread_func, data);\n\treturn res;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Could not start debugserver on device!\\nPlease make sure to mount a developer disk image first.\\n\""
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugserver_client_start_service",
          "args": [
            "socket_info->device",
            "&socket_info->debugserver_client",
            "\"idevicedebugserverproxy\""
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "debugserver_client_start_service",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/debugserver.c",
          "lines": "91-96",
          "snippet": "LIBIMOBILEDEVICE_API debugserver_error_t debugserver_client_start_service(idevice_t device, debugserver_client_t * client, const char* label)\n{\n\tdebugserver_error_t err = DEBUGSERVER_E_UNKNOWN_ERROR;\n\tservice_client_factory_start_service(device, DEBUGSERVER_SERVICE_NAME, (void**)client, label, SERVICE_CONSTRUCTOR(debugserver_client_new), &err);\n\treturn err;\n}",
          "includes": [
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/debug.h\"",
            "#include \"lockdown.h\"",
            "#include \"debugserver.h\"",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/debug.h\"\n#include \"lockdown.h\"\n#include \"debugserver.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API debugserver_error_t debugserver_client_start_service(idevice_t device, debugserver_client_t * client, const char* label)\n{\n\tdebugserver_error_t err = DEBUGSERVER_E_UNKNOWN_ERROR;\n\tservice_client_factory_start_service(device, DEBUGSERVER_SERVICE_NAME, (void**)client, label, SERVICE_CONSTRUCTOR(debugserver_client_new), &err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s: client_fd = %d\\n\"",
            "__func__",
            "socket_info->client_fd"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "debugserver_client_handle_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicedebug.c",
          "lines": "105-178",
          "snippet": "static debugserver_error_t debugserver_client_handle_response(debugserver_client_t client, char** response, int send_reply)\n{\n\tdebugserver_error_t dres = DEBUGSERVER_E_SUCCESS;\n\tdebugserver_command_t command = NULL;\n\tchar* o = NULL;\n\tchar* r = *response;\n\n\tif (r[0] == 'O') {\n\t\t/* stdout/stderr */\n\t\tdebugserver_decode_string(r + 1, strlen(r) - 1, &o);\n\t\tprintf(\"%s\", o);\n\t\tfflush(stdout);\n\t\tif (o != NULL) {\n\t\t\tfree(o);\n\t\t\to = NULL;\n\t\t}\n\n\t\tfree(*response);\n\t\t*response = NULL;\n\n\t\tif (!send_reply)\n\t\t\treturn dres;\n\n\t\t/* send reply */\n\t\tdebugserver_command_new(\"OK\", 0, NULL, &command);\n\t\tdres = debugserver_client_send_command(client, command, response);\n\t\tdebug_info(\"result: %d\", dres);\n\t\tdebugserver_command_free(command);\n\t\tcommand = NULL;\n\t} else if (r[0] == 'T') {\n\t\t/* thread stopped information */\n\t\tdebug_info(\"Thread stopped. Details:\\n%s\", r + 1);\n\n\t\tfree(*response);\n\t\t*response = NULL;\n\n\t\tif (!send_reply)\n\t\t\treturn dres;\n\n\t\tdres = DEBUGSERVER_E_UNKNOWN_ERROR;\n\t} else if (r[0] == 'E' || r[0] == 'W') {\n\t\tprintf(\"%s: %s\\n\", (r[0] == 'E' ? \"ERROR\": \"WARNING\") , r + 1);\n\n\t\tfree(*response);\n\t\t*response = NULL;\n\n\t\tif (!send_reply)\n\t\t\treturn dres;\n\n\t\t/* send reply */\n\t\tdebugserver_command_new(\"OK\", 0, NULL, &command);\n\t\tdres = debugserver_client_send_command(client, command, response);\n\t\tdebug_info(\"result: %d\", dres);\n\t\tdebugserver_command_free(command);\n\t\tcommand = NULL;\n\t} else if (r && strlen(r) == 0) {\n\t\tif (!send_reply)\n\t\t\treturn dres;\n\n\t\tfree(*response);\n\t\t*response = NULL;\n\n\t\t/* no command */\n\t\tdebugserver_command_new(\"OK\", 0, NULL, &command);\n\t\tdres = debugserver_client_send_command(client, command, response);\n\t\tdebug_info(\"result: %d\", dres);\n\t\tdebugserver_command_free(command);\n\t\tcommand = NULL;\n\t} else {\n\t\tdebug_info(\"ERROR: unhandled response\", r);\n\t}\n\n\treturn dres;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include <plist/plist.h>",
            "#include <libimobiledevice/debugserver.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <libimobiledevice/installation_proxy.h>",
            "#include <windows.h>",
            "#include <libgen.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include <plist/plist.h>\n#include <libimobiledevice/debugserver.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <libimobiledevice/installation_proxy.h>\n#include <windows.h>\n#include <libgen.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <config.h>\n\nstatic debugserver_error_t debugserver_client_handle_response(debugserver_client_t client, char** response, int send_reply)\n{\n\tdebugserver_error_t dres = DEBUGSERVER_E_SUCCESS;\n\tdebugserver_command_t command = NULL;\n\tchar* o = NULL;\n\tchar* r = *response;\n\n\tif (r[0] == 'O') {\n\t\t/* stdout/stderr */\n\t\tdebugserver_decode_string(r + 1, strlen(r) - 1, &o);\n\t\tprintf(\"%s\", o);\n\t\tfflush(stdout);\n\t\tif (o != NULL) {\n\t\t\tfree(o);\n\t\t\to = NULL;\n\t\t}\n\n\t\tfree(*response);\n\t\t*response = NULL;\n\n\t\tif (!send_reply)\n\t\t\treturn dres;\n\n\t\t/* send reply */\n\t\tdebugserver_command_new(\"OK\", 0, NULL, &command);\n\t\tdres = debugserver_client_send_command(client, command, response);\n\t\tdebug_info(\"result: %d\", dres);\n\t\tdebugserver_command_free(command);\n\t\tcommand = NULL;\n\t} else if (r[0] == 'T') {\n\t\t/* thread stopped information */\n\t\tdebug_info(\"Thread stopped. Details:\\n%s\", r + 1);\n\n\t\tfree(*response);\n\t\t*response = NULL;\n\n\t\tif (!send_reply)\n\t\t\treturn dres;\n\n\t\tdres = DEBUGSERVER_E_UNKNOWN_ERROR;\n\t} else if (r[0] == 'E' || r[0] == 'W') {\n\t\tprintf(\"%s: %s\\n\", (r[0] == 'E' ? \"ERROR\": \"WARNING\") , r + 1);\n\n\t\tfree(*response);\n\t\t*response = NULL;\n\n\t\tif (!send_reply)\n\t\t\treturn dres;\n\n\t\t/* send reply */\n\t\tdebugserver_command_new(\"OK\", 0, NULL, &command);\n\t\tdres = debugserver_client_send_command(client, command, response);\n\t\tdebug_info(\"result: %d\", dres);\n\t\tdebugserver_command_free(command);\n\t\tcommand = NULL;\n\t} else if (r && strlen(r) == 0) {\n\t\tif (!send_reply)\n\t\t\treturn dres;\n\n\t\tfree(*response);\n\t\t*response = NULL;\n\n\t\t/* no command */\n\t\tdebugserver_command_new(\"OK\", 0, NULL, &command);\n\t\tdres = debugserver_client_send_command(client, command, response);\n\t\tdebug_info(\"result: %d\", dres);\n\t\tdebugserver_command_free(command);\n\t\tcommand = NULL;\n\t} else {\n\t\tdebug_info(\"ERROR: unhandled response\", r);\n\t}\n\n\treturn dres;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common/thread.h\"\n#include \"common/socket.h\"\n#include <libimobiledevice/debugserver.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <signal.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void* connection_handler(void* data)\n{\n\tdebugserver_error_t derr = DEBUGSERVER_E_SUCCESS;\n\tsocket_info_t* socket_info = (socket_info_t*)data;\n\tthread_t ctod;\n\n\tdebug(\"%s: client_fd = %d\\n\", __func__, socket_info->client_fd);\n\n\tderr = debugserver_client_start_service(socket_info->device, &socket_info->debugserver_client, \"idevicedebugserverproxy\");\n\tif (derr != DEBUGSERVER_E_SUCCESS) {\n\t\tfprintf(stderr, \"Could not start debugserver on device!\\nPlease make sure to mount a developer disk image first.\\n\");\n\t\treturn NULL;\n\t}\n\n\t/* spawn client to device thread */\n\tsocket_info->stop_ctod = 0;\n\tif (thread_new(&ctod, thread_client_to_device, data) != 0) {\n\t\tfprintf(stderr, \"Failed to start client to device thread...\\n\");\n\t}\n\n\t/* join the fun */\n\tthread_join(ctod);\n\tthread_free(ctod);\n\n\tdebug(\"%s: shutting down...\\n\", __func__);\n\n\tdebugserver_client_free(socket_info->debugserver_client);\n\tsocket_info->debugserver_client = NULL;\n\n\t/* shutdown client socket */\n\tsocket_shutdown(socket_info->client_fd, SHUT_RDWR);\n\tsocket_close(socket_info->client_fd);\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "thread_client_to_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicedebugserverproxy.c",
    "lines": "135-202",
    "snippet": "static void *thread_client_to_device(void *data)\n{\n\tsocket_info_t* socket_info = (socket_info_t*)data;\n\tdebugserver_error_t res = DEBUGSERVER_E_UNKNOWN_ERROR;\n\n\tint recv_len;\n\tint sent;\n\tchar buffer[131072];\n\tthread_t dtoc;\n\n\tdebug(\"%s: started thread...\\n\", __func__);\n\n\tdebug(\"%s: client_fd = %d\\n\", __func__, socket_info->client_fd);\n\n\t/* spawn server to client thread */\n\tsocket_info->stop_dtoc = 0;\n\tif (thread_new(&dtoc, thread_device_to_client, data) != 0) {\n\t\tfprintf(stderr, \"Failed to start device to client thread...\\n\");\n\t}\n\n\twhile (!quit_flag && !socket_info->stop_ctod && socket_info->client_fd > 0) {\n\t\tdebug(\"%s: receiving data from client...\\n\", __func__);\n\n\t\t/* attempt to read incoming data from client */\n\t\trecv_len = socket_receive_timeout(socket_info->client_fd, buffer, sizeof(buffer), 0, 5000);\n\n\t\t/* any data received? */\n\t\tif (recv_len <= 0) {\n\t\t\tif (recv_len == 0) {\n\t\t\t\t/* try again */\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"Receive failed: %s\\n\", strerror(errno));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t/* forward data to device */\n\t\t\tdebug(\"%s: sending data to device...\\n\", __func__);\n\t\t\tres = debugserver_client_send(socket_info->debugserver_client, buffer, recv_len, (uint32_t*)&sent);\n\n\t\t\tif (sent < recv_len || res != DEBUGSERVER_E_SUCCESS) {\n\t\t\t\tif (sent <= 0) {\n\t\t\t\t\tfprintf(stderr, \"send failed: %s\\n\", strerror(errno));\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"only sent %d from %d bytes\\n\", sent, recv_len);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// sending succeeded, receive from device\n\t\t\t\tdebug(\"%s: sent %d bytes to device\\n\", __func__, sent);\n\t\t\t}\n\t\t}\n\t}\n\n\tdebug(\"%s: shutting down...\\n\", __func__);\n\n\tsocket_shutdown(socket_info->client_fd, SHUT_RDWR);\n\tsocket_close(socket_info->client_fd);\n\n\tsocket_info->client_fd = -1;\n\tsocket_info->stop_dtoc = 1;\n\n\t/* join other thread to allow it to stop */\n\tthread_join(dtoc);\n\tthread_free(dtoc);\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"common/thread.h\"",
      "#include \"common/socket.h\"",
      "#include <libimobiledevice/debugserver.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <signal.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int quit_flag = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "thread_free",
          "args": [
            "dtoc"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "thread_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "39-44",
          "snippet": "void thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nvoid thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "thread_join",
          "args": [
            "dtoc"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "thread_join",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "46-54",
          "snippet": "void thread_join(thread_t thread)\n{\n\t/* wait for thread to complete */\n#ifdef WIN32\n\tWaitForSingleObject(thread, INFINITE);\n#else\n\tpthread_join(thread, NULL);\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nvoid thread_join(thread_t thread)\n{\n\t/* wait for thread to complete */\n#ifdef WIN32\n\tWaitForSingleObject(thread, INFINITE);\n#else\n\tpthread_join(thread, NULL);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "socket_close",
          "args": [
            "socket_info->client_fd"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "socket_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/socket.c",
          "lines": "346-352",
          "snippet": "int socket_close(int fd) {\n#ifdef WIN32\n\treturn closesocket(fd);\n#else\n\treturn close(fd);\n#endif\n}",
          "includes": [
            "#include \"socket.h\"",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <windows.h>",
            "#include <winsock2.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"socket.h\"\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <windows.h>\n#include <winsock2.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdio.h>\n\nint socket_close(int fd) {\n#ifdef WIN32\n\treturn closesocket(fd);\n#else\n\treturn close(fd);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "socket_shutdown",
          "args": [
            "socket_info->client_fd",
            "SHUT_RDWR"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "socket_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/socket.c",
          "lines": "341-344",
          "snippet": "int socket_shutdown(int fd, int how)\n{\n\treturn shutdown(fd, how);\n}",
          "includes": [
            "#include \"socket.h\"",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <windows.h>",
            "#include <winsock2.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"socket.h\"\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <windows.h>\n#include <winsock2.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdio.h>\n\nint socket_shutdown(int fd, int how)\n{\n\treturn shutdown(fd, how);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s: shutting down...\\n\"",
            "__func__"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "debug_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/debug.c",
          "lines": "101-134",
          "snippet": "void debug_buffer(const char *data, const int length)\n{\n#ifndef STRIP_DEBUG_CODE\n\tint i;\n\tint j;\n\tunsigned char c;\n\n\tif (debug_level) {\n\t\tfor (i = 0; i < length; i += 16) {\n\t\t\tfprintf(stderr, \"%04x: \", i);\n\t\t\tfor (j = 0; j < 16; j++) {\n\t\t\t\tif (i + j >= length) {\n\t\t\t\t\tfprintf(stderr, \"   \");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"%02x \", *(data + i + j) & 0xff);\n\t\t\t}\n\t\t\tfprintf(stderr, \"  | \");\n\t\t\tfor (j = 0; j < 16; j++) {\n\t\t\t\tif (i + j >= length)\n\t\t\t\t\tbreak;\n\t\t\t\tc = *(data + i + j);\n\t\t\t\tif ((c < 32) || (c > 127)) {\n\t\t\t\t\tfprintf(stderr, \".\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"%c\", c);\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t}\n\t\tfprintf(stderr, \"\\n\");\n\t}\n#endif\n}",
          "includes": [
            "#include \"asprintf.h\"",
            "#include \"src/idevice.h\"",
            "#include \"libimobiledevice/libimobiledevice.h\"",
            "#include \"debug.h\"",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int debug_level;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"asprintf.h\"\n#include \"src/idevice.h\"\n#include \"libimobiledevice/libimobiledevice.h\"\n#include \"debug.h\"\n#include <time.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int debug_level;\n\nvoid debug_buffer(const char *data, const int length)\n{\n#ifndef STRIP_DEBUG_CODE\n\tint i;\n\tint j;\n\tunsigned char c;\n\n\tif (debug_level) {\n\t\tfor (i = 0; i < length; i += 16) {\n\t\t\tfprintf(stderr, \"%04x: \", i);\n\t\t\tfor (j = 0; j < 16; j++) {\n\t\t\t\tif (i + j >= length) {\n\t\t\t\t\tfprintf(stderr, \"   \");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"%02x \", *(data + i + j) & 0xff);\n\t\t\t}\n\t\t\tfprintf(stderr, \"  | \");\n\t\t\tfor (j = 0; j < 16; j++) {\n\t\t\t\tif (i + j >= length)\n\t\t\t\t\tbreak;\n\t\t\t\tc = *(data + i + j);\n\t\t\t\tif ((c < 32) || (c > 127)) {\n\t\t\t\t\tfprintf(stderr, \".\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"%c\", c);\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t}\n\t\tfprintf(stderr, \"\\n\");\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s: sent %d bytes to device\\n\"",
            "__func__",
            "sent"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "debugserver_client_handle_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicedebug.c",
          "lines": "105-178",
          "snippet": "static debugserver_error_t debugserver_client_handle_response(debugserver_client_t client, char** response, int send_reply)\n{\n\tdebugserver_error_t dres = DEBUGSERVER_E_SUCCESS;\n\tdebugserver_command_t command = NULL;\n\tchar* o = NULL;\n\tchar* r = *response;\n\n\tif (r[0] == 'O') {\n\t\t/* stdout/stderr */\n\t\tdebugserver_decode_string(r + 1, strlen(r) - 1, &o);\n\t\tprintf(\"%s\", o);\n\t\tfflush(stdout);\n\t\tif (o != NULL) {\n\t\t\tfree(o);\n\t\t\to = NULL;\n\t\t}\n\n\t\tfree(*response);\n\t\t*response = NULL;\n\n\t\tif (!send_reply)\n\t\t\treturn dres;\n\n\t\t/* send reply */\n\t\tdebugserver_command_new(\"OK\", 0, NULL, &command);\n\t\tdres = debugserver_client_send_command(client, command, response);\n\t\tdebug_info(\"result: %d\", dres);\n\t\tdebugserver_command_free(command);\n\t\tcommand = NULL;\n\t} else if (r[0] == 'T') {\n\t\t/* thread stopped information */\n\t\tdebug_info(\"Thread stopped. Details:\\n%s\", r + 1);\n\n\t\tfree(*response);\n\t\t*response = NULL;\n\n\t\tif (!send_reply)\n\t\t\treturn dres;\n\n\t\tdres = DEBUGSERVER_E_UNKNOWN_ERROR;\n\t} else if (r[0] == 'E' || r[0] == 'W') {\n\t\tprintf(\"%s: %s\\n\", (r[0] == 'E' ? \"ERROR\": \"WARNING\") , r + 1);\n\n\t\tfree(*response);\n\t\t*response = NULL;\n\n\t\tif (!send_reply)\n\t\t\treturn dres;\n\n\t\t/* send reply */\n\t\tdebugserver_command_new(\"OK\", 0, NULL, &command);\n\t\tdres = debugserver_client_send_command(client, command, response);\n\t\tdebug_info(\"result: %d\", dres);\n\t\tdebugserver_command_free(command);\n\t\tcommand = NULL;\n\t} else if (r && strlen(r) == 0) {\n\t\tif (!send_reply)\n\t\t\treturn dres;\n\n\t\tfree(*response);\n\t\t*response = NULL;\n\n\t\t/* no command */\n\t\tdebugserver_command_new(\"OK\", 0, NULL, &command);\n\t\tdres = debugserver_client_send_command(client, command, response);\n\t\tdebug_info(\"result: %d\", dres);\n\t\tdebugserver_command_free(command);\n\t\tcommand = NULL;\n\t} else {\n\t\tdebug_info(\"ERROR: unhandled response\", r);\n\t}\n\n\treturn dres;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include <plist/plist.h>",
            "#include <libimobiledevice/debugserver.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <libimobiledevice/installation_proxy.h>",
            "#include <windows.h>",
            "#include <libgen.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include <plist/plist.h>\n#include <libimobiledevice/debugserver.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <libimobiledevice/installation_proxy.h>\n#include <windows.h>\n#include <libgen.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <config.h>\n\nstatic debugserver_error_t debugserver_client_handle_response(debugserver_client_t client, char** response, int send_reply)\n{\n\tdebugserver_error_t dres = DEBUGSERVER_E_SUCCESS;\n\tdebugserver_command_t command = NULL;\n\tchar* o = NULL;\n\tchar* r = *response;\n\n\tif (r[0] == 'O') {\n\t\t/* stdout/stderr */\n\t\tdebugserver_decode_string(r + 1, strlen(r) - 1, &o);\n\t\tprintf(\"%s\", o);\n\t\tfflush(stdout);\n\t\tif (o != NULL) {\n\t\t\tfree(o);\n\t\t\to = NULL;\n\t\t}\n\n\t\tfree(*response);\n\t\t*response = NULL;\n\n\t\tif (!send_reply)\n\t\t\treturn dres;\n\n\t\t/* send reply */\n\t\tdebugserver_command_new(\"OK\", 0, NULL, &command);\n\t\tdres = debugserver_client_send_command(client, command, response);\n\t\tdebug_info(\"result: %d\", dres);\n\t\tdebugserver_command_free(command);\n\t\tcommand = NULL;\n\t} else if (r[0] == 'T') {\n\t\t/* thread stopped information */\n\t\tdebug_info(\"Thread stopped. Details:\\n%s\", r + 1);\n\n\t\tfree(*response);\n\t\t*response = NULL;\n\n\t\tif (!send_reply)\n\t\t\treturn dres;\n\n\t\tdres = DEBUGSERVER_E_UNKNOWN_ERROR;\n\t} else if (r[0] == 'E' || r[0] == 'W') {\n\t\tprintf(\"%s: %s\\n\", (r[0] == 'E' ? \"ERROR\": \"WARNING\") , r + 1);\n\n\t\tfree(*response);\n\t\t*response = NULL;\n\n\t\tif (!send_reply)\n\t\t\treturn dres;\n\n\t\t/* send reply */\n\t\tdebugserver_command_new(\"OK\", 0, NULL, &command);\n\t\tdres = debugserver_client_send_command(client, command, response);\n\t\tdebug_info(\"result: %d\", dres);\n\t\tdebugserver_command_free(command);\n\t\tcommand = NULL;\n\t} else if (r && strlen(r) == 0) {\n\t\tif (!send_reply)\n\t\t\treturn dres;\n\n\t\tfree(*response);\n\t\t*response = NULL;\n\n\t\t/* no command */\n\t\tdebugserver_command_new(\"OK\", 0, NULL, &command);\n\t\tdres = debugserver_client_send_command(client, command, response);\n\t\tdebug_info(\"result: %d\", dres);\n\t\tdebugserver_command_free(command);\n\t\tcommand = NULL;\n\t} else {\n\t\tdebug_info(\"ERROR: unhandled response\", r);\n\t}\n\n\treturn dres;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"only sent %d from %d bytes\\n\"",
            "sent",
            "recv_len"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"send failed: %s\\n\"",
            "strerror(errno)"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugserver_client_send",
          "args": [
            "socket_info->debugserver_client",
            "buffer",
            "recv_len",
            "(uint32_t*)&sent"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "debugserver_client_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/debugserver.c",
          "lines": "110-129",
          "snippet": "LIBIMOBILEDEVICE_API debugserver_error_t debugserver_client_send(debugserver_client_t client, const char* data, uint32_t size, uint32_t *sent)\n{\n\tdebugserver_error_t res = DEBUGSERVER_E_UNKNOWN_ERROR;\n\tint bytes = 0;\n\n\tif (!client || !data || (size == 0)) {\n\t\treturn DEBUGSERVER_E_INVALID_ARG;\n\t}\n\n\tdebug_info(\"sending %d bytes\", size);\n\tres = debugserver_error(service_send(client->parent, data, size, (uint32_t*)&bytes));\n\tif (bytes <= 0) {\n\t\tdebug_info(\"ERROR: sending to device failed.\");\n\t}\n\tif (sent) {\n\t\t*sent = (uint32_t)bytes;\n\t}\n\n\treturn res;\n}",
          "includes": [
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/debug.h\"",
            "#include \"lockdown.h\"",
            "#include \"debugserver.h\"",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/debug.h\"\n#include \"lockdown.h\"\n#include \"debugserver.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API debugserver_error_t debugserver_client_send(debugserver_client_t client, const char* data, uint32_t size, uint32_t *sent)\n{\n\tdebugserver_error_t res = DEBUGSERVER_E_UNKNOWN_ERROR;\n\tint bytes = 0;\n\n\tif (!client || !data || (size == 0)) {\n\t\treturn DEBUGSERVER_E_INVALID_ARG;\n\t}\n\n\tdebug_info(\"sending %d bytes\", size);\n\tres = debugserver_error(service_send(client->parent, data, size, (uint32_t*)&bytes));\n\tif (bytes <= 0) {\n\t\tdebug_info(\"ERROR: sending to device failed.\");\n\t}\n\tif (sent) {\n\t\t*sent = (uint32_t)bytes;\n\t}\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Receive failed: %s\\n\"",
            "strerror(errno)"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket_receive_timeout",
          "args": [
            "socket_info->client_fd",
            "buffer",
            "sizeof(buffer)",
            "0",
            "5000"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "socket_receive_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/socket.c",
          "lines": "364-387",
          "snippet": "int socket_receive_timeout(int fd, void *data, size_t length, int flags,\n\t\t\t\t\t unsigned int timeout)\n{\n\tint res;\n\tint result;\n\n\t// check if data is available\n\tres = socket_check_fd(fd, FDM_READ, timeout);\n\tif (res <= 0) {\n\t\treturn res;\n\t}\n\t// if we get here, there _is_ data available\n\tresult = recv(fd, data, length, flags);\n\tif (res > 0 && result == 0) {\n\t\t// but this is an error condition\n\t\tif (verbose >= 3)\n\t\t\tfprintf(stderr, \"%s: fd=%d recv returned 0\\n\", __func__, fd);\n\t\treturn -EAGAIN;\n\t}\n\tif (result < 0) {\n\t\treturn -errno;\n\t}\n\treturn result;\n}",
          "includes": [
            "#include \"socket.h\"",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <windows.h>",
            "#include <winsock2.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int verbose = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"socket.h\"\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <windows.h>\n#include <winsock2.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdio.h>\n\nstatic int verbose = 0;\n\nint socket_receive_timeout(int fd, void *data, size_t length, int flags,\n\t\t\t\t\t unsigned int timeout)\n{\n\tint res;\n\tint result;\n\n\t// check if data is available\n\tres = socket_check_fd(fd, FDM_READ, timeout);\n\tif (res <= 0) {\n\t\treturn res;\n\t}\n\t// if we get here, there _is_ data available\n\tresult = recv(fd, data, length, flags);\n\tif (res > 0 && result == 0) {\n\t\t// but this is an error condition\n\t\tif (verbose >= 3)\n\t\t\tfprintf(stderr, \"%s: fd=%d recv returned 0\\n\", __func__, fd);\n\t\treturn -EAGAIN;\n\t}\n\tif (result < 0) {\n\t\treturn -errno;\n\t}\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Failed to start device to client thread...\\n\""
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread_new",
          "args": [
            "&dtoc",
            "thread_device_to_client",
            "data"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "thread_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "24-37",
          "snippet": "int thread_new(thread_t *thread, thread_func_t thread_func, void* data)\n{\n#ifdef WIN32\n\tHANDLE th = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)thread_func, data, 0, NULL);\n\tif (th == NULL) {\n\t\treturn -1;\n\t}\n\t*thread = th;\n\treturn 0;\n#else\n\tint res = pthread_create(thread, NULL, thread_func, data);\n\treturn res;\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nint thread_new(thread_t *thread, thread_func_t thread_func, void* data)\n{\n#ifdef WIN32\n\tHANDLE th = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)thread_func, data, 0, NULL);\n\tif (th == NULL) {\n\t\treturn -1;\n\t}\n\t*thread = th;\n\treturn 0;\n#else\n\tint res = pthread_create(thread, NULL, thread_func, data);\n\treturn res;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common/thread.h\"\n#include \"common/socket.h\"\n#include <libimobiledevice/debugserver.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <signal.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int quit_flag = 0;\n\nstatic void *thread_client_to_device(void *data)\n{\n\tsocket_info_t* socket_info = (socket_info_t*)data;\n\tdebugserver_error_t res = DEBUGSERVER_E_UNKNOWN_ERROR;\n\n\tint recv_len;\n\tint sent;\n\tchar buffer[131072];\n\tthread_t dtoc;\n\n\tdebug(\"%s: started thread...\\n\", __func__);\n\n\tdebug(\"%s: client_fd = %d\\n\", __func__, socket_info->client_fd);\n\n\t/* spawn server to client thread */\n\tsocket_info->stop_dtoc = 0;\n\tif (thread_new(&dtoc, thread_device_to_client, data) != 0) {\n\t\tfprintf(stderr, \"Failed to start device to client thread...\\n\");\n\t}\n\n\twhile (!quit_flag && !socket_info->stop_ctod && socket_info->client_fd > 0) {\n\t\tdebug(\"%s: receiving data from client...\\n\", __func__);\n\n\t\t/* attempt to read incoming data from client */\n\t\trecv_len = socket_receive_timeout(socket_info->client_fd, buffer, sizeof(buffer), 0, 5000);\n\n\t\t/* any data received? */\n\t\tif (recv_len <= 0) {\n\t\t\tif (recv_len == 0) {\n\t\t\t\t/* try again */\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"Receive failed: %s\\n\", strerror(errno));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t/* forward data to device */\n\t\t\tdebug(\"%s: sending data to device...\\n\", __func__);\n\t\t\tres = debugserver_client_send(socket_info->debugserver_client, buffer, recv_len, (uint32_t*)&sent);\n\n\t\t\tif (sent < recv_len || res != DEBUGSERVER_E_SUCCESS) {\n\t\t\t\tif (sent <= 0) {\n\t\t\t\t\tfprintf(stderr, \"send failed: %s\\n\", strerror(errno));\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"only sent %d from %d bytes\\n\", sent, recv_len);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// sending succeeded, receive from device\n\t\t\t\tdebug(\"%s: sent %d bytes to device\\n\", __func__, sent);\n\t\t\t}\n\t\t}\n\t}\n\n\tdebug(\"%s: shutting down...\\n\", __func__);\n\n\tsocket_shutdown(socket_info->client_fd, SHUT_RDWR);\n\tsocket_close(socket_info->client_fd);\n\n\tsocket_info->client_fd = -1;\n\tsocket_info->stop_dtoc = 1;\n\n\t/* join other thread to allow it to stop */\n\tthread_join(dtoc);\n\tthread_free(dtoc);\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "thread_device_to_client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicedebugserverproxy.c",
    "lines": "80-133",
    "snippet": "static void *thread_device_to_client(void *data)\n{\n\tsocket_info_t* socket_info = (socket_info_t*)data;\n\tdebugserver_error_t res = DEBUGSERVER_E_UNKNOWN_ERROR;\n\n\tint recv_len;\n\tint sent;\n\tchar buffer[131072];\n\n\tdebug(\"%s: started thread...\\n\", __func__);\n\n\tdebug(\"%s: client_fd = %d\\n\", __func__, socket_info->client_fd);\n\n\twhile (!quit_flag && !socket_info->stop_dtoc && socket_info->client_fd > 0) {\n\t\tdebug(\"%s: receiving data from device...\\n\", __func__);\n\n\t\tres = debugserver_client_receive_with_timeout(socket_info->debugserver_client, buffer, sizeof(buffer), (uint32_t*)&recv_len, 5000);\n\n\t\tif (recv_len <= 0) {\n\t\t\tif (recv_len == 0 && res == DEBUGSERVER_E_SUCCESS) {\n\t\t\t\t// try again\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"recv failed: %s\\n\", strerror(errno));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t/* send to device */\n\t\t\tdebug(\"%s: sending data to client...\\n\", __func__);\n\t\t\tsent = socket_send(socket_info->client_fd, buffer, recv_len);\n\t\t\tif (sent < recv_len) {\n\t\t\t\tif (sent <= 0) {\n\t\t\t\t\tfprintf(stderr, \"send failed: %s\\n\", strerror(errno));\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"only sent %d from %d bytes\\n\", sent, recv_len);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// sending succeeded, receive from device\n\t\t\t\tdebug(\"%s: pushed %d bytes to client\\n\", __func__, sent);\n\t\t\t}\n\t\t}\n\t}\n\n\tdebug(\"%s: shutting down...\\n\", __func__);\n\n\tsocket_shutdown(socket_info->client_fd, SHUT_RDWR);\n\tsocket_close(socket_info->client_fd);\n\n\tsocket_info->client_fd = -1;\n\tsocket_info->stop_ctod = 1;\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"common/thread.h\"",
      "#include \"common/socket.h\"",
      "#include <libimobiledevice/debugserver.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <signal.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int quit_flag = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "socket_close",
          "args": [
            "socket_info->client_fd"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "socket_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/socket.c",
          "lines": "346-352",
          "snippet": "int socket_close(int fd) {\n#ifdef WIN32\n\treturn closesocket(fd);\n#else\n\treturn close(fd);\n#endif\n}",
          "includes": [
            "#include \"socket.h\"",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <windows.h>",
            "#include <winsock2.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"socket.h\"\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <windows.h>\n#include <winsock2.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdio.h>\n\nint socket_close(int fd) {\n#ifdef WIN32\n\treturn closesocket(fd);\n#else\n\treturn close(fd);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "socket_shutdown",
          "args": [
            "socket_info->client_fd",
            "SHUT_RDWR"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "socket_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/socket.c",
          "lines": "341-344",
          "snippet": "int socket_shutdown(int fd, int how)\n{\n\treturn shutdown(fd, how);\n}",
          "includes": [
            "#include \"socket.h\"",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <windows.h>",
            "#include <winsock2.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"socket.h\"\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <windows.h>\n#include <winsock2.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdio.h>\n\nint socket_shutdown(int fd, int how)\n{\n\treturn shutdown(fd, how);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s: shutting down...\\n\"",
            "__func__"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "debug_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/debug.c",
          "lines": "101-134",
          "snippet": "void debug_buffer(const char *data, const int length)\n{\n#ifndef STRIP_DEBUG_CODE\n\tint i;\n\tint j;\n\tunsigned char c;\n\n\tif (debug_level) {\n\t\tfor (i = 0; i < length; i += 16) {\n\t\t\tfprintf(stderr, \"%04x: \", i);\n\t\t\tfor (j = 0; j < 16; j++) {\n\t\t\t\tif (i + j >= length) {\n\t\t\t\t\tfprintf(stderr, \"   \");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"%02x \", *(data + i + j) & 0xff);\n\t\t\t}\n\t\t\tfprintf(stderr, \"  | \");\n\t\t\tfor (j = 0; j < 16; j++) {\n\t\t\t\tif (i + j >= length)\n\t\t\t\t\tbreak;\n\t\t\t\tc = *(data + i + j);\n\t\t\t\tif ((c < 32) || (c > 127)) {\n\t\t\t\t\tfprintf(stderr, \".\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"%c\", c);\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t}\n\t\tfprintf(stderr, \"\\n\");\n\t}\n#endif\n}",
          "includes": [
            "#include \"asprintf.h\"",
            "#include \"src/idevice.h\"",
            "#include \"libimobiledevice/libimobiledevice.h\"",
            "#include \"debug.h\"",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <stdint.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int debug_level;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"asprintf.h\"\n#include \"src/idevice.h\"\n#include \"libimobiledevice/libimobiledevice.h\"\n#include \"debug.h\"\n#include <time.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int debug_level;\n\nvoid debug_buffer(const char *data, const int length)\n{\n#ifndef STRIP_DEBUG_CODE\n\tint i;\n\tint j;\n\tunsigned char c;\n\n\tif (debug_level) {\n\t\tfor (i = 0; i < length; i += 16) {\n\t\t\tfprintf(stderr, \"%04x: \", i);\n\t\t\tfor (j = 0; j < 16; j++) {\n\t\t\t\tif (i + j >= length) {\n\t\t\t\t\tfprintf(stderr, \"   \");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"%02x \", *(data + i + j) & 0xff);\n\t\t\t}\n\t\t\tfprintf(stderr, \"  | \");\n\t\t\tfor (j = 0; j < 16; j++) {\n\t\t\t\tif (i + j >= length)\n\t\t\t\t\tbreak;\n\t\t\t\tc = *(data + i + j);\n\t\t\t\tif ((c < 32) || (c > 127)) {\n\t\t\t\t\tfprintf(stderr, \".\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"%c\", c);\n\t\t\t}\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t}\n\t\tfprintf(stderr, \"\\n\");\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s: pushed %d bytes to client\\n\"",
            "__func__",
            "sent"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "debugserver_client_handle_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicedebug.c",
          "lines": "105-178",
          "snippet": "static debugserver_error_t debugserver_client_handle_response(debugserver_client_t client, char** response, int send_reply)\n{\n\tdebugserver_error_t dres = DEBUGSERVER_E_SUCCESS;\n\tdebugserver_command_t command = NULL;\n\tchar* o = NULL;\n\tchar* r = *response;\n\n\tif (r[0] == 'O') {\n\t\t/* stdout/stderr */\n\t\tdebugserver_decode_string(r + 1, strlen(r) - 1, &o);\n\t\tprintf(\"%s\", o);\n\t\tfflush(stdout);\n\t\tif (o != NULL) {\n\t\t\tfree(o);\n\t\t\to = NULL;\n\t\t}\n\n\t\tfree(*response);\n\t\t*response = NULL;\n\n\t\tif (!send_reply)\n\t\t\treturn dres;\n\n\t\t/* send reply */\n\t\tdebugserver_command_new(\"OK\", 0, NULL, &command);\n\t\tdres = debugserver_client_send_command(client, command, response);\n\t\tdebug_info(\"result: %d\", dres);\n\t\tdebugserver_command_free(command);\n\t\tcommand = NULL;\n\t} else if (r[0] == 'T') {\n\t\t/* thread stopped information */\n\t\tdebug_info(\"Thread stopped. Details:\\n%s\", r + 1);\n\n\t\tfree(*response);\n\t\t*response = NULL;\n\n\t\tif (!send_reply)\n\t\t\treturn dres;\n\n\t\tdres = DEBUGSERVER_E_UNKNOWN_ERROR;\n\t} else if (r[0] == 'E' || r[0] == 'W') {\n\t\tprintf(\"%s: %s\\n\", (r[0] == 'E' ? \"ERROR\": \"WARNING\") , r + 1);\n\n\t\tfree(*response);\n\t\t*response = NULL;\n\n\t\tif (!send_reply)\n\t\t\treturn dres;\n\n\t\t/* send reply */\n\t\tdebugserver_command_new(\"OK\", 0, NULL, &command);\n\t\tdres = debugserver_client_send_command(client, command, response);\n\t\tdebug_info(\"result: %d\", dres);\n\t\tdebugserver_command_free(command);\n\t\tcommand = NULL;\n\t} else if (r && strlen(r) == 0) {\n\t\tif (!send_reply)\n\t\t\treturn dres;\n\n\t\tfree(*response);\n\t\t*response = NULL;\n\n\t\t/* no command */\n\t\tdebugserver_command_new(\"OK\", 0, NULL, &command);\n\t\tdres = debugserver_client_send_command(client, command, response);\n\t\tdebug_info(\"result: %d\", dres);\n\t\tdebugserver_command_free(command);\n\t\tcommand = NULL;\n\t} else {\n\t\tdebug_info(\"ERROR: unhandled response\", r);\n\t}\n\n\treturn dres;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include <plist/plist.h>",
            "#include <libimobiledevice/debugserver.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <libimobiledevice/installation_proxy.h>",
            "#include <windows.h>",
            "#include <libgen.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include <plist/plist.h>\n#include <libimobiledevice/debugserver.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <libimobiledevice/installation_proxy.h>\n#include <windows.h>\n#include <libgen.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <config.h>\n\nstatic debugserver_error_t debugserver_client_handle_response(debugserver_client_t client, char** response, int send_reply)\n{\n\tdebugserver_error_t dres = DEBUGSERVER_E_SUCCESS;\n\tdebugserver_command_t command = NULL;\n\tchar* o = NULL;\n\tchar* r = *response;\n\n\tif (r[0] == 'O') {\n\t\t/* stdout/stderr */\n\t\tdebugserver_decode_string(r + 1, strlen(r) - 1, &o);\n\t\tprintf(\"%s\", o);\n\t\tfflush(stdout);\n\t\tif (o != NULL) {\n\t\t\tfree(o);\n\t\t\to = NULL;\n\t\t}\n\n\t\tfree(*response);\n\t\t*response = NULL;\n\n\t\tif (!send_reply)\n\t\t\treturn dres;\n\n\t\t/* send reply */\n\t\tdebugserver_command_new(\"OK\", 0, NULL, &command);\n\t\tdres = debugserver_client_send_command(client, command, response);\n\t\tdebug_info(\"result: %d\", dres);\n\t\tdebugserver_command_free(command);\n\t\tcommand = NULL;\n\t} else if (r[0] == 'T') {\n\t\t/* thread stopped information */\n\t\tdebug_info(\"Thread stopped. Details:\\n%s\", r + 1);\n\n\t\tfree(*response);\n\t\t*response = NULL;\n\n\t\tif (!send_reply)\n\t\t\treturn dres;\n\n\t\tdres = DEBUGSERVER_E_UNKNOWN_ERROR;\n\t} else if (r[0] == 'E' || r[0] == 'W') {\n\t\tprintf(\"%s: %s\\n\", (r[0] == 'E' ? \"ERROR\": \"WARNING\") , r + 1);\n\n\t\tfree(*response);\n\t\t*response = NULL;\n\n\t\tif (!send_reply)\n\t\t\treturn dres;\n\n\t\t/* send reply */\n\t\tdebugserver_command_new(\"OK\", 0, NULL, &command);\n\t\tdres = debugserver_client_send_command(client, command, response);\n\t\tdebug_info(\"result: %d\", dres);\n\t\tdebugserver_command_free(command);\n\t\tcommand = NULL;\n\t} else if (r && strlen(r) == 0) {\n\t\tif (!send_reply)\n\t\t\treturn dres;\n\n\t\tfree(*response);\n\t\t*response = NULL;\n\n\t\t/* no command */\n\t\tdebugserver_command_new(\"OK\", 0, NULL, &command);\n\t\tdres = debugserver_client_send_command(client, command, response);\n\t\tdebug_info(\"result: %d\", dres);\n\t\tdebugserver_command_free(command);\n\t\tcommand = NULL;\n\t} else {\n\t\tdebug_info(\"ERROR: unhandled response\", r);\n\t}\n\n\treturn dres;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"only sent %d from %d bytes\\n\"",
            "sent",
            "recv_len"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"send failed: %s\\n\"",
            "strerror(errno)"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket_send",
          "args": [
            "socket_info->client_fd",
            "buffer",
            "recv_len"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "socket_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/socket.c",
          "lines": "389-392",
          "snippet": "int socket_send(int fd, void *data, size_t length)\n{\n\treturn send(fd, data, length, 0);\n}",
          "includes": [
            "#include \"socket.h\"",
            "#include <arpa/inet.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <windows.h>",
            "#include <winsock2.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"socket.h\"\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <windows.h>\n#include <winsock2.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <errno.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdio.h>\n\nint socket_send(int fd, void *data, size_t length)\n{\n\treturn send(fd, data, length, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"recv failed: %s\\n\"",
            "strerror(errno)"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugserver_client_receive_with_timeout",
          "args": [
            "socket_info->debugserver_client",
            "buffer",
            "sizeof(buffer)",
            "(uint32_t*)&recv_len",
            "5000"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "debugserver_client_receive_with_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/debugserver.c",
          "lines": "131-149",
          "snippet": "LIBIMOBILEDEVICE_API debugserver_error_t debugserver_client_receive_with_timeout(debugserver_client_t client, char* data, uint32_t size, uint32_t *received, unsigned int timeout)\n{\n\tdebugserver_error_t res = DEBUGSERVER_E_UNKNOWN_ERROR;\n\tint bytes = 0;\n\n\tif (!client || !data || (size == 0)) {\n\t\treturn DEBUGSERVER_E_INVALID_ARG;\n\t}\n\n\tres = debugserver_error(service_receive_with_timeout(client->parent, data, size, (uint32_t*)&bytes, timeout));\n\tif (bytes <= 0) {\n\t\tdebug_info(\"Could not read data, error %d\", res);\n\t}\n\tif (received) {\n\t\t*received = (uint32_t)bytes;\n\t}\n\n\treturn res;\n}",
          "includes": [
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/debug.h\"",
            "#include \"lockdown.h\"",
            "#include \"debugserver.h\"",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/debug.h\"\n#include \"lockdown.h\"\n#include \"debugserver.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API debugserver_error_t debugserver_client_receive_with_timeout(debugserver_client_t client, char* data, uint32_t size, uint32_t *received, unsigned int timeout)\n{\n\tdebugserver_error_t res = DEBUGSERVER_E_UNKNOWN_ERROR;\n\tint bytes = 0;\n\n\tif (!client || !data || (size == 0)) {\n\t\treturn DEBUGSERVER_E_INVALID_ARG;\n\t}\n\n\tres = debugserver_error(service_receive_with_timeout(client->parent, data, size, (uint32_t*)&bytes, timeout));\n\tif (bytes <= 0) {\n\t\tdebug_info(\"Could not read data, error %d\", res);\n\t}\n\tif (received) {\n\t\t*received = (uint32_t)bytes;\n\t}\n\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common/thread.h\"\n#include \"common/socket.h\"\n#include <libimobiledevice/debugserver.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <signal.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int quit_flag = 0;\n\nstatic void *thread_device_to_client(void *data)\n{\n\tsocket_info_t* socket_info = (socket_info_t*)data;\n\tdebugserver_error_t res = DEBUGSERVER_E_UNKNOWN_ERROR;\n\n\tint recv_len;\n\tint sent;\n\tchar buffer[131072];\n\n\tdebug(\"%s: started thread...\\n\", __func__);\n\n\tdebug(\"%s: client_fd = %d\\n\", __func__, socket_info->client_fd);\n\n\twhile (!quit_flag && !socket_info->stop_dtoc && socket_info->client_fd > 0) {\n\t\tdebug(\"%s: receiving data from device...\\n\", __func__);\n\n\t\tres = debugserver_client_receive_with_timeout(socket_info->debugserver_client, buffer, sizeof(buffer), (uint32_t*)&recv_len, 5000);\n\n\t\tif (recv_len <= 0) {\n\t\t\tif (recv_len == 0 && res == DEBUGSERVER_E_SUCCESS) {\n\t\t\t\t// try again\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"recv failed: %s\\n\", strerror(errno));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t/* send to device */\n\t\t\tdebug(\"%s: sending data to client...\\n\", __func__);\n\t\t\tsent = socket_send(socket_info->client_fd, buffer, recv_len);\n\t\t\tif (sent < recv_len) {\n\t\t\t\tif (sent <= 0) {\n\t\t\t\t\tfprintf(stderr, \"send failed: %s\\n\", strerror(errno));\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"only sent %d from %d bytes\\n\", sent, recv_len);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// sending succeeded, receive from device\n\t\t\t\tdebug(\"%s: pushed %d bytes to client\\n\", __func__, sent);\n\t\t\t}\n\t\t}\n\t}\n\n\tdebug(\"%s: shutting down...\\n\", __func__);\n\n\tsocket_shutdown(socket_info->client_fd, SHUT_RDWR);\n\tsocket_close(socket_info->client_fd);\n\n\tsocket_info->client_fd = -1;\n\tsocket_info->stop_ctod = 1;\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "print_usage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicedebugserverproxy.c",
    "lines": "66-78",
    "snippet": "static void print_usage(int argc, char **argv)\n{\n\tchar *name = NULL;\n\n\tname = strrchr(argv[0], '/');\n\tprintf(\"Usage: %s [OPTIONS] <PORT>\\n\", (name ? name + 1: argv[0]));\n\tprintf(\"Proxy debugserver connection from device to a local socket at PORT.\\n\\n\");\n\tprintf(\"  -d, --debug\\t\\tenable communication debugging\\n\");\n\tprintf(\"  -u, --udid UDID\\ttarget specific device by its 40-digit device UDID\\n\");\n\tprintf(\"  -h, --help\\t\\tprints usage information\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"Homepage: <\" PACKAGE_URL \">\\n\");\n}",
    "includes": [
      "#include \"common/thread.h\"",
      "#include \"common/socket.h\"",
      "#include <libimobiledevice/debugserver.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <signal.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Homepage: <\" PACKAGE_URL \">\\n\""
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  -h, --help\\t\\tprints usage information\\n\""
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  -u, --udid UDID\\ttarget specific device by its 40-digit device UDID\\n\""
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  -d, --debug\\t\\tenable communication debugging\\n\""
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Proxy debugserver connection from device to a local socket at PORT.\\n\\n\""
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Usage: %s [OPTIONS] <PORT>\\n\"",
            "(name ? name + 1: argv[0])"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "asprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/include/asprintf.h",
          "lines": "23-31",
          "snippet": "static inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}",
          "includes": [
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <config.h>\n\nstatic inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "argv[0]",
            "'/'"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common/thread.h\"\n#include \"common/socket.h\"\n#include <libimobiledevice/debugserver.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <signal.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void print_usage(int argc, char **argv)\n{\n\tchar *name = NULL;\n\n\tname = strrchr(argv[0], '/');\n\tprintf(\"Usage: %s [OPTIONS] <PORT>\\n\", (name ? name + 1: argv[0]));\n\tprintf(\"Proxy debugserver connection from device to a local socket at PORT.\\n\\n\");\n\tprintf(\"  -d, --debug\\t\\tenable communication debugging\\n\");\n\tprintf(\"  -u, --udid UDID\\ttarget specific device by its 40-digit device UDID\\n\");\n\tprintf(\"  -h, --help\\t\\tprints usage information\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"Homepage: <\" PACKAGE_URL \">\\n\");\n}"
  },
  {
    "function_name": "clean_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicedebugserverproxy.c",
    "lines": "60-64",
    "snippet": "static void clean_exit(int sig)\n{\n\tfprintf(stderr, \"Exiting...\\n\");\n\tquit_flag++;\n}",
    "includes": [
      "#include \"common/thread.h\"",
      "#include \"common/socket.h\"",
      "#include <libimobiledevice/debugserver.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <signal.h>",
      "#include <errno.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int quit_flag = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Exiting...\\n\""
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common/thread.h\"\n#include \"common/socket.h\"\n#include <libimobiledevice/debugserver.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <signal.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int quit_flag = 0;\n\nstatic void clean_exit(int sig)\n{\n\tfprintf(stderr, \"Exiting...\\n\");\n\tquit_flag++;\n}"
  }
]