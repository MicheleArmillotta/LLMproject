[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicedebug.c",
    "lines": "198-516",
    "snippet": "int main(int argc, char *argv[])\n{\n\tint res = -1;\n\tidevice_t device = NULL;\n\tidevice_error_t ret = IDEVICE_E_UNKNOWN_ERROR;\n\tinstproxy_client_t instproxy_client = NULL;\n\tdebugserver_client_t debugserver_client = NULL;\n\tint i;\n\tint debug_level = 0;\n\tint cmd = CMD_NONE;\n\tconst char* udid = NULL;\n\tconst char* bundle_identifier = NULL;\n\tchar* path = NULL;\n\tchar* working_directory = NULL;\n\tchar **newlist = NULL;\n\tchar** environment = NULL;\n\tint environment_index = 0;\n\tint environment_count = 0;\n\tchar* response = NULL;\n\tdebugserver_command_t command = NULL;\n\tdebugserver_error_t dres = DEBUGSERVER_E_UNKNOWN_ERROR;\n\n\t/* map signals */\n\tsignal(SIGINT, on_signal);\n\tsignal(SIGTERM, on_signal);\n#ifndef WIN32\n\tsignal(SIGQUIT, on_signal);\n\tsignal(SIGPIPE, SIG_IGN);\n#endif\n\n\t/* parse command line arguments */\n\tfor (i = 1; i < argc; i++) {\n\t\tif (!strcmp(argv[i], \"-d\") || !strcmp(argv[i], \"--debug\")) {\n\t\t\tdebug_level++;\n\t\t\tidevice_set_debug_level(debug_level);\n\t\t\tcontinue;\n\t\t} else if (!strcmp(argv[i], \"-u\") || !strcmp(argv[i], \"--udid\")) {\n\t\t\ti++;\n\t\t\tif (!argv[i] || (strlen(argv[i]) != 40)) {\n\t\t\t\tprint_usage(argc, argv);\n\t\t\t\tres = 0;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tudid = argv[i];\n\t\t\tcontinue;\n\t\t} else if (!strcmp(argv[i], \"-e\") || !strcmp(argv[i], \"--env\")) {\n\t\t\ti++;\n\t\t\tif (!argv[i] || (strlen(argv[i]) <= 1) || strchr(argv[i], '=') == NULL) {\n\t\t\t\tprint_usage(argc, argv);\n\t\t\t\tres = 0;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\t/* add environment variable */\n\t\t\tif (!newlist)\n\t\t\t\tnewlist = malloc((environment_count + 1) * sizeof(char*));\n\t\t\telse\n\t\t\t\tnewlist = realloc(environment, (environment_count + 1) * sizeof(char*));\n\t\t\tnewlist[environment_count++] = strdup(argv[i]);\n\t\t\tenvironment = newlist;\n\t\t\tcontinue;\n\t\t} else if (!strcmp(argv[i], \"-h\") || !strcmp(argv[i], \"--help\")) {\n\t\t\tprint_usage(argc, argv);\n\t\t\tres = 0;\n\t\t\tgoto cleanup;\n\t\t} else if (!strcmp(argv[i], \"run\")) {\n\t\t\tcmd = CMD_RUN;\n\n\t\t\ti++;\n\t\t\tif (!argv[i]) {\n\t\t\t\t/* make sure at least the bundle identifier was provided */\n\t\t\t\tprintf(\"Please supply the bundle identifier of the app to run.\\n\");\n\t\t\t\tprint_usage(argc, argv);\n\t\t\t\tres = 0;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\t/*  read bundle identifier */\n\t\t\tbundle_identifier = argv[i];\n\t\t\tbreak;\n\t\t} else {\n\t\t\tprint_usage(argc, argv);\n\t\t\tres = 0;\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tif (environment) {\n\t\tnewlist = realloc(environment, (environment_count + 1) * sizeof(char*));\n\t\tnewlist[environment_count] = NULL;\n\t\tenvironment = newlist;\n\t}\n\n\t/* verify options */\n\tif (cmd == CMD_NONE) {\n\t\tprint_usage(argc, argv);\n\t\tgoto cleanup;\n\t}\n\n\t/* connect to the device */\n\tret = idevice_new(&device, udid);\n\tif (ret != IDEVICE_E_SUCCESS) {\n\t\tif (udid) {\n\t\t\tprintf(\"No device found with udid %s, is it plugged in?\\n\", udid);\n\t\t} else {\n\t\t\tprintf(\"No device found, is it plugged in?\\n\");\n\t\t}\n\t\tgoto cleanup;\n\t}\n\n\tswitch (cmd) {\n\t\tcase CMD_RUN:\n\t\tdefault:\n\t\t\t/* get the path to the app and it's working directory */\n\t\t\tif (instproxy_client_start_service(device, &instproxy_client, \"idevicerun\") != INSTPROXY_E_SUCCESS) {\n\t\t\t\tfprintf(stderr, \"Could not start installation proxy service.\\n\");\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tplist_t container = NULL;\n\t\t\tinstproxy_client_get_object_by_key_from_info_directionary_for_bundle_identifier(instproxy_client, bundle_identifier, \"Container\", &container);\n\t\t\tinstproxy_client_get_path_for_bundle_identifier(instproxy_client, bundle_identifier, &path);\n\t\t\tinstproxy_client_free(instproxy_client);\n\t\t\tinstproxy_client = NULL;\n\n\t\t\tif (container) {\n\t\t\t\tif (plist_get_node_type(container) == PLIST_STRING) {\n\t\t\t\t\tplist_get_string_val(container, &working_directory);\n\t\t\t\t\tdebug_info(\"working_directory: %s\\n\", working_directory);\n\t\t\t\t\tplist_free(container);\n\t\t\t\t} else {\n\t\t\t\t\t\tplist_free(container);\n\t\t\t\t\tfprintf(stderr, \"Could not determine container path for bundle identifier %s.\\n\", bundle_identifier);\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* start and connect to debugserver */\n\t\t\tif (debugserver_client_start_service(device, &debugserver_client, \"idevicerun\") != DEBUGSERVER_E_SUCCESS) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"Could not start com.apple.debugserver!\\n\"\n\t\t\t\t\t\"Please make sure to mount the developer disk image first:\\n\"\n\t\t\t\t\t\"  1) Get the iOS version from `ideviceinfo -k ProductVersion`.\\n\"\n\t\t\t\t\t\"  2) Find the matching iPhoneOS DeveloperDiskImage.dmg files.\\n\"\n\t\t\t\t\t\"  3) Run `ideviceimagemounter` with the above path.\\n\");\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\n\t\t\t/* enable logging for the session in debug mode */\n\t\t\tif (debug_level) {\n\t\t\t\tdebug_info(\"Setting logging bitmask...\");\n\t\t\t\tdebugserver_command_new(\"QSetLogging:bitmask=LOG_ALL|LOG_RNB_REMOTE|LOG_RNB_PACKETS\", 0, NULL, &command);\n\t\t\t\tdres = debugserver_client_send_command(debugserver_client, command, &response);\n\t\t\t\tdebugserver_command_free(command);\n\t\t\t\tcommand = NULL;\n\t\t\t\tif (response) {\n\t\t\t\t\tif (strncmp(response, \"OK\", 2)) {\n\t\t\t\t\t\tdebugserver_client_handle_response(debugserver_client, &response, 0);\n\t\t\t\t\t\tgoto cleanup;\n\t\t\t\t\t}\n\t\t\t\t\tfree(response);\n\t\t\t\t\tresponse = NULL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* set maximum packet size */\n\t\t\tdebug_info(\"Setting maximum packet size...\");\n\t\t\tchar* packet_size[2] = {strdup(\"1024\"), NULL};\n\t\t\tdebugserver_command_new(\"QSetMaxPacketSize:\", 1, packet_size, &command);\n\t\t\tfree(packet_size[0]);\n\t\t\tdres = debugserver_client_send_command(debugserver_client, command, &response);\n\t\t\tdebugserver_command_free(command);\n\t\t\tcommand = NULL;\n\t\t\tif (response) {\n\t\t\t\tif (strncmp(response, \"OK\", 2)) {\n\t\t\t\t\tdebugserver_client_handle_response(debugserver_client, &response, 0);\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tfree(response);\n\t\t\t\tresponse = NULL;\n\t\t\t}\n\n\t\t\t/* set working directory */\n\t\t\tdebug_info(\"Setting working directory...\");\n\t\t\tchar* working_dir[2] = {working_directory, NULL};\n\t\t\tdebugserver_command_new(\"QSetWorkingDir:\", 1, working_dir, &command);\n\t\t\tdres = debugserver_client_send_command(debugserver_client, command, &response);\n\t\t\tdebugserver_command_free(command);\n\t\t\tcommand = NULL;\n\t\t\tif (response) {\n\t\t\t\tif (strncmp(response, \"OK\", 2)) {\n\t\t\t\t\tdebugserver_client_handle_response(debugserver_client, &response, 0);\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tfree(response);\n\t\t\t\tresponse = NULL;\n\t\t\t}\n\n\t\t\t/* set environment */\n\t\t\tif (environment) {\n\t\t\t\tdebug_info(\"Setting environment...\");\n\t\t\t\tfor (environment_index = 0; environment_index < environment_count; environment_index++) {\n\t\t\t\t\tdebug_info(\"setting environment variable: %s\", environment[environment_index]);\n\t\t\t\t\tdebugserver_client_set_environment_hex_encoded(debugserver_client, environment[environment_index], NULL);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* set arguments and run app */\n\t\t\tdebug_info(\"Setting argv...\");\n\t\t\ti++; /* i is the offset of the bundle identifier, thus skip it */\n\t\t\tint app_argc = (argc - i + 2);\n\t\t\tchar **app_argv = (char**)malloc(sizeof(char*) * app_argc);\n\t\t\tapp_argv[0] = path;\n\t\t\tdebug_info(\"app_argv[%d] = %s\", 0, app_argv[0]);\n\t\t\tapp_argc = 1;\n\t\t\twhile (i < argc && argv && argv[i]) {\n\t\t\t\tdebug_info(\"app_argv[%d] = %s\", app_argc, argv[i]);\n\t\t\t\tapp_argv[app_argc++] = argv[i];\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tapp_argv[app_argc] = NULL;\n\t\t\tdebugserver_client_set_argv(debugserver_client, app_argc, app_argv, NULL);\n\t\t\tfree(app_argv);\n\n\t\t\t/* check if launch succeeded */\n\t\t\tdebug_info(\"Checking if launch succeeded...\");\n\t\t\tdebugserver_command_new(\"qLaunchSuccess\", 0, NULL, &command);\n\t\t\tdres = debugserver_client_send_command(debugserver_client, command, &response);\n\t\t\tdebugserver_command_free(command);\n\t\t\tcommand = NULL;\n\t\t\tif (response) {\n\t\t\t\tif (strncmp(response, \"OK\", 2)) {\n\t\t\t\t\tdebugserver_client_handle_response(debugserver_client, &response, 0);\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tfree(response);\n\t\t\t\tresponse = NULL;\n\t\t\t}\n\n\t\t\t/* set thread */\n\t\t\tdebug_info(\"Setting thread...\");\n\t\t\tdebugserver_command_new(\"Hc0\", 0, NULL, &command);\n\t\t\tdres = debugserver_client_send_command(debugserver_client, command, &response);\n\t\t\tdebugserver_command_free(command);\n\t\t\tcommand = NULL;\n\t\t\tif (response) {\n\t\t\t\tif (strncmp(response, \"OK\", 2)) {\n\t\t\t\t\tdebugserver_client_handle_response(debugserver_client, &response, 0);\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tfree(response);\n\t\t\t\tresponse = NULL;\n\t\t\t}\n\n\t\t\t/* continue running process */\n\t\t\tdebug_info(\"Continue running process...\");\n\t\t\tdebugserver_command_new(\"c\", 0, NULL, &command);\n\t\t\tdres = debugserver_client_send_command(debugserver_client, command, &response);\n\t\t\tdebugserver_command_free(command);\n\t\t\tcommand = NULL;\n\n\t\t\t/* main loop which is parsing/handling packets during the run */\n\t\t\tdebug_info(\"Entering run loop...\");\n\t\t\twhile (!quit_flag) {\n\t\t\t\tif (dres != DEBUGSERVER_E_SUCCESS) {\n\t\t\t\t\tdebug_info(\"failed to receive response\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (response) {\n\t\t\t\t\tdebug_info(\"response: %s\", response);\n\t\t\t\t\tdres = debugserver_client_handle_response(debugserver_client, &response, 1);\n\t\t\t\t}\n\n\t\t\t\tsleep(1);\n\t\t\t}\n\n\t\t\t/* kill process after we finished */\n\t\t\tdebug_info(\"Killing process...\");\n\t\t\tdebugserver_command_new(\"k\", 0, NULL, &command);\n\t\t\tdres = debugserver_client_send_command(debugserver_client, command, &response);\n\t\t\tdebugserver_command_free(command);\n\t\t\tcommand = NULL;\n\t\t\tif (response) {\n\t\t\t\tif (strncmp(response, \"OK\", 2)) {\n\t\t\t\t\tdebugserver_client_handle_response(debugserver_client, &response, 0);\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tfree(response);\n\t\t\t\tresponse = NULL;\n\t\t\t}\n\n\t\t\tres = (dres == DEBUGSERVER_E_SUCCESS) ? 0: -1;\n\t\tbreak;\n\t}\n\ncleanup:\n\t/* cleanup the house */\n\tif (environment) {\n\t\tfor (environment_index = 0; environment_index < environment_count; environment_index++) {\n\t\t\tfree(environment[environment_index]);\n\t\t}\n\t\tfree(environment);\n\t}\n\n\tif (working_directory)\n\t\tfree(working_directory);\n\n\tif (path)\n\t\tfree(path);\n\n\tif (response)\n\t\tfree(response);\n\n\tif (debugserver_client)\n\t\tdebugserver_client_free(debugserver_client);\n\n\tif (device)\n\t\tidevice_free(device);\n\n\treturn res;\n}",
    "includes": [
      "#include \"common/debug.h\"",
      "#include <plist/plist.h>",
      "#include <libimobiledevice/debugserver.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <libimobiledevice/installation_proxy.h>",
      "#include <windows.h>",
      "#include <libgen.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int quit_flag = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "idevice_free",
          "args": [
            "device"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "idevice_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
          "lines": "247-265",
          "snippet": "LIBIMOBILEDEVICE_API idevice_error_t idevice_free(idevice_t device)\n{\n\tif (!device)\n\t\treturn IDEVICE_E_INVALID_ARG;\n\tidevice_error_t ret = IDEVICE_E_UNKNOWN_ERROR;\n\n\tret = IDEVICE_E_SUCCESS;\n\n\tfree(device->udid);\n\n\tif (device->conn_type == CONNECTION_USBMUXD) {\n\t\tdevice->conn_data = 0;\n\t}\n\tif (device->conn_data) {\n\t\tfree(device->conn_data);\n\t}\n\tfree(device);\n\treturn ret;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"common/thread.h\"",
            "#include \"common/userpref.h\"",
            "#include \"idevice.h\"",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <usbmuxd.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "LIBIMOBILEDEVICE_API idevice_error_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nLIBIMOBILEDEVICE_API idevice_error_t idevice_free(idevice_t device)\n{\n\tif (!device)\n\t\treturn IDEVICE_E_INVALID_ARG;\n\tidevice_error_t ret = IDEVICE_E_UNKNOWN_ERROR;\n\n\tret = IDEVICE_E_SUCCESS;\n\n\tfree(device->udid);\n\n\tif (device->conn_type == CONNECTION_USBMUXD) {\n\t\tdevice->conn_data = 0;\n\t}\n\tif (device->conn_data) {\n\t\tfree(device->conn_data);\n\t}\n\tfree(device);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugserver_client_free",
          "args": [
            "debugserver_client"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "debugserver_client_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/debugserver.c",
          "lines": "98-108",
          "snippet": "LIBIMOBILEDEVICE_API debugserver_error_t debugserver_client_free(debugserver_client_t client)\n{\n\tif (!client)\n\t\treturn DEBUGSERVER_E_INVALID_ARG;\n\n\tdebugserver_error_t err = debugserver_error(service_client_free(client->parent));\n\tclient->parent = NULL;\n\tfree(client);\n\n\treturn err;\n}",
          "includes": [
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/debug.h\"",
            "#include \"lockdown.h\"",
            "#include \"debugserver.h\"",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/debug.h\"\n#include \"lockdown.h\"\n#include \"debugserver.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API debugserver_error_t debugserver_client_free(debugserver_client_t client)\n{\n\tif (!client)\n\t\treturn DEBUGSERVER_E_INVALID_ARG;\n\n\tdebugserver_error_t err = debugserver_error(service_client_free(client->parent));\n\tclient->parent = NULL;\n\tfree(client);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "response"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "thread_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "39-44",
          "snippet": "void thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nvoid thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugserver_client_handle_response",
          "args": [
            "debugserver_client",
            "&response",
            "0"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "debugserver_client_handle_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicedebug.c",
          "lines": "105-178",
          "snippet": "static debugserver_error_t debugserver_client_handle_response(debugserver_client_t client, char** response, int send_reply)\n{\n\tdebugserver_error_t dres = DEBUGSERVER_E_SUCCESS;\n\tdebugserver_command_t command = NULL;\n\tchar* o = NULL;\n\tchar* r = *response;\n\n\tif (r[0] == 'O') {\n\t\t/* stdout/stderr */\n\t\tdebugserver_decode_string(r + 1, strlen(r) - 1, &o);\n\t\tprintf(\"%s\", o);\n\t\tfflush(stdout);\n\t\tif (o != NULL) {\n\t\t\tfree(o);\n\t\t\to = NULL;\n\t\t}\n\n\t\tfree(*response);\n\t\t*response = NULL;\n\n\t\tif (!send_reply)\n\t\t\treturn dres;\n\n\t\t/* send reply */\n\t\tdebugserver_command_new(\"OK\", 0, NULL, &command);\n\t\tdres = debugserver_client_send_command(client, command, response);\n\t\tdebug_info(\"result: %d\", dres);\n\t\tdebugserver_command_free(command);\n\t\tcommand = NULL;\n\t} else if (r[0] == 'T') {\n\t\t/* thread stopped information */\n\t\tdebug_info(\"Thread stopped. Details:\\n%s\", r + 1);\n\n\t\tfree(*response);\n\t\t*response = NULL;\n\n\t\tif (!send_reply)\n\t\t\treturn dres;\n\n\t\tdres = DEBUGSERVER_E_UNKNOWN_ERROR;\n\t} else if (r[0] == 'E' || r[0] == 'W') {\n\t\tprintf(\"%s: %s\\n\", (r[0] == 'E' ? \"ERROR\": \"WARNING\") , r + 1);\n\n\t\tfree(*response);\n\t\t*response = NULL;\n\n\t\tif (!send_reply)\n\t\t\treturn dres;\n\n\t\t/* send reply */\n\t\tdebugserver_command_new(\"OK\", 0, NULL, &command);\n\t\tdres = debugserver_client_send_command(client, command, response);\n\t\tdebug_info(\"result: %d\", dres);\n\t\tdebugserver_command_free(command);\n\t\tcommand = NULL;\n\t} else if (r && strlen(r) == 0) {\n\t\tif (!send_reply)\n\t\t\treturn dres;\n\n\t\tfree(*response);\n\t\t*response = NULL;\n\n\t\t/* no command */\n\t\tdebugserver_command_new(\"OK\", 0, NULL, &command);\n\t\tdres = debugserver_client_send_command(client, command, response);\n\t\tdebug_info(\"result: %d\", dres);\n\t\tdebugserver_command_free(command);\n\t\tcommand = NULL;\n\t} else {\n\t\tdebug_info(\"ERROR: unhandled response\", r);\n\t}\n\n\treturn dres;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include <plist/plist.h>",
            "#include <libimobiledevice/debugserver.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <libimobiledevice/installation_proxy.h>",
            "#include <windows.h>",
            "#include <libgen.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include <plist/plist.h>\n#include <libimobiledevice/debugserver.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <libimobiledevice/installation_proxy.h>\n#include <windows.h>\n#include <libgen.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <config.h>\n\nstatic debugserver_error_t debugserver_client_handle_response(debugserver_client_t client, char** response, int send_reply)\n{\n\tdebugserver_error_t dres = DEBUGSERVER_E_SUCCESS;\n\tdebugserver_command_t command = NULL;\n\tchar* o = NULL;\n\tchar* r = *response;\n\n\tif (r[0] == 'O') {\n\t\t/* stdout/stderr */\n\t\tdebugserver_decode_string(r + 1, strlen(r) - 1, &o);\n\t\tprintf(\"%s\", o);\n\t\tfflush(stdout);\n\t\tif (o != NULL) {\n\t\t\tfree(o);\n\t\t\to = NULL;\n\t\t}\n\n\t\tfree(*response);\n\t\t*response = NULL;\n\n\t\tif (!send_reply)\n\t\t\treturn dres;\n\n\t\t/* send reply */\n\t\tdebugserver_command_new(\"OK\", 0, NULL, &command);\n\t\tdres = debugserver_client_send_command(client, command, response);\n\t\tdebug_info(\"result: %d\", dres);\n\t\tdebugserver_command_free(command);\n\t\tcommand = NULL;\n\t} else if (r[0] == 'T') {\n\t\t/* thread stopped information */\n\t\tdebug_info(\"Thread stopped. Details:\\n%s\", r + 1);\n\n\t\tfree(*response);\n\t\t*response = NULL;\n\n\t\tif (!send_reply)\n\t\t\treturn dres;\n\n\t\tdres = DEBUGSERVER_E_UNKNOWN_ERROR;\n\t} else if (r[0] == 'E' || r[0] == 'W') {\n\t\tprintf(\"%s: %s\\n\", (r[0] == 'E' ? \"ERROR\": \"WARNING\") , r + 1);\n\n\t\tfree(*response);\n\t\t*response = NULL;\n\n\t\tif (!send_reply)\n\t\t\treturn dres;\n\n\t\t/* send reply */\n\t\tdebugserver_command_new(\"OK\", 0, NULL, &command);\n\t\tdres = debugserver_client_send_command(client, command, response);\n\t\tdebug_info(\"result: %d\", dres);\n\t\tdebugserver_command_free(command);\n\t\tcommand = NULL;\n\t} else if (r && strlen(r) == 0) {\n\t\tif (!send_reply)\n\t\t\treturn dres;\n\n\t\tfree(*response);\n\t\t*response = NULL;\n\n\t\t/* no command */\n\t\tdebugserver_command_new(\"OK\", 0, NULL, &command);\n\t\tdres = debugserver_client_send_command(client, command, response);\n\t\tdebug_info(\"result: %d\", dres);\n\t\tdebugserver_command_free(command);\n\t\tcommand = NULL;\n\t} else {\n\t\tdebug_info(\"ERROR: unhandled response\", r);\n\t}\n\n\treturn dres;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "response",
            "\"OK\"",
            "2"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugserver_command_free",
          "args": [
            "command"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "debugserver_command_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/debugserver.c",
          "lines": "181-203",
          "snippet": "LIBIMOBILEDEVICE_API debugserver_error_t debugserver_command_free(debugserver_command_t command)\n{\n\tint i;\n\tdebugserver_error_t res = DEBUGSERVER_E_UNKNOWN_ERROR;\n\n\tif (!command)\n\t\treturn DEBUGSERVER_E_INVALID_ARG;\n\n\tif (command) {\n\t\tif (command->name)\n\t\t\tfree(command->name);\n\t\tif (command->argv && command->argc) {\n\t\t\tfor (i = 0; i < command->argc; i++) {\n\t\t\t\tfree(command->argv[i]);\n\t\t\t}\n\t\t\tfree(command->argv);\n\t\t}\n\t\tfree(command);\n\t\tres = DEBUGSERVER_E_SUCCESS;\n\t}\n\n\treturn res;\n}",
          "includes": [
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/debug.h\"",
            "#include \"lockdown.h\"",
            "#include \"debugserver.h\"",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/debug.h\"\n#include \"lockdown.h\"\n#include \"debugserver.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API debugserver_error_t debugserver_command_free(debugserver_command_t command)\n{\n\tint i;\n\tdebugserver_error_t res = DEBUGSERVER_E_UNKNOWN_ERROR;\n\n\tif (!command)\n\t\treturn DEBUGSERVER_E_INVALID_ARG;\n\n\tif (command) {\n\t\tif (command->name)\n\t\t\tfree(command->name);\n\t\tif (command->argv && command->argc) {\n\t\t\tfor (i = 0; i < command->argc; i++) {\n\t\t\t\tfree(command->argv[i]);\n\t\t\t}\n\t\t\tfree(command->argv);\n\t\t}\n\t\tfree(command);\n\t\tres = DEBUGSERVER_E_SUCCESS;\n\t}\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugserver_client_send_command",
          "args": [
            "debugserver_client",
            "command",
            "&response"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "debugserver_client_send_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/debugserver.c",
          "lines": "472-536",
          "snippet": "LIBIMOBILEDEVICE_API debugserver_error_t debugserver_client_send_command(debugserver_client_t client, debugserver_command_t command, char** response)\n{\n\tdebugserver_error_t res = DEBUGSERVER_E_SUCCESS;\n\tint i;\n\tuint32_t bytes = 0;\n\n\tchar* send_buffer = NULL;\n\tuint32_t send_buffer_size = 0;\n\n\tchar* command_arguments = NULL;\n\n\t/* concat all arguments */\n\tchar* tmp = NULL;\n\tchar* newtmp = NULL;\n\tfor (i = 0; i < command->argc; i++) {\n\t\tdebug_info(\"argv[%d]: %s\", i, command->argv[i]);\n\t\tif (!tmp) {\n\t\t\ttmp = strdup(command->argv[i]);\n\t\t} else {\n\t\t\tnewtmp = string_concat(tmp, command->argv[i], NULL);\n\t\t\tfree(tmp);\n\t\t\ttmp = newtmp;\n\t\t}\n\t}\n\tcommand_arguments = tmp;\n\ttmp = NULL;\n\n\tdebug_info(\"command_arguments(%d): %s\", command->argc, command_arguments);\n\n\t/* encode command arguments, add checksum if required and assemble entire command */\n\tdebugserver_format_command(\"$\", command->name, command_arguments, !client->noack_mode, &send_buffer, &send_buffer_size);\n\n\tdebug_info(\"sending encoded command: %s\", send_buffer);\n\n\tres = debugserver_client_send(client, send_buffer, send_buffer_size, &bytes);\n\tdebug_info(\"command result: %d\", res);\n\tif (res != DEBUGSERVER_E_SUCCESS) {\n\t\tgoto cleanup;\n\t}\n\n\t/* receive response */\n\tres = debugserver_client_receive_response(client, response);\n\tdebug_info(\"response result: %d\", res);\n\tif (res != DEBUGSERVER_E_SUCCESS) {\n\t\tgoto cleanup;\n\t}\n\n\tif (response) {\n\t\tdebug_info(\"received response: %s\", *response);\n\t}\n\n\t/* disable sending ack on the client */\n\tif (!strncmp(command->name, \"QStartNoAckMode\", 16)) {\n\t\tdebugserver_client_set_ack_mode(client, 0);\n\t}\n\ncleanup:\n\tif (command_arguments)\n\t\tfree(command_arguments);\n\n\tif (send_buffer)\n\t\tfree(send_buffer);\n\n\treturn res;\n}",
          "includes": [
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/debug.h\"",
            "#include \"lockdown.h\"",
            "#include \"debugserver.h\"",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/debug.h\"\n#include \"lockdown.h\"\n#include \"debugserver.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API debugserver_error_t debugserver_client_send_command(debugserver_client_t client, debugserver_command_t command, char** response)\n{\n\tdebugserver_error_t res = DEBUGSERVER_E_SUCCESS;\n\tint i;\n\tuint32_t bytes = 0;\n\n\tchar* send_buffer = NULL;\n\tuint32_t send_buffer_size = 0;\n\n\tchar* command_arguments = NULL;\n\n\t/* concat all arguments */\n\tchar* tmp = NULL;\n\tchar* newtmp = NULL;\n\tfor (i = 0; i < command->argc; i++) {\n\t\tdebug_info(\"argv[%d]: %s\", i, command->argv[i]);\n\t\tif (!tmp) {\n\t\t\ttmp = strdup(command->argv[i]);\n\t\t} else {\n\t\t\tnewtmp = string_concat(tmp, command->argv[i], NULL);\n\t\t\tfree(tmp);\n\t\t\ttmp = newtmp;\n\t\t}\n\t}\n\tcommand_arguments = tmp;\n\ttmp = NULL;\n\n\tdebug_info(\"command_arguments(%d): %s\", command->argc, command_arguments);\n\n\t/* encode command arguments, add checksum if required and assemble entire command */\n\tdebugserver_format_command(\"$\", command->name, command_arguments, !client->noack_mode, &send_buffer, &send_buffer_size);\n\n\tdebug_info(\"sending encoded command: %s\", send_buffer);\n\n\tres = debugserver_client_send(client, send_buffer, send_buffer_size, &bytes);\n\tdebug_info(\"command result: %d\", res);\n\tif (res != DEBUGSERVER_E_SUCCESS) {\n\t\tgoto cleanup;\n\t}\n\n\t/* receive response */\n\tres = debugserver_client_receive_response(client, response);\n\tdebug_info(\"response result: %d\", res);\n\tif (res != DEBUGSERVER_E_SUCCESS) {\n\t\tgoto cleanup;\n\t}\n\n\tif (response) {\n\t\tdebug_info(\"received response: %s\", *response);\n\t}\n\n\t/* disable sending ack on the client */\n\tif (!strncmp(command->name, \"QStartNoAckMode\", 16)) {\n\t\tdebugserver_client_set_ack_mode(client, 0);\n\t}\n\ncleanup:\n\tif (command_arguments)\n\t\tfree(command_arguments);\n\n\tif (send_buffer)\n\t\tfree(send_buffer);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugserver_command_new",
          "args": [
            "\"k\"",
            "0",
            "NULL",
            "&command"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "debugserver_command_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/debugserver.c",
          "lines": "156-179",
          "snippet": "LIBIMOBILEDEVICE_API debugserver_error_t debugserver_command_new(const char* name, int argc, char* argv[], debugserver_command_t* command)\n{\n\tint i;\n\tdebugserver_command_t tmp = (debugserver_command_t) malloc(sizeof(struct debugserver_command_private));\n\n\t/* copy name */\n\ttmp->name = strdup(name);\n\n\t/* copy arguments */\n\ttmp->argc = argc;\n\ttmp->argv = NULL;\n\tif (argc > 0) {\n\t\ttmp->argv = malloc(sizeof(char*) * (argc + 2));\n\t\tfor (i = 0; i < argc; i++) {\n\t\t\ttmp->argv[i] = strdup(argv[i]);\n\t\t}\n\t\ttmp->argv[i+1] = NULL;\n\t}\n\n\t/* return */\n\t*command = tmp;\n\n\treturn DEBUGSERVER_E_SUCCESS;\n}",
          "includes": [
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/debug.h\"",
            "#include \"lockdown.h\"",
            "#include \"debugserver.h\"",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/debug.h\"\n#include \"lockdown.h\"\n#include \"debugserver.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API debugserver_error_t debugserver_command_new(const char* name, int argc, char* argv[], debugserver_command_t* command)\n{\n\tint i;\n\tdebugserver_command_t tmp = (debugserver_command_t) malloc(sizeof(struct debugserver_command_private));\n\n\t/* copy name */\n\ttmp->name = strdup(name);\n\n\t/* copy arguments */\n\ttmp->argc = argc;\n\ttmp->argv = NULL;\n\tif (argc > 0) {\n\t\ttmp->argv = malloc(sizeof(char*) * (argc + 2));\n\t\tfor (i = 0; i < argc; i++) {\n\t\t\ttmp->argv[i] = strdup(argv[i]);\n\t\t}\n\t\ttmp->argv[i+1] = NULL;\n\t}\n\n\t/* return */\n\t*command = tmp;\n\n\treturn DEBUGSERVER_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"Killing process...\""
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sleep",
          "args": [
            "1"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "diagnostics_relay_sleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/diagnostics_relay.c",
          "lines": "199-229",
          "snippet": "LIBIMOBILEDEVICE_API diagnostics_relay_error_t diagnostics_relay_sleep(diagnostics_relay_client_t client)\n{\n\tif (!client)\n\t\treturn DIAGNOSTICS_RELAY_E_INVALID_ARG;\n\n\tdiagnostics_relay_error_t ret = DIAGNOSTICS_RELAY_E_UNKNOWN_ERROR;\n\n\tplist_t dict = plist_new_dict();\n\n\tplist_dict_set_item(dict,\"Request\", plist_new_string(\"Sleep\"));\n\tret = diagnostics_relay_send(client, dict);\n\tplist_free(dict);\n\tdict = NULL;\n\n\tret = diagnostics_relay_receive(client, &dict);\n\tif (!dict) {\n\t\treturn DIAGNOSTICS_RELAY_E_PLIST_ERROR;\n\t}\n\n\tint check = diagnostics_relay_check_result(dict);\n\tif (check == RESULT_SUCCESS) {\n\t\tret = DIAGNOSTICS_RELAY_E_SUCCESS;\n\t} else if (check == RESULT_UNKNOWN_REQUEST) {\n\t\tret = DIAGNOSTICS_RELAY_E_UNKNOWN_REQUEST;\n\t} else {\n\t\tret = DIAGNOSTICS_RELAY_E_UNKNOWN_ERROR;\n\t}\n\n\tplist_free(dict);\n\treturn ret;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"property_list_service.h\"",
            "#include \"diagnostics_relay.h\"",
            "#include <stdlib.h>",
            "#include <string.h>"
          ],
          "macros_used": [
            "#define RESULT_UNKNOWN_REQUEST 2",
            "#define RESULT_SUCCESS 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"property_list_service.h\"\n#include \"diagnostics_relay.h\"\n#include <stdlib.h>\n#include <string.h>\n\n#define RESULT_UNKNOWN_REQUEST 2\n#define RESULT_SUCCESS 0\n\nLIBIMOBILEDEVICE_API diagnostics_relay_error_t diagnostics_relay_sleep(diagnostics_relay_client_t client)\n{\n\tif (!client)\n\t\treturn DIAGNOSTICS_RELAY_E_INVALID_ARG;\n\n\tdiagnostics_relay_error_t ret = DIAGNOSTICS_RELAY_E_UNKNOWN_ERROR;\n\n\tplist_t dict = plist_new_dict();\n\n\tplist_dict_set_item(dict,\"Request\", plist_new_string(\"Sleep\"));\n\tret = diagnostics_relay_send(client, dict);\n\tplist_free(dict);\n\tdict = NULL;\n\n\tret = diagnostics_relay_receive(client, &dict);\n\tif (!dict) {\n\t\treturn DIAGNOSTICS_RELAY_E_PLIST_ERROR;\n\t}\n\n\tint check = diagnostics_relay_check_result(dict);\n\tif (check == RESULT_SUCCESS) {\n\t\tret = DIAGNOSTICS_RELAY_E_SUCCESS;\n\t} else if (check == RESULT_UNKNOWN_REQUEST) {\n\t\tret = DIAGNOSTICS_RELAY_E_UNKNOWN_REQUEST;\n\t} else {\n\t\tret = DIAGNOSTICS_RELAY_E_UNKNOWN_ERROR;\n\t}\n\n\tplist_free(dict);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"response: %s\"",
            "response"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"failed to receive response\""
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"Entering run loop...\""
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"Continue running process...\""
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "response",
            "\"OK\"",
            "2"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"Setting thread...\""
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "response",
            "\"OK\"",
            "2"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"Checking if launch succeeded...\""
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugserver_client_set_argv",
          "args": [
            "debugserver_client",
            "app_argc",
            "app_argv",
            "NULL"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "debugserver_client_set_argv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/debugserver.c",
          "lines": "557-625",
          "snippet": "LIBIMOBILEDEVICE_API debugserver_error_t debugserver_client_set_argv(debugserver_client_t client, int argc, char* argv[], char** response)\n{\n\tif (!client || !argc)\n\t\treturn DEBUGSERVER_E_INVALID_ARG;\n\n\tdebugserver_error_t result = DEBUGSERVER_E_UNKNOWN_ERROR;\n\tchar *pkt = NULL;\n\tint pkt_len = 0;\n\tint i = 0;\n\n\t/* calculate total length */\n\twhile (i < argc && argv && argv[i]) {\n\t\tchar *prefix = NULL;\n\t\tasprintf(&prefix, \",%d,%d,\", (int)strlen(argv[i]) * 2, i);\n\t\tpkt_len += (int)strlen(prefix) + (int)strlen(argv[i]) * 2;\n\t\tfree(prefix);\n\t\ti++;\n\t}\n\n\t/* allocate packet and initialize it */\n\tpkt = (char *) malloc(pkt_len + 1);\n\tmemset(pkt, 0, pkt_len + 1);\n\n\tchar *pktp = pkt;\n\n\ti = 0;\n\twhile (i < argc && argv && argv[i]) {\n\t\tdebug_info(\"argv[%d] = \\\"%s\\\"\", i, argv[i]);\n\n\t\tchar *prefix = NULL;\n\t\tchar *m = NULL;\n\t\tint arg_len = strlen(argv[i]);\n\t\tint arg_hexlen = arg_len * 2;\n\n\t\tasprintf(&prefix, \",%d,%d,\", arg_hexlen, i);\n\n\t\tm = (char *) malloc(arg_hexlen);\n\t\tchar *p = m;\n\t\tchar *q = (char*)argv[i];\n\t\twhile (*q) {\n\t\t\t*p++ = debugserver_int2hex(*q >> 4);\n\t\t\t*p++ = debugserver_int2hex(*q & 0xf);\n\t\t\tq++;\n\t\t}\n\n\t\tmemcpy(pktp, prefix, strlen(prefix));\n\t\tpktp += strlen(prefix);\n\n\t\tmemcpy(pktp, m, arg_hexlen);\n\t\tpktp += arg_hexlen;\n\n\t\tfree(prefix);\n\t\tfree(m);\n\n\t\ti++;\n\t}\n\n\tpkt[0] = 'A';\n\n\tdebugserver_command_t command = NULL;\n\tdebugserver_command_new(pkt, 0, NULL, &command);\n\tresult = debugserver_client_send_command(client, command, response);\n\tdebugserver_command_free(command);\n\n\tif (pkt)\n\t\tfree(pkt);\n\n\treturn result;\n}",
          "includes": [
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/debug.h\"",
            "#include \"lockdown.h\"",
            "#include \"debugserver.h\"",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/debug.h\"\n#include \"lockdown.h\"\n#include \"debugserver.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API debugserver_error_t debugserver_client_set_argv(debugserver_client_t client, int argc, char* argv[], char** response)\n{\n\tif (!client || !argc)\n\t\treturn DEBUGSERVER_E_INVALID_ARG;\n\n\tdebugserver_error_t result = DEBUGSERVER_E_UNKNOWN_ERROR;\n\tchar *pkt = NULL;\n\tint pkt_len = 0;\n\tint i = 0;\n\n\t/* calculate total length */\n\twhile (i < argc && argv && argv[i]) {\n\t\tchar *prefix = NULL;\n\t\tasprintf(&prefix, \",%d,%d,\", (int)strlen(argv[i]) * 2, i);\n\t\tpkt_len += (int)strlen(prefix) + (int)strlen(argv[i]) * 2;\n\t\tfree(prefix);\n\t\ti++;\n\t}\n\n\t/* allocate packet and initialize it */\n\tpkt = (char *) malloc(pkt_len + 1);\n\tmemset(pkt, 0, pkt_len + 1);\n\n\tchar *pktp = pkt;\n\n\ti = 0;\n\twhile (i < argc && argv && argv[i]) {\n\t\tdebug_info(\"argv[%d] = \\\"%s\\\"\", i, argv[i]);\n\n\t\tchar *prefix = NULL;\n\t\tchar *m = NULL;\n\t\tint arg_len = strlen(argv[i]);\n\t\tint arg_hexlen = arg_len * 2;\n\n\t\tasprintf(&prefix, \",%d,%d,\", arg_hexlen, i);\n\n\t\tm = (char *) malloc(arg_hexlen);\n\t\tchar *p = m;\n\t\tchar *q = (char*)argv[i];\n\t\twhile (*q) {\n\t\t\t*p++ = debugserver_int2hex(*q >> 4);\n\t\t\t*p++ = debugserver_int2hex(*q & 0xf);\n\t\t\tq++;\n\t\t}\n\n\t\tmemcpy(pktp, prefix, strlen(prefix));\n\t\tpktp += strlen(prefix);\n\n\t\tmemcpy(pktp, m, arg_hexlen);\n\t\tpktp += arg_hexlen;\n\n\t\tfree(prefix);\n\t\tfree(m);\n\n\t\ti++;\n\t}\n\n\tpkt[0] = 'A';\n\n\tdebugserver_command_t command = NULL;\n\tdebugserver_command_new(pkt, 0, NULL, &command);\n\tresult = debugserver_client_send_command(client, command, response);\n\tdebugserver_command_free(command);\n\n\tif (pkt)\n\t\tfree(pkt);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"app_argv[%d] = %s\"",
            "app_argc",
            "argv[i]"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"app_argv[%d] = %s\"",
            "0",
            "app_argv[0]"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(char*) * app_argc"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"Setting argv...\""
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugserver_client_set_environment_hex_encoded",
          "args": [
            "debugserver_client",
            "environment[environment_index]",
            "NULL"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "debugserver_client_set_environment_hex_encoded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/debugserver.c",
          "lines": "538-555",
          "snippet": "LIBIMOBILEDEVICE_API debugserver_error_t debugserver_client_set_environment_hex_encoded(debugserver_client_t client, const char* env, char** response)\n{\n\tif (!client || !env)\n\t\treturn DEBUGSERVER_E_INVALID_ARG;\n\n\tdebugserver_error_t result = DEBUGSERVER_E_UNKNOWN_ERROR;\n\tchar* env_tmp = strdup(env);\n\tchar* env_arg[2] = { env_tmp, NULL };\n\n\tdebugserver_command_t command = NULL;\n\tdebugserver_command_new(\"QEnvironmentHexEncoded:\", 1, env_arg, &command);\n\tresult = debugserver_client_send_command(client, command, response);\n\tdebugserver_command_free(command);\n\n\tfree(env_tmp);\n\n\treturn result;\n}",
          "includes": [
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/debug.h\"",
            "#include \"lockdown.h\"",
            "#include \"debugserver.h\"",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/debug.h\"\n#include \"lockdown.h\"\n#include \"debugserver.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API debugserver_error_t debugserver_client_set_environment_hex_encoded(debugserver_client_t client, const char* env, char** response)\n{\n\tif (!client || !env)\n\t\treturn DEBUGSERVER_E_INVALID_ARG;\n\n\tdebugserver_error_t result = DEBUGSERVER_E_UNKNOWN_ERROR;\n\tchar* env_tmp = strdup(env);\n\tchar* env_arg[2] = { env_tmp, NULL };\n\n\tdebugserver_command_t command = NULL;\n\tdebugserver_command_new(\"QEnvironmentHexEncoded:\", 1, env_arg, &command);\n\tresult = debugserver_client_send_command(client, command, response);\n\tdebugserver_command_free(command);\n\n\tfree(env_tmp);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"setting environment variable: %s\"",
            "environment[environment_index]"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"Setting environment...\""
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "response",
            "\"OK\"",
            "2"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"Setting working directory...\""
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "response",
            "\"OK\"",
            "2"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"1024\""
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"Setting maximum packet size...\""
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "response",
            "\"OK\"",
            "2"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"Setting logging bitmask...\""
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Could not start com.apple.debugserver!\\n\"\n\t\t\t\t\t\"Please make sure to mount the developer disk image first:\\n\"\n\t\t\t\t\t\"  1) Get the iOS version from `ideviceinfo -k ProductVersion`.\\n\"\n\t\t\t\t\t\"  2) Find the matching iPhoneOS DeveloperDiskImage.dmg files.\\n\"\n\t\t\t\t\t\"  3) Run `ideviceimagemounter` with the above path.\\n\""
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugserver_client_start_service",
          "args": [
            "device",
            "&debugserver_client",
            "\"idevicerun\""
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "debugserver_client_start_service",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/debugserver.c",
          "lines": "91-96",
          "snippet": "LIBIMOBILEDEVICE_API debugserver_error_t debugserver_client_start_service(idevice_t device, debugserver_client_t * client, const char* label)\n{\n\tdebugserver_error_t err = DEBUGSERVER_E_UNKNOWN_ERROR;\n\tservice_client_factory_start_service(device, DEBUGSERVER_SERVICE_NAME, (void**)client, label, SERVICE_CONSTRUCTOR(debugserver_client_new), &err);\n\treturn err;\n}",
          "includes": [
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/debug.h\"",
            "#include \"lockdown.h\"",
            "#include \"debugserver.h\"",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/debug.h\"\n#include \"lockdown.h\"\n#include \"debugserver.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API debugserver_error_t debugserver_client_start_service(idevice_t device, debugserver_client_t * client, const char* label)\n{\n\tdebugserver_error_t err = DEBUGSERVER_E_UNKNOWN_ERROR;\n\tservice_client_factory_start_service(device, DEBUGSERVER_SERVICE_NAME, (void**)client, label, SERVICE_CONSTRUCTOR(debugserver_client_new), &err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Could not determine container path for bundle identifier %s.\\n\"",
            "bundle_identifier"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_free",
          "args": [
            "container"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_free",
          "args": [
            "container"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"working_directory: %s\\n\"",
            "working_directory"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_string_val",
          "args": [
            "container",
            "&working_directory"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_node_type",
          "args": [
            "container"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instproxy_client_free",
          "args": [
            "instproxy_client"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "instproxy_client_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/installation_proxy.c",
          "lines": "256-273",
          "snippet": "LIBIMOBILEDEVICE_API instproxy_error_t instproxy_client_free(instproxy_client_t client)\n{\n\tif (!client)\n\t\treturn INSTPROXY_E_INVALID_ARG;\n\n\tproperty_list_service_client_free(client->parent);\n\tclient->parent = NULL;\n\tif (client->receive_status_thread) {\n\t\tdebug_info(\"joining receive_status_thread\");\n\t\tthread_join(client->receive_status_thread);\n\t\tthread_free(client->receive_status_thread);\n\t\tclient->receive_status_thread = (thread_t)NULL;\n\t}\n\tmutex_destroy(&client->mutex);\n\tfree(client);\n\n\treturn INSTPROXY_E_SUCCESS;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"property_list_service.h\"",
            "#include \"installation_proxy.h\"",
            "#include <plist/plist.h>",
            "#include <unistd.h>",
            "#include <inttypes.h>",
            "#include <stdlib.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"property_list_service.h\"\n#include \"installation_proxy.h\"\n#include <plist/plist.h>\n#include <unistd.h>\n#include <inttypes.h>\n#include <stdlib.h>\n#include <string.h>\n\nLIBIMOBILEDEVICE_API instproxy_error_t instproxy_client_free(instproxy_client_t client)\n{\n\tif (!client)\n\t\treturn INSTPROXY_E_INVALID_ARG;\n\n\tproperty_list_service_client_free(client->parent);\n\tclient->parent = NULL;\n\tif (client->receive_status_thread) {\n\t\tdebug_info(\"joining receive_status_thread\");\n\t\tthread_join(client->receive_status_thread);\n\t\tthread_free(client->receive_status_thread);\n\t\tclient->receive_status_thread = (thread_t)NULL;\n\t}\n\tmutex_destroy(&client->mutex);\n\tfree(client);\n\n\treturn INSTPROXY_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "instproxy_client_get_path_for_bundle_identifier",
          "args": [
            "instproxy_client",
            "bundle_identifier",
            "&path"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instproxy_client_get_object_by_key_from_info_directionary_for_bundle_identifier",
          "args": [
            "instproxy_client",
            "bundle_identifier",
            "\"Container\"",
            "&container"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "instproxy_client_get_object_by_key_from_info_directionary_for_bundle_identifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicedebug.c",
          "lines": "58-103",
          "snippet": "static instproxy_error_t instproxy_client_get_object_by_key_from_info_directionary_for_bundle_identifier(instproxy_client_t client, const char* appid, const char* key, plist_t* node)\n{\n\tif (!client || !appid || !key)\n\t\treturn INSTPROXY_E_INVALID_ARG;\n\n\tplist_t apps = NULL;\n\n\t// create client options for any application types\n\tplist_t client_opts = instproxy_client_options_new();\n\tinstproxy_client_options_add(client_opts, \"ApplicationType\", \"Any\", NULL);\n\n\t// only return attributes we need\n\tinstproxy_client_options_set_return_attributes(client_opts, \"CFBundleIdentifier\", \"CFBundleExecutable\", key, NULL);\n\n\t// only query for specific appid\n\tconst char* appids[] = {appid, NULL};\n\n\t// query device for list of apps\n\tinstproxy_error_t ierr = instproxy_lookup(client, appids, client_opts, &apps);\n\n\tinstproxy_client_options_free(client_opts);\n\n\tif (ierr != INSTPROXY_E_SUCCESS) {\n\t\treturn ierr;\n\t}\n\n\tplist_t app_found = plist_access_path(apps, 1, appid);\n\tif (!app_found) {\n\t\tif (apps)\n\t\t\tplist_free(apps);\n\t\t*node = NULL;\n\t\treturn INSTPROXY_E_OP_FAILED;\n\t}\n\n\tplist_t object = plist_dict_get_item(app_found, key);\n\tif (object) {\n\t\t*node = plist_copy(object);\n\t} else {\n\t\tdebug_info(\"key %s not found\", key);\n\t\treturn INSTPROXY_E_OP_FAILED;\n\t}\n\n\tplist_free(apps);\n\n\treturn INSTPROXY_E_SUCCESS;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include <plist/plist.h>",
            "#include <libimobiledevice/debugserver.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <libimobiledevice/installation_proxy.h>",
            "#include <windows.h>",
            "#include <libgen.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include <plist/plist.h>\n#include <libimobiledevice/debugserver.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <libimobiledevice/installation_proxy.h>\n#include <windows.h>\n#include <libgen.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <config.h>\n\nstatic instproxy_error_t instproxy_client_get_object_by_key_from_info_directionary_for_bundle_identifier(instproxy_client_t client, const char* appid, const char* key, plist_t* node)\n{\n\tif (!client || !appid || !key)\n\t\treturn INSTPROXY_E_INVALID_ARG;\n\n\tplist_t apps = NULL;\n\n\t// create client options for any application types\n\tplist_t client_opts = instproxy_client_options_new();\n\tinstproxy_client_options_add(client_opts, \"ApplicationType\", \"Any\", NULL);\n\n\t// only return attributes we need\n\tinstproxy_client_options_set_return_attributes(client_opts, \"CFBundleIdentifier\", \"CFBundleExecutable\", key, NULL);\n\n\t// only query for specific appid\n\tconst char* appids[] = {appid, NULL};\n\n\t// query device for list of apps\n\tinstproxy_error_t ierr = instproxy_lookup(client, appids, client_opts, &apps);\n\n\tinstproxy_client_options_free(client_opts);\n\n\tif (ierr != INSTPROXY_E_SUCCESS) {\n\t\treturn ierr;\n\t}\n\n\tplist_t app_found = plist_access_path(apps, 1, appid);\n\tif (!app_found) {\n\t\tif (apps)\n\t\t\tplist_free(apps);\n\t\t*node = NULL;\n\t\treturn INSTPROXY_E_OP_FAILED;\n\t}\n\n\tplist_t object = plist_dict_get_item(app_found, key);\n\tif (object) {\n\t\t*node = plist_copy(object);\n\t} else {\n\t\tdebug_info(\"key %s not found\", key);\n\t\treturn INSTPROXY_E_OP_FAILED;\n\t}\n\n\tplist_free(apps);\n\n\treturn INSTPROXY_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Could not start installation proxy service.\\n\""
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instproxy_client_start_service",
          "args": [
            "device",
            "&instproxy_client",
            "\"idevicerun\""
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "instproxy_client_start_service",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/installation_proxy.c",
          "lines": "249-254",
          "snippet": "LIBIMOBILEDEVICE_API instproxy_error_t instproxy_client_start_service(idevice_t device, instproxy_client_t * client, const char* label)\n{\n\tinstproxy_error_t err = INSTPROXY_E_UNKNOWN_ERROR;\n\tservice_client_factory_start_service(device, INSTPROXY_SERVICE_NAME, (void**)client, label, SERVICE_CONSTRUCTOR(instproxy_client_new), &err);\n\treturn err;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"property_list_service.h\"",
            "#include \"installation_proxy.h\"",
            "#include <plist/plist.h>",
            "#include <unistd.h>",
            "#include <inttypes.h>",
            "#include <stdlib.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"property_list_service.h\"\n#include \"installation_proxy.h\"\n#include <plist/plist.h>\n#include <unistd.h>\n#include <inttypes.h>\n#include <stdlib.h>\n#include <string.h>\n\nLIBIMOBILEDEVICE_API instproxy_error_t instproxy_client_start_service(idevice_t device, instproxy_client_t * client, const char* label)\n{\n\tinstproxy_error_t err = INSTPROXY_E_UNKNOWN_ERROR;\n\tservice_client_factory_start_service(device, INSTPROXY_SERVICE_NAME, (void**)client, label, SERVICE_CONSTRUCTOR(instproxy_client_new), &err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"No device found, is it plugged in?\\n\""
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"No device found with udid %s, is it plugged in?\\n\"",
            "udid"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "asprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/include/asprintf.h",
          "lines": "23-31",
          "snippet": "static inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}",
          "includes": [
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <config.h>\n\nstatic inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "idevice_new",
          "args": [
            "&device",
            "udid"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "idevice_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
          "lines": "230-245",
          "snippet": "LIBIMOBILEDEVICE_API idevice_error_t idevice_new(idevice_t * device, const char *udid)\n{\n\tusbmuxd_device_info_t muxdev;\n\tint res = usbmuxd_get_device_by_udid(udid, &muxdev);\n\tif (res > 0) {\n\t\tidevice_t dev = (idevice_t) malloc(sizeof(struct idevice_private));\n\t\tdev->udid = strdup(muxdev.udid);\n\t\tdev->conn_type = CONNECTION_USBMUXD;\n\t\tdev->conn_data = (void*)(long)muxdev.handle;\n\t\t*device = dev;\n\t\treturn IDEVICE_E_SUCCESS;\n\t}\n\t/* other connection types could follow here */\n\n\treturn IDEVICE_E_NO_DEVICE;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"common/thread.h\"",
            "#include \"common/userpref.h\"",
            "#include \"idevice.h\"",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <usbmuxd.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "LIBIMOBILEDEVICE_API idevice_error_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nLIBIMOBILEDEVICE_API idevice_error_t idevice_new(idevice_t * device, const char *udid)\n{\n\tusbmuxd_device_info_t muxdev;\n\tint res = usbmuxd_get_device_by_udid(udid, &muxdev);\n\tif (res > 0) {\n\t\tidevice_t dev = (idevice_t) malloc(sizeof(struct idevice_private));\n\t\tdev->udid = strdup(muxdev.udid);\n\t\tdev->conn_type = CONNECTION_USBMUXD;\n\t\tdev->conn_data = (void*)(long)muxdev.handle;\n\t\t*device = dev;\n\t\treturn IDEVICE_E_SUCCESS;\n\t}\n\t/* other connection types could follow here */\n\n\treturn IDEVICE_E_NO_DEVICE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_usage",
          "args": [
            "argc",
            "argv"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "print_usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicedebug.c",
          "lines": "180-196",
          "snippet": "static void print_usage(int argc, char **argv)\n{\n\tchar *name = NULL;\n\tname = strrchr(argv[0], '/');\n\tprintf(\"Usage: %s [OPTIONS] COMMAND\\n\", (name ? name + 1: argv[0]));\n\tprintf(\"Interact with the debugserver service of a device.\\n\\n\");\n\tprintf(\" Where COMMAND is one of:\\n\");\n\tprintf(\"  run BUNDLEID [ARGS...]\\trun app with BUNDLEID and optional ARGS on device.\\n\");\n\tprintf(\"\\n\");\n\tprintf(\" The following OPTIONS are accepted:\\n\");\n\tprintf(\"  -e, --env NAME=VALUE\\tset environment variable NAME to VALUE\\n\");\n\tprintf(\"  -u, --udid UDID\\ttarget specific device by its 40-digit device UDID\\n\");\n\tprintf(\"  -d, --debug\\t\\tenable communication debugging\\n\");\n\tprintf(\"  -h, --help\\t\\tprints usage information\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"Homepage: <\" PACKAGE_URL \">\\n\");\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include <plist/plist.h>",
            "#include <libimobiledevice/debugserver.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <libimobiledevice/installation_proxy.h>",
            "#include <windows.h>",
            "#include <libgen.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include <plist/plist.h>\n#include <libimobiledevice/debugserver.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <libimobiledevice/installation_proxy.h>\n#include <windows.h>\n#include <libgen.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <config.h>\n\nstatic void print_usage(int argc, char **argv)\n{\n\tchar *name = NULL;\n\tname = strrchr(argv[0], '/');\n\tprintf(\"Usage: %s [OPTIONS] COMMAND\\n\", (name ? name + 1: argv[0]));\n\tprintf(\"Interact with the debugserver service of a device.\\n\\n\");\n\tprintf(\" Where COMMAND is one of:\\n\");\n\tprintf(\"  run BUNDLEID [ARGS...]\\trun app with BUNDLEID and optional ARGS on device.\\n\");\n\tprintf(\"\\n\");\n\tprintf(\" The following OPTIONS are accepted:\\n\");\n\tprintf(\"  -e, --env NAME=VALUE\\tset environment variable NAME to VALUE\\n\");\n\tprintf(\"  -u, --udid UDID\\ttarget specific device by its 40-digit device UDID\\n\");\n\tprintf(\"  -d, --debug\\t\\tenable communication debugging\\n\");\n\tprintf(\"  -h, --help\\t\\tprints usage information\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"Homepage: <\" PACKAGE_URL \">\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "environment",
            "(environment_count + 1) * sizeof(char*)"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Please supply the bundle identifier of the app to run.\\n\""
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"run\""
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "plist_strcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
          "lines": "296-309",
          "snippet": "static int plist_strcmp(plist_t node, const char *str)\n{\n\tchar *buffer = NULL;\n\tint ret = 0;\n\n\tif (plist_get_node_type(node) != PLIST_STRING)\n\t\treturn ret;\n\n\tplist_get_string_val(node, &buffer);\n\tret = strcmp(buffer, str);\n\tfree(buffer);\n\n\treturn ret;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <unistd.h>",
            "#include <gcrypt.h>",
            "#include <openssl/sha.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int plist_strcmp(plist_t node, const char *str)\n{\n\tchar *buffer = NULL;\n\tint ret = 0;\n\n\tif (plist_get_node_type(node) != PLIST_STRING)\n\t\treturn ret;\n\n\tplist_get_string_val(node, &buffer);\n\tret = strcmp(buffer, str);\n\tfree(buffer);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[i]"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "environment",
            "(environment_count + 1) * sizeof(char*)"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "(environment_count + 1) * sizeof(char*)"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "argv[i]",
            "'='"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "argv[i]"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "argv[i]"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idevice_set_debug_level",
          "args": [
            "debug_level"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "idevice_set_debug_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
          "lines": "225-228",
          "snippet": "LIBIMOBILEDEVICE_API void idevice_set_debug_level(int level)\n{\n\tinternal_set_debug_level(level);\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"common/thread.h\"",
            "#include \"common/userpref.h\"",
            "#include \"idevice.h\"",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <usbmuxd.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API void idevice_set_debug_level(int level)\n{\n\tinternal_set_debug_level(level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGPIPE",
            "SIG_IGN"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGQUIT",
            "on_signal"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGTERM",
            "on_signal"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGINT",
            "on_signal"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common/debug.h\"\n#include <plist/plist.h>\n#include <libimobiledevice/debugserver.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <libimobiledevice/installation_proxy.h>\n#include <windows.h>\n#include <libgen.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <config.h>\n\nstatic int quit_flag = 0;\n\nint main(int argc, char *argv[])\n{\n\tint res = -1;\n\tidevice_t device = NULL;\n\tidevice_error_t ret = IDEVICE_E_UNKNOWN_ERROR;\n\tinstproxy_client_t instproxy_client = NULL;\n\tdebugserver_client_t debugserver_client = NULL;\n\tint i;\n\tint debug_level = 0;\n\tint cmd = CMD_NONE;\n\tconst char* udid = NULL;\n\tconst char* bundle_identifier = NULL;\n\tchar* path = NULL;\n\tchar* working_directory = NULL;\n\tchar **newlist = NULL;\n\tchar** environment = NULL;\n\tint environment_index = 0;\n\tint environment_count = 0;\n\tchar* response = NULL;\n\tdebugserver_command_t command = NULL;\n\tdebugserver_error_t dres = DEBUGSERVER_E_UNKNOWN_ERROR;\n\n\t/* map signals */\n\tsignal(SIGINT, on_signal);\n\tsignal(SIGTERM, on_signal);\n#ifndef WIN32\n\tsignal(SIGQUIT, on_signal);\n\tsignal(SIGPIPE, SIG_IGN);\n#endif\n\n\t/* parse command line arguments */\n\tfor (i = 1; i < argc; i++) {\n\t\tif (!strcmp(argv[i], \"-d\") || !strcmp(argv[i], \"--debug\")) {\n\t\t\tdebug_level++;\n\t\t\tidevice_set_debug_level(debug_level);\n\t\t\tcontinue;\n\t\t} else if (!strcmp(argv[i], \"-u\") || !strcmp(argv[i], \"--udid\")) {\n\t\t\ti++;\n\t\t\tif (!argv[i] || (strlen(argv[i]) != 40)) {\n\t\t\t\tprint_usage(argc, argv);\n\t\t\t\tres = 0;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tudid = argv[i];\n\t\t\tcontinue;\n\t\t} else if (!strcmp(argv[i], \"-e\") || !strcmp(argv[i], \"--env\")) {\n\t\t\ti++;\n\t\t\tif (!argv[i] || (strlen(argv[i]) <= 1) || strchr(argv[i], '=') == NULL) {\n\t\t\t\tprint_usage(argc, argv);\n\t\t\t\tres = 0;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\t/* add environment variable */\n\t\t\tif (!newlist)\n\t\t\t\tnewlist = malloc((environment_count + 1) * sizeof(char*));\n\t\t\telse\n\t\t\t\tnewlist = realloc(environment, (environment_count + 1) * sizeof(char*));\n\t\t\tnewlist[environment_count++] = strdup(argv[i]);\n\t\t\tenvironment = newlist;\n\t\t\tcontinue;\n\t\t} else if (!strcmp(argv[i], \"-h\") || !strcmp(argv[i], \"--help\")) {\n\t\t\tprint_usage(argc, argv);\n\t\t\tres = 0;\n\t\t\tgoto cleanup;\n\t\t} else if (!strcmp(argv[i], \"run\")) {\n\t\t\tcmd = CMD_RUN;\n\n\t\t\ti++;\n\t\t\tif (!argv[i]) {\n\t\t\t\t/* make sure at least the bundle identifier was provided */\n\t\t\t\tprintf(\"Please supply the bundle identifier of the app to run.\\n\");\n\t\t\t\tprint_usage(argc, argv);\n\t\t\t\tres = 0;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\t/*  read bundle identifier */\n\t\t\tbundle_identifier = argv[i];\n\t\t\tbreak;\n\t\t} else {\n\t\t\tprint_usage(argc, argv);\n\t\t\tres = 0;\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tif (environment) {\n\t\tnewlist = realloc(environment, (environment_count + 1) * sizeof(char*));\n\t\tnewlist[environment_count] = NULL;\n\t\tenvironment = newlist;\n\t}\n\n\t/* verify options */\n\tif (cmd == CMD_NONE) {\n\t\tprint_usage(argc, argv);\n\t\tgoto cleanup;\n\t}\n\n\t/* connect to the device */\n\tret = idevice_new(&device, udid);\n\tif (ret != IDEVICE_E_SUCCESS) {\n\t\tif (udid) {\n\t\t\tprintf(\"No device found with udid %s, is it plugged in?\\n\", udid);\n\t\t} else {\n\t\t\tprintf(\"No device found, is it plugged in?\\n\");\n\t\t}\n\t\tgoto cleanup;\n\t}\n\n\tswitch (cmd) {\n\t\tcase CMD_RUN:\n\t\tdefault:\n\t\t\t/* get the path to the app and it's working directory */\n\t\t\tif (instproxy_client_start_service(device, &instproxy_client, \"idevicerun\") != INSTPROXY_E_SUCCESS) {\n\t\t\t\tfprintf(stderr, \"Could not start installation proxy service.\\n\");\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tplist_t container = NULL;\n\t\t\tinstproxy_client_get_object_by_key_from_info_directionary_for_bundle_identifier(instproxy_client, bundle_identifier, \"Container\", &container);\n\t\t\tinstproxy_client_get_path_for_bundle_identifier(instproxy_client, bundle_identifier, &path);\n\t\t\tinstproxy_client_free(instproxy_client);\n\t\t\tinstproxy_client = NULL;\n\n\t\t\tif (container) {\n\t\t\t\tif (plist_get_node_type(container) == PLIST_STRING) {\n\t\t\t\t\tplist_get_string_val(container, &working_directory);\n\t\t\t\t\tdebug_info(\"working_directory: %s\\n\", working_directory);\n\t\t\t\t\tplist_free(container);\n\t\t\t\t} else {\n\t\t\t\t\t\tplist_free(container);\n\t\t\t\t\tfprintf(stderr, \"Could not determine container path for bundle identifier %s.\\n\", bundle_identifier);\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* start and connect to debugserver */\n\t\t\tif (debugserver_client_start_service(device, &debugserver_client, \"idevicerun\") != DEBUGSERVER_E_SUCCESS) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"Could not start com.apple.debugserver!\\n\"\n\t\t\t\t\t\"Please make sure to mount the developer disk image first:\\n\"\n\t\t\t\t\t\"  1) Get the iOS version from `ideviceinfo -k ProductVersion`.\\n\"\n\t\t\t\t\t\"  2) Find the matching iPhoneOS DeveloperDiskImage.dmg files.\\n\"\n\t\t\t\t\t\"  3) Run `ideviceimagemounter` with the above path.\\n\");\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\n\t\t\t/* enable logging for the session in debug mode */\n\t\t\tif (debug_level) {\n\t\t\t\tdebug_info(\"Setting logging bitmask...\");\n\t\t\t\tdebugserver_command_new(\"QSetLogging:bitmask=LOG_ALL|LOG_RNB_REMOTE|LOG_RNB_PACKETS\", 0, NULL, &command);\n\t\t\t\tdres = debugserver_client_send_command(debugserver_client, command, &response);\n\t\t\t\tdebugserver_command_free(command);\n\t\t\t\tcommand = NULL;\n\t\t\t\tif (response) {\n\t\t\t\t\tif (strncmp(response, \"OK\", 2)) {\n\t\t\t\t\t\tdebugserver_client_handle_response(debugserver_client, &response, 0);\n\t\t\t\t\t\tgoto cleanup;\n\t\t\t\t\t}\n\t\t\t\t\tfree(response);\n\t\t\t\t\tresponse = NULL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* set maximum packet size */\n\t\t\tdebug_info(\"Setting maximum packet size...\");\n\t\t\tchar* packet_size[2] = {strdup(\"1024\"), NULL};\n\t\t\tdebugserver_command_new(\"QSetMaxPacketSize:\", 1, packet_size, &command);\n\t\t\tfree(packet_size[0]);\n\t\t\tdres = debugserver_client_send_command(debugserver_client, command, &response);\n\t\t\tdebugserver_command_free(command);\n\t\t\tcommand = NULL;\n\t\t\tif (response) {\n\t\t\t\tif (strncmp(response, \"OK\", 2)) {\n\t\t\t\t\tdebugserver_client_handle_response(debugserver_client, &response, 0);\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tfree(response);\n\t\t\t\tresponse = NULL;\n\t\t\t}\n\n\t\t\t/* set working directory */\n\t\t\tdebug_info(\"Setting working directory...\");\n\t\t\tchar* working_dir[2] = {working_directory, NULL};\n\t\t\tdebugserver_command_new(\"QSetWorkingDir:\", 1, working_dir, &command);\n\t\t\tdres = debugserver_client_send_command(debugserver_client, command, &response);\n\t\t\tdebugserver_command_free(command);\n\t\t\tcommand = NULL;\n\t\t\tif (response) {\n\t\t\t\tif (strncmp(response, \"OK\", 2)) {\n\t\t\t\t\tdebugserver_client_handle_response(debugserver_client, &response, 0);\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tfree(response);\n\t\t\t\tresponse = NULL;\n\t\t\t}\n\n\t\t\t/* set environment */\n\t\t\tif (environment) {\n\t\t\t\tdebug_info(\"Setting environment...\");\n\t\t\t\tfor (environment_index = 0; environment_index < environment_count; environment_index++) {\n\t\t\t\t\tdebug_info(\"setting environment variable: %s\", environment[environment_index]);\n\t\t\t\t\tdebugserver_client_set_environment_hex_encoded(debugserver_client, environment[environment_index], NULL);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* set arguments and run app */\n\t\t\tdebug_info(\"Setting argv...\");\n\t\t\ti++; /* i is the offset of the bundle identifier, thus skip it */\n\t\t\tint app_argc = (argc - i + 2);\n\t\t\tchar **app_argv = (char**)malloc(sizeof(char*) * app_argc);\n\t\t\tapp_argv[0] = path;\n\t\t\tdebug_info(\"app_argv[%d] = %s\", 0, app_argv[0]);\n\t\t\tapp_argc = 1;\n\t\t\twhile (i < argc && argv && argv[i]) {\n\t\t\t\tdebug_info(\"app_argv[%d] = %s\", app_argc, argv[i]);\n\t\t\t\tapp_argv[app_argc++] = argv[i];\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tapp_argv[app_argc] = NULL;\n\t\t\tdebugserver_client_set_argv(debugserver_client, app_argc, app_argv, NULL);\n\t\t\tfree(app_argv);\n\n\t\t\t/* check if launch succeeded */\n\t\t\tdebug_info(\"Checking if launch succeeded...\");\n\t\t\tdebugserver_command_new(\"qLaunchSuccess\", 0, NULL, &command);\n\t\t\tdres = debugserver_client_send_command(debugserver_client, command, &response);\n\t\t\tdebugserver_command_free(command);\n\t\t\tcommand = NULL;\n\t\t\tif (response) {\n\t\t\t\tif (strncmp(response, \"OK\", 2)) {\n\t\t\t\t\tdebugserver_client_handle_response(debugserver_client, &response, 0);\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tfree(response);\n\t\t\t\tresponse = NULL;\n\t\t\t}\n\n\t\t\t/* set thread */\n\t\t\tdebug_info(\"Setting thread...\");\n\t\t\tdebugserver_command_new(\"Hc0\", 0, NULL, &command);\n\t\t\tdres = debugserver_client_send_command(debugserver_client, command, &response);\n\t\t\tdebugserver_command_free(command);\n\t\t\tcommand = NULL;\n\t\t\tif (response) {\n\t\t\t\tif (strncmp(response, \"OK\", 2)) {\n\t\t\t\t\tdebugserver_client_handle_response(debugserver_client, &response, 0);\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tfree(response);\n\t\t\t\tresponse = NULL;\n\t\t\t}\n\n\t\t\t/* continue running process */\n\t\t\tdebug_info(\"Continue running process...\");\n\t\t\tdebugserver_command_new(\"c\", 0, NULL, &command);\n\t\t\tdres = debugserver_client_send_command(debugserver_client, command, &response);\n\t\t\tdebugserver_command_free(command);\n\t\t\tcommand = NULL;\n\n\t\t\t/* main loop which is parsing/handling packets during the run */\n\t\t\tdebug_info(\"Entering run loop...\");\n\t\t\twhile (!quit_flag) {\n\t\t\t\tif (dres != DEBUGSERVER_E_SUCCESS) {\n\t\t\t\t\tdebug_info(\"failed to receive response\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (response) {\n\t\t\t\t\tdebug_info(\"response: %s\", response);\n\t\t\t\t\tdres = debugserver_client_handle_response(debugserver_client, &response, 1);\n\t\t\t\t}\n\n\t\t\t\tsleep(1);\n\t\t\t}\n\n\t\t\t/* kill process after we finished */\n\t\t\tdebug_info(\"Killing process...\");\n\t\t\tdebugserver_command_new(\"k\", 0, NULL, &command);\n\t\t\tdres = debugserver_client_send_command(debugserver_client, command, &response);\n\t\t\tdebugserver_command_free(command);\n\t\t\tcommand = NULL;\n\t\t\tif (response) {\n\t\t\t\tif (strncmp(response, \"OK\", 2)) {\n\t\t\t\t\tdebugserver_client_handle_response(debugserver_client, &response, 0);\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tfree(response);\n\t\t\t\tresponse = NULL;\n\t\t\t}\n\n\t\t\tres = (dres == DEBUGSERVER_E_SUCCESS) ? 0: -1;\n\t\tbreak;\n\t}\n\ncleanup:\n\t/* cleanup the house */\n\tif (environment) {\n\t\tfor (environment_index = 0; environment_index < environment_count; environment_index++) {\n\t\t\tfree(environment[environment_index]);\n\t\t}\n\t\tfree(environment);\n\t}\n\n\tif (working_directory)\n\t\tfree(working_directory);\n\n\tif (path)\n\t\tfree(path);\n\n\tif (response)\n\t\tfree(response);\n\n\tif (debugserver_client)\n\t\tdebugserver_client_free(debugserver_client);\n\n\tif (device)\n\t\tidevice_free(device);\n\n\treturn res;\n}"
  },
  {
    "function_name": "print_usage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicedebug.c",
    "lines": "180-196",
    "snippet": "static void print_usage(int argc, char **argv)\n{\n\tchar *name = NULL;\n\tname = strrchr(argv[0], '/');\n\tprintf(\"Usage: %s [OPTIONS] COMMAND\\n\", (name ? name + 1: argv[0]));\n\tprintf(\"Interact with the debugserver service of a device.\\n\\n\");\n\tprintf(\" Where COMMAND is one of:\\n\");\n\tprintf(\"  run BUNDLEID [ARGS...]\\trun app with BUNDLEID and optional ARGS on device.\\n\");\n\tprintf(\"\\n\");\n\tprintf(\" The following OPTIONS are accepted:\\n\");\n\tprintf(\"  -e, --env NAME=VALUE\\tset environment variable NAME to VALUE\\n\");\n\tprintf(\"  -u, --udid UDID\\ttarget specific device by its 40-digit device UDID\\n\");\n\tprintf(\"  -d, --debug\\t\\tenable communication debugging\\n\");\n\tprintf(\"  -h, --help\\t\\tprints usage information\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"Homepage: <\" PACKAGE_URL \">\\n\");\n}",
    "includes": [
      "#include \"common/debug.h\"",
      "#include <plist/plist.h>",
      "#include <libimobiledevice/debugserver.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <libimobiledevice/installation_proxy.h>",
      "#include <windows.h>",
      "#include <libgen.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Homepage: <\" PACKAGE_URL \">\\n\""
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  -h, --help\\t\\tprints usage information\\n\""
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  -d, --debug\\t\\tenable communication debugging\\n\""
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  -u, --udid UDID\\ttarget specific device by its 40-digit device UDID\\n\""
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  -e, --env NAME=VALUE\\tset environment variable NAME to VALUE\\n\""
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" The following OPTIONS are accepted:\\n\""
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  run BUNDLEID [ARGS...]\\trun app with BUNDLEID and optional ARGS on device.\\n\""
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" Where COMMAND is one of:\\n\""
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Interact with the debugserver service of a device.\\n\\n\""
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Usage: %s [OPTIONS] COMMAND\\n\"",
            "(name ? name + 1: argv[0])"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "asprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/include/asprintf.h",
          "lines": "23-31",
          "snippet": "static inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}",
          "includes": [
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <config.h>\n\nstatic inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "argv[0]",
            "'/'"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common/debug.h\"\n#include <plist/plist.h>\n#include <libimobiledevice/debugserver.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <libimobiledevice/installation_proxy.h>\n#include <windows.h>\n#include <libgen.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <config.h>\n\nstatic void print_usage(int argc, char **argv)\n{\n\tchar *name = NULL;\n\tname = strrchr(argv[0], '/');\n\tprintf(\"Usage: %s [OPTIONS] COMMAND\\n\", (name ? name + 1: argv[0]));\n\tprintf(\"Interact with the debugserver service of a device.\\n\\n\");\n\tprintf(\" Where COMMAND is one of:\\n\");\n\tprintf(\"  run BUNDLEID [ARGS...]\\trun app with BUNDLEID and optional ARGS on device.\\n\");\n\tprintf(\"\\n\");\n\tprintf(\" The following OPTIONS are accepted:\\n\");\n\tprintf(\"  -e, --env NAME=VALUE\\tset environment variable NAME to VALUE\\n\");\n\tprintf(\"  -u, --udid UDID\\ttarget specific device by its 40-digit device UDID\\n\");\n\tprintf(\"  -d, --debug\\t\\tenable communication debugging\\n\");\n\tprintf(\"  -h, --help\\t\\tprints usage information\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"Homepage: <\" PACKAGE_URL \">\\n\");\n}"
  },
  {
    "function_name": "debugserver_client_handle_response",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicedebug.c",
    "lines": "105-178",
    "snippet": "static debugserver_error_t debugserver_client_handle_response(debugserver_client_t client, char** response, int send_reply)\n{\n\tdebugserver_error_t dres = DEBUGSERVER_E_SUCCESS;\n\tdebugserver_command_t command = NULL;\n\tchar* o = NULL;\n\tchar* r = *response;\n\n\tif (r[0] == 'O') {\n\t\t/* stdout/stderr */\n\t\tdebugserver_decode_string(r + 1, strlen(r) - 1, &o);\n\t\tprintf(\"%s\", o);\n\t\tfflush(stdout);\n\t\tif (o != NULL) {\n\t\t\tfree(o);\n\t\t\to = NULL;\n\t\t}\n\n\t\tfree(*response);\n\t\t*response = NULL;\n\n\t\tif (!send_reply)\n\t\t\treturn dres;\n\n\t\t/* send reply */\n\t\tdebugserver_command_new(\"OK\", 0, NULL, &command);\n\t\tdres = debugserver_client_send_command(client, command, response);\n\t\tdebug_info(\"result: %d\", dres);\n\t\tdebugserver_command_free(command);\n\t\tcommand = NULL;\n\t} else if (r[0] == 'T') {\n\t\t/* thread stopped information */\n\t\tdebug_info(\"Thread stopped. Details:\\n%s\", r + 1);\n\n\t\tfree(*response);\n\t\t*response = NULL;\n\n\t\tif (!send_reply)\n\t\t\treturn dres;\n\n\t\tdres = DEBUGSERVER_E_UNKNOWN_ERROR;\n\t} else if (r[0] == 'E' || r[0] == 'W') {\n\t\tprintf(\"%s: %s\\n\", (r[0] == 'E' ? \"ERROR\": \"WARNING\") , r + 1);\n\n\t\tfree(*response);\n\t\t*response = NULL;\n\n\t\tif (!send_reply)\n\t\t\treturn dres;\n\n\t\t/* send reply */\n\t\tdebugserver_command_new(\"OK\", 0, NULL, &command);\n\t\tdres = debugserver_client_send_command(client, command, response);\n\t\tdebug_info(\"result: %d\", dres);\n\t\tdebugserver_command_free(command);\n\t\tcommand = NULL;\n\t} else if (r && strlen(r) == 0) {\n\t\tif (!send_reply)\n\t\t\treturn dres;\n\n\t\tfree(*response);\n\t\t*response = NULL;\n\n\t\t/* no command */\n\t\tdebugserver_command_new(\"OK\", 0, NULL, &command);\n\t\tdres = debugserver_client_send_command(client, command, response);\n\t\tdebug_info(\"result: %d\", dres);\n\t\tdebugserver_command_free(command);\n\t\tcommand = NULL;\n\t} else {\n\t\tdebug_info(\"ERROR: unhandled response\", r);\n\t}\n\n\treturn dres;\n}",
    "includes": [
      "#include \"common/debug.h\"",
      "#include <plist/plist.h>",
      "#include <libimobiledevice/debugserver.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <libimobiledevice/installation_proxy.h>",
      "#include <windows.h>",
      "#include <libgen.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"ERROR: unhandled response\"",
            "r"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugserver_command_free",
          "args": [
            "command"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "debugserver_command_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/debugserver.c",
          "lines": "181-203",
          "snippet": "LIBIMOBILEDEVICE_API debugserver_error_t debugserver_command_free(debugserver_command_t command)\n{\n\tint i;\n\tdebugserver_error_t res = DEBUGSERVER_E_UNKNOWN_ERROR;\n\n\tif (!command)\n\t\treturn DEBUGSERVER_E_INVALID_ARG;\n\n\tif (command) {\n\t\tif (command->name)\n\t\t\tfree(command->name);\n\t\tif (command->argv && command->argc) {\n\t\t\tfor (i = 0; i < command->argc; i++) {\n\t\t\t\tfree(command->argv[i]);\n\t\t\t}\n\t\t\tfree(command->argv);\n\t\t}\n\t\tfree(command);\n\t\tres = DEBUGSERVER_E_SUCCESS;\n\t}\n\n\treturn res;\n}",
          "includes": [
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/debug.h\"",
            "#include \"lockdown.h\"",
            "#include \"debugserver.h\"",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/debug.h\"\n#include \"lockdown.h\"\n#include \"debugserver.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API debugserver_error_t debugserver_command_free(debugserver_command_t command)\n{\n\tint i;\n\tdebugserver_error_t res = DEBUGSERVER_E_UNKNOWN_ERROR;\n\n\tif (!command)\n\t\treturn DEBUGSERVER_E_INVALID_ARG;\n\n\tif (command) {\n\t\tif (command->name)\n\t\t\tfree(command->name);\n\t\tif (command->argv && command->argc) {\n\t\t\tfor (i = 0; i < command->argc; i++) {\n\t\t\t\tfree(command->argv[i]);\n\t\t\t}\n\t\t\tfree(command->argv);\n\t\t}\n\t\tfree(command);\n\t\tres = DEBUGSERVER_E_SUCCESS;\n\t}\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"result: %d\"",
            "dres"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugserver_client_send_command",
          "args": [
            "client",
            "command",
            "response"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "debugserver_client_send_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/debugserver.c",
          "lines": "472-536",
          "snippet": "LIBIMOBILEDEVICE_API debugserver_error_t debugserver_client_send_command(debugserver_client_t client, debugserver_command_t command, char** response)\n{\n\tdebugserver_error_t res = DEBUGSERVER_E_SUCCESS;\n\tint i;\n\tuint32_t bytes = 0;\n\n\tchar* send_buffer = NULL;\n\tuint32_t send_buffer_size = 0;\n\n\tchar* command_arguments = NULL;\n\n\t/* concat all arguments */\n\tchar* tmp = NULL;\n\tchar* newtmp = NULL;\n\tfor (i = 0; i < command->argc; i++) {\n\t\tdebug_info(\"argv[%d]: %s\", i, command->argv[i]);\n\t\tif (!tmp) {\n\t\t\ttmp = strdup(command->argv[i]);\n\t\t} else {\n\t\t\tnewtmp = string_concat(tmp, command->argv[i], NULL);\n\t\t\tfree(tmp);\n\t\t\ttmp = newtmp;\n\t\t}\n\t}\n\tcommand_arguments = tmp;\n\ttmp = NULL;\n\n\tdebug_info(\"command_arguments(%d): %s\", command->argc, command_arguments);\n\n\t/* encode command arguments, add checksum if required and assemble entire command */\n\tdebugserver_format_command(\"$\", command->name, command_arguments, !client->noack_mode, &send_buffer, &send_buffer_size);\n\n\tdebug_info(\"sending encoded command: %s\", send_buffer);\n\n\tres = debugserver_client_send(client, send_buffer, send_buffer_size, &bytes);\n\tdebug_info(\"command result: %d\", res);\n\tif (res != DEBUGSERVER_E_SUCCESS) {\n\t\tgoto cleanup;\n\t}\n\n\t/* receive response */\n\tres = debugserver_client_receive_response(client, response);\n\tdebug_info(\"response result: %d\", res);\n\tif (res != DEBUGSERVER_E_SUCCESS) {\n\t\tgoto cleanup;\n\t}\n\n\tif (response) {\n\t\tdebug_info(\"received response: %s\", *response);\n\t}\n\n\t/* disable sending ack on the client */\n\tif (!strncmp(command->name, \"QStartNoAckMode\", 16)) {\n\t\tdebugserver_client_set_ack_mode(client, 0);\n\t}\n\ncleanup:\n\tif (command_arguments)\n\t\tfree(command_arguments);\n\n\tif (send_buffer)\n\t\tfree(send_buffer);\n\n\treturn res;\n}",
          "includes": [
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/debug.h\"",
            "#include \"lockdown.h\"",
            "#include \"debugserver.h\"",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/debug.h\"\n#include \"lockdown.h\"\n#include \"debugserver.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API debugserver_error_t debugserver_client_send_command(debugserver_client_t client, debugserver_command_t command, char** response)\n{\n\tdebugserver_error_t res = DEBUGSERVER_E_SUCCESS;\n\tint i;\n\tuint32_t bytes = 0;\n\n\tchar* send_buffer = NULL;\n\tuint32_t send_buffer_size = 0;\n\n\tchar* command_arguments = NULL;\n\n\t/* concat all arguments */\n\tchar* tmp = NULL;\n\tchar* newtmp = NULL;\n\tfor (i = 0; i < command->argc; i++) {\n\t\tdebug_info(\"argv[%d]: %s\", i, command->argv[i]);\n\t\tif (!tmp) {\n\t\t\ttmp = strdup(command->argv[i]);\n\t\t} else {\n\t\t\tnewtmp = string_concat(tmp, command->argv[i], NULL);\n\t\t\tfree(tmp);\n\t\t\ttmp = newtmp;\n\t\t}\n\t}\n\tcommand_arguments = tmp;\n\ttmp = NULL;\n\n\tdebug_info(\"command_arguments(%d): %s\", command->argc, command_arguments);\n\n\t/* encode command arguments, add checksum if required and assemble entire command */\n\tdebugserver_format_command(\"$\", command->name, command_arguments, !client->noack_mode, &send_buffer, &send_buffer_size);\n\n\tdebug_info(\"sending encoded command: %s\", send_buffer);\n\n\tres = debugserver_client_send(client, send_buffer, send_buffer_size, &bytes);\n\tdebug_info(\"command result: %d\", res);\n\tif (res != DEBUGSERVER_E_SUCCESS) {\n\t\tgoto cleanup;\n\t}\n\n\t/* receive response */\n\tres = debugserver_client_receive_response(client, response);\n\tdebug_info(\"response result: %d\", res);\n\tif (res != DEBUGSERVER_E_SUCCESS) {\n\t\tgoto cleanup;\n\t}\n\n\tif (response) {\n\t\tdebug_info(\"received response: %s\", *response);\n\t}\n\n\t/* disable sending ack on the client */\n\tif (!strncmp(command->name, \"QStartNoAckMode\", 16)) {\n\t\tdebugserver_client_set_ack_mode(client, 0);\n\t}\n\ncleanup:\n\tif (command_arguments)\n\t\tfree(command_arguments);\n\n\tif (send_buffer)\n\t\tfree(send_buffer);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugserver_command_new",
          "args": [
            "\"OK\"",
            "0",
            "NULL",
            "&command"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "debugserver_command_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/debugserver.c",
          "lines": "156-179",
          "snippet": "LIBIMOBILEDEVICE_API debugserver_error_t debugserver_command_new(const char* name, int argc, char* argv[], debugserver_command_t* command)\n{\n\tint i;\n\tdebugserver_command_t tmp = (debugserver_command_t) malloc(sizeof(struct debugserver_command_private));\n\n\t/* copy name */\n\ttmp->name = strdup(name);\n\n\t/* copy arguments */\n\ttmp->argc = argc;\n\ttmp->argv = NULL;\n\tif (argc > 0) {\n\t\ttmp->argv = malloc(sizeof(char*) * (argc + 2));\n\t\tfor (i = 0; i < argc; i++) {\n\t\t\ttmp->argv[i] = strdup(argv[i]);\n\t\t}\n\t\ttmp->argv[i+1] = NULL;\n\t}\n\n\t/* return */\n\t*command = tmp;\n\n\treturn DEBUGSERVER_E_SUCCESS;\n}",
          "includes": [
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/debug.h\"",
            "#include \"lockdown.h\"",
            "#include \"debugserver.h\"",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/debug.h\"\n#include \"lockdown.h\"\n#include \"debugserver.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API debugserver_error_t debugserver_command_new(const char* name, int argc, char* argv[], debugserver_command_t* command)\n{\n\tint i;\n\tdebugserver_command_t tmp = (debugserver_command_t) malloc(sizeof(struct debugserver_command_private));\n\n\t/* copy name */\n\ttmp->name = strdup(name);\n\n\t/* copy arguments */\n\ttmp->argc = argc;\n\ttmp->argv = NULL;\n\tif (argc > 0) {\n\t\ttmp->argv = malloc(sizeof(char*) * (argc + 2));\n\t\tfor (i = 0; i < argc; i++) {\n\t\t\ttmp->argv[i] = strdup(argv[i]);\n\t\t}\n\t\ttmp->argv[i+1] = NULL;\n\t}\n\n\t/* return */\n\t*command = tmp;\n\n\treturn DEBUGSERVER_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "*response"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "thread_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "39-44",
          "snippet": "void thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nvoid thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "r"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"result: %d\"",
            "dres"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: %s\\n\"",
            "(r[0] == 'E' ? \"ERROR\": \"WARNING\")",
            "r + 1"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "asprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/include/asprintf.h",
          "lines": "23-31",
          "snippet": "static inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}",
          "includes": [
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <config.h>\n\nstatic inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"Thread stopped. Details:\\n%s\"",
            "r + 1"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"result: %d\"",
            "dres"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stdout"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugserver_decode_string",
          "args": [
            "r + 1",
            "strlen(r) - 1",
            "&o"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "debugserver_decode_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/debugserver.c",
          "lines": "275-286",
          "snippet": "LIBIMOBILEDEVICE_API void debugserver_decode_string(const char *encoded_buffer, size_t encoded_length, char** buffer)\n{\n\t*buffer = malloc(sizeof(char) * ((encoded_length / 2)+1));\n\tchar* t = *buffer;\n\tconst char *f = encoded_buffer;\n\tconst char *fend = f + encoded_length;\n\twhile (f < fend) {\n\t\t*t++ = debugserver_hex2int(*f) << 4 | debugserver_hex2int(f[1]);\n\t\tf += 2;\n\t}\n\t*t = '\\0';\n}",
          "includes": [
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/debug.h\"",
            "#include \"lockdown.h\"",
            "#include \"debugserver.h\"",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/debug.h\"\n#include \"lockdown.h\"\n#include \"debugserver.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API void debugserver_decode_string(const char *encoded_buffer, size_t encoded_length, char** buffer)\n{\n\t*buffer = malloc(sizeof(char) * ((encoded_length / 2)+1));\n\tchar* t = *buffer;\n\tconst char *f = encoded_buffer;\n\tconst char *fend = f + encoded_length;\n\twhile (f < fend) {\n\t\t*t++ = debugserver_hex2int(*f) << 4 | debugserver_hex2int(f[1]);\n\t\tf += 2;\n\t}\n\t*t = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "r"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common/debug.h\"\n#include <plist/plist.h>\n#include <libimobiledevice/debugserver.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <libimobiledevice/installation_proxy.h>\n#include <windows.h>\n#include <libgen.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <config.h>\n\nstatic debugserver_error_t debugserver_client_handle_response(debugserver_client_t client, char** response, int send_reply)\n{\n\tdebugserver_error_t dres = DEBUGSERVER_E_SUCCESS;\n\tdebugserver_command_t command = NULL;\n\tchar* o = NULL;\n\tchar* r = *response;\n\n\tif (r[0] == 'O') {\n\t\t/* stdout/stderr */\n\t\tdebugserver_decode_string(r + 1, strlen(r) - 1, &o);\n\t\tprintf(\"%s\", o);\n\t\tfflush(stdout);\n\t\tif (o != NULL) {\n\t\t\tfree(o);\n\t\t\to = NULL;\n\t\t}\n\n\t\tfree(*response);\n\t\t*response = NULL;\n\n\t\tif (!send_reply)\n\t\t\treturn dres;\n\n\t\t/* send reply */\n\t\tdebugserver_command_new(\"OK\", 0, NULL, &command);\n\t\tdres = debugserver_client_send_command(client, command, response);\n\t\tdebug_info(\"result: %d\", dres);\n\t\tdebugserver_command_free(command);\n\t\tcommand = NULL;\n\t} else if (r[0] == 'T') {\n\t\t/* thread stopped information */\n\t\tdebug_info(\"Thread stopped. Details:\\n%s\", r + 1);\n\n\t\tfree(*response);\n\t\t*response = NULL;\n\n\t\tif (!send_reply)\n\t\t\treturn dres;\n\n\t\tdres = DEBUGSERVER_E_UNKNOWN_ERROR;\n\t} else if (r[0] == 'E' || r[0] == 'W') {\n\t\tprintf(\"%s: %s\\n\", (r[0] == 'E' ? \"ERROR\": \"WARNING\") , r + 1);\n\n\t\tfree(*response);\n\t\t*response = NULL;\n\n\t\tif (!send_reply)\n\t\t\treturn dres;\n\n\t\t/* send reply */\n\t\tdebugserver_command_new(\"OK\", 0, NULL, &command);\n\t\tdres = debugserver_client_send_command(client, command, response);\n\t\tdebug_info(\"result: %d\", dres);\n\t\tdebugserver_command_free(command);\n\t\tcommand = NULL;\n\t} else if (r && strlen(r) == 0) {\n\t\tif (!send_reply)\n\t\t\treturn dres;\n\n\t\tfree(*response);\n\t\t*response = NULL;\n\n\t\t/* no command */\n\t\tdebugserver_command_new(\"OK\", 0, NULL, &command);\n\t\tdres = debugserver_client_send_command(client, command, response);\n\t\tdebug_info(\"result: %d\", dres);\n\t\tdebugserver_command_free(command);\n\t\tcommand = NULL;\n\t} else {\n\t\tdebug_info(\"ERROR: unhandled response\", r);\n\t}\n\n\treturn dres;\n}"
  },
  {
    "function_name": "instproxy_client_get_object_by_key_from_info_directionary_for_bundle_identifier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicedebug.c",
    "lines": "58-103",
    "snippet": "static instproxy_error_t instproxy_client_get_object_by_key_from_info_directionary_for_bundle_identifier(instproxy_client_t client, const char* appid, const char* key, plist_t* node)\n{\n\tif (!client || !appid || !key)\n\t\treturn INSTPROXY_E_INVALID_ARG;\n\n\tplist_t apps = NULL;\n\n\t// create client options for any application types\n\tplist_t client_opts = instproxy_client_options_new();\n\tinstproxy_client_options_add(client_opts, \"ApplicationType\", \"Any\", NULL);\n\n\t// only return attributes we need\n\tinstproxy_client_options_set_return_attributes(client_opts, \"CFBundleIdentifier\", \"CFBundleExecutable\", key, NULL);\n\n\t// only query for specific appid\n\tconst char* appids[] = {appid, NULL};\n\n\t// query device for list of apps\n\tinstproxy_error_t ierr = instproxy_lookup(client, appids, client_opts, &apps);\n\n\tinstproxy_client_options_free(client_opts);\n\n\tif (ierr != INSTPROXY_E_SUCCESS) {\n\t\treturn ierr;\n\t}\n\n\tplist_t app_found = plist_access_path(apps, 1, appid);\n\tif (!app_found) {\n\t\tif (apps)\n\t\t\tplist_free(apps);\n\t\t*node = NULL;\n\t\treturn INSTPROXY_E_OP_FAILED;\n\t}\n\n\tplist_t object = plist_dict_get_item(app_found, key);\n\tif (object) {\n\t\t*node = plist_copy(object);\n\t} else {\n\t\tdebug_info(\"key %s not found\", key);\n\t\treturn INSTPROXY_E_OP_FAILED;\n\t}\n\n\tplist_free(apps);\n\n\treturn INSTPROXY_E_SUCCESS;\n}",
    "includes": [
      "#include \"common/debug.h\"",
      "#include <plist/plist.h>",
      "#include <libimobiledevice/debugserver.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <libimobiledevice/installation_proxy.h>",
      "#include <windows.h>",
      "#include <libgen.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "plist_free",
          "args": [
            "apps"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_info",
          "args": [
            "\"key %s not found\"",
            "key"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_copy",
          "args": [
            "object"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "app_found",
            "key"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_free",
          "args": [
            "apps"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_access_path",
          "args": [
            "apps",
            "1",
            "appid"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instproxy_client_options_free",
          "args": [
            "client_opts"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instproxy_lookup",
          "args": [
            "client",
            "appids",
            "client_opts",
            "&apps"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instproxy_client_options_set_return_attributes",
          "args": [
            "client_opts",
            "\"CFBundleIdentifier\"",
            "\"CFBundleExecutable\"",
            "key",
            "NULL"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instproxy_client_options_add",
          "args": [
            "client_opts",
            "\"ApplicationType\"",
            "\"Any\"",
            "NULL"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instproxy_client_options_new",
          "args": [],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common/debug.h\"\n#include <plist/plist.h>\n#include <libimobiledevice/debugserver.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <libimobiledevice/installation_proxy.h>\n#include <windows.h>\n#include <libgen.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <config.h>\n\nstatic instproxy_error_t instproxy_client_get_object_by_key_from_info_directionary_for_bundle_identifier(instproxy_client_t client, const char* appid, const char* key, plist_t* node)\n{\n\tif (!client || !appid || !key)\n\t\treturn INSTPROXY_E_INVALID_ARG;\n\n\tplist_t apps = NULL;\n\n\t// create client options for any application types\n\tplist_t client_opts = instproxy_client_options_new();\n\tinstproxy_client_options_add(client_opts, \"ApplicationType\", \"Any\", NULL);\n\n\t// only return attributes we need\n\tinstproxy_client_options_set_return_attributes(client_opts, \"CFBundleIdentifier\", \"CFBundleExecutable\", key, NULL);\n\n\t// only query for specific appid\n\tconst char* appids[] = {appid, NULL};\n\n\t// query device for list of apps\n\tinstproxy_error_t ierr = instproxy_lookup(client, appids, client_opts, &apps);\n\n\tinstproxy_client_options_free(client_opts);\n\n\tif (ierr != INSTPROXY_E_SUCCESS) {\n\t\treturn ierr;\n\t}\n\n\tplist_t app_found = plist_access_path(apps, 1, appid);\n\tif (!app_found) {\n\t\tif (apps)\n\t\t\tplist_free(apps);\n\t\t*node = NULL;\n\t\treturn INSTPROXY_E_OP_FAILED;\n\t}\n\n\tplist_t object = plist_dict_get_item(app_found, key);\n\tif (object) {\n\t\t*node = plist_copy(object);\n\t} else {\n\t\tdebug_info(\"key %s not found\", key);\n\t\treturn INSTPROXY_E_OP_FAILED;\n\t}\n\n\tplist_free(apps);\n\n\treturn INSTPROXY_E_SUCCESS;\n}"
  },
  {
    "function_name": "on_signal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicedebug.c",
    "lines": "52-56",
    "snippet": "static void on_signal(int sig)\n{\n\tfprintf(stderr, \"Exiting...\\n\");\n\tquit_flag++;\n}",
    "includes": [
      "#include \"common/debug.h\"",
      "#include <plist/plist.h>",
      "#include <libimobiledevice/debugserver.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <libimobiledevice/installation_proxy.h>",
      "#include <windows.h>",
      "#include <libgen.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <signal.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int quit_flag = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Exiting...\\n\""
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common/debug.h\"\n#include <plist/plist.h>\n#include <libimobiledevice/debugserver.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <libimobiledevice/installation_proxy.h>\n#include <windows.h>\n#include <libgen.h>\n#include <unistd.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <config.h>\n\nstatic int quit_flag = 0;\n\nstatic void on_signal(int sig)\n{\n\tfprintf(stderr, \"Exiting...\\n\");\n\tquit_flag++;\n}"
  }
]