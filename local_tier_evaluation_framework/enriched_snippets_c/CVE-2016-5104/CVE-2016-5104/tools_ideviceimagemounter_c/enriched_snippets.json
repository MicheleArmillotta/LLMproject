[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/ideviceimagemounter.c",
    "lines": "142-457",
    "snippet": "int main(int argc, char **argv)\n{\n\tidevice_t device = NULL;\n\tlockdownd_client_t lckd = NULL;\n\tlockdownd_error_t ldret = LOCKDOWN_E_UNKNOWN_ERROR;\n\tmobile_image_mounter_client_t mim = NULL;\n\tafc_client_t afc = NULL;\n\tlockdownd_service_descriptor_t service = NULL;\n\tint res = -1;\n\tchar *image_path = NULL;\n\tsize_t image_size = 0;\n\tchar *image_sig_path = NULL;\n\n\tparse_opts(argc, argv);\n\n\targc -= optind;\n\targv += optind;\n\n\tif (!list_mode) {\n\t\tif (argc < 1) {\n\t\t\tprintf(\"ERROR: No IMAGE_FILE has been given!\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\timage_path = strdup(argv[0]);\n\t\tif (argc >= 2) {\n\t\t\timage_sig_path = strdup(argv[1]);\n\t\t} else {\n\t\t\tif (asprintf(&image_sig_path, \"%s.signature\", image_path) < 0) {\n\t\t\t\tprintf(\"Out of memory?!\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (IDEVICE_E_SUCCESS != idevice_new(&device, udid)) {\n\t\tprintf(\"No device found, is it plugged in?\\n\");\n\t\treturn -1;\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS != (ldret = lockdownd_client_new_with_handshake(device, &lckd, \"ideviceimagemounter\"))) {\n\t\tprintf(\"ERROR: Could not connect to lockdown, error code %d.\\n\", ldret);\n\t\tgoto leave;\n\t}\n\n\tplist_t pver = NULL;\n\tchar *product_version = NULL;\n\tlockdownd_get_value(lckd, NULL, \"ProductVersion\", &pver);\n\tif (pver && plist_get_node_type(pver) == PLIST_STRING) {\n\t\tplist_get_string_val(pver, &product_version);\n\t}\n\tdisk_image_upload_type_t disk_image_upload_type = DISK_IMAGE_UPLOAD_TYPE_AFC;\n\tint product_version_major = 0;\n\tint product_version_minor = 0;\n\tif (product_version) {\n\t\tif (sscanf(product_version, \"%d.%d.%*d\", &product_version_major, &product_version_minor) == 2) {\n\t\t\tif (product_version_major >= 7)\n\t\t\t\tdisk_image_upload_type = DISK_IMAGE_UPLOAD_TYPE_UPLOAD_IMAGE;\n\t\t}\n\t}\n\n\tlockdownd_start_service(lckd, \"com.apple.mobile.mobile_image_mounter\", &service);\n\n\tif (!service || service->port == 0) {\n\t\tprintf(\"ERROR: Could not start mobile_image_mounter service!\\n\");\n\t\tgoto leave;\n\t}\n\n\tif (mobile_image_mounter_new(device, service, &mim) != MOBILE_IMAGE_MOUNTER_E_SUCCESS) {\n\t\tprintf(\"ERROR: Could not connect to mobile_image_mounter!\\n\");\n\t\tgoto leave;\n\t}\n\n\tif (service) {\n\t\tlockdownd_service_descriptor_free(service);\n\t\tservice = NULL;\n\t}\n\n\tif (!list_mode) {\n\t\tstruct stat fst;\n\t\tif (disk_image_upload_type == DISK_IMAGE_UPLOAD_TYPE_AFC) {\n\t\t\tif ((lockdownd_start_service(lckd, \"com.apple.afc\", &service) !=\n\t\t\t\t LOCKDOWN_E_SUCCESS) || !service || !service->port) {\n\t\t\t\tfprintf(stderr, \"Could not start com.apple.afc!\\n\");\n\t\t\t\tgoto leave;\n\t\t\t}\n\t\t\tif (afc_client_new(device, service, &afc) != AFC_E_SUCCESS) {\n\t\t\t\tfprintf(stderr, \"Could not connect to AFC!\\n\");\n\t\t\t\tgoto leave;\n\t\t\t}\n\t\t\tif (service) {\n\t\t\t\tlockdownd_service_descriptor_free(service);\n\t\t\t\tservice = NULL;\n\t\t\t}\n\t\t}\n\t\tif (stat(image_path, &fst) != 0) {\n\t\t\tfprintf(stderr, \"ERROR: stat: %s: %s\\n\", image_path, strerror(errno));\n\t\t\tgoto leave;\n\t\t}\n\t\timage_size = fst.st_size;\n\t\tif (stat(image_sig_path, &fst) != 0) {\n\t\t\tfprintf(stderr, \"ERROR: stat: %s: %s\\n\", image_sig_path, strerror(errno));\n\t\t\tgoto leave;\n\t\t}\n\t}\n\n\tlockdownd_client_free(lckd);\n\tlckd = NULL;\n\n\tmobile_image_mounter_error_t err;\n\tplist_t result = NULL;\n\n\tif (list_mode) {\n\t\t/* list mounts mode */\n\t\tif (!imagetype) {\n\t\t\timagetype = strdup(\"Developer\");\n\t\t}\n\t\terr = mobile_image_mounter_lookup_image(mim, imagetype, &result);\n\t\tfree(imagetype);\n\t\tif (err == MOBILE_IMAGE_MOUNTER_E_SUCCESS) {\n\t\t\tres = 0;\n\t\t\tif (xml_mode) {\n\t\t\t\tprint_xml(result);\n\t\t\t} else {\n\t\t\t\tplist_print_to_stream(result, stdout);\n\t\t\t}\n\t\t} else {\n\t\t\tprintf(\"Error: lookup_image returned %d\\n\", err);\n\t\t}\n\t} else {\n\t\tchar sig[8192];\n\t\tsize_t sig_length = 0;\n\t\tFILE *f = fopen(image_sig_path, \"rb\");\n\t\tif (!f) {\n\t\t\tfprintf(stderr, \"Error opening signature file '%s': %s\\n\", image_sig_path, strerror(errno));\n\t\t\tgoto leave;\n\t\t}\n\t\tsig_length = fread(sig, 1, sizeof(sig), f);\n\t\tfclose(f);\n\t\tif (sig_length == 0) {\n\t\t\tfprintf(stderr, \"Could not read signature from file '%s'\\n\", image_sig_path);\n\t\t\tgoto leave;\n\t\t}\n\n\t\tf = fopen(image_path, \"rb\");\n\t\tif (!f) {\n\t\t\tfprintf(stderr, \"Error opening image file '%s': %s\\n\", image_path, strerror(errno));\n\t\t\tgoto leave;\n\t\t}\n\n\t\tchar *targetname = NULL;\n\t\tif (asprintf(&targetname, \"%s/%s\", PKG_PATH, \"staging.dimage\") < 0) {\n\t\t\tfprintf(stderr, \"Out of memory!?\\n\");\n\t\t\tgoto leave;\n\t\t}\n\t\tchar *mountname = NULL;\n\t\tif (asprintf(&mountname, \"%s/%s\", PATH_PREFIX, targetname) < 0) {\n\t\t\tfprintf(stderr, \"Out of memory!?\\n\");\n\t\t\tgoto leave;\n\t\t}\n\n\n\t\tif (!imagetype) {\n\t\t\timagetype = strdup(\"Developer\");\n\t\t}\n\n\t\tswitch(disk_image_upload_type) {\n\t\t\tcase DISK_IMAGE_UPLOAD_TYPE_UPLOAD_IMAGE:\n\t\t\t\tprintf(\"Uploading %s\\n\", image_path);\n\t\t\t\terr = mobile_image_mounter_upload_image(mim, imagetype, image_size, sig, sig_length, mim_upload_cb, f);\n\t\t\t\tbreak;\n\t\t\tcase DISK_IMAGE_UPLOAD_TYPE_AFC:\n\t\t\tdefault:\n\t\t\t\tprintf(\"Uploading %s --> afc:///%s\\n\", image_path, targetname);\n\t\t\t\tchar **strs = NULL;\n\t\t\t\tif (afc_get_file_info(afc, PKG_PATH, &strs) != AFC_E_SUCCESS) {\n\t\t\t\t\tif (afc_make_directory(afc, PKG_PATH) != AFC_E_SUCCESS) {\n\t\t\t\t\t\tfprintf(stderr, \"WARNING: Could not create directory '%s' on device!\\n\", PKG_PATH);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (strs) {\n\t\t\t\t\tint i = 0;\n\t\t\t\t\twhile (strs[i]) {\n\t\t\t\t\t\tfree(strs[i]);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tfree(strs);\n\t\t\t\t}\n\n\t\t\t\tuint64_t af = 0;\n\t\t\t\tif ((afc_file_open(afc, targetname, AFC_FOPEN_WRONLY, &af) !=\n\t\t\t\t\t AFC_E_SUCCESS) || !af) {\n\t\t\t\t\tfclose(f);\n\t\t\t\t\tfprintf(stderr, \"afc_file_open on '%s' failed!\\n\", targetname);\n\t\t\t\t\tgoto leave;\n\t\t\t\t}\n\n\t\t\t\tchar buf[8192];\n\t\t\t\tsize_t amount = 0;\n\t\t\t\tdo {\n\t\t\t\t\tamount = fread(buf, 1, sizeof(buf), f);\n\t\t\t\t\tif (amount > 0) {\n\t\t\t\t\t\tuint32_t written, total = 0;\n\t\t\t\t\t\twhile (total < amount) {\n\t\t\t\t\t\t\twritten = 0;\n\t\t\t\t\t\t\tif (afc_file_write(afc, af, buf, amount, &written) !=\n\t\t\t\t\t\t\t\tAFC_E_SUCCESS) {\n\t\t\t\t\t\t\t\tfprintf(stderr, \"AFC Write error!\\n\");\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttotal += written;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (total != amount) {\n\t\t\t\t\t\t\tfprintf(stderr, \"Error: wrote only %d of %d\\n\", total,\n\t\t\t\t\t\t\t\t\t(unsigned int)amount);\n\t\t\t\t\t\t\tafc_file_close(afc, af);\n\t\t\t\t\t\t\tfclose(f);\n\t\t\t\t\t\t\tgoto leave;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile (amount > 0);\n\n\t\t\t\tafc_file_close(afc, af);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tfclose(f);\n\n\t\tprintf(\"done.\\n\");\n\n\t\tprintf(\"Mounting...\\n\");\n\t\terr = mobile_image_mounter_mount_image(mim, mountname, sig, sig_length, imagetype, &result);\n\t\tfree(imagetype);\n\t\tif (err == MOBILE_IMAGE_MOUNTER_E_SUCCESS) {\n\t\t\tif (result) {\n\t\t\t\tplist_t node = plist_dict_get_item(result, \"Status\");\n\t\t\t\tif (node) {\n\t\t\t\t\tchar *status = NULL;\n\t\t\t\t\tplist_get_string_val(node, &status);\n\t\t\t\t\tif (status) {\n\t\t\t\t\t\tif (!strcmp(status, \"Complete\")) {\n\t\t\t\t\t\t\tprintf(\"Done.\\n\");\n\t\t\t\t\t\t\tres = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tprintf(\"unexpected status value:\\n\");\n\t\t\t\t\t\t\tif (xml_mode) {\n\t\t\t\t\t\t\t\tprint_xml(result);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tplist_print_to_stream(result, stdout);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree(status);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprintf(\"unexpected result:\\n\");\n\t\t\t\t\t\tif (xml_mode) {\n\t\t\t\t\t\t\tprint_xml(result);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tplist_print_to_stream(result, stdout);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnode = plist_dict_get_item(result, \"Error\");\n\t\t\t\tif (node) {\n\t\t\t\t\tchar *error = NULL;\n\t\t\t\t\tplist_get_string_val(node, &error);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tprintf(\"Error: %s\\n\", error);\n\t\t\t\t\t\tfree(error);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprintf(\"unexpected result:\\n\");\n\t\t\t\t\t\tif (xml_mode) {\n\t\t\t\t\t\t\tprint_xml(result);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tplist_print_to_stream(result, stdout);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\tif (xml_mode) {\n\t\t\t\t\t\tprint_xml(result);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tplist_print_to_stream(result, stdout);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tprintf(\"Error: mount_image returned %d\\n\", err);\n\n\t\t}\n\t}\n\n\tif (result) {\n\t\tplist_free(result);\n\t}\n\n\t/* perform hangup command */\n\tmobile_image_mounter_hangup(mim);\n\t/* free client */\n\tmobile_image_mounter_free(mim);\n\nleave:\n\tif (afc) {\n\t\tafc_client_free(afc);\n\t}\n\tif (lckd) {\n\t\tlockdownd_client_free(lckd);\n\t}\n\tidevice_free(device);\n\n\tif (image_path)\n\t\t\tfree(image_path);\n\tif (image_sig_path)\n\t\tfree(image_sig_path);\n\n\treturn res;\n}",
    "includes": [
      "#include \"common/utils.h\"",
      "#include <asprintf.h>",
      "#include <libimobiledevice/mobile_image_mounter.h>",
      "#include <libimobiledevice/notification_proxy.h>",
      "#include <libimobiledevice/afc.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <inttypes.h>",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <libgen.h>",
      "#include <errno.h>",
      "#include <getopt.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int list_mode = 0;",
      "static int xml_mode = 0;",
      "static char *udid = NULL;",
      "static char *imagetype = NULL;",
      "static const char PKG_PATH[] = \"PublicStaging\";",
      "static const char PATH_PREFIX[] = \"/private/var/mobile/Media\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "image_sig_path"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "thread_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/thread.c",
          "lines": "39-44",
          "snippet": "void thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}",
          "includes": [
            "#include \"thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"thread.h\"\n\nvoid thread_free(thread_t thread)\n{\n#ifdef WIN32\n\tCloseHandle(thread);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "idevice_free",
          "args": [
            "device"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "idevice_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
          "lines": "247-265",
          "snippet": "LIBIMOBILEDEVICE_API idevice_error_t idevice_free(idevice_t device)\n{\n\tif (!device)\n\t\treturn IDEVICE_E_INVALID_ARG;\n\tidevice_error_t ret = IDEVICE_E_UNKNOWN_ERROR;\n\n\tret = IDEVICE_E_SUCCESS;\n\n\tfree(device->udid);\n\n\tif (device->conn_type == CONNECTION_USBMUXD) {\n\t\tdevice->conn_data = 0;\n\t}\n\tif (device->conn_data) {\n\t\tfree(device->conn_data);\n\t}\n\tfree(device);\n\treturn ret;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"common/thread.h\"",
            "#include \"common/userpref.h\"",
            "#include \"idevice.h\"",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <usbmuxd.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "LIBIMOBILEDEVICE_API idevice_error_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nLIBIMOBILEDEVICE_API idevice_error_t idevice_free(idevice_t device)\n{\n\tif (!device)\n\t\treturn IDEVICE_E_INVALID_ARG;\n\tidevice_error_t ret = IDEVICE_E_UNKNOWN_ERROR;\n\n\tret = IDEVICE_E_SUCCESS;\n\n\tfree(device->udid);\n\n\tif (device->conn_type == CONNECTION_USBMUXD) {\n\t\tdevice->conn_data = 0;\n\t}\n\tif (device->conn_data) {\n\t\tfree(device->conn_data);\n\t}\n\tfree(device);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdownd_client_free",
          "args": [
            "lckd"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "lockdownd_client_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/lockdown.c",
          "lines": "322-336",
          "snippet": "LIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_client_free(lockdownd_client_t client)\n{\n\tif (!client)\n\t\treturn LOCKDOWN_E_INVALID_ARG;\n\n\tlockdownd_error_t ret = LOCKDOWN_E_UNKNOWN_ERROR;\n\n\tif (client->session_id) {\n\t\tlockdownd_stop_session(client, client->session_id);\n\t}\n\n\tret = lockdownd_client_free_simple(client);\n\n\treturn ret;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/userpref.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"lockdown.h\"",
            "#include \"property_list_service.h\"",
            "#include <plist/plist.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/x509.h>",
            "#include <libtasn1.h>",
            "#include <openssl/x509v3.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/pem.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/userpref.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"lockdown.h\"\n#include \"property_list_service.h\"\n#include <plist/plist.h>\n#include <gnutls/crypto.h>\n#include <gnutls/x509.h>\n#include <libtasn1.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/pem.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_client_free(lockdownd_client_t client)\n{\n\tif (!client)\n\t\treturn LOCKDOWN_E_INVALID_ARG;\n\n\tlockdownd_error_t ret = LOCKDOWN_E_UNKNOWN_ERROR;\n\n\tif (client->session_id) {\n\t\tlockdownd_stop_session(client, client->session_id);\n\t}\n\n\tret = lockdownd_client_free_simple(client);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afc_client_free",
          "args": [
            "afc"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "afc_client_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "125-138",
          "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_client_free(afc_client_t client)\n{\n\tif (!client || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tif (client->free_parent && client->parent) {\n\t\tservice_client_free(client->parent);\n\t\tclient->parent = NULL;\n\t}\n\tfree(client->afc_packet);\n\tmutex_destroy(&client->mutex);\n\tfree(client);\n\treturn AFC_E_SUCCESS;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_client_free(afc_client_t client)\n{\n\tif (!client || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tif (client->free_parent && client->parent) {\n\t\tservice_client_free(client->parent);\n\t\tclient->parent = NULL;\n\t}\n\tfree(client->afc_packet);\n\tmutex_destroy(&client->mutex);\n\tfree(client);\n\treturn AFC_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mobile_image_mounter_free",
          "args": [
            "mim"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "mobile_image_mounter_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/mobile_image_mounter.c",
          "lines": "102-113",
          "snippet": "LIBIMOBILEDEVICE_API mobile_image_mounter_error_t mobile_image_mounter_free(mobile_image_mounter_client_t client)\n{\n\tif (!client)\n\t\treturn MOBILE_IMAGE_MOUNTER_E_INVALID_ARG;\n\n\tproperty_list_service_client_free(client->parent);\n\tclient->parent = NULL;\n\tmutex_destroy(&client->mutex);\n\tfree(client);\n\n\treturn MOBILE_IMAGE_MOUNTER_E_SUCCESS;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"property_list_service.h\"",
            "#include \"mobile_image_mounter.h\"",
            "#include <plist/plist.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"property_list_service.h\"\n#include \"mobile_image_mounter.h\"\n#include <plist/plist.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n\nLIBIMOBILEDEVICE_API mobile_image_mounter_error_t mobile_image_mounter_free(mobile_image_mounter_client_t client)\n{\n\tif (!client)\n\t\treturn MOBILE_IMAGE_MOUNTER_E_INVALID_ARG;\n\n\tproperty_list_service_client_free(client->parent);\n\tclient->parent = NULL;\n\tmutex_destroy(&client->mutex);\n\tfree(client);\n\n\treturn MOBILE_IMAGE_MOUNTER_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mobile_image_mounter_hangup",
          "args": [
            "mim"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "mobile_image_mounter_hangup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/mobile_image_mounter.c",
          "lines": "287-318",
          "snippet": "LIBIMOBILEDEVICE_API mobile_image_mounter_error_t mobile_image_mounter_hangup(mobile_image_mounter_client_t client)\n{\n\tif (!client) {\n\t\treturn MOBILE_IMAGE_MOUNTER_E_INVALID_ARG;\n\t}\n\tmobile_image_mounter_lock(client);\n\n\tplist_t dict = plist_new_dict();\n\tplist_dict_set_item(dict, \"Command\", plist_new_string(\"Hangup\"));\n\n\tmobile_image_mounter_error_t res = mobile_image_mounter_error(property_list_service_send_xml_plist(client->parent, dict));\n\tplist_free(dict);\n\n\tif (res != MOBILE_IMAGE_MOUNTER_E_SUCCESS) {\n\t\tdebug_info(\"%s: Error sending XML plist to device!\", __func__);\n\t\tgoto leave_unlock;\n\t}\n\n\tdict = NULL;\n\tres = mobile_image_mounter_error(property_list_service_receive_plist(client->parent, &dict));\n\tif (res != MOBILE_IMAGE_MOUNTER_E_SUCCESS) {\n\t\tdebug_info(\"%s: Error receiving response from device!\", __func__);\n\t}\n\tif (dict) {\n\t\tdebug_plist(dict);\n\t\tplist_free(dict);\n\t}\n\nleave_unlock:\n\tmobile_image_mounter_unlock(client);\n\treturn res;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"property_list_service.h\"",
            "#include \"mobile_image_mounter.h\"",
            "#include <plist/plist.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"property_list_service.h\"\n#include \"mobile_image_mounter.h\"\n#include <plist/plist.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n\nLIBIMOBILEDEVICE_API mobile_image_mounter_error_t mobile_image_mounter_hangup(mobile_image_mounter_client_t client)\n{\n\tif (!client) {\n\t\treturn MOBILE_IMAGE_MOUNTER_E_INVALID_ARG;\n\t}\n\tmobile_image_mounter_lock(client);\n\n\tplist_t dict = plist_new_dict();\n\tplist_dict_set_item(dict, \"Command\", plist_new_string(\"Hangup\"));\n\n\tmobile_image_mounter_error_t res = mobile_image_mounter_error(property_list_service_send_xml_plist(client->parent, dict));\n\tplist_free(dict);\n\n\tif (res != MOBILE_IMAGE_MOUNTER_E_SUCCESS) {\n\t\tdebug_info(\"%s: Error sending XML plist to device!\", __func__);\n\t\tgoto leave_unlock;\n\t}\n\n\tdict = NULL;\n\tres = mobile_image_mounter_error(property_list_service_receive_plist(client->parent, &dict));\n\tif (res != MOBILE_IMAGE_MOUNTER_E_SUCCESS) {\n\t\tdebug_info(\"%s: Error receiving response from device!\", __func__);\n\t}\n\tif (dict) {\n\t\tdebug_plist(dict);\n\t\tplist_free(dict);\n\t}\n\nleave_unlock:\n\tmobile_image_mounter_unlock(client);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_free",
          "args": [
            "result"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Error: mount_image returned %d\\n\"",
            "err"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "asprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/include/asprintf.h",
          "lines": "23-31",
          "snippet": "static inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}",
          "includes": [
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <config.h>\n\nstatic inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_print_to_stream",
          "args": [
            "result",
            "stdout"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "plist_print_to_stream",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/common/utils.c",
          "lines": "466-483",
          "snippet": "void plist_print_to_stream(plist_t plist, FILE* stream)\n{\n\tint indent = 0;\n\n\tif (!plist || !stream)\n\t\treturn;\n\n\tswitch (plist_get_node_type(plist)) {\n\tcase PLIST_DICT:\n\t\tplist_dict_print_to_stream(plist, &indent, stream);\n\t\tbreak;\n\tcase PLIST_ARRAY:\n\t\tplist_array_print_to_stream(plist, &indent, stream);\n\t\tbreak;\n\tdefault:\n\t\tplist_node_print_to_stream(plist, &indent, stream);\n\t}\n}",
          "includes": [
            "#include \"utils.h\"",
            "#include <ctype.h>",
            "#include <inttypes.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void plist_node_print_to_stream(plist_t node, int* indent_level, FILE* stream);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils.h\"\n#include <ctype.h>\n#include <inttypes.h>\n#include <sys/time.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic void plist_node_print_to_stream(plist_t node, int* indent_level, FILE* stream);\n\nvoid plist_print_to_stream(plist_t plist, FILE* stream)\n{\n\tint indent = 0;\n\n\tif (!plist || !stream)\n\t\treturn;\n\n\tswitch (plist_get_node_type(plist)) {\n\tcase PLIST_DICT:\n\t\tplist_dict_print_to_stream(plist, &indent, stream);\n\t\tbreak;\n\tcase PLIST_ARRAY:\n\t\tplist_array_print_to_stream(plist, &indent, stream);\n\t\tbreak;\n\tdefault:\n\t\tplist_node_print_to_stream(plist, &indent, stream);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_xml",
          "args": [
            "result"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "print_xml",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/ideviceimagemounter.c",
          "lines": "128-135",
          "snippet": "static void print_xml(plist_t node)\n{\n\tchar *xml = NULL;\n\tuint32_t len = 0;\n\tplist_to_xml(node, &xml, &len);\n\tif (xml)\n\t\tputs(xml);\n}",
          "includes": [
            "#include \"common/utils.h\"",
            "#include <asprintf.h>",
            "#include <libimobiledevice/mobile_image_mounter.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <inttypes.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <libgen.h>",
            "#include <errno.h>",
            "#include <getopt.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/utils.h\"\n#include <asprintf.h>\n#include <libimobiledevice/mobile_image_mounter.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <inttypes.h>\n#include <sys/time.h>\n#include <time.h>\n#include <libgen.h>\n#include <errno.h>\n#include <getopt.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <config.h>\n\nstatic void print_xml(plist_t node)\n{\n\tchar *xml = NULL;\n\tuint32_t len = 0;\n\tplist_to_xml(node, &xml, &len);\n\tif (xml)\n\t\tputs(xml);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"unexpected result:\\n\""
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_string_val",
          "args": [
            "node",
            "&error"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "result",
            "\"Error\""
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"unexpected result:\\n\""
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"unexpected status value:\\n\""
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Done.\\n\""
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "status",
            "\"Complete\""
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "plist_strcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
          "lines": "296-309",
          "snippet": "static int plist_strcmp(plist_t node, const char *str)\n{\n\tchar *buffer = NULL;\n\tint ret = 0;\n\n\tif (plist_get_node_type(node) != PLIST_STRING)\n\t\treturn ret;\n\n\tplist_get_string_val(node, &buffer);\n\tret = strcmp(buffer, str);\n\tfree(buffer);\n\n\treturn ret;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <unistd.h>",
            "#include <gcrypt.h>",
            "#include <openssl/sha.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int plist_strcmp(plist_t node, const char *str)\n{\n\tchar *buffer = NULL;\n\tint ret = 0;\n\n\tif (plist_get_node_type(node) != PLIST_STRING)\n\t\treturn ret;\n\n\tplist_get_string_val(node, &buffer);\n\tret = strcmp(buffer, str);\n\tfree(buffer);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "plist_get_string_val",
          "args": [
            "node",
            "&status"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_dict_get_item",
          "args": [
            "result",
            "\"Status\""
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mobile_image_mounter_mount_image",
          "args": [
            "mim",
            "mountname",
            "sig",
            "sig_length",
            "imagetype",
            "&result"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "mobile_image_mounter_mount_image",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/mobile_image_mounter.c",
          "lines": "255-285",
          "snippet": "LIBIMOBILEDEVICE_API mobile_image_mounter_error_t mobile_image_mounter_mount_image(mobile_image_mounter_client_t client, const char *image_path, const char *signature, uint16_t signature_size, const char *image_type, plist_t *result)\n{\n\tif (!client || !image_path || !image_type || !result) {\n\t\treturn MOBILE_IMAGE_MOUNTER_E_INVALID_ARG;\n\t}\n\tmobile_image_mounter_lock(client);\n\n\tplist_t dict = plist_new_dict();\n\tplist_dict_set_item(dict, \"Command\", plist_new_string(\"MountImage\"));\n\tplist_dict_set_item(dict, \"ImagePath\", plist_new_string(image_path));\n\tif (signature && signature_size != 0)\n\t\tplist_dict_set_item(dict, \"ImageSignature\", plist_new_data(signature, signature_size));\n\tplist_dict_set_item(dict, \"ImageType\", plist_new_string(image_type));\n\n\tmobile_image_mounter_error_t res = mobile_image_mounter_error(property_list_service_send_xml_plist(client->parent, dict));\n\tplist_free(dict);\n\n\tif (res != MOBILE_IMAGE_MOUNTER_E_SUCCESS) {\n\t\tdebug_info(\"%s: Error sending XML plist to device!\", __func__);\n\t\tgoto leave_unlock;\n\t}\n\n\tres = mobile_image_mounter_error(property_list_service_receive_plist(client->parent, result));\n\tif (res != MOBILE_IMAGE_MOUNTER_E_SUCCESS) {\n\t\tdebug_info(\"%s: Error receiving response from device!\", __func__);\n\t}\n\nleave_unlock:\n\tmobile_image_mounter_unlock(client);\n\treturn res;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"property_list_service.h\"",
            "#include \"mobile_image_mounter.h\"",
            "#include <plist/plist.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"property_list_service.h\"\n#include \"mobile_image_mounter.h\"\n#include <plist/plist.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n\nLIBIMOBILEDEVICE_API mobile_image_mounter_error_t mobile_image_mounter_mount_image(mobile_image_mounter_client_t client, const char *image_path, const char *signature, uint16_t signature_size, const char *image_type, plist_t *result)\n{\n\tif (!client || !image_path || !image_type || !result) {\n\t\treturn MOBILE_IMAGE_MOUNTER_E_INVALID_ARG;\n\t}\n\tmobile_image_mounter_lock(client);\n\n\tplist_t dict = plist_new_dict();\n\tplist_dict_set_item(dict, \"Command\", plist_new_string(\"MountImage\"));\n\tplist_dict_set_item(dict, \"ImagePath\", plist_new_string(image_path));\n\tif (signature && signature_size != 0)\n\t\tplist_dict_set_item(dict, \"ImageSignature\", plist_new_data(signature, signature_size));\n\tplist_dict_set_item(dict, \"ImageType\", plist_new_string(image_type));\n\n\tmobile_image_mounter_error_t res = mobile_image_mounter_error(property_list_service_send_xml_plist(client->parent, dict));\n\tplist_free(dict);\n\n\tif (res != MOBILE_IMAGE_MOUNTER_E_SUCCESS) {\n\t\tdebug_info(\"%s: Error sending XML plist to device!\", __func__);\n\t\tgoto leave_unlock;\n\t}\n\n\tres = mobile_image_mounter_error(property_list_service_receive_plist(client->parent, result));\n\tif (res != MOBILE_IMAGE_MOUNTER_E_SUCCESS) {\n\t\tdebug_info(\"%s: Error receiving response from device!\", __func__);\n\t}\n\nleave_unlock:\n\tmobile_image_mounter_unlock(client);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Mounting...\\n\""
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"done.\\n\""
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afc_file_close",
          "args": [
            "afc",
            "af"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "afc_file_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "749-775",
          "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_file_close(afc_client_t client, uint64_t handle)\n{\n\tuint32_t bytes = 0;\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tif (!client || (handle == 0))\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_lock(client);\n\n\tdebug_info(\"File handle %i\", handle);\n\n\t/* Send command */\n\tret = afc_dispatch_packet(client, AFC_OP_FILE_CLOSE, (const char*)&handle, 8, NULL, 0, &bytes);\n\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_UNKNOWN_ERROR;\n\t}\n\n\t/* Receive the response */\n\tret = afc_receive_data(client, NULL, &bytes);\n\n\tafc_unlock(client);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_file_close(afc_client_t client, uint64_t handle)\n{\n\tuint32_t bytes = 0;\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tif (!client || (handle == 0))\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_lock(client);\n\n\tdebug_info(\"File handle %i\", handle);\n\n\t/* Send command */\n\tret = afc_dispatch_packet(client, AFC_OP_FILE_CLOSE, (const char*)&handle, 8, NULL, 0, &bytes);\n\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_UNKNOWN_ERROR;\n\t}\n\n\t/* Receive the response */\n\tret = afc_receive_data(client, NULL, &bytes);\n\n\tafc_unlock(client);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: wrote only %d of %d\\n\"",
            "total",
            "(unsigned int)amount"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"AFC Write error!\\n\""
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afc_file_write",
          "args": [
            "afc",
            "af",
            "buf",
            "amount",
            "&written"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "afc_file_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "717-747",
          "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_file_write(afc_client_t client, uint64_t handle, const char *data, uint32_t length, uint32_t *bytes_written)\n{\n\tuint32_t current_count = 0;\n\tuint32_t bytes_loc = 0;\n\tafc_error_t ret = AFC_E_SUCCESS;\n\n\tif (!client || !client->afc_packet || !client->parent || !bytes_written || (handle == 0))\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_lock(client);\n\n\tdebug_info(\"Write length: %i\", length);\n\n\tret = afc_dispatch_packet(client, AFC_OP_FILE_WRITE, (const char*)&handle, 8, data, length, &bytes_loc);\n\n\tcurrent_count += bytes_loc - (sizeof(AFCPacket) + 8);\n\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\t*bytes_written = current_count;\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\tret = afc_receive_data(client, NULL, &bytes_loc);\n\tafc_unlock(client);\n\tif (ret != AFC_E_SUCCESS) {\n\t\tdebug_info(\"uh oh?\");\n\t}\n\t*bytes_written = current_count;\n\treturn ret;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_file_write(afc_client_t client, uint64_t handle, const char *data, uint32_t length, uint32_t *bytes_written)\n{\n\tuint32_t current_count = 0;\n\tuint32_t bytes_loc = 0;\n\tafc_error_t ret = AFC_E_SUCCESS;\n\n\tif (!client || !client->afc_packet || !client->parent || !bytes_written || (handle == 0))\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_lock(client);\n\n\tdebug_info(\"Write length: %i\", length);\n\n\tret = afc_dispatch_packet(client, AFC_OP_FILE_WRITE, (const char*)&handle, 8, data, length, &bytes_loc);\n\n\tcurrent_count += bytes_loc - (sizeof(AFCPacket) + 8);\n\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\t*bytes_written = current_count;\n\t\treturn AFC_E_SUCCESS;\n\t}\n\n\tret = afc_receive_data(client, NULL, &bytes_loc);\n\tafc_unlock(client);\n\tif (ret != AFC_E_SUCCESS) {\n\t\tdebug_info(\"uh oh?\");\n\t}\n\t*bytes_written = current_count;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fread",
          "args": [
            "buf",
            "1",
            "sizeof(buf)",
            "f"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"afc_file_open on '%s' failed!\\n\"",
            "targetname"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afc_file_open",
          "args": [
            "afc",
            "targetname",
            "AFC_FOPEN_WRONLY",
            "&af"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "afc_file_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "616-662",
          "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_file_open(afc_client_t client, const char *filename, afc_file_mode_t file_mode, uint64_t *handle)\n{\n\tif (!client || !client->parent || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tuint64_t file_mode_loc = htole64(file_mode);\n\tuint32_t bytes = 0;\n\tchar *data = (char *) malloc(sizeof(char) * (8 + strlen(filename) + 1));\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\t/* set handle to 0 so in case an error occurs, the handle is invalid */\n\t*handle = 0;\n\n\tafc_lock(client);\n\n\t/* Send command */\n\tmemcpy(data, &file_mode_loc, 8);\n\tmemcpy(data + 8, filename, strlen(filename));\n\tdata[8 + strlen(filename)] = '\\0';\n\tret = afc_dispatch_packet(client, AFC_OP_FILE_OPEN, data, 8 + strlen(filename) + 1, NULL, 0, &bytes);\n\tfree(data);\n\n\tif (ret != AFC_E_SUCCESS) {\n\t\tdebug_info(\"Didn't receive a response to the command\");\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\t/* Receive the data */\n\tdata = NULL;\n\tret = afc_receive_data(client, &data, &bytes);\n\tif ((ret == AFC_E_SUCCESS) && (bytes > 0) && data) {\n\t\tafc_unlock(client);\n\n\t\t/* Get the file handle */\n\t\tmemcpy(handle, data, sizeof(uint64_t));\n\t\tfree(data);\n\t\treturn ret;\n\t}\n\t/* in case memory was allocated but no data received or an error occurred */\n\tfree(data);\n\n\tdebug_info(\"Didn't get any further data\");\n\n\tafc_unlock(client);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_file_open(afc_client_t client, const char *filename, afc_file_mode_t file_mode, uint64_t *handle)\n{\n\tif (!client || !client->parent || !client->afc_packet)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tuint64_t file_mode_loc = htole64(file_mode);\n\tuint32_t bytes = 0;\n\tchar *data = (char *) malloc(sizeof(char) * (8 + strlen(filename) + 1));\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\t/* set handle to 0 so in case an error occurs, the handle is invalid */\n\t*handle = 0;\n\n\tafc_lock(client);\n\n\t/* Send command */\n\tmemcpy(data, &file_mode_loc, 8);\n\tmemcpy(data + 8, filename, strlen(filename));\n\tdata[8 + strlen(filename)] = '\\0';\n\tret = afc_dispatch_packet(client, AFC_OP_FILE_OPEN, data, 8 + strlen(filename) + 1, NULL, 0, &bytes);\n\tfree(data);\n\n\tif (ret != AFC_E_SUCCESS) {\n\t\tdebug_info(\"Didn't receive a response to the command\");\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\t/* Receive the data */\n\tdata = NULL;\n\tret = afc_receive_data(client, &data, &bytes);\n\tif ((ret == AFC_E_SUCCESS) && (bytes > 0) && data) {\n\t\tafc_unlock(client);\n\n\t\t/* Get the file handle */\n\t\tmemcpy(handle, data, sizeof(uint64_t));\n\t\tfree(data);\n\t\treturn ret;\n\t}\n\t/* in case memory was allocated but no data received or an error occurred */\n\tfree(data);\n\n\tdebug_info(\"Didn't get any further data\");\n\n\tafc_unlock(client);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"WARNING: Could not create directory '%s' on device!\\n\"",
            "PKG_PATH"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afc_make_directory",
          "args": [
            "afc",
            "PKG_PATH"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "afc_make_directory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "562-584",
          "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_make_directory(afc_client_t client, const char *path)\n{\n\tuint32_t bytes = 0;\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tif (!client)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_lock(client);\n\n\t/* Send command */\n\tret = afc_dispatch_packet(client, AFC_OP_MAKE_DIR, path, strlen(path)+1, NULL, 0, &bytes);\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\t/* Receive response */\n\tret = afc_receive_data(client, NULL, &bytes);\n\n\tafc_unlock(client);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_make_directory(afc_client_t client, const char *path)\n{\n\tuint32_t bytes = 0;\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tif (!client)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_lock(client);\n\n\t/* Send command */\n\tret = afc_dispatch_packet(client, AFC_OP_MAKE_DIR, path, strlen(path)+1, NULL, 0, &bytes);\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\t/* Receive response */\n\tret = afc_receive_data(client, NULL, &bytes);\n\n\tafc_unlock(client);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afc_get_file_info",
          "args": [
            "afc",
            "PKG_PATH",
            "&strs"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "afc_get_file_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "586-614",
          "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_get_file_info(afc_client_t client, const char *path, char ***file_information)\n{\n\tchar *received = NULL;\n\tuint32_t bytes = 0;\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tif (!client || !path || !file_information)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_lock(client);\n\n\t/* Send command */\n\tret = afc_dispatch_packet(client, AFC_OP_GET_FILE_INFO, path, strlen(path)+1, NULL, 0, &bytes);\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\n\t/* Receive data */\n\tret = afc_receive_data(client, &received, &bytes);\n\tif (received) {\n\t\t*file_information = make_strings_list(received, bytes);\n\t\tfree(received);\n\t}\n\n\tafc_unlock(client);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_get_file_info(afc_client_t client, const char *path, char ***file_information)\n{\n\tchar *received = NULL;\n\tuint32_t bytes = 0;\n\tafc_error_t ret = AFC_E_UNKNOWN_ERROR;\n\n\tif (!client || !path || !file_information)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tafc_lock(client);\n\n\t/* Send command */\n\tret = afc_dispatch_packet(client, AFC_OP_GET_FILE_INFO, path, strlen(path)+1, NULL, 0, &bytes);\n\tif (ret != AFC_E_SUCCESS) {\n\t\tafc_unlock(client);\n\t\treturn AFC_E_NOT_ENOUGH_DATA;\n\t}\n\n\t/* Receive data */\n\tret = afc_receive_data(client, &received, &bytes);\n\tif (received) {\n\t\t*file_information = make_strings_list(received, bytes);\n\t\tfree(received);\n\t}\n\n\tafc_unlock(client);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mobile_image_mounter_upload_image",
          "args": [
            "mim",
            "imagetype",
            "image_size",
            "sig",
            "sig_length",
            "mim_upload_cb",
            "f"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "mobile_image_mounter_upload_image",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/mobile_image_mounter.c",
          "lines": "144-253",
          "snippet": "LIBIMOBILEDEVICE_API mobile_image_mounter_error_t mobile_image_mounter_upload_image(mobile_image_mounter_client_t client, const char *image_type, size_t image_size, const char *signature, uint16_t signature_size, mobile_image_mounter_upload_cb_t upload_cb, void* userdata)\n{\n\tif (!client || !image_type || (image_size == 0) || !upload_cb) {\n\t\treturn MOBILE_IMAGE_MOUNTER_E_INVALID_ARG;\n\t}\n\tmobile_image_mounter_lock(client);\n\tplist_t result = NULL;\n\n\tplist_t dict = plist_new_dict();\n\tplist_dict_set_item(dict, \"Command\", plist_new_string(\"ReceiveBytes\"));\n\tif (signature && signature_size != 0)\n\t\tplist_dict_set_item(dict, \"ImageSignature\", plist_new_data(signature, signature_size));\n\tplist_dict_set_item(dict, \"ImageSize\", plist_new_uint(image_size));\n\tplist_dict_set_item(dict, \"ImageType\", plist_new_string(image_type));\n\n\tmobile_image_mounter_error_t res = mobile_image_mounter_error(property_list_service_send_xml_plist(client->parent, dict));\n\tplist_free(dict);\n\n\tif (res != MOBILE_IMAGE_MOUNTER_E_SUCCESS) {\n\t\tdebug_info(\"Error sending XML plist to device!\");\n\t\tgoto leave_unlock;\n\t}\n\n\tres = mobile_image_mounter_error(property_list_service_receive_plist(client->parent, &result));\n\tif (res != MOBILE_IMAGE_MOUNTER_E_SUCCESS) {\n\t\tdebug_info(\"Error receiving response from device!\");\n\t\tgoto leave_unlock;\n\t}\n\tres = MOBILE_IMAGE_MOUNTER_E_COMMAND_FAILED;\n\n\tchar* strval = NULL;\n\tplist_t node = plist_dict_get_item(result, \"Status\");\n\tif (node && plist_get_node_type(node) == PLIST_STRING) {\n\t\tplist_get_string_val(node, &strval);\n\t}\n\tif (!strval) {\n\t\tdebug_info(\"Error: Unexpected response received!\");\n\t\tgoto leave_unlock;\n\t}\n\tif (strcmp(strval, \"ReceiveBytesAck\") != 0) {\n\t\tdebug_info(\"Error: didn't get ReceiveBytesAck but %s\", strval);\n\t\tfree(strval);\n\t\tgoto leave_unlock;\n\t}\n\tfree(strval);\n\n\tsize_t tx = 0;\n\tsize_t bufsize = 65536;\n\tunsigned char *buf = (unsigned char*)malloc(bufsize);\n\tif (!buf) {\n\t\tdebug_info(\"Out of memory\");\n\t\tres = MOBILE_IMAGE_MOUNTER_E_UNKNOWN_ERROR;\n\t\tgoto leave_unlock;\n\t}\n\tdebug_info(\"uploading image (%d bytes)\", (int)image_size);\n\twhile (tx < image_size) {\n\t\tsize_t remaining = image_size - tx;\n\t\tsize_t amount = (remaining < bufsize) ? remaining : bufsize;\n\t\tssize_t r = upload_cb(buf, amount, userdata);\n\t\tif (r < 0) {\n\t\t\tdebug_info(\"upload_cb returned %d\", (int)r);\n\t\t\tbreak;\n\t\t}\n\t\tuint32_t sent = 0;\n\t\tif (service_send(client->parent->parent, (const char*)buf, (uint32_t)r, &sent) != SERVICE_E_SUCCESS) {\n\t\t\tdebug_info(\"service_send failed\");\n\t\t\tbreak;\n\t\t}\n\t\ttx += r;\n\t}\n\tfree(buf);\n\tif (tx < image_size) {\n\t\tdebug_info(\"Error: failed to upload image\");\n\t\tgoto leave_unlock;\n\t}\n\tdebug_info(\"image uploaded\");\n\n\tres = mobile_image_mounter_error(property_list_service_receive_plist(client->parent, &result));\n\tif (res != MOBILE_IMAGE_MOUNTER_E_SUCCESS) {\n\t\tdebug_info(\"Error receiving response from device!\");\n\t\tgoto leave_unlock;\n\t}\n\tres = MOBILE_IMAGE_MOUNTER_E_COMMAND_FAILED;\n\n\tstrval = NULL;\n\tnode = plist_dict_get_item(result, \"Status\");\n\tif (node && plist_get_node_type(node) == PLIST_STRING) {\n\t\tplist_get_string_val(node, &strval);\n\t}\n\tif (!strval) {\n\t\tdebug_info(\"Error: Unexpected response received!\");\n\t\tgoto leave_unlock;\n\t}\n\tif (strcmp(strval, \"Complete\") != 0) {\n\t\tdebug_info(\"Error: didn't get Complete but %s\", strval);\n\t\tfree(strval);\n\t\tgoto leave_unlock;\n\t} else {\n\t\tres = MOBILE_IMAGE_MOUNTER_E_SUCCESS;\n\t}\n\tfree(strval);\n\n\nleave_unlock:\n\tmobile_image_mounter_unlock(client);\n\tif (result)\n\t\tplist_free(result);\n\treturn res;\n\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"property_list_service.h\"",
            "#include \"mobile_image_mounter.h\"",
            "#include <plist/plist.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"property_list_service.h\"\n#include \"mobile_image_mounter.h\"\n#include <plist/plist.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n\nLIBIMOBILEDEVICE_API mobile_image_mounter_error_t mobile_image_mounter_upload_image(mobile_image_mounter_client_t client, const char *image_type, size_t image_size, const char *signature, uint16_t signature_size, mobile_image_mounter_upload_cb_t upload_cb, void* userdata)\n{\n\tif (!client || !image_type || (image_size == 0) || !upload_cb) {\n\t\treturn MOBILE_IMAGE_MOUNTER_E_INVALID_ARG;\n\t}\n\tmobile_image_mounter_lock(client);\n\tplist_t result = NULL;\n\n\tplist_t dict = plist_new_dict();\n\tplist_dict_set_item(dict, \"Command\", plist_new_string(\"ReceiveBytes\"));\n\tif (signature && signature_size != 0)\n\t\tplist_dict_set_item(dict, \"ImageSignature\", plist_new_data(signature, signature_size));\n\tplist_dict_set_item(dict, \"ImageSize\", plist_new_uint(image_size));\n\tplist_dict_set_item(dict, \"ImageType\", plist_new_string(image_type));\n\n\tmobile_image_mounter_error_t res = mobile_image_mounter_error(property_list_service_send_xml_plist(client->parent, dict));\n\tplist_free(dict);\n\n\tif (res != MOBILE_IMAGE_MOUNTER_E_SUCCESS) {\n\t\tdebug_info(\"Error sending XML plist to device!\");\n\t\tgoto leave_unlock;\n\t}\n\n\tres = mobile_image_mounter_error(property_list_service_receive_plist(client->parent, &result));\n\tif (res != MOBILE_IMAGE_MOUNTER_E_SUCCESS) {\n\t\tdebug_info(\"Error receiving response from device!\");\n\t\tgoto leave_unlock;\n\t}\n\tres = MOBILE_IMAGE_MOUNTER_E_COMMAND_FAILED;\n\n\tchar* strval = NULL;\n\tplist_t node = plist_dict_get_item(result, \"Status\");\n\tif (node && plist_get_node_type(node) == PLIST_STRING) {\n\t\tplist_get_string_val(node, &strval);\n\t}\n\tif (!strval) {\n\t\tdebug_info(\"Error: Unexpected response received!\");\n\t\tgoto leave_unlock;\n\t}\n\tif (strcmp(strval, \"ReceiveBytesAck\") != 0) {\n\t\tdebug_info(\"Error: didn't get ReceiveBytesAck but %s\", strval);\n\t\tfree(strval);\n\t\tgoto leave_unlock;\n\t}\n\tfree(strval);\n\n\tsize_t tx = 0;\n\tsize_t bufsize = 65536;\n\tunsigned char *buf = (unsigned char*)malloc(bufsize);\n\tif (!buf) {\n\t\tdebug_info(\"Out of memory\");\n\t\tres = MOBILE_IMAGE_MOUNTER_E_UNKNOWN_ERROR;\n\t\tgoto leave_unlock;\n\t}\n\tdebug_info(\"uploading image (%d bytes)\", (int)image_size);\n\twhile (tx < image_size) {\n\t\tsize_t remaining = image_size - tx;\n\t\tsize_t amount = (remaining < bufsize) ? remaining : bufsize;\n\t\tssize_t r = upload_cb(buf, amount, userdata);\n\t\tif (r < 0) {\n\t\t\tdebug_info(\"upload_cb returned %d\", (int)r);\n\t\t\tbreak;\n\t\t}\n\t\tuint32_t sent = 0;\n\t\tif (service_send(client->parent->parent, (const char*)buf, (uint32_t)r, &sent) != SERVICE_E_SUCCESS) {\n\t\t\tdebug_info(\"service_send failed\");\n\t\t\tbreak;\n\t\t}\n\t\ttx += r;\n\t}\n\tfree(buf);\n\tif (tx < image_size) {\n\t\tdebug_info(\"Error: failed to upload image\");\n\t\tgoto leave_unlock;\n\t}\n\tdebug_info(\"image uploaded\");\n\n\tres = mobile_image_mounter_error(property_list_service_receive_plist(client->parent, &result));\n\tif (res != MOBILE_IMAGE_MOUNTER_E_SUCCESS) {\n\t\tdebug_info(\"Error receiving response from device!\");\n\t\tgoto leave_unlock;\n\t}\n\tres = MOBILE_IMAGE_MOUNTER_E_COMMAND_FAILED;\n\n\tstrval = NULL;\n\tnode = plist_dict_get_item(result, \"Status\");\n\tif (node && plist_get_node_type(node) == PLIST_STRING) {\n\t\tplist_get_string_val(node, &strval);\n\t}\n\tif (!strval) {\n\t\tdebug_info(\"Error: Unexpected response received!\");\n\t\tgoto leave_unlock;\n\t}\n\tif (strcmp(strval, \"Complete\") != 0) {\n\t\tdebug_info(\"Error: didn't get Complete but %s\", strval);\n\t\tfree(strval);\n\t\tgoto leave_unlock;\n\t} else {\n\t\tres = MOBILE_IMAGE_MOUNTER_E_SUCCESS;\n\t}\n\tfree(strval);\n\n\nleave_unlock:\n\tmobile_image_mounter_unlock(client);\n\tif (result)\n\t\tplist_free(result);\n\treturn res;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"Developer\""
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Out of memory!?\\n\""
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Out of memory!?\\n\""
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error opening image file '%s': %s\\n\"",
            "image_path",
            "strerror(errno)"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "image_path",
            "\"rb\""
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Could not read signature from file '%s'\\n\"",
            "image_sig_path"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fread",
          "args": [
            "sig",
            "1",
            "sizeof(sig)",
            "f"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error opening signature file '%s': %s\\n\"",
            "image_sig_path",
            "strerror(errno)"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "image_sig_path",
            "\"rb\""
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mobile_image_mounter_lookup_image",
          "args": [
            "mim",
            "imagetype",
            "&result"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "mobile_image_mounter_lookup_image",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/mobile_image_mounter.c",
          "lines": "115-142",
          "snippet": "LIBIMOBILEDEVICE_API mobile_image_mounter_error_t mobile_image_mounter_lookup_image(mobile_image_mounter_client_t client, const char *image_type, plist_t *result)\n{\n\tif (!client || !image_type || !result) {\n\t\treturn MOBILE_IMAGE_MOUNTER_E_INVALID_ARG;\n\t}\n\tmobile_image_mounter_lock(client);\n\n\tplist_t dict = plist_new_dict();\n\tplist_dict_set_item(dict,\"Command\", plist_new_string(\"LookupImage\"));\n\tplist_dict_set_item(dict,\"ImageType\", plist_new_string(image_type));\n\n\tmobile_image_mounter_error_t res = mobile_image_mounter_error(property_list_service_send_xml_plist(client->parent, dict));\n\tplist_free(dict);\n\n\tif (res != MOBILE_IMAGE_MOUNTER_E_SUCCESS) {\n\t\tdebug_info(\"%s: Error sending XML plist to device!\", __func__);\n\t\tgoto leave_unlock;\n\t}\n\n\tres = mobile_image_mounter_error(property_list_service_receive_plist(client->parent, result));\n\tif (res != MOBILE_IMAGE_MOUNTER_E_SUCCESS) {\n\t\tdebug_info(\"%s: Error receiving response from device!\", __func__);\n\t}\n\nleave_unlock:\n\tmobile_image_mounter_unlock(client);\n\treturn res;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"property_list_service.h\"",
            "#include \"mobile_image_mounter.h\"",
            "#include <plist/plist.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"property_list_service.h\"\n#include \"mobile_image_mounter.h\"\n#include <plist/plist.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n\nLIBIMOBILEDEVICE_API mobile_image_mounter_error_t mobile_image_mounter_lookup_image(mobile_image_mounter_client_t client, const char *image_type, plist_t *result)\n{\n\tif (!client || !image_type || !result) {\n\t\treturn MOBILE_IMAGE_MOUNTER_E_INVALID_ARG;\n\t}\n\tmobile_image_mounter_lock(client);\n\n\tplist_t dict = plist_new_dict();\n\tplist_dict_set_item(dict,\"Command\", plist_new_string(\"LookupImage\"));\n\tplist_dict_set_item(dict,\"ImageType\", plist_new_string(image_type));\n\n\tmobile_image_mounter_error_t res = mobile_image_mounter_error(property_list_service_send_xml_plist(client->parent, dict));\n\tplist_free(dict);\n\n\tif (res != MOBILE_IMAGE_MOUNTER_E_SUCCESS) {\n\t\tdebug_info(\"%s: Error sending XML plist to device!\", __func__);\n\t\tgoto leave_unlock;\n\t}\n\n\tres = mobile_image_mounter_error(property_list_service_receive_plist(client->parent, result));\n\tif (res != MOBILE_IMAGE_MOUNTER_E_SUCCESS) {\n\t\tdebug_info(\"%s: Error receiving response from device!\", __func__);\n\t}\n\nleave_unlock:\n\tmobile_image_mounter_unlock(client);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"Developer\""
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"ERROR: stat: %s: %s\\n\"",
            "image_sig_path",
            "strerror(errno)"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "image_sig_path",
            "&fst"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "mobilebackup_write_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup.c",
          "lines": "322-338",
          "snippet": "static void mobilebackup_write_status(const char *path, int status)\n{\n\tstruct stat st;\n\tplist_t status_plist = plist_new_dict();\n\tplist_dict_set_item(status_plist, \"Backup Success\", plist_new_bool(status));\n\tchar *file_path = mobilebackup_build_path(path, \"Status\", \".plist\");\n\n\tif (stat(file_path, &st) == 0)\n\t\tremove(file_path);\n\n\tplist_write_to_filename(status_plist, file_path, PLIST_FORMAT_XML);\n\n\tplist_free(status_plist);\n\tstatus_plist = NULL;\n\n\tfree(file_path);\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <unistd.h>",
            "#include <gcrypt.h>",
            "#include <openssl/sha.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <gcrypt.h>\n#include <openssl/sha.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void mobilebackup_write_status(const char *path, int status)\n{\n\tstruct stat st;\n\tplist_t status_plist = plist_new_dict();\n\tplist_dict_set_item(status_plist, \"Backup Success\", plist_new_bool(status));\n\tchar *file_path = mobilebackup_build_path(path, \"Status\", \".plist\");\n\n\tif (stat(file_path, &st) == 0)\n\t\tremove(file_path);\n\n\tplist_write_to_filename(status_plist, file_path, PLIST_FORMAT_XML);\n\n\tplist_free(status_plist);\n\tstatus_plist = NULL;\n\n\tfree(file_path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"ERROR: stat: %s: %s\\n\"",
            "image_path",
            "strerror(errno)"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdownd_service_descriptor_free",
          "args": [
            "service"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "lockdownd_service_descriptor_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/lockdown.c",
          "lines": "1522-1528",
          "snippet": "LIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_service_descriptor_free(lockdownd_service_descriptor_t service)\n{\n\tif (service)\n\t\tfree(service);\n\n\treturn LOCKDOWN_E_SUCCESS;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/userpref.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"lockdown.h\"",
            "#include \"property_list_service.h\"",
            "#include <plist/plist.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/x509.h>",
            "#include <libtasn1.h>",
            "#include <openssl/x509v3.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/pem.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/userpref.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"lockdown.h\"\n#include \"property_list_service.h\"\n#include <plist/plist.h>\n#include <gnutls/crypto.h>\n#include <gnutls/x509.h>\n#include <libtasn1.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/pem.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_service_descriptor_free(lockdownd_service_descriptor_t service)\n{\n\tif (service)\n\t\tfree(service);\n\n\treturn LOCKDOWN_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Could not connect to AFC!\\n\""
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afc_client_new",
          "args": [
            "device",
            "service",
            "&afc"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "afc_client_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/afc.c",
          "lines": "99-116",
          "snippet": "LIBIMOBILEDEVICE_API afc_error_t afc_client_new(idevice_t device, lockdownd_service_descriptor_t service, afc_client_t * client)\n{\n\tif (!device || !service || service->port == 0)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tservice_client_t parent = NULL;\n\tif (service_client_new(device, service, &parent) != SERVICE_E_SUCCESS) {\n\t\treturn AFC_E_MUX_ERROR;\n\t}\n\n\tafc_error_t err = afc_client_new_with_service_client(parent, client);\n\tif (err != AFC_E_SUCCESS) {\n\t\tservice_client_free(parent);\n\t} else {\n\t\t(*client)->free_parent = 1;\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"endianness.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"afc.h\"",
            "#include <string.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endianness.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"afc.h\"\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API afc_error_t afc_client_new(idevice_t device, lockdownd_service_descriptor_t service, afc_client_t * client)\n{\n\tif (!device || !service || service->port == 0)\n\t\treturn AFC_E_INVALID_ARG;\n\n\tservice_client_t parent = NULL;\n\tif (service_client_new(device, service, &parent) != SERVICE_E_SUCCESS) {\n\t\treturn AFC_E_MUX_ERROR;\n\t}\n\n\tafc_error_t err = afc_client_new_with_service_client(parent, client);\n\tif (err != AFC_E_SUCCESS) {\n\t\tservice_client_free(parent);\n\t} else {\n\t\t(*client)->free_parent = 1;\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Could not start com.apple.afc!\\n\""
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdownd_start_service",
          "args": [
            "lckd",
            "\"com.apple.afc\"",
            "&service"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "lockdownd_start_service_with_escrow_bag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/lockdown.c",
          "lines": "1364-1367",
          "snippet": "LIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_start_service_with_escrow_bag(lockdownd_client_t client, const char *identifier, lockdownd_service_descriptor_t *service)\n{\n\treturn lockdownd_do_start_service(client, identifier, 1, service);\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/userpref.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"lockdown.h\"",
            "#include \"property_list_service.h\"",
            "#include <plist/plist.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/x509.h>",
            "#include <libtasn1.h>",
            "#include <openssl/x509v3.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/pem.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/userpref.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"lockdown.h\"\n#include \"property_list_service.h\"\n#include <plist/plist.h>\n#include <gnutls/crypto.h>\n#include <gnutls/x509.h>\n#include <libtasn1.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/pem.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_start_service_with_escrow_bag(lockdownd_client_t client, const char *identifier, lockdownd_service_descriptor_t *service)\n{\n\treturn lockdownd_do_start_service(client, identifier, 1, service);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ERROR: Could not connect to mobile_image_mounter!\\n\""
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mobile_image_mounter_new",
          "args": [
            "device",
            "service",
            "&mim"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "mobile_image_mounter_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/mobile_image_mounter.c",
          "lines": "78-93",
          "snippet": "LIBIMOBILEDEVICE_API mobile_image_mounter_error_t mobile_image_mounter_new(idevice_t device, lockdownd_service_descriptor_t service, mobile_image_mounter_client_t *client)\n{\n\tproperty_list_service_client_t plistclient = NULL;\n\tmobile_image_mounter_error_t err = mobile_image_mounter_error(property_list_service_client_new(device, service, &plistclient));\n\tif (err != MOBILE_IMAGE_MOUNTER_E_SUCCESS) {\n\t\treturn err;\n\t}\n\n\tmobile_image_mounter_client_t client_loc = (mobile_image_mounter_client_t) malloc(sizeof(struct mobile_image_mounter_client_private));\n\tclient_loc->parent = plistclient;\n\n\tmutex_init(&client_loc->mutex);\n\n\t*client = client_loc;\n\treturn MOBILE_IMAGE_MOUNTER_E_SUCCESS;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"property_list_service.h\"",
            "#include \"mobile_image_mounter.h\"",
            "#include <plist/plist.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"property_list_service.h\"\n#include \"mobile_image_mounter.h\"\n#include <plist/plist.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n\nLIBIMOBILEDEVICE_API mobile_image_mounter_error_t mobile_image_mounter_new(idevice_t device, lockdownd_service_descriptor_t service, mobile_image_mounter_client_t *client)\n{\n\tproperty_list_service_client_t plistclient = NULL;\n\tmobile_image_mounter_error_t err = mobile_image_mounter_error(property_list_service_client_new(device, service, &plistclient));\n\tif (err != MOBILE_IMAGE_MOUNTER_E_SUCCESS) {\n\t\treturn err;\n\t}\n\n\tmobile_image_mounter_client_t client_loc = (mobile_image_mounter_client_t) malloc(sizeof(struct mobile_image_mounter_client_private));\n\tclient_loc->parent = plistclient;\n\n\tmutex_init(&client_loc->mutex);\n\n\t*client = client_loc;\n\treturn MOBILE_IMAGE_MOUNTER_E_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ERROR: Could not start mobile_image_mounter service!\\n\""
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "product_version",
            "\"%d.%d.%*d\"",
            "&product_version_major",
            "&product_version_minor"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_string_val",
          "args": [
            "pver",
            "&product_version"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_get_node_type",
          "args": [
            "pver"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdownd_get_value",
          "args": [
            "lckd",
            "NULL",
            "\"ProductVersion\"",
            "&pver"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "lockdownd_get_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/lockdown.c",
          "lines": "426-478",
          "snippet": "LIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_get_value(lockdownd_client_t client, const char *domain, const char *key, plist_t *value)\n{\n\tif (!client)\n\t\treturn LOCKDOWN_E_INVALID_ARG;\n\n\tplist_t dict = NULL;\n\tlockdownd_error_t ret = LOCKDOWN_E_UNKNOWN_ERROR;\n\n\t/* setup request plist */\n\tdict = plist_new_dict();\n\tplist_dict_add_label(dict, client->label);\n\tif (domain) {\n\t\tplist_dict_set_item(dict,\"Domain\", plist_new_string(domain));\n\t}\n\tif (key) {\n\t\tplist_dict_set_item(dict,\"Key\", plist_new_string(key));\n\t}\n\tplist_dict_set_item(dict,\"Request\", plist_new_string(\"GetValue\"));\n\n\t/* send to device */\n\tret = lockdownd_send(client, dict);\n\n\tplist_free(dict);\n\tdict = NULL;\n\n\tif (ret != LOCKDOWN_E_SUCCESS)\n\t\treturn ret;\n\n\t/* Now get device's answer */\n\tret = lockdownd_receive(client, &dict);\n\tif (ret != LOCKDOWN_E_SUCCESS)\n\t\treturn ret;\n\n\tret = lockdown_check_result(dict, \"GetValue\");\n\tif (ret == LOCKDOWN_E_SUCCESS) {\n\t\tdebug_info(\"success\");\n\t}\n\n\tif (ret != LOCKDOWN_E_SUCCESS) {\n\t\tplist_free(dict);\n\t\treturn ret;\n\t}\n\n\tplist_t value_node = plist_dict_get_item(dict, \"Value\");\n\n\tif (value_node) {\n\t\tdebug_info(\"has a value\");\n\t\t*value = plist_copy(value_node);\n\t}\n\n\tplist_free(dict);\n\treturn ret;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/userpref.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"lockdown.h\"",
            "#include \"property_list_service.h\"",
            "#include <plist/plist.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/x509.h>",
            "#include <libtasn1.h>",
            "#include <openssl/x509v3.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/pem.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/userpref.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"lockdown.h\"\n#include \"property_list_service.h\"\n#include <plist/plist.h>\n#include <gnutls/crypto.h>\n#include <gnutls/x509.h>\n#include <libtasn1.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/pem.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_get_value(lockdownd_client_t client, const char *domain, const char *key, plist_t *value)\n{\n\tif (!client)\n\t\treturn LOCKDOWN_E_INVALID_ARG;\n\n\tplist_t dict = NULL;\n\tlockdownd_error_t ret = LOCKDOWN_E_UNKNOWN_ERROR;\n\n\t/* setup request plist */\n\tdict = plist_new_dict();\n\tplist_dict_add_label(dict, client->label);\n\tif (domain) {\n\t\tplist_dict_set_item(dict,\"Domain\", plist_new_string(domain));\n\t}\n\tif (key) {\n\t\tplist_dict_set_item(dict,\"Key\", plist_new_string(key));\n\t}\n\tplist_dict_set_item(dict,\"Request\", plist_new_string(\"GetValue\"));\n\n\t/* send to device */\n\tret = lockdownd_send(client, dict);\n\n\tplist_free(dict);\n\tdict = NULL;\n\n\tif (ret != LOCKDOWN_E_SUCCESS)\n\t\treturn ret;\n\n\t/* Now get device's answer */\n\tret = lockdownd_receive(client, &dict);\n\tif (ret != LOCKDOWN_E_SUCCESS)\n\t\treturn ret;\n\n\tret = lockdown_check_result(dict, \"GetValue\");\n\tif (ret == LOCKDOWN_E_SUCCESS) {\n\t\tdebug_info(\"success\");\n\t}\n\n\tif (ret != LOCKDOWN_E_SUCCESS) {\n\t\tplist_free(dict);\n\t\treturn ret;\n\t}\n\n\tplist_t value_node = plist_dict_get_item(dict, \"Value\");\n\n\tif (value_node) {\n\t\tdebug_info(\"has a value\");\n\t\t*value = plist_copy(value_node);\n\t}\n\n\tplist_free(dict);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdownd_client_new_with_handshake",
          "args": [
            "device",
            "&lckd",
            "\"ideviceimagemounter\""
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "lockdownd_client_new_with_handshake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/lockdown.c",
          "lines": "671-753",
          "snippet": "LIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_client_new_with_handshake(idevice_t device, lockdownd_client_t *client, const char *label)\n{\n\tif (!client)\n\t\treturn LOCKDOWN_E_INVALID_ARG;\n\n\tlockdownd_error_t ret = LOCKDOWN_E_SUCCESS;\n\tlockdownd_client_t client_loc = NULL;\n\tplist_t pair_record = NULL;\n\tchar *host_id = NULL;\n\tchar *type = NULL;\n\n\tret = lockdownd_client_new(device, &client_loc, label);\n\tif (LOCKDOWN_E_SUCCESS != ret) {\n\t\tdebug_info(\"failed to create lockdownd client.\");\n\t\treturn ret;\n\t}\n\n\t/* perform handshake */\n\tif (LOCKDOWN_E_SUCCESS != lockdownd_query_type(client_loc, &type)) {\n\t\tdebug_info(\"QueryType failed in the lockdownd client.\");\n\t\tret = LOCKDOWN_E_NOT_ENOUGH_DATA;\n\t} else {\n\t\tif (strcmp(\"com.apple.mobile.lockdown\", type)) {\n\t\t\tdebug_info(\"Warning QueryType request returned \\\"%s\\\".\", type);\n\t\t}\n\t}\n\tfree(type);\n\n\tuserpref_read_pair_record(client_loc->udid, &pair_record);\n\tif (pair_record) {\n\t\tpair_record_get_host_id(pair_record, &host_id);\n\t}\n\tif (LOCKDOWN_E_SUCCESS == ret && !host_id) {\n\t\tret = LOCKDOWN_E_INVALID_CONF;\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS == ret && !pair_record) {\n\t\t/* attempt pairing */\n\t\tret = lockdownd_pair(client_loc, NULL);\n\t}\n\n\tplist_free(pair_record);\n\tpair_record = NULL;\n\n\t/* in any case, we need to validate pairing to receive trusted host status */\n\tret = lockdownd_validate_pair(client_loc, NULL);\n\n\t/* if not paired yet, let's do it now */\n\tif (LOCKDOWN_E_INVALID_HOST_ID == ret) {\n\t\tfree(host_id);\n\t\thost_id = NULL;\n\t\tret = lockdownd_pair(client_loc, NULL);\n\t\tif (LOCKDOWN_E_SUCCESS == ret) {\n\t\t\tret = lockdownd_validate_pair(client_loc, NULL);\n\t\t} else if (LOCKDOWN_E_PAIRING_DIALOG_RESPONSE_PENDING == ret) {\n\t\t\tdebug_info(\"Device shows the pairing dialog.\");\n\t\t}\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS == ret) {\n\t\tif (!host_id) {\n\t\t\tuserpref_read_pair_record(client_loc->udid, &pair_record);\n\t\t\tif (pair_record) {\n\t\t\t\tpair_record_get_host_id(pair_record, &host_id);\n\t\t\t\tplist_free(pair_record);\n\t\t\t}\n\t\t}\n\n\t\tret = lockdownd_start_session(client_loc, host_id, NULL, NULL);\n\t\tif (LOCKDOWN_E_SUCCESS != ret) {\n\t\t\tdebug_info(\"Session opening failed.\");\n\t\t}\n\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS == ret) {\n\t\t*client = client_loc;\n\t} else {\n\t\tlockdownd_client_free(client_loc);\n\t}\n\tfree(host_id);\n\treturn ret;\n}",
          "includes": [
            "#include <windows.h>",
            "#include \"asprintf.h\"",
            "#include \"common/utils.h\"",
            "#include \"common/userpref.h\"",
            "#include \"common/debug.h\"",
            "#include \"idevice.h\"",
            "#include \"lockdown.h\"",
            "#include \"property_list_service.h\"",
            "#include <plist/plist.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/x509.h>",
            "#include <libtasn1.h>",
            "#include <openssl/x509v3.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/pem.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include \"asprintf.h\"\n#include \"common/utils.h\"\n#include \"common/userpref.h\"\n#include \"common/debug.h\"\n#include \"idevice.h\"\n#include \"lockdown.h\"\n#include \"property_list_service.h\"\n#include <plist/plist.h>\n#include <gnutls/crypto.h>\n#include <gnutls/x509.h>\n#include <libtasn1.h>\n#include <openssl/x509v3.h>\n#include <openssl/x509.h>\n#include <openssl/pem.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API lockdownd_error_t lockdownd_client_new_with_handshake(idevice_t device, lockdownd_client_t *client, const char *label)\n{\n\tif (!client)\n\t\treturn LOCKDOWN_E_INVALID_ARG;\n\n\tlockdownd_error_t ret = LOCKDOWN_E_SUCCESS;\n\tlockdownd_client_t client_loc = NULL;\n\tplist_t pair_record = NULL;\n\tchar *host_id = NULL;\n\tchar *type = NULL;\n\n\tret = lockdownd_client_new(device, &client_loc, label);\n\tif (LOCKDOWN_E_SUCCESS != ret) {\n\t\tdebug_info(\"failed to create lockdownd client.\");\n\t\treturn ret;\n\t}\n\n\t/* perform handshake */\n\tif (LOCKDOWN_E_SUCCESS != lockdownd_query_type(client_loc, &type)) {\n\t\tdebug_info(\"QueryType failed in the lockdownd client.\");\n\t\tret = LOCKDOWN_E_NOT_ENOUGH_DATA;\n\t} else {\n\t\tif (strcmp(\"com.apple.mobile.lockdown\", type)) {\n\t\t\tdebug_info(\"Warning QueryType request returned \\\"%s\\\".\", type);\n\t\t}\n\t}\n\tfree(type);\n\n\tuserpref_read_pair_record(client_loc->udid, &pair_record);\n\tif (pair_record) {\n\t\tpair_record_get_host_id(pair_record, &host_id);\n\t}\n\tif (LOCKDOWN_E_SUCCESS == ret && !host_id) {\n\t\tret = LOCKDOWN_E_INVALID_CONF;\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS == ret && !pair_record) {\n\t\t/* attempt pairing */\n\t\tret = lockdownd_pair(client_loc, NULL);\n\t}\n\n\tplist_free(pair_record);\n\tpair_record = NULL;\n\n\t/* in any case, we need to validate pairing to receive trusted host status */\n\tret = lockdownd_validate_pair(client_loc, NULL);\n\n\t/* if not paired yet, let's do it now */\n\tif (LOCKDOWN_E_INVALID_HOST_ID == ret) {\n\t\tfree(host_id);\n\t\thost_id = NULL;\n\t\tret = lockdownd_pair(client_loc, NULL);\n\t\tif (LOCKDOWN_E_SUCCESS == ret) {\n\t\t\tret = lockdownd_validate_pair(client_loc, NULL);\n\t\t} else if (LOCKDOWN_E_PAIRING_DIALOG_RESPONSE_PENDING == ret) {\n\t\t\tdebug_info(\"Device shows the pairing dialog.\");\n\t\t}\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS == ret) {\n\t\tif (!host_id) {\n\t\t\tuserpref_read_pair_record(client_loc->udid, &pair_record);\n\t\t\tif (pair_record) {\n\t\t\t\tpair_record_get_host_id(pair_record, &host_id);\n\t\t\t\tplist_free(pair_record);\n\t\t\t}\n\t\t}\n\n\t\tret = lockdownd_start_session(client_loc, host_id, NULL, NULL);\n\t\tif (LOCKDOWN_E_SUCCESS != ret) {\n\t\t\tdebug_info(\"Session opening failed.\");\n\t\t}\n\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS == ret) {\n\t\t*client = client_loc;\n\t} else {\n\t\tlockdownd_client_free(client_loc);\n\t}\n\tfree(host_id);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"No device found, is it plugged in?\\n\""
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idevice_new",
          "args": [
            "&device",
            "udid"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "idevice_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
          "lines": "230-245",
          "snippet": "LIBIMOBILEDEVICE_API idevice_error_t idevice_new(idevice_t * device, const char *udid)\n{\n\tusbmuxd_device_info_t muxdev;\n\tint res = usbmuxd_get_device_by_udid(udid, &muxdev);\n\tif (res > 0) {\n\t\tidevice_t dev = (idevice_t) malloc(sizeof(struct idevice_private));\n\t\tdev->udid = strdup(muxdev.udid);\n\t\tdev->conn_type = CONNECTION_USBMUXD;\n\t\tdev->conn_data = (void*)(long)muxdev.handle;\n\t\t*device = dev;\n\t\treturn IDEVICE_E_SUCCESS;\n\t}\n\t/* other connection types could follow here */\n\n\treturn IDEVICE_E_NO_DEVICE;\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"common/thread.h\"",
            "#include \"common/userpref.h\"",
            "#include \"idevice.h\"",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <usbmuxd.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "LIBIMOBILEDEVICE_API idevice_error_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API idevice_error_t;\n\nLIBIMOBILEDEVICE_API idevice_error_t idevice_new(idevice_t * device, const char *udid)\n{\n\tusbmuxd_device_info_t muxdev;\n\tint res = usbmuxd_get_device_by_udid(udid, &muxdev);\n\tif (res > 0) {\n\t\tidevice_t dev = (idevice_t) malloc(sizeof(struct idevice_private));\n\t\tdev->udid = strdup(muxdev.udid);\n\t\tdev->conn_type = CONNECTION_USBMUXD;\n\t\tdev->conn_data = (void*)(long)muxdev.handle;\n\t\t*device = dev;\n\t\treturn IDEVICE_E_SUCCESS;\n\t}\n\t/* other connection types could follow here */\n\n\treturn IDEVICE_E_NO_DEVICE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Out of memory?!\\n\""
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[1]"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "argv[0]"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ERROR: No IMAGE_FILE has been given!\\n\""
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_opts",
          "args": [
            "argc",
            "argv"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "parse_opts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/ideviceimagemounter.c",
          "lines": "76-126",
          "snippet": "static void parse_opts(int argc, char **argv)\n{\n\tstatic struct option longopts[] = {\n\t\t{\"help\", 0, NULL, 'h'},\n\t\t{\"udid\", 0, NULL, 'u'},\n\t\t{\"list\", 0, NULL, 'l'},\n\t\t{\"imagetype\", 0, NULL, 't'},\n\t\t{\"xml\", 0, NULL, 'x'},\n\t\t{\"debug\", 0, NULL, 'd'},\n\t\t{NULL, 0, NULL, 0}\n\t};\n\tint c;\n\n\twhile (1) {\n\t\tc = getopt_long(argc, argv, \"hu:lt:xd\", longopts,\n\t\t\t\t\t\t(int *) 0);\n\t\tif (c == -1) {\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (c) {\n\t\tcase 'h':\n\t\t\tprint_usage(argc, argv);\n\t\t\texit(0);\n\t\tcase 'u':\n\t\t\tif (strlen(optarg) != 40) {\n\t\t\t\tprintf(\"%s: invalid UDID specified (length != 40)\\n\",\n\t\t\t\t\t   argv[0]);\n\t\t\t\tprint_usage(argc, argv);\n\t\t\t\texit(2);\n\t\t\t}\n\t\t\tudid = strdup(optarg);\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tlist_mode = 1;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\timagetype = strdup(optarg);\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\txml_mode = 1;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tidevice_set_debug_level(1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprint_usage(argc, argv);\n\t\t\texit(2);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"common/utils.h\"",
            "#include <asprintf.h>",
            "#include <libimobiledevice/mobile_image_mounter.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <inttypes.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <libgen.h>",
            "#include <errno.h>",
            "#include <getopt.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int list_mode = 0;",
            "static int xml_mode = 0;",
            "static char *udid = NULL;",
            "static char *imagetype = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common/utils.h\"\n#include <asprintf.h>\n#include <libimobiledevice/mobile_image_mounter.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <inttypes.h>\n#include <sys/time.h>\n#include <time.h>\n#include <libgen.h>\n#include <errno.h>\n#include <getopt.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <config.h>\n\nstatic int list_mode = 0;\nstatic int xml_mode = 0;\nstatic char *udid = NULL;\nstatic char *imagetype = NULL;\n\nstatic void parse_opts(int argc, char **argv)\n{\n\tstatic struct option longopts[] = {\n\t\t{\"help\", 0, NULL, 'h'},\n\t\t{\"udid\", 0, NULL, 'u'},\n\t\t{\"list\", 0, NULL, 'l'},\n\t\t{\"imagetype\", 0, NULL, 't'},\n\t\t{\"xml\", 0, NULL, 'x'},\n\t\t{\"debug\", 0, NULL, 'd'},\n\t\t{NULL, 0, NULL, 0}\n\t};\n\tint c;\n\n\twhile (1) {\n\t\tc = getopt_long(argc, argv, \"hu:lt:xd\", longopts,\n\t\t\t\t\t\t(int *) 0);\n\t\tif (c == -1) {\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (c) {\n\t\tcase 'h':\n\t\t\tprint_usage(argc, argv);\n\t\t\texit(0);\n\t\tcase 'u':\n\t\t\tif (strlen(optarg) != 40) {\n\t\t\t\tprintf(\"%s: invalid UDID specified (length != 40)\\n\",\n\t\t\t\t\t   argv[0]);\n\t\t\t\tprint_usage(argc, argv);\n\t\t\t\texit(2);\n\t\t\t}\n\t\t\tudid = strdup(optarg);\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tlist_mode = 1;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\timagetype = strdup(optarg);\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\txml_mode = 1;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tidevice_set_debug_level(1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprint_usage(argc, argv);\n\t\t\texit(2);\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common/utils.h\"\n#include <asprintf.h>\n#include <libimobiledevice/mobile_image_mounter.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <inttypes.h>\n#include <sys/time.h>\n#include <time.h>\n#include <libgen.h>\n#include <errno.h>\n#include <getopt.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <config.h>\n\nstatic int list_mode = 0;\nstatic int xml_mode = 0;\nstatic char *udid = NULL;\nstatic char *imagetype = NULL;\nstatic const char PKG_PATH[] = \"PublicStaging\";\nstatic const char PATH_PREFIX[] = \"/private/var/mobile/Media\";\n\nint main(int argc, char **argv)\n{\n\tidevice_t device = NULL;\n\tlockdownd_client_t lckd = NULL;\n\tlockdownd_error_t ldret = LOCKDOWN_E_UNKNOWN_ERROR;\n\tmobile_image_mounter_client_t mim = NULL;\n\tafc_client_t afc = NULL;\n\tlockdownd_service_descriptor_t service = NULL;\n\tint res = -1;\n\tchar *image_path = NULL;\n\tsize_t image_size = 0;\n\tchar *image_sig_path = NULL;\n\n\tparse_opts(argc, argv);\n\n\targc -= optind;\n\targv += optind;\n\n\tif (!list_mode) {\n\t\tif (argc < 1) {\n\t\t\tprintf(\"ERROR: No IMAGE_FILE has been given!\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\timage_path = strdup(argv[0]);\n\t\tif (argc >= 2) {\n\t\t\timage_sig_path = strdup(argv[1]);\n\t\t} else {\n\t\t\tif (asprintf(&image_sig_path, \"%s.signature\", image_path) < 0) {\n\t\t\t\tprintf(\"Out of memory?!\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (IDEVICE_E_SUCCESS != idevice_new(&device, udid)) {\n\t\tprintf(\"No device found, is it plugged in?\\n\");\n\t\treturn -1;\n\t}\n\n\tif (LOCKDOWN_E_SUCCESS != (ldret = lockdownd_client_new_with_handshake(device, &lckd, \"ideviceimagemounter\"))) {\n\t\tprintf(\"ERROR: Could not connect to lockdown, error code %d.\\n\", ldret);\n\t\tgoto leave;\n\t}\n\n\tplist_t pver = NULL;\n\tchar *product_version = NULL;\n\tlockdownd_get_value(lckd, NULL, \"ProductVersion\", &pver);\n\tif (pver && plist_get_node_type(pver) == PLIST_STRING) {\n\t\tplist_get_string_val(pver, &product_version);\n\t}\n\tdisk_image_upload_type_t disk_image_upload_type = DISK_IMAGE_UPLOAD_TYPE_AFC;\n\tint product_version_major = 0;\n\tint product_version_minor = 0;\n\tif (product_version) {\n\t\tif (sscanf(product_version, \"%d.%d.%*d\", &product_version_major, &product_version_minor) == 2) {\n\t\t\tif (product_version_major >= 7)\n\t\t\t\tdisk_image_upload_type = DISK_IMAGE_UPLOAD_TYPE_UPLOAD_IMAGE;\n\t\t}\n\t}\n\n\tlockdownd_start_service(lckd, \"com.apple.mobile.mobile_image_mounter\", &service);\n\n\tif (!service || service->port == 0) {\n\t\tprintf(\"ERROR: Could not start mobile_image_mounter service!\\n\");\n\t\tgoto leave;\n\t}\n\n\tif (mobile_image_mounter_new(device, service, &mim) != MOBILE_IMAGE_MOUNTER_E_SUCCESS) {\n\t\tprintf(\"ERROR: Could not connect to mobile_image_mounter!\\n\");\n\t\tgoto leave;\n\t}\n\n\tif (service) {\n\t\tlockdownd_service_descriptor_free(service);\n\t\tservice = NULL;\n\t}\n\n\tif (!list_mode) {\n\t\tstruct stat fst;\n\t\tif (disk_image_upload_type == DISK_IMAGE_UPLOAD_TYPE_AFC) {\n\t\t\tif ((lockdownd_start_service(lckd, \"com.apple.afc\", &service) !=\n\t\t\t\t LOCKDOWN_E_SUCCESS) || !service || !service->port) {\n\t\t\t\tfprintf(stderr, \"Could not start com.apple.afc!\\n\");\n\t\t\t\tgoto leave;\n\t\t\t}\n\t\t\tif (afc_client_new(device, service, &afc) != AFC_E_SUCCESS) {\n\t\t\t\tfprintf(stderr, \"Could not connect to AFC!\\n\");\n\t\t\t\tgoto leave;\n\t\t\t}\n\t\t\tif (service) {\n\t\t\t\tlockdownd_service_descriptor_free(service);\n\t\t\t\tservice = NULL;\n\t\t\t}\n\t\t}\n\t\tif (stat(image_path, &fst) != 0) {\n\t\t\tfprintf(stderr, \"ERROR: stat: %s: %s\\n\", image_path, strerror(errno));\n\t\t\tgoto leave;\n\t\t}\n\t\timage_size = fst.st_size;\n\t\tif (stat(image_sig_path, &fst) != 0) {\n\t\t\tfprintf(stderr, \"ERROR: stat: %s: %s\\n\", image_sig_path, strerror(errno));\n\t\t\tgoto leave;\n\t\t}\n\t}\n\n\tlockdownd_client_free(lckd);\n\tlckd = NULL;\n\n\tmobile_image_mounter_error_t err;\n\tplist_t result = NULL;\n\n\tif (list_mode) {\n\t\t/* list mounts mode */\n\t\tif (!imagetype) {\n\t\t\timagetype = strdup(\"Developer\");\n\t\t}\n\t\terr = mobile_image_mounter_lookup_image(mim, imagetype, &result);\n\t\tfree(imagetype);\n\t\tif (err == MOBILE_IMAGE_MOUNTER_E_SUCCESS) {\n\t\t\tres = 0;\n\t\t\tif (xml_mode) {\n\t\t\t\tprint_xml(result);\n\t\t\t} else {\n\t\t\t\tplist_print_to_stream(result, stdout);\n\t\t\t}\n\t\t} else {\n\t\t\tprintf(\"Error: lookup_image returned %d\\n\", err);\n\t\t}\n\t} else {\n\t\tchar sig[8192];\n\t\tsize_t sig_length = 0;\n\t\tFILE *f = fopen(image_sig_path, \"rb\");\n\t\tif (!f) {\n\t\t\tfprintf(stderr, \"Error opening signature file '%s': %s\\n\", image_sig_path, strerror(errno));\n\t\t\tgoto leave;\n\t\t}\n\t\tsig_length = fread(sig, 1, sizeof(sig), f);\n\t\tfclose(f);\n\t\tif (sig_length == 0) {\n\t\t\tfprintf(stderr, \"Could not read signature from file '%s'\\n\", image_sig_path);\n\t\t\tgoto leave;\n\t\t}\n\n\t\tf = fopen(image_path, \"rb\");\n\t\tif (!f) {\n\t\t\tfprintf(stderr, \"Error opening image file '%s': %s\\n\", image_path, strerror(errno));\n\t\t\tgoto leave;\n\t\t}\n\n\t\tchar *targetname = NULL;\n\t\tif (asprintf(&targetname, \"%s/%s\", PKG_PATH, \"staging.dimage\") < 0) {\n\t\t\tfprintf(stderr, \"Out of memory!?\\n\");\n\t\t\tgoto leave;\n\t\t}\n\t\tchar *mountname = NULL;\n\t\tif (asprintf(&mountname, \"%s/%s\", PATH_PREFIX, targetname) < 0) {\n\t\t\tfprintf(stderr, \"Out of memory!?\\n\");\n\t\t\tgoto leave;\n\t\t}\n\n\n\t\tif (!imagetype) {\n\t\t\timagetype = strdup(\"Developer\");\n\t\t}\n\n\t\tswitch(disk_image_upload_type) {\n\t\t\tcase DISK_IMAGE_UPLOAD_TYPE_UPLOAD_IMAGE:\n\t\t\t\tprintf(\"Uploading %s\\n\", image_path);\n\t\t\t\terr = mobile_image_mounter_upload_image(mim, imagetype, image_size, sig, sig_length, mim_upload_cb, f);\n\t\t\t\tbreak;\n\t\t\tcase DISK_IMAGE_UPLOAD_TYPE_AFC:\n\t\t\tdefault:\n\t\t\t\tprintf(\"Uploading %s --> afc:///%s\\n\", image_path, targetname);\n\t\t\t\tchar **strs = NULL;\n\t\t\t\tif (afc_get_file_info(afc, PKG_PATH, &strs) != AFC_E_SUCCESS) {\n\t\t\t\t\tif (afc_make_directory(afc, PKG_PATH) != AFC_E_SUCCESS) {\n\t\t\t\t\t\tfprintf(stderr, \"WARNING: Could not create directory '%s' on device!\\n\", PKG_PATH);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (strs) {\n\t\t\t\t\tint i = 0;\n\t\t\t\t\twhile (strs[i]) {\n\t\t\t\t\t\tfree(strs[i]);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tfree(strs);\n\t\t\t\t}\n\n\t\t\t\tuint64_t af = 0;\n\t\t\t\tif ((afc_file_open(afc, targetname, AFC_FOPEN_WRONLY, &af) !=\n\t\t\t\t\t AFC_E_SUCCESS) || !af) {\n\t\t\t\t\tfclose(f);\n\t\t\t\t\tfprintf(stderr, \"afc_file_open on '%s' failed!\\n\", targetname);\n\t\t\t\t\tgoto leave;\n\t\t\t\t}\n\n\t\t\t\tchar buf[8192];\n\t\t\t\tsize_t amount = 0;\n\t\t\t\tdo {\n\t\t\t\t\tamount = fread(buf, 1, sizeof(buf), f);\n\t\t\t\t\tif (amount > 0) {\n\t\t\t\t\t\tuint32_t written, total = 0;\n\t\t\t\t\t\twhile (total < amount) {\n\t\t\t\t\t\t\twritten = 0;\n\t\t\t\t\t\t\tif (afc_file_write(afc, af, buf, amount, &written) !=\n\t\t\t\t\t\t\t\tAFC_E_SUCCESS) {\n\t\t\t\t\t\t\t\tfprintf(stderr, \"AFC Write error!\\n\");\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttotal += written;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (total != amount) {\n\t\t\t\t\t\t\tfprintf(stderr, \"Error: wrote only %d of %d\\n\", total,\n\t\t\t\t\t\t\t\t\t(unsigned int)amount);\n\t\t\t\t\t\t\tafc_file_close(afc, af);\n\t\t\t\t\t\t\tfclose(f);\n\t\t\t\t\t\t\tgoto leave;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile (amount > 0);\n\n\t\t\t\tafc_file_close(afc, af);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tfclose(f);\n\n\t\tprintf(\"done.\\n\");\n\n\t\tprintf(\"Mounting...\\n\");\n\t\terr = mobile_image_mounter_mount_image(mim, mountname, sig, sig_length, imagetype, &result);\n\t\tfree(imagetype);\n\t\tif (err == MOBILE_IMAGE_MOUNTER_E_SUCCESS) {\n\t\t\tif (result) {\n\t\t\t\tplist_t node = plist_dict_get_item(result, \"Status\");\n\t\t\t\tif (node) {\n\t\t\t\t\tchar *status = NULL;\n\t\t\t\t\tplist_get_string_val(node, &status);\n\t\t\t\t\tif (status) {\n\t\t\t\t\t\tif (!strcmp(status, \"Complete\")) {\n\t\t\t\t\t\t\tprintf(\"Done.\\n\");\n\t\t\t\t\t\t\tres = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tprintf(\"unexpected status value:\\n\");\n\t\t\t\t\t\t\tif (xml_mode) {\n\t\t\t\t\t\t\t\tprint_xml(result);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tplist_print_to_stream(result, stdout);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree(status);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprintf(\"unexpected result:\\n\");\n\t\t\t\t\t\tif (xml_mode) {\n\t\t\t\t\t\t\tprint_xml(result);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tplist_print_to_stream(result, stdout);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnode = plist_dict_get_item(result, \"Error\");\n\t\t\t\tif (node) {\n\t\t\t\t\tchar *error = NULL;\n\t\t\t\t\tplist_get_string_val(node, &error);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tprintf(\"Error: %s\\n\", error);\n\t\t\t\t\t\tfree(error);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprintf(\"unexpected result:\\n\");\n\t\t\t\t\t\tif (xml_mode) {\n\t\t\t\t\t\t\tprint_xml(result);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tplist_print_to_stream(result, stdout);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\tif (xml_mode) {\n\t\t\t\t\t\tprint_xml(result);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tplist_print_to_stream(result, stdout);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tprintf(\"Error: mount_image returned %d\\n\", err);\n\n\t\t}\n\t}\n\n\tif (result) {\n\t\tplist_free(result);\n\t}\n\n\t/* perform hangup command */\n\tmobile_image_mounter_hangup(mim);\n\t/* free client */\n\tmobile_image_mounter_free(mim);\n\nleave:\n\tif (afc) {\n\t\tafc_client_free(afc);\n\t}\n\tif (lckd) {\n\t\tlockdownd_client_free(lckd);\n\t}\n\tidevice_free(device);\n\n\tif (image_path)\n\t\t\tfree(image_path);\n\tif (image_sig_path)\n\t\tfree(image_sig_path);\n\n\treturn res;\n}"
  },
  {
    "function_name": "mim_upload_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/ideviceimagemounter.c",
    "lines": "137-140",
    "snippet": "static ssize_t mim_upload_cb(void* buf, size_t size, void* userdata)\n{\n\treturn fread(buf, 1, size, (FILE*)userdata);\n}",
    "includes": [
      "#include \"common/utils.h\"",
      "#include <asprintf.h>",
      "#include <libimobiledevice/mobile_image_mounter.h>",
      "#include <libimobiledevice/notification_proxy.h>",
      "#include <libimobiledevice/afc.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <inttypes.h>",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <libgen.h>",
      "#include <errno.h>",
      "#include <getopt.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fread",
          "args": [
            "buf",
            "1",
            "size",
            "(FILE*)userdata"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common/utils.h\"\n#include <asprintf.h>\n#include <libimobiledevice/mobile_image_mounter.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <inttypes.h>\n#include <sys/time.h>\n#include <time.h>\n#include <libgen.h>\n#include <errno.h>\n#include <getopt.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <config.h>\n\nstatic ssize_t mim_upload_cb(void* buf, size_t size, void* userdata)\n{\n\treturn fread(buf, 1, size, (FILE*)userdata);\n}"
  },
  {
    "function_name": "print_xml",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/ideviceimagemounter.c",
    "lines": "128-135",
    "snippet": "static void print_xml(plist_t node)\n{\n\tchar *xml = NULL;\n\tuint32_t len = 0;\n\tplist_to_xml(node, &xml, &len);\n\tif (xml)\n\t\tputs(xml);\n}",
    "includes": [
      "#include \"common/utils.h\"",
      "#include <asprintf.h>",
      "#include <libimobiledevice/mobile_image_mounter.h>",
      "#include <libimobiledevice/notification_proxy.h>",
      "#include <libimobiledevice/afc.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <inttypes.h>",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <libgen.h>",
      "#include <errno.h>",
      "#include <getopt.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "puts",
          "args": [
            "xml"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plist_to_xml",
          "args": [
            "node",
            "&xml",
            "&len"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common/utils.h\"\n#include <asprintf.h>\n#include <libimobiledevice/mobile_image_mounter.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <inttypes.h>\n#include <sys/time.h>\n#include <time.h>\n#include <libgen.h>\n#include <errno.h>\n#include <getopt.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <config.h>\n\nstatic void print_xml(plist_t node)\n{\n\tchar *xml = NULL;\n\tuint32_t len = 0;\n\tplist_to_xml(node, &xml, &len);\n\tif (xml)\n\t\tputs(xml);\n}"
  },
  {
    "function_name": "parse_opts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/ideviceimagemounter.c",
    "lines": "76-126",
    "snippet": "static void parse_opts(int argc, char **argv)\n{\n\tstatic struct option longopts[] = {\n\t\t{\"help\", 0, NULL, 'h'},\n\t\t{\"udid\", 0, NULL, 'u'},\n\t\t{\"list\", 0, NULL, 'l'},\n\t\t{\"imagetype\", 0, NULL, 't'},\n\t\t{\"xml\", 0, NULL, 'x'},\n\t\t{\"debug\", 0, NULL, 'd'},\n\t\t{NULL, 0, NULL, 0}\n\t};\n\tint c;\n\n\twhile (1) {\n\t\tc = getopt_long(argc, argv, \"hu:lt:xd\", longopts,\n\t\t\t\t\t\t(int *) 0);\n\t\tif (c == -1) {\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (c) {\n\t\tcase 'h':\n\t\t\tprint_usage(argc, argv);\n\t\t\texit(0);\n\t\tcase 'u':\n\t\t\tif (strlen(optarg) != 40) {\n\t\t\t\tprintf(\"%s: invalid UDID specified (length != 40)\\n\",\n\t\t\t\t\t   argv[0]);\n\t\t\t\tprint_usage(argc, argv);\n\t\t\t\texit(2);\n\t\t\t}\n\t\t\tudid = strdup(optarg);\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tlist_mode = 1;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\timagetype = strdup(optarg);\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\txml_mode = 1;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tidevice_set_debug_level(1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprint_usage(argc, argv);\n\t\t\texit(2);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"common/utils.h\"",
      "#include <asprintf.h>",
      "#include <libimobiledevice/mobile_image_mounter.h>",
      "#include <libimobiledevice/notification_proxy.h>",
      "#include <libimobiledevice/afc.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <inttypes.h>",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <libgen.h>",
      "#include <errno.h>",
      "#include <getopt.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int list_mode = 0;",
      "static int xml_mode = 0;",
      "static char *udid = NULL;",
      "static char *imagetype = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "2"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "clean_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/idevicebackup2.c",
          "lines": "1108-1112",
          "snippet": "static void clean_exit(int sig)\n{\n\tfprintf(stderr, \"Exiting...\\n\");\n\tquit_flag++;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <sys/statvfs.h>",
            "#include <termios.h>",
            "#include <conio.h>",
            "#include <windows.h>",
            "#include <endianness.h>",
            "#include \"common/utils.h\"",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/mobilebackup2.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <time.h>",
            "#include <ctype.h>",
            "#include <libgen.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int quit_flag = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <sys/statvfs.h>\n#include <termios.h>\n#include <conio.h>\n#include <windows.h>\n#include <endianness.h>\n#include \"common/utils.h\"\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/mobilebackup2.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <time.h>\n#include <ctype.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int quit_flag = 0;\n\nstatic void clean_exit(int sig)\n{\n\tfprintf(stderr, \"Exiting...\\n\");\n\tquit_flag++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_usage",
          "args": [
            "argc",
            "argv"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "print_usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/ideviceimagemounter.c",
          "lines": "59-74",
          "snippet": "static void print_usage(int argc, char **argv)\n{\n\tchar *name = NULL;\n\n\tname = strrchr(argv[0], '/');\n\tprintf(\"Usage: %s [OPTIONS] IMAGE_FILE IMAGE_SIGNATURE_FILE\\n\\n\", (name ? name + 1: argv[0]));\n\tprintf(\"Mounts the specified disk image on the device.\\n\\n\");\n\tprintf(\"  -u, --udid UDID\\ttarget specific device by its 40-digit device UDID\\n\");\n\tprintf(\"  -l, --list\\t\\tList mount information\\n\");\n\tprintf(\"  -t, --imagetype\\tImage type to use, default is 'Developer'\\n\");\n\tprintf(\"  -x, --xml\\t\\tUse XML output\\n\");\n\tprintf(\"  -d, --debug\\t\\tenable communication debugging\\n\");\n\tprintf(\"  -h, --help\\t\\tprints usage information\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"Homepage: <\" PACKAGE_URL \">\\n\");\n}",
          "includes": [
            "#include \"common/utils.h\"",
            "#include <asprintf.h>",
            "#include <libimobiledevice/mobile_image_mounter.h>",
            "#include <libimobiledevice/notification_proxy.h>",
            "#include <libimobiledevice/afc.h>",
            "#include <libimobiledevice/lockdown.h>",
            "#include <libimobiledevice/libimobiledevice.h>",
            "#include <inttypes.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <libgen.h>",
            "#include <errno.h>",
            "#include <getopt.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *udid = NULL;",
            "static char *imagetype = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common/utils.h\"\n#include <asprintf.h>\n#include <libimobiledevice/mobile_image_mounter.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <inttypes.h>\n#include <sys/time.h>\n#include <time.h>\n#include <libgen.h>\n#include <errno.h>\n#include <getopt.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <config.h>\n\nstatic char *udid = NULL;\nstatic char *imagetype = NULL;\n\nstatic void print_usage(int argc, char **argv)\n{\n\tchar *name = NULL;\n\n\tname = strrchr(argv[0], '/');\n\tprintf(\"Usage: %s [OPTIONS] IMAGE_FILE IMAGE_SIGNATURE_FILE\\n\\n\", (name ? name + 1: argv[0]));\n\tprintf(\"Mounts the specified disk image on the device.\\n\\n\");\n\tprintf(\"  -u, --udid UDID\\ttarget specific device by its 40-digit device UDID\\n\");\n\tprintf(\"  -l, --list\\t\\tList mount information\\n\");\n\tprintf(\"  -t, --imagetype\\tImage type to use, default is 'Developer'\\n\");\n\tprintf(\"  -x, --xml\\t\\tUse XML output\\n\");\n\tprintf(\"  -d, --debug\\t\\tenable communication debugging\\n\");\n\tprintf(\"  -h, --help\\t\\tprints usage information\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"Homepage: <\" PACKAGE_URL \">\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "idevice_set_debug_level",
          "args": [
            "1"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "idevice_set_debug_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/src/idevice.c",
          "lines": "225-228",
          "snippet": "LIBIMOBILEDEVICE_API void idevice_set_debug_level(int level)\n{\n\tinternal_set_debug_level(level);\n}",
          "includes": [
            "#include \"common/debug.h\"",
            "#include \"common/thread.h\"",
            "#include \"common/userpref.h\"",
            "#include \"idevice.h\"",
            "#include <gnutls/gnutls.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/err.h>",
            "#include <usbmuxd.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common/debug.h\"\n#include \"common/thread.h\"\n#include \"common/userpref.h\"\n#include \"idevice.h\"\n#include <gnutls/gnutls.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <usbmuxd.h>\n#include <windows.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nLIBIMOBILEDEVICE_API void idevice_set_debug_level(int level)\n{\n\tinternal_set_debug_level(level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "optarg"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "optarg"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: invalid UDID specified (length != 40)\\n\"",
            "argv[0]"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "asprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/include/asprintf.h",
          "lines": "23-31",
          "snippet": "static inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}",
          "includes": [
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <config.h>\n\nstatic inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "optarg"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getopt_long",
          "args": [
            "argc",
            "argv",
            "\"hu:lt:xd\"",
            "longopts",
            "(int *) 0"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common/utils.h\"\n#include <asprintf.h>\n#include <libimobiledevice/mobile_image_mounter.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <inttypes.h>\n#include <sys/time.h>\n#include <time.h>\n#include <libgen.h>\n#include <errno.h>\n#include <getopt.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <config.h>\n\nstatic int list_mode = 0;\nstatic int xml_mode = 0;\nstatic char *udid = NULL;\nstatic char *imagetype = NULL;\n\nstatic void parse_opts(int argc, char **argv)\n{\n\tstatic struct option longopts[] = {\n\t\t{\"help\", 0, NULL, 'h'},\n\t\t{\"udid\", 0, NULL, 'u'},\n\t\t{\"list\", 0, NULL, 'l'},\n\t\t{\"imagetype\", 0, NULL, 't'},\n\t\t{\"xml\", 0, NULL, 'x'},\n\t\t{\"debug\", 0, NULL, 'd'},\n\t\t{NULL, 0, NULL, 0}\n\t};\n\tint c;\n\n\twhile (1) {\n\t\tc = getopt_long(argc, argv, \"hu:lt:xd\", longopts,\n\t\t\t\t\t\t(int *) 0);\n\t\tif (c == -1) {\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (c) {\n\t\tcase 'h':\n\t\t\tprint_usage(argc, argv);\n\t\t\texit(0);\n\t\tcase 'u':\n\t\t\tif (strlen(optarg) != 40) {\n\t\t\t\tprintf(\"%s: invalid UDID specified (length != 40)\\n\",\n\t\t\t\t\t   argv[0]);\n\t\t\t\tprint_usage(argc, argv);\n\t\t\t\texit(2);\n\t\t\t}\n\t\t\tudid = strdup(optarg);\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tlist_mode = 1;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\timagetype = strdup(optarg);\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\txml_mode = 1;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tidevice_set_debug_level(1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprint_usage(argc, argv);\n\t\t\texit(2);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "print_usage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/tools/ideviceimagemounter.c",
    "lines": "59-74",
    "snippet": "static void print_usage(int argc, char **argv)\n{\n\tchar *name = NULL;\n\n\tname = strrchr(argv[0], '/');\n\tprintf(\"Usage: %s [OPTIONS] IMAGE_FILE IMAGE_SIGNATURE_FILE\\n\\n\", (name ? name + 1: argv[0]));\n\tprintf(\"Mounts the specified disk image on the device.\\n\\n\");\n\tprintf(\"  -u, --udid UDID\\ttarget specific device by its 40-digit device UDID\\n\");\n\tprintf(\"  -l, --list\\t\\tList mount information\\n\");\n\tprintf(\"  -t, --imagetype\\tImage type to use, default is 'Developer'\\n\");\n\tprintf(\"  -x, --xml\\t\\tUse XML output\\n\");\n\tprintf(\"  -d, --debug\\t\\tenable communication debugging\\n\");\n\tprintf(\"  -h, --help\\t\\tprints usage information\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"Homepage: <\" PACKAGE_URL \">\\n\");\n}",
    "includes": [
      "#include \"common/utils.h\"",
      "#include <asprintf.h>",
      "#include <libimobiledevice/mobile_image_mounter.h>",
      "#include <libimobiledevice/notification_proxy.h>",
      "#include <libimobiledevice/afc.h>",
      "#include <libimobiledevice/lockdown.h>",
      "#include <libimobiledevice/libimobiledevice.h>",
      "#include <inttypes.h>",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <libgen.h>",
      "#include <errno.h>",
      "#include <getopt.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char *udid = NULL;",
      "static char *imagetype = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Homepage: <\" PACKAGE_URL \">\\n\""
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  -h, --help\\t\\tprints usage information\\n\""
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  -d, --debug\\t\\tenable communication debugging\\n\""
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  -x, --xml\\t\\tUse XML output\\n\""
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  -t, --imagetype\\tImage type to use, default is 'Developer'\\n\""
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  -l, --list\\t\\tList mount information\\n\""
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  -u, --udid UDID\\ttarget specific device by its 40-digit device UDID\\n\""
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Mounts the specified disk image on the device.\\n\\n\""
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Usage: %s [OPTIONS] IMAGE_FILE IMAGE_SIGNATURE_FILE\\n\\n\"",
            "(name ? name + 1: argv[0])"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "asprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-5104/repo/include/asprintf.h",
          "lines": "23-31",
          "snippet": "static inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}",
          "includes": [
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <config.h>\n\nstatic inline int asprintf(char **PTR, const char *TEMPLATE, ...)\n{\n\tint res;\n\tva_list AP;\n\tva_start(AP, TEMPLATE);\n\tres = vasprintf(PTR, TEMPLATE, AP);\n\tva_end(AP);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "argv[0]",
            "'/'"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common/utils.h\"\n#include <asprintf.h>\n#include <libimobiledevice/mobile_image_mounter.h>\n#include <libimobiledevice/notification_proxy.h>\n#include <libimobiledevice/afc.h>\n#include <libimobiledevice/lockdown.h>\n#include <libimobiledevice/libimobiledevice.h>\n#include <inttypes.h>\n#include <sys/time.h>\n#include <time.h>\n#include <libgen.h>\n#include <errno.h>\n#include <getopt.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <config.h>\n\nstatic char *udid = NULL;\nstatic char *imagetype = NULL;\n\nstatic void print_usage(int argc, char **argv)\n{\n\tchar *name = NULL;\n\n\tname = strrchr(argv[0], '/');\n\tprintf(\"Usage: %s [OPTIONS] IMAGE_FILE IMAGE_SIGNATURE_FILE\\n\\n\", (name ? name + 1: argv[0]));\n\tprintf(\"Mounts the specified disk image on the device.\\n\\n\");\n\tprintf(\"  -u, --udid UDID\\ttarget specific device by its 40-digit device UDID\\n\");\n\tprintf(\"  -l, --list\\t\\tList mount information\\n\");\n\tprintf(\"  -t, --imagetype\\tImage type to use, default is 'Developer'\\n\");\n\tprintf(\"  -x, --xml\\t\\tUse XML output\\n\");\n\tprintf(\"  -d, --debug\\t\\tenable communication debugging\\n\");\n\tprintf(\"  -h, --help\\t\\tprints usage information\\n\");\n\tprintf(\"\\n\");\n\tprintf(\"Homepage: <\" PACKAGE_URL \">\\n\");\n}"
  }
]