[
  {
    "function_name": "fs_private_tmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
    "lines": "1271-1278",
    "snippet": "void fs_private_tmp(void) {\n\t// mount tmpfs on top of /run/firejail/mnt\n\tif (arg_debug)\n\t\tprintf(\"Mounting tmpfs on /tmp directory\\n\");\n\tif (mount(\"tmpfs\", \"/tmp\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME | MS_REC,  \"mode=1777,gid=0\") < 0)\n\t\terrExit(\"mounting tmpfs on /tmp directory\");\n\tfs_logger2(\"tmpfs\", \"/tmp\");\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_logger2",
          "args": [
            "\"tmpfs\"",
            "\"/tmp\""
          ],
          "line": 1277
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger2int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_logger.c",
          "lines": "73-80",
          "snippet": "void fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mounting tmpfs on /tmp directory\""
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"tmpfs\"",
            "\"/tmp\"",
            "\"tmpfs\"",
            "MS_NOSUID | MS_STRICTATIME | MS_REC",
            "\"mode=1777,gid=0\""
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Mounting tmpfs on /tmp directory\\n\""
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_private_tmp(void) {\n\t// mount tmpfs on top of /run/firejail/mnt\n\tif (arg_debug)\n\t\tprintf(\"Mounting tmpfs on /tmp directory\\n\");\n\tif (mount(\"tmpfs\", \"/tmp\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME | MS_REC,  \"mode=1777,gid=0\") < 0)\n\t\terrExit(\"mounting tmpfs on /tmp directory\");\n\tfs_logger2(\"tmpfs\", \"/tmp\");\n}"
  },
  {
    "function_name": "fs_chroot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
    "lines": "1184-1268",
    "snippet": "void fs_chroot(const char *rootdir) {\n\tassert(rootdir);\n\t\n\tif (checkcfg(CFG_CHROOT_DESKTOP)) {\n\t\t// mount-bind a /dev in rootdir\n\t\tchar *newdev;\n\t\tif (asprintf(&newdev, \"%s/dev\", rootdir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting /dev on %s\\n\", newdev);\n\t\tif (mount(\"/dev\", newdev, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mounting /dev\");\n\t\tfree(newdev);\n\t\t\n\t\t// x11\n\t\tif (getenv(\"FIREJAIL_X11\")) {\n\t\t\tmask_x11_abstract_socket = 1;\n\t\t\tchar *newx11;\n\t\t\tif (asprintf(&newx11, \"%s/tmp/.X11-unix\", rootdir) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Mounting /tmp/.X11-unix on %s\\n\", newx11);\n\t\t\tif (mount(\"/tmp/.X11-unix\", newx11, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mounting /tmp/.X11-unix\");\n\t\t\tfree(newx11);\n\t\t}\n\t\t\n\t\t// some older distros don't have a /run directory\n\t\t// create one by default\n\t\t// no exit on error, let the user deal with any problems\n\t\tchar *rundir;\n\t\tif (asprintf(&rundir, \"%s/run\", rootdir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (!is_dir(rundir)) {\n\t\t\tint rv = mkdir(rundir, 0755);\n\t\t\t(void) rv;\n\t\t\trv = chown(rundir, 0, 0);\n\t\t\t(void) rv;\n\t\t}\n\t\t\n\t\t// copy /etc/resolv.conf in chroot directory\n\t\t// if resolv.conf in chroot is a symbolic link, this will fail\n\t\t// no exit on error, let the user deal with the problem\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"%s/etc/resolv.conf\", rootdir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Updating /etc/resolv.conf in %s\\n\", fname);\n\t\tif (is_link(fname)) {\n\t\t\tfprintf(stderr, \"Error: invalid %s file\\n\", fname);\n\t\t\texit(1);\n\t\t}\n\t\tif (copy_file(\"/etc/resolv.conf\", fname, 0, 0, 0644) == -1)\n\t\t\tfprintf(stderr, \"Warning: /etc/resolv.conf not initialized\\n\");\n\t}\n\t\n\t// chroot into the new directory\n\tif (arg_debug)\n\t\tprintf(\"Chrooting into %s\\n\", rootdir);\n\tif (chroot(rootdir) < 0)\n\t\terrExit(\"chroot\");\n\t// mount a new tmpfs in /run/firejail/mnt - the old one was lost in chroot\n\tfs_build_remount_mnt_dir();\n\t\t\n\tif (checkcfg(CFG_CHROOT_DESKTOP)) {\n\t\t// update /var directory in order to support multiple sandboxes running on the same root directory\n\t\tif (!arg_private_dev)\n\t\t\tfs_dev_shm();\n\t\tfs_var_lock();\n\t\tfs_var_tmp();\n\t\tfs_var_log();\n\t\tfs_var_lib();\n\t\tfs_var_cache();\n\t\tfs_var_utmp();\n\t\n\t\t// don't leak user information\n\t\trestrict_users();\n\t\n\t\t// when starting as root, firejail config is not disabled;\n\t\t// this mode could be used to install and test new software by chaining\n\t\t// firejail sandboxes (firejail --force)\n\t\tif (getuid() != 0)\n\t\t\tdisable_config();\n\t}\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "disable_config",
          "args": [],
          "line": 1266
        },
        "resolved": true,
        "details": {
          "function_name": "disable_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
          "lines": "721-740",
          "snippet": "static void disable_config(void) {\n\tstruct stat s;\n\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/.config/firejail\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (stat(fname, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, fname);\n\tfree(fname);\n\t\n\t// disable run time information\n\tif (stat(RUN_FIREJAIL_NETWORK_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_NETWORK_DIR);\n\tif (stat(RUN_FIREJAIL_BANDWIDTH_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_BANDWIDTH_DIR);\n\tif (stat(RUN_FIREJAIL_NAME_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_NAME_DIR);\n\tif (stat(RUN_FIREJAIL_X11_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_X11_DIR);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void disable_config(void) {\n\tstruct stat s;\n\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/.config/firejail\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (stat(fname, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, fname);\n\tfree(fname);\n\t\n\t// disable run time information\n\tif (stat(RUN_FIREJAIL_NETWORK_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_NETWORK_DIR);\n\tif (stat(RUN_FIREJAIL_BANDWIDTH_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_BANDWIDTH_DIR);\n\tif (stat(RUN_FIREJAIL_NAME_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_NAME_DIR);\n\tif (stat(RUN_FIREJAIL_X11_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_X11_DIR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "restrict_users",
          "args": [],
          "line": 1260
        },
        "resolved": true,
        "details": {
          "function_name": "restrict_users",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/restrict_users.c",
          "lines": "337-357",
          "snippet": "void restrict_users(void) {\n\tif (arg_allusers)\n\t\treturn;\n\t\t\n\t// only in user mode\n\tif (getuid()) {\n\t\tif (strncmp(cfg.homedir, \"/home/\", 6) == 0) {\n\t\t\t// user has the home directory under /home\n\t\t\tsanitize_home();\n\t\t}\n\t\telse {\n\t\t\t// user has the home directory outside /home\n\t\t\t// mount tmpfs on top of /home in order to hide it\n\t\t\tif (mount(\"tmpfs\", \"/home\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\t\terrExit(\"mount tmpfs\");\n\t\t\tfs_logger(\"tmpfs /home\");\n\t\t}\n\t\tsanitize_passwd();\n\t\tsanitize_group();\n\t}\n}",
          "includes": [
            "#include \"../../uids.h\"",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../uids.h\"\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid restrict_users(void) {\n\tif (arg_allusers)\n\t\treturn;\n\t\t\n\t// only in user mode\n\tif (getuid()) {\n\t\tif (strncmp(cfg.homedir, \"/home/\", 6) == 0) {\n\t\t\t// user has the home directory under /home\n\t\t\tsanitize_home();\n\t\t}\n\t\telse {\n\t\t\t// user has the home directory outside /home\n\t\t\t// mount tmpfs on top of /home in order to hide it\n\t\t\tif (mount(\"tmpfs\", \"/home\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\t\terrExit(\"mount tmpfs\");\n\t\t\tfs_logger(\"tmpfs /home\");\n\t\t}\n\t\tsanitize_passwd();\n\t\tsanitize_group();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_var_utmp",
          "args": [],
          "line": 1257
        },
        "resolved": true,
        "details": {
          "function_name": "fs_var_utmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_var.c",
          "lines": "308-355",
          "snippet": "void fs_var_utmp(void) {\n\tstruct stat s;\n\n\t// extract utmp group id\n\tgid_t utmp_group = 0;\n\tif (stat(UTMP_FILE, &s) == 0)\n\t\tutmp_group = s.st_gid;\n\telse {\n\t\tfprintf(stderr, \"Warning: cannot find /var/run/utmp\\n\");\n\t\treturn;\n\t}\n\n\t// create /run/firejail/mnt directory\n\tfs_build_mnt_dir();\n\t\n\t// create a new utmp file\n\tif (arg_debug)\n\t\tprintf(\"Create the new utmp file\\n\");\n\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(RUN_UTMP_FILE, \"w\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\t\t\n\t// read current utmp\n\tstruct utmp *u;\n\tstruct utmp u_boot;\n\tsetutent();\n\twhile ((u = getutent()) != NULL) {\n\t\tif (u->ut_type == BOOT_TIME) {\n\t\t\tmemcpy(&u_boot, u, sizeof(u_boot));\n\t\t\tu_boot.ut_tv.tv_sec = (unsigned) time(NULL);\n\t\t}\n\t}\n\tendutent();\n\t\t\t\n\t// save new utmp file\n\tfwrite(&u_boot, sizeof(u_boot), 1, fp);\n\tSET_PERMS_STREAM(fp, 0, utmp_group, S_IRUSR | S_IWRITE | S_IRGRP | S_IWGRP | S_IROTH);\n\tfclose(fp);\n\t\n\t// mount the new utmp file\n\tif (arg_debug)\n\t\tprintf(\"Mount the new utmp file\\n\");\n\tif (mount(RUN_UTMP_FILE, UTMP_FILE, NULL, MS_BIND|MS_NOSUID|MS_NOEXEC | MS_NODEV | MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind utmp\");\n\tfs_logger(\"create /var/run/utmp\");\n}",
          "includes": [
            "#include <time.h>",
            "#include <utmp.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <utmp.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_var_utmp(void) {\n\tstruct stat s;\n\n\t// extract utmp group id\n\tgid_t utmp_group = 0;\n\tif (stat(UTMP_FILE, &s) == 0)\n\t\tutmp_group = s.st_gid;\n\telse {\n\t\tfprintf(stderr, \"Warning: cannot find /var/run/utmp\\n\");\n\t\treturn;\n\t}\n\n\t// create /run/firejail/mnt directory\n\tfs_build_mnt_dir();\n\t\n\t// create a new utmp file\n\tif (arg_debug)\n\t\tprintf(\"Create the new utmp file\\n\");\n\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(RUN_UTMP_FILE, \"w\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\t\t\n\t// read current utmp\n\tstruct utmp *u;\n\tstruct utmp u_boot;\n\tsetutent();\n\twhile ((u = getutent()) != NULL) {\n\t\tif (u->ut_type == BOOT_TIME) {\n\t\t\tmemcpy(&u_boot, u, sizeof(u_boot));\n\t\t\tu_boot.ut_tv.tv_sec = (unsigned) time(NULL);\n\t\t}\n\t}\n\tendutent();\n\t\t\t\n\t// save new utmp file\n\tfwrite(&u_boot, sizeof(u_boot), 1, fp);\n\tSET_PERMS_STREAM(fp, 0, utmp_group, S_IRUSR | S_IWRITE | S_IRGRP | S_IWGRP | S_IROTH);\n\tfclose(fp);\n\t\n\t// mount the new utmp file\n\tif (arg_debug)\n\t\tprintf(\"Mount the new utmp file\\n\");\n\tif (mount(RUN_UTMP_FILE, UTMP_FILE, NULL, MS_BIND|MS_NOSUID|MS_NOEXEC | MS_NODEV | MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind utmp\");\n\tfs_logger(\"create /var/run/utmp\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_var_cache",
          "args": [],
          "line": 1256
        },
        "resolved": true,
        "details": {
          "function_name": "fs_var_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_var.c",
          "lines": "200-240",
          "snippet": "void fs_var_cache(void) {\n\tstruct stat s;\n\n\tif (stat(\"/var/cache/apache2\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/cache/apache2\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/cache/apache2\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/cache/apache2\");\n\t\tfs_logger(\"tmpfs /var/cache/apache2\");\n\t}\t\t\t\n\n\tif (stat(\"/var/cache/lighttpd\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/cache/lighttpd\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/cache/lighttpd\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/cache/lighttpd\");\n\t\tfs_logger(\"tmpfs /var/cache/lighttpd\");\n\n\t\tstruct passwd *p = getpwnam(\"www-data\");\n\t\tuid_t uid = 0;\n\t\tgid_t gid = 0;\n\t\tif (p) {\n\t\t\tuid = p->pw_uid;\n\t\t\tgid = p->pw_gid;\n\t\t}\n\t\t\n\t\tint rv = mkdir(\"/var/cache/lighttpd/compress\", 0755);\n\t\tif (rv == -1)\n\t\t\terrExit(\"mkdir\");\n\t\tif (chown(\"/var/cache/lighttpd/compress\", uid, gid) < 0)\n\t\t\terrExit(\"chown\");\n\t\tfs_logger(\"mkdir /var/cache/lighttpd/compress\");\n\n\t\trv = mkdir(\"/var/cache/lighttpd/uploads\", 0755);\n\t\tif (rv == -1)\n\t\t\terrExit(\"mkdir\");\n\t\tif (chown(\"/var/cache/lighttpd/uploads\", uid, gid) < 0)\n\t\t\terrExit(\"chown\");\n\t\tfs_logger(\"/var/cache/lighttpd/uploads\");\n\t}\t\t\t\n}",
          "includes": [
            "#include <time.h>",
            "#include <utmp.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <utmp.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_var_cache(void) {\n\tstruct stat s;\n\n\tif (stat(\"/var/cache/apache2\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/cache/apache2\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/cache/apache2\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/cache/apache2\");\n\t\tfs_logger(\"tmpfs /var/cache/apache2\");\n\t}\t\t\t\n\n\tif (stat(\"/var/cache/lighttpd\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/cache/lighttpd\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/cache/lighttpd\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/cache/lighttpd\");\n\t\tfs_logger(\"tmpfs /var/cache/lighttpd\");\n\n\t\tstruct passwd *p = getpwnam(\"www-data\");\n\t\tuid_t uid = 0;\n\t\tgid_t gid = 0;\n\t\tif (p) {\n\t\t\tuid = p->pw_uid;\n\t\t\tgid = p->pw_gid;\n\t\t}\n\t\t\n\t\tint rv = mkdir(\"/var/cache/lighttpd/compress\", 0755);\n\t\tif (rv == -1)\n\t\t\terrExit(\"mkdir\");\n\t\tif (chown(\"/var/cache/lighttpd/compress\", uid, gid) < 0)\n\t\t\terrExit(\"chown\");\n\t\tfs_logger(\"mkdir /var/cache/lighttpd/compress\");\n\n\t\trv = mkdir(\"/var/cache/lighttpd/uploads\", 0755);\n\t\tif (rv == -1)\n\t\t\terrExit(\"mkdir\");\n\t\tif (chown(\"/var/cache/lighttpd/uploads\", uid, gid) < 0)\n\t\t\terrExit(\"chown\");\n\t\tfs_logger(\"/var/cache/lighttpd/uploads\");\n\t}\t\t\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_var_lib",
          "args": [],
          "line": 1255
        },
        "resolved": true,
        "details": {
          "function_name": "fs_var_lib",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_var.c",
          "lines": "150-198",
          "snippet": "void fs_var_lib(void) {\n\tstruct stat s;\n\t\n\t// ISC DHCP multiserver\n\tif (stat(\"/var/lib/dhcp\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lib/dhcp\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lib/dhcp\", \"tmpfs\", MS_NOSUID |  MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/lib/dhcp\");\n\t\tfs_logger(\"tmpfs /var/lib/dhcp\");\n\t\t\t\n\t\t// isc dhcp server requires a /var/lib/dhcp/dhcpd.leases file\n\t\tFILE *fp = fopen(\"/var/lib/dhcp/dhcpd.leases\", \"w\");\n\t\t\n\t\tif (fp) {\n\t\t\tfprintf(fp, \"\\n\");\n\t\t\tSET_PERMS_STREAM(fp, 0, 0, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);\n\t\t\tfclose(fp);\n\t\t\tfs_logger(\"touch /var/lib/dhcp/dhcpd.leases\");\n\t\t}\n\t}\n\n\t// nginx multiserver\n\tif (stat(\"/var/lib/nginx\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lib/nginx\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lib/nginx\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/lib/nginx\");\n\t\tfs_logger(\"tmpfs /var/lib/nginx\");\n\t}\t\t\t\n\n\t// net-snmp multiserver\n\tif (stat(\"/var/lib/snmp\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lib/snmp\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lib/snmp\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/lib/snmp\");\n\t\tfs_logger(\"tmpfs /var/lib/snmp\");\n\t}\t\t\t\n\n\t// this is where sudo remembers its state\n\tif (stat(\"/var/lib/sudo\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lib/sudo\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lib/sudo\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/lib/sudo\");\n\t\tfs_logger(\"tmpfs /var/lib/sudo\");\n\t}\t\t\t\n}",
          "includes": [
            "#include <time.h>",
            "#include <utmp.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <utmp.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_var_lib(void) {\n\tstruct stat s;\n\t\n\t// ISC DHCP multiserver\n\tif (stat(\"/var/lib/dhcp\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lib/dhcp\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lib/dhcp\", \"tmpfs\", MS_NOSUID |  MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/lib/dhcp\");\n\t\tfs_logger(\"tmpfs /var/lib/dhcp\");\n\t\t\t\n\t\t// isc dhcp server requires a /var/lib/dhcp/dhcpd.leases file\n\t\tFILE *fp = fopen(\"/var/lib/dhcp/dhcpd.leases\", \"w\");\n\t\t\n\t\tif (fp) {\n\t\t\tfprintf(fp, \"\\n\");\n\t\t\tSET_PERMS_STREAM(fp, 0, 0, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);\n\t\t\tfclose(fp);\n\t\t\tfs_logger(\"touch /var/lib/dhcp/dhcpd.leases\");\n\t\t}\n\t}\n\n\t// nginx multiserver\n\tif (stat(\"/var/lib/nginx\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lib/nginx\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lib/nginx\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/lib/nginx\");\n\t\tfs_logger(\"tmpfs /var/lib/nginx\");\n\t}\t\t\t\n\n\t// net-snmp multiserver\n\tif (stat(\"/var/lib/snmp\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lib/snmp\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lib/snmp\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/lib/snmp\");\n\t\tfs_logger(\"tmpfs /var/lib/snmp\");\n\t}\t\t\t\n\n\t// this is where sudo remembers its state\n\tif (stat(\"/var/lib/sudo\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lib/sudo\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lib/sudo\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/lib/sudo\");\n\t\tfs_logger(\"tmpfs /var/lib/sudo\");\n\t}\t\t\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_var_log",
          "args": [],
          "line": 1254
        },
        "resolved": true,
        "details": {
          "function_name": "fs_var_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_var.c",
          "lines": "110-148",
          "snippet": "void fs_var_log(void) {\n\tbuild_list(\"/var/log\");\n\t\n\t// create /var/log if it doesn't exit\n\tif (is_dir(\"/var/log\")) {\n\t\t// extract group id for /var/log/wtmp\n\t\tstruct stat s;\n\t\tgid_t wtmp_group = 0;\n\t\tif (stat(\"/var/log/wtmp\", &s) == 0)\n\t\t\twtmp_group = s.st_gid;\n\t\t\n\t\t// mount a tmpfs on top of /var/log\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/log\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/log\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/log\");\n\t\tfs_logger(\"tmpfs /var/log\");\n\t\t\n\t\tbuild_dirs();\n\t\trelease_all();\n\t\t\n\t\t// create an empty /var/log/wtmp file\n\t\t/* coverity[toctou] */\n\t\tFILE *fp = fopen(\"/var/log/wtmp\", \"w\");\n\t\tSET_PERMS_STREAM(fp, 0, wtmp_group, S_IRUSR | S_IWRITE | S_IRGRP | S_IWGRP | S_IROTH);\n\t\tif (fp)\n\t\t\tfclose(fp);\n\t\tfs_logger(\"touch /var/log/wtmp\");\n\t\t\t\n\t\t// create an empty /var/log/btmp file\n\t\tfp = fopen(\"/var/log/btmp\", \"w\");\n\t\tSET_PERMS_STREAM(fp, 0, wtmp_group, S_IRUSR | S_IWRITE | S_IRGRP | S_IWGRP);\n\t\tif (fp)\n\t\t\tfclose(fp);\n\t\tfs_logger(\"touch /var/log/btmp\");\n\t}\n\telse\n\t\tfprintf(stderr, \"Warning: cannot mount tmpfs on top of /var/log\\n\");\n}",
          "includes": [
            "#include <time.h>",
            "#include <utmp.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <utmp.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_var_log(void) {\n\tbuild_list(\"/var/log\");\n\t\n\t// create /var/log if it doesn't exit\n\tif (is_dir(\"/var/log\")) {\n\t\t// extract group id for /var/log/wtmp\n\t\tstruct stat s;\n\t\tgid_t wtmp_group = 0;\n\t\tif (stat(\"/var/log/wtmp\", &s) == 0)\n\t\t\twtmp_group = s.st_gid;\n\t\t\n\t\t// mount a tmpfs on top of /var/log\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/log\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/log\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/log\");\n\t\tfs_logger(\"tmpfs /var/log\");\n\t\t\n\t\tbuild_dirs();\n\t\trelease_all();\n\t\t\n\t\t// create an empty /var/log/wtmp file\n\t\t/* coverity[toctou] */\n\t\tFILE *fp = fopen(\"/var/log/wtmp\", \"w\");\n\t\tSET_PERMS_STREAM(fp, 0, wtmp_group, S_IRUSR | S_IWRITE | S_IRGRP | S_IWGRP | S_IROTH);\n\t\tif (fp)\n\t\t\tfclose(fp);\n\t\tfs_logger(\"touch /var/log/wtmp\");\n\t\t\t\n\t\t// create an empty /var/log/btmp file\n\t\tfp = fopen(\"/var/log/btmp\", \"w\");\n\t\tSET_PERMS_STREAM(fp, 0, wtmp_group, S_IRUSR | S_IWRITE | S_IRGRP | S_IWGRP);\n\t\tif (fp)\n\t\t\tfclose(fp);\n\t\tfs_logger(\"touch /var/log/btmp\");\n\t}\n\telse\n\t\tfprintf(stderr, \"Warning: cannot mount tmpfs on top of /var/log\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_var_tmp",
          "args": [],
          "line": 1253
        },
        "resolved": true,
        "details": {
          "function_name": "fs_var_tmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_var.c",
          "lines": "291-306",
          "snippet": "void fs_var_tmp(void) {\n\tstruct stat s;\n\tif (stat(\"/var/tmp\", &s) == 0) {\n\t\tif (!is_link(\"/var/tmp\")) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Mounting tmpfs on /var/tmp\\n\");\n\t\t\tif (mount(\"tmpfs\", \"/var/tmp\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=1777,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting /var/tmp\");\n\t\t\tfs_logger(\"tmpfs /var/tmp\");\n\t\t}\n\t}\n\telse {\n\t\tfprintf(stderr, \"Warning: /var/tmp not mounted\\n\");\n\t\tdbg_test_dir(\"/var/tmp\");\n\t}\n}",
          "includes": [
            "#include <time.h>",
            "#include <utmp.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <utmp.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_var_tmp(void) {\n\tstruct stat s;\n\tif (stat(\"/var/tmp\", &s) == 0) {\n\t\tif (!is_link(\"/var/tmp\")) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Mounting tmpfs on /var/tmp\\n\");\n\t\t\tif (mount(\"tmpfs\", \"/var/tmp\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=1777,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting /var/tmp\");\n\t\t\tfs_logger(\"tmpfs /var/tmp\");\n\t\t}\n\t}\n\telse {\n\t\tfprintf(stderr, \"Warning: /var/tmp not mounted\\n\");\n\t\tdbg_test_dir(\"/var/tmp\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_var_lock",
          "args": [],
          "line": 1252
        },
        "resolved": true,
        "details": {
          "function_name": "fs_var_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_var.c",
          "lines": "257-289",
          "snippet": "void fs_var_lock(void) {\n\n\tif (is_dir(\"/var/lock\")) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lock\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lock\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=1777,gid=0\") < 0)\n\t\t\terrExit(\"mounting /lock\");\n\t\tfs_logger(\"tmpfs /var/lock\");\n\t}\n\telse {\n\t\tchar *lnk = realpath(\"/var/lock\", NULL);\n\t\tif (lnk) {\n\t\t\tif (!is_dir(lnk)) {\n\t\t\t\t// create directory\n\t\t\t\tif (mkdir(lnk, S_IRWXU|S_IRWXG|S_IRWXO))\n\t\t\t\t\terrExit(\"mkdir\");\n\t\t\t\tif (chmod(lnk, S_IRWXU|S_IRWXG|S_IRWXO))\n\t\t\t\t\terrExit(\"chmod\");\n\t\t\t\tASSERT_PERMS(lnk, 0, 0, S_IRWXU|S_IRWXG|S_IRWXO);\n\t\t\t}\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Mounting tmpfs on %s on behalf of /var/lock\\n\", lnk);\n\t\t\tif (mount(\"tmpfs\", lnk, \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=1777,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting /var/lock\");\n\t\t\tfree(lnk);\n\t\t\tfs_logger(\"tmpfs /var/lock\");\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"Warning: /var/lock not mounted\\n\");\n\t\t\tdbg_test_dir(\"/var/lock\");\n\t\t}\n\t}\n}",
          "includes": [
            "#include <time.h>",
            "#include <utmp.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <utmp.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_var_lock(void) {\n\n\tif (is_dir(\"/var/lock\")) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lock\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lock\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=1777,gid=0\") < 0)\n\t\t\terrExit(\"mounting /lock\");\n\t\tfs_logger(\"tmpfs /var/lock\");\n\t}\n\telse {\n\t\tchar *lnk = realpath(\"/var/lock\", NULL);\n\t\tif (lnk) {\n\t\t\tif (!is_dir(lnk)) {\n\t\t\t\t// create directory\n\t\t\t\tif (mkdir(lnk, S_IRWXU|S_IRWXG|S_IRWXO))\n\t\t\t\t\terrExit(\"mkdir\");\n\t\t\t\tif (chmod(lnk, S_IRWXU|S_IRWXG|S_IRWXO))\n\t\t\t\t\terrExit(\"chmod\");\n\t\t\t\tASSERT_PERMS(lnk, 0, 0, S_IRWXU|S_IRWXG|S_IRWXO);\n\t\t\t}\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Mounting tmpfs on %s on behalf of /var/lock\\n\", lnk);\n\t\t\tif (mount(\"tmpfs\", lnk, \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=1777,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting /var/lock\");\n\t\t\tfree(lnk);\n\t\t\tfs_logger(\"tmpfs /var/lock\");\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"Warning: /var/lock not mounted\\n\");\n\t\t\tdbg_test_dir(\"/var/lock\");\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_dev_shm",
          "args": [],
          "line": 1251
        },
        "resolved": true,
        "details": {
          "function_name": "fs_dev_shm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_dev.c",
          "lines": "247-284",
          "snippet": "void fs_dev_shm(void) {\n\tuid_t uid = getuid(); // set a new shm only if we started as root\n\tif (uid)\n\t\treturn;\n\n\tif (is_dir(\"/dev/shm\")) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /dev/shm\\n\");\n\t\tif (mount(\"tmpfs\", \"/dev/shm\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME | MS_REC,  \"mode=1777,gid=0\") < 0)\n\t\t\terrExit(\"mounting /dev/shm\");\n\t\tfs_logger(\"tmpfs /dev/shm\");\n\t}\n\telse {\n\t\tchar *lnk = realpath(\"/dev/shm\", NULL);\n\t\tif (lnk) {\n\t\t\tif (!is_dir(lnk)) {\n\t\t\t\t// create directory\n\t\t\t\tif (mkdir(lnk, 01777))\n\t\t\t\t\terrExit(\"mkdir\");\n\t\t\t\t// mkdir sets only the file permission bits\n\t\t\t\tif (chmod(lnk, 01777))\n\t\t\t\t\terrExit(\"chmod\");\n\t\t\t\tASSERT_PERMS(lnk, 0, 0, 01777);\n\t\t\t}\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Mounting tmpfs on %s on behalf of /dev/shm\\n\", lnk);\n\t\t\tif (mount(\"tmpfs\", lnk, \"tmpfs\", MS_NOSUID | MS_STRICTATIME | MS_REC,  \"mode=1777,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting /var/tmp\");\n\t\t\tfs_logger2(\"tmpfs\", lnk);\n\t\t\tfree(lnk);\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"Warning: /dev/shm not mounted\\n\");\n\t\t\tdbg_test_dir(\"/dev/shm\");\n\t\t}\n\t\t\t\n\t}\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_dev_shm(void) {\n\tuid_t uid = getuid(); // set a new shm only if we started as root\n\tif (uid)\n\t\treturn;\n\n\tif (is_dir(\"/dev/shm\")) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /dev/shm\\n\");\n\t\tif (mount(\"tmpfs\", \"/dev/shm\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME | MS_REC,  \"mode=1777,gid=0\") < 0)\n\t\t\terrExit(\"mounting /dev/shm\");\n\t\tfs_logger(\"tmpfs /dev/shm\");\n\t}\n\telse {\n\t\tchar *lnk = realpath(\"/dev/shm\", NULL);\n\t\tif (lnk) {\n\t\t\tif (!is_dir(lnk)) {\n\t\t\t\t// create directory\n\t\t\t\tif (mkdir(lnk, 01777))\n\t\t\t\t\terrExit(\"mkdir\");\n\t\t\t\t// mkdir sets only the file permission bits\n\t\t\t\tif (chmod(lnk, 01777))\n\t\t\t\t\terrExit(\"chmod\");\n\t\t\t\tASSERT_PERMS(lnk, 0, 0, 01777);\n\t\t\t}\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Mounting tmpfs on %s on behalf of /dev/shm\\n\", lnk);\n\t\t\tif (mount(\"tmpfs\", lnk, \"tmpfs\", MS_NOSUID | MS_STRICTATIME | MS_REC,  \"mode=1777,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting /var/tmp\");\n\t\t\tfs_logger2(\"tmpfs\", lnk);\n\t\t\tfree(lnk);\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"Warning: /dev/shm not mounted\\n\");\n\t\t\tdbg_test_dir(\"/dev/shm\");\n\t\t}\n\t\t\t\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "checkcfg",
          "args": [
            "CFG_CHROOT_DESKTOP"
          ],
          "line": 1248
        },
        "resolved": true,
        "details": {
          "function_name": "checkcfg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/checkcfg.c",
          "lines": "32-286",
          "snippet": "int checkcfg(int val) {\n\tassert(val < CFG_MAX);\n\tint line = 0;\n\n\tif (!initialized) {\n\t\t// initialize defaults\n\t\tint i;\n\t\tfor (i = 0; i < CFG_MAX; i++)\n\t\t\tcfg_val[i] = 1; // most of them are enabled by default\n\t\tcfg_val[CFG_RESTRICTED_NETWORK] = 0; // disabled by default\n\t\tcfg_val[CFG_FORCE_NONEWPRIVS] = 0; // disabled by default\n\t\tcfg_val[CFG_PRIVATE_BIN_NO_LOCAL] = 0; // disabled by default\n\t\t\n\t\t// open configuration file\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"%s/firejail.config\", SYSCONFDIR) == -1)\n\t\t\terrExit(\"asprintf\");\n\n\t\tFILE *fp = fopen(fname, \"r\");\n\t\tif (!fp) {\n#ifdef HAVE_GLOBALCFG\t\t\t\n\t\t\tfprintf(stderr, \"Error: Firejail configuration file %s not found\\n\", fname);\n\t\t\texit(1);\n#else\n\t\t\tinitialized = 1;\n\t\t\treturn\tcfg_val[val];\n#endif\t\n\t\t}\n\t\t\n\t\t// if the file exists, it should be owned by root\n\t\tstruct stat s;\n\t\tif (stat(fname, &s) == -1)\n\t\t\terrExit(\"stat\");\n\t\tif (s.st_uid != 0) {\n\t\t\tfprintf(stderr, \"Error: configuration file should be owned by root\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\t// read configuration file\n\t\tchar buf[MAX_READ];\n\t\twhile (fgets(buf,MAX_READ, fp)) {\n\t\t\tline++;\n\t\t\tif (*buf == '#' || *buf == '\\n') \n\t\t\t\tcontinue;\n\n\t\t\t// parse line\t\t\t\t\n\t\t\tchar *ptr = line_remove_spaces(buf);\n\t\t\tif (!ptr)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\t// file transfer\t\n\t\t\tif (strncmp(ptr, \"file-transfer \", 14) == 0) {\n\t\t\t\tif (strcmp(ptr + 14, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_FILE_TRANSFER] = 1;\n\t\t\t\telse if (strcmp(ptr + 14, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_FILE_TRANSFER] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// x11\n\t\t\telse if (strncmp(ptr, \"x11 \", 4) == 0) {\n\t\t\t\tif (strcmp(ptr + 4, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_X11] = 1;\n\t\t\t\telse if (strcmp(ptr + 4, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_X11] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// bind\n\t\t\telse if (strncmp(ptr, \"bind \", 5) == 0) {\n\t\t\t\tif (strcmp(ptr + 5, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_BIND] = 1;\n\t\t\t\telse if (strcmp(ptr + 5, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_BIND] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// user namespace\n\t\t\telse if (strncmp(ptr, \"userns \", 7) == 0) {\n\t\t\t\tif (strcmp(ptr + 7, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_USERNS] = 1;\n\t\t\t\telse if (strcmp(ptr + 7, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_USERNS] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// chroot\n\t\t\telse if (strncmp(ptr, \"chroot \", 7) == 0) {\n\t\t\t\tif (strcmp(ptr + 7, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_CHROOT] = 1;\n\t\t\t\telse if (strcmp(ptr + 7, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_CHROOT] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// nonewprivs\n\t\t\telse if (strncmp(ptr, \"force-nonewprivs \", 17) == 0) {\n\t\t\t\tif (strcmp(ptr + 17, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_SECCOMP] = 1;\n\t\t\t\telse if (strcmp(ptr + 17, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_SECCOMP] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// seccomp\n\t\t\telse if (strncmp(ptr, \"seccomp \", 8) == 0) {\n\t\t\t\tif (strcmp(ptr + 8, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_SECCOMP] = 1;\n\t\t\t\telse if (strcmp(ptr + 8, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_SECCOMP] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// whitelist\n\t\t\telse if (strncmp(ptr, \"whitelist \", 10) == 0) {\n\t\t\t\tif (strcmp(ptr + 10, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_WHITELIST] = 1;\n\t\t\t\telse if (strcmp(ptr + 10, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_WHITELIST] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// network\n\t\t\telse if (strncmp(ptr, \"network \", 8) == 0) {\n\t\t\t\tif (strcmp(ptr + 8, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_NETWORK] = 1;\n\t\t\t\telse if (strcmp(ptr + 8, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_NETWORK] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// network\n\t\t\telse if (strncmp(ptr, \"restricted-network \", 19) == 0) {\n\t\t\t\tif (strcmp(ptr + 19, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_RESTRICTED_NETWORK] = 1;\n\t\t\t\telse if (strcmp(ptr + 19, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_RESTRICTED_NETWORK] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// netfilter\n\t\t\telse if (strncmp(ptr, \"netfilter-default \", 18) == 0) {\n\t\t\t\tchar *fname = ptr + 18;\n\t\t\t\twhile (*fname == ' ' || *fname == '\\t')\n\t\t\t\t\tptr++;\n\t\t\t\tchar *end = strchr(fname, ' ');\n\t\t\t\tif (end)\n\t\t\t\t\t*end = '\\0';\n\t\t\t\t\n\t\t\t\t// is the file present?\n\t\t\t\tstruct stat s;\n\t\t\t\tif (stat(fname, &s) == -1) {\n\t\t\t\t\tfprintf(stderr, \"Error: netfilter-default file %s not available\\n\", fname);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tnetfilter_default = strdup(fname);\n\t\t\t\tif (!netfilter_default)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t\tif (arg_debug)\n\t\t\t\t\tprintf(\"netfilter default file %s\\n\", fname);\n\t\t\t}\n\t\t\t\n\t\t\t// Xephyr screen size\n\t\t\telse if (strncmp(ptr, \"xephyr-screen \", 14) == 0) {\n\t\t\t\t// expecting two numbers and an x between them\n\t\t\t\tint n1;\n\t\t\t\tint n2;\n\t\t\t\tint rv = sscanf(ptr + 14, \"%dx%d\", &n1, &n2);\n\t\t\t\tif (rv != 2)\n\t\t\t\t\tgoto errout;\n\t\t\t\tif (asprintf(&xephyr_screen, \"%dx%d\", n1, n2) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t}\n\t\n\t\t\t// xephyr window title\n\t\t\telse if (strncmp(ptr, \"xephyr-window-title \", 20) == 0) {\n\t\t\t\tif (strcmp(ptr + 20, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_XEPHYR_WINDOW_TITLE] = 1;\n\t\t\t\telse if (strcmp(ptr + 20, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_XEPHYR_WINDOW_TITLE] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t\t\n\t\t\t// Xephyr command extra parameters\n\t\t\telse if (strncmp(ptr, \"xephyr-extra-params \", 19) == 0) {\n\t\t\t\txephyr_extra_params = strdup(ptr + 19);\n\t\t\t\tif (!xephyr_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\t\t\t\n\t\t\t// quiet by default\n\t\t\telse if (strncmp(ptr, \"quiet-by-default \", 17) == 0) {\n\t\t\t\tif (strcmp(ptr + 17, \"yes\") == 0)\n\t\t\t\t\targ_quiet = 1;\n\t\t\t}\n\t\t\t// remount /proc and /sys\n\t\t\telse if (strncmp(ptr, \"remount-proc-sys \", 17) == 0) {\n\t\t\t\tif (strcmp(ptr + 17, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_REMOUNT_PROC_SYS] = 1;\n\t\t\t\telse if (strcmp(ptr + 17, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_REMOUNT_PROC_SYS] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\telse if (strncmp(ptr, \"overlayfs \", 10) == 0) {\n\t\t\t\tif (strcmp(ptr + 10, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_OVERLAYFS] = 1;\n\t\t\t\telse if (strcmp(ptr + 10, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_OVERLAYFS] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\telse if (strncmp(ptr, \"private-home \", 13) == 0) {\n\t\t\t\tif (strcmp(ptr + 13, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_PRIVATE_HOME] = 1;\n\t\t\t\telse if (strcmp(ptr + 13, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_PRIVATE_HOME] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\telse if (strncmp(ptr, \"chroot-desktop \", 15) == 0) {\n\t\t\t\tif (strcmp(ptr + 15, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_CHROOT_DESKTOP] = 1;\n\t\t\t\telse if (strcmp(ptr + 15, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_CHROOT_DESKTOP] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\telse if (strncmp(ptr, \"private-bin-no-local \", 21) == 0) {\n\t\t\t\tif (strcmp(ptr + 21, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_PRIVATE_BIN_NO_LOCAL] = 1;\n\t\t\t\telse if (strcmp(ptr + 21, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_PRIVATE_BIN_NO_LOCAL] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\telse\n\t\t\t\tgoto errout;\n\n\t\t\tfree(ptr);\n\t\t}\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t\tinitialized = 1;\n\t}\n\t\n\treturn cfg_val[val];\n\t\nerrout:\n\tfprintf(stderr, \"Error: invalid line %d in firejail configuration file\\n\", line );\n\texit(1);\n}",
          "includes": [
            "#include <linux/loop.h>",
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAX_READ 8192\t\t\t\t  // line buffer for profile files"
          ],
          "globals_used": [
            "static int initialized = 0;",
            "static int cfg_val[CFG_MAX];",
            "char *xephyr_screen = \"800x600\";",
            "char *xephyr_extra_params = \"\";",
            "char *netfilter_default = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/loop.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\n#define MAX_READ 8192\t\t\t\t  // line buffer for profile files\n\nstatic int initialized = 0;\nstatic int cfg_val[CFG_MAX];\nchar *xephyr_screen = \"800x600\";\nchar *xephyr_extra_params = \"\";\nchar *netfilter_default = NULL;\n\nint checkcfg(int val) {\n\tassert(val < CFG_MAX);\n\tint line = 0;\n\n\tif (!initialized) {\n\t\t// initialize defaults\n\t\tint i;\n\t\tfor (i = 0; i < CFG_MAX; i++)\n\t\t\tcfg_val[i] = 1; // most of them are enabled by default\n\t\tcfg_val[CFG_RESTRICTED_NETWORK] = 0; // disabled by default\n\t\tcfg_val[CFG_FORCE_NONEWPRIVS] = 0; // disabled by default\n\t\tcfg_val[CFG_PRIVATE_BIN_NO_LOCAL] = 0; // disabled by default\n\t\t\n\t\t// open configuration file\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"%s/firejail.config\", SYSCONFDIR) == -1)\n\t\t\terrExit(\"asprintf\");\n\n\t\tFILE *fp = fopen(fname, \"r\");\n\t\tif (!fp) {\n#ifdef HAVE_GLOBALCFG\t\t\t\n\t\t\tfprintf(stderr, \"Error: Firejail configuration file %s not found\\n\", fname);\n\t\t\texit(1);\n#else\n\t\t\tinitialized = 1;\n\t\t\treturn\tcfg_val[val];\n#endif\t\n\t\t}\n\t\t\n\t\t// if the file exists, it should be owned by root\n\t\tstruct stat s;\n\t\tif (stat(fname, &s) == -1)\n\t\t\terrExit(\"stat\");\n\t\tif (s.st_uid != 0) {\n\t\t\tfprintf(stderr, \"Error: configuration file should be owned by root\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\t// read configuration file\n\t\tchar buf[MAX_READ];\n\t\twhile (fgets(buf,MAX_READ, fp)) {\n\t\t\tline++;\n\t\t\tif (*buf == '#' || *buf == '\\n') \n\t\t\t\tcontinue;\n\n\t\t\t// parse line\t\t\t\t\n\t\t\tchar *ptr = line_remove_spaces(buf);\n\t\t\tif (!ptr)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\t// file transfer\t\n\t\t\tif (strncmp(ptr, \"file-transfer \", 14) == 0) {\n\t\t\t\tif (strcmp(ptr + 14, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_FILE_TRANSFER] = 1;\n\t\t\t\telse if (strcmp(ptr + 14, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_FILE_TRANSFER] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// x11\n\t\t\telse if (strncmp(ptr, \"x11 \", 4) == 0) {\n\t\t\t\tif (strcmp(ptr + 4, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_X11] = 1;\n\t\t\t\telse if (strcmp(ptr + 4, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_X11] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// bind\n\t\t\telse if (strncmp(ptr, \"bind \", 5) == 0) {\n\t\t\t\tif (strcmp(ptr + 5, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_BIND] = 1;\n\t\t\t\telse if (strcmp(ptr + 5, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_BIND] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// user namespace\n\t\t\telse if (strncmp(ptr, \"userns \", 7) == 0) {\n\t\t\t\tif (strcmp(ptr + 7, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_USERNS] = 1;\n\t\t\t\telse if (strcmp(ptr + 7, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_USERNS] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// chroot\n\t\t\telse if (strncmp(ptr, \"chroot \", 7) == 0) {\n\t\t\t\tif (strcmp(ptr + 7, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_CHROOT] = 1;\n\t\t\t\telse if (strcmp(ptr + 7, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_CHROOT] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// nonewprivs\n\t\t\telse if (strncmp(ptr, \"force-nonewprivs \", 17) == 0) {\n\t\t\t\tif (strcmp(ptr + 17, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_SECCOMP] = 1;\n\t\t\t\telse if (strcmp(ptr + 17, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_SECCOMP] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// seccomp\n\t\t\telse if (strncmp(ptr, \"seccomp \", 8) == 0) {\n\t\t\t\tif (strcmp(ptr + 8, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_SECCOMP] = 1;\n\t\t\t\telse if (strcmp(ptr + 8, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_SECCOMP] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// whitelist\n\t\t\telse if (strncmp(ptr, \"whitelist \", 10) == 0) {\n\t\t\t\tif (strcmp(ptr + 10, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_WHITELIST] = 1;\n\t\t\t\telse if (strcmp(ptr + 10, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_WHITELIST] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// network\n\t\t\telse if (strncmp(ptr, \"network \", 8) == 0) {\n\t\t\t\tif (strcmp(ptr + 8, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_NETWORK] = 1;\n\t\t\t\telse if (strcmp(ptr + 8, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_NETWORK] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// network\n\t\t\telse if (strncmp(ptr, \"restricted-network \", 19) == 0) {\n\t\t\t\tif (strcmp(ptr + 19, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_RESTRICTED_NETWORK] = 1;\n\t\t\t\telse if (strcmp(ptr + 19, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_RESTRICTED_NETWORK] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// netfilter\n\t\t\telse if (strncmp(ptr, \"netfilter-default \", 18) == 0) {\n\t\t\t\tchar *fname = ptr + 18;\n\t\t\t\twhile (*fname == ' ' || *fname == '\\t')\n\t\t\t\t\tptr++;\n\t\t\t\tchar *end = strchr(fname, ' ');\n\t\t\t\tif (end)\n\t\t\t\t\t*end = '\\0';\n\t\t\t\t\n\t\t\t\t// is the file present?\n\t\t\t\tstruct stat s;\n\t\t\t\tif (stat(fname, &s) == -1) {\n\t\t\t\t\tfprintf(stderr, \"Error: netfilter-default file %s not available\\n\", fname);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tnetfilter_default = strdup(fname);\n\t\t\t\tif (!netfilter_default)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t\tif (arg_debug)\n\t\t\t\t\tprintf(\"netfilter default file %s\\n\", fname);\n\t\t\t}\n\t\t\t\n\t\t\t// Xephyr screen size\n\t\t\telse if (strncmp(ptr, \"xephyr-screen \", 14) == 0) {\n\t\t\t\t// expecting two numbers and an x between them\n\t\t\t\tint n1;\n\t\t\t\tint n2;\n\t\t\t\tint rv = sscanf(ptr + 14, \"%dx%d\", &n1, &n2);\n\t\t\t\tif (rv != 2)\n\t\t\t\t\tgoto errout;\n\t\t\t\tif (asprintf(&xephyr_screen, \"%dx%d\", n1, n2) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t}\n\t\n\t\t\t// xephyr window title\n\t\t\telse if (strncmp(ptr, \"xephyr-window-title \", 20) == 0) {\n\t\t\t\tif (strcmp(ptr + 20, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_XEPHYR_WINDOW_TITLE] = 1;\n\t\t\t\telse if (strcmp(ptr + 20, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_XEPHYR_WINDOW_TITLE] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t\t\n\t\t\t// Xephyr command extra parameters\n\t\t\telse if (strncmp(ptr, \"xephyr-extra-params \", 19) == 0) {\n\t\t\t\txephyr_extra_params = strdup(ptr + 19);\n\t\t\t\tif (!xephyr_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\t\t\t\n\t\t\t// quiet by default\n\t\t\telse if (strncmp(ptr, \"quiet-by-default \", 17) == 0) {\n\t\t\t\tif (strcmp(ptr + 17, \"yes\") == 0)\n\t\t\t\t\targ_quiet = 1;\n\t\t\t}\n\t\t\t// remount /proc and /sys\n\t\t\telse if (strncmp(ptr, \"remount-proc-sys \", 17) == 0) {\n\t\t\t\tif (strcmp(ptr + 17, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_REMOUNT_PROC_SYS] = 1;\n\t\t\t\telse if (strcmp(ptr + 17, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_REMOUNT_PROC_SYS] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\telse if (strncmp(ptr, \"overlayfs \", 10) == 0) {\n\t\t\t\tif (strcmp(ptr + 10, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_OVERLAYFS] = 1;\n\t\t\t\telse if (strcmp(ptr + 10, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_OVERLAYFS] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\telse if (strncmp(ptr, \"private-home \", 13) == 0) {\n\t\t\t\tif (strcmp(ptr + 13, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_PRIVATE_HOME] = 1;\n\t\t\t\telse if (strcmp(ptr + 13, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_PRIVATE_HOME] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\telse if (strncmp(ptr, \"chroot-desktop \", 15) == 0) {\n\t\t\t\tif (strcmp(ptr + 15, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_CHROOT_DESKTOP] = 1;\n\t\t\t\telse if (strcmp(ptr + 15, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_CHROOT_DESKTOP] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\telse if (strncmp(ptr, \"private-bin-no-local \", 21) == 0) {\n\t\t\t\tif (strcmp(ptr + 21, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_PRIVATE_BIN_NO_LOCAL] = 1;\n\t\t\t\telse if (strcmp(ptr + 21, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_PRIVATE_BIN_NO_LOCAL] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\telse\n\t\t\t\tgoto errout;\n\n\t\t\tfree(ptr);\n\t\t}\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t\tinitialized = 1;\n\t}\n\t\n\treturn cfg_val[val];\n\t\nerrout:\n\tfprintf(stderr, \"Error: invalid line %d in firejail configuration file\\n\", line );\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_build_remount_mnt_dir",
          "args": [],
          "line": 1246
        },
        "resolved": true,
        "details": {
          "function_name": "fs_build_remount_mnt_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
          "lines": "120-123",
          "snippet": "static void fs_build_remount_mnt_dir(void) {\n\ttmpfs_mounted = 0;\n\tfs_build_mnt_dir();\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int tmpfs_mounted = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic int tmpfs_mounted = 0;\n\nstatic void fs_build_remount_mnt_dir(void) {\n\ttmpfs_mounted = 0;\n\tfs_build_mnt_dir();\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"chroot\""
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chroot",
          "args": [
            "rootdir"
          ],
          "line": 1243
        },
        "resolved": true,
        "details": {
          "function_name": "fs_chroot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
          "lines": "1184-1268",
          "snippet": "void fs_chroot(const char *rootdir) {\n\tassert(rootdir);\n\t\n\tif (checkcfg(CFG_CHROOT_DESKTOP)) {\n\t\t// mount-bind a /dev in rootdir\n\t\tchar *newdev;\n\t\tif (asprintf(&newdev, \"%s/dev\", rootdir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting /dev on %s\\n\", newdev);\n\t\tif (mount(\"/dev\", newdev, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mounting /dev\");\n\t\tfree(newdev);\n\t\t\n\t\t// x11\n\t\tif (getenv(\"FIREJAIL_X11\")) {\n\t\t\tmask_x11_abstract_socket = 1;\n\t\t\tchar *newx11;\n\t\t\tif (asprintf(&newx11, \"%s/tmp/.X11-unix\", rootdir) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Mounting /tmp/.X11-unix on %s\\n\", newx11);\n\t\t\tif (mount(\"/tmp/.X11-unix\", newx11, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mounting /tmp/.X11-unix\");\n\t\t\tfree(newx11);\n\t\t}\n\t\t\n\t\t// some older distros don't have a /run directory\n\t\t// create one by default\n\t\t// no exit on error, let the user deal with any problems\n\t\tchar *rundir;\n\t\tif (asprintf(&rundir, \"%s/run\", rootdir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (!is_dir(rundir)) {\n\t\t\tint rv = mkdir(rundir, 0755);\n\t\t\t(void) rv;\n\t\t\trv = chown(rundir, 0, 0);\n\t\t\t(void) rv;\n\t\t}\n\t\t\n\t\t// copy /etc/resolv.conf in chroot directory\n\t\t// if resolv.conf in chroot is a symbolic link, this will fail\n\t\t// no exit on error, let the user deal with the problem\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"%s/etc/resolv.conf\", rootdir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Updating /etc/resolv.conf in %s\\n\", fname);\n\t\tif (is_link(fname)) {\n\t\t\tfprintf(stderr, \"Error: invalid %s file\\n\", fname);\n\t\t\texit(1);\n\t\t}\n\t\tif (copy_file(\"/etc/resolv.conf\", fname, 0, 0, 0644) == -1)\n\t\t\tfprintf(stderr, \"Warning: /etc/resolv.conf not initialized\\n\");\n\t}\n\t\n\t// chroot into the new directory\n\tif (arg_debug)\n\t\tprintf(\"Chrooting into %s\\n\", rootdir);\n\tif (chroot(rootdir) < 0)\n\t\terrExit(\"chroot\");\n\t// mount a new tmpfs in /run/firejail/mnt - the old one was lost in chroot\n\tfs_build_remount_mnt_dir();\n\t\t\n\tif (checkcfg(CFG_CHROOT_DESKTOP)) {\n\t\t// update /var directory in order to support multiple sandboxes running on the same root directory\n\t\tif (!arg_private_dev)\n\t\t\tfs_dev_shm();\n\t\tfs_var_lock();\n\t\tfs_var_tmp();\n\t\tfs_var_log();\n\t\tfs_var_lib();\n\t\tfs_var_cache();\n\t\tfs_var_utmp();\n\t\n\t\t// don't leak user information\n\t\trestrict_users();\n\t\n\t\t// when starting as root, firejail config is not disabled;\n\t\t// this mode could be used to install and test new software by chaining\n\t\t// firejail sandboxes (firejail --force)\n\t\tif (getuid() != 0)\n\t\t\tdisable_config();\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Chrooting into %s\\n\"",
            "rootdir"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: /etc/resolv.conf not initialized\\n\""
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_file",
          "args": [
            "\"/etc/resolv.conf\"",
            "fname",
            "0",
            "0",
            "0644"
          ],
          "line": 1236
        },
        "resolved": true,
        "details": {
          "function_name": "copy_file_as_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/util.c",
          "lines": "224-240",
          "snippet": "void copy_file_as_user(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode) {\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// drop privileges\n\t\tdrop_privs(0);\n\n\t\t// copy, set permissions and ownership\n\t\tint rv = copy_file(srcname, destname, uid, gid, mode);\n\t\tif (rv)\n\t\t\tfprintf(stderr, \"Warning: cannot transfer .Xauthority in private home directory\\n\");\n\t\t_exit(0);\n\t}\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid copy_file_as_user(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode) {\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// drop privileges\n\t\tdrop_privs(0);\n\n\t\t// copy, set permissions and ownership\n\t\tint rv = copy_file(srcname, destname, uid, gid, mode);\n\t\tif (rv)\n\t\t\tfprintf(stderr, \"Warning: cannot transfer .Xauthority in private home directory\\n\");\n\t\t_exit(0);\n\t}\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1234
        },
        "resolved": true,
        "details": {
          "function_name": "fs_rdonly_noexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
          "lines": "615-633",
          "snippet": "void fs_rdonly_noexit(const char *dir) {\n\tassert(dir);\n\t// check directory exists\n\tstruct stat s;\n\tint rv = stat(dir, &s);\n\tif (rv == 0) {\n\t\tint merr = 0;\n\t\t// mount --bind /bin /bin\n\t\tif (mount(dir, dir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\tmerr = 1;\n\t\t// mount --bind -o remount,ro /bin\n\t\tif (mount(NULL, dir, NULL, MS_BIND|MS_REMOUNT|MS_RDONLY|MS_REC, NULL) < 0)\n\t\t\tmerr = 1;\n\t\tif (merr)\n\t\t\tfprintf(stderr, \"Warning: cannot mount %s read-only\\n\", dir); \n\t\telse\n\t\t\tfs_logger2(\"read-only\", dir);\n\t}\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fs_rdwr(const char *dir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void fs_rdwr(const char *dir);\n\nvoid fs_rdonly_noexit(const char *dir) {\n\tassert(dir);\n\t// check directory exists\n\tstruct stat s;\n\tint rv = stat(dir, &s);\n\tif (rv == 0) {\n\t\tint merr = 0;\n\t\t// mount --bind /bin /bin\n\t\tif (mount(dir, dir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\tmerr = 1;\n\t\t// mount --bind -o remount,ro /bin\n\t\tif (mount(NULL, dir, NULL, MS_BIND|MS_REMOUNT|MS_RDONLY|MS_REC, NULL) < 0)\n\t\t\tmerr = 1;\n\t\tif (merr)\n\t\t\tfprintf(stderr, \"Warning: cannot mount %s read-only\\n\", dir); \n\t\telse\n\t\t\tfs_logger2(\"read-only\", dir);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid %s file\\n\"",
            "fname"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_link",
          "args": [
            "fname"
          ],
          "line": 1232
        },
        "resolved": true,
        "details": {
          "function_name": "is_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/util.c",
          "lines": "295-307",
          "snippet": "int is_link(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\tstruct stat s;\n\tif (lstat(fname, &s) == 0) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nint is_link(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\tstruct stat s;\n\tif (lstat(fname, &s) == 0) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Updating /etc/resolv.conf in %s\\n\"",
            "fname"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&fname",
            "\"%s/etc/resolv.conf\"",
            "rootdir"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chown",
          "args": [
            "rundir",
            "0",
            "0"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "rundir",
            "0755"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_dir",
          "args": [
            "rundir"
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "is_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/util.c",
          "lines": "264-291",
          "snippet": "int is_dir(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\t// if fname doesn't end in '/', add one\n\tint rv;\n\tstruct stat s;\n\tif (fname[strlen(fname) - 1] == '/')\n\t\trv = stat(fname, &s);\n\telse {\n\t\tchar *tmp;\n\t\tif (asprintf(&tmp, \"%s/\", fname) == -1) {\n\t\t\tfprintf(stderr, \"Error: cannot allocate memory, %s:%d\\n\", __FILE__, __LINE__);\n\t\t\terrExit(\"asprintf\");\n\t\t}\n\t\trv = stat(tmp, &s);\n\t\tfree(tmp);\n\t}\n\n\tif (rv == -1)\n\t\treturn 0;\n\n\tif (S_ISDIR(s.st_mode))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nint is_dir(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\t// if fname doesn't end in '/', add one\n\tint rv;\n\tstruct stat s;\n\tif (fname[strlen(fname) - 1] == '/')\n\t\trv = stat(fname, &s);\n\telse {\n\t\tchar *tmp;\n\t\tif (asprintf(&tmp, \"%s/\", fname) == -1) {\n\t\t\tfprintf(stderr, \"Error: cannot allocate memory, %s:%d\\n\", __FILE__, __LINE__);\n\t\t\terrExit(\"asprintf\");\n\t\t}\n\t\trv = stat(tmp, &s);\n\t\tfree(tmp);\n\t}\n\n\tif (rv == -1)\n\t\treturn 0;\n\n\tif (S_ISDIR(s.st_mode))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&rundir",
            "\"%s/run\"",
            "rootdir"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "newx11"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mounting /tmp/.X11-unix\""
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"/tmp/.X11-unix\"",
            "newx11",
            "NULL",
            "MS_BIND|MS_REC",
            "NULL"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Mounting /tmp/.X11-unix on %s\\n\"",
            "newx11"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&newx11",
            "\"%s/tmp/.X11-unix\"",
            "rootdir"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"FIREJAIL_X11\""
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "newdev"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mounting /dev\""
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"/dev\"",
            "newdev",
            "NULL",
            "MS_BIND|MS_REC",
            "NULL"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Mounting /dev on %s\\n\"",
            "newdev"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&newdev",
            "\"%s/dev\"",
            "rootdir"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "rootdir"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_chroot(const char *rootdir) {\n\tassert(rootdir);\n\t\n\tif (checkcfg(CFG_CHROOT_DESKTOP)) {\n\t\t// mount-bind a /dev in rootdir\n\t\tchar *newdev;\n\t\tif (asprintf(&newdev, \"%s/dev\", rootdir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting /dev on %s\\n\", newdev);\n\t\tif (mount(\"/dev\", newdev, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mounting /dev\");\n\t\tfree(newdev);\n\t\t\n\t\t// x11\n\t\tif (getenv(\"FIREJAIL_X11\")) {\n\t\t\tmask_x11_abstract_socket = 1;\n\t\t\tchar *newx11;\n\t\t\tif (asprintf(&newx11, \"%s/tmp/.X11-unix\", rootdir) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Mounting /tmp/.X11-unix on %s\\n\", newx11);\n\t\t\tif (mount(\"/tmp/.X11-unix\", newx11, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mounting /tmp/.X11-unix\");\n\t\t\tfree(newx11);\n\t\t}\n\t\t\n\t\t// some older distros don't have a /run directory\n\t\t// create one by default\n\t\t// no exit on error, let the user deal with any problems\n\t\tchar *rundir;\n\t\tif (asprintf(&rundir, \"%s/run\", rootdir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (!is_dir(rundir)) {\n\t\t\tint rv = mkdir(rundir, 0755);\n\t\t\t(void) rv;\n\t\t\trv = chown(rundir, 0, 0);\n\t\t\t(void) rv;\n\t\t}\n\t\t\n\t\t// copy /etc/resolv.conf in chroot directory\n\t\t// if resolv.conf in chroot is a symbolic link, this will fail\n\t\t// no exit on error, let the user deal with the problem\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"%s/etc/resolv.conf\", rootdir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Updating /etc/resolv.conf in %s\\n\", fname);\n\t\tif (is_link(fname)) {\n\t\t\tfprintf(stderr, \"Error: invalid %s file\\n\", fname);\n\t\t\texit(1);\n\t\t}\n\t\tif (copy_file(\"/etc/resolv.conf\", fname, 0, 0, 0644) == -1)\n\t\t\tfprintf(stderr, \"Warning: /etc/resolv.conf not initialized\\n\");\n\t}\n\t\n\t// chroot into the new directory\n\tif (arg_debug)\n\t\tprintf(\"Chrooting into %s\\n\", rootdir);\n\tif (chroot(rootdir) < 0)\n\t\terrExit(\"chroot\");\n\t// mount a new tmpfs in /run/firejail/mnt - the old one was lost in chroot\n\tfs_build_remount_mnt_dir();\n\t\t\n\tif (checkcfg(CFG_CHROOT_DESKTOP)) {\n\t\t// update /var directory in order to support multiple sandboxes running on the same root directory\n\t\tif (!arg_private_dev)\n\t\t\tfs_dev_shm();\n\t\tfs_var_lock();\n\t\tfs_var_tmp();\n\t\tfs_var_log();\n\t\tfs_var_lib();\n\t\tfs_var_cache();\n\t\tfs_var_utmp();\n\t\n\t\t// don't leak user information\n\t\trestrict_users();\n\t\n\t\t// when starting as root, firejail config is not disabled;\n\t\t// this mode could be used to install and test new software by chaining\n\t\t// firejail sandboxes (firejail --force)\n\t\tif (getuid() != 0)\n\t\t\tdisable_config();\n\t}\n}"
  },
  {
    "function_name": "fs_check_chroot_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
    "lines": "1106-1181",
    "snippet": "int fs_check_chroot_dir(const char *rootdir) {\n\tEUID_ASSERT();\n\tassert(rootdir);\n\tstruct stat s;\n\tchar *name;\n\n\t// rootdir has to be owned by root\n\tif (stat(rootdir, &s) != 0) {\n\t\tfprintf(stderr, \"Error: cannot find chroot directory\\n\");\n\t\treturn 1;\n\t}\n\tif (s.st_uid != 0) {\n\t\tfprintf(stderr, \"Error: chroot directory should be owned by root\\n\");\n\t\treturn 1;\n\t}\n\n\t// check /dev\n\tif (asprintf(&name, \"%s/dev\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (stat(name, &s) == -1) {\n\t\tfprintf(stderr, \"Error: cannot find /dev in chroot directory\\n\");\n\t\treturn 1;\n\t}\n\tfree(name);\n\n\t// check /var/tmp\n\tif (asprintf(&name, \"%s/var/tmp\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (stat(name, &s) == -1) {\n\t\tfprintf(stderr, \"Error: cannot find /var/tmp in chroot directory\\n\");\n\t\treturn 1;\n\t}\n\tfree(name);\n\t\n\t// check /proc\n\tif (asprintf(&name, \"%s/proc\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (stat(name, &s) == -1) {\n\t\tfprintf(stderr, \"Error: cannot find /proc in chroot directory\\n\");\n\t\treturn 1;\n\t}\n\tfree(name);\n\t\n\t// check /tmp\n\tif (asprintf(&name, \"%s/tmp\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (stat(name, &s) == -1) {\n\t\tfprintf(stderr, \"Error: cannot find /tmp in chroot directory\\n\");\n\t\treturn 1;\n\t}\n\tfree(name);\n\n\t// check /bin/bash\n//\tif (asprintf(&name, \"%s/bin/bash\", rootdir) == -1)\n//\t\terrExit(\"asprintf\");\n//\tif (stat(name, &s) == -1) {\n//\t\tfprintf(stderr, \"Error: cannot find /bin/bash in chroot directory\\n\");\n//\t\treturn 1;\n//\t}\n//\tfree(name);\n\n\t// check x11 socket directory\n\tif (getenv(\"FIREJAIL_X11\")) {\n\t\tmask_x11_abstract_socket = 1;\n\t\tchar *name;\n\t\tif (asprintf(&name, \"%s/tmp/.X11-unix\", rootdir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (stat(name, &s) == -1) {\n\t\t\tfprintf(stderr, \"Error: cannot find /tmp/.X11-unix in chroot directory\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tfree(name);\n\t}\n\t\n\treturn 0;\t\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "name"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot find /tmp/.X11-unix in chroot directory\\n\""
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "name",
            "&s"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&name",
            "\"%s/tmp/.X11-unix\"",
            "rootdir"
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"FIREJAIL_X11\""
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "name"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot find /tmp in chroot directory\\n\""
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "name",
            "&s"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&name",
            "\"%s/tmp\"",
            "rootdir"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "name"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot find /proc in chroot directory\\n\""
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "name",
            "&s"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&name",
            "\"%s/proc\"",
            "rootdir"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "name"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot find /var/tmp in chroot directory\\n\""
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "name",
            "&s"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&name",
            "\"%s/var/tmp\"",
            "rootdir"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "name"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot find /dev in chroot directory\\n\""
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "name",
            "&s"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&name",
            "\"%s/dev\"",
            "rootdir"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: chroot directory should be owned by root\\n\""
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot find chroot directory\\n\""
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "rootdir",
            "&s"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "rootdir"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nint fs_check_chroot_dir(const char *rootdir) {\n\tEUID_ASSERT();\n\tassert(rootdir);\n\tstruct stat s;\n\tchar *name;\n\n\t// rootdir has to be owned by root\n\tif (stat(rootdir, &s) != 0) {\n\t\tfprintf(stderr, \"Error: cannot find chroot directory\\n\");\n\t\treturn 1;\n\t}\n\tif (s.st_uid != 0) {\n\t\tfprintf(stderr, \"Error: chroot directory should be owned by root\\n\");\n\t\treturn 1;\n\t}\n\n\t// check /dev\n\tif (asprintf(&name, \"%s/dev\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (stat(name, &s) == -1) {\n\t\tfprintf(stderr, \"Error: cannot find /dev in chroot directory\\n\");\n\t\treturn 1;\n\t}\n\tfree(name);\n\n\t// check /var/tmp\n\tif (asprintf(&name, \"%s/var/tmp\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (stat(name, &s) == -1) {\n\t\tfprintf(stderr, \"Error: cannot find /var/tmp in chroot directory\\n\");\n\t\treturn 1;\n\t}\n\tfree(name);\n\t\n\t// check /proc\n\tif (asprintf(&name, \"%s/proc\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (stat(name, &s) == -1) {\n\t\tfprintf(stderr, \"Error: cannot find /proc in chroot directory\\n\");\n\t\treturn 1;\n\t}\n\tfree(name);\n\t\n\t// check /tmp\n\tif (asprintf(&name, \"%s/tmp\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (stat(name, &s) == -1) {\n\t\tfprintf(stderr, \"Error: cannot find /tmp in chroot directory\\n\");\n\t\treturn 1;\n\t}\n\tfree(name);\n\n\t// check /bin/bash\n//\tif (asprintf(&name, \"%s/bin/bash\", rootdir) == -1)\n//\t\terrExit(\"asprintf\");\n//\tif (stat(name, &s) == -1) {\n//\t\tfprintf(stderr, \"Error: cannot find /bin/bash in chroot directory\\n\");\n//\t\treturn 1;\n//\t}\n//\tfree(name);\n\n\t// check x11 socket directory\n\tif (getenv(\"FIREJAIL_X11\")) {\n\t\tmask_x11_abstract_socket = 1;\n\t\tchar *name;\n\t\tif (asprintf(&name, \"%s/tmp/.X11-unix\", rootdir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (stat(name, &s) == -1) {\n\t\t\tfprintf(stderr, \"Error: cannot find /tmp/.X11-unix in chroot directory\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tfree(name);\n\t}\n\t\n\treturn 0;\t\n}"
  },
  {
    "function_name": "fs_overlayfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
    "lines": "862-1100",
    "snippet": "void fs_overlayfs(void) {\n\t// check kernel version\n\tstruct utsname u;\n\tint rv = uname(&u);\n\tif (rv != 0)\n\t\terrExit(\"uname\");\n\tint major;\n\tint minor;\n\tif (2 != sscanf(u.release, \"%d.%d\", &major, &minor)) {\n\t\tfprintf(stderr, \"Error: cannot extract Linux kernel version: %s\\n\", u.version);\n\t\texit(1);\n\t}\n\t\n\tif (arg_debug)\n\t\tprintf(\"Linux kernel version %d.%d\\n\", major, minor);\n\tint oldkernel = 0;\n\tif (major < 3) {\n\t\tfprintf(stderr, \"Error: minimum kernel version required 3.x\\n\");\n\t\texit(1);\n\t}\n\tif (major == 3 && minor < 18)\n\t\toldkernel = 1;\n\t\n\t// build overlay directories\n\tfs_build_mnt_dir();\n\n\tchar *oroot;\n\tif(asprintf(&oroot, \"%s/oroot\", RUN_MNT_DIR) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mkdir(oroot, 0755))\n\t\terrExit(\"mkdir\");\n\tif (chmod(oroot, 0755) == -1)\n\t\terrExit(\"chmod\");\n\tASSERT_PERMS(oroot, 0, 0, 0755);\n\n\tstruct stat s;\n\tchar *basedir = RUN_MNT_DIR;\n\tif (arg_overlay_keep) {\n\t\t// set base for working and diff directories\n\t\tbasedir = cfg.overlay_dir;\n\n\t\t// does the overlay exist?\n\t\tif (stat(basedir, &s) == 0) {\n\t\t\tif (arg_overlay_reuse == 0) {\n\t\t\t\tfprintf(stderr, \"Error: overlay directory exists, but reuse is not allowed\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (mkdir(basedir, 0755) != 0) {\n\t\t\t\tfprintf(stderr, \"Error: cannot create overlay directory\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t}\n\n\tchar *odiff;\n\tif(asprintf(&odiff, \"%s/odiff\", basedir) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// no need to check arg_overlay_reuse\n\tif (stat(odiff, &s) != 0) {\n\t\tif (mkdir(odiff, 0755))\n\t\t\terrExit(\"mkdir\");\n\t}\n\n\tif (chown(odiff, 0, 0) < 0)\n\t\terrExit(\"chown\");\n\tif (chmod(odiff, 0755) < 0)\n\t\terrExit(\"chmod\");\n\t\n\tchar *owork;\n\tif(asprintf(&owork, \"%s/owork\", basedir) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// no need to check arg_overlay_reuse\n\tif (stat(owork, &s) != 0) {\n\t\tif (mkdir(owork, 0755))\n\t\t\terrExit(\"mkdir\");\n\t}\n\n\tif (chown(owork, 0, 0) < 0)\n\t\terrExit(\"chown\");\n\tif (chmod(owork, 0755) < 0)\n\t\terrExit(\"chmod\");\n\t\n\t// mount overlayfs\n\tif (arg_debug)\n\t\tprintf(\"Mounting OverlayFS\\n\");\n\tchar *option;\n\tif (oldkernel) { // old Ubuntu/OpenSUSE kernels\n\t\tif (arg_overlay_keep) {\n\t\t\tfprintf(stderr, \"Error: option --overlay= not available for kernels older than 3.18\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (asprintf(&option, \"lowerdir=/,upperdir=%s\", odiff) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (mount(\"overlayfs\", oroot, \"overlayfs\", MS_MGC_VAL, option) < 0)\n\t\t\terrExit(\"mounting overlayfs\");\n\t}\n\telse { // kernel 3.18 or newer\n\t\tif (asprintf(&option, \"lowerdir=/,upperdir=%s,workdir=%s\", odiff, owork) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (mount(\"overlay\", oroot, \"overlay\", MS_MGC_VAL, option) < 0)\n\t\t\terrExit(\"mounting overlayfs\");\n\t\t\t\n\t\t//***************************\n\t\t// issue #263 start code\n\t\t// My setup has a separate mount point for /home. When the overlay is mounted,\n\t\t// the overlay does not contain the original /home contents. \n\t\t// I added code to create a second overlay for /home if the overlay home dir is empty and this seems to work\n\t\t// @dshmgh, Jan 2016\n\t\t{\n\t\t\tchar *overlayhome;\n\t\t\tstruct stat s;\n\t\t\tchar *hroot;\n\t\t\tchar *hdiff;\n\t\t\tchar *hwork;\n\t\t\n\t\t\t// dons add debug\n\t\t\tif (arg_debug) printf (\"DEBUG: chroot dirs are oroot %s  odiff %s  owork %s\\n\",oroot,odiff,owork);\n\t\t\n\t\t\t// BEFORE NEXT, WE NEED TO TEST IF /home has any contents or do we need to mount it?\n\t\t\t// must create var for oroot/cfg.homedir\n\t\t\tif (asprintf(&overlayhome,\"%s%s\",oroot,cfg.homedir) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tif (arg_debug) printf (\"DEBUG: overlayhome var holds ##%s##\\n\",overlayhome);\n\t\t\n\t\t\t// if no homedir in overlay -- create another overlay for /home\n\t\t\tif (stat(overlayhome, &s) == -1) {\n\t\t\n\t\t\t\tif(asprintf(&hroot, \"%s/oroot/home\", RUN_MNT_DIR) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\n\t\t\t\tif(asprintf(&hdiff, \"%s/hdiff\", basedir) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\n\t\t\t\t// no need to check arg_overlay_reuse\n\t\t\t\tif (stat(hdiff, &s) != 0) {\n\t\t\t\t\tif (mkdir(hdiff, S_IRWXU | S_IRWXG | S_IRWXO))\n\t\t\t\t\t\terrExit(\"mkdir\");\n\t\t\t\t}\n\n\t\t\t\tif (chown(hdiff, 0, 0) < 0)\n\t\t\t\t\terrExit(\"chown\");\n\t\t\t\tif (chmod(hdiff, S_IRWXU  | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH) < 0)\n\t\t\t\t\terrExit(\"chmod\");\n\t\t\n\t\t\t\tif(asprintf(&hwork, \"%s/hwork\", basedir) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\n\t\t\t\t// no need to check arg_overlay_reuse\n\t\t\t\tif (stat(hwork, &s) != 0) {\n\t\t\t\t\tif (mkdir(hwork, S_IRWXU | S_IRWXG | S_IRWXO))\n\t\t\t\t\t\terrExit(\"mkdir\");\n\t\t\t\t}\n\n\t\t\t\tif (chown(hwork, 0, 0) < 0)\n\t\t\t\t\terrExit(\"chown\");\n\t\t\t\tif (chmod(hwork, S_IRWXU  | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH) < 0)\n\t\t\t\t\terrExit(\"chmod\");\n\t\t\n\t\t\t\t// no homedir in overlay so now mount another overlay for /home\n\t\t\t\tif (asprintf(&option, \"lowerdir=/home,upperdir=%s,workdir=%s\", hdiff, hwork) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\tif (mount(\"overlay\", hroot, \"overlay\", MS_MGC_VAL, option) < 0)\n\t\t\t\t\terrExit(\"mounting overlayfs for mounted home directory\");\n\t\t\n\t\t\t\tprintf(\"OverlayFS for /home configured in %s directory\\n\", basedir);\n\t\t\t} // stat(overlayhome)\n\t\t\tfree(overlayhome);\n\t\t}\n\t\t// issue #263 end code\n\t\t//***************************\n\t}\n\tprintf(\"OverlayFS configured in %s directory\\n\", basedir);\n\t\n\t// mount-bind dev directory\n\tif (arg_debug)\n\t\tprintf(\"Mounting /dev\\n\");\n\tchar *dev;\n\tif (asprintf(&dev, \"%s/dev\", oroot) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(\"/dev\", dev, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /dev\");\n\tfs_logger(\"whitelist /dev\");\n\n\t// mount-bind run directory\n\tif (arg_debug)\n\t\tprintf(\"Mounting /run\\n\");\n\tchar *run;\n\tif (asprintf(&run, \"%s/run\", oroot) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(\"/run\", run, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /run\");\n\tfs_logger(\"whitelist /run\");\n\n\t// mount-bind /tmp/.X11-unix directory\n\tif (stat(\"/tmp/.X11-unix\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting /tmp/.X11-unix\\n\");\n\t\tchar *x11;\n\t\tif (asprintf(&x11, \"%s/tmp/.X11-unix\", oroot) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (mount(\"/tmp/.X11-unix\", x11, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\tfprintf(stderr, \"Warning: cannot mount /tmp/.X11-unix in overlay\\n\");\n\t\telse\n\t\t\tfs_logger(\"whitelist /tmp/.X11-unix\");\n\t\tfree(x11);\n\t}\n\n\t// chroot in the new filesystem\n\tif (chroot(oroot) == -1)\n\t\terrExit(\"chroot\");\n\n\t// update /var directory in order to support multiple sandboxes running on the same root directory\n\tif (!arg_private_dev)\n\t\tfs_dev_shm();\n\tfs_var_lock();\n\tfs_var_tmp();\n\tfs_var_log();\n\tfs_var_lib();\n\tfs_var_cache();\n\tfs_var_utmp();\n\n\t// don't leak user information\n\trestrict_users();\n\n\t// when starting as root, firejail config is not disabled;\n\t// this mode could be used to install and test new software by chaining\n\t// firejail sandboxes (firejail --force)\n\tif (getuid() != 0)\n\t\tdisable_config();\n\n\t// cleanup and exit\n\tfree(option);\n\tfree(oroot);\n\tfree(odiff);\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void fs_rdwr(const char *dir);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "odiff"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "oroot"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "option"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disable_config",
          "args": [],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "disable_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
          "lines": "721-740",
          "snippet": "static void disable_config(void) {\n\tstruct stat s;\n\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/.config/firejail\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (stat(fname, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, fname);\n\tfree(fname);\n\t\n\t// disable run time information\n\tif (stat(RUN_FIREJAIL_NETWORK_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_NETWORK_DIR);\n\tif (stat(RUN_FIREJAIL_BANDWIDTH_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_BANDWIDTH_DIR);\n\tif (stat(RUN_FIREJAIL_NAME_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_NAME_DIR);\n\tif (stat(RUN_FIREJAIL_X11_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_X11_DIR);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void disable_config(void) {\n\tstruct stat s;\n\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/.config/firejail\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (stat(fname, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, fname);\n\tfree(fname);\n\t\n\t// disable run time information\n\tif (stat(RUN_FIREJAIL_NETWORK_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_NETWORK_DIR);\n\tif (stat(RUN_FIREJAIL_BANDWIDTH_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_BANDWIDTH_DIR);\n\tif (stat(RUN_FIREJAIL_NAME_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_NAME_DIR);\n\tif (stat(RUN_FIREJAIL_X11_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_X11_DIR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "restrict_users",
          "args": [],
          "line": 1088
        },
        "resolved": true,
        "details": {
          "function_name": "restrict_users",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/restrict_users.c",
          "lines": "337-357",
          "snippet": "void restrict_users(void) {\n\tif (arg_allusers)\n\t\treturn;\n\t\t\n\t// only in user mode\n\tif (getuid()) {\n\t\tif (strncmp(cfg.homedir, \"/home/\", 6) == 0) {\n\t\t\t// user has the home directory under /home\n\t\t\tsanitize_home();\n\t\t}\n\t\telse {\n\t\t\t// user has the home directory outside /home\n\t\t\t// mount tmpfs on top of /home in order to hide it\n\t\t\tif (mount(\"tmpfs\", \"/home\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\t\terrExit(\"mount tmpfs\");\n\t\t\tfs_logger(\"tmpfs /home\");\n\t\t}\n\t\tsanitize_passwd();\n\t\tsanitize_group();\n\t}\n}",
          "includes": [
            "#include \"../../uids.h\"",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../uids.h\"\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid restrict_users(void) {\n\tif (arg_allusers)\n\t\treturn;\n\t\t\n\t// only in user mode\n\tif (getuid()) {\n\t\tif (strncmp(cfg.homedir, \"/home/\", 6) == 0) {\n\t\t\t// user has the home directory under /home\n\t\t\tsanitize_home();\n\t\t}\n\t\telse {\n\t\t\t// user has the home directory outside /home\n\t\t\t// mount tmpfs on top of /home in order to hide it\n\t\t\tif (mount(\"tmpfs\", \"/home\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\t\terrExit(\"mount tmpfs\");\n\t\t\tfs_logger(\"tmpfs /home\");\n\t\t}\n\t\tsanitize_passwd();\n\t\tsanitize_group();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_var_utmp",
          "args": [],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "fs_var_utmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_var.c",
          "lines": "308-355",
          "snippet": "void fs_var_utmp(void) {\n\tstruct stat s;\n\n\t// extract utmp group id\n\tgid_t utmp_group = 0;\n\tif (stat(UTMP_FILE, &s) == 0)\n\t\tutmp_group = s.st_gid;\n\telse {\n\t\tfprintf(stderr, \"Warning: cannot find /var/run/utmp\\n\");\n\t\treturn;\n\t}\n\n\t// create /run/firejail/mnt directory\n\tfs_build_mnt_dir();\n\t\n\t// create a new utmp file\n\tif (arg_debug)\n\t\tprintf(\"Create the new utmp file\\n\");\n\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(RUN_UTMP_FILE, \"w\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\t\t\n\t// read current utmp\n\tstruct utmp *u;\n\tstruct utmp u_boot;\n\tsetutent();\n\twhile ((u = getutent()) != NULL) {\n\t\tif (u->ut_type == BOOT_TIME) {\n\t\t\tmemcpy(&u_boot, u, sizeof(u_boot));\n\t\t\tu_boot.ut_tv.tv_sec = (unsigned) time(NULL);\n\t\t}\n\t}\n\tendutent();\n\t\t\t\n\t// save new utmp file\n\tfwrite(&u_boot, sizeof(u_boot), 1, fp);\n\tSET_PERMS_STREAM(fp, 0, utmp_group, S_IRUSR | S_IWRITE | S_IRGRP | S_IWGRP | S_IROTH);\n\tfclose(fp);\n\t\n\t// mount the new utmp file\n\tif (arg_debug)\n\t\tprintf(\"Mount the new utmp file\\n\");\n\tif (mount(RUN_UTMP_FILE, UTMP_FILE, NULL, MS_BIND|MS_NOSUID|MS_NOEXEC | MS_NODEV | MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind utmp\");\n\tfs_logger(\"create /var/run/utmp\");\n}",
          "includes": [
            "#include <time.h>",
            "#include <utmp.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <utmp.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_var_utmp(void) {\n\tstruct stat s;\n\n\t// extract utmp group id\n\tgid_t utmp_group = 0;\n\tif (stat(UTMP_FILE, &s) == 0)\n\t\tutmp_group = s.st_gid;\n\telse {\n\t\tfprintf(stderr, \"Warning: cannot find /var/run/utmp\\n\");\n\t\treturn;\n\t}\n\n\t// create /run/firejail/mnt directory\n\tfs_build_mnt_dir();\n\t\n\t// create a new utmp file\n\tif (arg_debug)\n\t\tprintf(\"Create the new utmp file\\n\");\n\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(RUN_UTMP_FILE, \"w\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\t\t\n\t// read current utmp\n\tstruct utmp *u;\n\tstruct utmp u_boot;\n\tsetutent();\n\twhile ((u = getutent()) != NULL) {\n\t\tif (u->ut_type == BOOT_TIME) {\n\t\t\tmemcpy(&u_boot, u, sizeof(u_boot));\n\t\t\tu_boot.ut_tv.tv_sec = (unsigned) time(NULL);\n\t\t}\n\t}\n\tendutent();\n\t\t\t\n\t// save new utmp file\n\tfwrite(&u_boot, sizeof(u_boot), 1, fp);\n\tSET_PERMS_STREAM(fp, 0, utmp_group, S_IRUSR | S_IWRITE | S_IRGRP | S_IWGRP | S_IROTH);\n\tfclose(fp);\n\t\n\t// mount the new utmp file\n\tif (arg_debug)\n\t\tprintf(\"Mount the new utmp file\\n\");\n\tif (mount(RUN_UTMP_FILE, UTMP_FILE, NULL, MS_BIND|MS_NOSUID|MS_NOEXEC | MS_NODEV | MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind utmp\");\n\tfs_logger(\"create /var/run/utmp\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_var_cache",
          "args": [],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "fs_var_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_var.c",
          "lines": "200-240",
          "snippet": "void fs_var_cache(void) {\n\tstruct stat s;\n\n\tif (stat(\"/var/cache/apache2\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/cache/apache2\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/cache/apache2\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/cache/apache2\");\n\t\tfs_logger(\"tmpfs /var/cache/apache2\");\n\t}\t\t\t\n\n\tif (stat(\"/var/cache/lighttpd\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/cache/lighttpd\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/cache/lighttpd\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/cache/lighttpd\");\n\t\tfs_logger(\"tmpfs /var/cache/lighttpd\");\n\n\t\tstruct passwd *p = getpwnam(\"www-data\");\n\t\tuid_t uid = 0;\n\t\tgid_t gid = 0;\n\t\tif (p) {\n\t\t\tuid = p->pw_uid;\n\t\t\tgid = p->pw_gid;\n\t\t}\n\t\t\n\t\tint rv = mkdir(\"/var/cache/lighttpd/compress\", 0755);\n\t\tif (rv == -1)\n\t\t\terrExit(\"mkdir\");\n\t\tif (chown(\"/var/cache/lighttpd/compress\", uid, gid) < 0)\n\t\t\terrExit(\"chown\");\n\t\tfs_logger(\"mkdir /var/cache/lighttpd/compress\");\n\n\t\trv = mkdir(\"/var/cache/lighttpd/uploads\", 0755);\n\t\tif (rv == -1)\n\t\t\terrExit(\"mkdir\");\n\t\tif (chown(\"/var/cache/lighttpd/uploads\", uid, gid) < 0)\n\t\t\terrExit(\"chown\");\n\t\tfs_logger(\"/var/cache/lighttpd/uploads\");\n\t}\t\t\t\n}",
          "includes": [
            "#include <time.h>",
            "#include <utmp.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <utmp.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_var_cache(void) {\n\tstruct stat s;\n\n\tif (stat(\"/var/cache/apache2\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/cache/apache2\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/cache/apache2\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/cache/apache2\");\n\t\tfs_logger(\"tmpfs /var/cache/apache2\");\n\t}\t\t\t\n\n\tif (stat(\"/var/cache/lighttpd\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/cache/lighttpd\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/cache/lighttpd\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/cache/lighttpd\");\n\t\tfs_logger(\"tmpfs /var/cache/lighttpd\");\n\n\t\tstruct passwd *p = getpwnam(\"www-data\");\n\t\tuid_t uid = 0;\n\t\tgid_t gid = 0;\n\t\tif (p) {\n\t\t\tuid = p->pw_uid;\n\t\t\tgid = p->pw_gid;\n\t\t}\n\t\t\n\t\tint rv = mkdir(\"/var/cache/lighttpd/compress\", 0755);\n\t\tif (rv == -1)\n\t\t\terrExit(\"mkdir\");\n\t\tif (chown(\"/var/cache/lighttpd/compress\", uid, gid) < 0)\n\t\t\terrExit(\"chown\");\n\t\tfs_logger(\"mkdir /var/cache/lighttpd/compress\");\n\n\t\trv = mkdir(\"/var/cache/lighttpd/uploads\", 0755);\n\t\tif (rv == -1)\n\t\t\terrExit(\"mkdir\");\n\t\tif (chown(\"/var/cache/lighttpd/uploads\", uid, gid) < 0)\n\t\t\terrExit(\"chown\");\n\t\tfs_logger(\"/var/cache/lighttpd/uploads\");\n\t}\t\t\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_var_lib",
          "args": [],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "fs_var_lib",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_var.c",
          "lines": "150-198",
          "snippet": "void fs_var_lib(void) {\n\tstruct stat s;\n\t\n\t// ISC DHCP multiserver\n\tif (stat(\"/var/lib/dhcp\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lib/dhcp\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lib/dhcp\", \"tmpfs\", MS_NOSUID |  MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/lib/dhcp\");\n\t\tfs_logger(\"tmpfs /var/lib/dhcp\");\n\t\t\t\n\t\t// isc dhcp server requires a /var/lib/dhcp/dhcpd.leases file\n\t\tFILE *fp = fopen(\"/var/lib/dhcp/dhcpd.leases\", \"w\");\n\t\t\n\t\tif (fp) {\n\t\t\tfprintf(fp, \"\\n\");\n\t\t\tSET_PERMS_STREAM(fp, 0, 0, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);\n\t\t\tfclose(fp);\n\t\t\tfs_logger(\"touch /var/lib/dhcp/dhcpd.leases\");\n\t\t}\n\t}\n\n\t// nginx multiserver\n\tif (stat(\"/var/lib/nginx\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lib/nginx\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lib/nginx\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/lib/nginx\");\n\t\tfs_logger(\"tmpfs /var/lib/nginx\");\n\t}\t\t\t\n\n\t// net-snmp multiserver\n\tif (stat(\"/var/lib/snmp\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lib/snmp\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lib/snmp\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/lib/snmp\");\n\t\tfs_logger(\"tmpfs /var/lib/snmp\");\n\t}\t\t\t\n\n\t// this is where sudo remembers its state\n\tif (stat(\"/var/lib/sudo\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lib/sudo\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lib/sudo\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/lib/sudo\");\n\t\tfs_logger(\"tmpfs /var/lib/sudo\");\n\t}\t\t\t\n}",
          "includes": [
            "#include <time.h>",
            "#include <utmp.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <utmp.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_var_lib(void) {\n\tstruct stat s;\n\t\n\t// ISC DHCP multiserver\n\tif (stat(\"/var/lib/dhcp\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lib/dhcp\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lib/dhcp\", \"tmpfs\", MS_NOSUID |  MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/lib/dhcp\");\n\t\tfs_logger(\"tmpfs /var/lib/dhcp\");\n\t\t\t\n\t\t// isc dhcp server requires a /var/lib/dhcp/dhcpd.leases file\n\t\tFILE *fp = fopen(\"/var/lib/dhcp/dhcpd.leases\", \"w\");\n\t\t\n\t\tif (fp) {\n\t\t\tfprintf(fp, \"\\n\");\n\t\t\tSET_PERMS_STREAM(fp, 0, 0, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);\n\t\t\tfclose(fp);\n\t\t\tfs_logger(\"touch /var/lib/dhcp/dhcpd.leases\");\n\t\t}\n\t}\n\n\t// nginx multiserver\n\tif (stat(\"/var/lib/nginx\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lib/nginx\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lib/nginx\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/lib/nginx\");\n\t\tfs_logger(\"tmpfs /var/lib/nginx\");\n\t}\t\t\t\n\n\t// net-snmp multiserver\n\tif (stat(\"/var/lib/snmp\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lib/snmp\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lib/snmp\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/lib/snmp\");\n\t\tfs_logger(\"tmpfs /var/lib/snmp\");\n\t}\t\t\t\n\n\t// this is where sudo remembers its state\n\tif (stat(\"/var/lib/sudo\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lib/sudo\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lib/sudo\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/lib/sudo\");\n\t\tfs_logger(\"tmpfs /var/lib/sudo\");\n\t}\t\t\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_var_log",
          "args": [],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "fs_var_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_var.c",
          "lines": "110-148",
          "snippet": "void fs_var_log(void) {\n\tbuild_list(\"/var/log\");\n\t\n\t// create /var/log if it doesn't exit\n\tif (is_dir(\"/var/log\")) {\n\t\t// extract group id for /var/log/wtmp\n\t\tstruct stat s;\n\t\tgid_t wtmp_group = 0;\n\t\tif (stat(\"/var/log/wtmp\", &s) == 0)\n\t\t\twtmp_group = s.st_gid;\n\t\t\n\t\t// mount a tmpfs on top of /var/log\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/log\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/log\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/log\");\n\t\tfs_logger(\"tmpfs /var/log\");\n\t\t\n\t\tbuild_dirs();\n\t\trelease_all();\n\t\t\n\t\t// create an empty /var/log/wtmp file\n\t\t/* coverity[toctou] */\n\t\tFILE *fp = fopen(\"/var/log/wtmp\", \"w\");\n\t\tSET_PERMS_STREAM(fp, 0, wtmp_group, S_IRUSR | S_IWRITE | S_IRGRP | S_IWGRP | S_IROTH);\n\t\tif (fp)\n\t\t\tfclose(fp);\n\t\tfs_logger(\"touch /var/log/wtmp\");\n\t\t\t\n\t\t// create an empty /var/log/btmp file\n\t\tfp = fopen(\"/var/log/btmp\", \"w\");\n\t\tSET_PERMS_STREAM(fp, 0, wtmp_group, S_IRUSR | S_IWRITE | S_IRGRP | S_IWGRP);\n\t\tif (fp)\n\t\t\tfclose(fp);\n\t\tfs_logger(\"touch /var/log/btmp\");\n\t}\n\telse\n\t\tfprintf(stderr, \"Warning: cannot mount tmpfs on top of /var/log\\n\");\n}",
          "includes": [
            "#include <time.h>",
            "#include <utmp.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <utmp.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_var_log(void) {\n\tbuild_list(\"/var/log\");\n\t\n\t// create /var/log if it doesn't exit\n\tif (is_dir(\"/var/log\")) {\n\t\t// extract group id for /var/log/wtmp\n\t\tstruct stat s;\n\t\tgid_t wtmp_group = 0;\n\t\tif (stat(\"/var/log/wtmp\", &s) == 0)\n\t\t\twtmp_group = s.st_gid;\n\t\t\n\t\t// mount a tmpfs on top of /var/log\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/log\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/log\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/log\");\n\t\tfs_logger(\"tmpfs /var/log\");\n\t\t\n\t\tbuild_dirs();\n\t\trelease_all();\n\t\t\n\t\t// create an empty /var/log/wtmp file\n\t\t/* coverity[toctou] */\n\t\tFILE *fp = fopen(\"/var/log/wtmp\", \"w\");\n\t\tSET_PERMS_STREAM(fp, 0, wtmp_group, S_IRUSR | S_IWRITE | S_IRGRP | S_IWGRP | S_IROTH);\n\t\tif (fp)\n\t\t\tfclose(fp);\n\t\tfs_logger(\"touch /var/log/wtmp\");\n\t\t\t\n\t\t// create an empty /var/log/btmp file\n\t\tfp = fopen(\"/var/log/btmp\", \"w\");\n\t\tSET_PERMS_STREAM(fp, 0, wtmp_group, S_IRUSR | S_IWRITE | S_IRGRP | S_IWGRP);\n\t\tif (fp)\n\t\t\tfclose(fp);\n\t\tfs_logger(\"touch /var/log/btmp\");\n\t}\n\telse\n\t\tfprintf(stderr, \"Warning: cannot mount tmpfs on top of /var/log\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_var_tmp",
          "args": [],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "fs_var_tmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_var.c",
          "lines": "291-306",
          "snippet": "void fs_var_tmp(void) {\n\tstruct stat s;\n\tif (stat(\"/var/tmp\", &s) == 0) {\n\t\tif (!is_link(\"/var/tmp\")) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Mounting tmpfs on /var/tmp\\n\");\n\t\t\tif (mount(\"tmpfs\", \"/var/tmp\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=1777,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting /var/tmp\");\n\t\t\tfs_logger(\"tmpfs /var/tmp\");\n\t\t}\n\t}\n\telse {\n\t\tfprintf(stderr, \"Warning: /var/tmp not mounted\\n\");\n\t\tdbg_test_dir(\"/var/tmp\");\n\t}\n}",
          "includes": [
            "#include <time.h>",
            "#include <utmp.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <utmp.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_var_tmp(void) {\n\tstruct stat s;\n\tif (stat(\"/var/tmp\", &s) == 0) {\n\t\tif (!is_link(\"/var/tmp\")) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Mounting tmpfs on /var/tmp\\n\");\n\t\t\tif (mount(\"tmpfs\", \"/var/tmp\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=1777,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting /var/tmp\");\n\t\t\tfs_logger(\"tmpfs /var/tmp\");\n\t\t}\n\t}\n\telse {\n\t\tfprintf(stderr, \"Warning: /var/tmp not mounted\\n\");\n\t\tdbg_test_dir(\"/var/tmp\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_var_lock",
          "args": [],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "fs_var_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_var.c",
          "lines": "257-289",
          "snippet": "void fs_var_lock(void) {\n\n\tif (is_dir(\"/var/lock\")) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lock\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lock\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=1777,gid=0\") < 0)\n\t\t\terrExit(\"mounting /lock\");\n\t\tfs_logger(\"tmpfs /var/lock\");\n\t}\n\telse {\n\t\tchar *lnk = realpath(\"/var/lock\", NULL);\n\t\tif (lnk) {\n\t\t\tif (!is_dir(lnk)) {\n\t\t\t\t// create directory\n\t\t\t\tif (mkdir(lnk, S_IRWXU|S_IRWXG|S_IRWXO))\n\t\t\t\t\terrExit(\"mkdir\");\n\t\t\t\tif (chmod(lnk, S_IRWXU|S_IRWXG|S_IRWXO))\n\t\t\t\t\terrExit(\"chmod\");\n\t\t\t\tASSERT_PERMS(lnk, 0, 0, S_IRWXU|S_IRWXG|S_IRWXO);\n\t\t\t}\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Mounting tmpfs on %s on behalf of /var/lock\\n\", lnk);\n\t\t\tif (mount(\"tmpfs\", lnk, \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=1777,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting /var/lock\");\n\t\t\tfree(lnk);\n\t\t\tfs_logger(\"tmpfs /var/lock\");\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"Warning: /var/lock not mounted\\n\");\n\t\t\tdbg_test_dir(\"/var/lock\");\n\t\t}\n\t}\n}",
          "includes": [
            "#include <time.h>",
            "#include <utmp.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <utmp.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_var_lock(void) {\n\n\tif (is_dir(\"/var/lock\")) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lock\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lock\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=1777,gid=0\") < 0)\n\t\t\terrExit(\"mounting /lock\");\n\t\tfs_logger(\"tmpfs /var/lock\");\n\t}\n\telse {\n\t\tchar *lnk = realpath(\"/var/lock\", NULL);\n\t\tif (lnk) {\n\t\t\tif (!is_dir(lnk)) {\n\t\t\t\t// create directory\n\t\t\t\tif (mkdir(lnk, S_IRWXU|S_IRWXG|S_IRWXO))\n\t\t\t\t\terrExit(\"mkdir\");\n\t\t\t\tif (chmod(lnk, S_IRWXU|S_IRWXG|S_IRWXO))\n\t\t\t\t\terrExit(\"chmod\");\n\t\t\t\tASSERT_PERMS(lnk, 0, 0, S_IRWXU|S_IRWXG|S_IRWXO);\n\t\t\t}\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Mounting tmpfs on %s on behalf of /var/lock\\n\", lnk);\n\t\t\tif (mount(\"tmpfs\", lnk, \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=1777,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting /var/lock\");\n\t\t\tfree(lnk);\n\t\t\tfs_logger(\"tmpfs /var/lock\");\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"Warning: /var/lock not mounted\\n\");\n\t\t\tdbg_test_dir(\"/var/lock\");\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_dev_shm",
          "args": [],
          "line": 1079
        },
        "resolved": true,
        "details": {
          "function_name": "fs_dev_shm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_dev.c",
          "lines": "247-284",
          "snippet": "void fs_dev_shm(void) {\n\tuid_t uid = getuid(); // set a new shm only if we started as root\n\tif (uid)\n\t\treturn;\n\n\tif (is_dir(\"/dev/shm\")) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /dev/shm\\n\");\n\t\tif (mount(\"tmpfs\", \"/dev/shm\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME | MS_REC,  \"mode=1777,gid=0\") < 0)\n\t\t\terrExit(\"mounting /dev/shm\");\n\t\tfs_logger(\"tmpfs /dev/shm\");\n\t}\n\telse {\n\t\tchar *lnk = realpath(\"/dev/shm\", NULL);\n\t\tif (lnk) {\n\t\t\tif (!is_dir(lnk)) {\n\t\t\t\t// create directory\n\t\t\t\tif (mkdir(lnk, 01777))\n\t\t\t\t\terrExit(\"mkdir\");\n\t\t\t\t// mkdir sets only the file permission bits\n\t\t\t\tif (chmod(lnk, 01777))\n\t\t\t\t\terrExit(\"chmod\");\n\t\t\t\tASSERT_PERMS(lnk, 0, 0, 01777);\n\t\t\t}\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Mounting tmpfs on %s on behalf of /dev/shm\\n\", lnk);\n\t\t\tif (mount(\"tmpfs\", lnk, \"tmpfs\", MS_NOSUID | MS_STRICTATIME | MS_REC,  \"mode=1777,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting /var/tmp\");\n\t\t\tfs_logger2(\"tmpfs\", lnk);\n\t\t\tfree(lnk);\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"Warning: /dev/shm not mounted\\n\");\n\t\t\tdbg_test_dir(\"/dev/shm\");\n\t\t}\n\t\t\t\n\t}\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_dev_shm(void) {\n\tuid_t uid = getuid(); // set a new shm only if we started as root\n\tif (uid)\n\t\treturn;\n\n\tif (is_dir(\"/dev/shm\")) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /dev/shm\\n\");\n\t\tif (mount(\"tmpfs\", \"/dev/shm\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME | MS_REC,  \"mode=1777,gid=0\") < 0)\n\t\t\terrExit(\"mounting /dev/shm\");\n\t\tfs_logger(\"tmpfs /dev/shm\");\n\t}\n\telse {\n\t\tchar *lnk = realpath(\"/dev/shm\", NULL);\n\t\tif (lnk) {\n\t\t\tif (!is_dir(lnk)) {\n\t\t\t\t// create directory\n\t\t\t\tif (mkdir(lnk, 01777))\n\t\t\t\t\terrExit(\"mkdir\");\n\t\t\t\t// mkdir sets only the file permission bits\n\t\t\t\tif (chmod(lnk, 01777))\n\t\t\t\t\terrExit(\"chmod\");\n\t\t\t\tASSERT_PERMS(lnk, 0, 0, 01777);\n\t\t\t}\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Mounting tmpfs on %s on behalf of /dev/shm\\n\", lnk);\n\t\t\tif (mount(\"tmpfs\", lnk, \"tmpfs\", MS_NOSUID | MS_STRICTATIME | MS_REC,  \"mode=1777,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting /var/tmp\");\n\t\t\tfs_logger2(\"tmpfs\", lnk);\n\t\t\tfree(lnk);\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"Warning: /dev/shm not mounted\\n\");\n\t\t\tdbg_test_dir(\"/dev/shm\");\n\t\t}\n\t\t\t\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"chroot\""
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chroot",
          "args": [
            "oroot"
          ],
          "line": 1074
        },
        "resolved": true,
        "details": {
          "function_name": "fs_chroot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
          "lines": "1184-1268",
          "snippet": "void fs_chroot(const char *rootdir) {\n\tassert(rootdir);\n\t\n\tif (checkcfg(CFG_CHROOT_DESKTOP)) {\n\t\t// mount-bind a /dev in rootdir\n\t\tchar *newdev;\n\t\tif (asprintf(&newdev, \"%s/dev\", rootdir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting /dev on %s\\n\", newdev);\n\t\tif (mount(\"/dev\", newdev, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mounting /dev\");\n\t\tfree(newdev);\n\t\t\n\t\t// x11\n\t\tif (getenv(\"FIREJAIL_X11\")) {\n\t\t\tmask_x11_abstract_socket = 1;\n\t\t\tchar *newx11;\n\t\t\tif (asprintf(&newx11, \"%s/tmp/.X11-unix\", rootdir) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Mounting /tmp/.X11-unix on %s\\n\", newx11);\n\t\t\tif (mount(\"/tmp/.X11-unix\", newx11, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mounting /tmp/.X11-unix\");\n\t\t\tfree(newx11);\n\t\t}\n\t\t\n\t\t// some older distros don't have a /run directory\n\t\t// create one by default\n\t\t// no exit on error, let the user deal with any problems\n\t\tchar *rundir;\n\t\tif (asprintf(&rundir, \"%s/run\", rootdir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (!is_dir(rundir)) {\n\t\t\tint rv = mkdir(rundir, 0755);\n\t\t\t(void) rv;\n\t\t\trv = chown(rundir, 0, 0);\n\t\t\t(void) rv;\n\t\t}\n\t\t\n\t\t// copy /etc/resolv.conf in chroot directory\n\t\t// if resolv.conf in chroot is a symbolic link, this will fail\n\t\t// no exit on error, let the user deal with the problem\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"%s/etc/resolv.conf\", rootdir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Updating /etc/resolv.conf in %s\\n\", fname);\n\t\tif (is_link(fname)) {\n\t\t\tfprintf(stderr, \"Error: invalid %s file\\n\", fname);\n\t\t\texit(1);\n\t\t}\n\t\tif (copy_file(\"/etc/resolv.conf\", fname, 0, 0, 0644) == -1)\n\t\t\tfprintf(stderr, \"Warning: /etc/resolv.conf not initialized\\n\");\n\t}\n\t\n\t// chroot into the new directory\n\tif (arg_debug)\n\t\tprintf(\"Chrooting into %s\\n\", rootdir);\n\tif (chroot(rootdir) < 0)\n\t\terrExit(\"chroot\");\n\t// mount a new tmpfs in /run/firejail/mnt - the old one was lost in chroot\n\tfs_build_remount_mnt_dir();\n\t\t\n\tif (checkcfg(CFG_CHROOT_DESKTOP)) {\n\t\t// update /var directory in order to support multiple sandboxes running on the same root directory\n\t\tif (!arg_private_dev)\n\t\t\tfs_dev_shm();\n\t\tfs_var_lock();\n\t\tfs_var_tmp();\n\t\tfs_var_log();\n\t\tfs_var_lib();\n\t\tfs_var_cache();\n\t\tfs_var_utmp();\n\t\n\t\t// don't leak user information\n\t\trestrict_users();\n\t\n\t\t// when starting as root, firejail config is not disabled;\n\t\t// this mode could be used to install and test new software by chaining\n\t\t// firejail sandboxes (firejail --force)\n\t\tif (getuid() != 0)\n\t\t\tdisable_config();\n\t}\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_chroot(const char *rootdir) {\n\tassert(rootdir);\n\t\n\tif (checkcfg(CFG_CHROOT_DESKTOP)) {\n\t\t// mount-bind a /dev in rootdir\n\t\tchar *newdev;\n\t\tif (asprintf(&newdev, \"%s/dev\", rootdir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting /dev on %s\\n\", newdev);\n\t\tif (mount(\"/dev\", newdev, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mounting /dev\");\n\t\tfree(newdev);\n\t\t\n\t\t// x11\n\t\tif (getenv(\"FIREJAIL_X11\")) {\n\t\t\tmask_x11_abstract_socket = 1;\n\t\t\tchar *newx11;\n\t\t\tif (asprintf(&newx11, \"%s/tmp/.X11-unix\", rootdir) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Mounting /tmp/.X11-unix on %s\\n\", newx11);\n\t\t\tif (mount(\"/tmp/.X11-unix\", newx11, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mounting /tmp/.X11-unix\");\n\t\t\tfree(newx11);\n\t\t}\n\t\t\n\t\t// some older distros don't have a /run directory\n\t\t// create one by default\n\t\t// no exit on error, let the user deal with any problems\n\t\tchar *rundir;\n\t\tif (asprintf(&rundir, \"%s/run\", rootdir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (!is_dir(rundir)) {\n\t\t\tint rv = mkdir(rundir, 0755);\n\t\t\t(void) rv;\n\t\t\trv = chown(rundir, 0, 0);\n\t\t\t(void) rv;\n\t\t}\n\t\t\n\t\t// copy /etc/resolv.conf in chroot directory\n\t\t// if resolv.conf in chroot is a symbolic link, this will fail\n\t\t// no exit on error, let the user deal with the problem\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"%s/etc/resolv.conf\", rootdir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Updating /etc/resolv.conf in %s\\n\", fname);\n\t\tif (is_link(fname)) {\n\t\t\tfprintf(stderr, \"Error: invalid %s file\\n\", fname);\n\t\t\texit(1);\n\t\t}\n\t\tif (copy_file(\"/etc/resolv.conf\", fname, 0, 0, 0644) == -1)\n\t\t\tfprintf(stderr, \"Warning: /etc/resolv.conf not initialized\\n\");\n\t}\n\t\n\t// chroot into the new directory\n\tif (arg_debug)\n\t\tprintf(\"Chrooting into %s\\n\", rootdir);\n\tif (chroot(rootdir) < 0)\n\t\terrExit(\"chroot\");\n\t// mount a new tmpfs in /run/firejail/mnt - the old one was lost in chroot\n\tfs_build_remount_mnt_dir();\n\t\t\n\tif (checkcfg(CFG_CHROOT_DESKTOP)) {\n\t\t// update /var directory in order to support multiple sandboxes running on the same root directory\n\t\tif (!arg_private_dev)\n\t\t\tfs_dev_shm();\n\t\tfs_var_lock();\n\t\tfs_var_tmp();\n\t\tfs_var_log();\n\t\tfs_var_lib();\n\t\tfs_var_cache();\n\t\tfs_var_utmp();\n\t\n\t\t// don't leak user information\n\t\trestrict_users();\n\t\n\t\t// when starting as root, firejail config is not disabled;\n\t\t// this mode could be used to install and test new software by chaining\n\t\t// firejail sandboxes (firejail --force)\n\t\tif (getuid() != 0)\n\t\t\tdisable_config();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "x11"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_logger",
          "args": [
            "\"whitelist /tmp/.X11-unix\""
          ],
          "line": 1069
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger_print_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_logger.c",
          "lines": "136-189",
          "snippet": "void fs_logger_print_log(pid_t pid) {\n\tEUID_ASSERT();\n\n\t// if the pid is that of a firejail  process, use the pid of the first child process\n\tEUID_ROOT();\n\tchar *comm = pid_proc_comm(pid);\n\tEUID_USER();\n\tif (comm) {\n\t\tif (strcmp(comm, \"firejail\") == 0) {\n\t\t\tpid_t child;\n\t\t\tif (find_child(pid, &child) == 0) {\n\t\t\t\tpid = child;\n\t\t\t}\n\t\t}\n\t\tfree(comm);\n\t}\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission denied\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// print RUN_FSLOGGER_FILE\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_FSLOGGER_FILE) == -1)\n\t\terrExit(\"asprintf\");\n\n\tEUID_ROOT();\n\tstruct stat s;\n\tif (stat(fname, &s) == -1) {\n\t\tfprintf(stderr, \"Error: Cannot access filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: Cannot open filesystem log\\n\");\n\t\texit(1);\n\t}\n\t\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp))\n\t\tprintf(\"%s\", buf);\n\tfclose(fp);\n\tfree(fname);\n\n\texit(0);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAXBUF 4098"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\n#define MAXBUF 4098\n\nvoid fs_logger_print_log(pid_t pid) {\n\tEUID_ASSERT();\n\n\t// if the pid is that of a firejail  process, use the pid of the first child process\n\tEUID_ROOT();\n\tchar *comm = pid_proc_comm(pid);\n\tEUID_USER();\n\tif (comm) {\n\t\tif (strcmp(comm, \"firejail\") == 0) {\n\t\t\tpid_t child;\n\t\t\tif (find_child(pid, &child) == 0) {\n\t\t\t\tpid = child;\n\t\t\t}\n\t\t}\n\t\tfree(comm);\n\t}\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission denied\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// print RUN_FSLOGGER_FILE\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_FSLOGGER_FILE) == -1)\n\t\terrExit(\"asprintf\");\n\n\tEUID_ROOT();\n\tstruct stat s;\n\tif (stat(fname, &s) == -1) {\n\t\tfprintf(stderr, \"Error: Cannot access filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: Cannot open filesystem log\\n\");\n\t\texit(1);\n\t}\n\t\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp))\n\t\tprintf(\"%s\", buf);\n\tfclose(fp);\n\tfree(fname);\n\n\texit(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: cannot mount /tmp/.X11-unix in overlay\\n\""
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"/tmp/.X11-unix\"",
            "x11",
            "NULL",
            "MS_BIND|MS_REC",
            "NULL"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&x11",
            "\"%s/tmp/.X11-unix\"",
            "oroot"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Mounting /tmp/.X11-unix\\n\""
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "\"/tmp/.X11-unix\"",
            "&s"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mounting /run\""
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"/run\"",
            "run",
            "NULL",
            "MS_BIND|MS_REC",
            "NULL"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&run",
            "\"%s/run\"",
            "oroot"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Mounting /run\\n\""
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mounting /dev\""
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"/dev\"",
            "dev",
            "NULL",
            "MS_BIND|MS_REC",
            "NULL"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&dev",
            "\"%s/dev\"",
            "oroot"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Mounting /dev\\n\""
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"OverlayFS configured in %s directory\\n\"",
            "basedir"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "overlayhome"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"OverlayFS for /home configured in %s directory\\n\"",
            "basedir"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mounting overlayfs for mounted home directory\""
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"overlay\"",
            "hroot",
            "\"overlay\"",
            "MS_MGC_VAL",
            "option"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&option",
            "\"lowerdir=/home,upperdir=%s,workdir=%s\"",
            "hdiff",
            "hwork"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"chmod\""
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chmod",
          "args": [
            "hwork",
            "S_IRWXU  | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"chown\""
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chown",
          "args": [
            "hwork",
            "0",
            "0"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mkdir\""
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "hwork",
            "S_IRWXU | S_IRWXG | S_IRWXO"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "hwork",
            "&s"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&hwork",
            "\"%s/hwork\"",
            "basedir"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"chmod\""
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chmod",
          "args": [
            "hdiff",
            "S_IRWXU  | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"chown\""
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chown",
          "args": [
            "hdiff",
            "0",
            "0"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mkdir\""
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "hdiff",
            "S_IRWXU | S_IRWXG | S_IRWXO"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "hdiff",
            "&s"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&hdiff",
            "\"%s/hdiff\"",
            "basedir"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&hroot",
            "\"%s/oroot/home\"",
            "RUN_MNT_DIR"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "overlayhome",
            "&s"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"DEBUG: overlayhome var holds ##%s##\\n\"",
            "overlayhome"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&overlayhome",
            "\"%s%s\"",
            "oroot",
            "cfg.homedir"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"DEBUG: chroot dirs are oroot %s  odiff %s  owork %s\\n\"",
            "oroot",
            "odiff",
            "owork"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mounting overlayfs\""
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"overlay\"",
            "oroot",
            "\"overlay\"",
            "MS_MGC_VAL",
            "option"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&option",
            "\"lowerdir=/,upperdir=%s,workdir=%s\"",
            "odiff",
            "owork"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mounting overlayfs\""
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"overlayfs\"",
            "oroot",
            "\"overlayfs\"",
            "MS_MGC_VAL",
            "option"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&option",
            "\"lowerdir=/,upperdir=%s\"",
            "odiff"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "fs_rdonly_noexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
          "lines": "615-633",
          "snippet": "void fs_rdonly_noexit(const char *dir) {\n\tassert(dir);\n\t// check directory exists\n\tstruct stat s;\n\tint rv = stat(dir, &s);\n\tif (rv == 0) {\n\t\tint merr = 0;\n\t\t// mount --bind /bin /bin\n\t\tif (mount(dir, dir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\tmerr = 1;\n\t\t// mount --bind -o remount,ro /bin\n\t\tif (mount(NULL, dir, NULL, MS_BIND|MS_REMOUNT|MS_RDONLY|MS_REC, NULL) < 0)\n\t\t\tmerr = 1;\n\t\tif (merr)\n\t\t\tfprintf(stderr, \"Warning: cannot mount %s read-only\\n\", dir); \n\t\telse\n\t\t\tfs_logger2(\"read-only\", dir);\n\t}\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fs_rdwr(const char *dir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void fs_rdwr(const char *dir);\n\nvoid fs_rdonly_noexit(const char *dir) {\n\tassert(dir);\n\t// check directory exists\n\tstruct stat s;\n\tint rv = stat(dir, &s);\n\tif (rv == 0) {\n\t\tint merr = 0;\n\t\t// mount --bind /bin /bin\n\t\tif (mount(dir, dir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\tmerr = 1;\n\t\t// mount --bind -o remount,ro /bin\n\t\tif (mount(NULL, dir, NULL, MS_BIND|MS_REMOUNT|MS_RDONLY|MS_REC, NULL) < 0)\n\t\t\tmerr = 1;\n\t\tif (merr)\n\t\t\tfprintf(stderr, \"Warning: cannot mount %s read-only\\n\", dir); \n\t\telse\n\t\t\tfs_logger2(\"read-only\", dir);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: option --overlay= not available for kernels older than 3.18\\n\""
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Mounting OverlayFS\\n\""
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"chmod\""
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chmod",
          "args": [
            "owork",
            "0755"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"chown\""
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chown",
          "args": [
            "owork",
            "0",
            "0"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mkdir\""
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "owork",
            "0755"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "owork",
            "&s"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&owork",
            "\"%s/owork\"",
            "basedir"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"chmod\""
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chmod",
          "args": [
            "odiff",
            "0755"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"chown\""
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chown",
          "args": [
            "odiff",
            "0",
            "0"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mkdir\""
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "odiff",
            "0755"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "odiff",
            "&s"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&odiff",
            "\"%s/odiff\"",
            "basedir"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot create overlay directory\\n\""
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "basedir",
            "0755"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: overlay directory exists, but reuse is not allowed\\n\""
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "basedir",
            "&s"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PERMS",
          "args": [
            "oroot",
            "0",
            "0",
            "0755"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"chmod\""
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chmod",
          "args": [
            "oroot",
            "0755"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mkdir\""
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "oroot",
            "0755"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&oroot",
            "\"%s/oroot\"",
            "RUN_MNT_DIR"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_build_mnt_dir",
          "args": [],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "fs_build_mnt_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
          "lines": "126-145",
          "snippet": "void fs_build_mnt_dir(void) {\n\tstruct stat s;\n\tfs_build_firejail_dir();\n\t\n\t// create /run/firejail/mnt directory\n\tif (stat(RUN_MNT_DIR, &s)) {\n\t\tcreate_dir_as_root(RUN_MNT_DIR, 0755);\n\t}\n\n\t// ... and mount tmpfs on top of it\n\tif (!tmpfs_mounted) {\n\t\t// mount tmpfs on top of /run/firejail/mnt\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on %s directory\\n\", RUN_MNT_DIR);\n\t\tif (mount(\"tmpfs\", RUN_MNT_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /run/firejail/mnt\");\n\t\ttmpfs_mounted = 1;\n\t\tfs_logger2(\"tmpfs\", RUN_MNT_DIR);\n\t}\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int tmpfs_mounted = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic int tmpfs_mounted = 0;\n\nvoid fs_build_mnt_dir(void) {\n\tstruct stat s;\n\tfs_build_firejail_dir();\n\t\n\t// create /run/firejail/mnt directory\n\tif (stat(RUN_MNT_DIR, &s)) {\n\t\tcreate_dir_as_root(RUN_MNT_DIR, 0755);\n\t}\n\n\t// ... and mount tmpfs on top of it\n\tif (!tmpfs_mounted) {\n\t\t// mount tmpfs on top of /run/firejail/mnt\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on %s directory\\n\", RUN_MNT_DIR);\n\t\tif (mount(\"tmpfs\", RUN_MNT_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /run/firejail/mnt\");\n\t\ttmpfs_mounted = 1;\n\t\tfs_logger2(\"tmpfs\", RUN_MNT_DIR);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: minimum kernel version required 3.x\\n\""
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Linux kernel version %d.%d\\n\"",
            "major",
            "minor"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot extract Linux kernel version: %s\\n\"",
            "u.version"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "u.release",
            "\"%d.%d\"",
            "&major",
            "&minor"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"uname\""
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uname",
          "args": [
            "&u"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void fs_rdwr(const char *dir);\n\nvoid fs_overlayfs(void) {\n\t// check kernel version\n\tstruct utsname u;\n\tint rv = uname(&u);\n\tif (rv != 0)\n\t\terrExit(\"uname\");\n\tint major;\n\tint minor;\n\tif (2 != sscanf(u.release, \"%d.%d\", &major, &minor)) {\n\t\tfprintf(stderr, \"Error: cannot extract Linux kernel version: %s\\n\", u.version);\n\t\texit(1);\n\t}\n\t\n\tif (arg_debug)\n\t\tprintf(\"Linux kernel version %d.%d\\n\", major, minor);\n\tint oldkernel = 0;\n\tif (major < 3) {\n\t\tfprintf(stderr, \"Error: minimum kernel version required 3.x\\n\");\n\t\texit(1);\n\t}\n\tif (major == 3 && minor < 18)\n\t\toldkernel = 1;\n\t\n\t// build overlay directories\n\tfs_build_mnt_dir();\n\n\tchar *oroot;\n\tif(asprintf(&oroot, \"%s/oroot\", RUN_MNT_DIR) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mkdir(oroot, 0755))\n\t\terrExit(\"mkdir\");\n\tif (chmod(oroot, 0755) == -1)\n\t\terrExit(\"chmod\");\n\tASSERT_PERMS(oroot, 0, 0, 0755);\n\n\tstruct stat s;\n\tchar *basedir = RUN_MNT_DIR;\n\tif (arg_overlay_keep) {\n\t\t// set base for working and diff directories\n\t\tbasedir = cfg.overlay_dir;\n\n\t\t// does the overlay exist?\n\t\tif (stat(basedir, &s) == 0) {\n\t\t\tif (arg_overlay_reuse == 0) {\n\t\t\t\tfprintf(stderr, \"Error: overlay directory exists, but reuse is not allowed\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (mkdir(basedir, 0755) != 0) {\n\t\t\t\tfprintf(stderr, \"Error: cannot create overlay directory\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t}\n\n\tchar *odiff;\n\tif(asprintf(&odiff, \"%s/odiff\", basedir) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// no need to check arg_overlay_reuse\n\tif (stat(odiff, &s) != 0) {\n\t\tif (mkdir(odiff, 0755))\n\t\t\terrExit(\"mkdir\");\n\t}\n\n\tif (chown(odiff, 0, 0) < 0)\n\t\terrExit(\"chown\");\n\tif (chmod(odiff, 0755) < 0)\n\t\terrExit(\"chmod\");\n\t\n\tchar *owork;\n\tif(asprintf(&owork, \"%s/owork\", basedir) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// no need to check arg_overlay_reuse\n\tif (stat(owork, &s) != 0) {\n\t\tif (mkdir(owork, 0755))\n\t\t\terrExit(\"mkdir\");\n\t}\n\n\tif (chown(owork, 0, 0) < 0)\n\t\terrExit(\"chown\");\n\tif (chmod(owork, 0755) < 0)\n\t\terrExit(\"chmod\");\n\t\n\t// mount overlayfs\n\tif (arg_debug)\n\t\tprintf(\"Mounting OverlayFS\\n\");\n\tchar *option;\n\tif (oldkernel) { // old Ubuntu/OpenSUSE kernels\n\t\tif (arg_overlay_keep) {\n\t\t\tfprintf(stderr, \"Error: option --overlay= not available for kernels older than 3.18\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (asprintf(&option, \"lowerdir=/,upperdir=%s\", odiff) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (mount(\"overlayfs\", oroot, \"overlayfs\", MS_MGC_VAL, option) < 0)\n\t\t\terrExit(\"mounting overlayfs\");\n\t}\n\telse { // kernel 3.18 or newer\n\t\tif (asprintf(&option, \"lowerdir=/,upperdir=%s,workdir=%s\", odiff, owork) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (mount(\"overlay\", oroot, \"overlay\", MS_MGC_VAL, option) < 0)\n\t\t\terrExit(\"mounting overlayfs\");\n\t\t\t\n\t\t//***************************\n\t\t// issue #263 start code\n\t\t// My setup has a separate mount point for /home. When the overlay is mounted,\n\t\t// the overlay does not contain the original /home contents. \n\t\t// I added code to create a second overlay for /home if the overlay home dir is empty and this seems to work\n\t\t// @dshmgh, Jan 2016\n\t\t{\n\t\t\tchar *overlayhome;\n\t\t\tstruct stat s;\n\t\t\tchar *hroot;\n\t\t\tchar *hdiff;\n\t\t\tchar *hwork;\n\t\t\n\t\t\t// dons add debug\n\t\t\tif (arg_debug) printf (\"DEBUG: chroot dirs are oroot %s  odiff %s  owork %s\\n\",oroot,odiff,owork);\n\t\t\n\t\t\t// BEFORE NEXT, WE NEED TO TEST IF /home has any contents or do we need to mount it?\n\t\t\t// must create var for oroot/cfg.homedir\n\t\t\tif (asprintf(&overlayhome,\"%s%s\",oroot,cfg.homedir) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tif (arg_debug) printf (\"DEBUG: overlayhome var holds ##%s##\\n\",overlayhome);\n\t\t\n\t\t\t// if no homedir in overlay -- create another overlay for /home\n\t\t\tif (stat(overlayhome, &s) == -1) {\n\t\t\n\t\t\t\tif(asprintf(&hroot, \"%s/oroot/home\", RUN_MNT_DIR) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\n\t\t\t\tif(asprintf(&hdiff, \"%s/hdiff\", basedir) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\n\t\t\t\t// no need to check arg_overlay_reuse\n\t\t\t\tif (stat(hdiff, &s) != 0) {\n\t\t\t\t\tif (mkdir(hdiff, S_IRWXU | S_IRWXG | S_IRWXO))\n\t\t\t\t\t\terrExit(\"mkdir\");\n\t\t\t\t}\n\n\t\t\t\tif (chown(hdiff, 0, 0) < 0)\n\t\t\t\t\terrExit(\"chown\");\n\t\t\t\tif (chmod(hdiff, S_IRWXU  | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH) < 0)\n\t\t\t\t\terrExit(\"chmod\");\n\t\t\n\t\t\t\tif(asprintf(&hwork, \"%s/hwork\", basedir) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\n\t\t\t\t// no need to check arg_overlay_reuse\n\t\t\t\tif (stat(hwork, &s) != 0) {\n\t\t\t\t\tif (mkdir(hwork, S_IRWXU | S_IRWXG | S_IRWXO))\n\t\t\t\t\t\terrExit(\"mkdir\");\n\t\t\t\t}\n\n\t\t\t\tif (chown(hwork, 0, 0) < 0)\n\t\t\t\t\terrExit(\"chown\");\n\t\t\t\tif (chmod(hwork, S_IRWXU  | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH) < 0)\n\t\t\t\t\terrExit(\"chmod\");\n\t\t\n\t\t\t\t// no homedir in overlay so now mount another overlay for /home\n\t\t\t\tif (asprintf(&option, \"lowerdir=/home,upperdir=%s,workdir=%s\", hdiff, hwork) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\tif (mount(\"overlay\", hroot, \"overlay\", MS_MGC_VAL, option) < 0)\n\t\t\t\t\terrExit(\"mounting overlayfs for mounted home directory\");\n\t\t\n\t\t\t\tprintf(\"OverlayFS for /home configured in %s directory\\n\", basedir);\n\t\t\t} // stat(overlayhome)\n\t\t\tfree(overlayhome);\n\t\t}\n\t\t// issue #263 end code\n\t\t//***************************\n\t}\n\tprintf(\"OverlayFS configured in %s directory\\n\", basedir);\n\t\n\t// mount-bind dev directory\n\tif (arg_debug)\n\t\tprintf(\"Mounting /dev\\n\");\n\tchar *dev;\n\tif (asprintf(&dev, \"%s/dev\", oroot) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(\"/dev\", dev, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /dev\");\n\tfs_logger(\"whitelist /dev\");\n\n\t// mount-bind run directory\n\tif (arg_debug)\n\t\tprintf(\"Mounting /run\\n\");\n\tchar *run;\n\tif (asprintf(&run, \"%s/run\", oroot) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(\"/run\", run, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /run\");\n\tfs_logger(\"whitelist /run\");\n\n\t// mount-bind /tmp/.X11-unix directory\n\tif (stat(\"/tmp/.X11-unix\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting /tmp/.X11-unix\\n\");\n\t\tchar *x11;\n\t\tif (asprintf(&x11, \"%s/tmp/.X11-unix\", oroot) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (mount(\"/tmp/.X11-unix\", x11, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\tfprintf(stderr, \"Warning: cannot mount /tmp/.X11-unix in overlay\\n\");\n\t\telse\n\t\t\tfs_logger(\"whitelist /tmp/.X11-unix\");\n\t\tfree(x11);\n\t}\n\n\t// chroot in the new filesystem\n\tif (chroot(oroot) == -1)\n\t\terrExit(\"chroot\");\n\n\t// update /var directory in order to support multiple sandboxes running on the same root directory\n\tif (!arg_private_dev)\n\t\tfs_dev_shm();\n\tfs_var_lock();\n\tfs_var_tmp();\n\tfs_var_log();\n\tfs_var_lib();\n\tfs_var_cache();\n\tfs_var_utmp();\n\n\t// don't leak user information\n\trestrict_users();\n\n\t// when starting as root, firejail config is not disabled;\n\t// this mode could be used to install and test new software by chaining\n\t// firejail sandboxes (firejail --force)\n\tif (getuid() != 0)\n\t\tdisable_config();\n\n\t// cleanup and exit\n\tfree(option);\n\tfree(oroot);\n\tfree(odiff);\n}"
  },
  {
    "function_name": "fs_check_overlay_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
    "lines": "793-829",
    "snippet": "char *fs_check_overlay_dir(const char *subdirname, int allow_reuse) {\n\tstruct stat s;\n\tchar *dirname;\n\n\t// create ~/.firejail directory\n\tif (asprintf(&dirname, \"%s/.firejail\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (stat(dirname, &s) == -1) {\n\t\t/* coverity[toctou] */\n\t\tif (mkdir(dirname, 0700))\n\t\t\terrExit(\"mkdir\");\n\t\tif (chmod(dirname, 0700) == -1)\n\t\t\terrExit(\"chmod\");\n\t\tASSERT_PERMS(dirname, getuid(), getgid(), 0700);\n\t}\n\telse if (is_link(dirname)) {\n\t\tfprintf(stderr, \"Error: invalid ~/.firejail directory\\n\");\n\t\texit(1);\n\t}\n\tfree(dirname);\n\n\t// check overlay directory\n\tif (asprintf(&dirname, \"%s/.firejail/%s\", cfg.homedir, subdirname) == -1)\n\t\terrExit(\"asprintf\");\n\tif (is_link(dirname)) {\n\t\tfprintf(stderr, \"Error: overlay directory is a symbolic link\\n\");\n\t\texit(1);\n\t}\n\tif (allow_reuse == 0) {\n\t\tif (stat(dirname, &s) == 0) {\n\t\t\tfprintf(stderr, \"Error: overlay directory already exists: %s\\n\", dirname);\n\t\t\texit(1);\n\t\t}\n\t}\n\n\treturn dirname;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "fs_rdonly_noexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
          "lines": "615-633",
          "snippet": "void fs_rdonly_noexit(const char *dir) {\n\tassert(dir);\n\t// check directory exists\n\tstruct stat s;\n\tint rv = stat(dir, &s);\n\tif (rv == 0) {\n\t\tint merr = 0;\n\t\t// mount --bind /bin /bin\n\t\tif (mount(dir, dir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\tmerr = 1;\n\t\t// mount --bind -o remount,ro /bin\n\t\tif (mount(NULL, dir, NULL, MS_BIND|MS_REMOUNT|MS_RDONLY|MS_REC, NULL) < 0)\n\t\t\tmerr = 1;\n\t\tif (merr)\n\t\t\tfprintf(stderr, \"Warning: cannot mount %s read-only\\n\", dir); \n\t\telse\n\t\t\tfs_logger2(\"read-only\", dir);\n\t}\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fs_rdwr(const char *dir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void fs_rdwr(const char *dir);\n\nvoid fs_rdonly_noexit(const char *dir) {\n\tassert(dir);\n\t// check directory exists\n\tstruct stat s;\n\tint rv = stat(dir, &s);\n\tif (rv == 0) {\n\t\tint merr = 0;\n\t\t// mount --bind /bin /bin\n\t\tif (mount(dir, dir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\tmerr = 1;\n\t\t// mount --bind -o remount,ro /bin\n\t\tif (mount(NULL, dir, NULL, MS_BIND|MS_REMOUNT|MS_RDONLY|MS_REC, NULL) < 0)\n\t\t\tmerr = 1;\n\t\tif (merr)\n\t\t\tfprintf(stderr, \"Warning: cannot mount %s read-only\\n\", dir); \n\t\telse\n\t\t\tfs_logger2(\"read-only\", dir);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: overlay directory already exists: %s\\n\"",
            "dirname"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "dirname",
            "&s"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: overlay directory is a symbolic link\\n\""
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_link",
          "args": [
            "dirname"
          ],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "is_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/util.c",
          "lines": "295-307",
          "snippet": "int is_link(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\tstruct stat s;\n\tif (lstat(fname, &s) == 0) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nint is_link(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\tstruct stat s;\n\tif (lstat(fname, &s) == 0) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&dirname",
            "\"%s/.firejail/%s\"",
            "cfg.homedir",
            "subdirname"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "dirname"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid ~/.firejail directory\\n\""
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PERMS",
          "args": [
            "dirname",
            "getuid()",
            "getgid()",
            "0700"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getgid",
          "args": [],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"chmod\""
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chmod",
          "args": [
            "dirname",
            "0700"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mkdir\""
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "dirname",
            "0700"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "dirname",
            "&s"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&dirname",
            "\"%s/.firejail\"",
            "cfg.homedir"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nchar *fs_check_overlay_dir(const char *subdirname, int allow_reuse) {\n\tstruct stat s;\n\tchar *dirname;\n\n\t// create ~/.firejail directory\n\tif (asprintf(&dirname, \"%s/.firejail\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (stat(dirname, &s) == -1) {\n\t\t/* coverity[toctou] */\n\t\tif (mkdir(dirname, 0700))\n\t\t\terrExit(\"mkdir\");\n\t\tif (chmod(dirname, 0700) == -1)\n\t\t\terrExit(\"chmod\");\n\t\tASSERT_PERMS(dirname, getuid(), getgid(), 0700);\n\t}\n\telse if (is_link(dirname)) {\n\t\tfprintf(stderr, \"Error: invalid ~/.firejail directory\\n\");\n\t\texit(1);\n\t}\n\tfree(dirname);\n\n\t// check overlay directory\n\tif (asprintf(&dirname, \"%s/.firejail/%s\", cfg.homedir, subdirname) == -1)\n\t\terrExit(\"asprintf\");\n\tif (is_link(dirname)) {\n\t\tfprintf(stderr, \"Error: overlay directory is a symbolic link\\n\");\n\t\texit(1);\n\t}\n\tif (allow_reuse == 0) {\n\t\tif (stat(dirname, &s) == 0) {\n\t\t\tfprintf(stderr, \"Error: overlay directory already exists: %s\\n\", dirname);\n\t\t\texit(1);\n\t\t}\n\t}\n\n\treturn dirname;\n}"
  },
  {
    "function_name": "fs_basic_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
    "lines": "744-788",
    "snippet": "void fs_basic_fs(void) {\n\tuid_t uid = getuid();\n\t\n\tif (arg_debug)\n\t\tprintf(\"Mounting read-only /bin, /sbin, /lib, /lib32, /lib64, /usr\");\n\tif (!arg_writable_etc) {\n\t\tfs_rdonly(\"/etc\");\n\t\tif (uid)\n\t\t\tfs_noexec(\"/etc\");\n\t\tif (arg_debug) printf(\", /etc\");\n\t}\n\tif (!arg_writable_var) {\n\t\tfs_rdonly(\"/var\");\n\t\tif (uid)\n\t\t\tfs_noexec(\"/var\");\n\t\tif (arg_debug) printf(\", /var\");\n\t}\n\tif (arg_debug) printf(\"\\n\");\n\tfs_rdonly(\"/bin\");\n\tfs_rdonly(\"/sbin\");\n\tfs_rdonly(\"/lib\");\n\tfs_rdonly(\"/lib64\");\n\tfs_rdonly(\"/lib32\");\n\tfs_rdonly(\"/libx32\");\n\tfs_rdonly(\"/usr\");\n\n\t// update /var directory in order to support multiple sandboxes running on the same root directory\n\tif (!arg_private_dev)\n\t\tfs_dev_shm();\n\tfs_var_lock();\n\tfs_var_tmp();\n\tfs_var_log();\n\tfs_var_lib();\n\tfs_var_cache();\n\tfs_var_utmp();\n\n\t// don't leak user information\n\trestrict_users();\n\t\n\t// when starting as root, firejail config is not disabled;\n\t// this mode could be used to install and test new software by chaining\n\t// firejail sandboxes (firejail --force)\n\tif (uid)\n\t\tdisable_config();\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "disable_config",
          "args": [],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "disable_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
          "lines": "721-740",
          "snippet": "static void disable_config(void) {\n\tstruct stat s;\n\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/.config/firejail\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (stat(fname, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, fname);\n\tfree(fname);\n\t\n\t// disable run time information\n\tif (stat(RUN_FIREJAIL_NETWORK_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_NETWORK_DIR);\n\tif (stat(RUN_FIREJAIL_BANDWIDTH_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_BANDWIDTH_DIR);\n\tif (stat(RUN_FIREJAIL_NAME_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_NAME_DIR);\n\tif (stat(RUN_FIREJAIL_X11_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_X11_DIR);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void disable_config(void) {\n\tstruct stat s;\n\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/.config/firejail\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (stat(fname, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, fname);\n\tfree(fname);\n\t\n\t// disable run time information\n\tif (stat(RUN_FIREJAIL_NETWORK_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_NETWORK_DIR);\n\tif (stat(RUN_FIREJAIL_BANDWIDTH_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_BANDWIDTH_DIR);\n\tif (stat(RUN_FIREJAIL_NAME_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_NAME_DIR);\n\tif (stat(RUN_FIREJAIL_X11_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_X11_DIR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "restrict_users",
          "args": [],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "restrict_users",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/restrict_users.c",
          "lines": "337-357",
          "snippet": "void restrict_users(void) {\n\tif (arg_allusers)\n\t\treturn;\n\t\t\n\t// only in user mode\n\tif (getuid()) {\n\t\tif (strncmp(cfg.homedir, \"/home/\", 6) == 0) {\n\t\t\t// user has the home directory under /home\n\t\t\tsanitize_home();\n\t\t}\n\t\telse {\n\t\t\t// user has the home directory outside /home\n\t\t\t// mount tmpfs on top of /home in order to hide it\n\t\t\tif (mount(\"tmpfs\", \"/home\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\t\terrExit(\"mount tmpfs\");\n\t\t\tfs_logger(\"tmpfs /home\");\n\t\t}\n\t\tsanitize_passwd();\n\t\tsanitize_group();\n\t}\n}",
          "includes": [
            "#include \"../../uids.h\"",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../uids.h\"\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid restrict_users(void) {\n\tif (arg_allusers)\n\t\treturn;\n\t\t\n\t// only in user mode\n\tif (getuid()) {\n\t\tif (strncmp(cfg.homedir, \"/home/\", 6) == 0) {\n\t\t\t// user has the home directory under /home\n\t\t\tsanitize_home();\n\t\t}\n\t\telse {\n\t\t\t// user has the home directory outside /home\n\t\t\t// mount tmpfs on top of /home in order to hide it\n\t\t\tif (mount(\"tmpfs\", \"/home\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\t\terrExit(\"mount tmpfs\");\n\t\t\tfs_logger(\"tmpfs /home\");\n\t\t}\n\t\tsanitize_passwd();\n\t\tsanitize_group();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_var_utmp",
          "args": [],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "fs_var_utmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_var.c",
          "lines": "308-355",
          "snippet": "void fs_var_utmp(void) {\n\tstruct stat s;\n\n\t// extract utmp group id\n\tgid_t utmp_group = 0;\n\tif (stat(UTMP_FILE, &s) == 0)\n\t\tutmp_group = s.st_gid;\n\telse {\n\t\tfprintf(stderr, \"Warning: cannot find /var/run/utmp\\n\");\n\t\treturn;\n\t}\n\n\t// create /run/firejail/mnt directory\n\tfs_build_mnt_dir();\n\t\n\t// create a new utmp file\n\tif (arg_debug)\n\t\tprintf(\"Create the new utmp file\\n\");\n\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(RUN_UTMP_FILE, \"w\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\t\t\n\t// read current utmp\n\tstruct utmp *u;\n\tstruct utmp u_boot;\n\tsetutent();\n\twhile ((u = getutent()) != NULL) {\n\t\tif (u->ut_type == BOOT_TIME) {\n\t\t\tmemcpy(&u_boot, u, sizeof(u_boot));\n\t\t\tu_boot.ut_tv.tv_sec = (unsigned) time(NULL);\n\t\t}\n\t}\n\tendutent();\n\t\t\t\n\t// save new utmp file\n\tfwrite(&u_boot, sizeof(u_boot), 1, fp);\n\tSET_PERMS_STREAM(fp, 0, utmp_group, S_IRUSR | S_IWRITE | S_IRGRP | S_IWGRP | S_IROTH);\n\tfclose(fp);\n\t\n\t// mount the new utmp file\n\tif (arg_debug)\n\t\tprintf(\"Mount the new utmp file\\n\");\n\tif (mount(RUN_UTMP_FILE, UTMP_FILE, NULL, MS_BIND|MS_NOSUID|MS_NOEXEC | MS_NODEV | MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind utmp\");\n\tfs_logger(\"create /var/run/utmp\");\n}",
          "includes": [
            "#include <time.h>",
            "#include <utmp.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <utmp.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_var_utmp(void) {\n\tstruct stat s;\n\n\t// extract utmp group id\n\tgid_t utmp_group = 0;\n\tif (stat(UTMP_FILE, &s) == 0)\n\t\tutmp_group = s.st_gid;\n\telse {\n\t\tfprintf(stderr, \"Warning: cannot find /var/run/utmp\\n\");\n\t\treturn;\n\t}\n\n\t// create /run/firejail/mnt directory\n\tfs_build_mnt_dir();\n\t\n\t// create a new utmp file\n\tif (arg_debug)\n\t\tprintf(\"Create the new utmp file\\n\");\n\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(RUN_UTMP_FILE, \"w\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\t\t\n\t// read current utmp\n\tstruct utmp *u;\n\tstruct utmp u_boot;\n\tsetutent();\n\twhile ((u = getutent()) != NULL) {\n\t\tif (u->ut_type == BOOT_TIME) {\n\t\t\tmemcpy(&u_boot, u, sizeof(u_boot));\n\t\t\tu_boot.ut_tv.tv_sec = (unsigned) time(NULL);\n\t\t}\n\t}\n\tendutent();\n\t\t\t\n\t// save new utmp file\n\tfwrite(&u_boot, sizeof(u_boot), 1, fp);\n\tSET_PERMS_STREAM(fp, 0, utmp_group, S_IRUSR | S_IWRITE | S_IRGRP | S_IWGRP | S_IROTH);\n\tfclose(fp);\n\t\n\t// mount the new utmp file\n\tif (arg_debug)\n\t\tprintf(\"Mount the new utmp file\\n\");\n\tif (mount(RUN_UTMP_FILE, UTMP_FILE, NULL, MS_BIND|MS_NOSUID|MS_NOEXEC | MS_NODEV | MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind utmp\");\n\tfs_logger(\"create /var/run/utmp\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_var_cache",
          "args": [],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "fs_var_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_var.c",
          "lines": "200-240",
          "snippet": "void fs_var_cache(void) {\n\tstruct stat s;\n\n\tif (stat(\"/var/cache/apache2\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/cache/apache2\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/cache/apache2\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/cache/apache2\");\n\t\tfs_logger(\"tmpfs /var/cache/apache2\");\n\t}\t\t\t\n\n\tif (stat(\"/var/cache/lighttpd\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/cache/lighttpd\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/cache/lighttpd\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/cache/lighttpd\");\n\t\tfs_logger(\"tmpfs /var/cache/lighttpd\");\n\n\t\tstruct passwd *p = getpwnam(\"www-data\");\n\t\tuid_t uid = 0;\n\t\tgid_t gid = 0;\n\t\tif (p) {\n\t\t\tuid = p->pw_uid;\n\t\t\tgid = p->pw_gid;\n\t\t}\n\t\t\n\t\tint rv = mkdir(\"/var/cache/lighttpd/compress\", 0755);\n\t\tif (rv == -1)\n\t\t\terrExit(\"mkdir\");\n\t\tif (chown(\"/var/cache/lighttpd/compress\", uid, gid) < 0)\n\t\t\terrExit(\"chown\");\n\t\tfs_logger(\"mkdir /var/cache/lighttpd/compress\");\n\n\t\trv = mkdir(\"/var/cache/lighttpd/uploads\", 0755);\n\t\tif (rv == -1)\n\t\t\terrExit(\"mkdir\");\n\t\tif (chown(\"/var/cache/lighttpd/uploads\", uid, gid) < 0)\n\t\t\terrExit(\"chown\");\n\t\tfs_logger(\"/var/cache/lighttpd/uploads\");\n\t}\t\t\t\n}",
          "includes": [
            "#include <time.h>",
            "#include <utmp.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <utmp.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_var_cache(void) {\n\tstruct stat s;\n\n\tif (stat(\"/var/cache/apache2\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/cache/apache2\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/cache/apache2\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/cache/apache2\");\n\t\tfs_logger(\"tmpfs /var/cache/apache2\");\n\t}\t\t\t\n\n\tif (stat(\"/var/cache/lighttpd\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/cache/lighttpd\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/cache/lighttpd\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/cache/lighttpd\");\n\t\tfs_logger(\"tmpfs /var/cache/lighttpd\");\n\n\t\tstruct passwd *p = getpwnam(\"www-data\");\n\t\tuid_t uid = 0;\n\t\tgid_t gid = 0;\n\t\tif (p) {\n\t\t\tuid = p->pw_uid;\n\t\t\tgid = p->pw_gid;\n\t\t}\n\t\t\n\t\tint rv = mkdir(\"/var/cache/lighttpd/compress\", 0755);\n\t\tif (rv == -1)\n\t\t\terrExit(\"mkdir\");\n\t\tif (chown(\"/var/cache/lighttpd/compress\", uid, gid) < 0)\n\t\t\terrExit(\"chown\");\n\t\tfs_logger(\"mkdir /var/cache/lighttpd/compress\");\n\n\t\trv = mkdir(\"/var/cache/lighttpd/uploads\", 0755);\n\t\tif (rv == -1)\n\t\t\terrExit(\"mkdir\");\n\t\tif (chown(\"/var/cache/lighttpd/uploads\", uid, gid) < 0)\n\t\t\terrExit(\"chown\");\n\t\tfs_logger(\"/var/cache/lighttpd/uploads\");\n\t}\t\t\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_var_lib",
          "args": [],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "fs_var_lib",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_var.c",
          "lines": "150-198",
          "snippet": "void fs_var_lib(void) {\n\tstruct stat s;\n\t\n\t// ISC DHCP multiserver\n\tif (stat(\"/var/lib/dhcp\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lib/dhcp\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lib/dhcp\", \"tmpfs\", MS_NOSUID |  MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/lib/dhcp\");\n\t\tfs_logger(\"tmpfs /var/lib/dhcp\");\n\t\t\t\n\t\t// isc dhcp server requires a /var/lib/dhcp/dhcpd.leases file\n\t\tFILE *fp = fopen(\"/var/lib/dhcp/dhcpd.leases\", \"w\");\n\t\t\n\t\tif (fp) {\n\t\t\tfprintf(fp, \"\\n\");\n\t\t\tSET_PERMS_STREAM(fp, 0, 0, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);\n\t\t\tfclose(fp);\n\t\t\tfs_logger(\"touch /var/lib/dhcp/dhcpd.leases\");\n\t\t}\n\t}\n\n\t// nginx multiserver\n\tif (stat(\"/var/lib/nginx\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lib/nginx\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lib/nginx\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/lib/nginx\");\n\t\tfs_logger(\"tmpfs /var/lib/nginx\");\n\t}\t\t\t\n\n\t// net-snmp multiserver\n\tif (stat(\"/var/lib/snmp\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lib/snmp\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lib/snmp\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/lib/snmp\");\n\t\tfs_logger(\"tmpfs /var/lib/snmp\");\n\t}\t\t\t\n\n\t// this is where sudo remembers its state\n\tif (stat(\"/var/lib/sudo\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lib/sudo\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lib/sudo\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/lib/sudo\");\n\t\tfs_logger(\"tmpfs /var/lib/sudo\");\n\t}\t\t\t\n}",
          "includes": [
            "#include <time.h>",
            "#include <utmp.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <utmp.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_var_lib(void) {\n\tstruct stat s;\n\t\n\t// ISC DHCP multiserver\n\tif (stat(\"/var/lib/dhcp\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lib/dhcp\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lib/dhcp\", \"tmpfs\", MS_NOSUID |  MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/lib/dhcp\");\n\t\tfs_logger(\"tmpfs /var/lib/dhcp\");\n\t\t\t\n\t\t// isc dhcp server requires a /var/lib/dhcp/dhcpd.leases file\n\t\tFILE *fp = fopen(\"/var/lib/dhcp/dhcpd.leases\", \"w\");\n\t\t\n\t\tif (fp) {\n\t\t\tfprintf(fp, \"\\n\");\n\t\t\tSET_PERMS_STREAM(fp, 0, 0, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);\n\t\t\tfclose(fp);\n\t\t\tfs_logger(\"touch /var/lib/dhcp/dhcpd.leases\");\n\t\t}\n\t}\n\n\t// nginx multiserver\n\tif (stat(\"/var/lib/nginx\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lib/nginx\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lib/nginx\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/lib/nginx\");\n\t\tfs_logger(\"tmpfs /var/lib/nginx\");\n\t}\t\t\t\n\n\t// net-snmp multiserver\n\tif (stat(\"/var/lib/snmp\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lib/snmp\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lib/snmp\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/lib/snmp\");\n\t\tfs_logger(\"tmpfs /var/lib/snmp\");\n\t}\t\t\t\n\n\t// this is where sudo remembers its state\n\tif (stat(\"/var/lib/sudo\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lib/sudo\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lib/sudo\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/lib/sudo\");\n\t\tfs_logger(\"tmpfs /var/lib/sudo\");\n\t}\t\t\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_var_log",
          "args": [],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "fs_var_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_var.c",
          "lines": "110-148",
          "snippet": "void fs_var_log(void) {\n\tbuild_list(\"/var/log\");\n\t\n\t// create /var/log if it doesn't exit\n\tif (is_dir(\"/var/log\")) {\n\t\t// extract group id for /var/log/wtmp\n\t\tstruct stat s;\n\t\tgid_t wtmp_group = 0;\n\t\tif (stat(\"/var/log/wtmp\", &s) == 0)\n\t\t\twtmp_group = s.st_gid;\n\t\t\n\t\t// mount a tmpfs on top of /var/log\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/log\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/log\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/log\");\n\t\tfs_logger(\"tmpfs /var/log\");\n\t\t\n\t\tbuild_dirs();\n\t\trelease_all();\n\t\t\n\t\t// create an empty /var/log/wtmp file\n\t\t/* coverity[toctou] */\n\t\tFILE *fp = fopen(\"/var/log/wtmp\", \"w\");\n\t\tSET_PERMS_STREAM(fp, 0, wtmp_group, S_IRUSR | S_IWRITE | S_IRGRP | S_IWGRP | S_IROTH);\n\t\tif (fp)\n\t\t\tfclose(fp);\n\t\tfs_logger(\"touch /var/log/wtmp\");\n\t\t\t\n\t\t// create an empty /var/log/btmp file\n\t\tfp = fopen(\"/var/log/btmp\", \"w\");\n\t\tSET_PERMS_STREAM(fp, 0, wtmp_group, S_IRUSR | S_IWRITE | S_IRGRP | S_IWGRP);\n\t\tif (fp)\n\t\t\tfclose(fp);\n\t\tfs_logger(\"touch /var/log/btmp\");\n\t}\n\telse\n\t\tfprintf(stderr, \"Warning: cannot mount tmpfs on top of /var/log\\n\");\n}",
          "includes": [
            "#include <time.h>",
            "#include <utmp.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <utmp.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_var_log(void) {\n\tbuild_list(\"/var/log\");\n\t\n\t// create /var/log if it doesn't exit\n\tif (is_dir(\"/var/log\")) {\n\t\t// extract group id for /var/log/wtmp\n\t\tstruct stat s;\n\t\tgid_t wtmp_group = 0;\n\t\tif (stat(\"/var/log/wtmp\", &s) == 0)\n\t\t\twtmp_group = s.st_gid;\n\t\t\n\t\t// mount a tmpfs on top of /var/log\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/log\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/log\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /var/log\");\n\t\tfs_logger(\"tmpfs /var/log\");\n\t\t\n\t\tbuild_dirs();\n\t\trelease_all();\n\t\t\n\t\t// create an empty /var/log/wtmp file\n\t\t/* coverity[toctou] */\n\t\tFILE *fp = fopen(\"/var/log/wtmp\", \"w\");\n\t\tSET_PERMS_STREAM(fp, 0, wtmp_group, S_IRUSR | S_IWRITE | S_IRGRP | S_IWGRP | S_IROTH);\n\t\tif (fp)\n\t\t\tfclose(fp);\n\t\tfs_logger(\"touch /var/log/wtmp\");\n\t\t\t\n\t\t// create an empty /var/log/btmp file\n\t\tfp = fopen(\"/var/log/btmp\", \"w\");\n\t\tSET_PERMS_STREAM(fp, 0, wtmp_group, S_IRUSR | S_IWRITE | S_IRGRP | S_IWGRP);\n\t\tif (fp)\n\t\t\tfclose(fp);\n\t\tfs_logger(\"touch /var/log/btmp\");\n\t}\n\telse\n\t\tfprintf(stderr, \"Warning: cannot mount tmpfs on top of /var/log\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_var_tmp",
          "args": [],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "fs_var_tmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_var.c",
          "lines": "291-306",
          "snippet": "void fs_var_tmp(void) {\n\tstruct stat s;\n\tif (stat(\"/var/tmp\", &s) == 0) {\n\t\tif (!is_link(\"/var/tmp\")) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Mounting tmpfs on /var/tmp\\n\");\n\t\t\tif (mount(\"tmpfs\", \"/var/tmp\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=1777,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting /var/tmp\");\n\t\t\tfs_logger(\"tmpfs /var/tmp\");\n\t\t}\n\t}\n\telse {\n\t\tfprintf(stderr, \"Warning: /var/tmp not mounted\\n\");\n\t\tdbg_test_dir(\"/var/tmp\");\n\t}\n}",
          "includes": [
            "#include <time.h>",
            "#include <utmp.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <utmp.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_var_tmp(void) {\n\tstruct stat s;\n\tif (stat(\"/var/tmp\", &s) == 0) {\n\t\tif (!is_link(\"/var/tmp\")) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Mounting tmpfs on /var/tmp\\n\");\n\t\t\tif (mount(\"tmpfs\", \"/var/tmp\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=1777,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting /var/tmp\");\n\t\t\tfs_logger(\"tmpfs /var/tmp\");\n\t\t}\n\t}\n\telse {\n\t\tfprintf(stderr, \"Warning: /var/tmp not mounted\\n\");\n\t\tdbg_test_dir(\"/var/tmp\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_var_lock",
          "args": [],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "fs_var_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_var.c",
          "lines": "257-289",
          "snippet": "void fs_var_lock(void) {\n\n\tif (is_dir(\"/var/lock\")) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lock\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lock\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=1777,gid=0\") < 0)\n\t\t\terrExit(\"mounting /lock\");\n\t\tfs_logger(\"tmpfs /var/lock\");\n\t}\n\telse {\n\t\tchar *lnk = realpath(\"/var/lock\", NULL);\n\t\tif (lnk) {\n\t\t\tif (!is_dir(lnk)) {\n\t\t\t\t// create directory\n\t\t\t\tif (mkdir(lnk, S_IRWXU|S_IRWXG|S_IRWXO))\n\t\t\t\t\terrExit(\"mkdir\");\n\t\t\t\tif (chmod(lnk, S_IRWXU|S_IRWXG|S_IRWXO))\n\t\t\t\t\terrExit(\"chmod\");\n\t\t\t\tASSERT_PERMS(lnk, 0, 0, S_IRWXU|S_IRWXG|S_IRWXO);\n\t\t\t}\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Mounting tmpfs on %s on behalf of /var/lock\\n\", lnk);\n\t\t\tif (mount(\"tmpfs\", lnk, \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=1777,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting /var/lock\");\n\t\t\tfree(lnk);\n\t\t\tfs_logger(\"tmpfs /var/lock\");\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"Warning: /var/lock not mounted\\n\");\n\t\t\tdbg_test_dir(\"/var/lock\");\n\t\t}\n\t}\n}",
          "includes": [
            "#include <time.h>",
            "#include <utmp.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <utmp.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_var_lock(void) {\n\n\tif (is_dir(\"/var/lock\")) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /var/lock\\n\");\n\t\tif (mount(\"tmpfs\", \"/var/lock\", \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=1777,gid=0\") < 0)\n\t\t\terrExit(\"mounting /lock\");\n\t\tfs_logger(\"tmpfs /var/lock\");\n\t}\n\telse {\n\t\tchar *lnk = realpath(\"/var/lock\", NULL);\n\t\tif (lnk) {\n\t\t\tif (!is_dir(lnk)) {\n\t\t\t\t// create directory\n\t\t\t\tif (mkdir(lnk, S_IRWXU|S_IRWXG|S_IRWXO))\n\t\t\t\t\terrExit(\"mkdir\");\n\t\t\t\tif (chmod(lnk, S_IRWXU|S_IRWXG|S_IRWXO))\n\t\t\t\t\terrExit(\"chmod\");\n\t\t\t\tASSERT_PERMS(lnk, 0, 0, S_IRWXU|S_IRWXG|S_IRWXO);\n\t\t\t}\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Mounting tmpfs on %s on behalf of /var/lock\\n\", lnk);\n\t\t\tif (mount(\"tmpfs\", lnk, \"tmpfs\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=1777,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting /var/lock\");\n\t\t\tfree(lnk);\n\t\t\tfs_logger(\"tmpfs /var/lock\");\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"Warning: /var/lock not mounted\\n\");\n\t\t\tdbg_test_dir(\"/var/lock\");\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_dev_shm",
          "args": [],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "fs_dev_shm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_dev.c",
          "lines": "247-284",
          "snippet": "void fs_dev_shm(void) {\n\tuid_t uid = getuid(); // set a new shm only if we started as root\n\tif (uid)\n\t\treturn;\n\n\tif (is_dir(\"/dev/shm\")) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /dev/shm\\n\");\n\t\tif (mount(\"tmpfs\", \"/dev/shm\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME | MS_REC,  \"mode=1777,gid=0\") < 0)\n\t\t\terrExit(\"mounting /dev/shm\");\n\t\tfs_logger(\"tmpfs /dev/shm\");\n\t}\n\telse {\n\t\tchar *lnk = realpath(\"/dev/shm\", NULL);\n\t\tif (lnk) {\n\t\t\tif (!is_dir(lnk)) {\n\t\t\t\t// create directory\n\t\t\t\tif (mkdir(lnk, 01777))\n\t\t\t\t\terrExit(\"mkdir\");\n\t\t\t\t// mkdir sets only the file permission bits\n\t\t\t\tif (chmod(lnk, 01777))\n\t\t\t\t\terrExit(\"chmod\");\n\t\t\t\tASSERT_PERMS(lnk, 0, 0, 01777);\n\t\t\t}\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Mounting tmpfs on %s on behalf of /dev/shm\\n\", lnk);\n\t\t\tif (mount(\"tmpfs\", lnk, \"tmpfs\", MS_NOSUID | MS_STRICTATIME | MS_REC,  \"mode=1777,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting /var/tmp\");\n\t\t\tfs_logger2(\"tmpfs\", lnk);\n\t\t\tfree(lnk);\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"Warning: /dev/shm not mounted\\n\");\n\t\t\tdbg_test_dir(\"/dev/shm\");\n\t\t}\n\t\t\t\n\t}\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_dev_shm(void) {\n\tuid_t uid = getuid(); // set a new shm only if we started as root\n\tif (uid)\n\t\treturn;\n\n\tif (is_dir(\"/dev/shm\")) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on /dev/shm\\n\");\n\t\tif (mount(\"tmpfs\", \"/dev/shm\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME | MS_REC,  \"mode=1777,gid=0\") < 0)\n\t\t\terrExit(\"mounting /dev/shm\");\n\t\tfs_logger(\"tmpfs /dev/shm\");\n\t}\n\telse {\n\t\tchar *lnk = realpath(\"/dev/shm\", NULL);\n\t\tif (lnk) {\n\t\t\tif (!is_dir(lnk)) {\n\t\t\t\t// create directory\n\t\t\t\tif (mkdir(lnk, 01777))\n\t\t\t\t\terrExit(\"mkdir\");\n\t\t\t\t// mkdir sets only the file permission bits\n\t\t\t\tif (chmod(lnk, 01777))\n\t\t\t\t\terrExit(\"chmod\");\n\t\t\t\tASSERT_PERMS(lnk, 0, 0, 01777);\n\t\t\t}\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Mounting tmpfs on %s on behalf of /dev/shm\\n\", lnk);\n\t\t\tif (mount(\"tmpfs\", lnk, \"tmpfs\", MS_NOSUID | MS_STRICTATIME | MS_REC,  \"mode=1777,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting /var/tmp\");\n\t\t\tfs_logger2(\"tmpfs\", lnk);\n\t\t\tfree(lnk);\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"Warning: /dev/shm not mounted\\n\");\n\t\t\tdbg_test_dir(\"/dev/shm\");\n\t\t}\n\t\t\t\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_rdonly",
          "args": [
            "\"/usr\""
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "fs_rdonly_noexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
          "lines": "615-633",
          "snippet": "void fs_rdonly_noexit(const char *dir) {\n\tassert(dir);\n\t// check directory exists\n\tstruct stat s;\n\tint rv = stat(dir, &s);\n\tif (rv == 0) {\n\t\tint merr = 0;\n\t\t// mount --bind /bin /bin\n\t\tif (mount(dir, dir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\tmerr = 1;\n\t\t// mount --bind -o remount,ro /bin\n\t\tif (mount(NULL, dir, NULL, MS_BIND|MS_REMOUNT|MS_RDONLY|MS_REC, NULL) < 0)\n\t\t\tmerr = 1;\n\t\tif (merr)\n\t\t\tfprintf(stderr, \"Warning: cannot mount %s read-only\\n\", dir); \n\t\telse\n\t\t\tfs_logger2(\"read-only\", dir);\n\t}\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fs_rdwr(const char *dir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void fs_rdwr(const char *dir);\n\nvoid fs_rdonly_noexit(const char *dir) {\n\tassert(dir);\n\t// check directory exists\n\tstruct stat s;\n\tint rv = stat(dir, &s);\n\tif (rv == 0) {\n\t\tint merr = 0;\n\t\t// mount --bind /bin /bin\n\t\tif (mount(dir, dir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\tmerr = 1;\n\t\t// mount --bind -o remount,ro /bin\n\t\tif (mount(NULL, dir, NULL, MS_BIND|MS_REMOUNT|MS_RDONLY|MS_REC, NULL) < 0)\n\t\t\tmerr = 1;\n\t\tif (merr)\n\t\t\tfprintf(stderr, \"Warning: cannot mount %s read-only\\n\", dir); \n\t\telse\n\t\t\tfs_logger2(\"read-only\", dir);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\", /var\""
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_noexec",
          "args": [
            "\"/var\""
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "fs_noexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
          "lines": "597-611",
          "snippet": "void fs_noexec(const char *dir) {\n\tassert(dir);\n\t// check directory exists\n\tstruct stat s;\n\tint rv = stat(dir, &s);\n\tif (rv == 0) {\n\t\t// mount --bind /bin /bin\n\t\tif (mount(dir, dir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mount noexec\");\n\t\t// mount --bind -o remount,ro /bin\n\t\tif (mount(NULL, dir, NULL, MS_BIND|MS_REMOUNT|MS_NOEXEC|MS_NODEV|MS_NOSUID|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mount read-only\");\n\t\tfs_logger2(\"noexec\", dir);\n\t}\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fs_rdwr(const char *dir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void fs_rdwr(const char *dir);\n\nvoid fs_noexec(const char *dir) {\n\tassert(dir);\n\t// check directory exists\n\tstruct stat s;\n\tint rv = stat(dir, &s);\n\tif (rv == 0) {\n\t\t// mount --bind /bin /bin\n\t\tif (mount(dir, dir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mount noexec\");\n\t\t// mount --bind -o remount,ro /bin\n\t\tif (mount(NULL, dir, NULL, MS_BIND|MS_REMOUNT|MS_NOEXEC|MS_NODEV|MS_NOSUID|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mount read-only\");\n\t\tfs_logger2(\"noexec\", dir);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\", /etc\""
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Mounting read-only /bin, /sbin, /lib, /lib32, /lib64, /usr\""
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_basic_fs(void) {\n\tuid_t uid = getuid();\n\t\n\tif (arg_debug)\n\t\tprintf(\"Mounting read-only /bin, /sbin, /lib, /lib32, /lib64, /usr\");\n\tif (!arg_writable_etc) {\n\t\tfs_rdonly(\"/etc\");\n\t\tif (uid)\n\t\t\tfs_noexec(\"/etc\");\n\t\tif (arg_debug) printf(\", /etc\");\n\t}\n\tif (!arg_writable_var) {\n\t\tfs_rdonly(\"/var\");\n\t\tif (uid)\n\t\t\tfs_noexec(\"/var\");\n\t\tif (arg_debug) printf(\", /var\");\n\t}\n\tif (arg_debug) printf(\"\\n\");\n\tfs_rdonly(\"/bin\");\n\tfs_rdonly(\"/sbin\");\n\tfs_rdonly(\"/lib\");\n\tfs_rdonly(\"/lib64\");\n\tfs_rdonly(\"/lib32\");\n\tfs_rdonly(\"/libx32\");\n\tfs_rdonly(\"/usr\");\n\n\t// update /var directory in order to support multiple sandboxes running on the same root directory\n\tif (!arg_private_dev)\n\t\tfs_dev_shm();\n\tfs_var_lock();\n\tfs_var_tmp();\n\tfs_var_log();\n\tfs_var_lib();\n\tfs_var_cache();\n\tfs_var_utmp();\n\n\t// don't leak user information\n\trestrict_users();\n\t\n\t// when starting as root, firejail config is not disabled;\n\t// this mode could be used to install and test new software by chaining\n\t// firejail sandboxes (firejail --force)\n\tif (uid)\n\t\tdisable_config();\n}"
  },
  {
    "function_name": "disable_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
    "lines": "721-740",
    "snippet": "static void disable_config(void) {\n\tstruct stat s;\n\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/.config/firejail\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (stat(fname, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, fname);\n\tfree(fname);\n\t\n\t// disable run time information\n\tif (stat(RUN_FIREJAIL_NETWORK_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_NETWORK_DIR);\n\tif (stat(RUN_FIREJAIL_BANDWIDTH_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_BANDWIDTH_DIR);\n\tif (stat(RUN_FIREJAIL_NAME_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_NAME_DIR);\n\tif (stat(RUN_FIREJAIL_X11_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_X11_DIR);\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "disable_file",
          "args": [
            "BLACKLIST_FILE",
            "RUN_FIREJAIL_X11_DIR"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "disable_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
          "lines": "200-325",
          "snippet": "static void disable_file(OPERATION op, const char *filename) {\n\tassert(filename);\n\tassert(op <OPERATION_MAX);\n\tlast_disable = UNSUCCESSFUL;\n\t\n\t// rebuild /run/firejail directory in case tmpfs was mounted on top of /run\n\tfs_build_firejail_dir();\n\t\n\t// Resolve all symlinks\n\tchar* fname = realpath(filename, NULL);\n\tif (fname == NULL && errno != EACCES) {\n\t\treturn;\n\t}\n\tif (fname == NULL && errno == EACCES) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Debug: no access to file %s, forcing mount\\n\", filename);\n\t\t// realpath and stat funtions will fail on FUSE filesystems\n\t\t// they don't seem to like a uid of 0\n\t\t// force mounting\n\t\tint rv = mount(RUN_RO_DIR, filename, \"none\", MS_BIND, \"mode=400,gid=0\");\n\t\tif (rv == 0)\n\t\t\tlast_disable = SUCCESSFUL;\n\t\telse {\n\t\t\trv = mount(RUN_RO_FILE, filename, \"none\", MS_BIND, \"mode=400,gid=0\");\n\t\t\tif (rv == 0)\n\t\t\t\tlast_disable = SUCCESSFUL;\n\t\t}\n\t\tif (last_disable == SUCCESSFUL) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Disable %s\\n\", filename);\n\t\t\tif (op == BLACKLIST_FILE)\n\t\t\t\tfs_logger2(\"blacklist\", filename);\n\t\t\telse\n\t\t\t\tfs_logger2(\"blacklist-nolog\", filename);\n\t\t}\n\t\telse {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Warning (blacklisting): %s is an invalid file, skipping...\\n\", filename);\n\t\t}\n\t\t\t\t\n\t\treturn;\n\t}\n\t\n\t// if the file is not present, do nothing\n\tstruct stat s;\n\tif (fname == NULL)\n\t\treturn;\n\tif (stat(fname, &s) == -1) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Warning: %s does not exist, skipping...\\n\", fname);\n\t\tfree(fname);\n\t\treturn;\n\t}\n\n\t// modify the file\n\tif (op == BLACKLIST_FILE || op == BLACKLIST_NOLOG) {\n\t\t// some distros put all executables under /usr/bin and make /bin a symbolic link\n\t\tif ((strcmp(fname, \"/bin\") == 0 || strcmp(fname, \"/usr/bin\") == 0) &&\n\t\t      is_link(filename) &&\n\t\t      S_ISDIR(s.st_mode))\n\t\t\tfprintf(stderr, \"Warning: %s directory link was not blacklisted\\n\", filename);\n\t\t\t\n\t\telse {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Disable %s\\n\", fname);\n\t\t\telse if (arg_debug_blacklists) {\n\t\t\t\tprintf(\"Disable %s\", fname);\n\t\t\t\tif (op == BLACKLIST_FILE)\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\telse\n\t\t\t\t\tprintf(\" - no logging\\n\");\n\t\t\t}\n\t\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\t\tif (mount(RUN_RO_DIR, fname, \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\t\t\t\terrExit(\"disable file\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (mount(RUN_RO_FILE, fname, \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\t\t\t\terrExit(\"disable file\");\n\t\t\t}\n\t\t\tlast_disable = SUCCESSFUL;\n\t\t\tif (op == BLACKLIST_FILE)\n\t\t\t\tfs_logger2(\"blacklist\", fname);\n\t\t\telse\n\t\t\t\tfs_logger2(\"blacklist-nolog\", fname);\n\t\t}\n\t}\n\telse if (op == MOUNT_READONLY) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting read-only %s\\n\", fname);\n\t\tfs_rdonly(fname);\n// todo: last_disable = SUCCESSFUL;\n\t}\n\telse if (op == MOUNT_RDWR) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting read-only %s\\n\", fname);\n\t\tfs_rdwr(fname);\n// todo: last_disable = SUCCESSFUL;\n\t}\n\telse if (op == MOUNT_NOEXEC) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting noexec %s\\n\", fname);\n\t\tfs_noexec(fname);\n// todo: last_disable = SUCCESSFUL;\n\t}\n\telse if (op == MOUNT_TMPFS) {\n\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Mounting tmpfs on %s\\n\", fname);\n\t\t\t// preserve owner and mode for the directory\n\t\t\tif (mount(\"tmpfs\", fname, \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME | MS_REC,  0) < 0)\n\t\t\t\terrExit(\"mounting tmpfs\");\n\t\t\t/* coverity[toctou] */\n\t\t\tif (chown(fname, s.st_uid, s.st_gid) == -1)\n\t\t\t\terrExit(\"mounting tmpfs chmod\");\n\t\t\tlast_disable = SUCCESSFUL;\n\t\t\tfs_logger2(\"tmpfs\", fname);\n\t\t}\n\t\telse\n\t\t\tprintf(\"Warning: %s is not a directory; cannot mount a tmpfs on top of it.\\n\", fname);\n\t}\n\telse\n\t\tassert(0);\n\n\tfree(fname);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "LAST_DISABLE_OPERATION last_disable = UNSUCCESSFUL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nLAST_DISABLE_OPERATION last_disable = UNSUCCESSFUL;\n\nstatic void disable_file(OPERATION op, const char *filename) {\n\tassert(filename);\n\tassert(op <OPERATION_MAX);\n\tlast_disable = UNSUCCESSFUL;\n\t\n\t// rebuild /run/firejail directory in case tmpfs was mounted on top of /run\n\tfs_build_firejail_dir();\n\t\n\t// Resolve all symlinks\n\tchar* fname = realpath(filename, NULL);\n\tif (fname == NULL && errno != EACCES) {\n\t\treturn;\n\t}\n\tif (fname == NULL && errno == EACCES) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Debug: no access to file %s, forcing mount\\n\", filename);\n\t\t// realpath and stat funtions will fail on FUSE filesystems\n\t\t// they don't seem to like a uid of 0\n\t\t// force mounting\n\t\tint rv = mount(RUN_RO_DIR, filename, \"none\", MS_BIND, \"mode=400,gid=0\");\n\t\tif (rv == 0)\n\t\t\tlast_disable = SUCCESSFUL;\n\t\telse {\n\t\t\trv = mount(RUN_RO_FILE, filename, \"none\", MS_BIND, \"mode=400,gid=0\");\n\t\t\tif (rv == 0)\n\t\t\t\tlast_disable = SUCCESSFUL;\n\t\t}\n\t\tif (last_disable == SUCCESSFUL) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Disable %s\\n\", filename);\n\t\t\tif (op == BLACKLIST_FILE)\n\t\t\t\tfs_logger2(\"blacklist\", filename);\n\t\t\telse\n\t\t\t\tfs_logger2(\"blacklist-nolog\", filename);\n\t\t}\n\t\telse {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Warning (blacklisting): %s is an invalid file, skipping...\\n\", filename);\n\t\t}\n\t\t\t\t\n\t\treturn;\n\t}\n\t\n\t// if the file is not present, do nothing\n\tstruct stat s;\n\tif (fname == NULL)\n\t\treturn;\n\tif (stat(fname, &s) == -1) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Warning: %s does not exist, skipping...\\n\", fname);\n\t\tfree(fname);\n\t\treturn;\n\t}\n\n\t// modify the file\n\tif (op == BLACKLIST_FILE || op == BLACKLIST_NOLOG) {\n\t\t// some distros put all executables under /usr/bin and make /bin a symbolic link\n\t\tif ((strcmp(fname, \"/bin\") == 0 || strcmp(fname, \"/usr/bin\") == 0) &&\n\t\t      is_link(filename) &&\n\t\t      S_ISDIR(s.st_mode))\n\t\t\tfprintf(stderr, \"Warning: %s directory link was not blacklisted\\n\", filename);\n\t\t\t\n\t\telse {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Disable %s\\n\", fname);\n\t\t\telse if (arg_debug_blacklists) {\n\t\t\t\tprintf(\"Disable %s\", fname);\n\t\t\t\tif (op == BLACKLIST_FILE)\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\telse\n\t\t\t\t\tprintf(\" - no logging\\n\");\n\t\t\t}\n\t\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\t\tif (mount(RUN_RO_DIR, fname, \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\t\t\t\terrExit(\"disable file\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (mount(RUN_RO_FILE, fname, \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\t\t\t\terrExit(\"disable file\");\n\t\t\t}\n\t\t\tlast_disable = SUCCESSFUL;\n\t\t\tif (op == BLACKLIST_FILE)\n\t\t\t\tfs_logger2(\"blacklist\", fname);\n\t\t\telse\n\t\t\t\tfs_logger2(\"blacklist-nolog\", fname);\n\t\t}\n\t}\n\telse if (op == MOUNT_READONLY) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting read-only %s\\n\", fname);\n\t\tfs_rdonly(fname);\n// todo: last_disable = SUCCESSFUL;\n\t}\n\telse if (op == MOUNT_RDWR) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting read-only %s\\n\", fname);\n\t\tfs_rdwr(fname);\n// todo: last_disable = SUCCESSFUL;\n\t}\n\telse if (op == MOUNT_NOEXEC) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting noexec %s\\n\", fname);\n\t\tfs_noexec(fname);\n// todo: last_disable = SUCCESSFUL;\n\t}\n\telse if (op == MOUNT_TMPFS) {\n\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Mounting tmpfs on %s\\n\", fname);\n\t\t\t// preserve owner and mode for the directory\n\t\t\tif (mount(\"tmpfs\", fname, \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME | MS_REC,  0) < 0)\n\t\t\t\terrExit(\"mounting tmpfs\");\n\t\t\t/* coverity[toctou] */\n\t\t\tif (chown(fname, s.st_uid, s.st_gid) == -1)\n\t\t\t\terrExit(\"mounting tmpfs chmod\");\n\t\t\tlast_disable = SUCCESSFUL;\n\t\t\tfs_logger2(\"tmpfs\", fname);\n\t\t}\n\t\telse\n\t\t\tprintf(\"Warning: %s is not a directory; cannot mount a tmpfs on top of it.\\n\", fname);\n\t}\n\telse\n\t\tassert(0);\n\n\tfree(fname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "RUN_FIREJAIL_X11_DIR",
            "&s"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "RUN_FIREJAIL_NAME_DIR",
            "&s"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "RUN_FIREJAIL_BANDWIDTH_DIR",
            "&s"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "RUN_FIREJAIL_NETWORK_DIR",
            "&s"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "fname",
            "&s"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&fname",
            "\"%s/.config/firejail\"",
            "cfg.homedir"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void disable_config(void) {\n\tstruct stat s;\n\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/.config/firejail\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (stat(fname, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, fname);\n\tfree(fname);\n\t\n\t// disable run time information\n\tif (stat(RUN_FIREJAIL_NETWORK_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_NETWORK_DIR);\n\tif (stat(RUN_FIREJAIL_BANDWIDTH_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_BANDWIDTH_DIR);\n\tif (stat(RUN_FIREJAIL_NAME_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_NAME_DIR);\n\tif (stat(RUN_FIREJAIL_X11_DIR, &s) == 0)\n\t\tdisable_file(BLACKLIST_FILE, RUN_FIREJAIL_X11_DIR);\n}"
  },
  {
    "function_name": "fs_proc_sys_dev_boot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
    "lines": "636-718",
    "snippet": "void fs_proc_sys_dev_boot(void) {\n\tif (arg_debug)\n\t\tprintf(\"Remounting /proc and /proc/sys filesystems\\n\");\n\tif (mount(\"proc\", \"/proc\", \"proc\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /proc\");\n\tfs_logger(\"remount /proc\");\n\n\t// remount /proc/sys readonly\n\tif (mount(\"/proc/sys\", \"/proc/sys\", NULL, MS_BIND | MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /proc/sys\");\n\n\tif (mount(NULL, \"/proc/sys\", NULL, MS_BIND | MS_REMOUNT | MS_RDONLY | MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /proc/sys\");\n\tfs_logger(\"read-only /proc/sys\");\n\n\n\t/* Mount a version of /sys that describes the network namespace */\n\tif (arg_debug)\n\t\tprintf(\"Remounting /sys directory\\n\");\n\tif (umount2(\"/sys\", MNT_DETACH) < 0)\n\t\tfprintf(stderr, \"Warning: failed to unmount /sys\\n\");\n\telse {\n\t\tif (mount(\"sysfs\", \"/sys\", \"sysfs\", MS_RDONLY|MS_NOSUID|MS_NOEXEC|MS_NODEV|MS_REC, NULL) < 0)\n\t\t\tfprintf(stderr, \"Warning: failed to mount /sys\\n\");\n\t\telse\n\t\t\tfs_logger(\"remount /sys\");\n\t}\n\t\t\n\tdisable_file(BLACKLIST_FILE, \"/sys/firmware\");\n\tdisable_file(BLACKLIST_FILE, \"/sys/hypervisor\");\n\t{ // allow user access to /sys/fs if \"--noblacklist=/sys/fs\" is present on the command line\n\t\tEUID_USER();\t\n\t\tprofile_add(\"blacklist /sys/fs\");\n\t\tEUID_ROOT();\n\t}\n\tdisable_file(BLACKLIST_FILE, \"/sys/module\");\n\tdisable_file(BLACKLIST_FILE, \"/sys/power\");\n\tdisable_file(BLACKLIST_FILE, \"/sys/kernel/debug\");\n\tdisable_file(BLACKLIST_FILE, \"/sys/kernel/vmcoreinfo\");\n\tdisable_file(BLACKLIST_FILE, \"/sys/kernel/uevent_helper\");\n\n\t// various /proc/sys files\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/security\");\t\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/efi/vars\");\t\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/fs/binfmt_misc\");\t\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/kernel/core_pattern\");\t\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/kernel/modprobe\");\t\n\tdisable_file(BLACKLIST_FILE, \"/proc/sysrq-trigger\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/kernel/hotplug\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/vm/panic_on_oom\");\n\n\t// various /proc files\n\tdisable_file(BLACKLIST_FILE, \"/proc/irq\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/bus\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/config.gz\");\t\n\tdisable_file(BLACKLIST_FILE, \"/proc/sched_debug\");\t\n\tdisable_file(BLACKLIST_FILE, \"/proc/timer_list\");\t\n\tdisable_file(BLACKLIST_FILE, \"/proc/timer_stats\");\t\n\tdisable_file(BLACKLIST_FILE, \"/proc/kcore\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/kallsyms\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/mem\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/kmem\");\n\t\n\t// remove kernel symbol information\n\tif (!arg_allow_debuggers) {\n\t\tdisable_file(BLACKLIST_FILE, \"/usr/src/linux\");\n\t\tdisable_file(BLACKLIST_FILE, \"/lib/modules\");\n\t\tdisable_file(BLACKLIST_FILE, \"/usr/lib/debug\");\n\t\tdisable_file(BLACKLIST_FILE, \"/boot\");\n\t}\n\t\t\n\t// disable /selinux\n\tdisable_file(BLACKLIST_FILE, \"/selinux\");\n\t\n\t// disable /dev/port\n\tdisable_file(BLACKLIST_FILE, \"/dev/port\");\n\t\n\tif (getuid() != 0) {\n\t\t// disable /dev/kmsg and /proc/kmsg\n\t\tdisable_file(BLACKLIST_FILE, \"/dev/kmsg\");\n\t\tdisable_file(BLACKLIST_FILE, \"/proc/kmsg\");\n\t}\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "disable_file",
          "args": [
            "BLACKLIST_FILE",
            "\"/proc/kmsg\""
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "disable_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
          "lines": "200-325",
          "snippet": "static void disable_file(OPERATION op, const char *filename) {\n\tassert(filename);\n\tassert(op <OPERATION_MAX);\n\tlast_disable = UNSUCCESSFUL;\n\t\n\t// rebuild /run/firejail directory in case tmpfs was mounted on top of /run\n\tfs_build_firejail_dir();\n\t\n\t// Resolve all symlinks\n\tchar* fname = realpath(filename, NULL);\n\tif (fname == NULL && errno != EACCES) {\n\t\treturn;\n\t}\n\tif (fname == NULL && errno == EACCES) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Debug: no access to file %s, forcing mount\\n\", filename);\n\t\t// realpath and stat funtions will fail on FUSE filesystems\n\t\t// they don't seem to like a uid of 0\n\t\t// force mounting\n\t\tint rv = mount(RUN_RO_DIR, filename, \"none\", MS_BIND, \"mode=400,gid=0\");\n\t\tif (rv == 0)\n\t\t\tlast_disable = SUCCESSFUL;\n\t\telse {\n\t\t\trv = mount(RUN_RO_FILE, filename, \"none\", MS_BIND, \"mode=400,gid=0\");\n\t\t\tif (rv == 0)\n\t\t\t\tlast_disable = SUCCESSFUL;\n\t\t}\n\t\tif (last_disable == SUCCESSFUL) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Disable %s\\n\", filename);\n\t\t\tif (op == BLACKLIST_FILE)\n\t\t\t\tfs_logger2(\"blacklist\", filename);\n\t\t\telse\n\t\t\t\tfs_logger2(\"blacklist-nolog\", filename);\n\t\t}\n\t\telse {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Warning (blacklisting): %s is an invalid file, skipping...\\n\", filename);\n\t\t}\n\t\t\t\t\n\t\treturn;\n\t}\n\t\n\t// if the file is not present, do nothing\n\tstruct stat s;\n\tif (fname == NULL)\n\t\treturn;\n\tif (stat(fname, &s) == -1) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Warning: %s does not exist, skipping...\\n\", fname);\n\t\tfree(fname);\n\t\treturn;\n\t}\n\n\t// modify the file\n\tif (op == BLACKLIST_FILE || op == BLACKLIST_NOLOG) {\n\t\t// some distros put all executables under /usr/bin and make /bin a symbolic link\n\t\tif ((strcmp(fname, \"/bin\") == 0 || strcmp(fname, \"/usr/bin\") == 0) &&\n\t\t      is_link(filename) &&\n\t\t      S_ISDIR(s.st_mode))\n\t\t\tfprintf(stderr, \"Warning: %s directory link was not blacklisted\\n\", filename);\n\t\t\t\n\t\telse {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Disable %s\\n\", fname);\n\t\t\telse if (arg_debug_blacklists) {\n\t\t\t\tprintf(\"Disable %s\", fname);\n\t\t\t\tif (op == BLACKLIST_FILE)\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\telse\n\t\t\t\t\tprintf(\" - no logging\\n\");\n\t\t\t}\n\t\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\t\tif (mount(RUN_RO_DIR, fname, \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\t\t\t\terrExit(\"disable file\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (mount(RUN_RO_FILE, fname, \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\t\t\t\terrExit(\"disable file\");\n\t\t\t}\n\t\t\tlast_disable = SUCCESSFUL;\n\t\t\tif (op == BLACKLIST_FILE)\n\t\t\t\tfs_logger2(\"blacklist\", fname);\n\t\t\telse\n\t\t\t\tfs_logger2(\"blacklist-nolog\", fname);\n\t\t}\n\t}\n\telse if (op == MOUNT_READONLY) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting read-only %s\\n\", fname);\n\t\tfs_rdonly(fname);\n// todo: last_disable = SUCCESSFUL;\n\t}\n\telse if (op == MOUNT_RDWR) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting read-only %s\\n\", fname);\n\t\tfs_rdwr(fname);\n// todo: last_disable = SUCCESSFUL;\n\t}\n\telse if (op == MOUNT_NOEXEC) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting noexec %s\\n\", fname);\n\t\tfs_noexec(fname);\n// todo: last_disable = SUCCESSFUL;\n\t}\n\telse if (op == MOUNT_TMPFS) {\n\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Mounting tmpfs on %s\\n\", fname);\n\t\t\t// preserve owner and mode for the directory\n\t\t\tif (mount(\"tmpfs\", fname, \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME | MS_REC,  0) < 0)\n\t\t\t\terrExit(\"mounting tmpfs\");\n\t\t\t/* coverity[toctou] */\n\t\t\tif (chown(fname, s.st_uid, s.st_gid) == -1)\n\t\t\t\terrExit(\"mounting tmpfs chmod\");\n\t\t\tlast_disable = SUCCESSFUL;\n\t\t\tfs_logger2(\"tmpfs\", fname);\n\t\t}\n\t\telse\n\t\t\tprintf(\"Warning: %s is not a directory; cannot mount a tmpfs on top of it.\\n\", fname);\n\t}\n\telse\n\t\tassert(0);\n\n\tfree(fname);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "LAST_DISABLE_OPERATION last_disable = UNSUCCESSFUL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nLAST_DISABLE_OPERATION last_disable = UNSUCCESSFUL;\n\nstatic void disable_file(OPERATION op, const char *filename) {\n\tassert(filename);\n\tassert(op <OPERATION_MAX);\n\tlast_disable = UNSUCCESSFUL;\n\t\n\t// rebuild /run/firejail directory in case tmpfs was mounted on top of /run\n\tfs_build_firejail_dir();\n\t\n\t// Resolve all symlinks\n\tchar* fname = realpath(filename, NULL);\n\tif (fname == NULL && errno != EACCES) {\n\t\treturn;\n\t}\n\tif (fname == NULL && errno == EACCES) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Debug: no access to file %s, forcing mount\\n\", filename);\n\t\t// realpath and stat funtions will fail on FUSE filesystems\n\t\t// they don't seem to like a uid of 0\n\t\t// force mounting\n\t\tint rv = mount(RUN_RO_DIR, filename, \"none\", MS_BIND, \"mode=400,gid=0\");\n\t\tif (rv == 0)\n\t\t\tlast_disable = SUCCESSFUL;\n\t\telse {\n\t\t\trv = mount(RUN_RO_FILE, filename, \"none\", MS_BIND, \"mode=400,gid=0\");\n\t\t\tif (rv == 0)\n\t\t\t\tlast_disable = SUCCESSFUL;\n\t\t}\n\t\tif (last_disable == SUCCESSFUL) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Disable %s\\n\", filename);\n\t\t\tif (op == BLACKLIST_FILE)\n\t\t\t\tfs_logger2(\"blacklist\", filename);\n\t\t\telse\n\t\t\t\tfs_logger2(\"blacklist-nolog\", filename);\n\t\t}\n\t\telse {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Warning (blacklisting): %s is an invalid file, skipping...\\n\", filename);\n\t\t}\n\t\t\t\t\n\t\treturn;\n\t}\n\t\n\t// if the file is not present, do nothing\n\tstruct stat s;\n\tif (fname == NULL)\n\t\treturn;\n\tif (stat(fname, &s) == -1) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Warning: %s does not exist, skipping...\\n\", fname);\n\t\tfree(fname);\n\t\treturn;\n\t}\n\n\t// modify the file\n\tif (op == BLACKLIST_FILE || op == BLACKLIST_NOLOG) {\n\t\t// some distros put all executables under /usr/bin and make /bin a symbolic link\n\t\tif ((strcmp(fname, \"/bin\") == 0 || strcmp(fname, \"/usr/bin\") == 0) &&\n\t\t      is_link(filename) &&\n\t\t      S_ISDIR(s.st_mode))\n\t\t\tfprintf(stderr, \"Warning: %s directory link was not blacklisted\\n\", filename);\n\t\t\t\n\t\telse {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Disable %s\\n\", fname);\n\t\t\telse if (arg_debug_blacklists) {\n\t\t\t\tprintf(\"Disable %s\", fname);\n\t\t\t\tif (op == BLACKLIST_FILE)\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\telse\n\t\t\t\t\tprintf(\" - no logging\\n\");\n\t\t\t}\n\t\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\t\tif (mount(RUN_RO_DIR, fname, \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\t\t\t\terrExit(\"disable file\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (mount(RUN_RO_FILE, fname, \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\t\t\t\terrExit(\"disable file\");\n\t\t\t}\n\t\t\tlast_disable = SUCCESSFUL;\n\t\t\tif (op == BLACKLIST_FILE)\n\t\t\t\tfs_logger2(\"blacklist\", fname);\n\t\t\telse\n\t\t\t\tfs_logger2(\"blacklist-nolog\", fname);\n\t\t}\n\t}\n\telse if (op == MOUNT_READONLY) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting read-only %s\\n\", fname);\n\t\tfs_rdonly(fname);\n// todo: last_disable = SUCCESSFUL;\n\t}\n\telse if (op == MOUNT_RDWR) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting read-only %s\\n\", fname);\n\t\tfs_rdwr(fname);\n// todo: last_disable = SUCCESSFUL;\n\t}\n\telse if (op == MOUNT_NOEXEC) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting noexec %s\\n\", fname);\n\t\tfs_noexec(fname);\n// todo: last_disable = SUCCESSFUL;\n\t}\n\telse if (op == MOUNT_TMPFS) {\n\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Mounting tmpfs on %s\\n\", fname);\n\t\t\t// preserve owner and mode for the directory\n\t\t\tif (mount(\"tmpfs\", fname, \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME | MS_REC,  0) < 0)\n\t\t\t\terrExit(\"mounting tmpfs\");\n\t\t\t/* coverity[toctou] */\n\t\t\tif (chown(fname, s.st_uid, s.st_gid) == -1)\n\t\t\t\terrExit(\"mounting tmpfs chmod\");\n\t\t\tlast_disable = SUCCESSFUL;\n\t\t\tfs_logger2(\"tmpfs\", fname);\n\t\t}\n\t\telse\n\t\t\tprintf(\"Warning: %s is not a directory; cannot mount a tmpfs on top of it.\\n\", fname);\n\t}\n\telse\n\t\tassert(0);\n\n\tfree(fname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ROOT",
          "args": [],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "profile_add",
          "args": [
            "\"blacklist /sys/fs\""
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "profile_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/profile.c",
          "lines": "919-938",
          "snippet": "void profile_add(char *str) {\n\tEUID_ASSERT();\n\t\n\tProfileEntry *prf = malloc(sizeof(ProfileEntry));\n\tif (!prf)\n\t\terrExit(\"malloc\");\n\tmemset(prf, 0, sizeof(ProfileEntry));\n\tprf->next = NULL;\n\tprf->data = str;\t\n\n\t// add prf to the list\n\tif (cfg.profile == NULL) {\n\t\tcfg.profile = prf;\n\t\treturn;\n\t}\n\tProfileEntry *ptr = cfg.profile;\n\twhile (ptr->next != NULL)\n\t\tptr = ptr->next;\n\tptr->next = prf;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <dirent.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <dirent.h>\n#include \"firejail.h\"\n\nvoid profile_add(char *str) {\n\tEUID_ASSERT();\n\t\n\tProfileEntry *prf = malloc(sizeof(ProfileEntry));\n\tif (!prf)\n\t\terrExit(\"malloc\");\n\tmemset(prf, 0, sizeof(ProfileEntry));\n\tprf->next = NULL;\n\tprf->data = str;\t\n\n\t// add prf to the list\n\tif (cfg.profile == NULL) {\n\t\tcfg.profile = prf;\n\t\treturn;\n\t}\n\tProfileEntry *ptr = cfg.profile;\n\twhile (ptr->next != NULL)\n\t\tptr = ptr->next;\n\tptr->next = prf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EUID_USER",
          "args": [],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_logger",
          "args": [
            "\"remount /sys\""
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger_print_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_logger.c",
          "lines": "136-189",
          "snippet": "void fs_logger_print_log(pid_t pid) {\n\tEUID_ASSERT();\n\n\t// if the pid is that of a firejail  process, use the pid of the first child process\n\tEUID_ROOT();\n\tchar *comm = pid_proc_comm(pid);\n\tEUID_USER();\n\tif (comm) {\n\t\tif (strcmp(comm, \"firejail\") == 0) {\n\t\t\tpid_t child;\n\t\t\tif (find_child(pid, &child) == 0) {\n\t\t\t\tpid = child;\n\t\t\t}\n\t\t}\n\t\tfree(comm);\n\t}\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission denied\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// print RUN_FSLOGGER_FILE\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_FSLOGGER_FILE) == -1)\n\t\terrExit(\"asprintf\");\n\n\tEUID_ROOT();\n\tstruct stat s;\n\tif (stat(fname, &s) == -1) {\n\t\tfprintf(stderr, \"Error: Cannot access filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: Cannot open filesystem log\\n\");\n\t\texit(1);\n\t}\n\t\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp))\n\t\tprintf(\"%s\", buf);\n\tfclose(fp);\n\tfree(fname);\n\n\texit(0);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAXBUF 4098"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\n#define MAXBUF 4098\n\nvoid fs_logger_print_log(pid_t pid) {\n\tEUID_ASSERT();\n\n\t// if the pid is that of a firejail  process, use the pid of the first child process\n\tEUID_ROOT();\n\tchar *comm = pid_proc_comm(pid);\n\tEUID_USER();\n\tif (comm) {\n\t\tif (strcmp(comm, \"firejail\") == 0) {\n\t\t\tpid_t child;\n\t\t\tif (find_child(pid, &child) == 0) {\n\t\t\t\tpid = child;\n\t\t\t}\n\t\t}\n\t\tfree(comm);\n\t}\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission denied\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// print RUN_FSLOGGER_FILE\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_FSLOGGER_FILE) == -1)\n\t\terrExit(\"asprintf\");\n\n\tEUID_ROOT();\n\tstruct stat s;\n\tif (stat(fname, &s) == -1) {\n\t\tfprintf(stderr, \"Error: Cannot access filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: Cannot open filesystem log\\n\");\n\t\texit(1);\n\t}\n\t\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp))\n\t\tprintf(\"%s\", buf);\n\tfclose(fp);\n\tfree(fname);\n\n\texit(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: failed to mount /sys\\n\""
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"sysfs\"",
            "\"/sys\"",
            "\"sysfs\"",
            "MS_RDONLY|MS_NOSUID|MS_NOEXEC|MS_NODEV|MS_REC",
            "NULL"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: failed to unmount /sys\\n\""
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umount2",
          "args": [
            "\"/sys\"",
            "MNT_DETACH"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Remounting /sys directory\\n\""
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mounting /proc/sys\""
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "NULL",
            "\"/proc/sys\"",
            "NULL",
            "MS_BIND | MS_REMOUNT | MS_RDONLY | MS_REC",
            "NULL"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mounting /proc/sys\""
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"/proc/sys\"",
            "\"/proc/sys\"",
            "NULL",
            "MS_BIND | MS_REC",
            "NULL"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mounting /proc\""
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"proc\"",
            "\"/proc\"",
            "\"proc\"",
            "MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_REC",
            "NULL"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Remounting /proc and /proc/sys filesystems\\n\""
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_proc_sys_dev_boot(void) {\n\tif (arg_debug)\n\t\tprintf(\"Remounting /proc and /proc/sys filesystems\\n\");\n\tif (mount(\"proc\", \"/proc\", \"proc\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /proc\");\n\tfs_logger(\"remount /proc\");\n\n\t// remount /proc/sys readonly\n\tif (mount(\"/proc/sys\", \"/proc/sys\", NULL, MS_BIND | MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /proc/sys\");\n\n\tif (mount(NULL, \"/proc/sys\", NULL, MS_BIND | MS_REMOUNT | MS_RDONLY | MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /proc/sys\");\n\tfs_logger(\"read-only /proc/sys\");\n\n\n\t/* Mount a version of /sys that describes the network namespace */\n\tif (arg_debug)\n\t\tprintf(\"Remounting /sys directory\\n\");\n\tif (umount2(\"/sys\", MNT_DETACH) < 0)\n\t\tfprintf(stderr, \"Warning: failed to unmount /sys\\n\");\n\telse {\n\t\tif (mount(\"sysfs\", \"/sys\", \"sysfs\", MS_RDONLY|MS_NOSUID|MS_NOEXEC|MS_NODEV|MS_REC, NULL) < 0)\n\t\t\tfprintf(stderr, \"Warning: failed to mount /sys\\n\");\n\t\telse\n\t\t\tfs_logger(\"remount /sys\");\n\t}\n\t\t\n\tdisable_file(BLACKLIST_FILE, \"/sys/firmware\");\n\tdisable_file(BLACKLIST_FILE, \"/sys/hypervisor\");\n\t{ // allow user access to /sys/fs if \"--noblacklist=/sys/fs\" is present on the command line\n\t\tEUID_USER();\t\n\t\tprofile_add(\"blacklist /sys/fs\");\n\t\tEUID_ROOT();\n\t}\n\tdisable_file(BLACKLIST_FILE, \"/sys/module\");\n\tdisable_file(BLACKLIST_FILE, \"/sys/power\");\n\tdisable_file(BLACKLIST_FILE, \"/sys/kernel/debug\");\n\tdisable_file(BLACKLIST_FILE, \"/sys/kernel/vmcoreinfo\");\n\tdisable_file(BLACKLIST_FILE, \"/sys/kernel/uevent_helper\");\n\n\t// various /proc/sys files\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/security\");\t\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/efi/vars\");\t\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/fs/binfmt_misc\");\t\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/kernel/core_pattern\");\t\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/kernel/modprobe\");\t\n\tdisable_file(BLACKLIST_FILE, \"/proc/sysrq-trigger\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/kernel/hotplug\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/vm/panic_on_oom\");\n\n\t// various /proc files\n\tdisable_file(BLACKLIST_FILE, \"/proc/irq\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/bus\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/config.gz\");\t\n\tdisable_file(BLACKLIST_FILE, \"/proc/sched_debug\");\t\n\tdisable_file(BLACKLIST_FILE, \"/proc/timer_list\");\t\n\tdisable_file(BLACKLIST_FILE, \"/proc/timer_stats\");\t\n\tdisable_file(BLACKLIST_FILE, \"/proc/kcore\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/kallsyms\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/mem\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/kmem\");\n\t\n\t// remove kernel symbol information\n\tif (!arg_allow_debuggers) {\n\t\tdisable_file(BLACKLIST_FILE, \"/usr/src/linux\");\n\t\tdisable_file(BLACKLIST_FILE, \"/lib/modules\");\n\t\tdisable_file(BLACKLIST_FILE, \"/usr/lib/debug\");\n\t\tdisable_file(BLACKLIST_FILE, \"/boot\");\n\t}\n\t\t\n\t// disable /selinux\n\tdisable_file(BLACKLIST_FILE, \"/selinux\");\n\t\n\t// disable /dev/port\n\tdisable_file(BLACKLIST_FILE, \"/dev/port\");\n\t\n\tif (getuid() != 0) {\n\t\t// disable /dev/kmsg and /proc/kmsg\n\t\tdisable_file(BLACKLIST_FILE, \"/dev/kmsg\");\n\t\tdisable_file(BLACKLIST_FILE, \"/proc/kmsg\");\n\t}\n}"
  },
  {
    "function_name": "fs_rdonly_noexit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
    "lines": "615-633",
    "snippet": "void fs_rdonly_noexit(const char *dir) {\n\tassert(dir);\n\t// check directory exists\n\tstruct stat s;\n\tint rv = stat(dir, &s);\n\tif (rv == 0) {\n\t\tint merr = 0;\n\t\t// mount --bind /bin /bin\n\t\tif (mount(dir, dir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\tmerr = 1;\n\t\t// mount --bind -o remount,ro /bin\n\t\tif (mount(NULL, dir, NULL, MS_BIND|MS_REMOUNT|MS_RDONLY|MS_REC, NULL) < 0)\n\t\t\tmerr = 1;\n\t\tif (merr)\n\t\t\tfprintf(stderr, \"Warning: cannot mount %s read-only\\n\", dir); \n\t\telse\n\t\t\tfs_logger2(\"read-only\", dir);\n\t}\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void fs_rdwr(const char *dir);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_logger2",
          "args": [
            "\"read-only\"",
            "dir"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger2int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_logger.c",
          "lines": "73-80",
          "snippet": "void fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: cannot mount %s read-only\\n\"",
            "dir"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "NULL",
            "dir",
            "NULL",
            "MS_BIND|MS_REMOUNT|MS_RDONLY|MS_REC",
            "NULL"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "dir",
            "dir",
            "NULL",
            "MS_BIND|MS_REC",
            "NULL"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "dir",
            "&s"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "dir"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void fs_rdwr(const char *dir);\n\nvoid fs_rdonly_noexit(const char *dir) {\n\tassert(dir);\n\t// check directory exists\n\tstruct stat s;\n\tint rv = stat(dir, &s);\n\tif (rv == 0) {\n\t\tint merr = 0;\n\t\t// mount --bind /bin /bin\n\t\tif (mount(dir, dir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\tmerr = 1;\n\t\t// mount --bind -o remount,ro /bin\n\t\tif (mount(NULL, dir, NULL, MS_BIND|MS_REMOUNT|MS_RDONLY|MS_REC, NULL) < 0)\n\t\t\tmerr = 1;\n\t\tif (merr)\n\t\t\tfprintf(stderr, \"Warning: cannot mount %s read-only\\n\", dir); \n\t\telse\n\t\t\tfs_logger2(\"read-only\", dir);\n\t}\n}"
  },
  {
    "function_name": "fs_noexec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
    "lines": "597-611",
    "snippet": "void fs_noexec(const char *dir) {\n\tassert(dir);\n\t// check directory exists\n\tstruct stat s;\n\tint rv = stat(dir, &s);\n\tif (rv == 0) {\n\t\t// mount --bind /bin /bin\n\t\tif (mount(dir, dir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mount noexec\");\n\t\t// mount --bind -o remount,ro /bin\n\t\tif (mount(NULL, dir, NULL, MS_BIND|MS_REMOUNT|MS_NOEXEC|MS_NODEV|MS_NOSUID|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mount read-only\");\n\t\tfs_logger2(\"noexec\", dir);\n\t}\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void fs_rdwr(const char *dir);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_logger2",
          "args": [
            "\"noexec\"",
            "dir"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger2int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_logger.c",
          "lines": "73-80",
          "snippet": "void fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount read-only\""
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "NULL",
            "dir",
            "NULL",
            "MS_BIND|MS_REMOUNT|MS_NOEXEC|MS_NODEV|MS_NOSUID|MS_REC",
            "NULL"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount noexec\""
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "dir",
            "dir",
            "NULL",
            "MS_BIND|MS_REC",
            "NULL"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "dir",
            "&s"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "dir"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void fs_rdwr(const char *dir);\n\nvoid fs_noexec(const char *dir) {\n\tassert(dir);\n\t// check directory exists\n\tstruct stat s;\n\tint rv = stat(dir, &s);\n\tif (rv == 0) {\n\t\t// mount --bind /bin /bin\n\t\tif (mount(dir, dir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mount noexec\");\n\t\t// mount --bind -o remount,ro /bin\n\t\tif (mount(NULL, dir, NULL, MS_BIND|MS_REMOUNT|MS_NOEXEC|MS_NODEV|MS_NOSUID|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mount read-only\");\n\t\tfs_logger2(\"noexec\", dir);\n\t}\n}"
  },
  {
    "function_name": "fs_rdwr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
    "lines": "574-595",
    "snippet": "static void fs_rdwr(const char *dir) {\n\tassert(dir);\n\t// check directory exists\n\tstruct stat s;\n\tint rv = stat(dir, &s);\n\tif (rv == 0) {\n\t\t// if the file is outside /home directory, allow only root user\n\t\tuid_t u = getuid();\n\t\tif (u != 0 && s.st_uid != u) {\n\t\t\tfprintf(stderr, \"Warning: you are not allowed to change %s to read-write\\n\", dir);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// mount --bind /bin /bin\n\t\tif (mount(dir, dir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mount read-write\");\n\t\t// mount --bind -o remount,rw /bin\n\t\tif (mount(NULL, dir, NULL, MS_BIND|MS_REMOUNT|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mount read-write\");\n\t\tfs_logger2(\"read-write\", dir);\n\t}\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void fs_rdwr(const char *dir);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_logger2",
          "args": [
            "\"read-write\"",
            "dir"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger2int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_logger.c",
          "lines": "73-80",
          "snippet": "void fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount read-write\""
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "NULL",
            "dir",
            "NULL",
            "MS_BIND|MS_REMOUNT|MS_REC",
            "NULL"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount read-write\""
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "dir",
            "dir",
            "NULL",
            "MS_BIND|MS_REC",
            "NULL"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: you are not allowed to change %s to read-write\\n\"",
            "dir"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "dir",
            "&s"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "dir"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void fs_rdwr(const char *dir);\n\nstatic void fs_rdwr(const char *dir) {\n\tassert(dir);\n\t// check directory exists\n\tstruct stat s;\n\tint rv = stat(dir, &s);\n\tif (rv == 0) {\n\t\t// if the file is outside /home directory, allow only root user\n\t\tuid_t u = getuid();\n\t\tif (u != 0 && s.st_uid != u) {\n\t\t\tfprintf(stderr, \"Warning: you are not allowed to change %s to read-write\\n\", dir);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// mount --bind /bin /bin\n\t\tif (mount(dir, dir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mount read-write\");\n\t\t// mount --bind -o remount,rw /bin\n\t\tif (mount(NULL, dir, NULL, MS_BIND|MS_REMOUNT|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mount read-write\");\n\t\tfs_logger2(\"read-write\", dir);\n\t}\n}"
  },
  {
    "function_name": "fs_rdonly",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
    "lines": "558-572",
    "snippet": "void fs_rdonly(const char *dir) {\n\tassert(dir);\n\t// check directory exists\n\tstruct stat s;\n\tint rv = stat(dir, &s);\n\tif (rv == 0) {\n\t\t// mount --bind /bin /bin\n\t\tif (mount(dir, dir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mount read-only\");\n\t\t// mount --bind -o remount,ro /bin\n\t\tif (mount(NULL, dir, NULL, MS_BIND|MS_REMOUNT|MS_RDONLY|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mount read-only\");\n\t\tfs_logger2(\"read-only\", dir);\n\t}\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void fs_rdwr(const char *dir);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_logger2",
          "args": [
            "\"read-only\"",
            "dir"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger2int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_logger.c",
          "lines": "73-80",
          "snippet": "void fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount read-only\""
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "NULL",
            "dir",
            "NULL",
            "MS_BIND|MS_REMOUNT|MS_RDONLY|MS_REC",
            "NULL"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount read-only\""
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "dir",
            "dir",
            "NULL",
            "MS_BIND|MS_REC",
            "NULL"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "dir",
            "&s"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "dir"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void fs_rdwr(const char *dir);\n\nvoid fs_rdonly(const char *dir) {\n\tassert(dir);\n\t// check directory exists\n\tstruct stat s;\n\tint rv = stat(dir, &s);\n\tif (rv == 0) {\n\t\t// mount --bind /bin /bin\n\t\tif (mount(dir, dir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mount read-only\");\n\t\t// mount --bind -o remount,ro /bin\n\t\tif (mount(NULL, dir, NULL, MS_BIND|MS_REMOUNT|MS_RDONLY|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mount read-only\");\n\t\tfs_logger2(\"read-only\", dir);\n\t}\n}"
  },
  {
    "function_name": "fs_blacklist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
    "lines": "373-551",
    "snippet": "void fs_blacklist(void) {\n\tchar *homedir = cfg.homedir;\n\tassert(homedir);\n\tProfileEntry *entry = cfg.profile;\n\tif (!entry)\n\t\treturn;\n\t\t\n\tsize_t noblacklist_c = 0;\n\tsize_t noblacklist_m = 32;\n\tchar **noblacklist = calloc(noblacklist_m, sizeof(*noblacklist));\n\n\tif (noblacklist == NULL)\n\t\terrExit(\"failed allocating memory for noblacklist entries\");\n\n\twhile (entry) {\n\t\tOPERATION op = OPERATION_MAX;\n\t\tchar *ptr;\n\n\t\t// whitelist commands handled by fs_whitelist()\n\t\tif (strncmp(entry->data, \"whitelist \", 10) == 0 || *entry->data == '\\0') {\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// process bind command\n\t\tif (strncmp(entry->data, \"bind \", 5) == 0)  {\n\t\t\tchar *dname1 = entry->data + 5;\n\t\t\tchar *dname2 = split_comma(dname1);\n\t\t\tif (dname2 == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: second directory missing in bind command\\n\");\n\t\t\t\tentry = entry->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstruct stat s;\n\t\t\tif (stat(dname1, &s) == -1) {\n\t\t\t\tfprintf(stderr, \"Error: cannot find %s for bind command\\n\", dname1);\n\t\t\t\tentry = entry->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (stat(dname2, &s) == -1) {\n\t\t\t\tfprintf(stderr, \"Error: cannot find %s for bind command\\n\", dname2);\n\t\t\t\tentry = entry->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t// mount --bind olddir newdir\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Mount-bind %s on top of %s\\n\", dname1, dname2);\n\t\t\t// preserve dname2 mode and ownership\n\t\t\tif (mount(dname1, dname2, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\t\t\t/* coverity[toctou] */\n\t\t\tif (chown(dname2, s.st_uid, s.st_gid) == -1)\n\t\t\t\terrExit(\"mount-bind chown\");\n\t\t\t/* coverity[toctou] */\n\t\t\tif (chmod(dname2, s.st_mode) == -1)\n\t\t\t\terrExit(\"mount-bind chmod\");\n\t\t\t\t\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Process noblacklist command\n\t\tif (strncmp(entry->data, \"noblacklist \", 12) == 0) {\n\t\t\tchar **paths = build_paths();\n\n\t\t\tchar *enames[sizeof(paths)+1] = {0};\n\t\t\tint i = 0;\n\n\t\t\tif (strncmp(entry->data + 12, \"${PATH}\", 7) == 0) {\n\t\t\t\t// expand ${PATH} macro\n\t\t\t\twhile (paths[i] != NULL) {\n\t\t\t\t\tif (asprintf(&enames[i], \"%s%s\", paths[i], entry->data + 19) == -1)\n\t\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// expand ${HOME} macro if found or pass as is\n\t\t\t\tenames[0] = expand_home(entry->data + 12, homedir);\n\t\t\t\tenames[1] = NULL;\n\t\t\t}\n\n\t\t\ti = 0;\n\t\t\twhile (enames[i] != NULL) {\n\t\t\t\tif (noblacklist_c >= noblacklist_m) {\n\t\t\t\t\tnoblacklist_m *= 2;\n\t\t\t\t\tnoblacklist = realloc(noblacklist, sizeof(*noblacklist) * noblacklist_m);\n\t\t\t\t\tif (noblacklist == NULL)\n\t\t\t\t\t\terrExit(\"failed increasing memory for noblacklist entries\");\n\t\t\t\t}\n\t\t\t\tnoblacklist[noblacklist_c++] = enames[i];\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\twhile (enames[i] != NULL) {\n\t\t\t\tfree(enames[i]);\n\t\t\t}\n\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// process blacklist command\n\t\tif (strncmp(entry->data, \"blacklist \", 10) == 0)  {\n\t\t\tptr = entry->data + 10;\n\t\t\top = BLACKLIST_FILE;\n\t\t}\n\t\telse if (strncmp(entry->data, \"blacklist-nolog \", 16) == 0)  {\n\t\t\tptr = entry->data + 16;\n\t\t\top = BLACKLIST_NOLOG;\n\t\t}\n\t\telse if (strncmp(entry->data, \"read-only \", 10) == 0) {\n\t\t\tptr = entry->data + 10;\n\t\t\top = MOUNT_READONLY;\n\t\t}\t\t\t\n\t\telse if (strncmp(entry->data, \"read-write \", 11) == 0) {\n\t\t\tptr = entry->data + 11;\n\t\t\top = MOUNT_RDWR;\n\t\t}\t\t\t\n\t\telse if (strncmp(entry->data, \"noexec \", 7) == 0) {\n\t\t\tptr = entry->data + 7;\n\t\t\top = MOUNT_NOEXEC;\n\t\t}\t\t\t\n\t\telse if (strncmp(entry->data, \"tmpfs \", 6) == 0) {\n\t\t\tptr = entry->data + 6;\n\t\t\top = MOUNT_TMPFS;\n\t\t}\t\t\t\n\t\telse if (strncmp(entry->data, \"mkdir \", 6) == 0) {\n\t\t\tEUID_USER();\n\t\t\tfs_mkdir(entry->data + 6);\n\t\t\tEUID_ROOT();\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\t\t\t\n\t\telse if (strncmp(entry->data, \"mkfile \", 7) == 0) {\n\t\t\tEUID_USER();\n\t\t\tfs_mkfile(entry->data + 7);\n\t\t\tEUID_ROOT();\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\t\t\t\n\t\telse {\n\t\t\tfprintf(stderr, \"Error: invalid profile line %s\\n\", entry->data);\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// replace home macro in blacklist array\n\t\tchar *new_name = expand_home(ptr, homedir);\n\t\tptr = new_name;\n\n\t\t// expand path macro - look for the file in /usr/local/bin,  /usr/local/sbin, /bin, /usr/bin, /sbin and  /usr/sbin directories\n\t\tif (ptr) {\n\t\t\tif (strncmp(ptr, \"${PATH}\", 7) == 0) {\n\t\t\t\tchar *fname = ptr + 7;\n\t\t\t\tsize_t fname_len = strlen(fname);\n\t\t\t\tchar **paths = build_paths(); //{\"/usr/local/bin\", \"/usr/local/sbin\", \"/bin\", \"/usr/bin/\", \"/sbin\", \"/usr/sbin\", NULL};\n\t\t\t\tint i = 0;\n\t\t\t\twhile (paths[i] != NULL) {\n\t\t\t\t\tchar *path = paths[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tchar newname[strlen(path) + fname_len + 1];\n\t\t\t\t\tsprintf(newname, \"%s%s\", path, fname);\n\t\t\t\t\tglobbing(op, newname, (const char**)noblacklist, noblacklist_c);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tglobbing(op, ptr, (const char**)noblacklist, noblacklist_c);\n\t\t}\n\n\t\tif (new_name)\n\t\t\tfree(new_name);\n\t\tentry = entry->next;\n\t}\n\n\tsize_t i;\n\tfor (i = 0; i < noblacklist_c; i++) free(noblacklist[i]);\n        free(noblacklist);\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "noblacklist"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "noblacklist[i]"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "new_name"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "globbing",
          "args": [
            "op",
            "ptr",
            "(const char**)noblacklist",
            "noblacklist_c"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "globbing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
          "lines": "328-369",
          "snippet": "static void globbing(OPERATION op, const char *pattern, const char *noblacklist[], size_t noblacklist_len) {\n\tassert(pattern);\n\n\tglob_t globbuf;\n\t// Profiles contain blacklists for files that might not exist on a user's machine.\n\t// GLOB_NOCHECK makes that okay.\n\tint globerr = glob(pattern, GLOB_NOCHECK | GLOB_NOSORT | GLOB_PERIOD, NULL, &globbuf);\n\tif (globerr) {\n\t\tfprintf(stderr, \"Error: failed to glob pattern %s\\n\", pattern);\n\t\texit(1);\n\t}\n\n\tsize_t i, j;\n\tfor (i = 0; i < globbuf.gl_pathc; i++) {\n\t\tchar *path = globbuf.gl_pathv[i];\n\t\tassert(path);\n\t\t// /home/me/.* can glob to /home/me/.. which would blacklist /home/\n\t\tconst char *base = gnu_basename(path);\n\t\tif (strcmp(base, \".\") == 0 || strcmp(base, \"..\") == 0)\n\t\t\tcontinue;\n\t\t// noblacklist is expected to be short in normal cases, so stupid and correct brute force is okay\n\t\tbool okay_to_blacklist = true;\n\t\tfor (j = 0; j < noblacklist_len; j++) {\n\t\t\tint result = fnmatch(noblacklist[j], path, FNM_PATHNAME);\n\t\t\tif (result == FNM_NOMATCH)\n\t\t\t\tcontinue;\n\t\t\telse if (result == 0) {\n\t\t\t\tokay_to_blacklist = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"Error: failed to compare path %s with pattern %s\\n\", path, noblacklist[j]);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\tif (okay_to_blacklist)\n\t\t\tdisable_file(op, path);\n\t\telse if (arg_debug)\n\t\t\tprintf(\"Not blacklist %s\\n\", path);\n\t}\n\tglobfree(&globbuf);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void globbing(OPERATION op, const char *pattern, const char *noblacklist[], size_t noblacklist_len) {\n\tassert(pattern);\n\n\tglob_t globbuf;\n\t// Profiles contain blacklists for files that might not exist on a user's machine.\n\t// GLOB_NOCHECK makes that okay.\n\tint globerr = glob(pattern, GLOB_NOCHECK | GLOB_NOSORT | GLOB_PERIOD, NULL, &globbuf);\n\tif (globerr) {\n\t\tfprintf(stderr, \"Error: failed to glob pattern %s\\n\", pattern);\n\t\texit(1);\n\t}\n\n\tsize_t i, j;\n\tfor (i = 0; i < globbuf.gl_pathc; i++) {\n\t\tchar *path = globbuf.gl_pathv[i];\n\t\tassert(path);\n\t\t// /home/me/.* can glob to /home/me/.. which would blacklist /home/\n\t\tconst char *base = gnu_basename(path);\n\t\tif (strcmp(base, \".\") == 0 || strcmp(base, \"..\") == 0)\n\t\t\tcontinue;\n\t\t// noblacklist is expected to be short in normal cases, so stupid and correct brute force is okay\n\t\tbool okay_to_blacklist = true;\n\t\tfor (j = 0; j < noblacklist_len; j++) {\n\t\t\tint result = fnmatch(noblacklist[j], path, FNM_PATHNAME);\n\t\t\tif (result == FNM_NOMATCH)\n\t\t\t\tcontinue;\n\t\t\telse if (result == 0) {\n\t\t\t\tokay_to_blacklist = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"Error: failed to compare path %s with pattern %s\\n\", path, noblacklist[j]);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\tif (okay_to_blacklist)\n\t\t\tdisable_file(op, path);\n\t\telse if (arg_debug)\n\t\t\tprintf(\"Not blacklist %s\\n\", path);\n\t}\n\tglobfree(&globbuf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "newname",
            "\"%s%s\"",
            "path",
            "fname"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_paths",
          "args": [],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "build_paths",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/paths.c",
          "lines": "48-100",
          "snippet": "char **build_paths(void) {\n\tif (initialized) {\n\t\tassert(paths);\n\t\treturn paths;\n\t}\n\tinitialized = 1;\n\t\n\tint cnt = 5;\t// 4 default paths + 1 NULL to end the array\n\tchar *path1 = getenv(\"PATH\");\n\tif (path1) {\n\t\tchar *path2 = strdup(path1);\n\t\tif (!path2)\n\t\t\terrExit(\"strdup\");\n\t\t\n\t\t// use path2 to count the entries\n\t\tchar *ptr = strtok(path2, \":\");\n\t\twhile (ptr) {\n\t\t\tcnt++;\n\t\t\tptr = strtok(NULL, \":\");\n\t\t}\n\t\tfree(path2);\n\t\tpath_cnt = cnt;\n\n\t\t// allocate paths array\n\t\tpaths = malloc(sizeof(char *) * cnt);\n\t\tif (!paths)\n\t\t\terrExit(\"malloc\");\n\t\tmemset(paths, 0, sizeof(char *) * cnt);\n\n\t\t// add default paths\n\t\tadd_path(\"/usr/local/bin\");\n\t\tadd_path(\"/usr/bin\");\n\t\tadd_path(\"/bin\");\n\t\tadd_path(\"/usr/local/sbin\");\n\t\tadd_path(\"/usr/sbin\");\n\t\tadd_path(\"/sbin\");\n\n\t\tpath2 = strdup(path1);\n\t\tif (!path2)\n\t\t\terrExit(\"strdup\");\n\t\t\n\t\t// use path2 to count the entries\n\t\tptr = strtok(path2, \":\");\n\t\twhile (ptr) {\n\t\t\tcnt++;\n\t\t\tadd_path(ptr);\n\t\t\tptr = strtok(NULL, \":\");\n\t\t}\n\t\tfree(path2);\n\t}\n\t\n\treturn paths;\n}",
          "includes": [
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char **paths = NULL;",
            "static int path_cnt = 0;",
            "static char initialized = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"firejail.h\"\n\nstatic char **paths = NULL;\nstatic int path_cnt = 0;\nstatic char initialized = 0;\n\nchar **build_paths(void) {\n\tif (initialized) {\n\t\tassert(paths);\n\t\treturn paths;\n\t}\n\tinitialized = 1;\n\t\n\tint cnt = 5;\t// 4 default paths + 1 NULL to end the array\n\tchar *path1 = getenv(\"PATH\");\n\tif (path1) {\n\t\tchar *path2 = strdup(path1);\n\t\tif (!path2)\n\t\t\terrExit(\"strdup\");\n\t\t\n\t\t// use path2 to count the entries\n\t\tchar *ptr = strtok(path2, \":\");\n\t\twhile (ptr) {\n\t\t\tcnt++;\n\t\t\tptr = strtok(NULL, \":\");\n\t\t}\n\t\tfree(path2);\n\t\tpath_cnt = cnt;\n\n\t\t// allocate paths array\n\t\tpaths = malloc(sizeof(char *) * cnt);\n\t\tif (!paths)\n\t\t\terrExit(\"malloc\");\n\t\tmemset(paths, 0, sizeof(char *) * cnt);\n\n\t\t// add default paths\n\t\tadd_path(\"/usr/local/bin\");\n\t\tadd_path(\"/usr/bin\");\n\t\tadd_path(\"/bin\");\n\t\tadd_path(\"/usr/local/sbin\");\n\t\tadd_path(\"/usr/sbin\");\n\t\tadd_path(\"/sbin\");\n\n\t\tpath2 = strdup(path1);\n\t\tif (!path2)\n\t\t\terrExit(\"strdup\");\n\t\t\n\t\t// use path2 to count the entries\n\t\tptr = strtok(path2, \":\");\n\t\twhile (ptr) {\n\t\t\tcnt++;\n\t\t\tadd_path(ptr);\n\t\t\tptr = strtok(NULL, \":\");\n\t\t}\n\t\tfree(path2);\n\t}\n\t\n\treturn paths;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "fname"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"${PATH}\"",
            "7"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expand_home",
          "args": [
            "ptr",
            "homedir"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "expand_home",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/util.c",
          "lines": "589-607",
          "snippet": "char *expand_home(const char *path, const char* homedir) {\n\tassert(path);\n\tassert(homedir);\n\n\t// Replace home macro\n\tchar *new_name = NULL;\n\tif (strncmp(path, \"${HOME}\", 7) == 0) {\n\t\tif (asprintf(&new_name, \"%s%s\", homedir, path + 7) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\treturn new_name;\n\t}\n\telse if (*path == '~') {\n\t\tif (asprintf(&new_name, \"%s%s\", homedir, path + 1) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\treturn new_name;\n\t}\n\n\treturn strdup(path);\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nchar *expand_home(const char *path, const char* homedir) {\n\tassert(path);\n\tassert(homedir);\n\n\t// Replace home macro\n\tchar *new_name = NULL;\n\tif (strncmp(path, \"${HOME}\", 7) == 0) {\n\t\tif (asprintf(&new_name, \"%s%s\", homedir, path + 7) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\treturn new_name;\n\t}\n\telse if (*path == '~') {\n\t\tif (asprintf(&new_name, \"%s%s\", homedir, path + 1) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\treturn new_name;\n\t}\n\n\treturn strdup(path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid profile line %s\\n\"",
            "entry->data"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ROOT",
          "args": [],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_mkfile",
          "args": [
            "entry->data + 7"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "fs_mkfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_mkdir.c",
          "lines": "93-136",
          "snippet": "void fs_mkfile(const char *name) {\n\tEUID_ASSERT();\n\t\n\t// check file name\n\tinvalid_filename(name);\n\tchar *expanded = expand_home(name, cfg.homedir);\n\tif (strncmp(expanded, cfg.homedir, strlen(cfg.homedir)) != 0) {\n\t\tfprintf(stderr, \"Error: only files in user home are supported by mkfile\\n\");\n\t\texit(1);\n\t}\n\n\tstruct stat s;\n\tif (stat(expanded, &s) == 0) {\n\t\t// file exists, do nothing\n\t\tgoto doexit;\n\t}\n\n\t// create file\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// drop privileges\n\t\tdrop_privs(0);\n\n\t\tFILE *fp = fopen(expanded, \"w\");\n\t\tif (!fp)\n\t\t\tfprintf(stderr, \"Warning: cannot create %s file\\n\", expanded);\n\t\telse {\n\t\t\tint fd = fileno(fp);\n\t\t\tif (fd == -1)\n\t\t\t\terrExit(\"fileno\");\n\t\t\tint rv = fchmod(fd, 0600);\n\t\t\t(void) rv;\n\t\t\tfclose(fp);\n\t\t}\n\t\t_exit(0);\n\t}\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n\ndoexit:\n\tfree(expanded);\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/wait.h>",
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/wait.h>\n#include <grp.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid fs_mkfile(const char *name) {\n\tEUID_ASSERT();\n\t\n\t// check file name\n\tinvalid_filename(name);\n\tchar *expanded = expand_home(name, cfg.homedir);\n\tif (strncmp(expanded, cfg.homedir, strlen(cfg.homedir)) != 0) {\n\t\tfprintf(stderr, \"Error: only files in user home are supported by mkfile\\n\");\n\t\texit(1);\n\t}\n\n\tstruct stat s;\n\tif (stat(expanded, &s) == 0) {\n\t\t// file exists, do nothing\n\t\tgoto doexit;\n\t}\n\n\t// create file\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// drop privileges\n\t\tdrop_privs(0);\n\n\t\tFILE *fp = fopen(expanded, \"w\");\n\t\tif (!fp)\n\t\t\tfprintf(stderr, \"Warning: cannot create %s file\\n\", expanded);\n\t\telse {\n\t\t\tint fd = fileno(fp);\n\t\t\tif (fd == -1)\n\t\t\t\terrExit(\"fileno\");\n\t\t\tint rv = fchmod(fd, 0600);\n\t\t\t(void) rv;\n\t\t\tfclose(fp);\n\t\t}\n\t\t_exit(0);\n\t}\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n\ndoexit:\n\tfree(expanded);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EUID_USER",
          "args": [],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "entry->data",
            "\"mkfile \"",
            "7"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ROOT",
          "args": [],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_mkdir",
          "args": [
            "entry->data + 6"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "fs_mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_mkdir.c",
          "lines": "57-91",
          "snippet": "void fs_mkdir(const char *name) {\n\tEUID_ASSERT();\n\t\n\t// check directory name\n\tinvalid_filename(name);\n\tchar *expanded = expand_home(name, cfg.homedir);\n\tif (strncmp(expanded, cfg.homedir, strlen(cfg.homedir)) != 0) {\n\t\tfprintf(stderr, \"Error: only directories in user home are supported by mkdir\\n\");\n\t\texit(1);\n\t}\n\n\tstruct stat s;\n\tif (stat(expanded, &s) == 0) {\n\t\t// file exists, do nothing\n\t\tgoto doexit;\n\t}\n\n\t// create directory\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// drop privileges\n\t\tdrop_privs(0);\n\n\t\t// create directory\n\t\tmkdir_recursive(expanded);\n\t\t_exit(0);\n\t}\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n\ndoexit:\n\tfree(expanded);\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/wait.h>",
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/wait.h>\n#include <grp.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid fs_mkdir(const char *name) {\n\tEUID_ASSERT();\n\t\n\t// check directory name\n\tinvalid_filename(name);\n\tchar *expanded = expand_home(name, cfg.homedir);\n\tif (strncmp(expanded, cfg.homedir, strlen(cfg.homedir)) != 0) {\n\t\tfprintf(stderr, \"Error: only directories in user home are supported by mkdir\\n\");\n\t\texit(1);\n\t}\n\n\tstruct stat s;\n\tif (stat(expanded, &s) == 0) {\n\t\t// file exists, do nothing\n\t\tgoto doexit;\n\t}\n\n\t// create directory\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// drop privileges\n\t\tdrop_privs(0);\n\n\t\t// create directory\n\t\tmkdir_recursive(expanded);\n\t\t_exit(0);\n\t}\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n\ndoexit:\n\tfree(expanded);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EUID_USER",
          "args": [],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "entry->data",
            "\"mkdir \"",
            "6"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "entry->data",
            "\"tmpfs \"",
            "6"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "entry->data",
            "\"noexec \"",
            "7"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "entry->data",
            "\"read-write \"",
            "11"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "entry->data",
            "\"read-only \"",
            "10"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "entry->data",
            "\"blacklist-nolog \"",
            "16"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "entry->data",
            "\"blacklist \"",
            "10"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "enames[i]"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"failed increasing memory for noblacklist entries\""
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "noblacklist",
            "sizeof(*noblacklist) * noblacklist_m"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&enames[i]",
            "\"%s%s\"",
            "paths[i]",
            "entry->data + 19"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "entry->data + 12",
            "\"${PATH}\"",
            "7"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "entry->data",
            "\"noblacklist \"",
            "12"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount-bind chmod\""
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chmod",
          "args": [
            "dname2",
            "s.st_mode"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount-bind chown\""
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chown",
          "args": [
            "dname2",
            "s.st_uid",
            "s.st_gid"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount bind\""
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "dname1",
            "dname2",
            "NULL",
            "MS_BIND|MS_REC",
            "NULL"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Mount-bind %s on top of %s\\n\"",
            "dname1",
            "dname2"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot find %s for bind command\\n\"",
            "dname2"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "dname2",
            "&s"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot find %s for bind command\\n\"",
            "dname1"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "dname1",
            "&s"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: second directory missing in bind command\\n\""
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "split_comma",
          "args": [
            "dname1"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "split_comma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/util.c",
          "lines": "361-373",
          "snippet": "char *split_comma(char *str) {\n\tEUID_ASSERT();\n\tif (str == NULL || *str == '\\0')\n\t\treturn NULL;\n\tchar *ptr = strchr(str, ',');\n\tif (!ptr)\n\t\treturn NULL;\n\t*ptr = '\\0';\n\tptr++;\n\tif (*ptr == '\\0')\n\t\treturn NULL;\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nchar *split_comma(char *str) {\n\tEUID_ASSERT();\n\tif (str == NULL || *str == '\\0')\n\t\treturn NULL;\n\tchar *ptr = strchr(str, ',');\n\tif (!ptr)\n\t\treturn NULL;\n\t*ptr = '\\0';\n\tptr++;\n\tif (*ptr == '\\0')\n\t\treturn NULL;\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "entry->data",
            "\"bind \"",
            "5"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "entry->data",
            "\"whitelist \"",
            "10"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"failed allocating memory for noblacklist entries\""
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "noblacklist_m",
            "sizeof(*noblacklist)"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "homedir"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_blacklist(void) {\n\tchar *homedir = cfg.homedir;\n\tassert(homedir);\n\tProfileEntry *entry = cfg.profile;\n\tif (!entry)\n\t\treturn;\n\t\t\n\tsize_t noblacklist_c = 0;\n\tsize_t noblacklist_m = 32;\n\tchar **noblacklist = calloc(noblacklist_m, sizeof(*noblacklist));\n\n\tif (noblacklist == NULL)\n\t\terrExit(\"failed allocating memory for noblacklist entries\");\n\n\twhile (entry) {\n\t\tOPERATION op = OPERATION_MAX;\n\t\tchar *ptr;\n\n\t\t// whitelist commands handled by fs_whitelist()\n\t\tif (strncmp(entry->data, \"whitelist \", 10) == 0 || *entry->data == '\\0') {\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// process bind command\n\t\tif (strncmp(entry->data, \"bind \", 5) == 0)  {\n\t\t\tchar *dname1 = entry->data + 5;\n\t\t\tchar *dname2 = split_comma(dname1);\n\t\t\tif (dname2 == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: second directory missing in bind command\\n\");\n\t\t\t\tentry = entry->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstruct stat s;\n\t\t\tif (stat(dname1, &s) == -1) {\n\t\t\t\tfprintf(stderr, \"Error: cannot find %s for bind command\\n\", dname1);\n\t\t\t\tentry = entry->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (stat(dname2, &s) == -1) {\n\t\t\t\tfprintf(stderr, \"Error: cannot find %s for bind command\\n\", dname2);\n\t\t\t\tentry = entry->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t// mount --bind olddir newdir\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Mount-bind %s on top of %s\\n\", dname1, dname2);\n\t\t\t// preserve dname2 mode and ownership\n\t\t\tif (mount(dname1, dname2, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\t\t\t/* coverity[toctou] */\n\t\t\tif (chown(dname2, s.st_uid, s.st_gid) == -1)\n\t\t\t\terrExit(\"mount-bind chown\");\n\t\t\t/* coverity[toctou] */\n\t\t\tif (chmod(dname2, s.st_mode) == -1)\n\t\t\t\terrExit(\"mount-bind chmod\");\n\t\t\t\t\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Process noblacklist command\n\t\tif (strncmp(entry->data, \"noblacklist \", 12) == 0) {\n\t\t\tchar **paths = build_paths();\n\n\t\t\tchar *enames[sizeof(paths)+1] = {0};\n\t\t\tint i = 0;\n\n\t\t\tif (strncmp(entry->data + 12, \"${PATH}\", 7) == 0) {\n\t\t\t\t// expand ${PATH} macro\n\t\t\t\twhile (paths[i] != NULL) {\n\t\t\t\t\tif (asprintf(&enames[i], \"%s%s\", paths[i], entry->data + 19) == -1)\n\t\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// expand ${HOME} macro if found or pass as is\n\t\t\t\tenames[0] = expand_home(entry->data + 12, homedir);\n\t\t\t\tenames[1] = NULL;\n\t\t\t}\n\n\t\t\ti = 0;\n\t\t\twhile (enames[i] != NULL) {\n\t\t\t\tif (noblacklist_c >= noblacklist_m) {\n\t\t\t\t\tnoblacklist_m *= 2;\n\t\t\t\t\tnoblacklist = realloc(noblacklist, sizeof(*noblacklist) * noblacklist_m);\n\t\t\t\t\tif (noblacklist == NULL)\n\t\t\t\t\t\terrExit(\"failed increasing memory for noblacklist entries\");\n\t\t\t\t}\n\t\t\t\tnoblacklist[noblacklist_c++] = enames[i];\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\twhile (enames[i] != NULL) {\n\t\t\t\tfree(enames[i]);\n\t\t\t}\n\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// process blacklist command\n\t\tif (strncmp(entry->data, \"blacklist \", 10) == 0)  {\n\t\t\tptr = entry->data + 10;\n\t\t\top = BLACKLIST_FILE;\n\t\t}\n\t\telse if (strncmp(entry->data, \"blacklist-nolog \", 16) == 0)  {\n\t\t\tptr = entry->data + 16;\n\t\t\top = BLACKLIST_NOLOG;\n\t\t}\n\t\telse if (strncmp(entry->data, \"read-only \", 10) == 0) {\n\t\t\tptr = entry->data + 10;\n\t\t\top = MOUNT_READONLY;\n\t\t}\t\t\t\n\t\telse if (strncmp(entry->data, \"read-write \", 11) == 0) {\n\t\t\tptr = entry->data + 11;\n\t\t\top = MOUNT_RDWR;\n\t\t}\t\t\t\n\t\telse if (strncmp(entry->data, \"noexec \", 7) == 0) {\n\t\t\tptr = entry->data + 7;\n\t\t\top = MOUNT_NOEXEC;\n\t\t}\t\t\t\n\t\telse if (strncmp(entry->data, \"tmpfs \", 6) == 0) {\n\t\t\tptr = entry->data + 6;\n\t\t\top = MOUNT_TMPFS;\n\t\t}\t\t\t\n\t\telse if (strncmp(entry->data, \"mkdir \", 6) == 0) {\n\t\t\tEUID_USER();\n\t\t\tfs_mkdir(entry->data + 6);\n\t\t\tEUID_ROOT();\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\t\t\t\n\t\telse if (strncmp(entry->data, \"mkfile \", 7) == 0) {\n\t\t\tEUID_USER();\n\t\t\tfs_mkfile(entry->data + 7);\n\t\t\tEUID_ROOT();\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\t\t\t\n\t\telse {\n\t\t\tfprintf(stderr, \"Error: invalid profile line %s\\n\", entry->data);\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// replace home macro in blacklist array\n\t\tchar *new_name = expand_home(ptr, homedir);\n\t\tptr = new_name;\n\n\t\t// expand path macro - look for the file in /usr/local/bin,  /usr/local/sbin, /bin, /usr/bin, /sbin and  /usr/sbin directories\n\t\tif (ptr) {\n\t\t\tif (strncmp(ptr, \"${PATH}\", 7) == 0) {\n\t\t\t\tchar *fname = ptr + 7;\n\t\t\t\tsize_t fname_len = strlen(fname);\n\t\t\t\tchar **paths = build_paths(); //{\"/usr/local/bin\", \"/usr/local/sbin\", \"/bin\", \"/usr/bin/\", \"/sbin\", \"/usr/sbin\", NULL};\n\t\t\t\tint i = 0;\n\t\t\t\twhile (paths[i] != NULL) {\n\t\t\t\t\tchar *path = paths[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tchar newname[strlen(path) + fname_len + 1];\n\t\t\t\t\tsprintf(newname, \"%s%s\", path, fname);\n\t\t\t\t\tglobbing(op, newname, (const char**)noblacklist, noblacklist_c);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tglobbing(op, ptr, (const char**)noblacklist, noblacklist_c);\n\t\t}\n\n\t\tif (new_name)\n\t\t\tfree(new_name);\n\t\tentry = entry->next;\n\t}\n\n\tsize_t i;\n\tfor (i = 0; i < noblacklist_c; i++) free(noblacklist[i]);\n        free(noblacklist);\n}"
  },
  {
    "function_name": "globbing",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
    "lines": "328-369",
    "snippet": "static void globbing(OPERATION op, const char *pattern, const char *noblacklist[], size_t noblacklist_len) {\n\tassert(pattern);\n\n\tglob_t globbuf;\n\t// Profiles contain blacklists for files that might not exist on a user's machine.\n\t// GLOB_NOCHECK makes that okay.\n\tint globerr = glob(pattern, GLOB_NOCHECK | GLOB_NOSORT | GLOB_PERIOD, NULL, &globbuf);\n\tif (globerr) {\n\t\tfprintf(stderr, \"Error: failed to glob pattern %s\\n\", pattern);\n\t\texit(1);\n\t}\n\n\tsize_t i, j;\n\tfor (i = 0; i < globbuf.gl_pathc; i++) {\n\t\tchar *path = globbuf.gl_pathv[i];\n\t\tassert(path);\n\t\t// /home/me/.* can glob to /home/me/.. which would blacklist /home/\n\t\tconst char *base = gnu_basename(path);\n\t\tif (strcmp(base, \".\") == 0 || strcmp(base, \"..\") == 0)\n\t\t\tcontinue;\n\t\t// noblacklist is expected to be short in normal cases, so stupid and correct brute force is okay\n\t\tbool okay_to_blacklist = true;\n\t\tfor (j = 0; j < noblacklist_len; j++) {\n\t\t\tint result = fnmatch(noblacklist[j], path, FNM_PATHNAME);\n\t\t\tif (result == FNM_NOMATCH)\n\t\t\t\tcontinue;\n\t\t\telse if (result == 0) {\n\t\t\t\tokay_to_blacklist = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"Error: failed to compare path %s with pattern %s\\n\", path, noblacklist[j]);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\tif (okay_to_blacklist)\n\t\t\tdisable_file(op, path);\n\t\telse if (arg_debug)\n\t\t\tprintf(\"Not blacklist %s\\n\", path);\n\t}\n\tglobfree(&globbuf);\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "globfree",
          "args": [
            "&globbuf"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Not blacklist %s\\n\"",
            "path"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disable_file",
          "args": [
            "op",
            "path"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "disable_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
          "lines": "200-325",
          "snippet": "static void disable_file(OPERATION op, const char *filename) {\n\tassert(filename);\n\tassert(op <OPERATION_MAX);\n\tlast_disable = UNSUCCESSFUL;\n\t\n\t// rebuild /run/firejail directory in case tmpfs was mounted on top of /run\n\tfs_build_firejail_dir();\n\t\n\t// Resolve all symlinks\n\tchar* fname = realpath(filename, NULL);\n\tif (fname == NULL && errno != EACCES) {\n\t\treturn;\n\t}\n\tif (fname == NULL && errno == EACCES) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Debug: no access to file %s, forcing mount\\n\", filename);\n\t\t// realpath and stat funtions will fail on FUSE filesystems\n\t\t// they don't seem to like a uid of 0\n\t\t// force mounting\n\t\tint rv = mount(RUN_RO_DIR, filename, \"none\", MS_BIND, \"mode=400,gid=0\");\n\t\tif (rv == 0)\n\t\t\tlast_disable = SUCCESSFUL;\n\t\telse {\n\t\t\trv = mount(RUN_RO_FILE, filename, \"none\", MS_BIND, \"mode=400,gid=0\");\n\t\t\tif (rv == 0)\n\t\t\t\tlast_disable = SUCCESSFUL;\n\t\t}\n\t\tif (last_disable == SUCCESSFUL) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Disable %s\\n\", filename);\n\t\t\tif (op == BLACKLIST_FILE)\n\t\t\t\tfs_logger2(\"blacklist\", filename);\n\t\t\telse\n\t\t\t\tfs_logger2(\"blacklist-nolog\", filename);\n\t\t}\n\t\telse {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Warning (blacklisting): %s is an invalid file, skipping...\\n\", filename);\n\t\t}\n\t\t\t\t\n\t\treturn;\n\t}\n\t\n\t// if the file is not present, do nothing\n\tstruct stat s;\n\tif (fname == NULL)\n\t\treturn;\n\tif (stat(fname, &s) == -1) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Warning: %s does not exist, skipping...\\n\", fname);\n\t\tfree(fname);\n\t\treturn;\n\t}\n\n\t// modify the file\n\tif (op == BLACKLIST_FILE || op == BLACKLIST_NOLOG) {\n\t\t// some distros put all executables under /usr/bin and make /bin a symbolic link\n\t\tif ((strcmp(fname, \"/bin\") == 0 || strcmp(fname, \"/usr/bin\") == 0) &&\n\t\t      is_link(filename) &&\n\t\t      S_ISDIR(s.st_mode))\n\t\t\tfprintf(stderr, \"Warning: %s directory link was not blacklisted\\n\", filename);\n\t\t\t\n\t\telse {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Disable %s\\n\", fname);\n\t\t\telse if (arg_debug_blacklists) {\n\t\t\t\tprintf(\"Disable %s\", fname);\n\t\t\t\tif (op == BLACKLIST_FILE)\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\telse\n\t\t\t\t\tprintf(\" - no logging\\n\");\n\t\t\t}\n\t\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\t\tif (mount(RUN_RO_DIR, fname, \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\t\t\t\terrExit(\"disable file\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (mount(RUN_RO_FILE, fname, \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\t\t\t\terrExit(\"disable file\");\n\t\t\t}\n\t\t\tlast_disable = SUCCESSFUL;\n\t\t\tif (op == BLACKLIST_FILE)\n\t\t\t\tfs_logger2(\"blacklist\", fname);\n\t\t\telse\n\t\t\t\tfs_logger2(\"blacklist-nolog\", fname);\n\t\t}\n\t}\n\telse if (op == MOUNT_READONLY) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting read-only %s\\n\", fname);\n\t\tfs_rdonly(fname);\n// todo: last_disable = SUCCESSFUL;\n\t}\n\telse if (op == MOUNT_RDWR) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting read-only %s\\n\", fname);\n\t\tfs_rdwr(fname);\n// todo: last_disable = SUCCESSFUL;\n\t}\n\telse if (op == MOUNT_NOEXEC) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting noexec %s\\n\", fname);\n\t\tfs_noexec(fname);\n// todo: last_disable = SUCCESSFUL;\n\t}\n\telse if (op == MOUNT_TMPFS) {\n\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Mounting tmpfs on %s\\n\", fname);\n\t\t\t// preserve owner and mode for the directory\n\t\t\tif (mount(\"tmpfs\", fname, \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME | MS_REC,  0) < 0)\n\t\t\t\terrExit(\"mounting tmpfs\");\n\t\t\t/* coverity[toctou] */\n\t\t\tif (chown(fname, s.st_uid, s.st_gid) == -1)\n\t\t\t\terrExit(\"mounting tmpfs chmod\");\n\t\t\tlast_disable = SUCCESSFUL;\n\t\t\tfs_logger2(\"tmpfs\", fname);\n\t\t}\n\t\telse\n\t\t\tprintf(\"Warning: %s is not a directory; cannot mount a tmpfs on top of it.\\n\", fname);\n\t}\n\telse\n\t\tassert(0);\n\n\tfree(fname);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "LAST_DISABLE_OPERATION last_disable = UNSUCCESSFUL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nLAST_DISABLE_OPERATION last_disable = UNSUCCESSFUL;\n\nstatic void disable_file(OPERATION op, const char *filename) {\n\tassert(filename);\n\tassert(op <OPERATION_MAX);\n\tlast_disable = UNSUCCESSFUL;\n\t\n\t// rebuild /run/firejail directory in case tmpfs was mounted on top of /run\n\tfs_build_firejail_dir();\n\t\n\t// Resolve all symlinks\n\tchar* fname = realpath(filename, NULL);\n\tif (fname == NULL && errno != EACCES) {\n\t\treturn;\n\t}\n\tif (fname == NULL && errno == EACCES) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Debug: no access to file %s, forcing mount\\n\", filename);\n\t\t// realpath and stat funtions will fail on FUSE filesystems\n\t\t// they don't seem to like a uid of 0\n\t\t// force mounting\n\t\tint rv = mount(RUN_RO_DIR, filename, \"none\", MS_BIND, \"mode=400,gid=0\");\n\t\tif (rv == 0)\n\t\t\tlast_disable = SUCCESSFUL;\n\t\telse {\n\t\t\trv = mount(RUN_RO_FILE, filename, \"none\", MS_BIND, \"mode=400,gid=0\");\n\t\t\tif (rv == 0)\n\t\t\t\tlast_disable = SUCCESSFUL;\n\t\t}\n\t\tif (last_disable == SUCCESSFUL) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Disable %s\\n\", filename);\n\t\t\tif (op == BLACKLIST_FILE)\n\t\t\t\tfs_logger2(\"blacklist\", filename);\n\t\t\telse\n\t\t\t\tfs_logger2(\"blacklist-nolog\", filename);\n\t\t}\n\t\telse {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Warning (blacklisting): %s is an invalid file, skipping...\\n\", filename);\n\t\t}\n\t\t\t\t\n\t\treturn;\n\t}\n\t\n\t// if the file is not present, do nothing\n\tstruct stat s;\n\tif (fname == NULL)\n\t\treturn;\n\tif (stat(fname, &s) == -1) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Warning: %s does not exist, skipping...\\n\", fname);\n\t\tfree(fname);\n\t\treturn;\n\t}\n\n\t// modify the file\n\tif (op == BLACKLIST_FILE || op == BLACKLIST_NOLOG) {\n\t\t// some distros put all executables under /usr/bin and make /bin a symbolic link\n\t\tif ((strcmp(fname, \"/bin\") == 0 || strcmp(fname, \"/usr/bin\") == 0) &&\n\t\t      is_link(filename) &&\n\t\t      S_ISDIR(s.st_mode))\n\t\t\tfprintf(stderr, \"Warning: %s directory link was not blacklisted\\n\", filename);\n\t\t\t\n\t\telse {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Disable %s\\n\", fname);\n\t\t\telse if (arg_debug_blacklists) {\n\t\t\t\tprintf(\"Disable %s\", fname);\n\t\t\t\tif (op == BLACKLIST_FILE)\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\telse\n\t\t\t\t\tprintf(\" - no logging\\n\");\n\t\t\t}\n\t\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\t\tif (mount(RUN_RO_DIR, fname, \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\t\t\t\terrExit(\"disable file\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (mount(RUN_RO_FILE, fname, \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\t\t\t\terrExit(\"disable file\");\n\t\t\t}\n\t\t\tlast_disable = SUCCESSFUL;\n\t\t\tif (op == BLACKLIST_FILE)\n\t\t\t\tfs_logger2(\"blacklist\", fname);\n\t\t\telse\n\t\t\t\tfs_logger2(\"blacklist-nolog\", fname);\n\t\t}\n\t}\n\telse if (op == MOUNT_READONLY) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting read-only %s\\n\", fname);\n\t\tfs_rdonly(fname);\n// todo: last_disable = SUCCESSFUL;\n\t}\n\telse if (op == MOUNT_RDWR) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting read-only %s\\n\", fname);\n\t\tfs_rdwr(fname);\n// todo: last_disable = SUCCESSFUL;\n\t}\n\telse if (op == MOUNT_NOEXEC) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting noexec %s\\n\", fname);\n\t\tfs_noexec(fname);\n// todo: last_disable = SUCCESSFUL;\n\t}\n\telse if (op == MOUNT_TMPFS) {\n\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Mounting tmpfs on %s\\n\", fname);\n\t\t\t// preserve owner and mode for the directory\n\t\t\tif (mount(\"tmpfs\", fname, \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME | MS_REC,  0) < 0)\n\t\t\t\terrExit(\"mounting tmpfs\");\n\t\t\t/* coverity[toctou] */\n\t\t\tif (chown(fname, s.st_uid, s.st_gid) == -1)\n\t\t\t\terrExit(\"mounting tmpfs chmod\");\n\t\t\tlast_disable = SUCCESSFUL;\n\t\t\tfs_logger2(\"tmpfs\", fname);\n\t\t}\n\t\telse\n\t\t\tprintf(\"Warning: %s is not a directory; cannot mount a tmpfs on top of it.\\n\", fname);\n\t}\n\telse\n\t\tassert(0);\n\n\tfree(fname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "fs_rdonly_noexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
          "lines": "615-633",
          "snippet": "void fs_rdonly_noexit(const char *dir) {\n\tassert(dir);\n\t// check directory exists\n\tstruct stat s;\n\tint rv = stat(dir, &s);\n\tif (rv == 0) {\n\t\tint merr = 0;\n\t\t// mount --bind /bin /bin\n\t\tif (mount(dir, dir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\tmerr = 1;\n\t\t// mount --bind -o remount,ro /bin\n\t\tif (mount(NULL, dir, NULL, MS_BIND|MS_REMOUNT|MS_RDONLY|MS_REC, NULL) < 0)\n\t\t\tmerr = 1;\n\t\tif (merr)\n\t\t\tfprintf(stderr, \"Warning: cannot mount %s read-only\\n\", dir); \n\t\telse\n\t\t\tfs_logger2(\"read-only\", dir);\n\t}\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fs_rdwr(const char *dir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void fs_rdwr(const char *dir);\n\nvoid fs_rdonly_noexit(const char *dir) {\n\tassert(dir);\n\t// check directory exists\n\tstruct stat s;\n\tint rv = stat(dir, &s);\n\tif (rv == 0) {\n\t\tint merr = 0;\n\t\t// mount --bind /bin /bin\n\t\tif (mount(dir, dir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\tmerr = 1;\n\t\t// mount --bind -o remount,ro /bin\n\t\tif (mount(NULL, dir, NULL, MS_BIND|MS_REMOUNT|MS_RDONLY|MS_REC, NULL) < 0)\n\t\t\tmerr = 1;\n\t\tif (merr)\n\t\t\tfprintf(stderr, \"Warning: cannot mount %s read-only\\n\", dir); \n\t\telse\n\t\t\tfs_logger2(\"read-only\", dir);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: failed to compare path %s with pattern %s\\n\"",
            "path",
            "noblacklist[j]"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fnmatch",
          "args": [
            "noblacklist[j]",
            "path",
            "FNM_PATHNAME"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "base",
            "\"..\""
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "base",
            "\".\""
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnu_basename",
          "args": [
            "path"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "gnu_basename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/util.c",
          "lines": "613-618",
          "snippet": "const char *gnu_basename(const char *path) {\n\tconst char *last_slash = strrchr(path, '/');\n\tif (!last_slash)\n\t\treturn path;\n\treturn last_slash+1;\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nconst char *gnu_basename(const char *path) {\n\tconst char *last_slash = strrchr(path, '/');\n\tif (!last_slash)\n\t\treturn path;\n\treturn last_slash+1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "path"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: failed to glob pattern %s\\n\"",
            "pattern"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "glob",
          "args": [
            "pattern",
            "GLOB_NOCHECK | GLOB_NOSORT | GLOB_PERIOD",
            "NULL",
            "&globbuf"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "globbing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
          "lines": "328-369",
          "snippet": "static void globbing(OPERATION op, const char *pattern, const char *noblacklist[], size_t noblacklist_len) {\n\tassert(pattern);\n\n\tglob_t globbuf;\n\t// Profiles contain blacklists for files that might not exist on a user's machine.\n\t// GLOB_NOCHECK makes that okay.\n\tint globerr = glob(pattern, GLOB_NOCHECK | GLOB_NOSORT | GLOB_PERIOD, NULL, &globbuf);\n\tif (globerr) {\n\t\tfprintf(stderr, \"Error: failed to glob pattern %s\\n\", pattern);\n\t\texit(1);\n\t}\n\n\tsize_t i, j;\n\tfor (i = 0; i < globbuf.gl_pathc; i++) {\n\t\tchar *path = globbuf.gl_pathv[i];\n\t\tassert(path);\n\t\t// /home/me/.* can glob to /home/me/.. which would blacklist /home/\n\t\tconst char *base = gnu_basename(path);\n\t\tif (strcmp(base, \".\") == 0 || strcmp(base, \"..\") == 0)\n\t\t\tcontinue;\n\t\t// noblacklist is expected to be short in normal cases, so stupid and correct brute force is okay\n\t\tbool okay_to_blacklist = true;\n\t\tfor (j = 0; j < noblacklist_len; j++) {\n\t\t\tint result = fnmatch(noblacklist[j], path, FNM_PATHNAME);\n\t\t\tif (result == FNM_NOMATCH)\n\t\t\t\tcontinue;\n\t\t\telse if (result == 0) {\n\t\t\t\tokay_to_blacklist = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"Error: failed to compare path %s with pattern %s\\n\", path, noblacklist[j]);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\tif (okay_to_blacklist)\n\t\t\tdisable_file(op, path);\n\t\telse if (arg_debug)\n\t\t\tprintf(\"Not blacklist %s\\n\", path);\n\t}\n\tglobfree(&globbuf);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "pattern"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void globbing(OPERATION op, const char *pattern, const char *noblacklist[], size_t noblacklist_len) {\n\tassert(pattern);\n\n\tglob_t globbuf;\n\t// Profiles contain blacklists for files that might not exist on a user's machine.\n\t// GLOB_NOCHECK makes that okay.\n\tint globerr = glob(pattern, GLOB_NOCHECK | GLOB_NOSORT | GLOB_PERIOD, NULL, &globbuf);\n\tif (globerr) {\n\t\tfprintf(stderr, \"Error: failed to glob pattern %s\\n\", pattern);\n\t\texit(1);\n\t}\n\n\tsize_t i, j;\n\tfor (i = 0; i < globbuf.gl_pathc; i++) {\n\t\tchar *path = globbuf.gl_pathv[i];\n\t\tassert(path);\n\t\t// /home/me/.* can glob to /home/me/.. which would blacklist /home/\n\t\tconst char *base = gnu_basename(path);\n\t\tif (strcmp(base, \".\") == 0 || strcmp(base, \"..\") == 0)\n\t\t\tcontinue;\n\t\t// noblacklist is expected to be short in normal cases, so stupid and correct brute force is okay\n\t\tbool okay_to_blacklist = true;\n\t\tfor (j = 0; j < noblacklist_len; j++) {\n\t\t\tint result = fnmatch(noblacklist[j], path, FNM_PATHNAME);\n\t\t\tif (result == FNM_NOMATCH)\n\t\t\t\tcontinue;\n\t\t\telse if (result == 0) {\n\t\t\t\tokay_to_blacklist = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"Error: failed to compare path %s with pattern %s\\n\", path, noblacklist[j]);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\tif (okay_to_blacklist)\n\t\t\tdisable_file(op, path);\n\t\telse if (arg_debug)\n\t\t\tprintf(\"Not blacklist %s\\n\", path);\n\t}\n\tglobfree(&globbuf);\n}"
  },
  {
    "function_name": "disable_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
    "lines": "200-325",
    "snippet": "static void disable_file(OPERATION op, const char *filename) {\n\tassert(filename);\n\tassert(op <OPERATION_MAX);\n\tlast_disable = UNSUCCESSFUL;\n\t\n\t// rebuild /run/firejail directory in case tmpfs was mounted on top of /run\n\tfs_build_firejail_dir();\n\t\n\t// Resolve all symlinks\n\tchar* fname = realpath(filename, NULL);\n\tif (fname == NULL && errno != EACCES) {\n\t\treturn;\n\t}\n\tif (fname == NULL && errno == EACCES) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Debug: no access to file %s, forcing mount\\n\", filename);\n\t\t// realpath and stat funtions will fail on FUSE filesystems\n\t\t// they don't seem to like a uid of 0\n\t\t// force mounting\n\t\tint rv = mount(RUN_RO_DIR, filename, \"none\", MS_BIND, \"mode=400,gid=0\");\n\t\tif (rv == 0)\n\t\t\tlast_disable = SUCCESSFUL;\n\t\telse {\n\t\t\trv = mount(RUN_RO_FILE, filename, \"none\", MS_BIND, \"mode=400,gid=0\");\n\t\t\tif (rv == 0)\n\t\t\t\tlast_disable = SUCCESSFUL;\n\t\t}\n\t\tif (last_disable == SUCCESSFUL) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Disable %s\\n\", filename);\n\t\t\tif (op == BLACKLIST_FILE)\n\t\t\t\tfs_logger2(\"blacklist\", filename);\n\t\t\telse\n\t\t\t\tfs_logger2(\"blacklist-nolog\", filename);\n\t\t}\n\t\telse {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Warning (blacklisting): %s is an invalid file, skipping...\\n\", filename);\n\t\t}\n\t\t\t\t\n\t\treturn;\n\t}\n\t\n\t// if the file is not present, do nothing\n\tstruct stat s;\n\tif (fname == NULL)\n\t\treturn;\n\tif (stat(fname, &s) == -1) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Warning: %s does not exist, skipping...\\n\", fname);\n\t\tfree(fname);\n\t\treturn;\n\t}\n\n\t// modify the file\n\tif (op == BLACKLIST_FILE || op == BLACKLIST_NOLOG) {\n\t\t// some distros put all executables under /usr/bin and make /bin a symbolic link\n\t\tif ((strcmp(fname, \"/bin\") == 0 || strcmp(fname, \"/usr/bin\") == 0) &&\n\t\t      is_link(filename) &&\n\t\t      S_ISDIR(s.st_mode))\n\t\t\tfprintf(stderr, \"Warning: %s directory link was not blacklisted\\n\", filename);\n\t\t\t\n\t\telse {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Disable %s\\n\", fname);\n\t\t\telse if (arg_debug_blacklists) {\n\t\t\t\tprintf(\"Disable %s\", fname);\n\t\t\t\tif (op == BLACKLIST_FILE)\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\telse\n\t\t\t\t\tprintf(\" - no logging\\n\");\n\t\t\t}\n\t\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\t\tif (mount(RUN_RO_DIR, fname, \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\t\t\t\terrExit(\"disable file\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (mount(RUN_RO_FILE, fname, \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\t\t\t\terrExit(\"disable file\");\n\t\t\t}\n\t\t\tlast_disable = SUCCESSFUL;\n\t\t\tif (op == BLACKLIST_FILE)\n\t\t\t\tfs_logger2(\"blacklist\", fname);\n\t\t\telse\n\t\t\t\tfs_logger2(\"blacklist-nolog\", fname);\n\t\t}\n\t}\n\telse if (op == MOUNT_READONLY) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting read-only %s\\n\", fname);\n\t\tfs_rdonly(fname);\n// todo: last_disable = SUCCESSFUL;\n\t}\n\telse if (op == MOUNT_RDWR) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting read-only %s\\n\", fname);\n\t\tfs_rdwr(fname);\n// todo: last_disable = SUCCESSFUL;\n\t}\n\telse if (op == MOUNT_NOEXEC) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting noexec %s\\n\", fname);\n\t\tfs_noexec(fname);\n// todo: last_disable = SUCCESSFUL;\n\t}\n\telse if (op == MOUNT_TMPFS) {\n\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Mounting tmpfs on %s\\n\", fname);\n\t\t\t// preserve owner and mode for the directory\n\t\t\tif (mount(\"tmpfs\", fname, \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME | MS_REC,  0) < 0)\n\t\t\t\terrExit(\"mounting tmpfs\");\n\t\t\t/* coverity[toctou] */\n\t\t\tif (chown(fname, s.st_uid, s.st_gid) == -1)\n\t\t\t\terrExit(\"mounting tmpfs chmod\");\n\t\t\tlast_disable = SUCCESSFUL;\n\t\t\tfs_logger2(\"tmpfs\", fname);\n\t\t}\n\t\telse\n\t\t\tprintf(\"Warning: %s is not a directory; cannot mount a tmpfs on top of it.\\n\", fname);\n\t}\n\telse\n\t\tassert(0);\n\n\tfree(fname);\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "LAST_DISABLE_OPERATION last_disable = UNSUCCESSFUL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "0"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Warning: %s is not a directory; cannot mount a tmpfs on top of it.\\n\"",
            "fname"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_logger2",
          "args": [
            "\"tmpfs\"",
            "fname"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger2int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_logger.c",
          "lines": "73-80",
          "snippet": "void fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mounting tmpfs chmod\""
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chown",
          "args": [
            "fname",
            "s.st_uid",
            "s.st_gid"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mounting tmpfs\""
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"tmpfs\"",
            "fname",
            "\"tmpfs\"",
            "MS_NOSUID | MS_NODEV | MS_STRICTATIME | MS_REC",
            "0"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Mounting tmpfs on %s\\n\"",
            "fname"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "s.st_mode"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_noexec",
          "args": [
            "fname"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "fs_noexec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
          "lines": "597-611",
          "snippet": "void fs_noexec(const char *dir) {\n\tassert(dir);\n\t// check directory exists\n\tstruct stat s;\n\tint rv = stat(dir, &s);\n\tif (rv == 0) {\n\t\t// mount --bind /bin /bin\n\t\tif (mount(dir, dir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mount noexec\");\n\t\t// mount --bind -o remount,ro /bin\n\t\tif (mount(NULL, dir, NULL, MS_BIND|MS_REMOUNT|MS_NOEXEC|MS_NODEV|MS_NOSUID|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mount read-only\");\n\t\tfs_logger2(\"noexec\", dir);\n\t}\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fs_rdwr(const char *dir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void fs_rdwr(const char *dir);\n\nvoid fs_noexec(const char *dir) {\n\tassert(dir);\n\t// check directory exists\n\tstruct stat s;\n\tint rv = stat(dir, &s);\n\tif (rv == 0) {\n\t\t// mount --bind /bin /bin\n\t\tif (mount(dir, dir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mount noexec\");\n\t\t// mount --bind -o remount,ro /bin\n\t\tif (mount(NULL, dir, NULL, MS_BIND|MS_REMOUNT|MS_NOEXEC|MS_NODEV|MS_NOSUID|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mount read-only\");\n\t\tfs_logger2(\"noexec\", dir);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Mounting noexec %s\\n\"",
            "fname"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_rdwr",
          "args": [
            "fname"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "fs_rdwr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
          "lines": "574-595",
          "snippet": "static void fs_rdwr(const char *dir) {\n\tassert(dir);\n\t// check directory exists\n\tstruct stat s;\n\tint rv = stat(dir, &s);\n\tif (rv == 0) {\n\t\t// if the file is outside /home directory, allow only root user\n\t\tuid_t u = getuid();\n\t\tif (u != 0 && s.st_uid != u) {\n\t\t\tfprintf(stderr, \"Warning: you are not allowed to change %s to read-write\\n\", dir);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// mount --bind /bin /bin\n\t\tif (mount(dir, dir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mount read-write\");\n\t\t// mount --bind -o remount,rw /bin\n\t\tif (mount(NULL, dir, NULL, MS_BIND|MS_REMOUNT|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mount read-write\");\n\t\tfs_logger2(\"read-write\", dir);\n\t}\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fs_rdwr(const char *dir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void fs_rdwr(const char *dir);\n\nstatic void fs_rdwr(const char *dir) {\n\tassert(dir);\n\t// check directory exists\n\tstruct stat s;\n\tint rv = stat(dir, &s);\n\tif (rv == 0) {\n\t\t// if the file is outside /home directory, allow only root user\n\t\tuid_t u = getuid();\n\t\tif (u != 0 && s.st_uid != u) {\n\t\t\tfprintf(stderr, \"Warning: you are not allowed to change %s to read-write\\n\", dir);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// mount --bind /bin /bin\n\t\tif (mount(dir, dir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mount read-write\");\n\t\t// mount --bind -o remount,rw /bin\n\t\tif (mount(NULL, dir, NULL, MS_BIND|MS_REMOUNT|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mount read-write\");\n\t\tfs_logger2(\"read-write\", dir);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Mounting read-only %s\\n\"",
            "fname"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_rdonly",
          "args": [
            "fname"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "fs_rdonly_noexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
          "lines": "615-633",
          "snippet": "void fs_rdonly_noexit(const char *dir) {\n\tassert(dir);\n\t// check directory exists\n\tstruct stat s;\n\tint rv = stat(dir, &s);\n\tif (rv == 0) {\n\t\tint merr = 0;\n\t\t// mount --bind /bin /bin\n\t\tif (mount(dir, dir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\tmerr = 1;\n\t\t// mount --bind -o remount,ro /bin\n\t\tif (mount(NULL, dir, NULL, MS_BIND|MS_REMOUNT|MS_RDONLY|MS_REC, NULL) < 0)\n\t\t\tmerr = 1;\n\t\tif (merr)\n\t\t\tfprintf(stderr, \"Warning: cannot mount %s read-only\\n\", dir); \n\t\telse\n\t\t\tfs_logger2(\"read-only\", dir);\n\t}\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fs_rdwr(const char *dir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void fs_rdwr(const char *dir);\n\nvoid fs_rdonly_noexit(const char *dir) {\n\tassert(dir);\n\t// check directory exists\n\tstruct stat s;\n\tint rv = stat(dir, &s);\n\tif (rv == 0) {\n\t\tint merr = 0;\n\t\t// mount --bind /bin /bin\n\t\tif (mount(dir, dir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\tmerr = 1;\n\t\t// mount --bind -o remount,ro /bin\n\t\tif (mount(NULL, dir, NULL, MS_BIND|MS_REMOUNT|MS_RDONLY|MS_REC, NULL) < 0)\n\t\t\tmerr = 1;\n\t\tif (merr)\n\t\t\tfprintf(stderr, \"Warning: cannot mount %s read-only\\n\", dir); \n\t\telse\n\t\t\tfs_logger2(\"read-only\", dir);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Mounting read-only %s\\n\"",
            "fname"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"disable file\""
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "RUN_RO_FILE",
            "fname",
            "\"none\"",
            "MS_BIND",
            "\"mode=400,gid=0\""
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"disable file\""
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "RUN_RO_DIR",
            "fname",
            "\"none\"",
            "MS_BIND",
            "\"mode=400,gid=0\""
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "s.st_mode"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" - no logging\\n\""
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Disable %s\"",
            "fname"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Disable %s\\n\"",
            "fname"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: %s directory link was not blacklisted\\n\"",
            "filename"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "s.st_mode"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_link",
          "args": [
            "filename"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "is_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/util.c",
          "lines": "295-307",
          "snippet": "int is_link(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\tstruct stat s;\n\tif (lstat(fname, &s) == 0) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nint is_link(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\tstruct stat s;\n\tif (lstat(fname, &s) == 0) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "fname",
            "\"/usr/bin\""
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "fname",
            "\"/bin\""
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Warning: %s does not exist, skipping...\\n\"",
            "fname"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "fname",
            "&s"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Warning (blacklisting): %s is an invalid file, skipping...\\n\"",
            "filename"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Disable %s\\n\"",
            "filename"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "RUN_RO_FILE",
            "filename",
            "\"none\"",
            "MS_BIND",
            "\"mode=400,gid=0\""
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "RUN_RO_DIR",
            "filename",
            "\"none\"",
            "MS_BIND",
            "\"mode=400,gid=0\""
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Debug: no access to file %s, forcing mount\\n\"",
            "filename"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realpath",
          "args": [
            "filename",
            "NULL"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_build_firejail_dir",
          "args": [],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "fs_build_firejail_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
          "lines": "73-114",
          "snippet": "void fs_build_firejail_dir(void) {\n\tstruct stat s;\n\n\t// CentOS 6 doesn't have /run directory\n\tif (stat(RUN_FIREJAIL_BASEDIR, &s)) {\n\t\tcreate_dir_as_root(RUN_FIREJAIL_BASEDIR, 0755);\n\t}\n\n\t// check /run/firejail directory belongs to root end exit if doesn't!\n\tif (stat(RUN_FIREJAIL_DIR, &s) == 0) {\n\t\tif (s.st_uid != 0 || s.st_gid != 0) {\n\t\t\tfprintf(stderr, \"Error: non-root %s directory, exiting...\\n\", RUN_FIREJAIL_DIR);\n\t\t\texit(1);\n\t\t}\n\t}\n\telse {\n\t\tcreate_dir_as_root(RUN_FIREJAIL_DIR, 0755);\n\t}\n\t\n\tif (stat(RUN_FIREJAIL_NETWORK_DIR, &s)) {\n\t\tcreate_dir_as_root(RUN_FIREJAIL_NETWORK_DIR, 0755);\n\t}\n\t\n\tif (stat(RUN_FIREJAIL_BANDWIDTH_DIR, &s)) {\n\t\tcreate_dir_as_root(RUN_FIREJAIL_BANDWIDTH_DIR, 0755);\n\t}\n\t\t\n\tif (stat(RUN_FIREJAIL_NAME_DIR, &s)) {\n\t\tcreate_dir_as_root(RUN_FIREJAIL_NAME_DIR, 0755);\n\t}\n\t\n\tif (stat(RUN_FIREJAIL_X11_DIR, &s)) {\n\t\tcreate_dir_as_root(RUN_FIREJAIL_X11_DIR, 0755);\n\t}\n\t\n\tif (stat(RUN_FIREJAIL_APPIMAGE_DIR, &s)) {\n\t\tcreate_dir_as_root(RUN_FIREJAIL_APPIMAGE_DIR, 0755);\n\t}\n\t\n\tcreate_empty_dir();\n\tcreate_empty_file();\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_build_firejail_dir(void) {\n\tstruct stat s;\n\n\t// CentOS 6 doesn't have /run directory\n\tif (stat(RUN_FIREJAIL_BASEDIR, &s)) {\n\t\tcreate_dir_as_root(RUN_FIREJAIL_BASEDIR, 0755);\n\t}\n\n\t// check /run/firejail directory belongs to root end exit if doesn't!\n\tif (stat(RUN_FIREJAIL_DIR, &s) == 0) {\n\t\tif (s.st_uid != 0 || s.st_gid != 0) {\n\t\t\tfprintf(stderr, \"Error: non-root %s directory, exiting...\\n\", RUN_FIREJAIL_DIR);\n\t\t\texit(1);\n\t\t}\n\t}\n\telse {\n\t\tcreate_dir_as_root(RUN_FIREJAIL_DIR, 0755);\n\t}\n\t\n\tif (stat(RUN_FIREJAIL_NETWORK_DIR, &s)) {\n\t\tcreate_dir_as_root(RUN_FIREJAIL_NETWORK_DIR, 0755);\n\t}\n\t\n\tif (stat(RUN_FIREJAIL_BANDWIDTH_DIR, &s)) {\n\t\tcreate_dir_as_root(RUN_FIREJAIL_BANDWIDTH_DIR, 0755);\n\t}\n\t\t\n\tif (stat(RUN_FIREJAIL_NAME_DIR, &s)) {\n\t\tcreate_dir_as_root(RUN_FIREJAIL_NAME_DIR, 0755);\n\t}\n\t\n\tif (stat(RUN_FIREJAIL_X11_DIR, &s)) {\n\t\tcreate_dir_as_root(RUN_FIREJAIL_X11_DIR, 0755);\n\t}\n\t\n\tif (stat(RUN_FIREJAIL_APPIMAGE_DIR, &s)) {\n\t\tcreate_dir_as_root(RUN_FIREJAIL_APPIMAGE_DIR, 0755);\n\t}\n\t\n\tcreate_empty_dir();\n\tcreate_empty_file();\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "op <OPERATION_MAX"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "filename"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nLAST_DISABLE_OPERATION last_disable = UNSUCCESSFUL;\n\nstatic void disable_file(OPERATION op, const char *filename) {\n\tassert(filename);\n\tassert(op <OPERATION_MAX);\n\tlast_disable = UNSUCCESSFUL;\n\t\n\t// rebuild /run/firejail directory in case tmpfs was mounted on top of /run\n\tfs_build_firejail_dir();\n\t\n\t// Resolve all symlinks\n\tchar* fname = realpath(filename, NULL);\n\tif (fname == NULL && errno != EACCES) {\n\t\treturn;\n\t}\n\tif (fname == NULL && errno == EACCES) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Debug: no access to file %s, forcing mount\\n\", filename);\n\t\t// realpath and stat funtions will fail on FUSE filesystems\n\t\t// they don't seem to like a uid of 0\n\t\t// force mounting\n\t\tint rv = mount(RUN_RO_DIR, filename, \"none\", MS_BIND, \"mode=400,gid=0\");\n\t\tif (rv == 0)\n\t\t\tlast_disable = SUCCESSFUL;\n\t\telse {\n\t\t\trv = mount(RUN_RO_FILE, filename, \"none\", MS_BIND, \"mode=400,gid=0\");\n\t\t\tif (rv == 0)\n\t\t\t\tlast_disable = SUCCESSFUL;\n\t\t}\n\t\tif (last_disable == SUCCESSFUL) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Disable %s\\n\", filename);\n\t\t\tif (op == BLACKLIST_FILE)\n\t\t\t\tfs_logger2(\"blacklist\", filename);\n\t\t\telse\n\t\t\t\tfs_logger2(\"blacklist-nolog\", filename);\n\t\t}\n\t\telse {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Warning (blacklisting): %s is an invalid file, skipping...\\n\", filename);\n\t\t}\n\t\t\t\t\n\t\treturn;\n\t}\n\t\n\t// if the file is not present, do nothing\n\tstruct stat s;\n\tif (fname == NULL)\n\t\treturn;\n\tif (stat(fname, &s) == -1) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Warning: %s does not exist, skipping...\\n\", fname);\n\t\tfree(fname);\n\t\treturn;\n\t}\n\n\t// modify the file\n\tif (op == BLACKLIST_FILE || op == BLACKLIST_NOLOG) {\n\t\t// some distros put all executables under /usr/bin and make /bin a symbolic link\n\t\tif ((strcmp(fname, \"/bin\") == 0 || strcmp(fname, \"/usr/bin\") == 0) &&\n\t\t      is_link(filename) &&\n\t\t      S_ISDIR(s.st_mode))\n\t\t\tfprintf(stderr, \"Warning: %s directory link was not blacklisted\\n\", filename);\n\t\t\t\n\t\telse {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Disable %s\\n\", fname);\n\t\t\telse if (arg_debug_blacklists) {\n\t\t\t\tprintf(\"Disable %s\", fname);\n\t\t\t\tif (op == BLACKLIST_FILE)\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\telse\n\t\t\t\t\tprintf(\" - no logging\\n\");\n\t\t\t}\n\t\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\t\tif (mount(RUN_RO_DIR, fname, \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\t\t\t\terrExit(\"disable file\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (mount(RUN_RO_FILE, fname, \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\t\t\t\terrExit(\"disable file\");\n\t\t\t}\n\t\t\tlast_disable = SUCCESSFUL;\n\t\t\tif (op == BLACKLIST_FILE)\n\t\t\t\tfs_logger2(\"blacklist\", fname);\n\t\t\telse\n\t\t\t\tfs_logger2(\"blacklist-nolog\", fname);\n\t\t}\n\t}\n\telse if (op == MOUNT_READONLY) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting read-only %s\\n\", fname);\n\t\tfs_rdonly(fname);\n// todo: last_disable = SUCCESSFUL;\n\t}\n\telse if (op == MOUNT_RDWR) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting read-only %s\\n\", fname);\n\t\tfs_rdwr(fname);\n// todo: last_disable = SUCCESSFUL;\n\t}\n\telse if (op == MOUNT_NOEXEC) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting noexec %s\\n\", fname);\n\t\tfs_noexec(fname);\n// todo: last_disable = SUCCESSFUL;\n\t}\n\telse if (op == MOUNT_TMPFS) {\n\t\tif (S_ISDIR(s.st_mode)) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Mounting tmpfs on %s\\n\", fname);\n\t\t\t// preserve owner and mode for the directory\n\t\t\tif (mount(\"tmpfs\", fname, \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME | MS_REC,  0) < 0)\n\t\t\t\terrExit(\"mounting tmpfs\");\n\t\t\t/* coverity[toctou] */\n\t\t\tif (chown(fname, s.st_uid, s.st_gid) == -1)\n\t\t\t\terrExit(\"mounting tmpfs chmod\");\n\t\t\tlast_disable = SUCCESSFUL;\n\t\t\tfs_logger2(\"tmpfs\", fname);\n\t\t}\n\t\telse\n\t\t\tprintf(\"Warning: %s is not a directory; cannot mount a tmpfs on top of it.\\n\", fname);\n\t}\n\telse\n\t\tassert(0);\n\n\tfree(fname);\n}"
  },
  {
    "function_name": "fs_delete_cp_command",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
    "lines": "177-179",
    "snippet": "void fs_delete_cp_command(void) {\n\tunlink(RUN_CP_COMMAND);\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "RUN_CP_COMMAND"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_delete_cp_command(void) {\n\tunlink(RUN_CP_COMMAND);\n}"
  },
  {
    "function_name": "fs_build_cp_command",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
    "lines": "148-174",
    "snippet": "void fs_build_cp_command(void) {\n\tstruct stat s;\n\tfs_build_mnt_dir();\n\tif (stat(RUN_CP_COMMAND, &s)) {\n\t\tchar* fname = realpath(\"/bin/cp\", NULL);\n\t\tif (fname == NULL) {\n\t\t\tfprintf(stderr, \"Error: /bin/cp not found\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (stat(fname, &s)) {\n\t\t\tfprintf(stderr, \"Error: /bin/cp not found\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (is_link(fname)) {\n\t\t\tfprintf(stderr, \"Error: invalid /bin/cp file\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tint rv = copy_file(fname, RUN_CP_COMMAND, 0, 0, 0755);\n\t\tif (rv) {\n\t\t\tfprintf(stderr, \"Error: cannot access /bin/cp\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tASSERT_PERMS(RUN_CP_COMMAND, 0, 0, 0755);\n\t\t\t\n\t\tfree(fname);\n\t}\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PERMS",
          "args": [
            "RUN_CP_COMMAND",
            "0",
            "0",
            "0755"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "fs_rdonly_noexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
          "lines": "615-633",
          "snippet": "void fs_rdonly_noexit(const char *dir) {\n\tassert(dir);\n\t// check directory exists\n\tstruct stat s;\n\tint rv = stat(dir, &s);\n\tif (rv == 0) {\n\t\tint merr = 0;\n\t\t// mount --bind /bin /bin\n\t\tif (mount(dir, dir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\tmerr = 1;\n\t\t// mount --bind -o remount,ro /bin\n\t\tif (mount(NULL, dir, NULL, MS_BIND|MS_REMOUNT|MS_RDONLY|MS_REC, NULL) < 0)\n\t\t\tmerr = 1;\n\t\tif (merr)\n\t\t\tfprintf(stderr, \"Warning: cannot mount %s read-only\\n\", dir); \n\t\telse\n\t\t\tfs_logger2(\"read-only\", dir);\n\t}\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fs_rdwr(const char *dir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void fs_rdwr(const char *dir);\n\nvoid fs_rdonly_noexit(const char *dir) {\n\tassert(dir);\n\t// check directory exists\n\tstruct stat s;\n\tint rv = stat(dir, &s);\n\tif (rv == 0) {\n\t\tint merr = 0;\n\t\t// mount --bind /bin /bin\n\t\tif (mount(dir, dir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\tmerr = 1;\n\t\t// mount --bind -o remount,ro /bin\n\t\tif (mount(NULL, dir, NULL, MS_BIND|MS_REMOUNT|MS_RDONLY|MS_REC, NULL) < 0)\n\t\t\tmerr = 1;\n\t\tif (merr)\n\t\t\tfprintf(stderr, \"Warning: cannot mount %s read-only\\n\", dir); \n\t\telse\n\t\t\tfs_logger2(\"read-only\", dir);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot access /bin/cp\\n\""
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_file",
          "args": [
            "fname",
            "RUN_CP_COMMAND",
            "0",
            "0",
            "0755"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "copy_file_as_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/util.c",
          "lines": "224-240",
          "snippet": "void copy_file_as_user(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode) {\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// drop privileges\n\t\tdrop_privs(0);\n\n\t\t// copy, set permissions and ownership\n\t\tint rv = copy_file(srcname, destname, uid, gid, mode);\n\t\tif (rv)\n\t\t\tfprintf(stderr, \"Warning: cannot transfer .Xauthority in private home directory\\n\");\n\t\t_exit(0);\n\t}\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid copy_file_as_user(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode) {\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// drop privileges\n\t\tdrop_privs(0);\n\n\t\t// copy, set permissions and ownership\n\t\tint rv = copy_file(srcname, destname, uid, gid, mode);\n\t\tif (rv)\n\t\t\tfprintf(stderr, \"Warning: cannot transfer .Xauthority in private home directory\\n\");\n\t\t_exit(0);\n\t}\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid /bin/cp file\\n\""
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_link",
          "args": [
            "fname"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "is_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/util.c",
          "lines": "295-307",
          "snippet": "int is_link(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\tstruct stat s;\n\tif (lstat(fname, &s) == 0) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nint is_link(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\tstruct stat s;\n\tif (lstat(fname, &s) == 0) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: /bin/cp not found\\n\""
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "fname",
            "&s"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: /bin/cp not found\\n\""
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realpath",
          "args": [
            "\"/bin/cp\"",
            "NULL"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "RUN_CP_COMMAND",
            "&s"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_build_mnt_dir",
          "args": [],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "fs_build_mnt_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
          "lines": "126-145",
          "snippet": "void fs_build_mnt_dir(void) {\n\tstruct stat s;\n\tfs_build_firejail_dir();\n\t\n\t// create /run/firejail/mnt directory\n\tif (stat(RUN_MNT_DIR, &s)) {\n\t\tcreate_dir_as_root(RUN_MNT_DIR, 0755);\n\t}\n\n\t// ... and mount tmpfs on top of it\n\tif (!tmpfs_mounted) {\n\t\t// mount tmpfs on top of /run/firejail/mnt\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on %s directory\\n\", RUN_MNT_DIR);\n\t\tif (mount(\"tmpfs\", RUN_MNT_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /run/firejail/mnt\");\n\t\ttmpfs_mounted = 1;\n\t\tfs_logger2(\"tmpfs\", RUN_MNT_DIR);\n\t}\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int tmpfs_mounted = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic int tmpfs_mounted = 0;\n\nvoid fs_build_mnt_dir(void) {\n\tstruct stat s;\n\tfs_build_firejail_dir();\n\t\n\t// create /run/firejail/mnt directory\n\tif (stat(RUN_MNT_DIR, &s)) {\n\t\tcreate_dir_as_root(RUN_MNT_DIR, 0755);\n\t}\n\n\t// ... and mount tmpfs on top of it\n\tif (!tmpfs_mounted) {\n\t\t// mount tmpfs on top of /run/firejail/mnt\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on %s directory\\n\", RUN_MNT_DIR);\n\t\tif (mount(\"tmpfs\", RUN_MNT_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /run/firejail/mnt\");\n\t\ttmpfs_mounted = 1;\n\t\tfs_logger2(\"tmpfs\", RUN_MNT_DIR);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_build_cp_command(void) {\n\tstruct stat s;\n\tfs_build_mnt_dir();\n\tif (stat(RUN_CP_COMMAND, &s)) {\n\t\tchar* fname = realpath(\"/bin/cp\", NULL);\n\t\tif (fname == NULL) {\n\t\t\tfprintf(stderr, \"Error: /bin/cp not found\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (stat(fname, &s)) {\n\t\t\tfprintf(stderr, \"Error: /bin/cp not found\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (is_link(fname)) {\n\t\t\tfprintf(stderr, \"Error: invalid /bin/cp file\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tint rv = copy_file(fname, RUN_CP_COMMAND, 0, 0, 0755);\n\t\tif (rv) {\n\t\t\tfprintf(stderr, \"Error: cannot access /bin/cp\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tASSERT_PERMS(RUN_CP_COMMAND, 0, 0, 0755);\n\t\t\t\n\t\tfree(fname);\n\t}\n}"
  },
  {
    "function_name": "fs_build_mnt_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
    "lines": "126-145",
    "snippet": "void fs_build_mnt_dir(void) {\n\tstruct stat s;\n\tfs_build_firejail_dir();\n\t\n\t// create /run/firejail/mnt directory\n\tif (stat(RUN_MNT_DIR, &s)) {\n\t\tcreate_dir_as_root(RUN_MNT_DIR, 0755);\n\t}\n\n\t// ... and mount tmpfs on top of it\n\tif (!tmpfs_mounted) {\n\t\t// mount tmpfs on top of /run/firejail/mnt\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on %s directory\\n\", RUN_MNT_DIR);\n\t\tif (mount(\"tmpfs\", RUN_MNT_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /run/firejail/mnt\");\n\t\ttmpfs_mounted = 1;\n\t\tfs_logger2(\"tmpfs\", RUN_MNT_DIR);\n\t}\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int tmpfs_mounted = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_logger2",
          "args": [
            "\"tmpfs\"",
            "RUN_MNT_DIR"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger2int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_logger.c",
          "lines": "73-80",
          "snippet": "void fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mounting /run/firejail/mnt\""
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"tmpfs\"",
            "RUN_MNT_DIR",
            "\"tmpfs\"",
            "MS_NOSUID | MS_STRICTATIME | MS_REC",
            "\"mode=755,gid=0\""
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Mounting tmpfs on %s directory\\n\"",
            "RUN_MNT_DIR"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_dir_as_root",
          "args": [
            "RUN_MNT_DIR",
            "0755"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "create_dir_as_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
          "lines": "32-43",
          "snippet": "static void create_dir_as_root(const char *dir, mode_t mode) {\n\tassert(dir);\n\tif (arg_debug)\n\t\tprintf(\"Creating %s directory\\n\", dir);\n\n\tif (mkdir(dir, mode) == -1)\n\t\terrExit(\"mkdir\");\n\tif (chmod(dir, mode) == -1)\n\t\terrExit(\"chmod\");\n\n\tASSERT_PERMS(dir, 0, 0, mode);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fs_rdwr(const char *dir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void fs_rdwr(const char *dir);\n\nstatic void create_dir_as_root(const char *dir, mode_t mode) {\n\tassert(dir);\n\tif (arg_debug)\n\t\tprintf(\"Creating %s directory\\n\", dir);\n\n\tif (mkdir(dir, mode) == -1)\n\t\terrExit(\"mkdir\");\n\tif (chmod(dir, mode) == -1)\n\t\terrExit(\"chmod\");\n\n\tASSERT_PERMS(dir, 0, 0, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "RUN_MNT_DIR",
            "&s"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_build_firejail_dir",
          "args": [],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "fs_build_firejail_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
          "lines": "73-114",
          "snippet": "void fs_build_firejail_dir(void) {\n\tstruct stat s;\n\n\t// CentOS 6 doesn't have /run directory\n\tif (stat(RUN_FIREJAIL_BASEDIR, &s)) {\n\t\tcreate_dir_as_root(RUN_FIREJAIL_BASEDIR, 0755);\n\t}\n\n\t// check /run/firejail directory belongs to root end exit if doesn't!\n\tif (stat(RUN_FIREJAIL_DIR, &s) == 0) {\n\t\tif (s.st_uid != 0 || s.st_gid != 0) {\n\t\t\tfprintf(stderr, \"Error: non-root %s directory, exiting...\\n\", RUN_FIREJAIL_DIR);\n\t\t\texit(1);\n\t\t}\n\t}\n\telse {\n\t\tcreate_dir_as_root(RUN_FIREJAIL_DIR, 0755);\n\t}\n\t\n\tif (stat(RUN_FIREJAIL_NETWORK_DIR, &s)) {\n\t\tcreate_dir_as_root(RUN_FIREJAIL_NETWORK_DIR, 0755);\n\t}\n\t\n\tif (stat(RUN_FIREJAIL_BANDWIDTH_DIR, &s)) {\n\t\tcreate_dir_as_root(RUN_FIREJAIL_BANDWIDTH_DIR, 0755);\n\t}\n\t\t\n\tif (stat(RUN_FIREJAIL_NAME_DIR, &s)) {\n\t\tcreate_dir_as_root(RUN_FIREJAIL_NAME_DIR, 0755);\n\t}\n\t\n\tif (stat(RUN_FIREJAIL_X11_DIR, &s)) {\n\t\tcreate_dir_as_root(RUN_FIREJAIL_X11_DIR, 0755);\n\t}\n\t\n\tif (stat(RUN_FIREJAIL_APPIMAGE_DIR, &s)) {\n\t\tcreate_dir_as_root(RUN_FIREJAIL_APPIMAGE_DIR, 0755);\n\t}\n\t\n\tcreate_empty_dir();\n\tcreate_empty_file();\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_build_firejail_dir(void) {\n\tstruct stat s;\n\n\t// CentOS 6 doesn't have /run directory\n\tif (stat(RUN_FIREJAIL_BASEDIR, &s)) {\n\t\tcreate_dir_as_root(RUN_FIREJAIL_BASEDIR, 0755);\n\t}\n\n\t// check /run/firejail directory belongs to root end exit if doesn't!\n\tif (stat(RUN_FIREJAIL_DIR, &s) == 0) {\n\t\tif (s.st_uid != 0 || s.st_gid != 0) {\n\t\t\tfprintf(stderr, \"Error: non-root %s directory, exiting...\\n\", RUN_FIREJAIL_DIR);\n\t\t\texit(1);\n\t\t}\n\t}\n\telse {\n\t\tcreate_dir_as_root(RUN_FIREJAIL_DIR, 0755);\n\t}\n\t\n\tif (stat(RUN_FIREJAIL_NETWORK_DIR, &s)) {\n\t\tcreate_dir_as_root(RUN_FIREJAIL_NETWORK_DIR, 0755);\n\t}\n\t\n\tif (stat(RUN_FIREJAIL_BANDWIDTH_DIR, &s)) {\n\t\tcreate_dir_as_root(RUN_FIREJAIL_BANDWIDTH_DIR, 0755);\n\t}\n\t\t\n\tif (stat(RUN_FIREJAIL_NAME_DIR, &s)) {\n\t\tcreate_dir_as_root(RUN_FIREJAIL_NAME_DIR, 0755);\n\t}\n\t\n\tif (stat(RUN_FIREJAIL_X11_DIR, &s)) {\n\t\tcreate_dir_as_root(RUN_FIREJAIL_X11_DIR, 0755);\n\t}\n\t\n\tif (stat(RUN_FIREJAIL_APPIMAGE_DIR, &s)) {\n\t\tcreate_dir_as_root(RUN_FIREJAIL_APPIMAGE_DIR, 0755);\n\t}\n\t\n\tcreate_empty_dir();\n\tcreate_empty_file();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic int tmpfs_mounted = 0;\n\nvoid fs_build_mnt_dir(void) {\n\tstruct stat s;\n\tfs_build_firejail_dir();\n\t\n\t// create /run/firejail/mnt directory\n\tif (stat(RUN_MNT_DIR, &s)) {\n\t\tcreate_dir_as_root(RUN_MNT_DIR, 0755);\n\t}\n\n\t// ... and mount tmpfs on top of it\n\tif (!tmpfs_mounted) {\n\t\t// mount tmpfs on top of /run/firejail/mnt\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on %s directory\\n\", RUN_MNT_DIR);\n\t\tif (mount(\"tmpfs\", RUN_MNT_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /run/firejail/mnt\");\n\t\ttmpfs_mounted = 1;\n\t\tfs_logger2(\"tmpfs\", RUN_MNT_DIR);\n\t}\n}"
  },
  {
    "function_name": "fs_build_remount_mnt_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
    "lines": "120-123",
    "snippet": "static void fs_build_remount_mnt_dir(void) {\n\ttmpfs_mounted = 0;\n\tfs_build_mnt_dir();\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int tmpfs_mounted = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_build_mnt_dir",
          "args": [],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "fs_build_mnt_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
          "lines": "126-145",
          "snippet": "void fs_build_mnt_dir(void) {\n\tstruct stat s;\n\tfs_build_firejail_dir();\n\t\n\t// create /run/firejail/mnt directory\n\tif (stat(RUN_MNT_DIR, &s)) {\n\t\tcreate_dir_as_root(RUN_MNT_DIR, 0755);\n\t}\n\n\t// ... and mount tmpfs on top of it\n\tif (!tmpfs_mounted) {\n\t\t// mount tmpfs on top of /run/firejail/mnt\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on %s directory\\n\", RUN_MNT_DIR);\n\t\tif (mount(\"tmpfs\", RUN_MNT_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /run/firejail/mnt\");\n\t\ttmpfs_mounted = 1;\n\t\tfs_logger2(\"tmpfs\", RUN_MNT_DIR);\n\t}\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int tmpfs_mounted = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic int tmpfs_mounted = 0;\n\nvoid fs_build_mnt_dir(void) {\n\tstruct stat s;\n\tfs_build_firejail_dir();\n\t\n\t// create /run/firejail/mnt directory\n\tif (stat(RUN_MNT_DIR, &s)) {\n\t\tcreate_dir_as_root(RUN_MNT_DIR, 0755);\n\t}\n\n\t// ... and mount tmpfs on top of it\n\tif (!tmpfs_mounted) {\n\t\t// mount tmpfs on top of /run/firejail/mnt\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on %s directory\\n\", RUN_MNT_DIR);\n\t\tif (mount(\"tmpfs\", RUN_MNT_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /run/firejail/mnt\");\n\t\ttmpfs_mounted = 1;\n\t\tfs_logger2(\"tmpfs\", RUN_MNT_DIR);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic int tmpfs_mounted = 0;\n\nstatic void fs_build_remount_mnt_dir(void) {\n\ttmpfs_mounted = 0;\n\tfs_build_mnt_dir();\n}"
  },
  {
    "function_name": "fs_build_firejail_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
    "lines": "73-114",
    "snippet": "void fs_build_firejail_dir(void) {\n\tstruct stat s;\n\n\t// CentOS 6 doesn't have /run directory\n\tif (stat(RUN_FIREJAIL_BASEDIR, &s)) {\n\t\tcreate_dir_as_root(RUN_FIREJAIL_BASEDIR, 0755);\n\t}\n\n\t// check /run/firejail directory belongs to root end exit if doesn't!\n\tif (stat(RUN_FIREJAIL_DIR, &s) == 0) {\n\t\tif (s.st_uid != 0 || s.st_gid != 0) {\n\t\t\tfprintf(stderr, \"Error: non-root %s directory, exiting...\\n\", RUN_FIREJAIL_DIR);\n\t\t\texit(1);\n\t\t}\n\t}\n\telse {\n\t\tcreate_dir_as_root(RUN_FIREJAIL_DIR, 0755);\n\t}\n\t\n\tif (stat(RUN_FIREJAIL_NETWORK_DIR, &s)) {\n\t\tcreate_dir_as_root(RUN_FIREJAIL_NETWORK_DIR, 0755);\n\t}\n\t\n\tif (stat(RUN_FIREJAIL_BANDWIDTH_DIR, &s)) {\n\t\tcreate_dir_as_root(RUN_FIREJAIL_BANDWIDTH_DIR, 0755);\n\t}\n\t\t\n\tif (stat(RUN_FIREJAIL_NAME_DIR, &s)) {\n\t\tcreate_dir_as_root(RUN_FIREJAIL_NAME_DIR, 0755);\n\t}\n\t\n\tif (stat(RUN_FIREJAIL_X11_DIR, &s)) {\n\t\tcreate_dir_as_root(RUN_FIREJAIL_X11_DIR, 0755);\n\t}\n\t\n\tif (stat(RUN_FIREJAIL_APPIMAGE_DIR, &s)) {\n\t\tcreate_dir_as_root(RUN_FIREJAIL_APPIMAGE_DIR, 0755);\n\t}\n\t\n\tcreate_empty_dir();\n\tcreate_empty_file();\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "create_empty_file",
          "args": [],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "create_empty_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
          "lines": "58-70",
          "snippet": "static void create_empty_file(void) {\n\tstruct stat s;\n\n\tif (stat(RUN_RO_FILE, &s)) {\n\t\t/* coverity[toctou] */\n\t\tFILE *fp = fopen(RUN_RO_FILE, \"w\");\n\t\tif (!fp)\n\t\t\terrExit(\"fopen\");\n\n\t\tSET_PERMS_STREAM(fp, 0, 0, S_IRUSR);\n\t\tfclose(fp);\n\t}\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void create_empty_file(void) {\n\tstruct stat s;\n\n\tif (stat(RUN_RO_FILE, &s)) {\n\t\t/* coverity[toctou] */\n\t\tFILE *fp = fopen(RUN_RO_FILE, \"w\");\n\t\tif (!fp)\n\t\t\terrExit(\"fopen\");\n\n\t\tSET_PERMS_STREAM(fp, 0, 0, S_IRUSR);\n\t\tfclose(fp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_empty_dir",
          "args": [],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "create_empty_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
          "lines": "45-56",
          "snippet": "static void create_empty_dir(void) {\n\tstruct stat s;\n\t\n\tif (stat(RUN_RO_DIR, &s)) {\n\t\t/* coverity[toctou] */\n\t\tif (mkdir(RUN_RO_DIR, S_IRUSR | S_IXUSR) == -1)\n\t\t\terrExit(\"mkdir\");\n\t\tif (chmod(RUN_RO_DIR, S_IRUSR | S_IXUSR) == -1)\n\t\t\terrExit(\"chmod\");\n\t\tASSERT_PERMS(RUN_RO_DIR, 0, 0, S_IRUSR | S_IXUSR);\n\t}\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void create_empty_dir(void) {\n\tstruct stat s;\n\t\n\tif (stat(RUN_RO_DIR, &s)) {\n\t\t/* coverity[toctou] */\n\t\tif (mkdir(RUN_RO_DIR, S_IRUSR | S_IXUSR) == -1)\n\t\t\terrExit(\"mkdir\");\n\t\tif (chmod(RUN_RO_DIR, S_IRUSR | S_IXUSR) == -1)\n\t\t\terrExit(\"chmod\");\n\t\tASSERT_PERMS(RUN_RO_DIR, 0, 0, S_IRUSR | S_IXUSR);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_dir_as_root",
          "args": [
            "RUN_FIREJAIL_APPIMAGE_DIR",
            "0755"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "create_dir_as_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
          "lines": "32-43",
          "snippet": "static void create_dir_as_root(const char *dir, mode_t mode) {\n\tassert(dir);\n\tif (arg_debug)\n\t\tprintf(\"Creating %s directory\\n\", dir);\n\n\tif (mkdir(dir, mode) == -1)\n\t\terrExit(\"mkdir\");\n\tif (chmod(dir, mode) == -1)\n\t\terrExit(\"chmod\");\n\n\tASSERT_PERMS(dir, 0, 0, mode);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fs_rdwr(const char *dir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void fs_rdwr(const char *dir);\n\nstatic void create_dir_as_root(const char *dir, mode_t mode) {\n\tassert(dir);\n\tif (arg_debug)\n\t\tprintf(\"Creating %s directory\\n\", dir);\n\n\tif (mkdir(dir, mode) == -1)\n\t\terrExit(\"mkdir\");\n\tif (chmod(dir, mode) == -1)\n\t\terrExit(\"chmod\");\n\n\tASSERT_PERMS(dir, 0, 0, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "RUN_FIREJAIL_APPIMAGE_DIR",
            "&s"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "RUN_FIREJAIL_X11_DIR",
            "&s"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "RUN_FIREJAIL_NAME_DIR",
            "&s"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "RUN_FIREJAIL_BANDWIDTH_DIR",
            "&s"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "RUN_FIREJAIL_NETWORK_DIR",
            "&s"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "fs_rdonly_noexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
          "lines": "615-633",
          "snippet": "void fs_rdonly_noexit(const char *dir) {\n\tassert(dir);\n\t// check directory exists\n\tstruct stat s;\n\tint rv = stat(dir, &s);\n\tif (rv == 0) {\n\t\tint merr = 0;\n\t\t// mount --bind /bin /bin\n\t\tif (mount(dir, dir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\tmerr = 1;\n\t\t// mount --bind -o remount,ro /bin\n\t\tif (mount(NULL, dir, NULL, MS_BIND|MS_REMOUNT|MS_RDONLY|MS_REC, NULL) < 0)\n\t\t\tmerr = 1;\n\t\tif (merr)\n\t\t\tfprintf(stderr, \"Warning: cannot mount %s read-only\\n\", dir); \n\t\telse\n\t\t\tfs_logger2(\"read-only\", dir);\n\t}\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fs_rdwr(const char *dir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void fs_rdwr(const char *dir);\n\nvoid fs_rdonly_noexit(const char *dir) {\n\tassert(dir);\n\t// check directory exists\n\tstruct stat s;\n\tint rv = stat(dir, &s);\n\tif (rv == 0) {\n\t\tint merr = 0;\n\t\t// mount --bind /bin /bin\n\t\tif (mount(dir, dir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\tmerr = 1;\n\t\t// mount --bind -o remount,ro /bin\n\t\tif (mount(NULL, dir, NULL, MS_BIND|MS_REMOUNT|MS_RDONLY|MS_REC, NULL) < 0)\n\t\t\tmerr = 1;\n\t\tif (merr)\n\t\t\tfprintf(stderr, \"Warning: cannot mount %s read-only\\n\", dir); \n\t\telse\n\t\t\tfs_logger2(\"read-only\", dir);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: non-root %s directory, exiting...\\n\"",
            "RUN_FIREJAIL_DIR"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "RUN_FIREJAIL_DIR",
            "&s"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "RUN_FIREJAIL_BASEDIR",
            "&s"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_build_firejail_dir(void) {\n\tstruct stat s;\n\n\t// CentOS 6 doesn't have /run directory\n\tif (stat(RUN_FIREJAIL_BASEDIR, &s)) {\n\t\tcreate_dir_as_root(RUN_FIREJAIL_BASEDIR, 0755);\n\t}\n\n\t// check /run/firejail directory belongs to root end exit if doesn't!\n\tif (stat(RUN_FIREJAIL_DIR, &s) == 0) {\n\t\tif (s.st_uid != 0 || s.st_gid != 0) {\n\t\t\tfprintf(stderr, \"Error: non-root %s directory, exiting...\\n\", RUN_FIREJAIL_DIR);\n\t\t\texit(1);\n\t\t}\n\t}\n\telse {\n\t\tcreate_dir_as_root(RUN_FIREJAIL_DIR, 0755);\n\t}\n\t\n\tif (stat(RUN_FIREJAIL_NETWORK_DIR, &s)) {\n\t\tcreate_dir_as_root(RUN_FIREJAIL_NETWORK_DIR, 0755);\n\t}\n\t\n\tif (stat(RUN_FIREJAIL_BANDWIDTH_DIR, &s)) {\n\t\tcreate_dir_as_root(RUN_FIREJAIL_BANDWIDTH_DIR, 0755);\n\t}\n\t\t\n\tif (stat(RUN_FIREJAIL_NAME_DIR, &s)) {\n\t\tcreate_dir_as_root(RUN_FIREJAIL_NAME_DIR, 0755);\n\t}\n\t\n\tif (stat(RUN_FIREJAIL_X11_DIR, &s)) {\n\t\tcreate_dir_as_root(RUN_FIREJAIL_X11_DIR, 0755);\n\t}\n\t\n\tif (stat(RUN_FIREJAIL_APPIMAGE_DIR, &s)) {\n\t\tcreate_dir_as_root(RUN_FIREJAIL_APPIMAGE_DIR, 0755);\n\t}\n\t\n\tcreate_empty_dir();\n\tcreate_empty_file();\n}"
  },
  {
    "function_name": "create_empty_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
    "lines": "58-70",
    "snippet": "static void create_empty_file(void) {\n\tstruct stat s;\n\n\tif (stat(RUN_RO_FILE, &s)) {\n\t\t/* coverity[toctou] */\n\t\tFILE *fp = fopen(RUN_RO_FILE, \"w\");\n\t\tif (!fp)\n\t\t\terrExit(\"fopen\");\n\n\t\tSET_PERMS_STREAM(fp, 0, 0, S_IRUSR);\n\t\tfclose(fp);\n\t}\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_PERMS_STREAM",
          "args": [
            "fp",
            "0",
            "0",
            "S_IRUSR"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fopen\""
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "RUN_RO_FILE",
            "\"w\""
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "RUN_RO_FILE",
            "&s"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void create_empty_file(void) {\n\tstruct stat s;\n\n\tif (stat(RUN_RO_FILE, &s)) {\n\t\t/* coverity[toctou] */\n\t\tFILE *fp = fopen(RUN_RO_FILE, \"w\");\n\t\tif (!fp)\n\t\t\terrExit(\"fopen\");\n\n\t\tSET_PERMS_STREAM(fp, 0, 0, S_IRUSR);\n\t\tfclose(fp);\n\t}\n}"
  },
  {
    "function_name": "create_empty_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
    "lines": "45-56",
    "snippet": "static void create_empty_dir(void) {\n\tstruct stat s;\n\t\n\tif (stat(RUN_RO_DIR, &s)) {\n\t\t/* coverity[toctou] */\n\t\tif (mkdir(RUN_RO_DIR, S_IRUSR | S_IXUSR) == -1)\n\t\t\terrExit(\"mkdir\");\n\t\tif (chmod(RUN_RO_DIR, S_IRUSR | S_IXUSR) == -1)\n\t\t\terrExit(\"chmod\");\n\t\tASSERT_PERMS(RUN_RO_DIR, 0, 0, S_IRUSR | S_IXUSR);\n\t}\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT_PERMS",
          "args": [
            "RUN_RO_DIR",
            "0",
            "0",
            "S_IRUSR | S_IXUSR"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"chmod\""
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chmod",
          "args": [
            "RUN_RO_DIR",
            "S_IRUSR | S_IXUSR"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mkdir\""
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "RUN_RO_DIR",
            "S_IRUSR | S_IXUSR"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "RUN_RO_DIR",
            "&s"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void create_empty_dir(void) {\n\tstruct stat s;\n\t\n\tif (stat(RUN_RO_DIR, &s)) {\n\t\t/* coverity[toctou] */\n\t\tif (mkdir(RUN_RO_DIR, S_IRUSR | S_IXUSR) == -1)\n\t\t\terrExit(\"mkdir\");\n\t\tif (chmod(RUN_RO_DIR, S_IRUSR | S_IXUSR) == -1)\n\t\t\terrExit(\"chmod\");\n\t\tASSERT_PERMS(RUN_RO_DIR, 0, 0, S_IRUSR | S_IXUSR);\n\t}\n}"
  },
  {
    "function_name": "create_dir_as_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
    "lines": "32-43",
    "snippet": "static void create_dir_as_root(const char *dir, mode_t mode) {\n\tassert(dir);\n\tif (arg_debug)\n\t\tprintf(\"Creating %s directory\\n\", dir);\n\n\tif (mkdir(dir, mode) == -1)\n\t\terrExit(\"mkdir\");\n\tif (chmod(dir, mode) == -1)\n\t\terrExit(\"chmod\");\n\n\tASSERT_PERMS(dir, 0, 0, mode);\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void fs_rdwr(const char *dir);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT_PERMS",
          "args": [
            "dir",
            "0",
            "0",
            "mode"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"chmod\""
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chmod",
          "args": [
            "dir",
            "mode"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mkdir\""
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "dir",
            "mode"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Creating %s directory\\n\"",
            "dir"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "dir"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void fs_rdwr(const char *dir);\n\nstatic void create_dir_as_root(const char *dir, mode_t mode) {\n\tassert(dir);\n\tif (arg_debug)\n\t\tprintf(\"Creating %s directory\\n\", dir);\n\n\tif (mkdir(dir, mode) == -1)\n\t\terrExit(\"mkdir\");\n\tif (chmod(dir, mode) == -1)\n\t\terrExit(\"chmod\");\n\n\tASSERT_PERMS(dir, 0, 0, mode);\n}"
  }
]