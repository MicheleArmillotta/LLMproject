[
  {
    "function_name": "build_cmdline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/cmdline.c",
    "lines": "137-159",
    "snippet": "void build_cmdline(char **command_line, char **window_title, int argc, char **argv, int index) {\n\t// index == -1 could happen if we have --shell=none and no program was specified\n\t// the program should exit with an error before entering this function\n\tassert(index != -1);\n\n\tint len = cmdline_length(argc, argv, index);\n\tif (len > ARG_MAX) {\n\t\terrno = E2BIG;\n\t\terrExit(\"cmdline_length\");\n\t}\n\n\t*command_line = malloc(len + 1);\n\tif (!*command_line)\n\t\t\terrExit(\"malloc\");\n\t*window_title = malloc(len + 1);\n\tif (!*window_title)\n\t\t\terrExit(\"malloc\");\n\t\n\tquote_cmdline(*command_line, *window_title, len, argc, argv, index);\n\n\tassert(*command_line);\n\tassert(*window_title);\n}",
    "includes": [
      "#include <errno.h>",
      "#include <assert.h>",
      "#include <linux/limits.h>",
      "#include <stdio.h>",
      "#include <stdbool.h>",
      "#include <string.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "*window_title"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "*command_line"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "quote_cmdline",
          "args": [
            "*command_line",
            "*window_title",
            "len",
            "argc",
            "argv",
            "index"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "quote_cmdline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/cmdline.c",
          "lines": "67-135",
          "snippet": "static void quote_cmdline(char *command_line, char *window_title, int len, int argc, char **argv, int index) {\n\tassert(index != -1);\n\n\tunsigned i,j;\n\tunsigned argcnt = argc - index;\n\tbool in_quotes = false;\n\tchar *ptr1 = command_line;\n\tchar *ptr2 = window_title;\n\n\tfor (i = 0; i < argcnt; i++) {\n\n\t\t// enclose args by single quotes,\n\t\t// and since single quote can't be represented in single quoted text\n\t\t// each occurence of it should be enclosed by double quotes\n\t\tin_quotes = false;\n\t\tfor (j = 0; j < strlen(argv[i + index]); j++) {\n\t\t\t// single quote\n\t\t\tif (argv[i + index][j] == '\\'') {\n\t\t\t\tif (in_quotes) {\n\t\t\t\t\t// close quotes\n\t\t\t\t\tptr1[0] = '\\'';\n\t\t\t\t\tptr1++;\n\t\t\t\t}\n\t\t\t\t// previous char was single quote too\n\t\t\t\tif (j > 0 && argv[i + index][j-1] == '\\'') {\n\t\t\t\t\tptr1--;\n\t\t\t\t\tsprintf(ptr1, \"\\'\\\"\");\n\t\t\t\t} \n\t\t\t\t// this first in series\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsprintf(ptr1, \"\\\"\\'\\\"\");\n\t\t\t\t}\n\t\t\t\tptr1 += strlen(ptr1);\n\t\t\t\tin_quotes = false;\n\t\t\t}\n\t\t\t// anything other\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!in_quotes) {\n\t\t\t\t\t// open quotes\n\t\t\t\t\tptr1[0] = '\\'';\n\t\t\t\t\tptr1++;\n\t\t\t\t}\n\t\t\t\tptr1[0] = argv[i + index][j];\n\t\t\t\tptr1++;\n\t\t\t\tin_quotes = true;\n\t\t\t}\n\t\t}\n\t\t// close quotes\n\t\tif (in_quotes) {\n\t\t\tptr1[0] = '\\'';\n\t\t\tptr1++;\n\t\t}\n\t\t// handle empty argument case\n\t\tif (strlen(argv[i + index]) == 0) {\n\t\t\tsprintf(ptr1, \"\\'\\'\");\n\t\t\tptr1 += strlen(ptr1);\n\t\t}\n\t\t// add space\n\t\tsprintf(ptr1, \" \");\n\t\tptr1 += strlen(ptr1);\n\n\t\tsprintf(ptr2, \"%s \", argv[i + index]);\n\t\tptr2 += strlen(ptr2);\n\t}\n\n\tassert((unsigned) len == strlen(command_line));\n}",
          "includes": [
            "#include <errno.h>",
            "#include <assert.h>",
            "#include <linux/limits.h>",
            "#include <stdio.h>",
            "#include <stdbool.h>",
            "#include <string.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <assert.h>\n#include <linux/limits.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n#include \"firejail.h\"\n\nstatic void quote_cmdline(char *command_line, char *window_title, int len, int argc, char **argv, int index) {\n\tassert(index != -1);\n\n\tunsigned i,j;\n\tunsigned argcnt = argc - index;\n\tbool in_quotes = false;\n\tchar *ptr1 = command_line;\n\tchar *ptr2 = window_title;\n\n\tfor (i = 0; i < argcnt; i++) {\n\n\t\t// enclose args by single quotes,\n\t\t// and since single quote can't be represented in single quoted text\n\t\t// each occurence of it should be enclosed by double quotes\n\t\tin_quotes = false;\n\t\tfor (j = 0; j < strlen(argv[i + index]); j++) {\n\t\t\t// single quote\n\t\t\tif (argv[i + index][j] == '\\'') {\n\t\t\t\tif (in_quotes) {\n\t\t\t\t\t// close quotes\n\t\t\t\t\tptr1[0] = '\\'';\n\t\t\t\t\tptr1++;\n\t\t\t\t}\n\t\t\t\t// previous char was single quote too\n\t\t\t\tif (j > 0 && argv[i + index][j-1] == '\\'') {\n\t\t\t\t\tptr1--;\n\t\t\t\t\tsprintf(ptr1, \"\\'\\\"\");\n\t\t\t\t} \n\t\t\t\t// this first in series\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsprintf(ptr1, \"\\\"\\'\\\"\");\n\t\t\t\t}\n\t\t\t\tptr1 += strlen(ptr1);\n\t\t\t\tin_quotes = false;\n\t\t\t}\n\t\t\t// anything other\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!in_quotes) {\n\t\t\t\t\t// open quotes\n\t\t\t\t\tptr1[0] = '\\'';\n\t\t\t\t\tptr1++;\n\t\t\t\t}\n\t\t\t\tptr1[0] = argv[i + index][j];\n\t\t\t\tptr1++;\n\t\t\t\tin_quotes = true;\n\t\t\t}\n\t\t}\n\t\t// close quotes\n\t\tif (in_quotes) {\n\t\t\tptr1[0] = '\\'';\n\t\t\tptr1++;\n\t\t}\n\t\t// handle empty argument case\n\t\tif (strlen(argv[i + index]) == 0) {\n\t\t\tsprintf(ptr1, \"\\'\\'\");\n\t\t\tptr1 += strlen(ptr1);\n\t\t}\n\t\t// add space\n\t\tsprintf(ptr1, \" \");\n\t\tptr1 += strlen(ptr1);\n\n\t\tsprintf(ptr2, \"%s \", argv[i + index]);\n\t\tptr2 += strlen(ptr2);\n\t}\n\n\tassert((unsigned) len == strlen(command_line));\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"malloc\""
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len + 1"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"malloc\""
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len + 1"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"cmdline_length\""
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmdline_length",
          "args": [
            "argc",
            "argv",
            "index"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "cmdline_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/cmdline.c",
          "lines": "29-65",
          "snippet": "static int cmdline_length(int argc, char **argv, int index) {\n\tassert(index != -1);\n\t\n\tunsigned i,j;\n\tint len = 0;\n\tunsigned argcnt = argc - index;\n\tbool in_quotes = false;\n\n\tfor (i = 0; i < argcnt; i++) {\n\t\tin_quotes = false;\n\t\tfor (j = 0; j < strlen(argv[i + index]); j++) {\n\t\t\tif (argv[i + index][j] == '\\'') {\n\t\t\t\tif (in_quotes)\n\t\t\t\t\tlen++;\n\t\t\t\tif (j > 0 && argv[i + index][j-1] == '\\'')\n\t\t\t\t\tlen++;\n\t\t\t\telse\n\t\t\t\t\tlen += 3;\n\t\t\t\tin_quotes = false;\n\t\t\t} else {\n\t\t\t\tif (!in_quotes)\n\t\t\t\t\tlen++;\n\t\t\t\tlen++;\n\t\t\t\tin_quotes = true;\n\t\t\t}\n\t\t}\n\t\tif (in_quotes) {\n\t\t\tlen++;\n\t\t}\n\t\tif (strlen(argv[i + index]) == 0) {\n\t\t\tlen += 2;\n\t\t}\n\t\tlen++;\n\t}\n\n\treturn len;\n}",
          "includes": [
            "#include <errno.h>",
            "#include <assert.h>",
            "#include <linux/limits.h>",
            "#include <stdio.h>",
            "#include <stdbool.h>",
            "#include <string.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <assert.h>\n#include <linux/limits.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n#include \"firejail.h\"\n\nstatic int cmdline_length(int argc, char **argv, int index) {\n\tassert(index != -1);\n\t\n\tunsigned i,j;\n\tint len = 0;\n\tunsigned argcnt = argc - index;\n\tbool in_quotes = false;\n\n\tfor (i = 0; i < argcnt; i++) {\n\t\tin_quotes = false;\n\t\tfor (j = 0; j < strlen(argv[i + index]); j++) {\n\t\t\tif (argv[i + index][j] == '\\'') {\n\t\t\t\tif (in_quotes)\n\t\t\t\t\tlen++;\n\t\t\t\tif (j > 0 && argv[i + index][j-1] == '\\'')\n\t\t\t\t\tlen++;\n\t\t\t\telse\n\t\t\t\t\tlen += 3;\n\t\t\t\tin_quotes = false;\n\t\t\t} else {\n\t\t\t\tif (!in_quotes)\n\t\t\t\t\tlen++;\n\t\t\t\tlen++;\n\t\t\t\tin_quotes = true;\n\t\t\t}\n\t\t}\n\t\tif (in_quotes) {\n\t\t\tlen++;\n\t\t}\n\t\tif (strlen(argv[i + index]) == 0) {\n\t\t\tlen += 2;\n\t\t}\n\t\tlen++;\n\t}\n\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "index != -1"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <assert.h>\n#include <linux/limits.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n#include \"firejail.h\"\n\nvoid build_cmdline(char **command_line, char **window_title, int argc, char **argv, int index) {\n\t// index == -1 could happen if we have --shell=none and no program was specified\n\t// the program should exit with an error before entering this function\n\tassert(index != -1);\n\n\tint len = cmdline_length(argc, argv, index);\n\tif (len > ARG_MAX) {\n\t\terrno = E2BIG;\n\t\terrExit(\"cmdline_length\");\n\t}\n\n\t*command_line = malloc(len + 1);\n\tif (!*command_line)\n\t\t\terrExit(\"malloc\");\n\t*window_title = malloc(len + 1);\n\tif (!*window_title)\n\t\t\terrExit(\"malloc\");\n\t\n\tquote_cmdline(*command_line, *window_title, len, argc, argv, index);\n\n\tassert(*command_line);\n\tassert(*window_title);\n}"
  },
  {
    "function_name": "quote_cmdline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/cmdline.c",
    "lines": "67-135",
    "snippet": "static void quote_cmdline(char *command_line, char *window_title, int len, int argc, char **argv, int index) {\n\tassert(index != -1);\n\n\tunsigned i,j;\n\tunsigned argcnt = argc - index;\n\tbool in_quotes = false;\n\tchar *ptr1 = command_line;\n\tchar *ptr2 = window_title;\n\n\tfor (i = 0; i < argcnt; i++) {\n\n\t\t// enclose args by single quotes,\n\t\t// and since single quote can't be represented in single quoted text\n\t\t// each occurence of it should be enclosed by double quotes\n\t\tin_quotes = false;\n\t\tfor (j = 0; j < strlen(argv[i + index]); j++) {\n\t\t\t// single quote\n\t\t\tif (argv[i + index][j] == '\\'') {\n\t\t\t\tif (in_quotes) {\n\t\t\t\t\t// close quotes\n\t\t\t\t\tptr1[0] = '\\'';\n\t\t\t\t\tptr1++;\n\t\t\t\t}\n\t\t\t\t// previous char was single quote too\n\t\t\t\tif (j > 0 && argv[i + index][j-1] == '\\'') {\n\t\t\t\t\tptr1--;\n\t\t\t\t\tsprintf(ptr1, \"\\'\\\"\");\n\t\t\t\t} \n\t\t\t\t// this first in series\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsprintf(ptr1, \"\\\"\\'\\\"\");\n\t\t\t\t}\n\t\t\t\tptr1 += strlen(ptr1);\n\t\t\t\tin_quotes = false;\n\t\t\t}\n\t\t\t// anything other\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!in_quotes) {\n\t\t\t\t\t// open quotes\n\t\t\t\t\tptr1[0] = '\\'';\n\t\t\t\t\tptr1++;\n\t\t\t\t}\n\t\t\t\tptr1[0] = argv[i + index][j];\n\t\t\t\tptr1++;\n\t\t\t\tin_quotes = true;\n\t\t\t}\n\t\t}\n\t\t// close quotes\n\t\tif (in_quotes) {\n\t\t\tptr1[0] = '\\'';\n\t\t\tptr1++;\n\t\t}\n\t\t// handle empty argument case\n\t\tif (strlen(argv[i + index]) == 0) {\n\t\t\tsprintf(ptr1, \"\\'\\'\");\n\t\t\tptr1 += strlen(ptr1);\n\t\t}\n\t\t// add space\n\t\tsprintf(ptr1, \" \");\n\t\tptr1 += strlen(ptr1);\n\n\t\tsprintf(ptr2, \"%s \", argv[i + index]);\n\t\tptr2 += strlen(ptr2);\n\t}\n\n\tassert((unsigned) len == strlen(command_line));\n}",
    "includes": [
      "#include <errno.h>",
      "#include <assert.h>",
      "#include <linux/limits.h>",
      "#include <stdio.h>",
      "#include <stdbool.h>",
      "#include <string.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "(unsigned) len == strlen(command_line)"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "command_line"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ptr2"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "ptr2",
            "\"%s \"",
            "argv[i + index]"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ptr1"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "ptr1",
            "\" \""
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ptr1"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "ptr1",
            "\"\\'\\'\""
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "argv[i + index]"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ptr1"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "ptr1",
            "\"\\\"\\'\\\"\""
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "ptr1",
            "\"\\'\\\"\""
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "argv[i + index]"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "index != -1"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <assert.h>\n#include <linux/limits.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n#include \"firejail.h\"\n\nstatic void quote_cmdline(char *command_line, char *window_title, int len, int argc, char **argv, int index) {\n\tassert(index != -1);\n\n\tunsigned i,j;\n\tunsigned argcnt = argc - index;\n\tbool in_quotes = false;\n\tchar *ptr1 = command_line;\n\tchar *ptr2 = window_title;\n\n\tfor (i = 0; i < argcnt; i++) {\n\n\t\t// enclose args by single quotes,\n\t\t// and since single quote can't be represented in single quoted text\n\t\t// each occurence of it should be enclosed by double quotes\n\t\tin_quotes = false;\n\t\tfor (j = 0; j < strlen(argv[i + index]); j++) {\n\t\t\t// single quote\n\t\t\tif (argv[i + index][j] == '\\'') {\n\t\t\t\tif (in_quotes) {\n\t\t\t\t\t// close quotes\n\t\t\t\t\tptr1[0] = '\\'';\n\t\t\t\t\tptr1++;\n\t\t\t\t}\n\t\t\t\t// previous char was single quote too\n\t\t\t\tif (j > 0 && argv[i + index][j-1] == '\\'') {\n\t\t\t\t\tptr1--;\n\t\t\t\t\tsprintf(ptr1, \"\\'\\\"\");\n\t\t\t\t} \n\t\t\t\t// this first in series\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsprintf(ptr1, \"\\\"\\'\\\"\");\n\t\t\t\t}\n\t\t\t\tptr1 += strlen(ptr1);\n\t\t\t\tin_quotes = false;\n\t\t\t}\n\t\t\t// anything other\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!in_quotes) {\n\t\t\t\t\t// open quotes\n\t\t\t\t\tptr1[0] = '\\'';\n\t\t\t\t\tptr1++;\n\t\t\t\t}\n\t\t\t\tptr1[0] = argv[i + index][j];\n\t\t\t\tptr1++;\n\t\t\t\tin_quotes = true;\n\t\t\t}\n\t\t}\n\t\t// close quotes\n\t\tif (in_quotes) {\n\t\t\tptr1[0] = '\\'';\n\t\t\tptr1++;\n\t\t}\n\t\t// handle empty argument case\n\t\tif (strlen(argv[i + index]) == 0) {\n\t\t\tsprintf(ptr1, \"\\'\\'\");\n\t\t\tptr1 += strlen(ptr1);\n\t\t}\n\t\t// add space\n\t\tsprintf(ptr1, \" \");\n\t\tptr1 += strlen(ptr1);\n\n\t\tsprintf(ptr2, \"%s \", argv[i + index]);\n\t\tptr2 += strlen(ptr2);\n\t}\n\n\tassert((unsigned) len == strlen(command_line));\n}"
  },
  {
    "function_name": "cmdline_length",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/cmdline.c",
    "lines": "29-65",
    "snippet": "static int cmdline_length(int argc, char **argv, int index) {\n\tassert(index != -1);\n\t\n\tunsigned i,j;\n\tint len = 0;\n\tunsigned argcnt = argc - index;\n\tbool in_quotes = false;\n\n\tfor (i = 0; i < argcnt; i++) {\n\t\tin_quotes = false;\n\t\tfor (j = 0; j < strlen(argv[i + index]); j++) {\n\t\t\tif (argv[i + index][j] == '\\'') {\n\t\t\t\tif (in_quotes)\n\t\t\t\t\tlen++;\n\t\t\t\tif (j > 0 && argv[i + index][j-1] == '\\'')\n\t\t\t\t\tlen++;\n\t\t\t\telse\n\t\t\t\t\tlen += 3;\n\t\t\t\tin_quotes = false;\n\t\t\t} else {\n\t\t\t\tif (!in_quotes)\n\t\t\t\t\tlen++;\n\t\t\t\tlen++;\n\t\t\t\tin_quotes = true;\n\t\t\t}\n\t\t}\n\t\tif (in_quotes) {\n\t\t\tlen++;\n\t\t}\n\t\tif (strlen(argv[i + index]) == 0) {\n\t\t\tlen += 2;\n\t\t}\n\t\tlen++;\n\t}\n\n\treturn len;\n}",
    "includes": [
      "#include <errno.h>",
      "#include <assert.h>",
      "#include <linux/limits.h>",
      "#include <stdio.h>",
      "#include <stdbool.h>",
      "#include <string.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "argv[i + index]"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "argv[i + index]"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "index != -1"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <assert.h>\n#include <linux/limits.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n#include \"firejail.h\"\n\nstatic int cmdline_length(int argc, char **argv, int index) {\n\tassert(index != -1);\n\t\n\tunsigned i,j;\n\tint len = 0;\n\tunsigned argcnt = argc - index;\n\tbool in_quotes = false;\n\n\tfor (i = 0; i < argcnt; i++) {\n\t\tin_quotes = false;\n\t\tfor (j = 0; j < strlen(argv[i + index]); j++) {\n\t\t\tif (argv[i + index][j] == '\\'') {\n\t\t\t\tif (in_quotes)\n\t\t\t\t\tlen++;\n\t\t\t\tif (j > 0 && argv[i + index][j-1] == '\\'')\n\t\t\t\t\tlen++;\n\t\t\t\telse\n\t\t\t\t\tlen += 3;\n\t\t\t\tin_quotes = false;\n\t\t\t} else {\n\t\t\t\tif (!in_quotes)\n\t\t\t\t\tlen++;\n\t\t\t\tlen++;\n\t\t\t\tin_quotes = true;\n\t\t\t}\n\t\t}\n\t\tif (in_quotes) {\n\t\t\tlen++;\n\t\t}\n\t\tif (strlen(argv[i + index]) == 0) {\n\t\t\tlen += 2;\n\t\t}\n\t\tlen++;\n\t}\n\n\treturn len;\n}"
  }
]