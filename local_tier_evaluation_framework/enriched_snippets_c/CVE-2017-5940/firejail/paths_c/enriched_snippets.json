[
  {
    "function_name": "build_paths",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/paths.c",
    "lines": "48-100",
    "snippet": "char **build_paths(void) {\n\tif (initialized) {\n\t\tassert(paths);\n\t\treturn paths;\n\t}\n\tinitialized = 1;\n\t\n\tint cnt = 5;\t// 4 default paths + 1 NULL to end the array\n\tchar *path1 = getenv(\"PATH\");\n\tif (path1) {\n\t\tchar *path2 = strdup(path1);\n\t\tif (!path2)\n\t\t\terrExit(\"strdup\");\n\t\t\n\t\t// use path2 to count the entries\n\t\tchar *ptr = strtok(path2, \":\");\n\t\twhile (ptr) {\n\t\t\tcnt++;\n\t\t\tptr = strtok(NULL, \":\");\n\t\t}\n\t\tfree(path2);\n\t\tpath_cnt = cnt;\n\n\t\t// allocate paths array\n\t\tpaths = malloc(sizeof(char *) * cnt);\n\t\tif (!paths)\n\t\t\terrExit(\"malloc\");\n\t\tmemset(paths, 0, sizeof(char *) * cnt);\n\n\t\t// add default paths\n\t\tadd_path(\"/usr/local/bin\");\n\t\tadd_path(\"/usr/bin\");\n\t\tadd_path(\"/bin\");\n\t\tadd_path(\"/usr/local/sbin\");\n\t\tadd_path(\"/usr/sbin\");\n\t\tadd_path(\"/sbin\");\n\n\t\tpath2 = strdup(path1);\n\t\tif (!path2)\n\t\t\terrExit(\"strdup\");\n\t\t\n\t\t// use path2 to count the entries\n\t\tptr = strtok(path2, \":\");\n\t\twhile (ptr) {\n\t\t\tcnt++;\n\t\t\tadd_path(ptr);\n\t\t\tptr = strtok(NULL, \":\");\n\t\t}\n\t\tfree(path2);\n\t}\n\t\n\treturn paths;\n}",
    "includes": [
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char **paths = NULL;",
      "static int path_cnt = 0;",
      "static char initialized = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "path2"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\":\""
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_path",
          "args": [
            "ptr"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "add_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/paths.c",
          "lines": "26-46",
          "snippet": "static void add_path(const char *path) {\n\tassert(paths);\n\tassert(path_cnt);\n\t\n\t// filter out duplicates\n\tint i;\n\tint empty = 0;\n\tfor (i = 0; i < path_cnt; i++) {\n\t\tif (paths[i] && strcmp(path, paths[i]) == 0) {\n\t\t\treturn;\n\t\t}\n\t\tif (!paths[i]) {\n\t\t\tempty = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tpaths[empty] = strdup(path);\n\tif (!paths[empty])\n\t\terrExit(\"strdup\");\n}",
          "includes": [
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char **paths = NULL;",
            "static int path_cnt = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"firejail.h\"\n\nstatic char **paths = NULL;\nstatic int path_cnt = 0;\n\nstatic void add_path(const char *path) {\n\tassert(paths);\n\tassert(path_cnt);\n\t\n\t// filter out duplicates\n\tint i;\n\tint empty = 0;\n\tfor (i = 0; i < path_cnt; i++) {\n\t\tif (paths[i] && strcmp(path, paths[i]) == 0) {\n\t\t\treturn;\n\t\t}\n\t\tif (!paths[i]) {\n\t\t\tempty = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tpaths[empty] = strdup(path);\n\tif (!paths[empty])\n\t\terrExit(\"strdup\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "path2",
            "\":\""
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"strdup\""
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "path1"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "paths",
            "0",
            "sizeof(char *) * cnt"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"malloc\""
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(char *) * cnt"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "path2"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\":\""
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "path2",
            "\":\""
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"strdup\""
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "path1"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"PATH\""
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "paths"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"firejail.h\"\n\nstatic char **paths = NULL;\nstatic int path_cnt = 0;\nstatic char initialized = 0;\n\nchar **build_paths(void) {\n\tif (initialized) {\n\t\tassert(paths);\n\t\treturn paths;\n\t}\n\tinitialized = 1;\n\t\n\tint cnt = 5;\t// 4 default paths + 1 NULL to end the array\n\tchar *path1 = getenv(\"PATH\");\n\tif (path1) {\n\t\tchar *path2 = strdup(path1);\n\t\tif (!path2)\n\t\t\terrExit(\"strdup\");\n\t\t\n\t\t// use path2 to count the entries\n\t\tchar *ptr = strtok(path2, \":\");\n\t\twhile (ptr) {\n\t\t\tcnt++;\n\t\t\tptr = strtok(NULL, \":\");\n\t\t}\n\t\tfree(path2);\n\t\tpath_cnt = cnt;\n\n\t\t// allocate paths array\n\t\tpaths = malloc(sizeof(char *) * cnt);\n\t\tif (!paths)\n\t\t\terrExit(\"malloc\");\n\t\tmemset(paths, 0, sizeof(char *) * cnt);\n\n\t\t// add default paths\n\t\tadd_path(\"/usr/local/bin\");\n\t\tadd_path(\"/usr/bin\");\n\t\tadd_path(\"/bin\");\n\t\tadd_path(\"/usr/local/sbin\");\n\t\tadd_path(\"/usr/sbin\");\n\t\tadd_path(\"/sbin\");\n\n\t\tpath2 = strdup(path1);\n\t\tif (!path2)\n\t\t\terrExit(\"strdup\");\n\t\t\n\t\t// use path2 to count the entries\n\t\tptr = strtok(path2, \":\");\n\t\twhile (ptr) {\n\t\t\tcnt++;\n\t\t\tadd_path(ptr);\n\t\t\tptr = strtok(NULL, \":\");\n\t\t}\n\t\tfree(path2);\n\t}\n\t\n\treturn paths;\n}"
  },
  {
    "function_name": "add_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/paths.c",
    "lines": "26-46",
    "snippet": "static void add_path(const char *path) {\n\tassert(paths);\n\tassert(path_cnt);\n\t\n\t// filter out duplicates\n\tint i;\n\tint empty = 0;\n\tfor (i = 0; i < path_cnt; i++) {\n\t\tif (paths[i] && strcmp(path, paths[i]) == 0) {\n\t\t\treturn;\n\t\t}\n\t\tif (!paths[i]) {\n\t\t\tempty = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tpaths[empty] = strdup(path);\n\tif (!paths[empty])\n\t\terrExit(\"strdup\");\n}",
    "includes": [
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char **paths = NULL;",
      "static int path_cnt = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"strdup\""
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "path"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "path",
            "paths[i]"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "path_cnt"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "paths"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"firejail.h\"\n\nstatic char **paths = NULL;\nstatic int path_cnt = 0;\n\nstatic void add_path(const char *path) {\n\tassert(paths);\n\tassert(path_cnt);\n\t\n\t// filter out duplicates\n\tint i;\n\tint empty = 0;\n\tfor (i = 0; i < path_cnt; i++) {\n\t\tif (paths[i] && strcmp(path, paths[i]) == 0) {\n\t\t\treturn;\n\t\t}\n\t\tif (!paths[i]) {\n\t\t\tempty = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tpaths[empty] = strdup(path);\n\tif (!paths[empty])\n\t\terrExit(\"strdup\");\n}"
  }
]