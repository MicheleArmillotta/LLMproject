[
  {
    "function_name": "network_main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/network_main.c",
    "lines": "292-336",
    "snippet": "void network_main(pid_t child) {\n\t// create veth pair or macvlan device\n\tif (cfg.bridge0.configured) {\n\t\tif (cfg.bridge0.macvlan == 0) {\n\t\t\tnet_configure_veth_pair(&cfg.bridge0, \"eth0\", child);\n\t\t}\n\t\telse\n\t\t\tnet_create_macvlan(cfg.bridge0.devsandbox, cfg.bridge0.dev, child);\n\t}\n\t\n\tif (cfg.bridge1.configured) {\n\t\tif (cfg.bridge1.macvlan == 0)\n\t\t\tnet_configure_veth_pair(&cfg.bridge1, \"eth1\", child);\n\t\telse\n\t\t\tnet_create_macvlan(cfg.bridge1.devsandbox, cfg.bridge1.dev, child);\n\t}\n\t\n\tif (cfg.bridge2.configured) {\n\t\tif (cfg.bridge2.macvlan == 0)\n\t\t\tnet_configure_veth_pair(&cfg.bridge2, \"eth2\", child);\n\t\telse\n\t\t\tnet_create_macvlan(cfg.bridge2.devsandbox, cfg.bridge2.dev, child);\n\t}\n\t\n\tif (cfg.bridge3.configured) {\n\t\tif (cfg.bridge3.macvlan == 0)\n\t\t\tnet_configure_veth_pair(&cfg.bridge3, \"eth3\", child);\n\t\telse\n\t\t\tnet_create_macvlan(cfg.bridge3.devsandbox, cfg.bridge3.dev, child);\n\t}\n\n\t// move interfaces in sandbox\n\tif (cfg.interface0.configured) {\n\t\tnet_move_interface(cfg.interface0.dev, child);\n\t}\n\tif (cfg.interface1.configured) {\n\t\tnet_move_interface(cfg.interface1.dev, child);\n\t}\n\tif (cfg.interface2.configured) {\n\t\tnet_move_interface(cfg.interface2.dev, child);\n\t}\n\tif (cfg.interface3.configured) {\n\t\tnet_move_interface(cfg.interface3.dev, child);\n\t}\n}",
    "includes": [
      "#include <net/if.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "net_move_interface",
          "args": [
            "cfg.interface3.dev",
            "child"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "net_move_interface",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/veth.c",
          "lines": "185-219",
          "snippet": "int net_move_interface(const char *dev, unsigned pid) {\n\tstruct iplink_req req;\n\tif (arg_debug)\n\t\tprintf(\"move device %s inside the namespace\\n\", dev);\n\tassert(dev);\n\n\tif (rtnl_open(&rth, 0) < 0) {\n\t\tfprintf(stderr, \"cannot open netlink\\n\");\n\t\texit(1);\n\t}\n\n\tmemset(&req, 0, sizeof(req));\n\n\treq.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg));\n\treq.n.nlmsg_flags = NLM_F_REQUEST;\n\treq.n.nlmsg_type = RTM_NEWLINK;\n\treq.i.ifi_family = 0;\n\t\n\t// find ifindex\n\tint ifindex = if_nametoindex(dev);\n\tif (ifindex <= 0) {\n\t\tfprintf(stderr, \"Error: cannot find interface %s\\n\", dev);\n\t\texit(1);\n\t}\n\treq.i.ifi_index = ifindex;\n\t\t\t\t\n\t// place the interface in child namespace\n\taddattr_l (&req.n, sizeof(req), IFLA_NET_NS_PID, &pid, 4);\n\n\t// send message\n\tif (rtnl_talk(&rth, &req.n, 0, 0, NULL) < 0)\n\t\texit(2);\n\n\treturn 0;\n}",
          "includes": [
            "#include <net/if.h>",
            "#include <linux/veth.h>",
            "#include \"../include/libnetlink.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rtnl_handle rth = { .fd = -1 };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <net/if.h>\n#include <linux/veth.h>\n#include \"../include/libnetlink.h\"\n#include \"firejail.h\"\n\nstatic struct rtnl_handle rth = { .fd = -1 };\n\nint net_move_interface(const char *dev, unsigned pid) {\n\tstruct iplink_req req;\n\tif (arg_debug)\n\t\tprintf(\"move device %s inside the namespace\\n\", dev);\n\tassert(dev);\n\n\tif (rtnl_open(&rth, 0) < 0) {\n\t\tfprintf(stderr, \"cannot open netlink\\n\");\n\t\texit(1);\n\t}\n\n\tmemset(&req, 0, sizeof(req));\n\n\treq.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg));\n\treq.n.nlmsg_flags = NLM_F_REQUEST;\n\treq.n.nlmsg_type = RTM_NEWLINK;\n\treq.i.ifi_family = 0;\n\t\n\t// find ifindex\n\tint ifindex = if_nametoindex(dev);\n\tif (ifindex <= 0) {\n\t\tfprintf(stderr, \"Error: cannot find interface %s\\n\", dev);\n\t\texit(1);\n\t}\n\treq.i.ifi_index = ifindex;\n\t\t\t\t\n\t// place the interface in child namespace\n\taddattr_l (&req.n, sizeof(req), IFLA_NET_NS_PID, &pid, 4);\n\n\t// send message\n\tif (rtnl_talk(&rth, &req.n, 0, 0, NULL) < 0)\n\t\texit(2);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_create_macvlan",
          "args": [
            "cfg.bridge3.devsandbox",
            "cfg.bridge3.dev",
            "child"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "net_create_macvlan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/veth.c",
          "lines": "120-181",
          "snippet": "int net_create_macvlan(const char *dev, const char *parent, unsigned pid) {\n\tint len;\n\tstruct iplink_req req;\n\tif (arg_debug)\n\t\tprintf(\"create macvlan %s, parent %s\\n\", dev, parent);\n\tassert(dev);\n\tassert(parent);\n\n\tif (rtnl_open(&rth, 0) < 0) {\n\t\tfprintf(stderr, \"cannot open netlink\\n\");\n\t\texit(1);\n\t}\n\n\tmemset(&req, 0, sizeof(req));\n\n\treq.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg));\n\treq.n.nlmsg_flags = NLM_F_REQUEST|NLM_F_CREATE|NLM_F_EXCL;\n\treq.n.nlmsg_type = RTM_NEWLINK;\n\treq.i.ifi_family = 0;\n\t\n\t// find parent ifindex\n\tint parent_ifindex = if_nametoindex(parent);\n\tif (parent_ifindex <= 0) {\n\t\tfprintf(stderr, \"Error: cannot find network device %s\\n\", parent);\n\t\texit(1);\n\t}\t\t\t\n\n\t// add parent\n\taddattr_l(&req.n, sizeof(req), IFLA_LINK, &parent_ifindex, 4);\n\n\t// add new interface name\n\tlen = strlen(dev) + 1;\n\taddattr_l(&req.n, sizeof(req), IFLA_IFNAME, dev, len);\n\t\n\t// place the interface in child namespace\n\taddattr_l (&req.n, sizeof(req), IFLA_NET_NS_PID, &pid, 4);\n\n\n\t// add  link info for the new interface\n\tstruct rtattr *linkinfo = NLMSG_TAIL(&req.n);\n\taddattr_l(&req.n, sizeof(req), IFLA_LINKINFO, NULL, 0);\n\taddattr_l(&req.n, sizeof(req), IFLA_INFO_KIND, \"macvlan\", strlen(\"macvlan\"));\n\n\t// set macvlan bridge mode\n\tstruct rtattr * data = NLMSG_TAIL(&req.n);\n\taddattr_l(&req.n, sizeof(req), IFLA_INFO_DATA, NULL, 0);\n\tint macvlan_type = MACVLAN_MODE_BRIDGE;\n\taddattr_l (&req.n, sizeof(req), IFLA_INFO_KIND, &macvlan_type, 4);\n\n\tdata->rta_len = (void *)NLMSG_TAIL(&req.n) - (void *)data;\n//\treq.n.nlmsg_len += sizeof(struct ifinfomsg);\n\n\n\tdata->rta_len = (void *)NLMSG_TAIL(&req.n) - (void *)data;\n\tlinkinfo->rta_len = (void *)NLMSG_TAIL(&req.n) - (void *)linkinfo;\n\n\t// send message\n\tif (rtnl_talk(&rth, &req.n, 0, 0, NULL) < 0)\n\t\texit(2);\n\n\treturn 0;\n}",
          "includes": [
            "#include <net/if.h>",
            "#include <linux/veth.h>",
            "#include \"../include/libnetlink.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rtnl_handle rth = { .fd = -1 };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <net/if.h>\n#include <linux/veth.h>\n#include \"../include/libnetlink.h\"\n#include \"firejail.h\"\n\nstatic struct rtnl_handle rth = { .fd = -1 };\n\nint net_create_macvlan(const char *dev, const char *parent, unsigned pid) {\n\tint len;\n\tstruct iplink_req req;\n\tif (arg_debug)\n\t\tprintf(\"create macvlan %s, parent %s\\n\", dev, parent);\n\tassert(dev);\n\tassert(parent);\n\n\tif (rtnl_open(&rth, 0) < 0) {\n\t\tfprintf(stderr, \"cannot open netlink\\n\");\n\t\texit(1);\n\t}\n\n\tmemset(&req, 0, sizeof(req));\n\n\treq.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg));\n\treq.n.nlmsg_flags = NLM_F_REQUEST|NLM_F_CREATE|NLM_F_EXCL;\n\treq.n.nlmsg_type = RTM_NEWLINK;\n\treq.i.ifi_family = 0;\n\t\n\t// find parent ifindex\n\tint parent_ifindex = if_nametoindex(parent);\n\tif (parent_ifindex <= 0) {\n\t\tfprintf(stderr, \"Error: cannot find network device %s\\n\", parent);\n\t\texit(1);\n\t}\t\t\t\n\n\t// add parent\n\taddattr_l(&req.n, sizeof(req), IFLA_LINK, &parent_ifindex, 4);\n\n\t// add new interface name\n\tlen = strlen(dev) + 1;\n\taddattr_l(&req.n, sizeof(req), IFLA_IFNAME, dev, len);\n\t\n\t// place the interface in child namespace\n\taddattr_l (&req.n, sizeof(req), IFLA_NET_NS_PID, &pid, 4);\n\n\n\t// add  link info for the new interface\n\tstruct rtattr *linkinfo = NLMSG_TAIL(&req.n);\n\taddattr_l(&req.n, sizeof(req), IFLA_LINKINFO, NULL, 0);\n\taddattr_l(&req.n, sizeof(req), IFLA_INFO_KIND, \"macvlan\", strlen(\"macvlan\"));\n\n\t// set macvlan bridge mode\n\tstruct rtattr * data = NLMSG_TAIL(&req.n);\n\taddattr_l(&req.n, sizeof(req), IFLA_INFO_DATA, NULL, 0);\n\tint macvlan_type = MACVLAN_MODE_BRIDGE;\n\taddattr_l (&req.n, sizeof(req), IFLA_INFO_KIND, &macvlan_type, 4);\n\n\tdata->rta_len = (void *)NLMSG_TAIL(&req.n) - (void *)data;\n//\treq.n.nlmsg_len += sizeof(struct ifinfomsg);\n\n\n\tdata->rta_len = (void *)NLMSG_TAIL(&req.n) - (void *)data;\n\tlinkinfo->rta_len = (void *)NLMSG_TAIL(&req.n) - (void *)linkinfo;\n\n\t// send message\n\tif (rtnl_talk(&rth, &req.n, 0, 0, NULL) < 0)\n\t\texit(2);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_configure_veth_pair",
          "args": [
            "&cfg.bridge3",
            "\"eth3\"",
            "child"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "net_configure_veth_pair",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/network_main.c",
          "lines": "116-144",
          "snippet": "void net_configure_veth_pair(Bridge *br, const char *ifname, pid_t child) {\n\tassert(br);\n\tif (br->configured == 0)\n\t\treturn;\n\n\t// create a veth pair\n\tchar *dev;\n\tif (br->veth_name == NULL) {\n\t\tif (asprintf(&dev, \"veth%u%s\", getpid(), ifname) < 0)\n\t\t\terrExit(\"asprintf\");\n\t}\n\telse\n\t\tdev = br->veth_name;\n\t\t\n\tnet_create_veth(dev, ifname, child);\n\n\t// add interface to the bridge\n\tnet_bridge_add_interface(br->dev, dev);\n\n\t// bring up the interface\n\tnet_if_up(dev);\n\n\tchar *msg;\n\tif (asprintf(&msg, \"%d.%d.%d.%d address assigned to sandbox\", PRINT_IP(br->ipsandbox)) == -1)\n\t\terrExit(\"asprintf\");\n\tlogmsg(msg);\n\tfflush(0);\n\tfree(msg);\n}",
          "includes": [
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/if.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid net_configure_veth_pair(Bridge *br, const char *ifname, pid_t child) {\n\tassert(br);\n\tif (br->configured == 0)\n\t\treturn;\n\n\t// create a veth pair\n\tchar *dev;\n\tif (br->veth_name == NULL) {\n\t\tif (asprintf(&dev, \"veth%u%s\", getpid(), ifname) < 0)\n\t\t\terrExit(\"asprintf\");\n\t}\n\telse\n\t\tdev = br->veth_name;\n\t\t\n\tnet_create_veth(dev, ifname, child);\n\n\t// add interface to the bridge\n\tnet_bridge_add_interface(br->dev, dev);\n\n\t// bring up the interface\n\tnet_if_up(dev);\n\n\tchar *msg;\n\tif (asprintf(&msg, \"%d.%d.%d.%d address assigned to sandbox\", PRINT_IP(br->ipsandbox)) == -1)\n\t\terrExit(\"asprintf\");\n\tlogmsg(msg);\n\tfflush(0);\n\tfree(msg);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <net/if.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid network_main(pid_t child) {\n\t// create veth pair or macvlan device\n\tif (cfg.bridge0.configured) {\n\t\tif (cfg.bridge0.macvlan == 0) {\n\t\t\tnet_configure_veth_pair(&cfg.bridge0, \"eth0\", child);\n\t\t}\n\t\telse\n\t\t\tnet_create_macvlan(cfg.bridge0.devsandbox, cfg.bridge0.dev, child);\n\t}\n\t\n\tif (cfg.bridge1.configured) {\n\t\tif (cfg.bridge1.macvlan == 0)\n\t\t\tnet_configure_veth_pair(&cfg.bridge1, \"eth1\", child);\n\t\telse\n\t\t\tnet_create_macvlan(cfg.bridge1.devsandbox, cfg.bridge1.dev, child);\n\t}\n\t\n\tif (cfg.bridge2.configured) {\n\t\tif (cfg.bridge2.macvlan == 0)\n\t\t\tnet_configure_veth_pair(&cfg.bridge2, \"eth2\", child);\n\t\telse\n\t\t\tnet_create_macvlan(cfg.bridge2.devsandbox, cfg.bridge2.dev, child);\n\t}\n\t\n\tif (cfg.bridge3.configured) {\n\t\tif (cfg.bridge3.macvlan == 0)\n\t\t\tnet_configure_veth_pair(&cfg.bridge3, \"eth3\", child);\n\t\telse\n\t\t\tnet_create_macvlan(cfg.bridge3.devsandbox, cfg.bridge3.dev, child);\n\t}\n\n\t// move interfaces in sandbox\n\tif (cfg.interface0.configured) {\n\t\tnet_move_interface(cfg.interface0.dev, child);\n\t}\n\tif (cfg.interface1.configured) {\n\t\tnet_move_interface(cfg.interface1.dev, child);\n\t}\n\tif (cfg.interface2.configured) {\n\t\tnet_move_interface(cfg.interface2.dev, child);\n\t}\n\tif (cfg.interface3.configured) {\n\t\tnet_move_interface(cfg.interface3.dev, child);\n\t}\n}"
  },
  {
    "function_name": "net_dns_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/network_main.c",
    "lines": "253-290",
    "snippet": "void net_dns_print(pid_t pid) {\n\tEUID_ASSERT();\n\t// drop privileges - will not be able to read /etc/resolv.conf for --noroot option\n\n\t// if the pid is that of a firejail  process, use the pid of the first child process\n\tEUID_ROOT();\n\tchar *comm = pid_proc_comm(pid);\n\tEUID_USER();\n\tif (comm) {\n\t\tif (strcmp(comm, \"firejail\") == 0) {\n\t\t\tpid_t child;\n\t\t\tif (find_child(pid, &child) == 0) {\n\t\t\t\tpid = child;\n\t\t\t}\n\t\t}\n\t\tfree(comm);\n\t}\n\t\n\tchar *fname;\n\tEUID_ROOT();\n\tif (asprintf(&fname, \"/proc/%d/root/etc/resolv.conf\", pid) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// access /etc/resolv.conf\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: cannot access /etc/resolv.conf\\n\");\n\t\texit(1);\n\t}\n\t\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp))\n\t\tprintf(\"%s\", buf);\n\tprintf(\"\\n\");\n\tfclose(fp);\n\tfree(fname);\n\texit(0);\n}",
    "includes": [
      "#include <net/if.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [
      "#define MAXBUF 4096"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "myexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/main.c",
          "lines": "137-149",
          "snippet": "static void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}",
          "includes": [
            "#include <sys/times.h>",
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int arg_command = 0;",
            "int arg_quiet = 0;",
            "pid_t sandbox_pid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/times.h>\n#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nint arg_command = 0;\nint arg_quiet = 0;\npid_t sandbox_pid;\n\nstatic void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s\"",
            "buf"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buf",
            "MAXBUF",
            "fp"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot access /etc/resolv.conf\\n\""
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "fname",
            "\"r\""
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&fname",
            "\"/proc/%d/root/etc/resolv.conf\"",
            "pid"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ROOT",
          "args": [],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "comm"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_child",
          "args": [
            "pid",
            "&child"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "find_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/util.c",
          "lines": "395-454",
          "snippet": "int find_child(pid_t parent, pid_t *child) {\n\tEUID_ASSERT();\n\t*child = 0;\t\t\t\t  // use it to flag a found child\n\n\tDIR *dir;\n\tEUID_ROOT();\t\t\t\t  // grsecurity fix\n\tif (!(dir = opendir(\"/proc\"))) {\n\t\t// sleep 2 seconds and try again\n\t\tsleep(2);\n\t\tif (!(dir = opendir(\"/proc\"))) {\n\t\t\tfprintf(stderr, \"Error: cannot open /proc directory\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tstruct dirent *entry;\n\tchar *end;\n\twhile (*child == 0 && (entry = readdir(dir))) {\n\t\tpid_t pid = strtol(entry->d_name, &end, 10);\n\t\tif (end == entry->d_name || *end)\n\t\t\tcontinue;\n\t\tif (pid == parent)\n\t\t\tcontinue;\n\n\t\t// open stat file\n\t\tchar *file;\n\t\tif (asprintf(&file, \"/proc/%u/status\", pid) == -1) {\n\t\t\tperror(\"asprintf\");\n\t\t\texit(1);\n\t\t}\n\t\tFILE *fp = fopen(file, \"r\");\n\t\tif (!fp) {\n\t\t\tfree(file);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// look for firejail executable name\n\t\tchar buf[BUFLEN];\n\t\twhile (fgets(buf, BUFLEN - 1, fp)) {\n\t\t\tif (strncmp(buf, \"PPid:\", 5) == 0) {\n\t\t\t\tchar *ptr = buf + 5;\n\t\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\tif (*ptr == '\\0') {\n\t\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tif (parent == atoi(ptr))\n\t\t\t\t\t*child = pid;\n\t\t\t\tbreak;\t\t  // stop reading the file\n\t\t\t}\n\t\t}\n\t\tfclose(fp);\n\t\tfree(file);\n\t}\n\tclosedir(dir);\n\tEUID_USER();\n\treturn (*child)? 0:1;\t\t\t  // 0 = found, 1 = not found\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define BUFLEN 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\n#define BUFLEN 4096\n\nint find_child(pid_t parent, pid_t *child) {\n\tEUID_ASSERT();\n\t*child = 0;\t\t\t\t  // use it to flag a found child\n\n\tDIR *dir;\n\tEUID_ROOT();\t\t\t\t  // grsecurity fix\n\tif (!(dir = opendir(\"/proc\"))) {\n\t\t// sleep 2 seconds and try again\n\t\tsleep(2);\n\t\tif (!(dir = opendir(\"/proc\"))) {\n\t\t\tfprintf(stderr, \"Error: cannot open /proc directory\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tstruct dirent *entry;\n\tchar *end;\n\twhile (*child == 0 && (entry = readdir(dir))) {\n\t\tpid_t pid = strtol(entry->d_name, &end, 10);\n\t\tif (end == entry->d_name || *end)\n\t\t\tcontinue;\n\t\tif (pid == parent)\n\t\t\tcontinue;\n\n\t\t// open stat file\n\t\tchar *file;\n\t\tif (asprintf(&file, \"/proc/%u/status\", pid) == -1) {\n\t\t\tperror(\"asprintf\");\n\t\t\texit(1);\n\t\t}\n\t\tFILE *fp = fopen(file, \"r\");\n\t\tif (!fp) {\n\t\t\tfree(file);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// look for firejail executable name\n\t\tchar buf[BUFLEN];\n\t\twhile (fgets(buf, BUFLEN - 1, fp)) {\n\t\t\tif (strncmp(buf, \"PPid:\", 5) == 0) {\n\t\t\t\tchar *ptr = buf + 5;\n\t\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\tif (*ptr == '\\0') {\n\t\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tif (parent == atoi(ptr))\n\t\t\t\t\t*child = pid;\n\t\t\t\tbreak;\t\t  // stop reading the file\n\t\t\t}\n\t\t}\n\t\tfclose(fp);\n\t\tfree(file);\n\t}\n\tclosedir(dir);\n\tEUID_USER();\n\treturn (*child)? 0:1;\t\t\t  // 0 = found, 1 = not found\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "comm",
            "\"firejail\""
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_USER",
          "args": [],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pid_proc_comm",
          "args": [
            "pid"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ROOT",
          "args": [],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/if.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\n#define MAXBUF 4096\n\nvoid net_dns_print(pid_t pid) {\n\tEUID_ASSERT();\n\t// drop privileges - will not be able to read /etc/resolv.conf for --noroot option\n\n\t// if the pid is that of a firejail  process, use the pid of the first child process\n\tEUID_ROOT();\n\tchar *comm = pid_proc_comm(pid);\n\tEUID_USER();\n\tif (comm) {\n\t\tif (strcmp(comm, \"firejail\") == 0) {\n\t\t\tpid_t child;\n\t\t\tif (find_child(pid, &child) == 0) {\n\t\t\t\tpid = child;\n\t\t\t}\n\t\t}\n\t\tfree(comm);\n\t}\n\t\n\tchar *fname;\n\tEUID_ROOT();\n\tif (asprintf(&fname, \"/proc/%d/root/etc/resolv.conf\", pid) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// access /etc/resolv.conf\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: cannot access /etc/resolv.conf\\n\");\n\t\texit(1);\n\t}\n\t\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp))\n\t\tprintf(\"%s\", buf);\n\tprintf(\"\\n\");\n\tfclose(fp);\n\tfree(fname);\n\texit(0);\n}"
  },
  {
    "function_name": "net_dns_print_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/network_main.c",
    "lines": "237-250",
    "snippet": "void net_dns_print_name(const char *name) {\n\tEUID_ASSERT();\n\tif (!name || strlen(name) == 0) {\n\t\tfprintf(stderr, \"Error: invalid sandbox name\\n\");\n\t\texit(1);\n\t}\n\tpid_t pid;\n\tif (name2pid(name, &pid)) {\n\t\tfprintf(stderr, \"Error: cannot find sandbox %s\\n\", name);\n\t\texit(1);\n\t}\n\n\tnet_dns_print(pid);\n}",
    "includes": [
      "#include <net/if.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "net_dns_print",
          "args": [
            "pid"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "net_dns_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/network_main.c",
          "lines": "253-290",
          "snippet": "void net_dns_print(pid_t pid) {\n\tEUID_ASSERT();\n\t// drop privileges - will not be able to read /etc/resolv.conf for --noroot option\n\n\t// if the pid is that of a firejail  process, use the pid of the first child process\n\tEUID_ROOT();\n\tchar *comm = pid_proc_comm(pid);\n\tEUID_USER();\n\tif (comm) {\n\t\tif (strcmp(comm, \"firejail\") == 0) {\n\t\t\tpid_t child;\n\t\t\tif (find_child(pid, &child) == 0) {\n\t\t\t\tpid = child;\n\t\t\t}\n\t\t}\n\t\tfree(comm);\n\t}\n\t\n\tchar *fname;\n\tEUID_ROOT();\n\tif (asprintf(&fname, \"/proc/%d/root/etc/resolv.conf\", pid) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// access /etc/resolv.conf\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: cannot access /etc/resolv.conf\\n\");\n\t\texit(1);\n\t}\n\t\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp))\n\t\tprintf(\"%s\", buf);\n\tprintf(\"\\n\");\n\tfclose(fp);\n\tfree(fname);\n\texit(0);\n}",
          "includes": [
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAXBUF 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/if.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\n#define MAXBUF 4096\n\nvoid net_dns_print(pid_t pid) {\n\tEUID_ASSERT();\n\t// drop privileges - will not be able to read /etc/resolv.conf for --noroot option\n\n\t// if the pid is that of a firejail  process, use the pid of the first child process\n\tEUID_ROOT();\n\tchar *comm = pid_proc_comm(pid);\n\tEUID_USER();\n\tif (comm) {\n\t\tif (strcmp(comm, \"firejail\") == 0) {\n\t\t\tpid_t child;\n\t\t\tif (find_child(pid, &child) == 0) {\n\t\t\t\tpid = child;\n\t\t\t}\n\t\t}\n\t\tfree(comm);\n\t}\n\t\n\tchar *fname;\n\tEUID_ROOT();\n\tif (asprintf(&fname, \"/proc/%d/root/etc/resolv.conf\", pid) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// access /etc/resolv.conf\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: cannot access /etc/resolv.conf\\n\");\n\t\texit(1);\n\t}\n\t\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp))\n\t\tprintf(\"%s\", buf);\n\tprintf(\"\\n\");\n\tfclose(fp);\n\tfree(fname);\n\texit(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "myexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/main.c",
          "lines": "137-149",
          "snippet": "static void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}",
          "includes": [
            "#include <sys/times.h>",
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int arg_command = 0;",
            "int arg_quiet = 0;",
            "pid_t sandbox_pid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/times.h>\n#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nint arg_command = 0;\nint arg_quiet = 0;\npid_t sandbox_pid;\n\nstatic void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot find sandbox %s\\n\"",
            "name"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name2pid",
          "args": [
            "name",
            "&pid"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid sandbox name\\n\""
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/if.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid net_dns_print_name(const char *name) {\n\tEUID_ASSERT();\n\tif (!name || strlen(name) == 0) {\n\t\tfprintf(stderr, \"Error: invalid sandbox name\\n\");\n\t\texit(1);\n\t}\n\tpid_t pid;\n\tif (name2pid(name, &pid)) {\n\t\tfprintf(stderr, \"Error: cannot find sandbox %s\\n\", name);\n\t\texit(1);\n\t}\n\n\tnet_dns_print(pid);\n}"
  },
  {
    "function_name": "net_check_cfg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/network_main.c",
    "lines": "175-233",
    "snippet": "void net_check_cfg(void) {\n\tEUID_ASSERT();\n\tint net_configured = 0;\n\tif (cfg.bridge0.configured)\n\t\tnet_configured++;\n\tif (cfg.bridge1.configured)\n\t\tnet_configured++;\n\tif (cfg.bridge2.configured)\n\t\tnet_configured++;\n\tif (cfg.bridge3.configured)\n\t\tnet_configured++;\n\n\tint if_configured = 0;\n\tif (cfg.interface0.configured)\n\t\tif_configured++;\n\tif (cfg.interface1.configured)\n\t\tif_configured++;\n\tif (cfg.interface2.configured)\n\t\tif_configured++;\n\tif (cfg.interface3.configured)\n\t\tif_configured++;\n\n\t// --defaultgw requires a network or an interface\n\tif (cfg.defaultgw && net_configured == 0 && if_configured == 0) {\n\t\tfprintf(stderr, \"Error: option --defaultgw requires at least one network or one interface to be configured\\n\");\n\t\texit(1);\n\t}\n\n\tif (net_configured == 0) // nothing to check\n\t\treturn;\n\n\t// --net=none\n\tif (arg_nonetwork && net_configured) {\n\t\tfprintf(stderr, \"Error: --net and --net=none are mutually exclusive\\n\");\n\t\texit(1);\n\t}\n\n\t// check default gateway address or assign one\n\tassert(cfg.bridge0.configured);\n\tif (cfg.defaultgw)\n\t\tcheck_default_gw(cfg.defaultgw);\n\telse {\n\t\t// first network is a regular bridge\n\t\tif (cfg.bridge0.macvlan == 0)\n\t\t\tcfg.defaultgw = cfg.bridge0.ip;\n\t\t// first network is a mac device\n\t\telse {\n\t\t\t// get the host default gw\n\t\t\tEUID_ROOT();\t// rise permissions for grsecurity\n\t\t\t// Error fopen:network_get_defaultgw(479): Permission denied\n\t\t\tuint32_t gw = network_get_defaultgw();\n\t\t\tEUID_USER();\n\t\t\t// check the gateway is network range\n\t\t\tif (in_netrange(gw, cfg.bridge0.ip, cfg.bridge0.mask))\n\t\t\t\tgw = 0;\n\t\t\tcfg.defaultgw = gw;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <net/if.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "in_netrange",
          "args": [
            "gw",
            "cfg.bridge0.ip",
            "cfg.bridge0.mask"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_USER",
          "args": [],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "network_get_defaultgw",
          "args": [],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "network_get_defaultgw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/network.c",
          "lines": "482-510",
          "snippet": "uint32_t network_get_defaultgw(void) {\n\tFILE *fp = fopen(\"/proc/self/net/route\", \"r\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\t\n\tchar buf[BUFSIZE];\n\tuint32_t retval = 0;\n\twhile (fgets(buf, BUFSIZE, fp)) {\n\t\tif (strncmp(buf, \"Iface\", 5) == 0)\n\t\t\tcontinue;\n\t\t\n\t\tchar *ptr = buf;\n\t\twhile (*ptr != ' ' && *ptr != '\\t')\n\t\t\tptr++;\n\t\twhile (*ptr == ' ' || *ptr == '\\t')\n\t\t\tptr++;\n\t\t\t\n\t\tunsigned dest;\n\t\tunsigned gw;\n\t\tint rv = sscanf(ptr, \"%x %x\", &dest, &gw);\n\t\tif (rv == 2 && dest == 0) {\n\t\t\tretval = ntohl(gw);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfclose(fp);\n\treturn retval;\n}",
          "includes": [
            "#include <linux/if_bridge.h>",
            "#include <net/route.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <ifaddrs.h>",
            "#include <netdb.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <arpa/inet.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define BUFSIZE 1024"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"firejail.h\"\n\n#define BUFSIZE 1024\n\nuint32_t network_get_defaultgw(void) {\n\tFILE *fp = fopen(\"/proc/self/net/route\", \"r\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\t\n\tchar buf[BUFSIZE];\n\tuint32_t retval = 0;\n\twhile (fgets(buf, BUFSIZE, fp)) {\n\t\tif (strncmp(buf, \"Iface\", 5) == 0)\n\t\t\tcontinue;\n\t\t\n\t\tchar *ptr = buf;\n\t\twhile (*ptr != ' ' && *ptr != '\\t')\n\t\t\tptr++;\n\t\twhile (*ptr == ' ' || *ptr == '\\t')\n\t\t\tptr++;\n\t\t\t\n\t\tunsigned dest;\n\t\tunsigned gw;\n\t\tint rv = sscanf(ptr, \"%x %x\", &dest, &gw);\n\t\tif (rv == 2 && dest == 0) {\n\t\t\tretval = ntohl(gw);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfclose(fp);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EUID_ROOT",
          "args": [],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_default_gw",
          "args": [
            "cfg.defaultgw"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "check_default_gw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/network_main.c",
          "lines": "147-173",
          "snippet": "void check_default_gw(uint32_t defaultgw) {\n\tassert(defaultgw);\n\n\tif (cfg.bridge0.configured) {\n\t\tchar *rv = in_netrange(defaultgw, cfg.bridge0.ip, cfg.bridge0.mask);\n\t\tif (rv == 0)\n\t\t\treturn;\n\t}\n\tif (cfg.bridge1.configured) {\n\t\tchar *rv = in_netrange(defaultgw, cfg.bridge1.ip, cfg.bridge1.mask);\n\t\tif (rv == 0)\n\t\t\treturn;\n\t}\n\tif (cfg.bridge2.configured) {\n\t\tchar *rv = in_netrange(defaultgw, cfg.bridge2.ip, cfg.bridge2.mask);\n\t\tif (rv == 0)\n\t\t\treturn;\n\t}\n\tif (cfg.bridge3.configured) {\n\t\tchar *rv = in_netrange(defaultgw, cfg.bridge3.ip, cfg.bridge3.mask);\n\t\tif (rv == 0)\n\t\t\treturn;\n\t}\n\n\tfprintf(stderr, \"Error: default gateway %d.%d.%d.%d is not in the range of any network\\n\", PRINT_IP(defaultgw));\n\texit(1);\n}",
          "includes": [
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/if.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid check_default_gw(uint32_t defaultgw) {\n\tassert(defaultgw);\n\n\tif (cfg.bridge0.configured) {\n\t\tchar *rv = in_netrange(defaultgw, cfg.bridge0.ip, cfg.bridge0.mask);\n\t\tif (rv == 0)\n\t\t\treturn;\n\t}\n\tif (cfg.bridge1.configured) {\n\t\tchar *rv = in_netrange(defaultgw, cfg.bridge1.ip, cfg.bridge1.mask);\n\t\tif (rv == 0)\n\t\t\treturn;\n\t}\n\tif (cfg.bridge2.configured) {\n\t\tchar *rv = in_netrange(defaultgw, cfg.bridge2.ip, cfg.bridge2.mask);\n\t\tif (rv == 0)\n\t\t\treturn;\n\t}\n\tif (cfg.bridge3.configured) {\n\t\tchar *rv = in_netrange(defaultgw, cfg.bridge3.ip, cfg.bridge3.mask);\n\t\tif (rv == 0)\n\t\t\treturn;\n\t}\n\n\tfprintf(stderr, \"Error: default gateway %d.%d.%d.%d is not in the range of any network\\n\", PRINT_IP(defaultgw));\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "cfg.bridge0.configured"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "myexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/main.c",
          "lines": "137-149",
          "snippet": "static void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}",
          "includes": [
            "#include <sys/times.h>",
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int arg_command = 0;",
            "int arg_quiet = 0;",
            "pid_t sandbox_pid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/times.h>\n#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nint arg_command = 0;\nint arg_quiet = 0;\npid_t sandbox_pid;\n\nstatic void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: --net and --net=none are mutually exclusive\\n\""
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: option --defaultgw requires at least one network or one interface to be configured\\n\""
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/if.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid net_check_cfg(void) {\n\tEUID_ASSERT();\n\tint net_configured = 0;\n\tif (cfg.bridge0.configured)\n\t\tnet_configured++;\n\tif (cfg.bridge1.configured)\n\t\tnet_configured++;\n\tif (cfg.bridge2.configured)\n\t\tnet_configured++;\n\tif (cfg.bridge3.configured)\n\t\tnet_configured++;\n\n\tint if_configured = 0;\n\tif (cfg.interface0.configured)\n\t\tif_configured++;\n\tif (cfg.interface1.configured)\n\t\tif_configured++;\n\tif (cfg.interface2.configured)\n\t\tif_configured++;\n\tif (cfg.interface3.configured)\n\t\tif_configured++;\n\n\t// --defaultgw requires a network or an interface\n\tif (cfg.defaultgw && net_configured == 0 && if_configured == 0) {\n\t\tfprintf(stderr, \"Error: option --defaultgw requires at least one network or one interface to be configured\\n\");\n\t\texit(1);\n\t}\n\n\tif (net_configured == 0) // nothing to check\n\t\treturn;\n\n\t// --net=none\n\tif (arg_nonetwork && net_configured) {\n\t\tfprintf(stderr, \"Error: --net and --net=none are mutually exclusive\\n\");\n\t\texit(1);\n\t}\n\n\t// check default gateway address or assign one\n\tassert(cfg.bridge0.configured);\n\tif (cfg.defaultgw)\n\t\tcheck_default_gw(cfg.defaultgw);\n\telse {\n\t\t// first network is a regular bridge\n\t\tif (cfg.bridge0.macvlan == 0)\n\t\t\tcfg.defaultgw = cfg.bridge0.ip;\n\t\t// first network is a mac device\n\t\telse {\n\t\t\t// get the host default gw\n\t\t\tEUID_ROOT();\t// rise permissions for grsecurity\n\t\t\t// Error fopen:network_get_defaultgw(479): Permission denied\n\t\t\tuint32_t gw = network_get_defaultgw();\n\t\t\tEUID_USER();\n\t\t\t// check the gateway is network range\n\t\t\tif (in_netrange(gw, cfg.bridge0.ip, cfg.bridge0.mask))\n\t\t\t\tgw = 0;\n\t\t\tcfg.defaultgw = gw;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "check_default_gw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/network_main.c",
    "lines": "147-173",
    "snippet": "void check_default_gw(uint32_t defaultgw) {\n\tassert(defaultgw);\n\n\tif (cfg.bridge0.configured) {\n\t\tchar *rv = in_netrange(defaultgw, cfg.bridge0.ip, cfg.bridge0.mask);\n\t\tif (rv == 0)\n\t\t\treturn;\n\t}\n\tif (cfg.bridge1.configured) {\n\t\tchar *rv = in_netrange(defaultgw, cfg.bridge1.ip, cfg.bridge1.mask);\n\t\tif (rv == 0)\n\t\t\treturn;\n\t}\n\tif (cfg.bridge2.configured) {\n\t\tchar *rv = in_netrange(defaultgw, cfg.bridge2.ip, cfg.bridge2.mask);\n\t\tif (rv == 0)\n\t\t\treturn;\n\t}\n\tif (cfg.bridge3.configured) {\n\t\tchar *rv = in_netrange(defaultgw, cfg.bridge3.ip, cfg.bridge3.mask);\n\t\tif (rv == 0)\n\t\t\treturn;\n\t}\n\n\tfprintf(stderr, \"Error: default gateway %d.%d.%d.%d is not in the range of any network\\n\", PRINT_IP(defaultgw));\n\texit(1);\n}",
    "includes": [
      "#include <net/if.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "myexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/main.c",
          "lines": "137-149",
          "snippet": "static void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}",
          "includes": [
            "#include <sys/times.h>",
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int arg_command = 0;",
            "int arg_quiet = 0;",
            "pid_t sandbox_pid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/times.h>\n#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nint arg_command = 0;\nint arg_quiet = 0;\npid_t sandbox_pid;\n\nstatic void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: default gateway %d.%d.%d.%d is not in the range of any network\\n\"",
            "PRINT_IP(defaultgw)"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_IP",
          "args": [
            "defaultgw"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_netrange",
          "args": [
            "defaultgw",
            "cfg.bridge3.ip",
            "cfg.bridge3.mask"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_netrange",
          "args": [
            "defaultgw",
            "cfg.bridge2.ip",
            "cfg.bridge2.mask"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_netrange",
          "args": [
            "defaultgw",
            "cfg.bridge1.ip",
            "cfg.bridge1.mask"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_netrange",
          "args": [
            "defaultgw",
            "cfg.bridge0.ip",
            "cfg.bridge0.mask"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "defaultgw"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/if.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid check_default_gw(uint32_t defaultgw) {\n\tassert(defaultgw);\n\n\tif (cfg.bridge0.configured) {\n\t\tchar *rv = in_netrange(defaultgw, cfg.bridge0.ip, cfg.bridge0.mask);\n\t\tif (rv == 0)\n\t\t\treturn;\n\t}\n\tif (cfg.bridge1.configured) {\n\t\tchar *rv = in_netrange(defaultgw, cfg.bridge1.ip, cfg.bridge1.mask);\n\t\tif (rv == 0)\n\t\t\treturn;\n\t}\n\tif (cfg.bridge2.configured) {\n\t\tchar *rv = in_netrange(defaultgw, cfg.bridge2.ip, cfg.bridge2.mask);\n\t\tif (rv == 0)\n\t\t\treturn;\n\t}\n\tif (cfg.bridge3.configured) {\n\t\tchar *rv = in_netrange(defaultgw, cfg.bridge3.ip, cfg.bridge3.mask);\n\t\tif (rv == 0)\n\t\t\treturn;\n\t}\n\n\tfprintf(stderr, \"Error: default gateway %d.%d.%d.%d is not in the range of any network\\n\", PRINT_IP(defaultgw));\n\texit(1);\n}"
  },
  {
    "function_name": "net_configure_veth_pair",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/network_main.c",
    "lines": "116-144",
    "snippet": "void net_configure_veth_pair(Bridge *br, const char *ifname, pid_t child) {\n\tassert(br);\n\tif (br->configured == 0)\n\t\treturn;\n\n\t// create a veth pair\n\tchar *dev;\n\tif (br->veth_name == NULL) {\n\t\tif (asprintf(&dev, \"veth%u%s\", getpid(), ifname) < 0)\n\t\t\terrExit(\"asprintf\");\n\t}\n\telse\n\t\tdev = br->veth_name;\n\t\t\n\tnet_create_veth(dev, ifname, child);\n\n\t// add interface to the bridge\n\tnet_bridge_add_interface(br->dev, dev);\n\n\t// bring up the interface\n\tnet_if_up(dev);\n\n\tchar *msg;\n\tif (asprintf(&msg, \"%d.%d.%d.%d address assigned to sandbox\", PRINT_IP(br->ipsandbox)) == -1)\n\t\terrExit(\"asprintf\");\n\tlogmsg(msg);\n\tfflush(0);\n\tfree(msg);\n}",
    "includes": [
      "#include <net/if.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "msg"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "0"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logmsg",
          "args": [
            "msg"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "logmsg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/util.c",
          "lines": "131-138",
          "snippet": "void logmsg(const char *msg) {\n\tif (!arg_debug)\n\t\treturn;\n\n\topenlog(\"firejail\", LOG_NDELAY | LOG_PID, LOG_USER);\n\tsyslog(LOG_INFO, \"%s\\n\", msg);\n\tcloselog();\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid logmsg(const char *msg) {\n\tif (!arg_debug)\n\t\treturn;\n\n\topenlog(\"firejail\", LOG_NDELAY | LOG_PID, LOG_USER);\n\tsyslog(LOG_INFO, \"%s\\n\", msg);\n\tcloselog();\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&msg",
            "\"%d.%d.%d.%d address assigned to sandbox\"",
            "PRINT_IP(br->ipsandbox)"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_IP",
          "args": [
            "br->ipsandbox"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_if_up",
          "args": [
            "dev"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "net_if_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/network.c",
          "lines": "188-245",
          "snippet": "void net_if_up(const char *ifname) {\n\tif (strlen(ifname) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error: invalid network device name %s\\n\", ifname);\n\t\texit(1);\n\t}\n\t\n\tint sock = socket(AF_INET,SOCK_DGRAM,0);\n\tif (sock < 0)\n\t\terrExit(\"socket\");\n\n\t// get the existing interface flags\n\tstruct ifreq ifr;\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ);\n\tifr.ifr_addr.sa_family = AF_INET;\n\n\t// read the existing flags\n\tif (ioctl(sock, SIOCGIFFLAGS, &ifr ) < 0) {\n\t\tclose(sock);\n\t\tprintf(\"Error: cannot bring up interface %s\\n\", ifname);\n\t\terrExit(\"ioctl\");\n\t}\n\n\tifr.ifr_flags |= IFF_UP;\n\n\t// set the new flags\n\tif (ioctl( sock, SIOCSIFFLAGS, &ifr ) < 0) {\n\t\tclose(sock);\n\t\tprintf(\"Error: cannot bring up interface %s\\n\", ifname);\n\t\terrExit(\"ioctl\");\n\t}\n\n\t// checking\n\t// read the existing flags\n\tif (ioctl(sock, SIOCGIFFLAGS, &ifr ) < 0) {\n\t\tclose(sock);\n\t\tprintf(\"Error: cannot bring up interface %s\\n\", ifname);\n\t\terrExit(\"ioctl\");\n\t}\n\n\t// wait not more than 500ms for the interface to come up\n\tint cnt = 0;\n\twhile (cnt < 50) {\n\t\tusleep(10000);\t\t\t  // sleep 10ms\n\n\t\t// read the existing flags\n\t\tif (ioctl(sock, SIOCGIFFLAGS, &ifr ) < 0) {\n\t\t\tclose(sock);\n\t\t\tprintf(\"Error: cannot bring up interface %s\\n\", ifname);\n\t\t\terrExit(\"ioctl\");\n\t\t}\n\t\tif (ifr.ifr_flags & IFF_RUNNING)\n\t\t\tbreak;\n\t\tcnt++;\n\t}\n\n\tclose(sock);\n}",
          "includes": [
            "#include <linux/if_bridge.h>",
            "#include <net/route.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <ifaddrs.h>",
            "#include <netdb.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <arpa/inet.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"firejail.h\"\n\nvoid net_if_up(const char *ifname) {\n\tif (strlen(ifname) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error: invalid network device name %s\\n\", ifname);\n\t\texit(1);\n\t}\n\t\n\tint sock = socket(AF_INET,SOCK_DGRAM,0);\n\tif (sock < 0)\n\t\terrExit(\"socket\");\n\n\t// get the existing interface flags\n\tstruct ifreq ifr;\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ);\n\tifr.ifr_addr.sa_family = AF_INET;\n\n\t// read the existing flags\n\tif (ioctl(sock, SIOCGIFFLAGS, &ifr ) < 0) {\n\t\tclose(sock);\n\t\tprintf(\"Error: cannot bring up interface %s\\n\", ifname);\n\t\terrExit(\"ioctl\");\n\t}\n\n\tifr.ifr_flags |= IFF_UP;\n\n\t// set the new flags\n\tif (ioctl( sock, SIOCSIFFLAGS, &ifr ) < 0) {\n\t\tclose(sock);\n\t\tprintf(\"Error: cannot bring up interface %s\\n\", ifname);\n\t\terrExit(\"ioctl\");\n\t}\n\n\t// checking\n\t// read the existing flags\n\tif (ioctl(sock, SIOCGIFFLAGS, &ifr ) < 0) {\n\t\tclose(sock);\n\t\tprintf(\"Error: cannot bring up interface %s\\n\", ifname);\n\t\terrExit(\"ioctl\");\n\t}\n\n\t// wait not more than 500ms for the interface to come up\n\tint cnt = 0;\n\twhile (cnt < 50) {\n\t\tusleep(10000);\t\t\t  // sleep 10ms\n\n\t\t// read the existing flags\n\t\tif (ioctl(sock, SIOCGIFFLAGS, &ifr ) < 0) {\n\t\t\tclose(sock);\n\t\t\tprintf(\"Error: cannot bring up interface %s\\n\", ifname);\n\t\t\terrExit(\"ioctl\");\n\t\t}\n\t\tif (ifr.ifr_flags & IFF_RUNNING)\n\t\t\tbreak;\n\t\tcnt++;\n\t}\n\n\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_bridge_add_interface",
          "args": [
            "br->dev",
            "dev"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "net_bridge_add_interface",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/network.c",
          "lines": "435-479",
          "snippet": "void net_bridge_add_interface(const char *bridge, const char *dev) {\n\tif (strlen(bridge) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error: invalid network device name %s\\n\", bridge);\n\t\texit(1);\n\t}\n\n\t// somehow adding the interface to the bridge resets MTU on bridge device!!!\n\t// workaround: restore MTU on the bridge device\n\t// todo: put a real fix in\n\tint mtu1 = net_get_mtu(bridge);\n\n\tstruct ifreq ifr;\n\tint err;\n\tint ifindex = if_nametoindex(dev);\n\n\tif (ifindex <= 0)\n\t\terrExit(\"if_nametoindex\");\n\n\tint sock;\n\tif ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0)\n              \terrExit(\"socket\");\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, bridge, IFNAMSIZ);\n#ifdef SIOCBRADDIF\n\tifr.ifr_ifindex = ifindex;\n\terr = ioctl(sock, SIOCBRADDIF, &ifr);\n\tif (err < 0)\n#endif\n\t{\n\t\tunsigned long args[4] = { BRCTL_ADD_IF, ifindex, 0, 0 };\n\n\t\tifr.ifr_data = (char *) args;\n\t\terr = ioctl(sock, SIOCDEVPRIVATE, &ifr);\n\t}\n\t(void) err;\n\tclose(sock);\n\n\tint mtu2 = net_get_mtu(bridge);\n\tif (mtu1 != mtu2) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Restoring MTU for %s\\n\", bridge);\n\t\tnet_set_mtu(bridge, mtu1);\n\t}\n}",
          "includes": [
            "#include <linux/if_bridge.h>",
            "#include <net/route.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <ifaddrs.h>",
            "#include <netdb.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <arpa/inet.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"firejail.h\"\n\nvoid net_bridge_add_interface(const char *bridge, const char *dev) {\n\tif (strlen(bridge) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error: invalid network device name %s\\n\", bridge);\n\t\texit(1);\n\t}\n\n\t// somehow adding the interface to the bridge resets MTU on bridge device!!!\n\t// workaround: restore MTU on the bridge device\n\t// todo: put a real fix in\n\tint mtu1 = net_get_mtu(bridge);\n\n\tstruct ifreq ifr;\n\tint err;\n\tint ifindex = if_nametoindex(dev);\n\n\tif (ifindex <= 0)\n\t\terrExit(\"if_nametoindex\");\n\n\tint sock;\n\tif ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0)\n              \terrExit(\"socket\");\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, bridge, IFNAMSIZ);\n#ifdef SIOCBRADDIF\n\tifr.ifr_ifindex = ifindex;\n\terr = ioctl(sock, SIOCBRADDIF, &ifr);\n\tif (err < 0)\n#endif\n\t{\n\t\tunsigned long args[4] = { BRCTL_ADD_IF, ifindex, 0, 0 };\n\n\t\tifr.ifr_data = (char *) args;\n\t\terr = ioctl(sock, SIOCDEVPRIVATE, &ifr);\n\t}\n\t(void) err;\n\tclose(sock);\n\n\tint mtu2 = net_get_mtu(bridge);\n\tif (mtu1 != mtu2) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Restoring MTU for %s\\n\", bridge);\n\t\tnet_set_mtu(bridge, mtu1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_create_veth",
          "args": [
            "dev",
            "ifname",
            "child"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "net_create_veth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/veth.c",
          "lines": "62-117",
          "snippet": "int net_create_veth(const char *dev, const char *nsdev, unsigned pid) {\n\tint len;\n\tstruct iplink_req req;\n\n\tif (arg_debug)\n\t\tprintf(\"create veth %s/%s/%u\\n\", dev, nsdev, pid);\n\tassert(dev);\n\tassert(nsdev);\n\tassert(pid);\n\n\tif (rtnl_open(&rth, 0) < 0) {\n\t\tfprintf(stderr, \"cannot open netlink\\n\");\n\t\texit(1);\n\t}\n\n\tmemset(&req, 0, sizeof(req));\n\n\treq.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg));\n\treq.n.nlmsg_flags = NLM_F_REQUEST|NLM_F_CREATE|NLM_F_EXCL;\n\treq.n.nlmsg_type = RTM_NEWLINK;\n\treq.i.ifi_family = 0;\n\n\tif (dev) {\n\t\tlen = strlen(dev) + 1;\n\t\taddattr_l(&req.n, sizeof(req), IFLA_IFNAME, dev, len);\n\t}\n\n\tstruct rtattr *linkinfo = NLMSG_TAIL(&req.n);\n\taddattr_l(&req.n, sizeof(req), IFLA_LINKINFO, NULL, 0);\n\taddattr_l(&req.n, sizeof(req), IFLA_INFO_KIND, \"veth\", strlen(\"veth\"));\n\n\tstruct rtattr * data = NLMSG_TAIL(&req.n);\n\taddattr_l(&req.n, sizeof(req), IFLA_INFO_DATA, NULL, 0);\n\n\tstruct rtattr * peerdata = NLMSG_TAIL(&req.n);\n\taddattr_l (&req.n, sizeof(req), VETH_INFO_PEER, NULL, 0);\n\treq.n.nlmsg_len += sizeof(struct ifinfomsg);\n\n\t// place the link in the child namespace\n\taddattr_l (&req.n, sizeof(req), IFLA_NET_NS_PID, &pid, 4);\n\n\tif (nsdev) {\n\t\tint len = strlen(nsdev) + 1;\n\t\taddattr_l(&req.n, sizeof(req), IFLA_IFNAME, nsdev, len);\n\t}\n\tpeerdata->rta_len = (void *)NLMSG_TAIL(&req.n) - (void *)peerdata;\n\n\tdata->rta_len = (void *)NLMSG_TAIL(&req.n) - (void *)data;\n\tlinkinfo->rta_len = (void *)NLMSG_TAIL(&req.n) - (void *)linkinfo;\n\n\t// send message\n\tif (rtnl_talk(&rth, &req.n, 0, 0, NULL) < 0)\n\t\texit(2);\n\n\treturn 0;\n}",
          "includes": [
            "#include <net/if.h>",
            "#include <linux/veth.h>",
            "#include \"../include/libnetlink.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rtnl_handle rth = { .fd = -1 };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <net/if.h>\n#include <linux/veth.h>\n#include \"../include/libnetlink.h\"\n#include \"firejail.h\"\n\nstatic struct rtnl_handle rth = { .fd = -1 };\n\nint net_create_veth(const char *dev, const char *nsdev, unsigned pid) {\n\tint len;\n\tstruct iplink_req req;\n\n\tif (arg_debug)\n\t\tprintf(\"create veth %s/%s/%u\\n\", dev, nsdev, pid);\n\tassert(dev);\n\tassert(nsdev);\n\tassert(pid);\n\n\tif (rtnl_open(&rth, 0) < 0) {\n\t\tfprintf(stderr, \"cannot open netlink\\n\");\n\t\texit(1);\n\t}\n\n\tmemset(&req, 0, sizeof(req));\n\n\treq.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg));\n\treq.n.nlmsg_flags = NLM_F_REQUEST|NLM_F_CREATE|NLM_F_EXCL;\n\treq.n.nlmsg_type = RTM_NEWLINK;\n\treq.i.ifi_family = 0;\n\n\tif (dev) {\n\t\tlen = strlen(dev) + 1;\n\t\taddattr_l(&req.n, sizeof(req), IFLA_IFNAME, dev, len);\n\t}\n\n\tstruct rtattr *linkinfo = NLMSG_TAIL(&req.n);\n\taddattr_l(&req.n, sizeof(req), IFLA_LINKINFO, NULL, 0);\n\taddattr_l(&req.n, sizeof(req), IFLA_INFO_KIND, \"veth\", strlen(\"veth\"));\n\n\tstruct rtattr * data = NLMSG_TAIL(&req.n);\n\taddattr_l(&req.n, sizeof(req), IFLA_INFO_DATA, NULL, 0);\n\n\tstruct rtattr * peerdata = NLMSG_TAIL(&req.n);\n\taddattr_l (&req.n, sizeof(req), VETH_INFO_PEER, NULL, 0);\n\treq.n.nlmsg_len += sizeof(struct ifinfomsg);\n\n\t// place the link in the child namespace\n\taddattr_l (&req.n, sizeof(req), IFLA_NET_NS_PID, &pid, 4);\n\n\tif (nsdev) {\n\t\tint len = strlen(nsdev) + 1;\n\t\taddattr_l(&req.n, sizeof(req), IFLA_IFNAME, nsdev, len);\n\t}\n\tpeerdata->rta_len = (void *)NLMSG_TAIL(&req.n) - (void *)peerdata;\n\n\tdata->rta_len = (void *)NLMSG_TAIL(&req.n) - (void *)data;\n\tlinkinfo->rta_len = (void *)NLMSG_TAIL(&req.n) - (void *)linkinfo;\n\n\t// send message\n\tif (rtnl_talk(&rth, &req.n, 0, 0, NULL) < 0)\n\t\texit(2);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&dev",
            "\"veth%u%s\"",
            "getpid()",
            "ifname"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "br"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/if.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid net_configure_veth_pair(Bridge *br, const char *ifname, pid_t child) {\n\tassert(br);\n\tif (br->configured == 0)\n\t\treturn;\n\n\t// create a veth pair\n\tchar *dev;\n\tif (br->veth_name == NULL) {\n\t\tif (asprintf(&dev, \"veth%u%s\", getpid(), ifname) < 0)\n\t\t\terrExit(\"asprintf\");\n\t}\n\telse\n\t\tdev = br->veth_name;\n\t\t\n\tnet_create_veth(dev, ifname, child);\n\n\t// add interface to the bridge\n\tnet_bridge_add_interface(br->dev, dev);\n\n\t// bring up the interface\n\tnet_if_up(dev);\n\n\tchar *msg;\n\tif (asprintf(&msg, \"%d.%d.%d.%d address assigned to sandbox\", PRINT_IP(br->ipsandbox)) == -1)\n\t\terrExit(\"asprintf\");\n\tlogmsg(msg);\n\tfflush(0);\n\tfree(msg);\n}"
  },
  {
    "function_name": "net_configure_sandbox_ip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/network_main.c",
    "lines": "85-108",
    "snippet": "void net_configure_sandbox_ip(Bridge *br) {\n\tassert(br);\n\tif (br->configured == 0)\n\t\treturn;\n\n\tif (br->arg_ip_none)\n\t\tbr->ipsandbox = 0;\n\telse if (br->ipsandbox) {\n\t\t// check network range\n\t\tchar *rv = in_netrange(br->ipsandbox, br->ip, br->mask);\n\t\tif (rv) {\n\t\t\tfprintf(stderr, \"%s\", rv);\n\t\t\texit(1);\n\t\t}\n\t\t// send an ARP request and check if there is anybody on this IP address\n\t\tif (arp_check(br->dev, br->ipsandbox, br->ip)) {\n\t\t\tfprintf(stderr, \"Error: IP address %d.%d.%d.%d is already in use\\n\", PRINT_IP(br->ipsandbox));\n\t\t\texit(1);\n\t\t}\n\t}\n\telse\n\t\t// ip address assigned by arp-scan for a bridge device\n\t\tbr->ipsandbox = arp_assign(br->dev, br); //br->ip, br->mask);\n}",
    "includes": [
      "#include <net/if.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arp_assign",
          "args": [
            "br->dev",
            "br"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "arp_assign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/arp.c",
          "lines": "266-287",
          "snippet": "uint32_t arp_assign(const char *dev, Bridge *br) {\n\tassert(br);\n\tuint32_t ip = 0;\n\n\t// try two random IP addresses\n\tip = arp_random(dev, br);\n\tif (!ip)\n\t\tip = arp_random(dev, br);\n\t\t\n\t// try all possible IP addresses one by one\n\tif (!ip)\n\t\tip = arp_sequential(dev, br);\n\t\n\t// print result\n\tif (!ip) {\n\t\tfprintf(stderr, \"Error: cannot assign an IP address; it looks like all of them are in use.\\n\");\n\t\tlogerr(\"Cannot assign an IP address; it looks like all of them are in use.\");\n\t\texit(1);\n\t}\n\t\n\treturn ip;\n}",
          "includes": [
            "#include <linux/if_packet.h>",
            "#include <linux/tcp.h>",
            "#include <linux/udp.h>",
            "#include <linux/ip.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/if_ether.h>\t\t\t  //TCP/IP Protocol Suite for Linux",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_packet.h>\n#include <linux/tcp.h>\n#include <linux/udp.h>\n#include <linux/ip.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/if_ether.h>\t\t\t  //TCP/IP Protocol Suite for Linux\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include \"firejail.h\"\n\nuint32_t arp_assign(const char *dev, Bridge *br) {\n\tassert(br);\n\tuint32_t ip = 0;\n\n\t// try two random IP addresses\n\tip = arp_random(dev, br);\n\tif (!ip)\n\t\tip = arp_random(dev, br);\n\t\t\n\t// try all possible IP addresses one by one\n\tif (!ip)\n\t\tip = arp_sequential(dev, br);\n\t\n\t// print result\n\tif (!ip) {\n\t\tfprintf(stderr, \"Error: cannot assign an IP address; it looks like all of them are in use.\\n\");\n\t\tlogerr(\"Cannot assign an IP address; it looks like all of them are in use.\");\n\t\texit(1);\n\t}\n\t\n\treturn ip;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "myexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/main.c",
          "lines": "137-149",
          "snippet": "static void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}",
          "includes": [
            "#include <sys/times.h>",
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int arg_command = 0;",
            "int arg_quiet = 0;",
            "pid_t sandbox_pid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/times.h>\n#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nint arg_command = 0;\nint arg_quiet = 0;\npid_t sandbox_pid;\n\nstatic void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: IP address %d.%d.%d.%d is already in use\\n\"",
            "PRINT_IP(br->ipsandbox)"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_IP",
          "args": [
            "br->ipsandbox"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arp_check",
          "args": [
            "br->dev",
            "br->ipsandbox",
            "br->ip"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "arp_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/arp.c",
          "lines": "44-159",
          "snippet": "int arp_check(const char *dev, uint32_t destaddr, uint32_t srcaddr) {\n\tif (strlen(dev) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error: invalid network device name %s\\n\", dev);\n\t\texit(1);\n\t}\n\t\n\tif (arg_debug)\n\t\tprintf(\"Trying %d.%d.%d.%d ...\\n\", PRINT_IP(destaddr));\n\n\t// find interface address\n\tint sock;\n\tif ((sock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0)\n\t\terrExit(\"socket\");\n\n\tsrcaddr = htonl(srcaddr);\n\tdestaddr = htonl(destaddr);\n\n\t// Find interface MAC address\n\tstruct ifreq ifr;\n\tmemset(&ifr, 0, sizeof (ifr));\n\tstrncpy(ifr.ifr_name, dev, IFNAMSIZ);\n\tif (ioctl(sock, SIOCGIFHWADDR, &ifr) < 0)\n\t\terrExit(\"ioctl\");\n\tclose(sock);\n\t\n\t// configure layer2 socket address information\n\tstruct sockaddr_ll addr;\n\tmemset(&addr, 0, sizeof(addr));\n\tif ((addr.sll_ifindex = if_nametoindex(dev)) == 0)\n\t\terrExit(\"if_nametoindex\");\n\taddr.sll_family = AF_PACKET;\n\tmemcpy (addr.sll_addr, ifr.ifr_hwaddr.sa_data, 6);\n\taddr.sll_halen = htons(6);\n\n\t// build the arp packet header\n\tArpHdr hdr;\n\tmemset(&hdr, 0, sizeof(hdr));\n\thdr.htype = htons(1);\n\thdr.ptype = htons(ETH_P_IP);\n\thdr.hlen = 6;\n\thdr.plen = 4;\n\thdr.opcode = htons(1); //ARPOP_REQUEST\n\tmemcpy(hdr.sender_mac, ifr.ifr_hwaddr.sa_data, 6);\n\tmemcpy(hdr.sender_ip, (uint8_t *)&srcaddr, 4);\n\tmemcpy(hdr.target_ip, (uint8_t *)&destaddr, 4);\n\n\t// build ethernet frame\n\tuint8_t frame[ETH_FRAME_LEN]; // includes eht header, vlan, and crc\n\tmemset(frame, 0, sizeof(frame));\n\tframe[0] = frame[1] = frame[2] = frame[3] = frame[4] = frame[5] = 0xff;\n\tmemcpy(frame + 6, ifr.ifr_hwaddr.sa_data, 6);\n\tframe[12] = ETH_P_ARP / 256;\n\tframe[13] = ETH_P_ARP % 256;\n\tmemcpy (frame + 14, &hdr, sizeof(hdr));\n\n\t// open layer2 socket\n\tif ((sock = socket(PF_PACKET, SOCK_RAW, htons (ETH_P_ALL))) < 0)\n\t\terrExit(\"socket\");\n\n\tint len;\n\tif ((len = sendto (sock, frame, 14 + sizeof(ArpHdr), 0, (struct sockaddr *) &addr, sizeof (addr))) <= 0)\n\t\terrExit(\"send\");\n\tfflush(0);\n\t\t\n\t// wait not more than one second for an answer\n\tfd_set fds;\n\tFD_ZERO(&fds);\n\tFD_SET(sock, &fds);\n\tint maxfd = sock;\n\tstruct timeval ts;\n\tts.tv_sec = 1; // 1 second wait time\n\tts.tv_usec = 0;\n\twhile (1) {\n\t\tint nready = select(maxfd + 1,  &fds, (fd_set *) 0, (fd_set *) 0, &ts);\n\t\tif (nready < 0)\n\t\t\terrExit(\"select\");\n\t\telse if (nready == 0) { // timeout\n\t\t\tclose(sock);\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\t// read the incoming packet\n\t\t\tint len = recvfrom(sock, frame, ETH_FRAME_LEN, 0, NULL, NULL);\n\t\t\tif (len < 0) {\n\t\t\t\tperror(\"recvfrom\");\n\t\t\t\tclose(sock);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\n\t\t\t// parse the incoming packet\n\t\t\tif ((unsigned int) len < 14 + sizeof(ArpHdr))\n\t\t\t\tcontinue;\n\t\t\tif (frame[12] != (ETH_P_ARP / 256) || frame[13] != (ETH_P_ARP % 256))\n\t\t\t\tcontinue;\n\t\t\tmemcpy(&hdr, frame + 14, sizeof(ArpHdr));\n\t\t\tif (hdr.opcode == htons(1))\n\t\t\t\tcontinue;\n\t\t\tif (hdr.opcode == htons(2)) {\n\t\t\t\t// check my mac and my address\n\t\t\t\tif (memcmp(ifr.ifr_hwaddr.sa_data, hdr.target_mac, 6) != 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tuint32_t ip;\n\t\t\t\tmemcpy(&ip, hdr.target_ip, 4);\n\t\t\t\tif (ip != srcaddr) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\t\t\t\t\t\n\t\t\t\tclose(sock);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\t// it will never get here!\n\tclose(sock);\n\treturn -1;\n}",
          "includes": [
            "#include <linux/if_packet.h>",
            "#include <linux/tcp.h>",
            "#include <linux/udp.h>",
            "#include <linux/ip.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/if_ether.h>\t\t\t  //TCP/IP Protocol Suite for Linux",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_packet.h>\n#include <linux/tcp.h>\n#include <linux/udp.h>\n#include <linux/ip.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/if_ether.h>\t\t\t  //TCP/IP Protocol Suite for Linux\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include \"firejail.h\"\n\nint arp_check(const char *dev, uint32_t destaddr, uint32_t srcaddr) {\n\tif (strlen(dev) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error: invalid network device name %s\\n\", dev);\n\t\texit(1);\n\t}\n\t\n\tif (arg_debug)\n\t\tprintf(\"Trying %d.%d.%d.%d ...\\n\", PRINT_IP(destaddr));\n\n\t// find interface address\n\tint sock;\n\tif ((sock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0)\n\t\terrExit(\"socket\");\n\n\tsrcaddr = htonl(srcaddr);\n\tdestaddr = htonl(destaddr);\n\n\t// Find interface MAC address\n\tstruct ifreq ifr;\n\tmemset(&ifr, 0, sizeof (ifr));\n\tstrncpy(ifr.ifr_name, dev, IFNAMSIZ);\n\tif (ioctl(sock, SIOCGIFHWADDR, &ifr) < 0)\n\t\terrExit(\"ioctl\");\n\tclose(sock);\n\t\n\t// configure layer2 socket address information\n\tstruct sockaddr_ll addr;\n\tmemset(&addr, 0, sizeof(addr));\n\tif ((addr.sll_ifindex = if_nametoindex(dev)) == 0)\n\t\terrExit(\"if_nametoindex\");\n\taddr.sll_family = AF_PACKET;\n\tmemcpy (addr.sll_addr, ifr.ifr_hwaddr.sa_data, 6);\n\taddr.sll_halen = htons(6);\n\n\t// build the arp packet header\n\tArpHdr hdr;\n\tmemset(&hdr, 0, sizeof(hdr));\n\thdr.htype = htons(1);\n\thdr.ptype = htons(ETH_P_IP);\n\thdr.hlen = 6;\n\thdr.plen = 4;\n\thdr.opcode = htons(1); //ARPOP_REQUEST\n\tmemcpy(hdr.sender_mac, ifr.ifr_hwaddr.sa_data, 6);\n\tmemcpy(hdr.sender_ip, (uint8_t *)&srcaddr, 4);\n\tmemcpy(hdr.target_ip, (uint8_t *)&destaddr, 4);\n\n\t// build ethernet frame\n\tuint8_t frame[ETH_FRAME_LEN]; // includes eht header, vlan, and crc\n\tmemset(frame, 0, sizeof(frame));\n\tframe[0] = frame[1] = frame[2] = frame[3] = frame[4] = frame[5] = 0xff;\n\tmemcpy(frame + 6, ifr.ifr_hwaddr.sa_data, 6);\n\tframe[12] = ETH_P_ARP / 256;\n\tframe[13] = ETH_P_ARP % 256;\n\tmemcpy (frame + 14, &hdr, sizeof(hdr));\n\n\t// open layer2 socket\n\tif ((sock = socket(PF_PACKET, SOCK_RAW, htons (ETH_P_ALL))) < 0)\n\t\terrExit(\"socket\");\n\n\tint len;\n\tif ((len = sendto (sock, frame, 14 + sizeof(ArpHdr), 0, (struct sockaddr *) &addr, sizeof (addr))) <= 0)\n\t\terrExit(\"send\");\n\tfflush(0);\n\t\t\n\t// wait not more than one second for an answer\n\tfd_set fds;\n\tFD_ZERO(&fds);\n\tFD_SET(sock, &fds);\n\tint maxfd = sock;\n\tstruct timeval ts;\n\tts.tv_sec = 1; // 1 second wait time\n\tts.tv_usec = 0;\n\twhile (1) {\n\t\tint nready = select(maxfd + 1,  &fds, (fd_set *) 0, (fd_set *) 0, &ts);\n\t\tif (nready < 0)\n\t\t\terrExit(\"select\");\n\t\telse if (nready == 0) { // timeout\n\t\t\tclose(sock);\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\t// read the incoming packet\n\t\t\tint len = recvfrom(sock, frame, ETH_FRAME_LEN, 0, NULL, NULL);\n\t\t\tif (len < 0) {\n\t\t\t\tperror(\"recvfrom\");\n\t\t\t\tclose(sock);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\n\t\t\t// parse the incoming packet\n\t\t\tif ((unsigned int) len < 14 + sizeof(ArpHdr))\n\t\t\t\tcontinue;\n\t\t\tif (frame[12] != (ETH_P_ARP / 256) || frame[13] != (ETH_P_ARP % 256))\n\t\t\t\tcontinue;\n\t\t\tmemcpy(&hdr, frame + 14, sizeof(ArpHdr));\n\t\t\tif (hdr.opcode == htons(1))\n\t\t\t\tcontinue;\n\t\t\tif (hdr.opcode == htons(2)) {\n\t\t\t\t// check my mac and my address\n\t\t\t\tif (memcmp(ifr.ifr_hwaddr.sa_data, hdr.target_mac, 6) != 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tuint32_t ip;\n\t\t\t\tmemcpy(&ip, hdr.target_ip, 4);\n\t\t\t\tif (ip != srcaddr) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\t\t\t\t\t\n\t\t\t\tclose(sock);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\t// it will never get here!\n\tclose(sock);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s\"",
            "rv"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_netrange",
          "args": [
            "br->ipsandbox",
            "br->ip",
            "br->mask"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "br"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/if.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid net_configure_sandbox_ip(Bridge *br) {\n\tassert(br);\n\tif (br->configured == 0)\n\t\treturn;\n\n\tif (br->arg_ip_none)\n\t\tbr->ipsandbox = 0;\n\telse if (br->ipsandbox) {\n\t\t// check network range\n\t\tchar *rv = in_netrange(br->ipsandbox, br->ip, br->mask);\n\t\tif (rv) {\n\t\t\tfprintf(stderr, \"%s\", rv);\n\t\t\texit(1);\n\t\t}\n\t\t// send an ARP request and check if there is anybody on this IP address\n\t\tif (arp_check(br->dev, br->ipsandbox, br->ip)) {\n\t\t\tfprintf(stderr, \"Error: IP address %d.%d.%d.%d is already in use\\n\", PRINT_IP(br->ipsandbox));\n\t\t\texit(1);\n\t\t}\n\t}\n\telse\n\t\t// ip address assigned by arp-scan for a bridge device\n\t\tbr->ipsandbox = arp_assign(br->dev, br); //br->ip, br->mask);\n}"
  },
  {
    "function_name": "net_configure_bridge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/network_main.c",
    "lines": "29-82",
    "snippet": "void net_configure_bridge(Bridge *br, char *dev_name) {\n\tassert(br);\n\tassert(dev_name);\n\n\tbr->dev = dev_name;\n\n\t// check the bridge device exists\n\tchar sysbridge[30 + strlen(br->dev)];\n\tsprintf(sysbridge, \"/sys/class/net/%s/bridge\", br->dev);\n\tstruct stat s;\n\tint rv = stat(sysbridge, &s);\n\tif (rv == 0) {\n\t\t// this is a bridge device\n\t\tbr->macvlan = 0;\n\t}\n\telse {\n\t\t// is this a regular Ethernet interface\n\t\tif (if_nametoindex(br->dev) > 0) {\n\t\t\tbr->macvlan = 1;\n\t\t\tchar *newname;\n\t\t\tif (asprintf(&newname, \"%s-%u\", br->devsandbox, getpid()) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tbr->devsandbox = newname;\n\t\t}\t\t\t\n\t\telse {\n\t\t\tfprintf(stderr, \"Error: cannot find network device %s\\n\", br->dev);\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// allow unconfigured interfaces\n\tif (net_get_if_addr(br->dev, &br->ip, &br->mask, br->mac, &br->mtu)) {\n\t\tfprintf(stderr, \"Warning: the network interface %s is not configured\\n\", br->dev);\n\t\tbr->configured = 1;\n\t\tbr->arg_ip_none = 1;\n\t\treturn;\n\t}\n\tif (arg_debug) {\n\t\tif (br->macvlan == 0)\n\t\t\tprintf(\"Bridge device %s at %d.%d.%d.%d/%d\\n\",\n\t\t\t\tbr->dev, PRINT_IP(br->ip), mask2bits(br->mask));\n\t\telse\n\t\t\tprintf(\"macvlan parent device %s at %d.%d.%d.%d/%d\\n\",\n\t\t\t\tbr->dev, PRINT_IP(br->ip), mask2bits(br->mask));\n\t}\n\t\n\tuint32_t range = ~br->mask + 1;\t\t  // the number of potential addresses\n\t// this software is not supported for /31 networks\n\tif (range < 4) {\n\t\tfprintf(stderr, \"Error: the software is not supported for /31 networks\\n\");\n\t\texit(1);\n\t}\n\tbr->configured = 1;\n}",
    "includes": [
      "#include <net/if.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "myexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/main.c",
          "lines": "137-149",
          "snippet": "static void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}",
          "includes": [
            "#include <sys/times.h>",
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int arg_command = 0;",
            "int arg_quiet = 0;",
            "pid_t sandbox_pid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/times.h>\n#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nint arg_command = 0;\nint arg_quiet = 0;\npid_t sandbox_pid;\n\nstatic void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: the software is not supported for /31 networks\\n\""
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"macvlan parent device %s at %d.%d.%d.%d/%d\\n\"",
            "br->dev",
            "PRINT_IP(br->ip)",
            "mask2bits(br->mask)"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mask2bits",
          "args": [
            "br->mask"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_IP",
          "args": [
            "br->ip"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Bridge device %s at %d.%d.%d.%d/%d\\n\"",
            "br->dev",
            "PRINT_IP(br->ip)",
            "mask2bits(br->mask)"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mask2bits",
          "args": [
            "br->mask"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_IP",
          "args": [
            "br->ip"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: the network interface %s is not configured\\n\"",
            "br->dev"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_get_if_addr",
          "args": [
            "br->dev",
            "&br->ip",
            "&br->mask",
            "br->mac",
            "&br->mtu"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "net_get_if_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/network.c",
          "lines": "147-185",
          "snippet": "int net_get_if_addr(const char *bridge, uint32_t *ip, uint32_t *mask, uint8_t mac[6], int *mtu) {\n\tassert(bridge);\n\tassert(ip);\n\tassert(mask);\n\t\n\tif (arg_debug)\n\t\tprintf(\"get interface %s configuration\\n\", bridge);\n\t\t\n\tint rv = -1;\n\tstruct ifaddrs *ifaddr, *ifa;\n\n\tif (getifaddrs(&ifaddr) == -1)\n\t\terrExit(\"getifaddrs\");\n\n\t// walk through the linked list; if the interface is found, extract IP address and mask\n\tfor (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {\n\t\tif (ifa->ifa_addr == NULL)\n\t\t\tcontinue;\n\t\tif (strcmp(ifa->ifa_name, bridge) != 0)\n\t\t\tcontinue;\n\n\t\tif (ifa->ifa_addr->sa_family == AF_INET) {\n\t\t\tstruct sockaddr_in *si = (struct sockaddr_in *) ifa->ifa_netmask;\n\t\t\t*mask = ntohl(si->sin_addr.s_addr);\n\t\t\tsi = (struct sockaddr_in *) ifa->ifa_addr;\n\t\t\t*ip = ntohl(si->sin_addr.s_addr);\n\t\t\tif (strcmp(ifa->ifa_name, \"lo\") != 0) {\n\t\t\t\tnet_get_mac(ifa->ifa_name, mac);\n\t\t\t\t*mtu = net_get_mtu(bridge);\n\t\t\t}\n\t\t\t\n\t\t\trv = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfreeifaddrs(ifaddr);\n\treturn rv;\n}",
          "includes": [
            "#include <linux/if_bridge.h>",
            "#include <net/route.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <ifaddrs.h>",
            "#include <netdb.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <arpa/inet.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"firejail.h\"\n\nint net_get_if_addr(const char *bridge, uint32_t *ip, uint32_t *mask, uint8_t mac[6], int *mtu) {\n\tassert(bridge);\n\tassert(ip);\n\tassert(mask);\n\t\n\tif (arg_debug)\n\t\tprintf(\"get interface %s configuration\\n\", bridge);\n\t\t\n\tint rv = -1;\n\tstruct ifaddrs *ifaddr, *ifa;\n\n\tif (getifaddrs(&ifaddr) == -1)\n\t\terrExit(\"getifaddrs\");\n\n\t// walk through the linked list; if the interface is found, extract IP address and mask\n\tfor (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {\n\t\tif (ifa->ifa_addr == NULL)\n\t\t\tcontinue;\n\t\tif (strcmp(ifa->ifa_name, bridge) != 0)\n\t\t\tcontinue;\n\n\t\tif (ifa->ifa_addr->sa_family == AF_INET) {\n\t\t\tstruct sockaddr_in *si = (struct sockaddr_in *) ifa->ifa_netmask;\n\t\t\t*mask = ntohl(si->sin_addr.s_addr);\n\t\t\tsi = (struct sockaddr_in *) ifa->ifa_addr;\n\t\t\t*ip = ntohl(si->sin_addr.s_addr);\n\t\t\tif (strcmp(ifa->ifa_name, \"lo\") != 0) {\n\t\t\t\tnet_get_mac(ifa->ifa_name, mac);\n\t\t\t\t*mtu = net_get_mtu(bridge);\n\t\t\t}\n\t\t\t\n\t\t\trv = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfreeifaddrs(ifaddr);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot find network device %s\\n\"",
            "br->dev"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&newname",
            "\"%s-%u\"",
            "br->devsandbox",
            "getpid()"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_nametoindex",
          "args": [
            "br->dev"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "sysbridge",
            "&s"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "sysbridge",
            "\"/sys/class/net/%s/bridge\"",
            "br->dev"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "br->dev"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "dev_name"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "br"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/if.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid net_configure_bridge(Bridge *br, char *dev_name) {\n\tassert(br);\n\tassert(dev_name);\n\n\tbr->dev = dev_name;\n\n\t// check the bridge device exists\n\tchar sysbridge[30 + strlen(br->dev)];\n\tsprintf(sysbridge, \"/sys/class/net/%s/bridge\", br->dev);\n\tstruct stat s;\n\tint rv = stat(sysbridge, &s);\n\tif (rv == 0) {\n\t\t// this is a bridge device\n\t\tbr->macvlan = 0;\n\t}\n\telse {\n\t\t// is this a regular Ethernet interface\n\t\tif (if_nametoindex(br->dev) > 0) {\n\t\t\tbr->macvlan = 1;\n\t\t\tchar *newname;\n\t\t\tif (asprintf(&newname, \"%s-%u\", br->devsandbox, getpid()) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tbr->devsandbox = newname;\n\t\t}\t\t\t\n\t\telse {\n\t\t\tfprintf(stderr, \"Error: cannot find network device %s\\n\", br->dev);\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// allow unconfigured interfaces\n\tif (net_get_if_addr(br->dev, &br->ip, &br->mask, br->mac, &br->mtu)) {\n\t\tfprintf(stderr, \"Warning: the network interface %s is not configured\\n\", br->dev);\n\t\tbr->configured = 1;\n\t\tbr->arg_ip_none = 1;\n\t\treturn;\n\t}\n\tif (arg_debug) {\n\t\tif (br->macvlan == 0)\n\t\t\tprintf(\"Bridge device %s at %d.%d.%d.%d/%d\\n\",\n\t\t\t\tbr->dev, PRINT_IP(br->ip), mask2bits(br->mask));\n\t\telse\n\t\t\tprintf(\"macvlan parent device %s at %d.%d.%d.%d/%d\\n\",\n\t\t\t\tbr->dev, PRINT_IP(br->ip), mask2bits(br->mask));\n\t}\n\t\n\tuint32_t range = ~br->mask + 1;\t\t  // the number of potential addresses\n\t// this software is not supported for /31 networks\n\tif (range < 4) {\n\t\tfprintf(stderr, \"Error: the software is not supported for /31 networks\\n\");\n\t\texit(1);\n\t}\n\tbr->configured = 1;\n}"
  }
]