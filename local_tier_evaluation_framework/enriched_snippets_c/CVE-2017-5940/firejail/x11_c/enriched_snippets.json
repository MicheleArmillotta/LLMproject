[
  {
    "function_name": "x11_xorg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/x11.c",
    "lines": "645-734",
    "snippet": "void x11_xorg(void) {\n#ifdef HAVE_X11\n\t// destination - create an empty ~/.Xauthotrity file if it doesn't exist already, and use it as a mount point\n\tchar *dest;\n\tif (asprintf(&dest, \"%s/.Xauthority\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\tstruct stat s;\n\tif (stat(dest, &s) == -1) {\n\t\t// create an .Xauthority file\n\t\tFILE *fp = fopen(dest, \"w\");\n\t\tif (!fp)\n\t\t\terrExit(\"fopen\");\n\t\tSET_PERMS_STREAM(fp, getuid(), getgid(), 0600);\n\t\tfclose(fp);\n\t}\n\n\t// check xauth utility is present in the system\n\tif (stat(\"/usr/bin/xauth\", &s) == -1) {\n\t\tfprintf(stderr, \"Error: cannot find /usr/bin/xauth executable\\n\");\n\t\texit(1);\n\t}\n\n\t// create a temporary .Xauthority file\n\tchar tmpfname[] = \"/tmp/.tmpXauth-XXXXXX\";\n\tint fd = mkstemp(tmpfname);\n\tif (fd == -1) {\n\t\tfprintf(stderr, \"Error: cannot create .Xauthority file\\n\");\n\t\texit(1);\n\t}\n\tclose(fd);\n\tif (chown(tmpfname, getuid(), getgid()) == -1)\n\t\terrExit(\"chown\");\n\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// generate the new .Xauthority file using xauth utility\n\t\tif (arg_debug)\n\t\t\tprintf(\"Generating a new .Xauthority file\\n\");\n\t\tdrop_privs(1);\n\n\t\tchar *display = getenv(\"DISPLAY\");\n\t\tif (!display)\n\t\t\tdisplay = \":0.0\";\n\t\t\n\t\tclearenv();\n\t\texeclp(\"/usr/bin/xauth\", \"/usr/bin/xauth\", \"-f\", tmpfname,\n\t\t\t\"generate\", display, \"MIT-MAGIC-COOKIE-1\", \"untrusted\", NULL); \n\t\t\n\t\t_exit(0);\n\t}\n\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n\n\t// check the file was created and set mode and ownership\n\tif (stat(tmpfname, &s) == -1) {\n\t\tfprintf(stderr, \"Error: cannot create the new .Xauthority file\\n\");\n\t\texit(1);\n\t}\n\tif (chown(tmpfname, getuid(), getgid()) == -1)\n\t\terrExit(\"chown\");\n\tif (chmod(tmpfname, 0600) == -1)\n\t\terrExit(\"chmod\");\n\t\n\t// move the temporary file in RUN_XAUTHORITY_SEC_FILE in order to have it deleted\n\t// automatically when the sandbox is closed\n\tif (copy_file(tmpfname, RUN_XAUTHORITY_SEC_FILE, getuid(), getgid(), 0600)) {\n\t\tfprintf(stderr, \"asdfdsfError: cannot create the new .Xauthority file\\n\");\n\t\texit(1);\n\t}\n\tif (chown(RUN_XAUTHORITY_SEC_FILE, getuid(), getgid()) == -1)\n\t\terrExit(\"chown\");\n\tif (chmod(RUN_XAUTHORITY_SEC_FILE, 0600) == -1)\n\t\terrExit(\"chmod\");\n\tunlink(tmpfname);\n\t\n\t// mount\n\tif (mount(RUN_XAUTHORITY_SEC_FILE, dest, \"none\", MS_BIND, \"mode=0600\") == -1) {\n\t\tfprintf(stderr, \"Error: cannot mount the new .Xauthority file\\n\");\n\t\texit(1);\n\t}\n\tif (chown(dest, getuid(), getgid()) == -1)\n\t\terrExit(\"chown\");\n\tif (chmod(dest, 0600) == -1)\n\t\terrExit(\"chmod\");\n\tfree(dest);\n#endif\t\n}",
    "includes": [
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "dest"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"chmod\""
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chmod",
          "args": [
            "dest",
            "0600"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"chown\""
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chown",
          "args": [
            "dest",
            "getuid()",
            "getgid()"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getgid",
          "args": [],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "myexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/main.c",
          "lines": "137-149",
          "snippet": "static void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}",
          "includes": [
            "#include <sys/times.h>",
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int arg_command = 0;",
            "int arg_quiet = 0;",
            "pid_t sandbox_pid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/times.h>\n#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nint arg_command = 0;\nint arg_quiet = 0;\npid_t sandbox_pid;\n\nstatic void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot mount the new .Xauthority file\\n\""
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "RUN_XAUTHORITY_SEC_FILE",
            "dest",
            "\"none\"",
            "MS_BIND",
            "\"mode=0600\""
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "tmpfname"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"chmod\""
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chmod",
          "args": [
            "RUN_XAUTHORITY_SEC_FILE",
            "0600"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"chown\""
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chown",
          "args": [
            "RUN_XAUTHORITY_SEC_FILE",
            "getuid()",
            "getgid()"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getgid",
          "args": [],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"asdfdsfError: cannot create the new .Xauthority file\\n\""
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_file",
          "args": [
            "tmpfname",
            "RUN_XAUTHORITY_SEC_FILE",
            "getuid()",
            "getgid()",
            "0600"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "copy_file_as_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/util.c",
          "lines": "224-240",
          "snippet": "void copy_file_as_user(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode) {\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// drop privileges\n\t\tdrop_privs(0);\n\n\t\t// copy, set permissions and ownership\n\t\tint rv = copy_file(srcname, destname, uid, gid, mode);\n\t\tif (rv)\n\t\t\tfprintf(stderr, \"Warning: cannot transfer .Xauthority in private home directory\\n\");\n\t\t_exit(0);\n\t}\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid copy_file_as_user(const char *srcname, const char *destname, uid_t uid, gid_t gid, mode_t mode) {\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// drop privileges\n\t\tdrop_privs(0);\n\n\t\t// copy, set permissions and ownership\n\t\tint rv = copy_file(srcname, destname, uid, gid, mode);\n\t\tif (rv)\n\t\t\tfprintf(stderr, \"Warning: cannot transfer .Xauthority in private home directory\\n\");\n\t\t_exit(0);\n\t}\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getgid",
          "args": [],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"chmod\""
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chmod",
          "args": [
            "tmpfname",
            "0600"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"chown\""
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chown",
          "args": [
            "tmpfname",
            "getuid()",
            "getgid()"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getgid",
          "args": [],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot create the new .Xauthority file\\n\""
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "tmpfname",
            "&s"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "child",
            "NULL",
            "0"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "0"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execlp",
          "args": [
            "\"/usr/bin/xauth\"",
            "\"/usr/bin/xauth\"",
            "\"-f\"",
            "tmpfname",
            "\"generate\"",
            "display",
            "\"MIT-MAGIC-COOKIE-1\"",
            "\"untrusted\"",
            "NULL"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clearenv",
          "args": [],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"DISPLAY\""
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "drop_privs",
          "args": [
            "1"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "drop_privs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/util.c",
          "lines": "36-81",
          "snippet": "void drop_privs(int nogroups) {\n\tEUID_ROOT();\n\tgid_t gid = getgid();\n\n\t// configure supplementary groups\n\tif (gid == 0 || nogroups) {\n\t\tif (setgroups(0, NULL) < 0)\n\t\t\terrExit(\"setgroups\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Username %s, no supplementary groups\\n\", cfg.username);\n\t}\n\telse {\n\t\tassert(cfg.username);\n\t\tgid_t groups[MAX_GROUPS];\n\t\tint ngroups = MAX_GROUPS;\n\t\tint rv = getgrouplist(cfg.username, gid, groups, &ngroups);\n\n\t\tif (arg_debug && rv) {\n\t\t\tprintf(\"Username %s, groups \", cfg.username);\n\t\t\tint i;\n\t\t\tfor (i = 0; i < ngroups; i++)\n\t\t\t\tprintf(\"%u, \", groups[i]);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\n\t\tif (rv == -1) {\n\t\t\tfprintf(stderr, \"Warning: cannot extract supplementary group list, dropping them\\n\");\n\t\t\tif (setgroups(0, NULL) < 0)\n\t\t\t\terrExit(\"setgroups\");\n\t\t}\n\t\telse {\n\t\t\trv = setgroups(ngroups, groups);\n\t\t\tif (rv) {\n\t\t\t\tfprintf(stderr, \"Warning: cannot set supplementary group list, dropping them\\n\");\n\t\t\t\tif (setgroups(0, NULL) < 0)\n\t\t\t\t\terrExit(\"setgroups\");\n\t\t\t}\n\t\t}\n\t}\n\n\t// set uid/gid\n\tif (setgid(getgid()) < 0)\n\t\terrExit(\"setgid/getgid\");\n\tif (setuid(getuid()) < 0)\n\t\terrExit(\"setuid/getuid\");\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAX_GROUPS 1024"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\n#define MAX_GROUPS 1024\n\nvoid drop_privs(int nogroups) {\n\tEUID_ROOT();\n\tgid_t gid = getgid();\n\n\t// configure supplementary groups\n\tif (gid == 0 || nogroups) {\n\t\tif (setgroups(0, NULL) < 0)\n\t\t\terrExit(\"setgroups\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Username %s, no supplementary groups\\n\", cfg.username);\n\t}\n\telse {\n\t\tassert(cfg.username);\n\t\tgid_t groups[MAX_GROUPS];\n\t\tint ngroups = MAX_GROUPS;\n\t\tint rv = getgrouplist(cfg.username, gid, groups, &ngroups);\n\n\t\tif (arg_debug && rv) {\n\t\t\tprintf(\"Username %s, groups \", cfg.username);\n\t\t\tint i;\n\t\t\tfor (i = 0; i < ngroups; i++)\n\t\t\t\tprintf(\"%u, \", groups[i]);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\n\t\tif (rv == -1) {\n\t\t\tfprintf(stderr, \"Warning: cannot extract supplementary group list, dropping them\\n\");\n\t\t\tif (setgroups(0, NULL) < 0)\n\t\t\t\terrExit(\"setgroups\");\n\t\t}\n\t\telse {\n\t\t\trv = setgroups(ngroups, groups);\n\t\t\tif (rv) {\n\t\t\t\tfprintf(stderr, \"Warning: cannot set supplementary group list, dropping them\\n\");\n\t\t\t\tif (setgroups(0, NULL) < 0)\n\t\t\t\t\terrExit(\"setgroups\");\n\t\t\t}\n\t\t}\n\t}\n\n\t// set uid/gid\n\tif (setgid(getgid()) < 0)\n\t\terrExit(\"setgid/getgid\");\n\tif (setuid(getuid()) < 0)\n\t\terrExit(\"setuid/getuid\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Generating a new .Xauthority file\\n\""
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fork\""
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"chown\""
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chown",
          "args": [
            "tmpfname",
            "getuid()",
            "getgid()"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getgid",
          "args": [],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot create .Xauthority file\\n\""
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkstemp",
          "args": [
            "tmpfname"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot find /usr/bin/xauth executable\\n\""
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "\"/usr/bin/xauth\"",
            "&s"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_PERMS_STREAM",
          "args": [
            "fp",
            "getuid()",
            "getgid()",
            "0600"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getgid",
          "args": [],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fopen\""
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "dest",
            "\"w\""
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "dest",
            "&s"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&dest",
            "\"%s/.Xauthority\"",
            "cfg.homedir"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/wait.h>\n#include <sys/mount.h>\n#include <dirent.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid x11_xorg(void) {\n#ifdef HAVE_X11\n\t// destination - create an empty ~/.Xauthotrity file if it doesn't exist already, and use it as a mount point\n\tchar *dest;\n\tif (asprintf(&dest, \"%s/.Xauthority\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\tstruct stat s;\n\tif (stat(dest, &s) == -1) {\n\t\t// create an .Xauthority file\n\t\tFILE *fp = fopen(dest, \"w\");\n\t\tif (!fp)\n\t\t\terrExit(\"fopen\");\n\t\tSET_PERMS_STREAM(fp, getuid(), getgid(), 0600);\n\t\tfclose(fp);\n\t}\n\n\t// check xauth utility is present in the system\n\tif (stat(\"/usr/bin/xauth\", &s) == -1) {\n\t\tfprintf(stderr, \"Error: cannot find /usr/bin/xauth executable\\n\");\n\t\texit(1);\n\t}\n\n\t// create a temporary .Xauthority file\n\tchar tmpfname[] = \"/tmp/.tmpXauth-XXXXXX\";\n\tint fd = mkstemp(tmpfname);\n\tif (fd == -1) {\n\t\tfprintf(stderr, \"Error: cannot create .Xauthority file\\n\");\n\t\texit(1);\n\t}\n\tclose(fd);\n\tif (chown(tmpfname, getuid(), getgid()) == -1)\n\t\terrExit(\"chown\");\n\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// generate the new .Xauthority file using xauth utility\n\t\tif (arg_debug)\n\t\t\tprintf(\"Generating a new .Xauthority file\\n\");\n\t\tdrop_privs(1);\n\n\t\tchar *display = getenv(\"DISPLAY\");\n\t\tif (!display)\n\t\t\tdisplay = \":0.0\";\n\t\t\n\t\tclearenv();\n\t\texeclp(\"/usr/bin/xauth\", \"/usr/bin/xauth\", \"-f\", tmpfname,\n\t\t\t\"generate\", display, \"MIT-MAGIC-COOKIE-1\", \"untrusted\", NULL); \n\t\t\n\t\t_exit(0);\n\t}\n\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n\n\t// check the file was created and set mode and ownership\n\tif (stat(tmpfname, &s) == -1) {\n\t\tfprintf(stderr, \"Error: cannot create the new .Xauthority file\\n\");\n\t\texit(1);\n\t}\n\tif (chown(tmpfname, getuid(), getgid()) == -1)\n\t\terrExit(\"chown\");\n\tif (chmod(tmpfname, 0600) == -1)\n\t\terrExit(\"chmod\");\n\t\n\t// move the temporary file in RUN_XAUTHORITY_SEC_FILE in order to have it deleted\n\t// automatically when the sandbox is closed\n\tif (copy_file(tmpfname, RUN_XAUTHORITY_SEC_FILE, getuid(), getgid(), 0600)) {\n\t\tfprintf(stderr, \"asdfdsfError: cannot create the new .Xauthority file\\n\");\n\t\texit(1);\n\t}\n\tif (chown(RUN_XAUTHORITY_SEC_FILE, getuid(), getgid()) == -1)\n\t\terrExit(\"chown\");\n\tif (chmod(RUN_XAUTHORITY_SEC_FILE, 0600) == -1)\n\t\terrExit(\"chmod\");\n\tunlink(tmpfname);\n\t\n\t// mount\n\tif (mount(RUN_XAUTHORITY_SEC_FILE, dest, \"none\", MS_BIND, \"mode=0600\") == -1) {\n\t\tfprintf(stderr, \"Error: cannot mount the new .Xauthority file\\n\");\n\t\texit(1);\n\t}\n\tif (chown(dest, getuid(), getgid()) == -1)\n\t\terrExit(\"chown\");\n\tif (chmod(dest, 0600) == -1)\n\t\terrExit(\"chmod\");\n\tfree(dest);\n#endif\t\n}"
  },
  {
    "function_name": "x11_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/x11.c",
    "lines": "608-643",
    "snippet": "void x11_block(void) {\n#ifdef HAVE_X11\n\tmask_x11_abstract_socket = 1;\n\n\t// check abstract socket presence and network namespace options\n\tif ((!arg_nonetwork && !cfg.bridge0.configured && !cfg.interface0.configured)\n\t\t&& x11_abstract_sockets_present()) {\n\t\tfprintf(stderr, \"ERROR: --x11=none specified, but abstract X11 socket still accessible.\\n\"\n\t\t\t\t\t\t\"Additional setup required. To block abstract X11 socket you can either:\\n\"\n\t\t\t\t\t\t\" * use network namespace in firejail (--net=none, --net=...)\\n\"\n\t\t\t\t\t\t\" * add \\\"-nolisten local\\\" to xserver options\\n\"\n\t\t\t\t\t\t\"   (eg. to your display manager config, or /etc/X11/xinit/xserverrc)\\n\");\n\t\texit(1);\n\t}\n\n\t// blacklist sockets\n\tprofile_check_line(\"blacklist /tmp/.X11-unix\", 0, NULL);\n\tprofile_add(strdup(\"blacklist /tmp/.X11-unix\"));\n\n\t// blacklist .Xauthority\n\tprofile_check_line(\"blacklist ${HOME}/.Xauthority\", 0, NULL);\n\tprofile_add(strdup(\"blacklist ${HOME}/.Xauthority\"));\n\tchar *xauthority = getenv(\"XAUTHORITY\");\n\tif (xauthority) {\n\t\tchar *line;\n\t\tif (asprintf(&line, \"blacklist %s\", xauthority) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tprofile_check_line(line, 0, NULL);\n\t\tprofile_add(line);\n\t}\n\n\t// clear environment\n\tenv_store(\"DISPLAY\", RMENV);\n\tenv_store(\"XAUTHORITY\", RMENV);\n#endif\n}",
    "includes": [
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int mask_x11_abstract_socket = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "env_store",
          "args": [
            "\"XAUTHORITY\"",
            "RMENV"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "env_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/env.c",
          "lines": "146-185",
          "snippet": "void env_store(const char *str, ENV_OP op) {\n\tEUID_ASSERT();\n\tassert(str);\n\t\n\t// some basic checking\n\tif (*str == '\\0')\n\t\tgoto errexit;\n\tchar *ptr = strchr(str, '=');\n\tif (op == SETENV) {\n\t\tif (!ptr)\n\t\t\tgoto errexit;\n\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errexit;\n\t}\n\n\t// build list entry\n\tEnv *env = malloc(sizeof(Env));\n\tif (!env)\n\t\terrExit(\"malloc\");\n\tmemset(env, 0, sizeof(Env));\n\tenv->name = strdup(str);\n\tif (env->name == NULL)\n\t\terrExit(\"strdup\");\n\tif (op == SETENV) {\n\t\tchar *ptr2 = strchr(env->name, '=');\n\t\tassert(ptr2);\n\t\t*ptr2 = '\\0';\n\t\tenv->value = ptr2 + 1;\n\t}\n\tenv->op = op;\n\t\n\t// add entry to the list\n\tenv_add(env);\n\treturn;\n\t\nerrexit:\n\tfprintf(stderr, \"Error: invalid --env setting\\n\");\n\texit(1);\n}",
          "includes": [
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid env_store(const char *str, ENV_OP op) {\n\tEUID_ASSERT();\n\tassert(str);\n\t\n\t// some basic checking\n\tif (*str == '\\0')\n\t\tgoto errexit;\n\tchar *ptr = strchr(str, '=');\n\tif (op == SETENV) {\n\t\tif (!ptr)\n\t\t\tgoto errexit;\n\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errexit;\n\t}\n\n\t// build list entry\n\tEnv *env = malloc(sizeof(Env));\n\tif (!env)\n\t\terrExit(\"malloc\");\n\tmemset(env, 0, sizeof(Env));\n\tenv->name = strdup(str);\n\tif (env->name == NULL)\n\t\terrExit(\"strdup\");\n\tif (op == SETENV) {\n\t\tchar *ptr2 = strchr(env->name, '=');\n\t\tassert(ptr2);\n\t\t*ptr2 = '\\0';\n\t\tenv->value = ptr2 + 1;\n\t}\n\tenv->op = op;\n\t\n\t// add entry to the list\n\tenv_add(env);\n\treturn;\n\t\nerrexit:\n\tfprintf(stderr, \"Error: invalid --env setting\\n\");\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "profile_add",
          "args": [
            "line"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "profile_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/profile.c",
          "lines": "919-938",
          "snippet": "void profile_add(char *str) {\n\tEUID_ASSERT();\n\t\n\tProfileEntry *prf = malloc(sizeof(ProfileEntry));\n\tif (!prf)\n\t\terrExit(\"malloc\");\n\tmemset(prf, 0, sizeof(ProfileEntry));\n\tprf->next = NULL;\n\tprf->data = str;\t\n\n\t// add prf to the list\n\tif (cfg.profile == NULL) {\n\t\tcfg.profile = prf;\n\t\treturn;\n\t}\n\tProfileEntry *ptr = cfg.profile;\n\twhile (ptr->next != NULL)\n\t\tptr = ptr->next;\n\tptr->next = prf;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <dirent.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <dirent.h>\n#include \"firejail.h\"\n\nvoid profile_add(char *str) {\n\tEUID_ASSERT();\n\t\n\tProfileEntry *prf = malloc(sizeof(ProfileEntry));\n\tif (!prf)\n\t\terrExit(\"malloc\");\n\tmemset(prf, 0, sizeof(ProfileEntry));\n\tprf->next = NULL;\n\tprf->data = str;\t\n\n\t// add prf to the list\n\tif (cfg.profile == NULL) {\n\t\tcfg.profile = prf;\n\t\treturn;\n\t}\n\tProfileEntry *ptr = cfg.profile;\n\twhile (ptr->next != NULL)\n\t\tptr = ptr->next;\n\tptr->next = prf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "profile_check_line",
          "args": [
            "line",
            "0",
            "NULL"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "profile_check_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/profile.c",
          "lines": "69-916",
          "snippet": "int profile_check_line(char *ptr, int lineno, const char *fname) {\n\tEUID_ASSERT();\n\t\n\t// check ignore list\n\tint i;\n\tfor (i = 0; i < MAX_PROFILE_IGNORE; i++) {\n\t\tif (cfg.profile_ignore[i] == NULL)\n\t\t\tbreak;\n\t\t\n\t\tif (strncmp(ptr, cfg.profile_ignore[i], strlen(cfg.profile_ignore[i])) == 0)\n\t\t\treturn 0;\t// ignore line\n\t}\n\t\n\tif (strncmp(ptr, \"ignore \", 7) == 0) {\n\t\tchar *str = strdup(ptr + 7);\n\t\tif (*str == '\\0') {\n\t\t\tfprintf(stderr, \"Error: invalid ignore option\\n\");\n\t\t\texit(1);\n\t\t}\n\t\t// find an empty entry in profile_ignore array\n\t\tint j;\n\t\tfor (j = 0; j < MAX_PROFILE_IGNORE; j++) {\n\t\t\tif (cfg.profile_ignore[j] == NULL) \n\t\t\t\tbreak;\n\t\t}\n\t\tif (j >= MAX_PROFILE_IGNORE) {\n\t\t\tfprintf(stderr, \"Error: maximum %d --ignore options are permitted\\n\", MAX_PROFILE_IGNORE);\n\t\t\texit(1);\n\t\t}\n\t\t// ... and configure it\n\t\telse \n\t\t\tcfg.profile_ignore[j] = str;\n\n\t\treturn 0;\n\t}\n\n\t// mkdir \n\tif (strncmp(ptr, \"mkdir \", 6) == 0) {\n\t\tfs_mkdir(ptr + 6);\n\t\treturn 1;\n\t}\n\t// mkfile \n\tif (strncmp(ptr, \"mkfile \", 7) == 0) {\n\t\tfs_mkfile(ptr + 7);\n\t\treturn 1;\n\t}\n\t// sandbox name\n\telse if (strncmp(ptr, \"name \", 5) == 0) {\n\t\tcfg.name = ptr + 5;\n\t\tif (strlen(cfg.name) == 0) {\n\t\t\tfprintf(stderr, \"Error: invalid sandbox name\\n\");\n\t\t\texit(1);\n\t\t}\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"ipc-namespace\") == 0) {\n\t\targ_ipc = 1;\n\t\treturn 0;\n\t}\n\t// seccomp, caps, private, user namespace\n\telse if (strcmp(ptr, \"noroot\") == 0) {\n#if HAVE_USERNS\n\t\tif (checkcfg(CFG_USERNS))\n\t\t\tcheck_user_namespace();\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: user namespace feature is disabled in Firejail configuration file\\n\");\n#endif\n\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nonewprivs\") == 0) {\n\t\targ_nonewprivs = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"seccomp\") == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP))\n\t\t\targ_seccomp = 1;\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: user seccomp feature is disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"caps\") == 0) {\n\t\targ_caps_default_filter = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"caps.drop all\") == 0) {\n\t\targ_caps_drop_all = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"shell none\") == 0) {\n\t\targ_shell_none = 1;\n\t\treturn 0;\n\t}\t\n\telse if (strcmp(ptr, \"tracelog\") == 0) {\n\t\targ_tracelog = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"private\") == 0) {\n\t\targ_private = 1;\n\t\treturn 0;\n\t}\n\tif (strncmp(ptr, \"private-home \", 13) == 0) {\n#ifdef HAVE_PRIVATE_HOME\n\t\tif (checkcfg(CFG_PRIVATE_HOME)) {\n\t\t\tcfg.home_private_keep = ptr + 13;\n\t\t\tfs_check_home_list();\n\t\t\targ_private = 1;\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: private-home is disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"allusers\") == 0) {\n\t\targ_allusers = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"private-dev\") == 0) {\n\t\targ_private_dev = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"private-tmp\") == 0) {\n\t\targ_private_tmp = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nogroups\") == 0) {\n\t\targ_nogroups = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nosound\") == 0) {\n\t\targ_nosound = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"no3d\") == 0) {\n\t\targ_no3d = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"netfilter\") == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK))\n\t\t\targ_netfilter = 1;\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strncmp(ptr, \"netfilter \", 10) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\targ_netfilter = 1;\n\t\t\targ_netfilter_file = strdup(ptr + 10);\n\t\t\tif (!arg_netfilter_file)\n\t\t\t\terrExit(\"strdup\");\n\t\t\tcheck_netfilter_file(arg_netfilter_file);\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strncmp(ptr, \"netfilter6 \", 11) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\targ_netfilter6 = 1;\n\t\t\targ_netfilter6_file = strdup(ptr + 11);\n\t\t\tif (!arg_netfilter6_file)\n\t\t\t\terrExit(\"strdup\");\n\t\t\tcheck_netfilter_file(arg_netfilter6_file);\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"net none\") == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\targ_nonetwork  = 1;\n\t\t\tcfg.bridge0.configured = 0;\n\t\t\tcfg.bridge1.configured = 0;\n\t\t\tcfg.bridge2.configured = 0;\n\t\t\tcfg.bridge3.configured = 0;\n\t\t\tcfg.interface0.configured = 0;\n\t\t\tcfg.interface1.configured = 0;\n\t\t\tcfg.interface2.configured = 0;\n\t\t\tcfg.interface3.configured = 0;\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strncmp(ptr, \"net \", 4) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n#ifdef HAVE_NETWORK_RESTRICTED\n\t\t\t// compile time restricted networking\n\t\t\tif (getuid() != 0) {\n\t\t\t\tfprintf(stderr, \"Error: only \\\"net none\\\" is allowed to non-root users\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n#endif\n\t\t\t// run time restricted networking\n\t\t\tif (checkcfg(CFG_RESTRICTED_NETWORK) && getuid() != 0) {\n\t\t\t\tfprintf(stderr, \"Error: only \\\"net none\\\" is allowed to non-root users\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t\n\t\t\tif (strcmp(ptr + 4, \"lo\") == 0) {\n\t\t\t\tfprintf(stderr, \"Error: cannot attach to lo device\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tBridge *br;\n\t\t\tif (cfg.bridge0.configured == 0)\n\t\t\t\tbr = &cfg.bridge0;\n\t\t\telse if (cfg.bridge1.configured == 0)\n\t\t\t\tbr = &cfg.bridge1;\n\t\t\telse if (cfg.bridge2.configured == 0)\n\t\t\t\tbr = &cfg.bridge2;\n\t\t\telse if (cfg.bridge3.configured == 0)\n\t\t\t\tbr = &cfg.bridge3;\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"Error: maximum 4 network devices are allowed\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tnet_configure_bridge(br, ptr + 4);\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\t\n\telse if (strncmp(ptr, \"veth-name \", 10) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tbr->veth_name = strdup(ptr + 10);\n\t\t\tif (br->veth_name == NULL)\n\t\t\t\terrExit(\"strdup\");\n\t\t\tif (*br->veth_name == '\\0') {\n\t\t\t\tfprintf(stderr, \"Error: no veth-name configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"iprange \", 8) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (br->iprange_start || br->iprange_end) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the IP range twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// parse option arguments\n\t\t\tchar *firstip = ptr + 8;\n\t\t\tchar *secondip = firstip;\n\t\t\twhile (*secondip != '\\0') {\n\t\t\t\tif (*secondip == ',')\n\t\t\t\t\tbreak;\n\t\t\t\tsecondip++;\n\t\t\t}\n\t\t\tif (*secondip == '\\0') {\n\t\t\t\tfprintf(stderr, \"Error: invalid IP range\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t*secondip = '\\0';\n\t\t\tsecondip++;\n\t\t\t\n\t\t\t// check addresses\n\t\t\tif (atoip(firstip, &br->iprange_start) || atoip(secondip, &br->iprange_end) ||\n\t\t\t    br->iprange_start >= br->iprange_end) {\n\t\t\t\tfprintf(stderr, \"Error: invalid IP range\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (in_netrange(br->iprange_start, br->ip, br->mask) || in_netrange(br->iprange_end, br->ip, br->mask)) {\n\t\t\t\tfprintf(stderr, \"Error: IP range addresses not in network range\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\n\n\telse if (strncmp(ptr, \"mac \", 4) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t\n\t\t\tif (mac_not_zero(br->macsandbox)) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the MAC address twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// read the address\n\t\t\tif (atomac(ptr + 4, br->macsandbox)) {\n\t\t\t\tfprintf(stderr, \"Error: invalid MAC address\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"mtu \", 4) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t\n\t\t\tif (sscanf(ptr + 4, \"%d\", &br->mtu) != 1 || br->mtu < 576 || br->mtu > 9198) {\n\t\t\t\tfprintf(stderr, \"Error: invalid mtu value\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"ip \", 3) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (br->arg_ip_none || br->ipsandbox) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the IP address twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// configure this IP address for the last bridge defined\n\t\t\tif (strcmp(ptr + 3, \"none\") == 0)\n\t\t\t\tbr->arg_ip_none = 1;\n\t\t\telse {\n\t\t\t\tif (atoip(ptr + 3, &br->ipsandbox)) {\n\t\t\t\t\tfprintf(stderr, \"Error: invalid IP address\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"ip6 \", 4) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (br->arg_ip_none || br->ip6sandbox) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the IP address twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// configure this IP address for the last bridge defined\n\t\t\t// todo: verify ipv6 syntax\n\t\t\tbr->ip6sandbox = ptr + 4;\n//\t\t\tif (atoip(argv[i] + 5, &br->ipsandbox)) {\n//\t\t\t\tfprintf(stderr, \"Error: invalid IP address\\n\");\n//\t\t\t\texit(1);\n//\t\t\t}\n\t\t\t\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"defaultgw \", 10) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tif (atoip(ptr + 10, &cfg.defaultgw)) {\n\t\t\t\tfprintf(stderr, \"Error: invalid IP address\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"apparmor\") == 0) {\n#ifdef HAVE_APPARMOR\t\t\n\t\targ_apparmor = 1;\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strncmp(ptr, \"protocol \", 9) == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP))\n\t\t\tprotocol_store(ptr + 9);\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: user seccomp feature is disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\t\n\tif (strncmp(ptr, \"env \", 4) == 0) {\n\t\tenv_store(ptr + 4, SETENV);\n\t\treturn 0;\n\t}\n\tif (strncmp(ptr, \"rmenv \", 6) == 0) {\n\t\tenv_store(ptr + 6, RMENV);\n\t\treturn 0;\n\t}\n\t\n\t// seccomp drop list on top of default list\n\tif (strncmp(ptr, \"seccomp \", 8) == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\targ_seccomp = 1;\n\t\t\tcfg.seccomp_list = strdup(ptr + 8);\n\t\t\tif (!cfg.seccomp_list)\n\t\t\t\terrExit(\"strdup\");\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: user seccomp feature is disabled in Firejail configuration file\\n\");\n#endif\n\n\t\treturn 0;\n\t}\n\t\n\t// seccomp drop list without default list\n\tif (strncmp(ptr, \"seccomp.drop \", 13) == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\targ_seccomp = 1;\n\t\t\tcfg.seccomp_list_drop = strdup(ptr + 13);\n\t\t\tif (!cfg.seccomp_list_drop)\n\t\t\t\terrExit(\"strdup\");\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: user seccomp feature is disabled in Firejail configuration file\\n\");\n#endif\t\t\n\t\treturn 0;\n\t}\n\n\t// seccomp keep list\n\tif (strncmp(ptr, \"seccomp.keep \", 13) == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\targ_seccomp = 1;\n\t\t\tcfg.seccomp_list_keep= strdup(ptr + 13);\n\t\t\tif (!cfg.seccomp_list_keep)\n\t\t\t\terrExit(\"strdup\");\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: user seccomp feature is disabled in Firejail configuration file\\n\");\n#endif\t\t\n\t\treturn 0;\n\t}\n\t\n\t// caps drop list\n\tif (strncmp(ptr, \"caps.drop \", 10) == 0) {\n\t\targ_caps_drop = 1;\n\t\targ_caps_list = strdup(ptr + 10);\n\t\tif (!arg_caps_list)\n\t\t\terrExit(\"strdup\");\n\t\t// verify seccomp list and exit if problems\n\t\tif (caps_check_list(arg_caps_list, NULL))\n\t\t\texit(1);\n\t\treturn 0;\n\t}\n\t\n\t// caps keep list\n\tif (strncmp(ptr, \"caps.keep \", 10) == 0) {\n\t\targ_caps_keep = 1;\n\t\targ_caps_list = strdup(ptr + 10);\n\t\tif (!arg_caps_list)\n\t\t\terrExit(\"strdup\");\n\t\t// verify seccomp list and exit if problems\n\t\tif (caps_check_list(arg_caps_list, NULL))\n\t\t\texit(1);\n\t\treturn 0;\n\t}\n\n\t// hostname\n\tif (strncmp(ptr, \"hostname \", 9) == 0) {\n\t\tcfg.hostname = ptr + 9;\n\t\treturn 0;\n\t}\n\t\n\t// dns\n\tif (strncmp(ptr, \"dns \", 4) == 0) {\n\t\tuint32_t dns;\n\t\tif (atoip(ptr + 4, &dns)) {\n\t\t\tfprintf(stderr, \"Error: invalid DNS server IP address\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\t\n\t\tif (cfg.dns1 == 0)\n\t\t\tcfg.dns1 = dns;\n\t\telse if (cfg.dns2 == 0)\n\t\t\tcfg.dns2 = dns;\n\t\telse if (cfg.dns3 == 0)\n\t\t\tcfg.dns3 = dns;\n\t\telse {\n\t\t\tfprintf(stderr, \"Error: up to 3 DNS servers can be specified\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\t// cpu affinity\n\tif (strncmp(ptr, \"cpu \", 4) == 0) {\n\t\tread_cpu_list(ptr + 4);\n\t\treturn 0;\n\t}\n\t\n\t// nice value\n\tif (strncmp(ptr, \"nice \", 4) == 0) {\n\t\tcfg.nice = atoi(ptr + 5);\n\t\tif (getuid() != 0 &&cfg.nice < 0)\n\t\t\tcfg.nice = 0;\n\t\targ_nice = 1;\n\t\treturn 0;\n\t}\n\n\t// cgroup\n\tif (strncmp(ptr, \"cgroup \", 7) == 0) {\n\t\tset_cgroup(ptr + 7);\n\t\treturn 0;\n\t}\n\t\n\t// writable-etc\n\tif (strcmp(ptr, \"writable-etc\") == 0) {\n\t\tif (cfg.etc_private_keep) {\n\t\t\tfprintf(stderr, \"Error: private-etc and writable-etc are mutually exclusive\\n\");\n\t\t\texit(1);\n\t\t}\n\t\targ_writable_etc = 1;\n\t\treturn 0;\n\t}\n\t\n\t// writable-var\n\tif (strcmp(ptr, \"writable-var\") == 0) {\n\t\targ_writable_var = 1;\n\t\treturn 0;\n\t}\n\t\n\t// private directory\n\tif (strncmp(ptr, \"private \", 8) == 0) {\n\t\tcfg.home_private = ptr + 8;\n\t\tfs_check_private_dir();\n\t\targ_private = 1;\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 none\") == 0) {\n\t\targ_x11_block = 1;\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 xephyr\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\tchar *x11env = getenv(\"FIREJAIL_X11\");\n\t\t\tif (x11env && strcmp(x11env, \"yes\") == 0) {\n\t\t\t\tmask_x11_abstract_socket = 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// start x11\n\t\t\t\tx11_start_xephyr(cfg.original_argc, cfg.original_argv);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 xorg\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11))\n\t\t\targ_x11_xorg = 1;\n\t\telse {\n\t\t\tfprintf(stderr, \"Error: --x11 feature is disabled in Firejail configuration file\\n\");\n\t\t\treturn 0;\n\t\t}\n#endif\n\t\treturn 0;\n\t}\n\tif (strcmp(ptr, \"x11 xpra\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\tchar *x11env = getenv(\"FIREJAIL_X11\");\n\t\t\tif (x11env && strcmp(x11env, \"yes\") == 0) {\n\t\t\t\tmask_x11_abstract_socket = 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// start x11\n\t\t\t\tx11_start_xpra(cfg.original_argc, cfg.original_argv);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n#endif\n\t\treturn 0;\n\t}\n\t\n\tif (strcmp(ptr, \"x11\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\tchar *x11env = getenv(\"FIREJAIL_X11\");\n\t\t\tif (x11env && strcmp(x11env, \"yes\") == 0) {\n\t\t\t\tmask_x11_abstract_socket = 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// start x11\n\t\t\t\tx11_start(cfg.original_argc, cfg.original_argv);\n\t\t\t\texit(0);\t\t\n\t\t\t}\n\t\t}\n#endif\t\t\n\t\treturn 0;\n\t}\n\t\n\t// private /etc list of files and directories\n\tif (strncmp(ptr, \"private-etc \", 12) == 0) {\n\t\tif (arg_writable_etc) {\n\t\t\tfprintf(stderr, \"Error: --private-etc and --writable-etc are mutually exclusive\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tcfg.etc_private_keep = ptr + 12;\n\t\tfs_check_etc_list();\n\t\targ_private_etc = 1;\n\t\t\n\t\treturn 0;\n\t}\n\n\t// private /bin list of files\n\tif (strncmp(ptr, \"private-bin \", 12) == 0) {\n\t\tcfg.bin_private_keep = ptr + 12;\n\t\targ_private_bin = 1;\n\t\tfs_check_bin_list();\n\t\treturn 0;\n\t}\n\n\t// filesystem bind\n\tif (strncmp(ptr, \"bind \", 5) == 0) {\n#ifdef HAVE_BIND\t\t\n\t\tif (checkcfg(CFG_BIND)) {\n\t\t\tif (getuid() != 0) {\n\t\t\t\tfprintf(stderr, \"Error: --bind option is available only if running as root\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\n\t\t\t// extract two directories\n\t\t\tchar *dname1 = ptr + 5;\n\t\t\tchar *dname2 = split_comma(dname1); // this inserts a '0 to separate the two dierctories\n\t\t\tif (dname2 == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: missing second directory for bind\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t\n\t\t\t// check directories\n\t\t\tinvalid_filename(dname1);\n\t\t\tinvalid_filename(dname2);\n\t\t\tif (strstr(dname1, \"..\") || strstr(dname2, \"..\")) {\n\t\t\t\tfprintf(stderr, \"Error: invalid file name.\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (is_link(dname1) || is_link(dname2)) {\n\t\t\t\tfprintf(stderr, \"Symbolic links are not allowed for bind command\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t\n\t\t\t// insert comma back\n\t\t\t*(dname2 - 1) = ',';\n\t\t\treturn 1;\n\t\t}\n\t\telse if (!arg_quiet) {\n\t\t\tfprintf(stderr, \"Warning: bind feature is disabled in Firejail configuration file\\n\");\n\t\t\treturn 0;\t\t\t\n\t\t}\n#else\n\t\treturn 0;\n#endif\t\t\n\t}\n\n\t// rlimit\n\tif (strncmp(ptr, \"rlimit\", 6) == 0) {\n\t\tif (strncmp(ptr, \"rlimit-nofile \", 14) == 0) {\n\t\t\tptr += 14;\n\t\t\tif (not_unsigned(ptr)) {\n\t\t\t\tfprintf(stderr, \"Invalid rlimit option on line %d\\n\", lineno);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tsscanf(ptr, \"%u\", &cfg.rlimit_nofile);\n\t\t\targ_rlimit_nofile = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-nproc \", 13) == 0) {\n\t\t\tptr += 13;\n\t\t\tif (not_unsigned(ptr)) {\n\t\t\t\tfprintf(stderr, \"Invalid rlimit option on line %d\\n\", lineno);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tsscanf(ptr, \"%u\", &cfg.rlimit_nproc);\n\t\t\targ_rlimit_nproc = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-fsize \", 13) == 0) {\n\t\t\tptr += 13;\n\t\t\tif (not_unsigned(ptr)) {\n\t\t\t\tfprintf(stderr, \"Invalid rlimit option on line %d\\n\", lineno);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tsscanf(ptr, \"%u\", &cfg.rlimit_fsize);\n\t\t\targ_rlimit_fsize = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-sigpending \", 18) == 0) {\n\t\t\tptr += 18;\n\t\t\tif (not_unsigned(ptr)) {\n\t\t\t\tfprintf(stderr, \"Invalid rlimit option on line %d\\n\", lineno);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tsscanf(ptr, \"%u\", &cfg.rlimit_sigpending);\n\t\t\targ_rlimit_sigpending = 1;\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"Invalid rlimit option on line %d\\n\", lineno);\n\t\t\texit(1);\n\t\t}\n\t\t\n\t\treturn 0;\t\t\n\t}\n\n\tif (strncmp(ptr, \"join-or-start \", 14) == 0) {\n\t\t// try to join by name only\n\t\tpid_t pid;\n\t\tif (!name2pid(ptr + 14, &pid)) {\n\t\t\tif (!cfg.shell && !arg_shell_none)\n\t\t\t\tcfg.shell = guess_shell();\n\n\t\t\t// find first non-option arg\n\t\t\tint i;\n\t\t\tfor (i = 1; i < cfg.original_argc && strncmp(cfg.original_argv[i], \"--\", 2) != 0; i++);\n\n\t\t\tjoin(pid, cfg.original_argc,cfg.original_argv, i + 1);\n\t\t\texit(0);\n\t\t}\n\n\t\t// set sandbox name and start normally\n\t\tcfg.name = ptr + 14;\n\t\tif (strlen(cfg.name) == 0) {\n\t\t\tfprintf(stderr, \"Error: invalid sandbox name\\n\");\n\t\t\texit(1);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t// rest of filesystem\n\tif (strncmp(ptr, \"blacklist \", 10) == 0)\n\t\tptr += 10;\n\telse if (strncmp(ptr, \"blacklist-nolog \", 16) == 0)\n\t\tptr += 16;\n\telse if (strncmp(ptr, \"noblacklist \", 12) == 0)\n\t\tptr += 12;\n\telse if (strncmp(ptr, \"whitelist \", 10) == 0) {\n#ifdef HAVE_WHITELIST\t\t\n\t\tif (checkcfg(CFG_WHITELIST)) {\n\t\t\targ_whitelist = 1;\n\t\t\tptr += 10;\n\t\t}\n\t\telse\n\t\t\treturn 0;\n#else\t\t\n\t\treturn 0;\n#endif\n\t}\n\telse if (strncmp(ptr, \"read-only \", 10) == 0)\n\t\tptr += 10;\n\telse if (strncmp(ptr, \"read-write \", 11) == 0)\n\t\tptr += 11;\n\telse if (strncmp(ptr, \"noexec \", 7) == 0)\n\t\tptr += 7;\n\telse if (strncmp(ptr, \"tmpfs \", 6) == 0) {\n\t\tif (getuid() != 0) {\n\t\t\tfprintf(stderr, \"Error: tmpfs available only when running the sandbox as root\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tptr += 6;\n\t}\n\telse {\n\t\tif (lineno == 0)\n\t\t\tfprintf(stderr, \"Error: \\\"%s\\\" as a command line option is invalid\\n\", ptr);\n\t\telse if (fname != NULL)\n\t\t\tfprintf(stderr, \"Error: line %d in %s is invalid\\n\", lineno, fname);\n\t\telse\n\t\t\tfprintf(stderr, \"Error: line %d in the custom profile is invalid\\n\", lineno);\n\t\texit(1);\n\t}\n\n\t// some characters just don't belong in filenames\n\tinvalid_filename(ptr);\n\tif (strstr(ptr, \"..\")) {\n\t\tif (lineno == 0)\n\t\t\tfprintf(stderr, \"Error: \\\"%s\\\" is an invalid filename\\n\", ptr);\n\t\telse if (fname != NULL)\n\t\t\tfprintf(stderr, \"Error: line %d in %s is invalid\\n\", lineno, fname);\n\t\telse\n\t\t\tfprintf(stderr, \"Error: line %d in the custom profile is invalid\\n\", lineno);\n\t\texit(1);\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <dirent.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <dirent.h>\n#include \"firejail.h\"\n\nint profile_check_line(char *ptr, int lineno, const char *fname) {\n\tEUID_ASSERT();\n\t\n\t// check ignore list\n\tint i;\n\tfor (i = 0; i < MAX_PROFILE_IGNORE; i++) {\n\t\tif (cfg.profile_ignore[i] == NULL)\n\t\t\tbreak;\n\t\t\n\t\tif (strncmp(ptr, cfg.profile_ignore[i], strlen(cfg.profile_ignore[i])) == 0)\n\t\t\treturn 0;\t// ignore line\n\t}\n\t\n\tif (strncmp(ptr, \"ignore \", 7) == 0) {\n\t\tchar *str = strdup(ptr + 7);\n\t\tif (*str == '\\0') {\n\t\t\tfprintf(stderr, \"Error: invalid ignore option\\n\");\n\t\t\texit(1);\n\t\t}\n\t\t// find an empty entry in profile_ignore array\n\t\tint j;\n\t\tfor (j = 0; j < MAX_PROFILE_IGNORE; j++) {\n\t\t\tif (cfg.profile_ignore[j] == NULL) \n\t\t\t\tbreak;\n\t\t}\n\t\tif (j >= MAX_PROFILE_IGNORE) {\n\t\t\tfprintf(stderr, \"Error: maximum %d --ignore options are permitted\\n\", MAX_PROFILE_IGNORE);\n\t\t\texit(1);\n\t\t}\n\t\t// ... and configure it\n\t\telse \n\t\t\tcfg.profile_ignore[j] = str;\n\n\t\treturn 0;\n\t}\n\n\t// mkdir \n\tif (strncmp(ptr, \"mkdir \", 6) == 0) {\n\t\tfs_mkdir(ptr + 6);\n\t\treturn 1;\n\t}\n\t// mkfile \n\tif (strncmp(ptr, \"mkfile \", 7) == 0) {\n\t\tfs_mkfile(ptr + 7);\n\t\treturn 1;\n\t}\n\t// sandbox name\n\telse if (strncmp(ptr, \"name \", 5) == 0) {\n\t\tcfg.name = ptr + 5;\n\t\tif (strlen(cfg.name) == 0) {\n\t\t\tfprintf(stderr, \"Error: invalid sandbox name\\n\");\n\t\t\texit(1);\n\t\t}\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"ipc-namespace\") == 0) {\n\t\targ_ipc = 1;\n\t\treturn 0;\n\t}\n\t// seccomp, caps, private, user namespace\n\telse if (strcmp(ptr, \"noroot\") == 0) {\n#if HAVE_USERNS\n\t\tif (checkcfg(CFG_USERNS))\n\t\t\tcheck_user_namespace();\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: user namespace feature is disabled in Firejail configuration file\\n\");\n#endif\n\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nonewprivs\") == 0) {\n\t\targ_nonewprivs = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"seccomp\") == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP))\n\t\t\targ_seccomp = 1;\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: user seccomp feature is disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"caps\") == 0) {\n\t\targ_caps_default_filter = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"caps.drop all\") == 0) {\n\t\targ_caps_drop_all = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"shell none\") == 0) {\n\t\targ_shell_none = 1;\n\t\treturn 0;\n\t}\t\n\telse if (strcmp(ptr, \"tracelog\") == 0) {\n\t\targ_tracelog = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"private\") == 0) {\n\t\targ_private = 1;\n\t\treturn 0;\n\t}\n\tif (strncmp(ptr, \"private-home \", 13) == 0) {\n#ifdef HAVE_PRIVATE_HOME\n\t\tif (checkcfg(CFG_PRIVATE_HOME)) {\n\t\t\tcfg.home_private_keep = ptr + 13;\n\t\t\tfs_check_home_list();\n\t\t\targ_private = 1;\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: private-home is disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"allusers\") == 0) {\n\t\targ_allusers = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"private-dev\") == 0) {\n\t\targ_private_dev = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"private-tmp\") == 0) {\n\t\targ_private_tmp = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nogroups\") == 0) {\n\t\targ_nogroups = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nosound\") == 0) {\n\t\targ_nosound = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"no3d\") == 0) {\n\t\targ_no3d = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"netfilter\") == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK))\n\t\t\targ_netfilter = 1;\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strncmp(ptr, \"netfilter \", 10) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\targ_netfilter = 1;\n\t\t\targ_netfilter_file = strdup(ptr + 10);\n\t\t\tif (!arg_netfilter_file)\n\t\t\t\terrExit(\"strdup\");\n\t\t\tcheck_netfilter_file(arg_netfilter_file);\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strncmp(ptr, \"netfilter6 \", 11) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\targ_netfilter6 = 1;\n\t\t\targ_netfilter6_file = strdup(ptr + 11);\n\t\t\tif (!arg_netfilter6_file)\n\t\t\t\terrExit(\"strdup\");\n\t\t\tcheck_netfilter_file(arg_netfilter6_file);\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"net none\") == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\targ_nonetwork  = 1;\n\t\t\tcfg.bridge0.configured = 0;\n\t\t\tcfg.bridge1.configured = 0;\n\t\t\tcfg.bridge2.configured = 0;\n\t\t\tcfg.bridge3.configured = 0;\n\t\t\tcfg.interface0.configured = 0;\n\t\t\tcfg.interface1.configured = 0;\n\t\t\tcfg.interface2.configured = 0;\n\t\t\tcfg.interface3.configured = 0;\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strncmp(ptr, \"net \", 4) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n#ifdef HAVE_NETWORK_RESTRICTED\n\t\t\t// compile time restricted networking\n\t\t\tif (getuid() != 0) {\n\t\t\t\tfprintf(stderr, \"Error: only \\\"net none\\\" is allowed to non-root users\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n#endif\n\t\t\t// run time restricted networking\n\t\t\tif (checkcfg(CFG_RESTRICTED_NETWORK) && getuid() != 0) {\n\t\t\t\tfprintf(stderr, \"Error: only \\\"net none\\\" is allowed to non-root users\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t\n\t\t\tif (strcmp(ptr + 4, \"lo\") == 0) {\n\t\t\t\tfprintf(stderr, \"Error: cannot attach to lo device\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tBridge *br;\n\t\t\tif (cfg.bridge0.configured == 0)\n\t\t\t\tbr = &cfg.bridge0;\n\t\t\telse if (cfg.bridge1.configured == 0)\n\t\t\t\tbr = &cfg.bridge1;\n\t\t\telse if (cfg.bridge2.configured == 0)\n\t\t\t\tbr = &cfg.bridge2;\n\t\t\telse if (cfg.bridge3.configured == 0)\n\t\t\t\tbr = &cfg.bridge3;\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"Error: maximum 4 network devices are allowed\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tnet_configure_bridge(br, ptr + 4);\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\t\n\telse if (strncmp(ptr, \"veth-name \", 10) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tbr->veth_name = strdup(ptr + 10);\n\t\t\tif (br->veth_name == NULL)\n\t\t\t\terrExit(\"strdup\");\n\t\t\tif (*br->veth_name == '\\0') {\n\t\t\t\tfprintf(stderr, \"Error: no veth-name configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"iprange \", 8) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (br->iprange_start || br->iprange_end) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the IP range twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// parse option arguments\n\t\t\tchar *firstip = ptr + 8;\n\t\t\tchar *secondip = firstip;\n\t\t\twhile (*secondip != '\\0') {\n\t\t\t\tif (*secondip == ',')\n\t\t\t\t\tbreak;\n\t\t\t\tsecondip++;\n\t\t\t}\n\t\t\tif (*secondip == '\\0') {\n\t\t\t\tfprintf(stderr, \"Error: invalid IP range\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t*secondip = '\\0';\n\t\t\tsecondip++;\n\t\t\t\n\t\t\t// check addresses\n\t\t\tif (atoip(firstip, &br->iprange_start) || atoip(secondip, &br->iprange_end) ||\n\t\t\t    br->iprange_start >= br->iprange_end) {\n\t\t\t\tfprintf(stderr, \"Error: invalid IP range\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (in_netrange(br->iprange_start, br->ip, br->mask) || in_netrange(br->iprange_end, br->ip, br->mask)) {\n\t\t\t\tfprintf(stderr, \"Error: IP range addresses not in network range\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\n\n\telse if (strncmp(ptr, \"mac \", 4) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t\n\t\t\tif (mac_not_zero(br->macsandbox)) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the MAC address twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// read the address\n\t\t\tif (atomac(ptr + 4, br->macsandbox)) {\n\t\t\t\tfprintf(stderr, \"Error: invalid MAC address\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"mtu \", 4) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t\n\t\t\tif (sscanf(ptr + 4, \"%d\", &br->mtu) != 1 || br->mtu < 576 || br->mtu > 9198) {\n\t\t\t\tfprintf(stderr, \"Error: invalid mtu value\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"ip \", 3) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (br->arg_ip_none || br->ipsandbox) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the IP address twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// configure this IP address for the last bridge defined\n\t\t\tif (strcmp(ptr + 3, \"none\") == 0)\n\t\t\t\tbr->arg_ip_none = 1;\n\t\t\telse {\n\t\t\t\tif (atoip(ptr + 3, &br->ipsandbox)) {\n\t\t\t\t\tfprintf(stderr, \"Error: invalid IP address\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"ip6 \", 4) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (br->arg_ip_none || br->ip6sandbox) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the IP address twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// configure this IP address for the last bridge defined\n\t\t\t// todo: verify ipv6 syntax\n\t\t\tbr->ip6sandbox = ptr + 4;\n//\t\t\tif (atoip(argv[i] + 5, &br->ipsandbox)) {\n//\t\t\t\tfprintf(stderr, \"Error: invalid IP address\\n\");\n//\t\t\t\texit(1);\n//\t\t\t}\n\t\t\t\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"defaultgw \", 10) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tif (atoip(ptr + 10, &cfg.defaultgw)) {\n\t\t\t\tfprintf(stderr, \"Error: invalid IP address\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"apparmor\") == 0) {\n#ifdef HAVE_APPARMOR\t\t\n\t\targ_apparmor = 1;\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strncmp(ptr, \"protocol \", 9) == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP))\n\t\t\tprotocol_store(ptr + 9);\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: user seccomp feature is disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\t\n\tif (strncmp(ptr, \"env \", 4) == 0) {\n\t\tenv_store(ptr + 4, SETENV);\n\t\treturn 0;\n\t}\n\tif (strncmp(ptr, \"rmenv \", 6) == 0) {\n\t\tenv_store(ptr + 6, RMENV);\n\t\treturn 0;\n\t}\n\t\n\t// seccomp drop list on top of default list\n\tif (strncmp(ptr, \"seccomp \", 8) == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\targ_seccomp = 1;\n\t\t\tcfg.seccomp_list = strdup(ptr + 8);\n\t\t\tif (!cfg.seccomp_list)\n\t\t\t\terrExit(\"strdup\");\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: user seccomp feature is disabled in Firejail configuration file\\n\");\n#endif\n\n\t\treturn 0;\n\t}\n\t\n\t// seccomp drop list without default list\n\tif (strncmp(ptr, \"seccomp.drop \", 13) == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\targ_seccomp = 1;\n\t\t\tcfg.seccomp_list_drop = strdup(ptr + 13);\n\t\t\tif (!cfg.seccomp_list_drop)\n\t\t\t\terrExit(\"strdup\");\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: user seccomp feature is disabled in Firejail configuration file\\n\");\n#endif\t\t\n\t\treturn 0;\n\t}\n\n\t// seccomp keep list\n\tif (strncmp(ptr, \"seccomp.keep \", 13) == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\targ_seccomp = 1;\n\t\t\tcfg.seccomp_list_keep= strdup(ptr + 13);\n\t\t\tif (!cfg.seccomp_list_keep)\n\t\t\t\terrExit(\"strdup\");\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: user seccomp feature is disabled in Firejail configuration file\\n\");\n#endif\t\t\n\t\treturn 0;\n\t}\n\t\n\t// caps drop list\n\tif (strncmp(ptr, \"caps.drop \", 10) == 0) {\n\t\targ_caps_drop = 1;\n\t\targ_caps_list = strdup(ptr + 10);\n\t\tif (!arg_caps_list)\n\t\t\terrExit(\"strdup\");\n\t\t// verify seccomp list and exit if problems\n\t\tif (caps_check_list(arg_caps_list, NULL))\n\t\t\texit(1);\n\t\treturn 0;\n\t}\n\t\n\t// caps keep list\n\tif (strncmp(ptr, \"caps.keep \", 10) == 0) {\n\t\targ_caps_keep = 1;\n\t\targ_caps_list = strdup(ptr + 10);\n\t\tif (!arg_caps_list)\n\t\t\terrExit(\"strdup\");\n\t\t// verify seccomp list and exit if problems\n\t\tif (caps_check_list(arg_caps_list, NULL))\n\t\t\texit(1);\n\t\treturn 0;\n\t}\n\n\t// hostname\n\tif (strncmp(ptr, \"hostname \", 9) == 0) {\n\t\tcfg.hostname = ptr + 9;\n\t\treturn 0;\n\t}\n\t\n\t// dns\n\tif (strncmp(ptr, \"dns \", 4) == 0) {\n\t\tuint32_t dns;\n\t\tif (atoip(ptr + 4, &dns)) {\n\t\t\tfprintf(stderr, \"Error: invalid DNS server IP address\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\t\n\t\tif (cfg.dns1 == 0)\n\t\t\tcfg.dns1 = dns;\n\t\telse if (cfg.dns2 == 0)\n\t\t\tcfg.dns2 = dns;\n\t\telse if (cfg.dns3 == 0)\n\t\t\tcfg.dns3 = dns;\n\t\telse {\n\t\t\tfprintf(stderr, \"Error: up to 3 DNS servers can be specified\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\t// cpu affinity\n\tif (strncmp(ptr, \"cpu \", 4) == 0) {\n\t\tread_cpu_list(ptr + 4);\n\t\treturn 0;\n\t}\n\t\n\t// nice value\n\tif (strncmp(ptr, \"nice \", 4) == 0) {\n\t\tcfg.nice = atoi(ptr + 5);\n\t\tif (getuid() != 0 &&cfg.nice < 0)\n\t\t\tcfg.nice = 0;\n\t\targ_nice = 1;\n\t\treturn 0;\n\t}\n\n\t// cgroup\n\tif (strncmp(ptr, \"cgroup \", 7) == 0) {\n\t\tset_cgroup(ptr + 7);\n\t\treturn 0;\n\t}\n\t\n\t// writable-etc\n\tif (strcmp(ptr, \"writable-etc\") == 0) {\n\t\tif (cfg.etc_private_keep) {\n\t\t\tfprintf(stderr, \"Error: private-etc and writable-etc are mutually exclusive\\n\");\n\t\t\texit(1);\n\t\t}\n\t\targ_writable_etc = 1;\n\t\treturn 0;\n\t}\n\t\n\t// writable-var\n\tif (strcmp(ptr, \"writable-var\") == 0) {\n\t\targ_writable_var = 1;\n\t\treturn 0;\n\t}\n\t\n\t// private directory\n\tif (strncmp(ptr, \"private \", 8) == 0) {\n\t\tcfg.home_private = ptr + 8;\n\t\tfs_check_private_dir();\n\t\targ_private = 1;\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 none\") == 0) {\n\t\targ_x11_block = 1;\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 xephyr\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\tchar *x11env = getenv(\"FIREJAIL_X11\");\n\t\t\tif (x11env && strcmp(x11env, \"yes\") == 0) {\n\t\t\t\tmask_x11_abstract_socket = 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// start x11\n\t\t\t\tx11_start_xephyr(cfg.original_argc, cfg.original_argv);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 xorg\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11))\n\t\t\targ_x11_xorg = 1;\n\t\telse {\n\t\t\tfprintf(stderr, \"Error: --x11 feature is disabled in Firejail configuration file\\n\");\n\t\t\treturn 0;\n\t\t}\n#endif\n\t\treturn 0;\n\t}\n\tif (strcmp(ptr, \"x11 xpra\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\tchar *x11env = getenv(\"FIREJAIL_X11\");\n\t\t\tif (x11env && strcmp(x11env, \"yes\") == 0) {\n\t\t\t\tmask_x11_abstract_socket = 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// start x11\n\t\t\t\tx11_start_xpra(cfg.original_argc, cfg.original_argv);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n#endif\n\t\treturn 0;\n\t}\n\t\n\tif (strcmp(ptr, \"x11\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\tchar *x11env = getenv(\"FIREJAIL_X11\");\n\t\t\tif (x11env && strcmp(x11env, \"yes\") == 0) {\n\t\t\t\tmask_x11_abstract_socket = 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// start x11\n\t\t\t\tx11_start(cfg.original_argc, cfg.original_argv);\n\t\t\t\texit(0);\t\t\n\t\t\t}\n\t\t}\n#endif\t\t\n\t\treturn 0;\n\t}\n\t\n\t// private /etc list of files and directories\n\tif (strncmp(ptr, \"private-etc \", 12) == 0) {\n\t\tif (arg_writable_etc) {\n\t\t\tfprintf(stderr, \"Error: --private-etc and --writable-etc are mutually exclusive\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tcfg.etc_private_keep = ptr + 12;\n\t\tfs_check_etc_list();\n\t\targ_private_etc = 1;\n\t\t\n\t\treturn 0;\n\t}\n\n\t// private /bin list of files\n\tif (strncmp(ptr, \"private-bin \", 12) == 0) {\n\t\tcfg.bin_private_keep = ptr + 12;\n\t\targ_private_bin = 1;\n\t\tfs_check_bin_list();\n\t\treturn 0;\n\t}\n\n\t// filesystem bind\n\tif (strncmp(ptr, \"bind \", 5) == 0) {\n#ifdef HAVE_BIND\t\t\n\t\tif (checkcfg(CFG_BIND)) {\n\t\t\tif (getuid() != 0) {\n\t\t\t\tfprintf(stderr, \"Error: --bind option is available only if running as root\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\n\t\t\t// extract two directories\n\t\t\tchar *dname1 = ptr + 5;\n\t\t\tchar *dname2 = split_comma(dname1); // this inserts a '0 to separate the two dierctories\n\t\t\tif (dname2 == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: missing second directory for bind\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t\n\t\t\t// check directories\n\t\t\tinvalid_filename(dname1);\n\t\t\tinvalid_filename(dname2);\n\t\t\tif (strstr(dname1, \"..\") || strstr(dname2, \"..\")) {\n\t\t\t\tfprintf(stderr, \"Error: invalid file name.\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (is_link(dname1) || is_link(dname2)) {\n\t\t\t\tfprintf(stderr, \"Symbolic links are not allowed for bind command\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t\n\t\t\t// insert comma back\n\t\t\t*(dname2 - 1) = ',';\n\t\t\treturn 1;\n\t\t}\n\t\telse if (!arg_quiet) {\n\t\t\tfprintf(stderr, \"Warning: bind feature is disabled in Firejail configuration file\\n\");\n\t\t\treturn 0;\t\t\t\n\t\t}\n#else\n\t\treturn 0;\n#endif\t\t\n\t}\n\n\t// rlimit\n\tif (strncmp(ptr, \"rlimit\", 6) == 0) {\n\t\tif (strncmp(ptr, \"rlimit-nofile \", 14) == 0) {\n\t\t\tptr += 14;\n\t\t\tif (not_unsigned(ptr)) {\n\t\t\t\tfprintf(stderr, \"Invalid rlimit option on line %d\\n\", lineno);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tsscanf(ptr, \"%u\", &cfg.rlimit_nofile);\n\t\t\targ_rlimit_nofile = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-nproc \", 13) == 0) {\n\t\t\tptr += 13;\n\t\t\tif (not_unsigned(ptr)) {\n\t\t\t\tfprintf(stderr, \"Invalid rlimit option on line %d\\n\", lineno);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tsscanf(ptr, \"%u\", &cfg.rlimit_nproc);\n\t\t\targ_rlimit_nproc = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-fsize \", 13) == 0) {\n\t\t\tptr += 13;\n\t\t\tif (not_unsigned(ptr)) {\n\t\t\t\tfprintf(stderr, \"Invalid rlimit option on line %d\\n\", lineno);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tsscanf(ptr, \"%u\", &cfg.rlimit_fsize);\n\t\t\targ_rlimit_fsize = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-sigpending \", 18) == 0) {\n\t\t\tptr += 18;\n\t\t\tif (not_unsigned(ptr)) {\n\t\t\t\tfprintf(stderr, \"Invalid rlimit option on line %d\\n\", lineno);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tsscanf(ptr, \"%u\", &cfg.rlimit_sigpending);\n\t\t\targ_rlimit_sigpending = 1;\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"Invalid rlimit option on line %d\\n\", lineno);\n\t\t\texit(1);\n\t\t}\n\t\t\n\t\treturn 0;\t\t\n\t}\n\n\tif (strncmp(ptr, \"join-or-start \", 14) == 0) {\n\t\t// try to join by name only\n\t\tpid_t pid;\n\t\tif (!name2pid(ptr + 14, &pid)) {\n\t\t\tif (!cfg.shell && !arg_shell_none)\n\t\t\t\tcfg.shell = guess_shell();\n\n\t\t\t// find first non-option arg\n\t\t\tint i;\n\t\t\tfor (i = 1; i < cfg.original_argc && strncmp(cfg.original_argv[i], \"--\", 2) != 0; i++);\n\n\t\t\tjoin(pid, cfg.original_argc,cfg.original_argv, i + 1);\n\t\t\texit(0);\n\t\t}\n\n\t\t// set sandbox name and start normally\n\t\tcfg.name = ptr + 14;\n\t\tif (strlen(cfg.name) == 0) {\n\t\t\tfprintf(stderr, \"Error: invalid sandbox name\\n\");\n\t\t\texit(1);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t// rest of filesystem\n\tif (strncmp(ptr, \"blacklist \", 10) == 0)\n\t\tptr += 10;\n\telse if (strncmp(ptr, \"blacklist-nolog \", 16) == 0)\n\t\tptr += 16;\n\telse if (strncmp(ptr, \"noblacklist \", 12) == 0)\n\t\tptr += 12;\n\telse if (strncmp(ptr, \"whitelist \", 10) == 0) {\n#ifdef HAVE_WHITELIST\t\t\n\t\tif (checkcfg(CFG_WHITELIST)) {\n\t\t\targ_whitelist = 1;\n\t\t\tptr += 10;\n\t\t}\n\t\telse\n\t\t\treturn 0;\n#else\t\t\n\t\treturn 0;\n#endif\n\t}\n\telse if (strncmp(ptr, \"read-only \", 10) == 0)\n\t\tptr += 10;\n\telse if (strncmp(ptr, \"read-write \", 11) == 0)\n\t\tptr += 11;\n\telse if (strncmp(ptr, \"noexec \", 7) == 0)\n\t\tptr += 7;\n\telse if (strncmp(ptr, \"tmpfs \", 6) == 0) {\n\t\tif (getuid() != 0) {\n\t\t\tfprintf(stderr, \"Error: tmpfs available only when running the sandbox as root\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tptr += 6;\n\t}\n\telse {\n\t\tif (lineno == 0)\n\t\t\tfprintf(stderr, \"Error: \\\"%s\\\" as a command line option is invalid\\n\", ptr);\n\t\telse if (fname != NULL)\n\t\t\tfprintf(stderr, \"Error: line %d in %s is invalid\\n\", lineno, fname);\n\t\telse\n\t\t\tfprintf(stderr, \"Error: line %d in the custom profile is invalid\\n\", lineno);\n\t\texit(1);\n\t}\n\n\t// some characters just don't belong in filenames\n\tinvalid_filename(ptr);\n\tif (strstr(ptr, \"..\")) {\n\t\tif (lineno == 0)\n\t\t\tfprintf(stderr, \"Error: \\\"%s\\\" is an invalid filename\\n\", ptr);\n\t\telse if (fname != NULL)\n\t\t\tfprintf(stderr, \"Error: line %d in %s is invalid\\n\", lineno, fname);\n\t\telse\n\t\t\tfprintf(stderr, \"Error: line %d in the custom profile is invalid\\n\", lineno);\n\t\texit(1);\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&line",
            "\"blacklist %s\"",
            "xauthority"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"XAUTHORITY\""
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"blacklist ${HOME}/.Xauthority\""
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"blacklist /tmp/.X11-unix\""
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "myexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/main.c",
          "lines": "137-149",
          "snippet": "static void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}",
          "includes": [
            "#include <sys/times.h>",
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int arg_command = 0;",
            "int arg_quiet = 0;",
            "pid_t sandbox_pid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/times.h>\n#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nint arg_command = 0;\nint arg_quiet = 0;\npid_t sandbox_pid;\n\nstatic void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"ERROR: --x11=none specified, but abstract X11 socket still accessible.\\n\"\n\t\t\t\t\t\t\"Additional setup required. To block abstract X11 socket you can either:\\n\"\n\t\t\t\t\t\t\" * use network namespace in firejail (--net=none, --net=...)\\n\"\n\t\t\t\t\t\t\" * add \\\"-nolisten local\\\" to xserver options\\n\"\n\t\t\t\t\t\t\"   (eg. to your display manager config, or /etc/X11/xinit/xserverrc)\\n\""
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x11_abstract_sockets_present",
          "args": [],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "x11_abstract_sockets_present",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/x11.c",
          "lines": "56-78",
          "snippet": "static int x11_abstract_sockets_present(void) {\n\tchar *path;\n\n\tEUID_ROOT(); // grsecurity fix\n\tFILE *fp = fopen(\"/proc/net/unix\", \"r\");\n\tEUID_USER();\n\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\n\twhile (fscanf(fp, \"%*s %*s %*s %*s %*s %*s %*s %ms\\n\", &path) != EOF) {\n\t\tif (path && strncmp(path, \"@/tmp/.X11-unix/\", 16) == 0) {\n\t\t\tfree(path);\n\t\t\tfclose(fp);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tfree(path);\n\tfclose(fp);\n\n\treturn 0;\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <sys/mount.h>\n#include <dirent.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nstatic int x11_abstract_sockets_present(void) {\n\tchar *path;\n\n\tEUID_ROOT(); // grsecurity fix\n\tFILE *fp = fopen(\"/proc/net/unix\", \"r\");\n\tEUID_USER();\n\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\n\twhile (fscanf(fp, \"%*s %*s %*s %*s %*s %*s %*s %ms\\n\", &path) != EOF) {\n\t\tif (path && strncmp(path, \"@/tmp/.X11-unix/\", 16) == 0) {\n\t\t\tfree(path);\n\t\t\tfclose(fp);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tfree(path);\n\tfclose(fp);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/wait.h>\n#include <sys/mount.h>\n#include <dirent.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nint mask_x11_abstract_socket = 0;\n\nvoid x11_block(void) {\n#ifdef HAVE_X11\n\tmask_x11_abstract_socket = 1;\n\n\t// check abstract socket presence and network namespace options\n\tif ((!arg_nonetwork && !cfg.bridge0.configured && !cfg.interface0.configured)\n\t\t&& x11_abstract_sockets_present()) {\n\t\tfprintf(stderr, \"ERROR: --x11=none specified, but abstract X11 socket still accessible.\\n\"\n\t\t\t\t\t\t\"Additional setup required. To block abstract X11 socket you can either:\\n\"\n\t\t\t\t\t\t\" * use network namespace in firejail (--net=none, --net=...)\\n\"\n\t\t\t\t\t\t\" * add \\\"-nolisten local\\\" to xserver options\\n\"\n\t\t\t\t\t\t\"   (eg. to your display manager config, or /etc/X11/xinit/xserverrc)\\n\");\n\t\texit(1);\n\t}\n\n\t// blacklist sockets\n\tprofile_check_line(\"blacklist /tmp/.X11-unix\", 0, NULL);\n\tprofile_add(strdup(\"blacklist /tmp/.X11-unix\"));\n\n\t// blacklist .Xauthority\n\tprofile_check_line(\"blacklist ${HOME}/.Xauthority\", 0, NULL);\n\tprofile_add(strdup(\"blacklist ${HOME}/.Xauthority\"));\n\tchar *xauthority = getenv(\"XAUTHORITY\");\n\tif (xauthority) {\n\t\tchar *line;\n\t\tif (asprintf(&line, \"blacklist %s\", xauthority) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tprofile_check_line(line, 0, NULL);\n\t\tprofile_add(line);\n\t}\n\n\t// clear environment\n\tenv_store(\"DISPLAY\", RMENV);\n\tenv_store(\"XAUTHORITY\", RMENV);\n#endif\n}"
  },
  {
    "function_name": "x11_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/x11.c",
    "lines": "584-604",
    "snippet": "void x11_start(int argc, char **argv) {\n\tEUID_ASSERT();\n\n\t// unfortunately, xpra does a number of weird things when started by root user!!!\n\tif (getuid() == 0) {\n\t\tfprintf(stderr, \"Error: X11 sandboxing is not available when running as root\\n\");\n\t\texit(1);\n\t}\n\n\t// check xpra\n\tif (x11_check_xpra() == 1)\n\t\tx11_start_xpra(argc, argv);\n\telse if (x11_check_xephyr() == 1)\n\t\tx11_start_xephyr(argc, argv);\n\telse {\n\t\tfprintf(stderr, \"\\nError: Xpra or Xephyr not found in /usr/bin directory, please install one of them:\\n\");\n\t\tfprintf(stderr, \"   Debian/Ubuntu/Mint: sudo apt-get install xpra\\n\");\n\t\tfprintf(stderr, \"   Debian/Ubuntu/Mint: sudo apt-get install xserver-xephyr\\n\");\n\t\texit(0);\n\t}\n}",
    "includes": [
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "myexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/main.c",
          "lines": "137-149",
          "snippet": "static void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}",
          "includes": [
            "#include <sys/times.h>",
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int arg_command = 0;",
            "int arg_quiet = 0;",
            "pid_t sandbox_pid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/times.h>\n#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nint arg_command = 0;\nint arg_quiet = 0;\npid_t sandbox_pid;\n\nstatic void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"   Debian/Ubuntu/Mint: sudo apt-get install xserver-xephyr\\n\""
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"   Debian/Ubuntu/Mint: sudo apt-get install xpra\\n\""
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\nError: Xpra or Xephyr not found in /usr/bin directory, please install one of them:\\n\""
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x11_start_xephyr",
          "args": [
            "argc",
            "argv"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "x11_start_xephyr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/x11.c",
          "lines": "187-385",
          "snippet": "void x11_start_xephyr(int argc, char **argv) {\n\tEUID_ASSERT();\n\tint i;\n\tstruct stat s;\n\tpid_t jail = 0;\n\tpid_t server = 0;\n\t\n\tsetenv(\"FIREJAIL_X11\", \"yes\", 1);\n\n\t// unfortunately, xephyr does a number of weird things when started by root user!!!\n\tif (getuid() == 0) {\n\t\tfprintf(stderr, \"Error: X11 sandboxing is not available when running as root\\n\");\n\t\texit(1);\n\t}\n\tdrop_privs(0);\n\n\t// check xephyr\n\tif (x11_check_xephyr() == 0) {\n\t\tfprintf(stderr, \"\\nError: Xephyr program was not found in /usr/bin directory, please install it:\\n\");\n\t\tfprintf(stderr, \"   Debian/Ubuntu/Mint: sudo apt-get install xserver-xephyr\\n\");\n\t\tfprintf(stderr, \"   Arch: sudo pacman -S xorg-server-xephyr\\n\");\n\t\texit(0);\n\t}\n\t\n\tint display = random_display_number();\n\tchar *display_str;\n\tif (asprintf(&display_str, \":%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\n\tassert(xephyr_screen);\n\tchar *server_argv[256] = { \"Xephyr\", \"-ac\", \"-br\", \"-noreset\", \"-screen\", xephyr_screen }; // rest initialyzed to NULL\n\tunsigned pos = 0;\n\twhile (server_argv[pos] != NULL) pos++;\n\tif (checkcfg(CFG_XEPHYR_WINDOW_TITLE)) {\n\t\tserver_argv[pos++] = \"-title\";\n\t\tserver_argv[pos++] = \"firejail x11 sandbox\";\n\t}\n\n\tassert(xephyr_extra_params); // should be \"\" if empty\n\n\t// parse xephyr_extra_params\n\t// very basic quoting support\n\tchar *temp = strdup(xephyr_extra_params);\n\tif (*xephyr_extra_params != '\\0') {\n\t\tif (!temp)\n\t\t\terrExit(\"strdup\");\n\t\tbool dquote = false;\n\t\tbool squote = false;\n\t\tfor (i = 0; i < (int) strlen(xephyr_extra_params); i++) {\n\t\t\tif (temp[i] == '\\\"') {\n\t\t\t\tdquote = !dquote;\n\t\t\t\tif (dquote) temp[i] = '\\0'; // replace closing quote by \\0\n\t\t\t}\n\t\t\tif (temp[i] == '\\'') {\n\t\t\t\tsquote = !squote;\n\t\t\t\tif (squote) temp[i] = '\\0'; // replace closing quote by \\0\n\t\t\t}\n\t\t\tif (!dquote && !squote && temp[i] == ' ') temp[i] = '\\0';\n\t\t\tif (dquote && squote) {\n\t\t\t\tfprintf(stderr, \"Error: mixed quoting found while parsing xephyr_extra_params\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\tif (dquote) {\n\t\t\tfprintf(stderr, \"Error: unclosed quote found while parsing xephyr_extra_params\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tfor (i = 0; i < (int) strlen(xephyr_extra_params)-1; i++) {\n\t\t\tif (pos >= (sizeof(server_argv)/sizeof(*server_argv)) - 2) {\n\t\t\t\tfprintf(stderr, \"Error: arg count limit exceeded while parsing xephyr_extra_params\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (temp[i] == '\\0' && (temp[i+1] == '\\\"' || temp[i+1] == '\\'')) server_argv[pos++] = temp + i + 2;\n\t\t\telse if (temp[i] == '\\0' && temp[i+1] != '\\0') server_argv[pos++] = temp + i + 1;\n\t\t}\n\t}\n\t\n\tserver_argv[pos++] = display_str;\n\tserver_argv[pos++] = NULL;\n\n\tassert(pos < (sizeof(server_argv)/sizeof(*server_argv))); // no overrun\n\tassert(server_argv[pos-1] == NULL); // last element is null\n\t\n\tif (arg_debug) {\n\t\tsize_t i = 0;\n\t\tprintf(\"xephyr server:\");\n\t\twhile (server_argv[i]!=NULL) {\n\t\t\tprintf(\" \\\"%s\\\"\", server_argv[i]);\n\t\t\ti++;\n\t\t}\n\t\tputchar('\\n');\n\t}\n\n\t// remove --x11 arg\n\tchar *jail_argv[argc+2];\n\tint j = 0;\n\tfor (i = 0; i < argc; i++) {\n\t\tif (strcmp(argv[i], \"--x11\") == 0)\n\t\t\tcontinue;\n\t\tif (strcmp(argv[i], \"--x11=xpra\") == 0)\n\t\t\tcontinue;\n\t\tif (strcmp(argv[i], \"--x11=xephyr\") == 0)\n\t\t\tcontinue;\n\t\tjail_argv[j] = argv[i];\n\t\tj++;\n\t}\n\tjail_argv[j] = NULL;\n\n\tassert(j < argc+2); // no overrun\n\n\tif (arg_debug) {\n\t\tsize_t i = 0;\n\t\tprintf(\"xephyr client:\");\n\t\twhile (jail_argv[i]!=NULL) {\n\t\t\tprintf(\" \\\"%s\\\"\", jail_argv[i]);\n\t\t\ti++;\n\t\t}\n\t\tputchar('\\n');\n\t}\n\t\n\tserver = fork();\n\tif (server < 0)\n\t\terrExit(\"fork\");\n\tif (server == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Starting xephyr...\\n\");\n\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\t\n\t\texecvp(server_argv[0], server_argv);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\tif (arg_debug)\n\t\tprintf(\"xephyr server pid %d\\n\", server);\n\n\t// check X11 socket\n\tchar *fname;\n\tif (asprintf(&fname, \"/tmp/.X11-unix/X%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\tint n = 0;\n\t// wait for x11 server to start\n\twhile (++n < 10) {\n\t\tsleep(1);\n\t\tif (stat(fname, &s) == 0)\n\t\t\tbreak;\n\t};\n\t\n\tif (n == 10) {\n\t\tfprintf(stderr, \"Error: failed to start xephyr\\n\");\n\t\texit(1);\n\t}\n\tfree(fname);\n\t\n\tif (arg_debug) {\n            \tprintf(\"X11 sockets: \"); fflush(0);\n            \tint rv = system(\"ls /tmp/.X11-unix\");\n            \t(void) rv;\n\t}\n\n\tsetenv(\"DISPLAY\", display_str, 1);\n\t// run attach command\n\tjail = fork();\n\tif (jail < 0)\n\t\terrExit(\"fork\");\n\tif (jail == 0) {\n\t\tif (!arg_quiet)\n\t\t\tprintf(\"\\n*** Attaching to Xephyr display %d ***\\n\\n\", display);\n\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\t\n\t\texecvp(jail_argv[0], jail_argv);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\t// cleanup\n\tfree(display_str);\n\tfree(temp);\n\n\t// wait for either server or jail termination\n\tpid_t pid = wait(NULL);\n\n\t// see which process terminated and kill other\n\tif (pid == server) {\n\t\tkill(jail, SIGTERM);\n\t} else if (pid == jail) {\n\t\tkill(server, SIGTERM);\n\t}\n\n\t// without this closing Xephyr window may mess your terminal:\n\t// \"monitoring\" process will release terminal before\n\t// jail process ends and releases terminal\n\twait(NULL); // fulneral\n\n\texit(0);\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <sys/mount.h>\n#include <dirent.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid x11_start_xephyr(int argc, char **argv) {\n\tEUID_ASSERT();\n\tint i;\n\tstruct stat s;\n\tpid_t jail = 0;\n\tpid_t server = 0;\n\t\n\tsetenv(\"FIREJAIL_X11\", \"yes\", 1);\n\n\t// unfortunately, xephyr does a number of weird things when started by root user!!!\n\tif (getuid() == 0) {\n\t\tfprintf(stderr, \"Error: X11 sandboxing is not available when running as root\\n\");\n\t\texit(1);\n\t}\n\tdrop_privs(0);\n\n\t// check xephyr\n\tif (x11_check_xephyr() == 0) {\n\t\tfprintf(stderr, \"\\nError: Xephyr program was not found in /usr/bin directory, please install it:\\n\");\n\t\tfprintf(stderr, \"   Debian/Ubuntu/Mint: sudo apt-get install xserver-xephyr\\n\");\n\t\tfprintf(stderr, \"   Arch: sudo pacman -S xorg-server-xephyr\\n\");\n\t\texit(0);\n\t}\n\t\n\tint display = random_display_number();\n\tchar *display_str;\n\tif (asprintf(&display_str, \":%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\n\tassert(xephyr_screen);\n\tchar *server_argv[256] = { \"Xephyr\", \"-ac\", \"-br\", \"-noreset\", \"-screen\", xephyr_screen }; // rest initialyzed to NULL\n\tunsigned pos = 0;\n\twhile (server_argv[pos] != NULL) pos++;\n\tif (checkcfg(CFG_XEPHYR_WINDOW_TITLE)) {\n\t\tserver_argv[pos++] = \"-title\";\n\t\tserver_argv[pos++] = \"firejail x11 sandbox\";\n\t}\n\n\tassert(xephyr_extra_params); // should be \"\" if empty\n\n\t// parse xephyr_extra_params\n\t// very basic quoting support\n\tchar *temp = strdup(xephyr_extra_params);\n\tif (*xephyr_extra_params != '\\0') {\n\t\tif (!temp)\n\t\t\terrExit(\"strdup\");\n\t\tbool dquote = false;\n\t\tbool squote = false;\n\t\tfor (i = 0; i < (int) strlen(xephyr_extra_params); i++) {\n\t\t\tif (temp[i] == '\\\"') {\n\t\t\t\tdquote = !dquote;\n\t\t\t\tif (dquote) temp[i] = '\\0'; // replace closing quote by \\0\n\t\t\t}\n\t\t\tif (temp[i] == '\\'') {\n\t\t\t\tsquote = !squote;\n\t\t\t\tif (squote) temp[i] = '\\0'; // replace closing quote by \\0\n\t\t\t}\n\t\t\tif (!dquote && !squote && temp[i] == ' ') temp[i] = '\\0';\n\t\t\tif (dquote && squote) {\n\t\t\t\tfprintf(stderr, \"Error: mixed quoting found while parsing xephyr_extra_params\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\tif (dquote) {\n\t\t\tfprintf(stderr, \"Error: unclosed quote found while parsing xephyr_extra_params\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tfor (i = 0; i < (int) strlen(xephyr_extra_params)-1; i++) {\n\t\t\tif (pos >= (sizeof(server_argv)/sizeof(*server_argv)) - 2) {\n\t\t\t\tfprintf(stderr, \"Error: arg count limit exceeded while parsing xephyr_extra_params\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (temp[i] == '\\0' && (temp[i+1] == '\\\"' || temp[i+1] == '\\'')) server_argv[pos++] = temp + i + 2;\n\t\t\telse if (temp[i] == '\\0' && temp[i+1] != '\\0') server_argv[pos++] = temp + i + 1;\n\t\t}\n\t}\n\t\n\tserver_argv[pos++] = display_str;\n\tserver_argv[pos++] = NULL;\n\n\tassert(pos < (sizeof(server_argv)/sizeof(*server_argv))); // no overrun\n\tassert(server_argv[pos-1] == NULL); // last element is null\n\t\n\tif (arg_debug) {\n\t\tsize_t i = 0;\n\t\tprintf(\"xephyr server:\");\n\t\twhile (server_argv[i]!=NULL) {\n\t\t\tprintf(\" \\\"%s\\\"\", server_argv[i]);\n\t\t\ti++;\n\t\t}\n\t\tputchar('\\n');\n\t}\n\n\t// remove --x11 arg\n\tchar *jail_argv[argc+2];\n\tint j = 0;\n\tfor (i = 0; i < argc; i++) {\n\t\tif (strcmp(argv[i], \"--x11\") == 0)\n\t\t\tcontinue;\n\t\tif (strcmp(argv[i], \"--x11=xpra\") == 0)\n\t\t\tcontinue;\n\t\tif (strcmp(argv[i], \"--x11=xephyr\") == 0)\n\t\t\tcontinue;\n\t\tjail_argv[j] = argv[i];\n\t\tj++;\n\t}\n\tjail_argv[j] = NULL;\n\n\tassert(j < argc+2); // no overrun\n\n\tif (arg_debug) {\n\t\tsize_t i = 0;\n\t\tprintf(\"xephyr client:\");\n\t\twhile (jail_argv[i]!=NULL) {\n\t\t\tprintf(\" \\\"%s\\\"\", jail_argv[i]);\n\t\t\ti++;\n\t\t}\n\t\tputchar('\\n');\n\t}\n\t\n\tserver = fork();\n\tif (server < 0)\n\t\terrExit(\"fork\");\n\tif (server == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Starting xephyr...\\n\");\n\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\t\n\t\texecvp(server_argv[0], server_argv);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\tif (arg_debug)\n\t\tprintf(\"xephyr server pid %d\\n\", server);\n\n\t// check X11 socket\n\tchar *fname;\n\tif (asprintf(&fname, \"/tmp/.X11-unix/X%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\tint n = 0;\n\t// wait for x11 server to start\n\twhile (++n < 10) {\n\t\tsleep(1);\n\t\tif (stat(fname, &s) == 0)\n\t\t\tbreak;\n\t};\n\t\n\tif (n == 10) {\n\t\tfprintf(stderr, \"Error: failed to start xephyr\\n\");\n\t\texit(1);\n\t}\n\tfree(fname);\n\t\n\tif (arg_debug) {\n            \tprintf(\"X11 sockets: \"); fflush(0);\n            \tint rv = system(\"ls /tmp/.X11-unix\");\n            \t(void) rv;\n\t}\n\n\tsetenv(\"DISPLAY\", display_str, 1);\n\t// run attach command\n\tjail = fork();\n\tif (jail < 0)\n\t\terrExit(\"fork\");\n\tif (jail == 0) {\n\t\tif (!arg_quiet)\n\t\t\tprintf(\"\\n*** Attaching to Xephyr display %d ***\\n\\n\", display);\n\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\t\n\t\texecvp(jail_argv[0], jail_argv);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\t// cleanup\n\tfree(display_str);\n\tfree(temp);\n\n\t// wait for either server or jail termination\n\tpid_t pid = wait(NULL);\n\n\t// see which process terminated and kill other\n\tif (pid == server) {\n\t\tkill(jail, SIGTERM);\n\t} else if (pid == jail) {\n\t\tkill(server, SIGTERM);\n\t}\n\n\t// without this closing Xephyr window may mess your terminal:\n\t// \"monitoring\" process will release terminal before\n\t// jail process ends and releases terminal\n\twait(NULL); // fulneral\n\n\texit(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "x11_check_xephyr",
          "args": [],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "x11_check_xephyr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/x11.c",
          "lines": "45-53",
          "snippet": "static int x11_check_xephyr(void) {\n\tstruct stat s;\n\t\n\t// check xephyr\n\tif (stat(\"/usr/bin/Xephyr\", &s) == -1)\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <sys/mount.h>\n#include <dirent.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nstatic int x11_check_xephyr(void) {\n\tstruct stat s;\n\t\n\t// check xephyr\n\tif (stat(\"/usr/bin/Xephyr\", &s) == -1)\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "x11_start_xpra",
          "args": [
            "argc",
            "argv"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "x11_start_xpra",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/x11.c",
          "lines": "387-582",
          "snippet": "void x11_start_xpra(int argc, char **argv) {\n\tEUID_ASSERT();\n\tint i;\n\tstruct stat s;\n\tpid_t client = 0;\n\tpid_t server = 0;\n\t\n\tsetenv(\"FIREJAIL_X11\", \"yes\", 1);\n\n\t// unfortunately, xpra does a number of weird things when started by root user!!!\n\tif (getuid() == 0) {\n\t\tfprintf(stderr, \"Error: X11 sandboxing is not available when running as root\\n\");\n\t\texit(1);\n\t}\n\tdrop_privs(0);\n\n\t// check xpra\n\tif (x11_check_xpra() == 0) {\n\t\tfprintf(stderr, \"\\nError: Xpra program was not found in /usr/bin directory, please install it:\\n\");\n\t\tfprintf(stderr, \"   Debian/Ubuntu/Mint: sudo apt-get install xpra\\n\");\n\t\texit(0);\n\t}\n\t\n\tint display = random_display_number();\n\tchar *display_str;\n\tif (asprintf(&display_str, \":%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// build the start command\n\tchar *server_argv[] = { \"xpra\", \"start\", display_str, \"--no-daemon\",  NULL };\n\n\tint fd_null = -1;\n\tif (arg_quiet) {\n\t\tfd_null = open(\"/dev/null\", O_RDWR);\n\t\tif (fd_null == -1)\n\t\t\terrExit(\"open\");\n\t}\n\n\t// start\n\tserver = fork();\n\tif (server < 0)\n\t\terrExit(\"fork\");\n\tif (server == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Starting xpra...\\n\");\n\n\t\tif (arg_quiet && fd_null != -1) {\n\t\t\tdup2(fd_null,0);\n\t\t\tdup2(fd_null,1);\n\t\t\tdup2(fd_null,2);\n\t\t}\n\t\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\t\n\t\texecvp(server_argv[0], server_argv);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\t// check X11 socket\n\tchar *fname;\n\tif (asprintf(&fname, \"/tmp/.X11-unix/X%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\tint n = 0;\n\t// wait for x11 server to start\n\twhile (++n < 10) {\n\t\tsleep(1);\n\t\tif (stat(fname, &s) == 0)\n\t\t\tbreak;\n\t}\n\t\n\tif (n == 10) {\n\t\tfprintf(stderr, \"Error: failed to start xpra\\n\");\n\t\texit(1);\n\t}\n\tfree(fname);\n\t\n\tif (arg_debug) {\n                printf(\"X11 sockets: \"); fflush(0);\n                int rv = system(\"ls /tmp/.X11-unix\");\n                (void) rv;\n        }\n\n\t// build attach command\n\tchar *attach_argv[] = { \"xpra\", \"--title=\\\"firejail x11 sandbox\\\"\", \"attach\", display_str, NULL };\n\n\t// run attach command\n\tclient = fork();\n\tif (client < 0)\n\t\terrExit(\"fork\");\n\tif (client == 0) {\n\t\tif (arg_quiet && fd_null != -1) {\n\t\t\tdup2(fd_null,0);\n\t\t\tdup2(fd_null,1);\n\t\t\tdup2(fd_null,2);\n\t\t}\n\n\t\tif (!arg_quiet)\n\t\t\tprintf(\"\\n*** Attaching to xpra display %d ***\\n\\n\", display);\n\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\t\n\t\texecvp(attach_argv[0], attach_argv);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\tsetenv(\"DISPLAY\", display_str, 1);\n\n\t// build jail command\n\tchar *firejail_argv[argc+2];\n\tint pos = 0;\n\tfor (i = 0; i < argc; i++) {\n\t\tif (strcmp(argv[i], \"--x11\") == 0)\n\t\t\tcontinue;\n\t\tif (strcmp(argv[i], \"--x11=xpra\") == 0)\n\t\t\tcontinue;\n\t\tif (strcmp(argv[i], \"--x11=xephyr\") == 0)\n\t\t\tcontinue;\n\t\tfirejail_argv[pos] = argv[i];\n\t\tpos++;\n\t}\n\tfirejail_argv[pos] = NULL;\n\n\tassert(pos < (argc+2));\n\tassert(!firejail_argv[pos]);\n\n\t// start jail\n\tpid_t jail = fork();\n\tif (jail < 0)\n\t\terrExit(\"fork\");\n\tif (jail == 0) {\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\t\n\t\tif (firejail_argv[0]) // shut up llvm scan-build\n\t\t\texecvp(firejail_argv[0], firejail_argv);\n\t\tperror(\"execvp\");\n\t\texit(1);\n\t}\n\n\tif (!arg_quiet)\n\t\tprintf(\"Xpra server pid %d, xpra client pid %d, jail %d\\n\", server, client, jail);\n\n\tsleep(1); // let jail start\n\n\t// wait for jail or server to end\n\twhile (1) {\n\t\tpid_t pid = wait(NULL);\n\n\t\tif (pid == jail) {\n\t\t\tchar *stop_argv[] = { \"xpra\", \"stop\", display_str, NULL };\n\t\t\tpid_t stop = fork();\n\t\t\tif (stop < 0)\n\t\t\t\terrExit(\"fork\");\n\t\t\tif (stop == 0) {\n\t\t\t\tif (arg_quiet && fd_null != -1) {\n\t\t\t\t\tdup2(fd_null,0);\n\t\t\t\t\tdup2(fd_null,1);\n\t\t\t\t\tdup2(fd_null,2);\n\t\t\t\t}\n\t\t\t\t// running without privileges - see drop_privs call above\n\t\t\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\t\n\t\t\t\texecvp(stop_argv[0], stop_argv);\n\t\t\t\tperror(\"execvp\");\n\t\t\t\t_exit(1);\n\t\t\t}\n\n\t\t\t// wait for xpra server to stop, 10 seconds limit\n\t\t\twhile (++n < 10) {\n\t\t\t\tsleep(1);\n\t\t\t\tpid = waitpid(server, NULL, WNOHANG);\n\t\t\t\tif (pid == server)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (arg_debug) {\n\t\t\t\tif (n == 10)\n\t\t\t\t\tprintf(\"failed to stop xpra server gratefully\\n\");\n\t\t\t\telse\n\t\t\t\t\tprintf(\"xpra server successfully stopped in %d secs\\n\", n);\n\t\t\t}\n\t\t\t\n\t\t\t// kill xpra server and xpra client\n\t\t\tkill(client, SIGTERM);\n\t\t\tkill(server, SIGTERM);\n\t\t\texit(0);\n\t\t}\n\t\telse if (pid == server) {\n\t\t\t// kill firejail process\n\t\t\tkill(jail, SIGTERM);\n\t\t\t// kill xpra client (should die with server, but...)\n\t\t\tkill(client, SIGTERM);\n\t\t\texit(0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <sys/mount.h>\n#include <dirent.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid x11_start_xpra(int argc, char **argv) {\n\tEUID_ASSERT();\n\tint i;\n\tstruct stat s;\n\tpid_t client = 0;\n\tpid_t server = 0;\n\t\n\tsetenv(\"FIREJAIL_X11\", \"yes\", 1);\n\n\t// unfortunately, xpra does a number of weird things when started by root user!!!\n\tif (getuid() == 0) {\n\t\tfprintf(stderr, \"Error: X11 sandboxing is not available when running as root\\n\");\n\t\texit(1);\n\t}\n\tdrop_privs(0);\n\n\t// check xpra\n\tif (x11_check_xpra() == 0) {\n\t\tfprintf(stderr, \"\\nError: Xpra program was not found in /usr/bin directory, please install it:\\n\");\n\t\tfprintf(stderr, \"   Debian/Ubuntu/Mint: sudo apt-get install xpra\\n\");\n\t\texit(0);\n\t}\n\t\n\tint display = random_display_number();\n\tchar *display_str;\n\tif (asprintf(&display_str, \":%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// build the start command\n\tchar *server_argv[] = { \"xpra\", \"start\", display_str, \"--no-daemon\",  NULL };\n\n\tint fd_null = -1;\n\tif (arg_quiet) {\n\t\tfd_null = open(\"/dev/null\", O_RDWR);\n\t\tif (fd_null == -1)\n\t\t\terrExit(\"open\");\n\t}\n\n\t// start\n\tserver = fork();\n\tif (server < 0)\n\t\terrExit(\"fork\");\n\tif (server == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Starting xpra...\\n\");\n\n\t\tif (arg_quiet && fd_null != -1) {\n\t\t\tdup2(fd_null,0);\n\t\t\tdup2(fd_null,1);\n\t\t\tdup2(fd_null,2);\n\t\t}\n\t\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\t\n\t\texecvp(server_argv[0], server_argv);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\t// check X11 socket\n\tchar *fname;\n\tif (asprintf(&fname, \"/tmp/.X11-unix/X%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\tint n = 0;\n\t// wait for x11 server to start\n\twhile (++n < 10) {\n\t\tsleep(1);\n\t\tif (stat(fname, &s) == 0)\n\t\t\tbreak;\n\t}\n\t\n\tif (n == 10) {\n\t\tfprintf(stderr, \"Error: failed to start xpra\\n\");\n\t\texit(1);\n\t}\n\tfree(fname);\n\t\n\tif (arg_debug) {\n                printf(\"X11 sockets: \"); fflush(0);\n                int rv = system(\"ls /tmp/.X11-unix\");\n                (void) rv;\n        }\n\n\t// build attach command\n\tchar *attach_argv[] = { \"xpra\", \"--title=\\\"firejail x11 sandbox\\\"\", \"attach\", display_str, NULL };\n\n\t// run attach command\n\tclient = fork();\n\tif (client < 0)\n\t\terrExit(\"fork\");\n\tif (client == 0) {\n\t\tif (arg_quiet && fd_null != -1) {\n\t\t\tdup2(fd_null,0);\n\t\t\tdup2(fd_null,1);\n\t\t\tdup2(fd_null,2);\n\t\t}\n\n\t\tif (!arg_quiet)\n\t\t\tprintf(\"\\n*** Attaching to xpra display %d ***\\n\\n\", display);\n\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\t\n\t\texecvp(attach_argv[0], attach_argv);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\tsetenv(\"DISPLAY\", display_str, 1);\n\n\t// build jail command\n\tchar *firejail_argv[argc+2];\n\tint pos = 0;\n\tfor (i = 0; i < argc; i++) {\n\t\tif (strcmp(argv[i], \"--x11\") == 0)\n\t\t\tcontinue;\n\t\tif (strcmp(argv[i], \"--x11=xpra\") == 0)\n\t\t\tcontinue;\n\t\tif (strcmp(argv[i], \"--x11=xephyr\") == 0)\n\t\t\tcontinue;\n\t\tfirejail_argv[pos] = argv[i];\n\t\tpos++;\n\t}\n\tfirejail_argv[pos] = NULL;\n\n\tassert(pos < (argc+2));\n\tassert(!firejail_argv[pos]);\n\n\t// start jail\n\tpid_t jail = fork();\n\tif (jail < 0)\n\t\terrExit(\"fork\");\n\tif (jail == 0) {\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\t\n\t\tif (firejail_argv[0]) // shut up llvm scan-build\n\t\t\texecvp(firejail_argv[0], firejail_argv);\n\t\tperror(\"execvp\");\n\t\texit(1);\n\t}\n\n\tif (!arg_quiet)\n\t\tprintf(\"Xpra server pid %d, xpra client pid %d, jail %d\\n\", server, client, jail);\n\n\tsleep(1); // let jail start\n\n\t// wait for jail or server to end\n\twhile (1) {\n\t\tpid_t pid = wait(NULL);\n\n\t\tif (pid == jail) {\n\t\t\tchar *stop_argv[] = { \"xpra\", \"stop\", display_str, NULL };\n\t\t\tpid_t stop = fork();\n\t\t\tif (stop < 0)\n\t\t\t\terrExit(\"fork\");\n\t\t\tif (stop == 0) {\n\t\t\t\tif (arg_quiet && fd_null != -1) {\n\t\t\t\t\tdup2(fd_null,0);\n\t\t\t\t\tdup2(fd_null,1);\n\t\t\t\t\tdup2(fd_null,2);\n\t\t\t\t}\n\t\t\t\t// running without privileges - see drop_privs call above\n\t\t\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\t\n\t\t\t\texecvp(stop_argv[0], stop_argv);\n\t\t\t\tperror(\"execvp\");\n\t\t\t\t_exit(1);\n\t\t\t}\n\n\t\t\t// wait for xpra server to stop, 10 seconds limit\n\t\t\twhile (++n < 10) {\n\t\t\t\tsleep(1);\n\t\t\t\tpid = waitpid(server, NULL, WNOHANG);\n\t\t\t\tif (pid == server)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (arg_debug) {\n\t\t\t\tif (n == 10)\n\t\t\t\t\tprintf(\"failed to stop xpra server gratefully\\n\");\n\t\t\t\telse\n\t\t\t\t\tprintf(\"xpra server successfully stopped in %d secs\\n\", n);\n\t\t\t}\n\t\t\t\n\t\t\t// kill xpra server and xpra client\n\t\t\tkill(client, SIGTERM);\n\t\t\tkill(server, SIGTERM);\n\t\t\texit(0);\n\t\t}\n\t\telse if (pid == server) {\n\t\t\t// kill firejail process\n\t\t\tkill(jail, SIGTERM);\n\t\t\t// kill xpra client (should die with server, but...)\n\t\t\tkill(client, SIGTERM);\n\t\t\texit(0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "x11_check_xpra",
          "args": [],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "x11_check_xpra",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/x11.c",
          "lines": "34-42",
          "snippet": "static int x11_check_xpra(void) {\n\tstruct stat s;\n\t\n\t// check xpra\n\tif (stat(\"/usr/bin/xpra\", &s) == -1)\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <sys/mount.h>\n#include <dirent.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nstatic int x11_check_xpra(void) {\n\tstruct stat s;\n\t\n\t// check xpra\n\tif (stat(\"/usr/bin/xpra\", &s) == -1)\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: X11 sandboxing is not available when running as root\\n\""
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/wait.h>\n#include <sys/mount.h>\n#include <dirent.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid x11_start(int argc, char **argv) {\n\tEUID_ASSERT();\n\n\t// unfortunately, xpra does a number of weird things when started by root user!!!\n\tif (getuid() == 0) {\n\t\tfprintf(stderr, \"Error: X11 sandboxing is not available when running as root\\n\");\n\t\texit(1);\n\t}\n\n\t// check xpra\n\tif (x11_check_xpra() == 1)\n\t\tx11_start_xpra(argc, argv);\n\telse if (x11_check_xephyr() == 1)\n\t\tx11_start_xephyr(argc, argv);\n\telse {\n\t\tfprintf(stderr, \"\\nError: Xpra or Xephyr not found in /usr/bin directory, please install one of them:\\n\");\n\t\tfprintf(stderr, \"   Debian/Ubuntu/Mint: sudo apt-get install xpra\\n\");\n\t\tfprintf(stderr, \"   Debian/Ubuntu/Mint: sudo apt-get install xserver-xephyr\\n\");\n\t\texit(0);\n\t}\n}"
  },
  {
    "function_name": "x11_start_xpra",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/x11.c",
    "lines": "387-582",
    "snippet": "void x11_start_xpra(int argc, char **argv) {\n\tEUID_ASSERT();\n\tint i;\n\tstruct stat s;\n\tpid_t client = 0;\n\tpid_t server = 0;\n\t\n\tsetenv(\"FIREJAIL_X11\", \"yes\", 1);\n\n\t// unfortunately, xpra does a number of weird things when started by root user!!!\n\tif (getuid() == 0) {\n\t\tfprintf(stderr, \"Error: X11 sandboxing is not available when running as root\\n\");\n\t\texit(1);\n\t}\n\tdrop_privs(0);\n\n\t// check xpra\n\tif (x11_check_xpra() == 0) {\n\t\tfprintf(stderr, \"\\nError: Xpra program was not found in /usr/bin directory, please install it:\\n\");\n\t\tfprintf(stderr, \"   Debian/Ubuntu/Mint: sudo apt-get install xpra\\n\");\n\t\texit(0);\n\t}\n\t\n\tint display = random_display_number();\n\tchar *display_str;\n\tif (asprintf(&display_str, \":%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// build the start command\n\tchar *server_argv[] = { \"xpra\", \"start\", display_str, \"--no-daemon\",  NULL };\n\n\tint fd_null = -1;\n\tif (arg_quiet) {\n\t\tfd_null = open(\"/dev/null\", O_RDWR);\n\t\tif (fd_null == -1)\n\t\t\terrExit(\"open\");\n\t}\n\n\t// start\n\tserver = fork();\n\tif (server < 0)\n\t\terrExit(\"fork\");\n\tif (server == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Starting xpra...\\n\");\n\n\t\tif (arg_quiet && fd_null != -1) {\n\t\t\tdup2(fd_null,0);\n\t\t\tdup2(fd_null,1);\n\t\t\tdup2(fd_null,2);\n\t\t}\n\t\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\t\n\t\texecvp(server_argv[0], server_argv);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\t// check X11 socket\n\tchar *fname;\n\tif (asprintf(&fname, \"/tmp/.X11-unix/X%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\tint n = 0;\n\t// wait for x11 server to start\n\twhile (++n < 10) {\n\t\tsleep(1);\n\t\tif (stat(fname, &s) == 0)\n\t\t\tbreak;\n\t}\n\t\n\tif (n == 10) {\n\t\tfprintf(stderr, \"Error: failed to start xpra\\n\");\n\t\texit(1);\n\t}\n\tfree(fname);\n\t\n\tif (arg_debug) {\n                printf(\"X11 sockets: \"); fflush(0);\n                int rv = system(\"ls /tmp/.X11-unix\");\n                (void) rv;\n        }\n\n\t// build attach command\n\tchar *attach_argv[] = { \"xpra\", \"--title=\\\"firejail x11 sandbox\\\"\", \"attach\", display_str, NULL };\n\n\t// run attach command\n\tclient = fork();\n\tif (client < 0)\n\t\terrExit(\"fork\");\n\tif (client == 0) {\n\t\tif (arg_quiet && fd_null != -1) {\n\t\t\tdup2(fd_null,0);\n\t\t\tdup2(fd_null,1);\n\t\t\tdup2(fd_null,2);\n\t\t}\n\n\t\tif (!arg_quiet)\n\t\t\tprintf(\"\\n*** Attaching to xpra display %d ***\\n\\n\", display);\n\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\t\n\t\texecvp(attach_argv[0], attach_argv);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\tsetenv(\"DISPLAY\", display_str, 1);\n\n\t// build jail command\n\tchar *firejail_argv[argc+2];\n\tint pos = 0;\n\tfor (i = 0; i < argc; i++) {\n\t\tif (strcmp(argv[i], \"--x11\") == 0)\n\t\t\tcontinue;\n\t\tif (strcmp(argv[i], \"--x11=xpra\") == 0)\n\t\t\tcontinue;\n\t\tif (strcmp(argv[i], \"--x11=xephyr\") == 0)\n\t\t\tcontinue;\n\t\tfirejail_argv[pos] = argv[i];\n\t\tpos++;\n\t}\n\tfirejail_argv[pos] = NULL;\n\n\tassert(pos < (argc+2));\n\tassert(!firejail_argv[pos]);\n\n\t// start jail\n\tpid_t jail = fork();\n\tif (jail < 0)\n\t\terrExit(\"fork\");\n\tif (jail == 0) {\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\t\n\t\tif (firejail_argv[0]) // shut up llvm scan-build\n\t\t\texecvp(firejail_argv[0], firejail_argv);\n\t\tperror(\"execvp\");\n\t\texit(1);\n\t}\n\n\tif (!arg_quiet)\n\t\tprintf(\"Xpra server pid %d, xpra client pid %d, jail %d\\n\", server, client, jail);\n\n\tsleep(1); // let jail start\n\n\t// wait for jail or server to end\n\twhile (1) {\n\t\tpid_t pid = wait(NULL);\n\n\t\tif (pid == jail) {\n\t\t\tchar *stop_argv[] = { \"xpra\", \"stop\", display_str, NULL };\n\t\t\tpid_t stop = fork();\n\t\t\tif (stop < 0)\n\t\t\t\terrExit(\"fork\");\n\t\t\tif (stop == 0) {\n\t\t\t\tif (arg_quiet && fd_null != -1) {\n\t\t\t\t\tdup2(fd_null,0);\n\t\t\t\t\tdup2(fd_null,1);\n\t\t\t\t\tdup2(fd_null,2);\n\t\t\t\t}\n\t\t\t\t// running without privileges - see drop_privs call above\n\t\t\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\t\n\t\t\t\texecvp(stop_argv[0], stop_argv);\n\t\t\t\tperror(\"execvp\");\n\t\t\t\t_exit(1);\n\t\t\t}\n\n\t\t\t// wait for xpra server to stop, 10 seconds limit\n\t\t\twhile (++n < 10) {\n\t\t\t\tsleep(1);\n\t\t\t\tpid = waitpid(server, NULL, WNOHANG);\n\t\t\t\tif (pid == server)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (arg_debug) {\n\t\t\t\tif (n == 10)\n\t\t\t\t\tprintf(\"failed to stop xpra server gratefully\\n\");\n\t\t\t\telse\n\t\t\t\t\tprintf(\"xpra server successfully stopped in %d secs\\n\", n);\n\t\t\t}\n\t\t\t\n\t\t\t// kill xpra server and xpra client\n\t\t\tkill(client, SIGTERM);\n\t\t\tkill(server, SIGTERM);\n\t\t\texit(0);\n\t\t}\n\t\telse if (pid == server) {\n\t\t\t// kill firejail process\n\t\t\tkill(jail, SIGTERM);\n\t\t\t// kill xpra client (should die with server, but...)\n\t\t\tkill(client, SIGTERM);\n\t\t\texit(0);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "myexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/main.c",
          "lines": "137-149",
          "snippet": "static void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}",
          "includes": [
            "#include <sys/times.h>",
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int arg_command = 0;",
            "int arg_quiet = 0;",
            "pid_t sandbox_pid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/times.h>\n#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nint arg_command = 0;\nint arg_quiet = 0;\npid_t sandbox_pid;\n\nstatic void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}"
        }
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "client",
            "SIGTERM"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "jail",
            "SIGTERM"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "server",
            "SIGTERM"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "client",
            "SIGTERM"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"xpra server successfully stopped in %d secs\\n\"",
            "n"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"failed to stop xpra server gratefully\\n\""
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "server",
            "NULL",
            "WNOHANG"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sleep",
          "args": [
            "1"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "1"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"execvp\""
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execvp",
          "args": [
            "stop_argv[0]",
            "stop_argv"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "getenv(\"LD_PRELOAD\") == NULL"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"LD_PRELOAD\""
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "fd_null",
            "2"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "fd_null",
            "1"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "fd_null",
            "0"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fork\""
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait",
          "args": [
            "NULL"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "wait_for_other",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/util.c",
          "lines": "541-569",
          "snippet": "void wait_for_other(int fd) {\n\t//****************************\n\t// wait for the parent to be initialized\n\t//****************************\n\tchar childstr[BUFLEN + 1];\n\tint newfd = dup(fd);\n\tif (newfd == -1)\n\t\terrExit(\"dup\");\n\tFILE* stream;\n\tstream = fdopen(newfd, \"r\");\n\t*childstr = '\\0';\n\tif (fgets(childstr, BUFLEN, stream)) {\n\t\t// remove \\n)\n\t\tchar *ptr = childstr;\n\t\twhile(*ptr !='\\0' && *ptr != '\\n')\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\terrExit(\"fgets\");\n\t\t*ptr = '\\0';\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: cannot establish communication with the parent, exiting...\\n\");\n\t\texit(1);\n\t}\n\tif (strcmp(childstr, \"arg_noroot=0\") == 0)\n\t\targ_noroot = 0;\n\n\tfclose(stream);\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define BUFLEN 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\n#define BUFLEN 4096\n\nvoid wait_for_other(int fd) {\n\t//****************************\n\t// wait for the parent to be initialized\n\t//****************************\n\tchar childstr[BUFLEN + 1];\n\tint newfd = dup(fd);\n\tif (newfd == -1)\n\t\terrExit(\"dup\");\n\tFILE* stream;\n\tstream = fdopen(newfd, \"r\");\n\t*childstr = '\\0';\n\tif (fgets(childstr, BUFLEN, stream)) {\n\t\t// remove \\n)\n\t\tchar *ptr = childstr;\n\t\twhile(*ptr !='\\0' && *ptr != '\\n')\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\terrExit(\"fgets\");\n\t\t*ptr = '\\0';\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: cannot establish communication with the parent, exiting...\\n\");\n\t\texit(1);\n\t}\n\tif (strcmp(childstr, \"arg_noroot=0\") == 0)\n\t\targ_noroot = 0;\n\n\tfclose(stream);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sleep",
          "args": [
            "1"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Xpra server pid %d, xpra client pid %d, jail %d\\n\"",
            "server",
            "client",
            "jail"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"execvp\""
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execvp",
          "args": [
            "firejail_argv[0]",
            "firejail_argv"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "getenv(\"LD_PRELOAD\") == NULL"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"LD_PRELOAD\""
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fork\""
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "!firejail_argv[pos]"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "pos < (argc+2)"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"--x11=xephyr\""
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"--x11=xpra\""
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"--x11\""
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"DISPLAY\"",
            "display_str",
            "1"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "1"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"execvp\""
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execvp",
          "args": [
            "attach_argv[0]",
            "attach_argv"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "getenv(\"LD_PRELOAD\") == NULL"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"LD_PRELOAD\""
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n*** Attaching to xpra display %d ***\\n\\n\"",
            "display"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "fd_null",
            "2"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "fd_null",
            "1"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "fd_null",
            "0"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fork\""
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "system",
          "args": [
            "\"ls /tmp/.X11-unix\""
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "0"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"X11 sockets: \""
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: failed to start xpra\\n\""
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "fname",
            "&s"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sleep",
          "args": [
            "1"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&fname",
            "\"/tmp/.X11-unix/X%d\"",
            "display"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "1"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"execvp\""
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execvp",
          "args": [
            "server_argv[0]",
            "server_argv"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "getenv(\"LD_PRELOAD\") == NULL"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"LD_PRELOAD\""
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "fd_null",
            "2"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "fd_null",
            "1"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "fd_null",
            "0"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Starting xpra...\\n\""
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fork\""
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"open\""
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "\"/dev/null\"",
            "O_RDWR"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&display_str",
            "\":%d\"",
            "display"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "random_display_number",
          "args": [],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "random_display_number",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/x11.c",
          "lines": "80-103",
          "snippet": "static int random_display_number(void) {\n\tint i;\n\tint found = 1;\n\tint display;\n\tfor (i = 0; i < 100; i++) {\n\t\tdisplay = rand() % 1024;\n\t\tif (display < 10)\n\t\t\tcontinue;\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/tmp/.X11-unix/X%d\", display) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tstruct stat s;\n\t\tif (stat(fname, &s) == -1) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found) {\n\t\tfprintf(stderr, \"Error: cannot pick up a random X11 display number, exiting...\\n\");\n\t\texit(1);\n\t}\n\t\n\treturn display;\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <sys/mount.h>\n#include <dirent.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nstatic int random_display_number(void) {\n\tint i;\n\tint found = 1;\n\tint display;\n\tfor (i = 0; i < 100; i++) {\n\t\tdisplay = rand() % 1024;\n\t\tif (display < 10)\n\t\t\tcontinue;\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/tmp/.X11-unix/X%d\", display) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tstruct stat s;\n\t\tif (stat(fname, &s) == -1) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found) {\n\t\tfprintf(stderr, \"Error: cannot pick up a random X11 display number, exiting...\\n\");\n\t\texit(1);\n\t}\n\t\n\treturn display;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"   Debian/Ubuntu/Mint: sudo apt-get install xpra\\n\""
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\nError: Xpra program was not found in /usr/bin directory, please install it:\\n\""
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x11_check_xpra",
          "args": [],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "x11_check_xpra",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/x11.c",
          "lines": "34-42",
          "snippet": "static int x11_check_xpra(void) {\n\tstruct stat s;\n\t\n\t// check xpra\n\tif (stat(\"/usr/bin/xpra\", &s) == -1)\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <sys/mount.h>\n#include <dirent.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nstatic int x11_check_xpra(void) {\n\tstruct stat s;\n\t\n\t// check xpra\n\tif (stat(\"/usr/bin/xpra\", &s) == -1)\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_privs",
          "args": [
            "0"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "drop_privs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/util.c",
          "lines": "36-81",
          "snippet": "void drop_privs(int nogroups) {\n\tEUID_ROOT();\n\tgid_t gid = getgid();\n\n\t// configure supplementary groups\n\tif (gid == 0 || nogroups) {\n\t\tif (setgroups(0, NULL) < 0)\n\t\t\terrExit(\"setgroups\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Username %s, no supplementary groups\\n\", cfg.username);\n\t}\n\telse {\n\t\tassert(cfg.username);\n\t\tgid_t groups[MAX_GROUPS];\n\t\tint ngroups = MAX_GROUPS;\n\t\tint rv = getgrouplist(cfg.username, gid, groups, &ngroups);\n\n\t\tif (arg_debug && rv) {\n\t\t\tprintf(\"Username %s, groups \", cfg.username);\n\t\t\tint i;\n\t\t\tfor (i = 0; i < ngroups; i++)\n\t\t\t\tprintf(\"%u, \", groups[i]);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\n\t\tif (rv == -1) {\n\t\t\tfprintf(stderr, \"Warning: cannot extract supplementary group list, dropping them\\n\");\n\t\t\tif (setgroups(0, NULL) < 0)\n\t\t\t\terrExit(\"setgroups\");\n\t\t}\n\t\telse {\n\t\t\trv = setgroups(ngroups, groups);\n\t\t\tif (rv) {\n\t\t\t\tfprintf(stderr, \"Warning: cannot set supplementary group list, dropping them\\n\");\n\t\t\t\tif (setgroups(0, NULL) < 0)\n\t\t\t\t\terrExit(\"setgroups\");\n\t\t\t}\n\t\t}\n\t}\n\n\t// set uid/gid\n\tif (setgid(getgid()) < 0)\n\t\terrExit(\"setgid/getgid\");\n\tif (setuid(getuid()) < 0)\n\t\terrExit(\"setuid/getuid\");\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAX_GROUPS 1024"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\n#define MAX_GROUPS 1024\n\nvoid drop_privs(int nogroups) {\n\tEUID_ROOT();\n\tgid_t gid = getgid();\n\n\t// configure supplementary groups\n\tif (gid == 0 || nogroups) {\n\t\tif (setgroups(0, NULL) < 0)\n\t\t\terrExit(\"setgroups\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Username %s, no supplementary groups\\n\", cfg.username);\n\t}\n\telse {\n\t\tassert(cfg.username);\n\t\tgid_t groups[MAX_GROUPS];\n\t\tint ngroups = MAX_GROUPS;\n\t\tint rv = getgrouplist(cfg.username, gid, groups, &ngroups);\n\n\t\tif (arg_debug && rv) {\n\t\t\tprintf(\"Username %s, groups \", cfg.username);\n\t\t\tint i;\n\t\t\tfor (i = 0; i < ngroups; i++)\n\t\t\t\tprintf(\"%u, \", groups[i]);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\n\t\tif (rv == -1) {\n\t\t\tfprintf(stderr, \"Warning: cannot extract supplementary group list, dropping them\\n\");\n\t\t\tif (setgroups(0, NULL) < 0)\n\t\t\t\terrExit(\"setgroups\");\n\t\t}\n\t\telse {\n\t\t\trv = setgroups(ngroups, groups);\n\t\t\tif (rv) {\n\t\t\t\tfprintf(stderr, \"Warning: cannot set supplementary group list, dropping them\\n\");\n\t\t\t\tif (setgroups(0, NULL) < 0)\n\t\t\t\t\terrExit(\"setgroups\");\n\t\t\t}\n\t\t}\n\t}\n\n\t// set uid/gid\n\tif (setgid(getgid()) < 0)\n\t\terrExit(\"setgid/getgid\");\n\tif (setuid(getuid()) < 0)\n\t\terrExit(\"setuid/getuid\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: X11 sandboxing is not available when running as root\\n\""
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"FIREJAIL_X11\"",
            "\"yes\"",
            "1"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/wait.h>\n#include <sys/mount.h>\n#include <dirent.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid x11_start_xpra(int argc, char **argv) {\n\tEUID_ASSERT();\n\tint i;\n\tstruct stat s;\n\tpid_t client = 0;\n\tpid_t server = 0;\n\t\n\tsetenv(\"FIREJAIL_X11\", \"yes\", 1);\n\n\t// unfortunately, xpra does a number of weird things when started by root user!!!\n\tif (getuid() == 0) {\n\t\tfprintf(stderr, \"Error: X11 sandboxing is not available when running as root\\n\");\n\t\texit(1);\n\t}\n\tdrop_privs(0);\n\n\t// check xpra\n\tif (x11_check_xpra() == 0) {\n\t\tfprintf(stderr, \"\\nError: Xpra program was not found in /usr/bin directory, please install it:\\n\");\n\t\tfprintf(stderr, \"   Debian/Ubuntu/Mint: sudo apt-get install xpra\\n\");\n\t\texit(0);\n\t}\n\t\n\tint display = random_display_number();\n\tchar *display_str;\n\tif (asprintf(&display_str, \":%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// build the start command\n\tchar *server_argv[] = { \"xpra\", \"start\", display_str, \"--no-daemon\",  NULL };\n\n\tint fd_null = -1;\n\tif (arg_quiet) {\n\t\tfd_null = open(\"/dev/null\", O_RDWR);\n\t\tif (fd_null == -1)\n\t\t\terrExit(\"open\");\n\t}\n\n\t// start\n\tserver = fork();\n\tif (server < 0)\n\t\terrExit(\"fork\");\n\tif (server == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Starting xpra...\\n\");\n\n\t\tif (arg_quiet && fd_null != -1) {\n\t\t\tdup2(fd_null,0);\n\t\t\tdup2(fd_null,1);\n\t\t\tdup2(fd_null,2);\n\t\t}\n\t\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\t\n\t\texecvp(server_argv[0], server_argv);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\t// check X11 socket\n\tchar *fname;\n\tif (asprintf(&fname, \"/tmp/.X11-unix/X%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\tint n = 0;\n\t// wait for x11 server to start\n\twhile (++n < 10) {\n\t\tsleep(1);\n\t\tif (stat(fname, &s) == 0)\n\t\t\tbreak;\n\t}\n\t\n\tif (n == 10) {\n\t\tfprintf(stderr, \"Error: failed to start xpra\\n\");\n\t\texit(1);\n\t}\n\tfree(fname);\n\t\n\tif (arg_debug) {\n                printf(\"X11 sockets: \"); fflush(0);\n                int rv = system(\"ls /tmp/.X11-unix\");\n                (void) rv;\n        }\n\n\t// build attach command\n\tchar *attach_argv[] = { \"xpra\", \"--title=\\\"firejail x11 sandbox\\\"\", \"attach\", display_str, NULL };\n\n\t// run attach command\n\tclient = fork();\n\tif (client < 0)\n\t\terrExit(\"fork\");\n\tif (client == 0) {\n\t\tif (arg_quiet && fd_null != -1) {\n\t\t\tdup2(fd_null,0);\n\t\t\tdup2(fd_null,1);\n\t\t\tdup2(fd_null,2);\n\t\t}\n\n\t\tif (!arg_quiet)\n\t\t\tprintf(\"\\n*** Attaching to xpra display %d ***\\n\\n\", display);\n\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\t\n\t\texecvp(attach_argv[0], attach_argv);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\tsetenv(\"DISPLAY\", display_str, 1);\n\n\t// build jail command\n\tchar *firejail_argv[argc+2];\n\tint pos = 0;\n\tfor (i = 0; i < argc; i++) {\n\t\tif (strcmp(argv[i], \"--x11\") == 0)\n\t\t\tcontinue;\n\t\tif (strcmp(argv[i], \"--x11=xpra\") == 0)\n\t\t\tcontinue;\n\t\tif (strcmp(argv[i], \"--x11=xephyr\") == 0)\n\t\t\tcontinue;\n\t\tfirejail_argv[pos] = argv[i];\n\t\tpos++;\n\t}\n\tfirejail_argv[pos] = NULL;\n\n\tassert(pos < (argc+2));\n\tassert(!firejail_argv[pos]);\n\n\t// start jail\n\tpid_t jail = fork();\n\tif (jail < 0)\n\t\terrExit(\"fork\");\n\tif (jail == 0) {\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\t\n\t\tif (firejail_argv[0]) // shut up llvm scan-build\n\t\t\texecvp(firejail_argv[0], firejail_argv);\n\t\tperror(\"execvp\");\n\t\texit(1);\n\t}\n\n\tif (!arg_quiet)\n\t\tprintf(\"Xpra server pid %d, xpra client pid %d, jail %d\\n\", server, client, jail);\n\n\tsleep(1); // let jail start\n\n\t// wait for jail or server to end\n\twhile (1) {\n\t\tpid_t pid = wait(NULL);\n\n\t\tif (pid == jail) {\n\t\t\tchar *stop_argv[] = { \"xpra\", \"stop\", display_str, NULL };\n\t\t\tpid_t stop = fork();\n\t\t\tif (stop < 0)\n\t\t\t\terrExit(\"fork\");\n\t\t\tif (stop == 0) {\n\t\t\t\tif (arg_quiet && fd_null != -1) {\n\t\t\t\t\tdup2(fd_null,0);\n\t\t\t\t\tdup2(fd_null,1);\n\t\t\t\t\tdup2(fd_null,2);\n\t\t\t\t}\n\t\t\t\t// running without privileges - see drop_privs call above\n\t\t\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\t\n\t\t\t\texecvp(stop_argv[0], stop_argv);\n\t\t\t\tperror(\"execvp\");\n\t\t\t\t_exit(1);\n\t\t\t}\n\n\t\t\t// wait for xpra server to stop, 10 seconds limit\n\t\t\twhile (++n < 10) {\n\t\t\t\tsleep(1);\n\t\t\t\tpid = waitpid(server, NULL, WNOHANG);\n\t\t\t\tif (pid == server)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (arg_debug) {\n\t\t\t\tif (n == 10)\n\t\t\t\t\tprintf(\"failed to stop xpra server gratefully\\n\");\n\t\t\t\telse\n\t\t\t\t\tprintf(\"xpra server successfully stopped in %d secs\\n\", n);\n\t\t\t}\n\t\t\t\n\t\t\t// kill xpra server and xpra client\n\t\t\tkill(client, SIGTERM);\n\t\t\tkill(server, SIGTERM);\n\t\t\texit(0);\n\t\t}\n\t\telse if (pid == server) {\n\t\t\t// kill firejail process\n\t\t\tkill(jail, SIGTERM);\n\t\t\t// kill xpra client (should die with server, but...)\n\t\t\tkill(client, SIGTERM);\n\t\t\texit(0);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "x11_start_xephyr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/x11.c",
    "lines": "187-385",
    "snippet": "void x11_start_xephyr(int argc, char **argv) {\n\tEUID_ASSERT();\n\tint i;\n\tstruct stat s;\n\tpid_t jail = 0;\n\tpid_t server = 0;\n\t\n\tsetenv(\"FIREJAIL_X11\", \"yes\", 1);\n\n\t// unfortunately, xephyr does a number of weird things when started by root user!!!\n\tif (getuid() == 0) {\n\t\tfprintf(stderr, \"Error: X11 sandboxing is not available when running as root\\n\");\n\t\texit(1);\n\t}\n\tdrop_privs(0);\n\n\t// check xephyr\n\tif (x11_check_xephyr() == 0) {\n\t\tfprintf(stderr, \"\\nError: Xephyr program was not found in /usr/bin directory, please install it:\\n\");\n\t\tfprintf(stderr, \"   Debian/Ubuntu/Mint: sudo apt-get install xserver-xephyr\\n\");\n\t\tfprintf(stderr, \"   Arch: sudo pacman -S xorg-server-xephyr\\n\");\n\t\texit(0);\n\t}\n\t\n\tint display = random_display_number();\n\tchar *display_str;\n\tif (asprintf(&display_str, \":%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\n\tassert(xephyr_screen);\n\tchar *server_argv[256] = { \"Xephyr\", \"-ac\", \"-br\", \"-noreset\", \"-screen\", xephyr_screen }; // rest initialyzed to NULL\n\tunsigned pos = 0;\n\twhile (server_argv[pos] != NULL) pos++;\n\tif (checkcfg(CFG_XEPHYR_WINDOW_TITLE)) {\n\t\tserver_argv[pos++] = \"-title\";\n\t\tserver_argv[pos++] = \"firejail x11 sandbox\";\n\t}\n\n\tassert(xephyr_extra_params); // should be \"\" if empty\n\n\t// parse xephyr_extra_params\n\t// very basic quoting support\n\tchar *temp = strdup(xephyr_extra_params);\n\tif (*xephyr_extra_params != '\\0') {\n\t\tif (!temp)\n\t\t\terrExit(\"strdup\");\n\t\tbool dquote = false;\n\t\tbool squote = false;\n\t\tfor (i = 0; i < (int) strlen(xephyr_extra_params); i++) {\n\t\t\tif (temp[i] == '\\\"') {\n\t\t\t\tdquote = !dquote;\n\t\t\t\tif (dquote) temp[i] = '\\0'; // replace closing quote by \\0\n\t\t\t}\n\t\t\tif (temp[i] == '\\'') {\n\t\t\t\tsquote = !squote;\n\t\t\t\tif (squote) temp[i] = '\\0'; // replace closing quote by \\0\n\t\t\t}\n\t\t\tif (!dquote && !squote && temp[i] == ' ') temp[i] = '\\0';\n\t\t\tif (dquote && squote) {\n\t\t\t\tfprintf(stderr, \"Error: mixed quoting found while parsing xephyr_extra_params\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\tif (dquote) {\n\t\t\tfprintf(stderr, \"Error: unclosed quote found while parsing xephyr_extra_params\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tfor (i = 0; i < (int) strlen(xephyr_extra_params)-1; i++) {\n\t\t\tif (pos >= (sizeof(server_argv)/sizeof(*server_argv)) - 2) {\n\t\t\t\tfprintf(stderr, \"Error: arg count limit exceeded while parsing xephyr_extra_params\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (temp[i] == '\\0' && (temp[i+1] == '\\\"' || temp[i+1] == '\\'')) server_argv[pos++] = temp + i + 2;\n\t\t\telse if (temp[i] == '\\0' && temp[i+1] != '\\0') server_argv[pos++] = temp + i + 1;\n\t\t}\n\t}\n\t\n\tserver_argv[pos++] = display_str;\n\tserver_argv[pos++] = NULL;\n\n\tassert(pos < (sizeof(server_argv)/sizeof(*server_argv))); // no overrun\n\tassert(server_argv[pos-1] == NULL); // last element is null\n\t\n\tif (arg_debug) {\n\t\tsize_t i = 0;\n\t\tprintf(\"xephyr server:\");\n\t\twhile (server_argv[i]!=NULL) {\n\t\t\tprintf(\" \\\"%s\\\"\", server_argv[i]);\n\t\t\ti++;\n\t\t}\n\t\tputchar('\\n');\n\t}\n\n\t// remove --x11 arg\n\tchar *jail_argv[argc+2];\n\tint j = 0;\n\tfor (i = 0; i < argc; i++) {\n\t\tif (strcmp(argv[i], \"--x11\") == 0)\n\t\t\tcontinue;\n\t\tif (strcmp(argv[i], \"--x11=xpra\") == 0)\n\t\t\tcontinue;\n\t\tif (strcmp(argv[i], \"--x11=xephyr\") == 0)\n\t\t\tcontinue;\n\t\tjail_argv[j] = argv[i];\n\t\tj++;\n\t}\n\tjail_argv[j] = NULL;\n\n\tassert(j < argc+2); // no overrun\n\n\tif (arg_debug) {\n\t\tsize_t i = 0;\n\t\tprintf(\"xephyr client:\");\n\t\twhile (jail_argv[i]!=NULL) {\n\t\t\tprintf(\" \\\"%s\\\"\", jail_argv[i]);\n\t\t\ti++;\n\t\t}\n\t\tputchar('\\n');\n\t}\n\t\n\tserver = fork();\n\tif (server < 0)\n\t\terrExit(\"fork\");\n\tif (server == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Starting xephyr...\\n\");\n\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\t\n\t\texecvp(server_argv[0], server_argv);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\tif (arg_debug)\n\t\tprintf(\"xephyr server pid %d\\n\", server);\n\n\t// check X11 socket\n\tchar *fname;\n\tif (asprintf(&fname, \"/tmp/.X11-unix/X%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\tint n = 0;\n\t// wait for x11 server to start\n\twhile (++n < 10) {\n\t\tsleep(1);\n\t\tif (stat(fname, &s) == 0)\n\t\t\tbreak;\n\t};\n\t\n\tif (n == 10) {\n\t\tfprintf(stderr, \"Error: failed to start xephyr\\n\");\n\t\texit(1);\n\t}\n\tfree(fname);\n\t\n\tif (arg_debug) {\n            \tprintf(\"X11 sockets: \"); fflush(0);\n            \tint rv = system(\"ls /tmp/.X11-unix\");\n            \t(void) rv;\n\t}\n\n\tsetenv(\"DISPLAY\", display_str, 1);\n\t// run attach command\n\tjail = fork();\n\tif (jail < 0)\n\t\terrExit(\"fork\");\n\tif (jail == 0) {\n\t\tif (!arg_quiet)\n\t\t\tprintf(\"\\n*** Attaching to Xephyr display %d ***\\n\\n\", display);\n\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\t\n\t\texecvp(jail_argv[0], jail_argv);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\t// cleanup\n\tfree(display_str);\n\tfree(temp);\n\n\t// wait for either server or jail termination\n\tpid_t pid = wait(NULL);\n\n\t// see which process terminated and kill other\n\tif (pid == server) {\n\t\tkill(jail, SIGTERM);\n\t} else if (pid == jail) {\n\t\tkill(server, SIGTERM);\n\t}\n\n\t// without this closing Xephyr window may mess your terminal:\n\t// \"monitoring\" process will release terminal before\n\t// jail process ends and releases terminal\n\twait(NULL); // fulneral\n\n\texit(0);\n}",
    "includes": [
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "myexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/main.c",
          "lines": "137-149",
          "snippet": "static void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}",
          "includes": [
            "#include <sys/times.h>",
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int arg_command = 0;",
            "int arg_quiet = 0;",
            "pid_t sandbox_pid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/times.h>\n#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nint arg_command = 0;\nint arg_quiet = 0;\npid_t sandbox_pid;\n\nstatic void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}"
        }
      },
      {
        "call_info": {
          "callee": "wait",
          "args": [
            "NULL"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "wait_for_other",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/util.c",
          "lines": "541-569",
          "snippet": "void wait_for_other(int fd) {\n\t//****************************\n\t// wait for the parent to be initialized\n\t//****************************\n\tchar childstr[BUFLEN + 1];\n\tint newfd = dup(fd);\n\tif (newfd == -1)\n\t\terrExit(\"dup\");\n\tFILE* stream;\n\tstream = fdopen(newfd, \"r\");\n\t*childstr = '\\0';\n\tif (fgets(childstr, BUFLEN, stream)) {\n\t\t// remove \\n)\n\t\tchar *ptr = childstr;\n\t\twhile(*ptr !='\\0' && *ptr != '\\n')\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\terrExit(\"fgets\");\n\t\t*ptr = '\\0';\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: cannot establish communication with the parent, exiting...\\n\");\n\t\texit(1);\n\t}\n\tif (strcmp(childstr, \"arg_noroot=0\") == 0)\n\t\targ_noroot = 0;\n\n\tfclose(stream);\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define BUFLEN 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\n#define BUFLEN 4096\n\nvoid wait_for_other(int fd) {\n\t//****************************\n\t// wait for the parent to be initialized\n\t//****************************\n\tchar childstr[BUFLEN + 1];\n\tint newfd = dup(fd);\n\tif (newfd == -1)\n\t\terrExit(\"dup\");\n\tFILE* stream;\n\tstream = fdopen(newfd, \"r\");\n\t*childstr = '\\0';\n\tif (fgets(childstr, BUFLEN, stream)) {\n\t\t// remove \\n)\n\t\tchar *ptr = childstr;\n\t\twhile(*ptr !='\\0' && *ptr != '\\n')\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\terrExit(\"fgets\");\n\t\t*ptr = '\\0';\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: cannot establish communication with the parent, exiting...\\n\");\n\t\texit(1);\n\t}\n\tif (strcmp(childstr, \"arg_noroot=0\") == 0)\n\t\targ_noroot = 0;\n\n\tfclose(stream);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "server",
            "SIGTERM"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "jail",
            "SIGTERM"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "temp"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "display_str"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "1"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"execvp\""
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execvp",
          "args": [
            "jail_argv[0]",
            "jail_argv"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "getenv(\"LD_PRELOAD\") == NULL"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"LD_PRELOAD\""
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n*** Attaching to Xephyr display %d ***\\n\\n\"",
            "display"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fork\""
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"DISPLAY\"",
            "display_str",
            "1"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "system",
          "args": [
            "\"ls /tmp/.X11-unix\""
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "0"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"X11 sockets: \""
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: failed to start xephyr\\n\""
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "fname",
            "&s"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sleep",
          "args": [
            "1"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&fname",
            "\"/tmp/.X11-unix/X%d\"",
            "display"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"xephyr server pid %d\\n\"",
            "server"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "1"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"execvp\""
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execvp",
          "args": [
            "server_argv[0]",
            "server_argv"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "getenv(\"LD_PRELOAD\") == NULL"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"LD_PRELOAD\""
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Starting xephyr...\\n\""
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fork\""
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "putchar",
          "args": [
            "'\\n'"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" \\\"%s\\\"\"",
            "jail_argv[i]"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"xephyr client:\""
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "j < argc+2"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"--x11=xephyr\""
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"--x11=xpra\""
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"--x11\""
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "putchar",
          "args": [
            "'\\n'"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" \\\"%s\\\"\"",
            "server_argv[i]"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"xephyr server:\""
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "server_argv[pos-1] == NULL"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "pos < (sizeof(server_argv)/sizeof(*server_argv))"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: arg count limit exceeded while parsing xephyr_extra_params\\n\""
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "xephyr_extra_params"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: unclosed quote found while parsing xephyr_extra_params\\n\""
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: mixed quoting found while parsing xephyr_extra_params\\n\""
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "xephyr_extra_params"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"strdup\""
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "xephyr_extra_params"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "xephyr_extra_params"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "checkcfg",
          "args": [
            "CFG_XEPHYR_WINDOW_TITLE"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "checkcfg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/checkcfg.c",
          "lines": "32-286",
          "snippet": "int checkcfg(int val) {\n\tassert(val < CFG_MAX);\n\tint line = 0;\n\n\tif (!initialized) {\n\t\t// initialize defaults\n\t\tint i;\n\t\tfor (i = 0; i < CFG_MAX; i++)\n\t\t\tcfg_val[i] = 1; // most of them are enabled by default\n\t\tcfg_val[CFG_RESTRICTED_NETWORK] = 0; // disabled by default\n\t\tcfg_val[CFG_FORCE_NONEWPRIVS] = 0; // disabled by default\n\t\tcfg_val[CFG_PRIVATE_BIN_NO_LOCAL] = 0; // disabled by default\n\t\t\n\t\t// open configuration file\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"%s/firejail.config\", SYSCONFDIR) == -1)\n\t\t\terrExit(\"asprintf\");\n\n\t\tFILE *fp = fopen(fname, \"r\");\n\t\tif (!fp) {\n#ifdef HAVE_GLOBALCFG\t\t\t\n\t\t\tfprintf(stderr, \"Error: Firejail configuration file %s not found\\n\", fname);\n\t\t\texit(1);\n#else\n\t\t\tinitialized = 1;\n\t\t\treturn\tcfg_val[val];\n#endif\t\n\t\t}\n\t\t\n\t\t// if the file exists, it should be owned by root\n\t\tstruct stat s;\n\t\tif (stat(fname, &s) == -1)\n\t\t\terrExit(\"stat\");\n\t\tif (s.st_uid != 0) {\n\t\t\tfprintf(stderr, \"Error: configuration file should be owned by root\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\t// read configuration file\n\t\tchar buf[MAX_READ];\n\t\twhile (fgets(buf,MAX_READ, fp)) {\n\t\t\tline++;\n\t\t\tif (*buf == '#' || *buf == '\\n') \n\t\t\t\tcontinue;\n\n\t\t\t// parse line\t\t\t\t\n\t\t\tchar *ptr = line_remove_spaces(buf);\n\t\t\tif (!ptr)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\t// file transfer\t\n\t\t\tif (strncmp(ptr, \"file-transfer \", 14) == 0) {\n\t\t\t\tif (strcmp(ptr + 14, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_FILE_TRANSFER] = 1;\n\t\t\t\telse if (strcmp(ptr + 14, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_FILE_TRANSFER] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// x11\n\t\t\telse if (strncmp(ptr, \"x11 \", 4) == 0) {\n\t\t\t\tif (strcmp(ptr + 4, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_X11] = 1;\n\t\t\t\telse if (strcmp(ptr + 4, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_X11] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// bind\n\t\t\telse if (strncmp(ptr, \"bind \", 5) == 0) {\n\t\t\t\tif (strcmp(ptr + 5, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_BIND] = 1;\n\t\t\t\telse if (strcmp(ptr + 5, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_BIND] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// user namespace\n\t\t\telse if (strncmp(ptr, \"userns \", 7) == 0) {\n\t\t\t\tif (strcmp(ptr + 7, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_USERNS] = 1;\n\t\t\t\telse if (strcmp(ptr + 7, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_USERNS] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// chroot\n\t\t\telse if (strncmp(ptr, \"chroot \", 7) == 0) {\n\t\t\t\tif (strcmp(ptr + 7, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_CHROOT] = 1;\n\t\t\t\telse if (strcmp(ptr + 7, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_CHROOT] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// nonewprivs\n\t\t\telse if (strncmp(ptr, \"force-nonewprivs \", 17) == 0) {\n\t\t\t\tif (strcmp(ptr + 17, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_SECCOMP] = 1;\n\t\t\t\telse if (strcmp(ptr + 17, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_SECCOMP] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// seccomp\n\t\t\telse if (strncmp(ptr, \"seccomp \", 8) == 0) {\n\t\t\t\tif (strcmp(ptr + 8, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_SECCOMP] = 1;\n\t\t\t\telse if (strcmp(ptr + 8, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_SECCOMP] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// whitelist\n\t\t\telse if (strncmp(ptr, \"whitelist \", 10) == 0) {\n\t\t\t\tif (strcmp(ptr + 10, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_WHITELIST] = 1;\n\t\t\t\telse if (strcmp(ptr + 10, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_WHITELIST] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// network\n\t\t\telse if (strncmp(ptr, \"network \", 8) == 0) {\n\t\t\t\tif (strcmp(ptr + 8, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_NETWORK] = 1;\n\t\t\t\telse if (strcmp(ptr + 8, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_NETWORK] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// network\n\t\t\telse if (strncmp(ptr, \"restricted-network \", 19) == 0) {\n\t\t\t\tif (strcmp(ptr + 19, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_RESTRICTED_NETWORK] = 1;\n\t\t\t\telse if (strcmp(ptr + 19, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_RESTRICTED_NETWORK] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// netfilter\n\t\t\telse if (strncmp(ptr, \"netfilter-default \", 18) == 0) {\n\t\t\t\tchar *fname = ptr + 18;\n\t\t\t\twhile (*fname == ' ' || *fname == '\\t')\n\t\t\t\t\tptr++;\n\t\t\t\tchar *end = strchr(fname, ' ');\n\t\t\t\tif (end)\n\t\t\t\t\t*end = '\\0';\n\t\t\t\t\n\t\t\t\t// is the file present?\n\t\t\t\tstruct stat s;\n\t\t\t\tif (stat(fname, &s) == -1) {\n\t\t\t\t\tfprintf(stderr, \"Error: netfilter-default file %s not available\\n\", fname);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tnetfilter_default = strdup(fname);\n\t\t\t\tif (!netfilter_default)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t\tif (arg_debug)\n\t\t\t\t\tprintf(\"netfilter default file %s\\n\", fname);\n\t\t\t}\n\t\t\t\n\t\t\t// Xephyr screen size\n\t\t\telse if (strncmp(ptr, \"xephyr-screen \", 14) == 0) {\n\t\t\t\t// expecting two numbers and an x between them\n\t\t\t\tint n1;\n\t\t\t\tint n2;\n\t\t\t\tint rv = sscanf(ptr + 14, \"%dx%d\", &n1, &n2);\n\t\t\t\tif (rv != 2)\n\t\t\t\t\tgoto errout;\n\t\t\t\tif (asprintf(&xephyr_screen, \"%dx%d\", n1, n2) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t}\n\t\n\t\t\t// xephyr window title\n\t\t\telse if (strncmp(ptr, \"xephyr-window-title \", 20) == 0) {\n\t\t\t\tif (strcmp(ptr + 20, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_XEPHYR_WINDOW_TITLE] = 1;\n\t\t\t\telse if (strcmp(ptr + 20, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_XEPHYR_WINDOW_TITLE] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t\t\n\t\t\t// Xephyr command extra parameters\n\t\t\telse if (strncmp(ptr, \"xephyr-extra-params \", 19) == 0) {\n\t\t\t\txephyr_extra_params = strdup(ptr + 19);\n\t\t\t\tif (!xephyr_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\t\t\t\n\t\t\t// quiet by default\n\t\t\telse if (strncmp(ptr, \"quiet-by-default \", 17) == 0) {\n\t\t\t\tif (strcmp(ptr + 17, \"yes\") == 0)\n\t\t\t\t\targ_quiet = 1;\n\t\t\t}\n\t\t\t// remount /proc and /sys\n\t\t\telse if (strncmp(ptr, \"remount-proc-sys \", 17) == 0) {\n\t\t\t\tif (strcmp(ptr + 17, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_REMOUNT_PROC_SYS] = 1;\n\t\t\t\telse if (strcmp(ptr + 17, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_REMOUNT_PROC_SYS] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\telse if (strncmp(ptr, \"overlayfs \", 10) == 0) {\n\t\t\t\tif (strcmp(ptr + 10, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_OVERLAYFS] = 1;\n\t\t\t\telse if (strcmp(ptr + 10, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_OVERLAYFS] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\telse if (strncmp(ptr, \"private-home \", 13) == 0) {\n\t\t\t\tif (strcmp(ptr + 13, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_PRIVATE_HOME] = 1;\n\t\t\t\telse if (strcmp(ptr + 13, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_PRIVATE_HOME] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\telse if (strncmp(ptr, \"chroot-desktop \", 15) == 0) {\n\t\t\t\tif (strcmp(ptr + 15, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_CHROOT_DESKTOP] = 1;\n\t\t\t\telse if (strcmp(ptr + 15, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_CHROOT_DESKTOP] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\telse if (strncmp(ptr, \"private-bin-no-local \", 21) == 0) {\n\t\t\t\tif (strcmp(ptr + 21, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_PRIVATE_BIN_NO_LOCAL] = 1;\n\t\t\t\telse if (strcmp(ptr + 21, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_PRIVATE_BIN_NO_LOCAL] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\telse\n\t\t\t\tgoto errout;\n\n\t\t\tfree(ptr);\n\t\t}\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t\tinitialized = 1;\n\t}\n\t\n\treturn cfg_val[val];\n\t\nerrout:\n\tfprintf(stderr, \"Error: invalid line %d in firejail configuration file\\n\", line );\n\texit(1);\n}",
          "includes": [
            "#include <linux/loop.h>",
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAX_READ 8192\t\t\t\t  // line buffer for profile files"
          ],
          "globals_used": [
            "static int initialized = 0;",
            "static int cfg_val[CFG_MAX];",
            "char *xephyr_screen = \"800x600\";",
            "char *xephyr_extra_params = \"\";",
            "char *netfilter_default = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/loop.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\n#define MAX_READ 8192\t\t\t\t  // line buffer for profile files\n\nstatic int initialized = 0;\nstatic int cfg_val[CFG_MAX];\nchar *xephyr_screen = \"800x600\";\nchar *xephyr_extra_params = \"\";\nchar *netfilter_default = NULL;\n\nint checkcfg(int val) {\n\tassert(val < CFG_MAX);\n\tint line = 0;\n\n\tif (!initialized) {\n\t\t// initialize defaults\n\t\tint i;\n\t\tfor (i = 0; i < CFG_MAX; i++)\n\t\t\tcfg_val[i] = 1; // most of them are enabled by default\n\t\tcfg_val[CFG_RESTRICTED_NETWORK] = 0; // disabled by default\n\t\tcfg_val[CFG_FORCE_NONEWPRIVS] = 0; // disabled by default\n\t\tcfg_val[CFG_PRIVATE_BIN_NO_LOCAL] = 0; // disabled by default\n\t\t\n\t\t// open configuration file\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"%s/firejail.config\", SYSCONFDIR) == -1)\n\t\t\terrExit(\"asprintf\");\n\n\t\tFILE *fp = fopen(fname, \"r\");\n\t\tif (!fp) {\n#ifdef HAVE_GLOBALCFG\t\t\t\n\t\t\tfprintf(stderr, \"Error: Firejail configuration file %s not found\\n\", fname);\n\t\t\texit(1);\n#else\n\t\t\tinitialized = 1;\n\t\t\treturn\tcfg_val[val];\n#endif\t\n\t\t}\n\t\t\n\t\t// if the file exists, it should be owned by root\n\t\tstruct stat s;\n\t\tif (stat(fname, &s) == -1)\n\t\t\terrExit(\"stat\");\n\t\tif (s.st_uid != 0) {\n\t\t\tfprintf(stderr, \"Error: configuration file should be owned by root\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\t// read configuration file\n\t\tchar buf[MAX_READ];\n\t\twhile (fgets(buf,MAX_READ, fp)) {\n\t\t\tline++;\n\t\t\tif (*buf == '#' || *buf == '\\n') \n\t\t\t\tcontinue;\n\n\t\t\t// parse line\t\t\t\t\n\t\t\tchar *ptr = line_remove_spaces(buf);\n\t\t\tif (!ptr)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\t// file transfer\t\n\t\t\tif (strncmp(ptr, \"file-transfer \", 14) == 0) {\n\t\t\t\tif (strcmp(ptr + 14, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_FILE_TRANSFER] = 1;\n\t\t\t\telse if (strcmp(ptr + 14, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_FILE_TRANSFER] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// x11\n\t\t\telse if (strncmp(ptr, \"x11 \", 4) == 0) {\n\t\t\t\tif (strcmp(ptr + 4, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_X11] = 1;\n\t\t\t\telse if (strcmp(ptr + 4, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_X11] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// bind\n\t\t\telse if (strncmp(ptr, \"bind \", 5) == 0) {\n\t\t\t\tif (strcmp(ptr + 5, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_BIND] = 1;\n\t\t\t\telse if (strcmp(ptr + 5, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_BIND] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// user namespace\n\t\t\telse if (strncmp(ptr, \"userns \", 7) == 0) {\n\t\t\t\tif (strcmp(ptr + 7, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_USERNS] = 1;\n\t\t\t\telse if (strcmp(ptr + 7, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_USERNS] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// chroot\n\t\t\telse if (strncmp(ptr, \"chroot \", 7) == 0) {\n\t\t\t\tif (strcmp(ptr + 7, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_CHROOT] = 1;\n\t\t\t\telse if (strcmp(ptr + 7, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_CHROOT] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// nonewprivs\n\t\t\telse if (strncmp(ptr, \"force-nonewprivs \", 17) == 0) {\n\t\t\t\tif (strcmp(ptr + 17, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_SECCOMP] = 1;\n\t\t\t\telse if (strcmp(ptr + 17, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_SECCOMP] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// seccomp\n\t\t\telse if (strncmp(ptr, \"seccomp \", 8) == 0) {\n\t\t\t\tif (strcmp(ptr + 8, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_SECCOMP] = 1;\n\t\t\t\telse if (strcmp(ptr + 8, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_SECCOMP] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// whitelist\n\t\t\telse if (strncmp(ptr, \"whitelist \", 10) == 0) {\n\t\t\t\tif (strcmp(ptr + 10, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_WHITELIST] = 1;\n\t\t\t\telse if (strcmp(ptr + 10, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_WHITELIST] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// network\n\t\t\telse if (strncmp(ptr, \"network \", 8) == 0) {\n\t\t\t\tif (strcmp(ptr + 8, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_NETWORK] = 1;\n\t\t\t\telse if (strcmp(ptr + 8, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_NETWORK] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// network\n\t\t\telse if (strncmp(ptr, \"restricted-network \", 19) == 0) {\n\t\t\t\tif (strcmp(ptr + 19, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_RESTRICTED_NETWORK] = 1;\n\t\t\t\telse if (strcmp(ptr + 19, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_RESTRICTED_NETWORK] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// netfilter\n\t\t\telse if (strncmp(ptr, \"netfilter-default \", 18) == 0) {\n\t\t\t\tchar *fname = ptr + 18;\n\t\t\t\twhile (*fname == ' ' || *fname == '\\t')\n\t\t\t\t\tptr++;\n\t\t\t\tchar *end = strchr(fname, ' ');\n\t\t\t\tif (end)\n\t\t\t\t\t*end = '\\0';\n\t\t\t\t\n\t\t\t\t// is the file present?\n\t\t\t\tstruct stat s;\n\t\t\t\tif (stat(fname, &s) == -1) {\n\t\t\t\t\tfprintf(stderr, \"Error: netfilter-default file %s not available\\n\", fname);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tnetfilter_default = strdup(fname);\n\t\t\t\tif (!netfilter_default)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t\tif (arg_debug)\n\t\t\t\t\tprintf(\"netfilter default file %s\\n\", fname);\n\t\t\t}\n\t\t\t\n\t\t\t// Xephyr screen size\n\t\t\telse if (strncmp(ptr, \"xephyr-screen \", 14) == 0) {\n\t\t\t\t// expecting two numbers and an x between them\n\t\t\t\tint n1;\n\t\t\t\tint n2;\n\t\t\t\tint rv = sscanf(ptr + 14, \"%dx%d\", &n1, &n2);\n\t\t\t\tif (rv != 2)\n\t\t\t\t\tgoto errout;\n\t\t\t\tif (asprintf(&xephyr_screen, \"%dx%d\", n1, n2) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t}\n\t\n\t\t\t// xephyr window title\n\t\t\telse if (strncmp(ptr, \"xephyr-window-title \", 20) == 0) {\n\t\t\t\tif (strcmp(ptr + 20, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_XEPHYR_WINDOW_TITLE] = 1;\n\t\t\t\telse if (strcmp(ptr + 20, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_XEPHYR_WINDOW_TITLE] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t\t\n\t\t\t// Xephyr command extra parameters\n\t\t\telse if (strncmp(ptr, \"xephyr-extra-params \", 19) == 0) {\n\t\t\t\txephyr_extra_params = strdup(ptr + 19);\n\t\t\t\tif (!xephyr_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\t\t\t\n\t\t\t// quiet by default\n\t\t\telse if (strncmp(ptr, \"quiet-by-default \", 17) == 0) {\n\t\t\t\tif (strcmp(ptr + 17, \"yes\") == 0)\n\t\t\t\t\targ_quiet = 1;\n\t\t\t}\n\t\t\t// remount /proc and /sys\n\t\t\telse if (strncmp(ptr, \"remount-proc-sys \", 17) == 0) {\n\t\t\t\tif (strcmp(ptr + 17, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_REMOUNT_PROC_SYS] = 1;\n\t\t\t\telse if (strcmp(ptr + 17, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_REMOUNT_PROC_SYS] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\telse if (strncmp(ptr, \"overlayfs \", 10) == 0) {\n\t\t\t\tif (strcmp(ptr + 10, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_OVERLAYFS] = 1;\n\t\t\t\telse if (strcmp(ptr + 10, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_OVERLAYFS] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\telse if (strncmp(ptr, \"private-home \", 13) == 0) {\n\t\t\t\tif (strcmp(ptr + 13, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_PRIVATE_HOME] = 1;\n\t\t\t\telse if (strcmp(ptr + 13, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_PRIVATE_HOME] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\telse if (strncmp(ptr, \"chroot-desktop \", 15) == 0) {\n\t\t\t\tif (strcmp(ptr + 15, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_CHROOT_DESKTOP] = 1;\n\t\t\t\telse if (strcmp(ptr + 15, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_CHROOT_DESKTOP] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\telse if (strncmp(ptr, \"private-bin-no-local \", 21) == 0) {\n\t\t\t\tif (strcmp(ptr + 21, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_PRIVATE_BIN_NO_LOCAL] = 1;\n\t\t\t\telse if (strcmp(ptr + 21, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_PRIVATE_BIN_NO_LOCAL] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\telse\n\t\t\t\tgoto errout;\n\n\t\t\tfree(ptr);\n\t\t}\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t\tinitialized = 1;\n\t}\n\t\n\treturn cfg_val[val];\n\t\nerrout:\n\tfprintf(stderr, \"Error: invalid line %d in firejail configuration file\\n\", line );\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "xephyr_screen"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&display_str",
            "\":%d\"",
            "display"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "random_display_number",
          "args": [],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "random_display_number",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/x11.c",
          "lines": "80-103",
          "snippet": "static int random_display_number(void) {\n\tint i;\n\tint found = 1;\n\tint display;\n\tfor (i = 0; i < 100; i++) {\n\t\tdisplay = rand() % 1024;\n\t\tif (display < 10)\n\t\t\tcontinue;\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/tmp/.X11-unix/X%d\", display) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tstruct stat s;\n\t\tif (stat(fname, &s) == -1) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found) {\n\t\tfprintf(stderr, \"Error: cannot pick up a random X11 display number, exiting...\\n\");\n\t\texit(1);\n\t}\n\t\n\treturn display;\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <sys/mount.h>\n#include <dirent.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nstatic int random_display_number(void) {\n\tint i;\n\tint found = 1;\n\tint display;\n\tfor (i = 0; i < 100; i++) {\n\t\tdisplay = rand() % 1024;\n\t\tif (display < 10)\n\t\t\tcontinue;\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/tmp/.X11-unix/X%d\", display) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tstruct stat s;\n\t\tif (stat(fname, &s) == -1) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found) {\n\t\tfprintf(stderr, \"Error: cannot pick up a random X11 display number, exiting...\\n\");\n\t\texit(1);\n\t}\n\t\n\treturn display;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"   Arch: sudo pacman -S xorg-server-xephyr\\n\""
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"   Debian/Ubuntu/Mint: sudo apt-get install xserver-xephyr\\n\""
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"\\nError: Xephyr program was not found in /usr/bin directory, please install it:\\n\""
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x11_check_xephyr",
          "args": [],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "x11_check_xephyr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/x11.c",
          "lines": "45-53",
          "snippet": "static int x11_check_xephyr(void) {\n\tstruct stat s;\n\t\n\t// check xephyr\n\tif (stat(\"/usr/bin/Xephyr\", &s) == -1)\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <sys/mount.h>\n#include <dirent.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nstatic int x11_check_xephyr(void) {\n\tstruct stat s;\n\t\n\t// check xephyr\n\tif (stat(\"/usr/bin/Xephyr\", &s) == -1)\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_privs",
          "args": [
            "0"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "drop_privs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/util.c",
          "lines": "36-81",
          "snippet": "void drop_privs(int nogroups) {\n\tEUID_ROOT();\n\tgid_t gid = getgid();\n\n\t// configure supplementary groups\n\tif (gid == 0 || nogroups) {\n\t\tif (setgroups(0, NULL) < 0)\n\t\t\terrExit(\"setgroups\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Username %s, no supplementary groups\\n\", cfg.username);\n\t}\n\telse {\n\t\tassert(cfg.username);\n\t\tgid_t groups[MAX_GROUPS];\n\t\tint ngroups = MAX_GROUPS;\n\t\tint rv = getgrouplist(cfg.username, gid, groups, &ngroups);\n\n\t\tif (arg_debug && rv) {\n\t\t\tprintf(\"Username %s, groups \", cfg.username);\n\t\t\tint i;\n\t\t\tfor (i = 0; i < ngroups; i++)\n\t\t\t\tprintf(\"%u, \", groups[i]);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\n\t\tif (rv == -1) {\n\t\t\tfprintf(stderr, \"Warning: cannot extract supplementary group list, dropping them\\n\");\n\t\t\tif (setgroups(0, NULL) < 0)\n\t\t\t\terrExit(\"setgroups\");\n\t\t}\n\t\telse {\n\t\t\trv = setgroups(ngroups, groups);\n\t\t\tif (rv) {\n\t\t\t\tfprintf(stderr, \"Warning: cannot set supplementary group list, dropping them\\n\");\n\t\t\t\tif (setgroups(0, NULL) < 0)\n\t\t\t\t\terrExit(\"setgroups\");\n\t\t\t}\n\t\t}\n\t}\n\n\t// set uid/gid\n\tif (setgid(getgid()) < 0)\n\t\terrExit(\"setgid/getgid\");\n\tif (setuid(getuid()) < 0)\n\t\terrExit(\"setuid/getuid\");\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAX_GROUPS 1024"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\n#define MAX_GROUPS 1024\n\nvoid drop_privs(int nogroups) {\n\tEUID_ROOT();\n\tgid_t gid = getgid();\n\n\t// configure supplementary groups\n\tif (gid == 0 || nogroups) {\n\t\tif (setgroups(0, NULL) < 0)\n\t\t\terrExit(\"setgroups\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Username %s, no supplementary groups\\n\", cfg.username);\n\t}\n\telse {\n\t\tassert(cfg.username);\n\t\tgid_t groups[MAX_GROUPS];\n\t\tint ngroups = MAX_GROUPS;\n\t\tint rv = getgrouplist(cfg.username, gid, groups, &ngroups);\n\n\t\tif (arg_debug && rv) {\n\t\t\tprintf(\"Username %s, groups \", cfg.username);\n\t\t\tint i;\n\t\t\tfor (i = 0; i < ngroups; i++)\n\t\t\t\tprintf(\"%u, \", groups[i]);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\n\t\tif (rv == -1) {\n\t\t\tfprintf(stderr, \"Warning: cannot extract supplementary group list, dropping them\\n\");\n\t\t\tif (setgroups(0, NULL) < 0)\n\t\t\t\terrExit(\"setgroups\");\n\t\t}\n\t\telse {\n\t\t\trv = setgroups(ngroups, groups);\n\t\t\tif (rv) {\n\t\t\t\tfprintf(stderr, \"Warning: cannot set supplementary group list, dropping them\\n\");\n\t\t\t\tif (setgroups(0, NULL) < 0)\n\t\t\t\t\terrExit(\"setgroups\");\n\t\t\t}\n\t\t}\n\t}\n\n\t// set uid/gid\n\tif (setgid(getgid()) < 0)\n\t\terrExit(\"setgid/getgid\");\n\tif (setuid(getuid()) < 0)\n\t\terrExit(\"setuid/getuid\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: X11 sandboxing is not available when running as root\\n\""
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"FIREJAIL_X11\"",
            "\"yes\"",
            "1"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/wait.h>\n#include <sys/mount.h>\n#include <dirent.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid x11_start_xephyr(int argc, char **argv) {\n\tEUID_ASSERT();\n\tint i;\n\tstruct stat s;\n\tpid_t jail = 0;\n\tpid_t server = 0;\n\t\n\tsetenv(\"FIREJAIL_X11\", \"yes\", 1);\n\n\t// unfortunately, xephyr does a number of weird things when started by root user!!!\n\tif (getuid() == 0) {\n\t\tfprintf(stderr, \"Error: X11 sandboxing is not available when running as root\\n\");\n\t\texit(1);\n\t}\n\tdrop_privs(0);\n\n\t// check xephyr\n\tif (x11_check_xephyr() == 0) {\n\t\tfprintf(stderr, \"\\nError: Xephyr program was not found in /usr/bin directory, please install it:\\n\");\n\t\tfprintf(stderr, \"   Debian/Ubuntu/Mint: sudo apt-get install xserver-xephyr\\n\");\n\t\tfprintf(stderr, \"   Arch: sudo pacman -S xorg-server-xephyr\\n\");\n\t\texit(0);\n\t}\n\t\n\tint display = random_display_number();\n\tchar *display_str;\n\tif (asprintf(&display_str, \":%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\n\tassert(xephyr_screen);\n\tchar *server_argv[256] = { \"Xephyr\", \"-ac\", \"-br\", \"-noreset\", \"-screen\", xephyr_screen }; // rest initialyzed to NULL\n\tunsigned pos = 0;\n\twhile (server_argv[pos] != NULL) pos++;\n\tif (checkcfg(CFG_XEPHYR_WINDOW_TITLE)) {\n\t\tserver_argv[pos++] = \"-title\";\n\t\tserver_argv[pos++] = \"firejail x11 sandbox\";\n\t}\n\n\tassert(xephyr_extra_params); // should be \"\" if empty\n\n\t// parse xephyr_extra_params\n\t// very basic quoting support\n\tchar *temp = strdup(xephyr_extra_params);\n\tif (*xephyr_extra_params != '\\0') {\n\t\tif (!temp)\n\t\t\terrExit(\"strdup\");\n\t\tbool dquote = false;\n\t\tbool squote = false;\n\t\tfor (i = 0; i < (int) strlen(xephyr_extra_params); i++) {\n\t\t\tif (temp[i] == '\\\"') {\n\t\t\t\tdquote = !dquote;\n\t\t\t\tif (dquote) temp[i] = '\\0'; // replace closing quote by \\0\n\t\t\t}\n\t\t\tif (temp[i] == '\\'') {\n\t\t\t\tsquote = !squote;\n\t\t\t\tif (squote) temp[i] = '\\0'; // replace closing quote by \\0\n\t\t\t}\n\t\t\tif (!dquote && !squote && temp[i] == ' ') temp[i] = '\\0';\n\t\t\tif (dquote && squote) {\n\t\t\t\tfprintf(stderr, \"Error: mixed quoting found while parsing xephyr_extra_params\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\tif (dquote) {\n\t\t\tfprintf(stderr, \"Error: unclosed quote found while parsing xephyr_extra_params\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tfor (i = 0; i < (int) strlen(xephyr_extra_params)-1; i++) {\n\t\t\tif (pos >= (sizeof(server_argv)/sizeof(*server_argv)) - 2) {\n\t\t\t\tfprintf(stderr, \"Error: arg count limit exceeded while parsing xephyr_extra_params\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (temp[i] == '\\0' && (temp[i+1] == '\\\"' || temp[i+1] == '\\'')) server_argv[pos++] = temp + i + 2;\n\t\t\telse if (temp[i] == '\\0' && temp[i+1] != '\\0') server_argv[pos++] = temp + i + 1;\n\t\t}\n\t}\n\t\n\tserver_argv[pos++] = display_str;\n\tserver_argv[pos++] = NULL;\n\n\tassert(pos < (sizeof(server_argv)/sizeof(*server_argv))); // no overrun\n\tassert(server_argv[pos-1] == NULL); // last element is null\n\t\n\tif (arg_debug) {\n\t\tsize_t i = 0;\n\t\tprintf(\"xephyr server:\");\n\t\twhile (server_argv[i]!=NULL) {\n\t\t\tprintf(\" \\\"%s\\\"\", server_argv[i]);\n\t\t\ti++;\n\t\t}\n\t\tputchar('\\n');\n\t}\n\n\t// remove --x11 arg\n\tchar *jail_argv[argc+2];\n\tint j = 0;\n\tfor (i = 0; i < argc; i++) {\n\t\tif (strcmp(argv[i], \"--x11\") == 0)\n\t\t\tcontinue;\n\t\tif (strcmp(argv[i], \"--x11=xpra\") == 0)\n\t\t\tcontinue;\n\t\tif (strcmp(argv[i], \"--x11=xephyr\") == 0)\n\t\t\tcontinue;\n\t\tjail_argv[j] = argv[i];\n\t\tj++;\n\t}\n\tjail_argv[j] = NULL;\n\n\tassert(j < argc+2); // no overrun\n\n\tif (arg_debug) {\n\t\tsize_t i = 0;\n\t\tprintf(\"xephyr client:\");\n\t\twhile (jail_argv[i]!=NULL) {\n\t\t\tprintf(\" \\\"%s\\\"\", jail_argv[i]);\n\t\t\ti++;\n\t\t}\n\t\tputchar('\\n');\n\t}\n\t\n\tserver = fork();\n\tif (server < 0)\n\t\terrExit(\"fork\");\n\tif (server == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Starting xephyr...\\n\");\n\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\t\n\t\texecvp(server_argv[0], server_argv);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\tif (arg_debug)\n\t\tprintf(\"xephyr server pid %d\\n\", server);\n\n\t// check X11 socket\n\tchar *fname;\n\tif (asprintf(&fname, \"/tmp/.X11-unix/X%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\tint n = 0;\n\t// wait for x11 server to start\n\twhile (++n < 10) {\n\t\tsleep(1);\n\t\tif (stat(fname, &s) == 0)\n\t\t\tbreak;\n\t};\n\t\n\tif (n == 10) {\n\t\tfprintf(stderr, \"Error: failed to start xephyr\\n\");\n\t\texit(1);\n\t}\n\tfree(fname);\n\t\n\tif (arg_debug) {\n            \tprintf(\"X11 sockets: \"); fflush(0);\n            \tint rv = system(\"ls /tmp/.X11-unix\");\n            \t(void) rv;\n\t}\n\n\tsetenv(\"DISPLAY\", display_str, 1);\n\t// run attach command\n\tjail = fork();\n\tif (jail < 0)\n\t\terrExit(\"fork\");\n\tif (jail == 0) {\n\t\tif (!arg_quiet)\n\t\t\tprintf(\"\\n*** Attaching to Xephyr display %d ***\\n\\n\", display);\n\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\t\n\t\texecvp(jail_argv[0], jail_argv);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\t// cleanup\n\tfree(display_str);\n\tfree(temp);\n\n\t// wait for either server or jail termination\n\tpid_t pid = wait(NULL);\n\n\t// see which process terminated and kill other\n\tif (pid == server) {\n\t\tkill(jail, SIGTERM);\n\t} else if (pid == jail) {\n\t\tkill(server, SIGTERM);\n\t}\n\n\t// without this closing Xephyr window may mess your terminal:\n\t// \"monitoring\" process will release terminal before\n\t// jail process ends and releases terminal\n\twait(NULL); // fulneral\n\n\texit(0);\n}"
  },
  {
    "function_name": "fs_x11",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/x11.c",
    "lines": "123-181",
    "snippet": "void fs_x11(void) {\n#ifdef HAVE_X11\n\tint display = x11_display();\n\tif (display <= 0)\n\t\treturn;\n\n\tchar *x11file;\n\tif (asprintf(&x11file, \"/tmp/.X11-unix/X%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\tstruct stat s;\n\tif (stat(x11file, &s) == -1)\n\t\treturn;\n\n\t// keep a copy of real /tmp/.X11-unix directory in WHITELIST_TMP_DIR\n\tint rv = mkdir(RUN_WHITELIST_X11_DIR, 1777);\n\tif (rv == -1)\n\t\terrExit(\"mkdir\");\n\tif (chown(RUN_WHITELIST_X11_DIR, 0, 0) < 0)\n\t\terrExit(\"chown\");\n\tif (chmod(RUN_WHITELIST_X11_DIR, 1777) < 0)\n\t\terrExit(\"chmod\");\n\n\tif (mount(\"/tmp/.X11-unix\", RUN_WHITELIST_X11_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\n\t// mount tmpfs on /tmp/.X11-unix\n\tif (arg_debug || arg_debug_whitelists)\n\t\tprintf(\"Mounting tmpfs on /tmp/.X11-unix directory\\n\");\n\tif (mount(\"tmpfs\", \"/tmp/.X11-unix\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME | MS_REC,  \"mode=1777,gid=0\") < 0)\n\t\terrExit(\"mounting tmpfs on /tmp\");\n\tfs_logger(\"tmpfs /tmp/.X11-unix\");\n\n\t// create an empty file\n\tFILE *fp = fopen(x11file, \"w\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: cannot create empty file in x11 directory\\n\");\n\t\texit(1);\n\t}\n\t// set file properties\n\tSET_PERMS_STREAM(fp, s.st_uid, s.st_gid, s.st_mode);\n\tfclose(fp);\n\n\t// mount\n\tchar *wx11file;\n\tif (asprintf(&wx11file, \"%s/X%d\", RUN_WHITELIST_X11_DIR, display) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(wx11file, x11file, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\t fs_logger2(\"whitelist\", x11file);\n\n\tfree(x11file);\n\tfree(wx11file);\n\t\n\t// block access to RUN_WHITELIST_X11_DIR\n\t if (mount(RUN_RO_DIR, RUN_WHITELIST_X11_DIR, \"none\", MS_BIND, \"mode=400,gid=0\") == -1)\n\t \terrExit(\"mount\");\n\t fs_logger2(\"blacklist\", RUN_WHITELIST_X11_DIR);\n#endif\n}",
    "includes": [
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_logger2",
          "args": [
            "\"blacklist\"",
            "RUN_WHITELIST_X11_DIR"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger2int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_logger.c",
          "lines": "73-80",
          "snippet": "void fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount\""
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "RUN_RO_DIR",
            "RUN_WHITELIST_X11_DIR",
            "\"none\"",
            "MS_BIND",
            "\"mode=400,gid=0\""
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "wx11file"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "x11file"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount bind\""
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "wx11file",
            "x11file",
            "NULL",
            "MS_BIND|MS_REC",
            "NULL"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&wx11file",
            "\"%s/X%d\"",
            "RUN_WHITELIST_X11_DIR",
            "display"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_PERMS_STREAM",
          "args": [
            "fp",
            "s.st_uid",
            "s.st_gid",
            "s.st_mode"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "myexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/main.c",
          "lines": "137-149",
          "snippet": "static void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}",
          "includes": [
            "#include <sys/times.h>",
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int arg_command = 0;",
            "int arg_quiet = 0;",
            "pid_t sandbox_pid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/times.h>\n#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nint arg_command = 0;\nint arg_quiet = 0;\npid_t sandbox_pid;\n\nstatic void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot create empty file in x11 directory\\n\""
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "x11file",
            "\"w\""
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_logger",
          "args": [
            "\"tmpfs /tmp/.X11-unix\""
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger_print_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_logger.c",
          "lines": "136-189",
          "snippet": "void fs_logger_print_log(pid_t pid) {\n\tEUID_ASSERT();\n\n\t// if the pid is that of a firejail  process, use the pid of the first child process\n\tEUID_ROOT();\n\tchar *comm = pid_proc_comm(pid);\n\tEUID_USER();\n\tif (comm) {\n\t\tif (strcmp(comm, \"firejail\") == 0) {\n\t\t\tpid_t child;\n\t\t\tif (find_child(pid, &child) == 0) {\n\t\t\t\tpid = child;\n\t\t\t}\n\t\t}\n\t\tfree(comm);\n\t}\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission denied\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// print RUN_FSLOGGER_FILE\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_FSLOGGER_FILE) == -1)\n\t\terrExit(\"asprintf\");\n\n\tEUID_ROOT();\n\tstruct stat s;\n\tif (stat(fname, &s) == -1) {\n\t\tfprintf(stderr, \"Error: Cannot access filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: Cannot open filesystem log\\n\");\n\t\texit(1);\n\t}\n\t\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp))\n\t\tprintf(\"%s\", buf);\n\tfclose(fp);\n\tfree(fname);\n\n\texit(0);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAXBUF 4098"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\n#define MAXBUF 4098\n\nvoid fs_logger_print_log(pid_t pid) {\n\tEUID_ASSERT();\n\n\t// if the pid is that of a firejail  process, use the pid of the first child process\n\tEUID_ROOT();\n\tchar *comm = pid_proc_comm(pid);\n\tEUID_USER();\n\tif (comm) {\n\t\tif (strcmp(comm, \"firejail\") == 0) {\n\t\t\tpid_t child;\n\t\t\tif (find_child(pid, &child) == 0) {\n\t\t\t\tpid = child;\n\t\t\t}\n\t\t}\n\t\tfree(comm);\n\t}\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission denied\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// print RUN_FSLOGGER_FILE\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_FSLOGGER_FILE) == -1)\n\t\terrExit(\"asprintf\");\n\n\tEUID_ROOT();\n\tstruct stat s;\n\tif (stat(fname, &s) == -1) {\n\t\tfprintf(stderr, \"Error: Cannot access filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: Cannot open filesystem log\\n\");\n\t\texit(1);\n\t}\n\t\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp))\n\t\tprintf(\"%s\", buf);\n\tfclose(fp);\n\tfree(fname);\n\n\texit(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mounting tmpfs on /tmp\""
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"tmpfs\"",
            "\"/tmp/.X11-unix\"",
            "\"tmpfs\"",
            "MS_NOSUID | MS_STRICTATIME | MS_REC",
            "\"mode=1777,gid=0\""
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Mounting tmpfs on /tmp/.X11-unix directory\\n\""
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount bind\""
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"/tmp/.X11-unix\"",
            "RUN_WHITELIST_X11_DIR",
            "NULL",
            "MS_BIND|MS_REC",
            "NULL"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"chmod\""
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chmod",
          "args": [
            "RUN_WHITELIST_X11_DIR",
            "1777"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"chown\""
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chown",
          "args": [
            "RUN_WHITELIST_X11_DIR",
            "0",
            "0"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mkdir\""
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "RUN_WHITELIST_X11_DIR",
            "1777"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "x11file",
            "&s"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&x11file",
            "\"/tmp/.X11-unix/X%d\"",
            "display"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x11_display",
          "args": [],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "x11_display",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/x11.c",
          "lines": "107-121",
          "snippet": "int x11_display(void) {\n\t// extract display\n\tchar *d = getenv(\"DISPLAY\");\n\tif (!d)\n\t\treturn - 1;\n\t\n\tint display;\n\tint rv = sscanf(d, \":%d\", &display);\n\tif (rv != 1)\n\t\treturn -1;\n\tif (arg_debug)\n\t\tprintf(\"DISPLAY %s, %d\\n\", d, display);\n\t\n\treturn display;\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <sys/mount.h>\n#include <dirent.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nint x11_display(void) {\n\t// extract display\n\tchar *d = getenv(\"DISPLAY\");\n\tif (!d)\n\t\treturn - 1;\n\t\n\tint display;\n\tint rv = sscanf(d, \":%d\", &display);\n\tif (rv != 1)\n\t\treturn -1;\n\tif (arg_debug)\n\t\tprintf(\"DISPLAY %s, %d\\n\", d, display);\n\t\n\treturn display;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/wait.h>\n#include <sys/mount.h>\n#include <dirent.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid fs_x11(void) {\n#ifdef HAVE_X11\n\tint display = x11_display();\n\tif (display <= 0)\n\t\treturn;\n\n\tchar *x11file;\n\tif (asprintf(&x11file, \"/tmp/.X11-unix/X%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\tstruct stat s;\n\tif (stat(x11file, &s) == -1)\n\t\treturn;\n\n\t// keep a copy of real /tmp/.X11-unix directory in WHITELIST_TMP_DIR\n\tint rv = mkdir(RUN_WHITELIST_X11_DIR, 1777);\n\tif (rv == -1)\n\t\terrExit(\"mkdir\");\n\tif (chown(RUN_WHITELIST_X11_DIR, 0, 0) < 0)\n\t\terrExit(\"chown\");\n\tif (chmod(RUN_WHITELIST_X11_DIR, 1777) < 0)\n\t\terrExit(\"chmod\");\n\n\tif (mount(\"/tmp/.X11-unix\", RUN_WHITELIST_X11_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\n\t// mount tmpfs on /tmp/.X11-unix\n\tif (arg_debug || arg_debug_whitelists)\n\t\tprintf(\"Mounting tmpfs on /tmp/.X11-unix directory\\n\");\n\tif (mount(\"tmpfs\", \"/tmp/.X11-unix\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME | MS_REC,  \"mode=1777,gid=0\") < 0)\n\t\terrExit(\"mounting tmpfs on /tmp\");\n\tfs_logger(\"tmpfs /tmp/.X11-unix\");\n\n\t// create an empty file\n\tFILE *fp = fopen(x11file, \"w\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: cannot create empty file in x11 directory\\n\");\n\t\texit(1);\n\t}\n\t// set file properties\n\tSET_PERMS_STREAM(fp, s.st_uid, s.st_gid, s.st_mode);\n\tfclose(fp);\n\n\t// mount\n\tchar *wx11file;\n\tif (asprintf(&wx11file, \"%s/X%d\", RUN_WHITELIST_X11_DIR, display) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(wx11file, x11file, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\t fs_logger2(\"whitelist\", x11file);\n\n\tfree(x11file);\n\tfree(wx11file);\n\t\n\t// block access to RUN_WHITELIST_X11_DIR\n\t if (mount(RUN_RO_DIR, RUN_WHITELIST_X11_DIR, \"none\", MS_BIND, \"mode=400,gid=0\") == -1)\n\t \terrExit(\"mount\");\n\t fs_logger2(\"blacklist\", RUN_WHITELIST_X11_DIR);\n#endif\n}"
  },
  {
    "function_name": "x11_display",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/x11.c",
    "lines": "107-121",
    "snippet": "int x11_display(void) {\n\t// extract display\n\tchar *d = getenv(\"DISPLAY\");\n\tif (!d)\n\t\treturn - 1;\n\t\n\tint display;\n\tint rv = sscanf(d, \":%d\", &display);\n\tif (rv != 1)\n\t\treturn -1;\n\tif (arg_debug)\n\t\tprintf(\"DISPLAY %s, %d\\n\", d, display);\n\t\n\treturn display;\n}",
    "includes": [
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"DISPLAY %s, %d\\n\"",
            "d",
            "display"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "d",
            "\":%d\"",
            "&display"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"DISPLAY\""
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/wait.h>\n#include <sys/mount.h>\n#include <dirent.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nint x11_display(void) {\n\t// extract display\n\tchar *d = getenv(\"DISPLAY\");\n\tif (!d)\n\t\treturn - 1;\n\t\n\tint display;\n\tint rv = sscanf(d, \":%d\", &display);\n\tif (rv != 1)\n\t\treturn -1;\n\tif (arg_debug)\n\t\tprintf(\"DISPLAY %s, %d\\n\", d, display);\n\t\n\treturn display;\n}"
  },
  {
    "function_name": "random_display_number",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/x11.c",
    "lines": "80-103",
    "snippet": "static int random_display_number(void) {\n\tint i;\n\tint found = 1;\n\tint display;\n\tfor (i = 0; i < 100; i++) {\n\t\tdisplay = rand() % 1024;\n\t\tif (display < 10)\n\t\t\tcontinue;\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/tmp/.X11-unix/X%d\", display) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tstruct stat s;\n\t\tif (stat(fname, &s) == -1) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found) {\n\t\tfprintf(stderr, \"Error: cannot pick up a random X11 display number, exiting...\\n\");\n\t\texit(1);\n\t}\n\t\n\treturn display;\n}",
    "includes": [
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "myexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/main.c",
          "lines": "137-149",
          "snippet": "static void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}",
          "includes": [
            "#include <sys/times.h>",
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int arg_command = 0;",
            "int arg_quiet = 0;",
            "pid_t sandbox_pid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/times.h>\n#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nint arg_command = 0;\nint arg_quiet = 0;\npid_t sandbox_pid;\n\nstatic void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot pick up a random X11 display number, exiting...\\n\""
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "fname",
            "&s"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&fname",
            "\"/tmp/.X11-unix/X%d\"",
            "display"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rand",
          "args": [],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "random_display_number",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/x11.c",
          "lines": "80-103",
          "snippet": "static int random_display_number(void) {\n\tint i;\n\tint found = 1;\n\tint display;\n\tfor (i = 0; i < 100; i++) {\n\t\tdisplay = rand() % 1024;\n\t\tif (display < 10)\n\t\t\tcontinue;\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/tmp/.X11-unix/X%d\", display) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tstruct stat s;\n\t\tif (stat(fname, &s) == -1) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found) {\n\t\tfprintf(stderr, \"Error: cannot pick up a random X11 display number, exiting...\\n\");\n\t\texit(1);\n\t}\n\t\n\treturn display;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <sys/wait.h>\n#include <sys/mount.h>\n#include <dirent.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nstatic int random_display_number(void) {\n\tint i;\n\tint found = 1;\n\tint display;\n\tfor (i = 0; i < 100; i++) {\n\t\tdisplay = rand() % 1024;\n\t\tif (display < 10)\n\t\t\tcontinue;\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/tmp/.X11-unix/X%d\", display) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tstruct stat s;\n\t\tif (stat(fname, &s) == -1) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found) {\n\t\tfprintf(stderr, \"Error: cannot pick up a random X11 display number, exiting...\\n\");\n\t\texit(1);\n\t}\n\t\n\treturn display;\n}"
  },
  {
    "function_name": "x11_abstract_sockets_present",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/x11.c",
    "lines": "56-78",
    "snippet": "static int x11_abstract_sockets_present(void) {\n\tchar *path;\n\n\tEUID_ROOT(); // grsecurity fix\n\tFILE *fp = fopen(\"/proc/net/unix\", \"r\");\n\tEUID_USER();\n\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\n\twhile (fscanf(fp, \"%*s %*s %*s %*s %*s %*s %*s %ms\\n\", &path) != EOF) {\n\t\tif (path && strncmp(path, \"@/tmp/.X11-unix/\", 16) == 0) {\n\t\t\tfree(path);\n\t\t\tfclose(fp);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tfree(path);\n\tfclose(fp);\n\n\treturn 0;\n}",
    "includes": [
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "path"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "path"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "path",
            "\"@/tmp/.X11-unix/\"",
            "16"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscanf",
          "args": [
            "fp",
            "\"%*s %*s %*s %*s %*s %*s %*s %ms\\n\"",
            "&path"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fopen\""
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_USER",
          "args": [],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "\"/proc/net/unix\"",
            "\"r\""
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ROOT",
          "args": [],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/wait.h>\n#include <sys/mount.h>\n#include <dirent.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nstatic int x11_abstract_sockets_present(void) {\n\tchar *path;\n\n\tEUID_ROOT(); // grsecurity fix\n\tFILE *fp = fopen(\"/proc/net/unix\", \"r\");\n\tEUID_USER();\n\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\n\twhile (fscanf(fp, \"%*s %*s %*s %*s %*s %*s %*s %ms\\n\", &path) != EOF) {\n\t\tif (path && strncmp(path, \"@/tmp/.X11-unix/\", 16) == 0) {\n\t\t\tfree(path);\n\t\t\tfclose(fp);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tfree(path);\n\tfclose(fp);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "x11_check_xephyr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/x11.c",
    "lines": "45-53",
    "snippet": "static int x11_check_xephyr(void) {\n\tstruct stat s;\n\t\n\t// check xephyr\n\tif (stat(\"/usr/bin/Xephyr\", &s) == -1)\n\t\treturn 0;\n\n\treturn 1;\n}",
    "includes": [
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "\"/usr/bin/Xephyr\"",
            "&s"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/wait.h>\n#include <sys/mount.h>\n#include <dirent.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nstatic int x11_check_xephyr(void) {\n\tstruct stat s;\n\t\n\t// check xephyr\n\tif (stat(\"/usr/bin/Xephyr\", &s) == -1)\n\t\treturn 0;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "x11_check_xpra",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/x11.c",
    "lines": "34-42",
    "snippet": "static int x11_check_xpra(void) {\n\tstruct stat s;\n\t\n\t// check xpra\n\tif (stat(\"/usr/bin/xpra\", &s) == -1)\n\t\treturn 0;\n\n\treturn 1;\n}",
    "includes": [
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "\"/usr/bin/xpra\"",
            "&s"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/wait.h>\n#include <sys/mount.h>\n#include <dirent.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nstatic int x11_check_xpra(void) {\n\tstruct stat s;\n\t\n\t// check xpra\n\tif (stat(\"/usr/bin/xpra\", &s) == -1)\n\t\treturn 0;\n\n\treturn 1;\n}"
  }
]