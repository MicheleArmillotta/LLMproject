[
  {
    "function_name": "run_no_sandbox",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/no_sandbox.c",
    "lines": "162-291",
    "snippet": "void run_no_sandbox(int argc, char **argv) {\n\tEUID_ASSERT();\n\n\t// process limited subset of options\n\tint i;\n\tfor (i = 0; i < argc; i++) {\n\t\tif (strcmp(argv[i], \"--csh\") == 0) {\n\t\t\tif (arg_shell_none) {\n\t\t\t\tfprintf(stderr, \"Error: --shell=none was already specified.\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (cfg.shell) {\n\t\t\t\tfprintf(stderr, \"Error: only one default user shell can be specified\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tcfg.shell = \"/bin/csh\";\n\t\t}\n\t\telse if (strcmp(argv[i], \"--zsh\") == 0) {\n\t\t\tif (arg_shell_none) {\n\t\t\t\tfprintf(stderr, \"Error: --shell=none was already specified.\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (cfg.shell) {\n\t\t\t\tfprintf(stderr, \"Error: only one default user shell can be specified\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tcfg.shell = \"/bin/zsh\";\n\t\t}\n\t\telse if (strcmp(argv[i], \"--shell=none\") == 0) {\n\t\t\targ_shell_none = 1;\n\t\t\tif (cfg.shell) {\n\t\t\t\tfprintf(stderr, \"Error: a shell was already specified\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(argv[i], \"--shell=\", 8) == 0) {\n\t\t\tif (arg_shell_none) {\n\t\t\t\tfprintf(stderr, \"Error: --shell=none was already specified.\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tinvalid_filename(argv[i] + 8);\n\n\t\t\tif (cfg.shell) {\n\t\t\t\tfprintf(stderr, \"Error: only one user shell can be specified\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tcfg.shell = argv[i] + 8;\n\n\t\t\tif (is_dir(cfg.shell) || strstr(cfg.shell, \"..\")) {\n\t\t\t\tfprintf(stderr, \"Error: invalid shell\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// access call checks as real UID/GID, not as effective UID/GID\n\t\t\tif(cfg.chrootdir) {\n\t\t\t\tchar *shellpath;\n\t\t\t\tif (asprintf(&shellpath, \"%s%s\", cfg.chrootdir, cfg.shell) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\tif (access(shellpath, R_OK)) {\n\t\t\t\t\tfprintf(stderr, \"Error: cannot access shell file in chroot\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tfree(shellpath);\n\t\t\t} else if (access(cfg.shell, R_OK)) {\n\t\t\t\tfprintf(stderr, \"Error: cannot access shell file\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t}\n\n\t// use $SHELL to get shell used in sandbox\n\tif (!arg_shell_none && !cfg.shell) {\n\t\tchar *shell =  getenv(\"SHELL\");\n\t\tif (access(shell, R_OK) == 0)\n\t\t\tcfg.shell = shell;\n\t}\n\t// guess shell otherwise\n\tif (!arg_shell_none && !cfg.shell) {\n\t\tcfg.shell = guess_shell();\n\t\tif (arg_debug)\n\t\t\tprintf(\"Autoselecting %s as shell\\n\", cfg.shell);\n\t}\n\tif (!arg_shell_none && !cfg.shell) {\n\t\tfprintf(stderr, \"Error: unable to guess your shell, please set explicitly by using --shell option.\\n\");\n\t\texit(1);\n\t}\n\n\tint prog_index = 0;\n\t// find first non option arg:\n\t//\t- first argument not starting wiht --,\n\t//\t- whatever follows after -c (example: firejail -c ls)\n\tfor (i = 1; i < argc; i++) {\n\t\tif (strcmp(argv[i], \"-c\") == 0) {\n\t\t\tprog_index = i + 1;\n\t\t\tif (prog_index == argc) {\n\t\t\t\tfprintf(stderr, \"Error: option -c requires an argument\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t// check first argument not starting with --\n\t\tif (strncmp(argv[i],\"--\",2) != 0) {\n\t\t\tprog_index = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!arg_shell_none) {\n\t\tif (prog_index == 0) {\n\t\t\tcfg.command_line = cfg.shell;\n\t\t\tcfg.window_title = cfg.shell;\n\t\t} else {\n\t\t\tbuild_cmdline(&cfg.command_line, &cfg.window_title, argc, argv, prog_index);\n\t\t}\n\t}\n\n\tcfg.original_argv = argv;\n\tcfg.original_program_index = prog_index;\n\n\tchar *command;\n\tif (prog_index == 0)\n\t\tcommand = cfg.shell;\n\telse\n\t\tcommand = argv[prog_index];\n\tif (!arg_quiet)\n\t\tfprintf(stderr, \"Warning: an existing sandbox was detected. \"\n\t\t\t\"%s will run without any additional sandboxing features\\n\", command);\n\n\tstart_application();\n}",
    "includes": [
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "start_application",
          "args": [],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "start_application",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/sandbox.c",
          "lines": "296-393",
          "snippet": "void start_application(void) {\n//if (setsid() == -1)\n//errExit(\"setsid\");\n\n\t// set environment\n\tenv_defaults();\n\tenv_apply();\n\tif (arg_debug) {\n\t\tprintf(\"starting application\\n\");\n\t\tprintf(\"LD_PRELOAD=%s\\n\", getenv(\"LD_PRELOAD\"));\n\t}\n\n\t//****************************************\n\t// audit\n\t//****************************************\n\tif (arg_audit) {\n\t\tassert(arg_audit_prog);\n\t\tstruct stat s;\n\t\tif (stat(arg_audit_prog, &s) != 0) {\n\t\t\tfprintf(stderr, \"Error: cannot find the audit program\\n\");\n\t\t\texit(1);\n\t\t}\n\t\texecl(arg_audit_prog, arg_audit_prog, NULL);\n\t}\n\t//****************************************\n\t// start the program without using a shell\n\t//****************************************\n\telse if (arg_shell_none) {\n\t\tif (arg_debug) {\n\t\t\tint i;\n\t\t\tfor (i = cfg.original_program_index; i < cfg.original_argc; i++) {\n\t\t\t\tif (cfg.original_argv[i] == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tprintf(\"execvp argument %d: %s\\n\", i - cfg.original_program_index, cfg.original_argv[i]);\n\t\t\t}\n\t\t}\n\n\t\tif (cfg.original_program_index == 0) {\n\t\t\tfprintf(stderr, \"Error: --shell=none configured, but no program specified\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tif (!arg_command && !arg_quiet)\n\t\t\tprintf(\"Child process initialized\\n\");\n\n\t\texecvp(cfg.original_argv[cfg.original_program_index], &cfg.original_argv[cfg.original_program_index]);\n\t\texit(1);\n\t}\n\t//****************************************\n\t// start the program using a shell\n\t//****************************************\n\telse {\n\t\tassert(cfg.shell);\n\t\tassert(cfg.command_line);\n\n\t\tchar *arg[5];\n\t\tint index = 0;\n\t\targ[index++] = cfg.shell;\n\t\tif (login_shell) {\n\t\t\targ[index++] = \"-l\";\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Starting %s login shell\\n\", cfg.shell);\n\t\t} else {\n\t\t\targ[index++] = \"-c\";\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Running %s command through %s\\n\", cfg.command_line, cfg.shell);\n\t\t\tif (arg_doubledash)\n\t\t\t\targ[index++] = \"--\";\n\t\t\targ[index++] = cfg.command_line;\n\t\t}\n\t\targ[index] = NULL;\n\t\tassert(index < 5);\n\n\t\tif (arg_debug) {\n\t\t\tchar *msg;\n\t\t\tif (asprintf(&msg, \"sandbox %d, execvp into %s\", sandbox_pid, cfg.command_line) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tlogmsg(msg);\n\t\t\tfree(msg);\n\t\t}\n\n\t\tif (arg_debug) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < 5; i++) {\n\t\t\t\tif (arg[i] == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tprintf(\"execvp argument %d: %s\\n\", i, arg[i]);\n\t\t\t}\n\t\t}\n\n\t\tif (!arg_command && !arg_quiet)\n\t\t\tprintf(\"Child process initialized\\n\");\n\t\texecvp(arg[0], arg);\n\t}\n\n\tperror(\"execvp\");\n\texit(1); // it should never get here!!!\n}",
          "includes": [
            "#include <sys/apparmor.h>",
            "#include <sys/prctl.h>",
            "#include <sched.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/prctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/apparmor.h>\n#include <sys/prctl.h>\n#include <sched.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/prctl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid start_application(void) {\n//if (setsid() == -1)\n//errExit(\"setsid\");\n\n\t// set environment\n\tenv_defaults();\n\tenv_apply();\n\tif (arg_debug) {\n\t\tprintf(\"starting application\\n\");\n\t\tprintf(\"LD_PRELOAD=%s\\n\", getenv(\"LD_PRELOAD\"));\n\t}\n\n\t//****************************************\n\t// audit\n\t//****************************************\n\tif (arg_audit) {\n\t\tassert(arg_audit_prog);\n\t\tstruct stat s;\n\t\tif (stat(arg_audit_prog, &s) != 0) {\n\t\t\tfprintf(stderr, \"Error: cannot find the audit program\\n\");\n\t\t\texit(1);\n\t\t}\n\t\texecl(arg_audit_prog, arg_audit_prog, NULL);\n\t}\n\t//****************************************\n\t// start the program without using a shell\n\t//****************************************\n\telse if (arg_shell_none) {\n\t\tif (arg_debug) {\n\t\t\tint i;\n\t\t\tfor (i = cfg.original_program_index; i < cfg.original_argc; i++) {\n\t\t\t\tif (cfg.original_argv[i] == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tprintf(\"execvp argument %d: %s\\n\", i - cfg.original_program_index, cfg.original_argv[i]);\n\t\t\t}\n\t\t}\n\n\t\tif (cfg.original_program_index == 0) {\n\t\t\tfprintf(stderr, \"Error: --shell=none configured, but no program specified\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tif (!arg_command && !arg_quiet)\n\t\t\tprintf(\"Child process initialized\\n\");\n\n\t\texecvp(cfg.original_argv[cfg.original_program_index], &cfg.original_argv[cfg.original_program_index]);\n\t\texit(1);\n\t}\n\t//****************************************\n\t// start the program using a shell\n\t//****************************************\n\telse {\n\t\tassert(cfg.shell);\n\t\tassert(cfg.command_line);\n\n\t\tchar *arg[5];\n\t\tint index = 0;\n\t\targ[index++] = cfg.shell;\n\t\tif (login_shell) {\n\t\t\targ[index++] = \"-l\";\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Starting %s login shell\\n\", cfg.shell);\n\t\t} else {\n\t\t\targ[index++] = \"-c\";\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Running %s command through %s\\n\", cfg.command_line, cfg.shell);\n\t\t\tif (arg_doubledash)\n\t\t\t\targ[index++] = \"--\";\n\t\t\targ[index++] = cfg.command_line;\n\t\t}\n\t\targ[index] = NULL;\n\t\tassert(index < 5);\n\n\t\tif (arg_debug) {\n\t\t\tchar *msg;\n\t\t\tif (asprintf(&msg, \"sandbox %d, execvp into %s\", sandbox_pid, cfg.command_line) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tlogmsg(msg);\n\t\t\tfree(msg);\n\t\t}\n\n\t\tif (arg_debug) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < 5; i++) {\n\t\t\t\tif (arg[i] == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tprintf(\"execvp argument %d: %s\\n\", i, arg[i]);\n\t\t\t}\n\t\t}\n\n\t\tif (!arg_command && !arg_quiet)\n\t\t\tprintf(\"Child process initialized\\n\");\n\t\texecvp(arg[0], arg);\n\t}\n\n\tperror(\"execvp\");\n\texit(1); // it should never get here!!!\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: an existing sandbox was detected. \"\n\t\t\t\"%s will run without any additional sandboxing features\\n\"",
            "command"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_cmdline",
          "args": [
            "&cfg.command_line",
            "&cfg.window_title",
            "argc",
            "argv",
            "prog_index"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "build_cmdline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/cmdline.c",
          "lines": "137-159",
          "snippet": "void build_cmdline(char **command_line, char **window_title, int argc, char **argv, int index) {\n\t// index == -1 could happen if we have --shell=none and no program was specified\n\t// the program should exit with an error before entering this function\n\tassert(index != -1);\n\n\tint len = cmdline_length(argc, argv, index);\n\tif (len > ARG_MAX) {\n\t\terrno = E2BIG;\n\t\terrExit(\"cmdline_length\");\n\t}\n\n\t*command_line = malloc(len + 1);\n\tif (!*command_line)\n\t\t\terrExit(\"malloc\");\n\t*window_title = malloc(len + 1);\n\tif (!*window_title)\n\t\t\terrExit(\"malloc\");\n\t\n\tquote_cmdline(*command_line, *window_title, len, argc, argv, index);\n\n\tassert(*command_line);\n\tassert(*window_title);\n}",
          "includes": [
            "#include <errno.h>",
            "#include <assert.h>",
            "#include <linux/limits.h>",
            "#include <stdio.h>",
            "#include <stdbool.h>",
            "#include <string.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <assert.h>\n#include <linux/limits.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n#include \"firejail.h\"\n\nvoid build_cmdline(char **command_line, char **window_title, int argc, char **argv, int index) {\n\t// index == -1 could happen if we have --shell=none and no program was specified\n\t// the program should exit with an error before entering this function\n\tassert(index != -1);\n\n\tint len = cmdline_length(argc, argv, index);\n\tif (len > ARG_MAX) {\n\t\terrno = E2BIG;\n\t\terrExit(\"cmdline_length\");\n\t}\n\n\t*command_line = malloc(len + 1);\n\tif (!*command_line)\n\t\t\terrExit(\"malloc\");\n\t*window_title = malloc(len + 1);\n\tif (!*window_title)\n\t\t\terrExit(\"malloc\");\n\t\n\tquote_cmdline(*command_line, *window_title, len, argc, argv, index);\n\n\tassert(*command_line);\n\tassert(*window_title);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "argv[i]",
            "\"--\"",
            "2"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "myexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/main.c",
          "lines": "137-149",
          "snippet": "static void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}",
          "includes": [
            "#include <sys/times.h>",
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int arg_command = 0;",
            "int arg_quiet = 0;",
            "pid_t sandbox_pid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/times.h>\n#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nint arg_command = 0;\nint arg_quiet = 0;\npid_t sandbox_pid;\n\nstatic void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: option -c requires an argument\\n\""
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"-c\""
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: unable to guess your shell, please set explicitly by using --shell option.\\n\""
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Autoselecting %s as shell\\n\"",
            "cfg.shell"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "guess_shell",
          "args": [],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "guess_shell",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/main.c",
          "lines": "836-853",
          "snippet": "char *guess_shell(void) {\n\tchar *shell = NULL;\n\t// shells in order of preference\n\tchar *shells[] = {\"/bin/bash\", \"/bin/csh\", \"/usr/bin/zsh\", \"/bin/sh\", \"/bin/ash\", NULL };\n\n\tint i = 0;\n\twhile (shells[i] != NULL) {\n\t\tstruct stat s;\n\t\t// access call checks as real UID/GID, not as effective UID/GID\n\t\tif (stat(shells[i], &s) == 0 && access(shells[i], R_OK) == 0) {\n\t\t\tshell = shells[i];\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\n\treturn shell;\n}",
          "includes": [
            "#include <sys/times.h>",
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/times.h>\n#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nchar *guess_shell(void) {\n\tchar *shell = NULL;\n\t// shells in order of preference\n\tchar *shells[] = {\"/bin/bash\", \"/bin/csh\", \"/usr/bin/zsh\", \"/bin/sh\", \"/bin/ash\", NULL };\n\n\tint i = 0;\n\twhile (shells[i] != NULL) {\n\t\tstruct stat s;\n\t\t// access call checks as real UID/GID, not as effective UID/GID\n\t\tif (stat(shells[i], &s) == 0 && access(shells[i], R_OK) == 0) {\n\t\t\tshell = shells[i];\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\n\treturn shell;\n}"
        }
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "shell",
            "R_OK"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"SHELL\""
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot access shell file\\n\""
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "cfg.shell",
            "R_OK"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "shellpath"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot access shell file in chroot\\n\""
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "shellpath",
            "R_OK"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&shellpath",
            "\"%s%s\"",
            "cfg.chrootdir",
            "cfg.shell"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid shell\\n\""
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "cfg.shell",
            "\"..\""
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_dir",
          "args": [
            "cfg.shell"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "is_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/util.c",
          "lines": "264-291",
          "snippet": "int is_dir(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\t// if fname doesn't end in '/', add one\n\tint rv;\n\tstruct stat s;\n\tif (fname[strlen(fname) - 1] == '/')\n\t\trv = stat(fname, &s);\n\telse {\n\t\tchar *tmp;\n\t\tif (asprintf(&tmp, \"%s/\", fname) == -1) {\n\t\t\tfprintf(stderr, \"Error: cannot allocate memory, %s:%d\\n\", __FILE__, __LINE__);\n\t\t\terrExit(\"asprintf\");\n\t\t}\n\t\trv = stat(tmp, &s);\n\t\tfree(tmp);\n\t}\n\n\tif (rv == -1)\n\t\treturn 0;\n\n\tif (S_ISDIR(s.st_mode))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nint is_dir(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\t// if fname doesn't end in '/', add one\n\tint rv;\n\tstruct stat s;\n\tif (fname[strlen(fname) - 1] == '/')\n\t\trv = stat(fname, &s);\n\telse {\n\t\tchar *tmp;\n\t\tif (asprintf(&tmp, \"%s/\", fname) == -1) {\n\t\t\tfprintf(stderr, \"Error: cannot allocate memory, %s:%d\\n\", __FILE__, __LINE__);\n\t\t\terrExit(\"asprintf\");\n\t\t}\n\t\trv = stat(tmp, &s);\n\t\tfree(tmp);\n\t}\n\n\tif (rv == -1)\n\t\treturn 0;\n\n\tif (S_ISDIR(s.st_mode))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: only one user shell can be specified\\n\""
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invalid_filename",
          "args": [
            "argv[i] + 8"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "invalid_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/util.c",
          "lines": "668-689",
          "snippet": "void invalid_filename(const char *fname) {\n\tEUID_ASSERT();\n\tassert(fname);\n\tconst char *ptr = fname;\n\n\tif (arg_debug_check_filename)\n\t\tprintf(\"Checking filename %s\\n\", fname);\n\n\tif (strncmp(ptr, \"${HOME}\", 7) == 0)\n\t\tptr = fname + 7;\n\telse if (strncmp(ptr, \"${PATH}\", 7) == 0)\n\t\tptr = fname + 7;\n\telse if (strcmp(fname, \"${DOWNLOADS}\") == 0)\n\t\treturn;\n\n\tint len = strlen(ptr);\n\t// file globbing ('*') is allowed\n\tif (strcspn(ptr, \"\\\\&!?\\\"'<>%^(){}[];,\") != (size_t)len) {\n\t\tfprintf(stderr, \"Error: \\\"%s\\\" is an invalid filename\\n\", ptr);\n\t\texit(1);\n\t}\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid invalid_filename(const char *fname) {\n\tEUID_ASSERT();\n\tassert(fname);\n\tconst char *ptr = fname;\n\n\tif (arg_debug_check_filename)\n\t\tprintf(\"Checking filename %s\\n\", fname);\n\n\tif (strncmp(ptr, \"${HOME}\", 7) == 0)\n\t\tptr = fname + 7;\n\telse if (strncmp(ptr, \"${PATH}\", 7) == 0)\n\t\tptr = fname + 7;\n\telse if (strcmp(fname, \"${DOWNLOADS}\") == 0)\n\t\treturn;\n\n\tint len = strlen(ptr);\n\t// file globbing ('*') is allowed\n\tif (strcspn(ptr, \"\\\\&!?\\\"'<>%^(){}[];,\") != (size_t)len) {\n\t\tfprintf(stderr, \"Error: \\\"%s\\\" is an invalid filename\\n\", ptr);\n\t\texit(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: --shell=none was already specified.\\n\""
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "argv[i]",
            "\"--shell=\"",
            "8"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: a shell was already specified\\n\""
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"--shell=none\""
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: only one default user shell can be specified\\n\""
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: --shell=none was already specified.\\n\""
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"--zsh\""
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: only one default user shell can be specified\\n\""
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: --shell=none was already specified.\\n\""
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"--csh\""
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <grp.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid run_no_sandbox(int argc, char **argv) {\n\tEUID_ASSERT();\n\n\t// process limited subset of options\n\tint i;\n\tfor (i = 0; i < argc; i++) {\n\t\tif (strcmp(argv[i], \"--csh\") == 0) {\n\t\t\tif (arg_shell_none) {\n\t\t\t\tfprintf(stderr, \"Error: --shell=none was already specified.\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (cfg.shell) {\n\t\t\t\tfprintf(stderr, \"Error: only one default user shell can be specified\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tcfg.shell = \"/bin/csh\";\n\t\t}\n\t\telse if (strcmp(argv[i], \"--zsh\") == 0) {\n\t\t\tif (arg_shell_none) {\n\t\t\t\tfprintf(stderr, \"Error: --shell=none was already specified.\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (cfg.shell) {\n\t\t\t\tfprintf(stderr, \"Error: only one default user shell can be specified\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tcfg.shell = \"/bin/zsh\";\n\t\t}\n\t\telse if (strcmp(argv[i], \"--shell=none\") == 0) {\n\t\t\targ_shell_none = 1;\n\t\t\tif (cfg.shell) {\n\t\t\t\tfprintf(stderr, \"Error: a shell was already specified\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(argv[i], \"--shell=\", 8) == 0) {\n\t\t\tif (arg_shell_none) {\n\t\t\t\tfprintf(stderr, \"Error: --shell=none was already specified.\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tinvalid_filename(argv[i] + 8);\n\n\t\t\tif (cfg.shell) {\n\t\t\t\tfprintf(stderr, \"Error: only one user shell can be specified\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tcfg.shell = argv[i] + 8;\n\n\t\t\tif (is_dir(cfg.shell) || strstr(cfg.shell, \"..\")) {\n\t\t\t\tfprintf(stderr, \"Error: invalid shell\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// access call checks as real UID/GID, not as effective UID/GID\n\t\t\tif(cfg.chrootdir) {\n\t\t\t\tchar *shellpath;\n\t\t\t\tif (asprintf(&shellpath, \"%s%s\", cfg.chrootdir, cfg.shell) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\tif (access(shellpath, R_OK)) {\n\t\t\t\t\tfprintf(stderr, \"Error: cannot access shell file in chroot\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tfree(shellpath);\n\t\t\t} else if (access(cfg.shell, R_OK)) {\n\t\t\t\tfprintf(stderr, \"Error: cannot access shell file\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t}\n\n\t// use $SHELL to get shell used in sandbox\n\tif (!arg_shell_none && !cfg.shell) {\n\t\tchar *shell =  getenv(\"SHELL\");\n\t\tif (access(shell, R_OK) == 0)\n\t\t\tcfg.shell = shell;\n\t}\n\t// guess shell otherwise\n\tif (!arg_shell_none && !cfg.shell) {\n\t\tcfg.shell = guess_shell();\n\t\tif (arg_debug)\n\t\t\tprintf(\"Autoselecting %s as shell\\n\", cfg.shell);\n\t}\n\tif (!arg_shell_none && !cfg.shell) {\n\t\tfprintf(stderr, \"Error: unable to guess your shell, please set explicitly by using --shell option.\\n\");\n\t\texit(1);\n\t}\n\n\tint prog_index = 0;\n\t// find first non option arg:\n\t//\t- first argument not starting wiht --,\n\t//\t- whatever follows after -c (example: firejail -c ls)\n\tfor (i = 1; i < argc; i++) {\n\t\tif (strcmp(argv[i], \"-c\") == 0) {\n\t\t\tprog_index = i + 1;\n\t\t\tif (prog_index == argc) {\n\t\t\t\tfprintf(stderr, \"Error: option -c requires an argument\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t// check first argument not starting with --\n\t\tif (strncmp(argv[i],\"--\",2) != 0) {\n\t\t\tprog_index = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!arg_shell_none) {\n\t\tif (prog_index == 0) {\n\t\t\tcfg.command_line = cfg.shell;\n\t\t\tcfg.window_title = cfg.shell;\n\t\t} else {\n\t\t\tbuild_cmdline(&cfg.command_line, &cfg.window_title, argc, argv, prog_index);\n\t\t}\n\t}\n\n\tcfg.original_argv = argv;\n\tcfg.original_program_index = prog_index;\n\n\tchar *command;\n\tif (prog_index == 0)\n\t\tcommand = cfg.shell;\n\telse\n\t\tcommand = argv[prog_index];\n\tif (!arg_quiet)\n\t\tfprintf(stderr, \"Warning: an existing sandbox was detected. \"\n\t\t\t\"%s will run without any additional sandboxing features\\n\", command);\n\n\tstart_application();\n}"
  },
  {
    "function_name": "check_kernel_procs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/no_sandbox.c",
    "lines": "87-160",
    "snippet": "int check_kernel_procs(void) {\n\t// we run this function with EUID set in order to detect grsecurity\n\t// only user processes are available in /proc when running grsecurity\n\t// EUID_ASSERT();\n\n\tchar *kern_proc[] = {\n\t\t\"kthreadd\",\n\t\t\"ksoftirqd\",\n\t\t\"kworker\",\n\t\t\"rcu_sched\",\n\t\t\"rcu_bh\",\n\t\tNULL\t// NULL terminated list\n\t};\n\tint i;\n\n\tif (arg_debug)\n\t\tprintf(\"Looking for kernel processes\\n\");\n\n\t// look at the first 10 processes\n\t// if a kernel process is found, return 1\n\tfor (i = 1; i <= 10; i++) { \n\t\tstruct stat s;\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/proc/%d/comm\", i) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (stat(fname, &s) == -1) {\n\t\t\tfree(fname);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t// open file\n\t\t/* coverity[toctou] */\n\t\tFILE *fp = fopen(fname, \"r\");\n\t\tif (!fp) {\n\t\t\tfprintf(stderr, \"Warning: cannot open %s\\n\", fname);\n\t\t\tfree(fname);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t// read file\n\t\tchar buf[100];\n\t\tif (fgets(buf, 10, fp) == NULL) {\n\t\t\tfprintf(stderr, \"Warning: cannot read %s\\n\", fname);\n\t\t\tfclose(fp);\n\t\t\tfree(fname);\n\t\t\tcontinue;\n\t\t}\n\t\t// clean /n\n\t\tchar *ptr;\n\t\tif ((ptr = strchr(buf, '\\n')) != NULL)\n\t\t\t*ptr = '\\0';\n\t\t\n\t\t// check process name against the kernel list\n\t\tint j = 0;\n\t\twhile (kern_proc[j] != NULL) {\n\t\t\tif (strncmp(buf, kern_proc[j], strlen(kern_proc[j])) == 0) {\n\t\t\t\tif (arg_debug)\n\t\t\t\t\tprintf(\"Found %s process, we are not running in a sandbox\\n\", buf);\n\t\t\t\tfclose(fp);\n\t\t\t\tfree(fname);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\t\n\t\tfclose(fp);\n\t\tfree(fname);\n\t}\n\n\tif (arg_debug)\n\t\tprintf(\"No kernel processes found, we are already running in a sandbox\\n\");\n\n\treturn 0;\n}",
    "includes": [
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"No kernel processes found, we are already running in a sandbox\\n\""
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Found %s process, we are not running in a sandbox\\n\"",
            "buf"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "kern_proc[j]",
            "strlen(kern_proc[j])"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "kern_proc[j]"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "buf",
            "'\\n'"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: cannot read %s\\n\"",
            "fname"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buf",
            "10",
            "fp"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: cannot open %s\\n\"",
            "fname"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "fname",
            "\"r\""
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "fname",
            "&s"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&fname",
            "\"/proc/%d/comm\"",
            "i"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Looking for kernel processes\\n\""
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <grp.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nint check_kernel_procs(void) {\n\t// we run this function with EUID set in order to detect grsecurity\n\t// only user processes are available in /proc when running grsecurity\n\t// EUID_ASSERT();\n\n\tchar *kern_proc[] = {\n\t\t\"kthreadd\",\n\t\t\"ksoftirqd\",\n\t\t\"kworker\",\n\t\t\"rcu_sched\",\n\t\t\"rcu_bh\",\n\t\tNULL\t// NULL terminated list\n\t};\n\tint i;\n\n\tif (arg_debug)\n\t\tprintf(\"Looking for kernel processes\\n\");\n\n\t// look at the first 10 processes\n\t// if a kernel process is found, return 1\n\tfor (i = 1; i <= 10; i++) { \n\t\tstruct stat s;\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/proc/%d/comm\", i) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (stat(fname, &s) == -1) {\n\t\t\tfree(fname);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t// open file\n\t\t/* coverity[toctou] */\n\t\tFILE *fp = fopen(fname, \"r\");\n\t\tif (!fp) {\n\t\t\tfprintf(stderr, \"Warning: cannot open %s\\n\", fname);\n\t\t\tfree(fname);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t// read file\n\t\tchar buf[100];\n\t\tif (fgets(buf, 10, fp) == NULL) {\n\t\t\tfprintf(stderr, \"Warning: cannot read %s\\n\", fname);\n\t\t\tfclose(fp);\n\t\t\tfree(fname);\n\t\t\tcontinue;\n\t\t}\n\t\t// clean /n\n\t\tchar *ptr;\n\t\tif ((ptr = strchr(buf, '\\n')) != NULL)\n\t\t\t*ptr = '\\0';\n\t\t\n\t\t// check process name against the kernel list\n\t\tint j = 0;\n\t\twhile (kern_proc[j] != NULL) {\n\t\t\tif (strncmp(buf, kern_proc[j], strlen(kern_proc[j])) == 0) {\n\t\t\t\tif (arg_debug)\n\t\t\t\t\tprintf(\"Found %s process, we are not running in a sandbox\\n\", buf);\n\t\t\t\tfclose(fp);\n\t\t\t\tfree(fname);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\t\n\t\tfclose(fp);\n\t\tfree(fname);\n\t}\n\n\tif (arg_debug)\n\t\tprintf(\"No kernel processes found, we are already running in a sandbox\\n\");\n\n\treturn 0;\n}"
  },
  {
    "function_name": "check_namespace_virt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/no_sandbox.c",
    "lines": "40-83",
    "snippet": "int check_namespace_virt(void) {\n\tEUID_ASSERT();\n\t\n\t// check container environment variable\n\tchar *str = getenv(\"container\");\n\tif (str && is_container(str))\n\t\treturn 1;\n\t\n\t// check PID 1 container environment variable\n\tEUID_ROOT();\n\tFILE *fp = fopen(\"/proc/1/environ\", \"r\");\n\tif (fp) {\n\t\tint c = 0;\n\t\twhile (c != EOF) {\n\t\t\t// read one line\n\t\t\tchar buf[MAX_BUF];\n\t\t\tint i = 0;\n\t\t\twhile ((c = fgetc(fp)) != EOF) {\n\t\t\t\tif (c == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[i] = (char) c;\n\t\t\t\tif (++i == (MAX_BUF - 1))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbuf[i] = '\\0';\n\t\t\t\n\t\t\t// check env var name\n\t\t\tif (strncmp(buf, \"container=\", 10) == 0) {\n\t\t\t\t// found it\n\t\t\t\tif (is_container(buf + 10)) {\n\t\t\t\t\tfclose(fp);\n\t\t\t\t\tEUID_USER();\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n//\t\t\tprintf(\"i %d c %d, buf #%s#\\n\", i, c, buf);\n\t\t}\n\t\t\n\t\tfclose(fp);\n\t}\n\t\t\n\tEUID_USER();\n\treturn 0;\n}",
    "includes": [
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [
      "#define MAX_BUF 4096"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EUID_USER",
          "args": [],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_USER",
          "args": [],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_container",
          "args": [
            "buf + 10"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "is_container",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/no_sandbox.c",
          "lines": "28-37",
          "snippet": "int is_container(const char *str) {\n\tassert(str);\n\tif (strcmp(str, \"lxc\") == 0 ||\n\t     strcmp(str, \"docker\") == 0 ||\n\t     strcmp(str, \"lxc-libvirt\") == 0 ||\n\t     strcmp(str, \"systemd-nspawn\") == 0 ||\n\t     strcmp(str, \"rkt\") == 0)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <grp.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nint is_container(const char *str) {\n\tassert(str);\n\tif (strcmp(str, \"lxc\") == 0 ||\n\t     strcmp(str, \"docker\") == 0 ||\n\t     strcmp(str, \"lxc-libvirt\") == 0 ||\n\t     strcmp(str, \"systemd-nspawn\") == 0 ||\n\t     strcmp(str, \"rkt\") == 0)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "\"container=\"",
            "10"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgetc",
          "args": [
            "fp"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "\"/proc/1/environ\"",
            "\"r\""
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ROOT",
          "args": [],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"container\""
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <grp.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\n#define MAX_BUF 4096\n\nint check_namespace_virt(void) {\n\tEUID_ASSERT();\n\t\n\t// check container environment variable\n\tchar *str = getenv(\"container\");\n\tif (str && is_container(str))\n\t\treturn 1;\n\t\n\t// check PID 1 container environment variable\n\tEUID_ROOT();\n\tFILE *fp = fopen(\"/proc/1/environ\", \"r\");\n\tif (fp) {\n\t\tint c = 0;\n\t\twhile (c != EOF) {\n\t\t\t// read one line\n\t\t\tchar buf[MAX_BUF];\n\t\t\tint i = 0;\n\t\t\twhile ((c = fgetc(fp)) != EOF) {\n\t\t\t\tif (c == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[i] = (char) c;\n\t\t\t\tif (++i == (MAX_BUF - 1))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbuf[i] = '\\0';\n\t\t\t\n\t\t\t// check env var name\n\t\t\tif (strncmp(buf, \"container=\", 10) == 0) {\n\t\t\t\t// found it\n\t\t\t\tif (is_container(buf + 10)) {\n\t\t\t\t\tfclose(fp);\n\t\t\t\t\tEUID_USER();\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n//\t\t\tprintf(\"i %d c %d, buf #%s#\\n\", i, c, buf);\n\t\t}\n\t\t\n\t\tfclose(fp);\n\t}\n\t\t\n\tEUID_USER();\n\treturn 0;\n}"
  },
  {
    "function_name": "is_container",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/no_sandbox.c",
    "lines": "28-37",
    "snippet": "int is_container(const char *str) {\n\tassert(str);\n\tif (strcmp(str, \"lxc\") == 0 ||\n\t     strcmp(str, \"docker\") == 0 ||\n\t     strcmp(str, \"lxc-libvirt\") == 0 ||\n\t     strcmp(str, \"systemd-nspawn\") == 0 ||\n\t     strcmp(str, \"rkt\") == 0)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include <grp.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"rkt\""
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"systemd-nspawn\""
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"lxc-libvirt\""
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"docker\""
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"lxc\""
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "str"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <grp.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nint is_container(const char *str) {\n\tassert(str);\n\tif (strcmp(str, \"lxc\") == 0 ||\n\t     strcmp(str, \"docker\") == 0 ||\n\t     strcmp(str, \"lxc-libvirt\") == 0 ||\n\t     strcmp(str, \"systemd-nspawn\") == 0 ||\n\t     strcmp(str, \"rkt\") == 0)\n\t\treturn 1;\n\treturn 0;\n}"
  }
]