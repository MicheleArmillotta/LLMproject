[
  {
    "function_name": "join",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/join.c",
    "lines": "191-398",
    "snippet": "void join(pid_t pid, int argc, char **argv, int index) {\n\tEUID_ASSERT();\n\tchar *homedir = cfg.homedir;\n\t\n\textract_command(argc, argv, index);\n\tsignal (SIGTERM, signal_handler);\n\n\t// if the pid is that of a firejail  process, use the pid of the first child process\n\tEUID_ROOT();\n\tchar *comm = pid_proc_comm(pid);\n\tEUID_USER();\n\tif (comm) {\n\t\tif (strcmp(comm, \"firejail\") == 0) {\n\t\t\tpid_t child;\n\t\t\tif (find_child(pid, &child) == 0) {\n\t\t\t\tpid = child;\n\t\t\t\tprintf(\"Switching to pid %u, the first child process inside the sandbox\\n\", (unsigned) pid);\n\t\t\t}\n\t\t}\n\t\tfree(comm);\n\t}\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission is denied to join a sandbox created by a different user.\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tEUID_ROOT();\n\t// in user mode set caps seccomp, cpu, cgroup, etc\n\tif (getuid() != 0) {\n\t\textract_caps_seccomp(pid);\n\t\textract_cpu(pid);\n\t\textract_cgroup(pid);\n\t\textract_nogroups(pid);\n\t\textract_user_namespace(pid);\n\t}\n\t\n\t// set cgroup\n\tif (cfg.cgroup)\t// not available for uid 0\n\t\tset_cgroup(cfg.cgroup);\n\t\t\n\t// join namespaces\n\tif (arg_join_network) {\n\t\tif (join_namespace(pid, \"net\"))\n\t\t\texit(1);\n\t}\n\telse if (arg_join_filesystem) {\n\t\tif (join_namespace(pid, \"mnt\"))\n\t\t\texit(1);\n\t}\n\telse {\n\t\tif (join_namespace(pid, \"ipc\"))\n\t\t\texit(1);\n\t\tif (join_namespace(pid, \"net\"))\n\t\t\texit(1);\n\t\tif (join_namespace(pid, \"pid\"))\n\t\t\texit(1);\n\t\tif (join_namespace(pid, \"uts\"))\n\t\t\texit(1);\n\t\tif (join_namespace(pid, \"mnt\"))\n\t\t\texit(1);\n\t}\n\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// chroot into /proc/PID/root directory\n\t\tchar *rootdir;\n\t\tif (asprintf(&rootdir, \"/proc/%d/root\", pid) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\t\t\n\t\tint rv;\n\t\tif (!arg_join_network) {\n\t\t\trv = chroot(rootdir); // this will fail for processes in sandboxes not started with --chroot option\n\t\t\tif (rv == 0)\n\t\t\t\tprintf(\"changing root to %s\\n\", rootdir);\n\t\t}\n\t\t\n\t\tprctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0); // kill the child in case the parent died\n\t\tif (chdir(\"/\") < 0)\n\t\t\terrExit(\"chdir\");\n\t\tif (homedir) {\n\t\t\tstruct stat s;\n\t\t\tif (stat(homedir, &s) == 0) {\n\t\t\t\t/* coverity[toctou] */\n\t\t\t\tif (chdir(homedir) < 0)\n\t\t\t\t\terrExit(\"chdir\");\n\t\t\t}\n\t\t}\n\t\t\n\t\t// set cpu affinity\n\t\tif (cfg.cpus)\t// not available for uid 0\n\t\t\tset_cpu_affinity();\n\t\t\t\t\t\n\t\t// set caps filter\n\t\tif (apply_caps == 1)\t// not available for uid 0\n\t\t\tcaps_set(caps);\n#ifdef HAVE_SECCOMP\n\t\t// set protocol filter\n\t\tif (getuid() != 0)\n\t\t\tprotocol_filter_load(RUN_PROTOCOL_CFG);\n\t\tif (cfg.protocol) {\t// not available for uid 0\n\t\t\tprotocol_filter();\n\t\t}\n\t\t\t\t\n\t\t// set seccomp filter\n\t\tif (apply_seccomp == 1)\t// not available for uid 0\n\t\t\tseccomp_set();\n#endif\n\n\t\t// fix qt 4.8\n\t\tif (setenv(\"QT_X11_NO_MITSHM\", \"1\", 1) < 0)\n\t\t\terrExit(\"setenv\");\n\t\tif (setenv(\"container\", \"firejail\", 1) < 0) // LXC sets container=lxc,\n\t\t\terrExit(\"setenv\");\n\n\t\t// mount user namespace or drop privileges\n\t\tif (arg_noroot) {\t// not available for uid 0\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Joining user namespace\\n\");\n\t\t\tif (join_namespace(1, \"user\"))\n\t\t\t\texit(1);\n\n\t\t\t// user namespace resets capabilities\n\t\t\t// set caps filter\n\t\t\tif (apply_caps == 1)\t// not available for uid 0\n\t\t\t\tcaps_set(caps);\n\t\t}\n\t\telse \n\t\t\tdrop_privs(arg_nogroups);\t// nogroups not available for uid 0\n\n\n\t\t// set prompt color to green\n\t\tchar *prompt = getenv(\"FIREJAIL_PROMPT\");\n\t\tif (prompt && strcmp(prompt, \"yes\") == 0) {\n\t\t\t//export PS1='\\[\\e[1;32m\\][\\u@\\h \\W]\\$\\[\\e[0m\\] '\n\t\t\tif (setenv(\"PROMPT_COMMAND\", \"export PS1=\\\"\\\\[\\\\e[1;32m\\\\][\\\\u@\\\\h \\\\W]\\\\$\\\\[\\\\e[0m\\\\] \\\"\", 1) < 0)\n\t\t\t\terrExit(\"setenv\");\n\t\t}\n\t\t\n\t\t// set nice\n\t\tif (arg_nice) {\n\t\t\terrno = 0;\n\t\t\tint rv = nice(cfg.nice);\n\t\t\t(void) rv;\n\t\t\tif (errno) {\n\t\t\t\tfprintf(stderr, \"Warning: cannot set nice value\\n\");\n\t\t\t\terrno = 0;\n\t\t\t}\n\t\t}\n\n\t\t// run cmdline trough shell\n\t\tif (cfg.command_line == NULL) {\n\t\t\t// if the sandbox was started with --shell=none, it is possible we don't have a shell\n\t\t\t// inside the sandbox\n\t\t\tif (cfg.shell == NULL) {\n\t\t\t\tcfg.shell = guess_shell();\n\t\t\t\tif (!cfg.shell) {\n\t\t\t\t\tfprintf(stderr, \"Error: no POSIX shell found, please use --shell command line option\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t\n\t\t\tstruct stat s;\n\t\t\tif (stat(cfg.shell, &s) == -1)  {\n\t\t\t\tfprintf(stderr, \"Error: %s shell not found inside the sandbox\\n\", cfg.shell);\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tcfg.command_line = cfg.shell;\n\t\t\tcfg.window_title = cfg.shell;\n\t\t}\n\n\t\tint cwd = 0;\n\t\tif (cfg.cwd) {\n\t\t\tif (chdir(cfg.cwd) == 0)\n\t\t\t\tcwd = 1;\n\t\t}\n\n\t\tif (!cwd) {\n\t\t\tif (chdir(\"/\") < 0)\n\t\t\t\terrExit(\"chdir\");\n\t\t\tif (cfg.homedir) {\n\t\t\t\tstruct stat s;\n\t\t\t\tif (stat(cfg.homedir, &s) == 0) {\n\t\t\t\t\t/* coverity[toctou] */\n\t\t\t\t\tif (chdir(cfg.homedir) < 0)\n\t\t\t\t\t\terrExit(\"chdir\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstart_application();\n\n\t\t// it will never get here!!!\n\t}\n\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n\tflush_stdin();\n\texit(0);\n}",
    "includes": [
      "#include <errno.h>",
      "#include <sys/prctl.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int apply_caps = 0;",
      "static uint64_t caps = 0;",
      "static int apply_seccomp = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "myexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/main.c",
          "lines": "137-149",
          "snippet": "static void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}",
          "includes": [
            "#include <sys/times.h>",
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int arg_command = 0;",
            "int arg_quiet = 0;",
            "pid_t sandbox_pid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/times.h>\n#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nint arg_command = 0;\nint arg_quiet = 0;\npid_t sandbox_pid;\n\nstatic void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_stdin",
          "args": [],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "flush_stdin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/util.c",
          "lines": "721-731",
          "snippet": "void flush_stdin(void) {\n\tif (isatty(STDIN_FILENO)) {\n\t\tint cnt = 0;\n\t\tioctl(STDIN_FILENO, FIONREAD, &cnt);\n\t\tif (cnt) {\n\t\t\tif (!arg_quiet)\n\t\t\t\tprintf(\"Warning: removing %d bytes from stdin\\n\", cnt);\n\t\t\tioctl(STDIN_FILENO, TCFLSH, TCIFLUSH);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid flush_stdin(void) {\n\tif (isatty(STDIN_FILENO)) {\n\t\tint cnt = 0;\n\t\tioctl(STDIN_FILENO, FIONREAD, &cnt);\n\t\tif (cnt) {\n\t\t\tif (!arg_quiet)\n\t\t\t\tprintf(\"Warning: removing %d bytes from stdin\\n\", cnt);\n\t\t\tioctl(STDIN_FILENO, TCFLSH, TCIFLUSH);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "child",
            "NULL",
            "0"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "start_application",
          "args": [],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "start_application",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/sandbox.c",
          "lines": "296-393",
          "snippet": "void start_application(void) {\n//if (setsid() == -1)\n//errExit(\"setsid\");\n\n\t// set environment\n\tenv_defaults();\n\tenv_apply();\n\tif (arg_debug) {\n\t\tprintf(\"starting application\\n\");\n\t\tprintf(\"LD_PRELOAD=%s\\n\", getenv(\"LD_PRELOAD\"));\n\t}\n\n\t//****************************************\n\t// audit\n\t//****************************************\n\tif (arg_audit) {\n\t\tassert(arg_audit_prog);\n\t\tstruct stat s;\n\t\tif (stat(arg_audit_prog, &s) != 0) {\n\t\t\tfprintf(stderr, \"Error: cannot find the audit program\\n\");\n\t\t\texit(1);\n\t\t}\n\t\texecl(arg_audit_prog, arg_audit_prog, NULL);\n\t}\n\t//****************************************\n\t// start the program without using a shell\n\t//****************************************\n\telse if (arg_shell_none) {\n\t\tif (arg_debug) {\n\t\t\tint i;\n\t\t\tfor (i = cfg.original_program_index; i < cfg.original_argc; i++) {\n\t\t\t\tif (cfg.original_argv[i] == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tprintf(\"execvp argument %d: %s\\n\", i - cfg.original_program_index, cfg.original_argv[i]);\n\t\t\t}\n\t\t}\n\n\t\tif (cfg.original_program_index == 0) {\n\t\t\tfprintf(stderr, \"Error: --shell=none configured, but no program specified\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tif (!arg_command && !arg_quiet)\n\t\t\tprintf(\"Child process initialized\\n\");\n\n\t\texecvp(cfg.original_argv[cfg.original_program_index], &cfg.original_argv[cfg.original_program_index]);\n\t\texit(1);\n\t}\n\t//****************************************\n\t// start the program using a shell\n\t//****************************************\n\telse {\n\t\tassert(cfg.shell);\n\t\tassert(cfg.command_line);\n\n\t\tchar *arg[5];\n\t\tint index = 0;\n\t\targ[index++] = cfg.shell;\n\t\tif (login_shell) {\n\t\t\targ[index++] = \"-l\";\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Starting %s login shell\\n\", cfg.shell);\n\t\t} else {\n\t\t\targ[index++] = \"-c\";\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Running %s command through %s\\n\", cfg.command_line, cfg.shell);\n\t\t\tif (arg_doubledash)\n\t\t\t\targ[index++] = \"--\";\n\t\t\targ[index++] = cfg.command_line;\n\t\t}\n\t\targ[index] = NULL;\n\t\tassert(index < 5);\n\n\t\tif (arg_debug) {\n\t\t\tchar *msg;\n\t\t\tif (asprintf(&msg, \"sandbox %d, execvp into %s\", sandbox_pid, cfg.command_line) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tlogmsg(msg);\n\t\t\tfree(msg);\n\t\t}\n\n\t\tif (arg_debug) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < 5; i++) {\n\t\t\t\tif (arg[i] == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tprintf(\"execvp argument %d: %s\\n\", i, arg[i]);\n\t\t\t}\n\t\t}\n\n\t\tif (!arg_command && !arg_quiet)\n\t\t\tprintf(\"Child process initialized\\n\");\n\t\texecvp(arg[0], arg);\n\t}\n\n\tperror(\"execvp\");\n\texit(1); // it should never get here!!!\n}",
          "includes": [
            "#include <sys/apparmor.h>",
            "#include <sys/prctl.h>",
            "#include <sched.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/prctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/apparmor.h>\n#include <sys/prctl.h>\n#include <sched.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/prctl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid start_application(void) {\n//if (setsid() == -1)\n//errExit(\"setsid\");\n\n\t// set environment\n\tenv_defaults();\n\tenv_apply();\n\tif (arg_debug) {\n\t\tprintf(\"starting application\\n\");\n\t\tprintf(\"LD_PRELOAD=%s\\n\", getenv(\"LD_PRELOAD\"));\n\t}\n\n\t//****************************************\n\t// audit\n\t//****************************************\n\tif (arg_audit) {\n\t\tassert(arg_audit_prog);\n\t\tstruct stat s;\n\t\tif (stat(arg_audit_prog, &s) != 0) {\n\t\t\tfprintf(stderr, \"Error: cannot find the audit program\\n\");\n\t\t\texit(1);\n\t\t}\n\t\texecl(arg_audit_prog, arg_audit_prog, NULL);\n\t}\n\t//****************************************\n\t// start the program without using a shell\n\t//****************************************\n\telse if (arg_shell_none) {\n\t\tif (arg_debug) {\n\t\t\tint i;\n\t\t\tfor (i = cfg.original_program_index; i < cfg.original_argc; i++) {\n\t\t\t\tif (cfg.original_argv[i] == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tprintf(\"execvp argument %d: %s\\n\", i - cfg.original_program_index, cfg.original_argv[i]);\n\t\t\t}\n\t\t}\n\n\t\tif (cfg.original_program_index == 0) {\n\t\t\tfprintf(stderr, \"Error: --shell=none configured, but no program specified\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tif (!arg_command && !arg_quiet)\n\t\t\tprintf(\"Child process initialized\\n\");\n\n\t\texecvp(cfg.original_argv[cfg.original_program_index], &cfg.original_argv[cfg.original_program_index]);\n\t\texit(1);\n\t}\n\t//****************************************\n\t// start the program using a shell\n\t//****************************************\n\telse {\n\t\tassert(cfg.shell);\n\t\tassert(cfg.command_line);\n\n\t\tchar *arg[5];\n\t\tint index = 0;\n\t\targ[index++] = cfg.shell;\n\t\tif (login_shell) {\n\t\t\targ[index++] = \"-l\";\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Starting %s login shell\\n\", cfg.shell);\n\t\t} else {\n\t\t\targ[index++] = \"-c\";\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Running %s command through %s\\n\", cfg.command_line, cfg.shell);\n\t\t\tif (arg_doubledash)\n\t\t\t\targ[index++] = \"--\";\n\t\t\targ[index++] = cfg.command_line;\n\t\t}\n\t\targ[index] = NULL;\n\t\tassert(index < 5);\n\n\t\tif (arg_debug) {\n\t\t\tchar *msg;\n\t\t\tif (asprintf(&msg, \"sandbox %d, execvp into %s\", sandbox_pid, cfg.command_line) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tlogmsg(msg);\n\t\t\tfree(msg);\n\t\t}\n\n\t\tif (arg_debug) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < 5; i++) {\n\t\t\t\tif (arg[i] == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tprintf(\"execvp argument %d: %s\\n\", i, arg[i]);\n\t\t\t}\n\t\t}\n\n\t\tif (!arg_command && !arg_quiet)\n\t\t\tprintf(\"Child process initialized\\n\");\n\t\texecvp(arg[0], arg);\n\t}\n\n\tperror(\"execvp\");\n\texit(1); // it should never get here!!!\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"chdir\""
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chdir",
          "args": [
            "cfg.homedir"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "cfg.homedir",
            "&s"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"chdir\""
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chdir",
          "args": [
            "\"/\""
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chdir",
          "args": [
            "cfg.cwd"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: %s shell not found inside the sandbox\\n\"",
            "cfg.shell"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "cfg.shell",
            "&s"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: no POSIX shell found, please use --shell command line option\\n\""
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "guess_shell",
          "args": [],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "guess_shell",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/main.c",
          "lines": "836-853",
          "snippet": "char *guess_shell(void) {\n\tchar *shell = NULL;\n\t// shells in order of preference\n\tchar *shells[] = {\"/bin/bash\", \"/bin/csh\", \"/usr/bin/zsh\", \"/bin/sh\", \"/bin/ash\", NULL };\n\n\tint i = 0;\n\twhile (shells[i] != NULL) {\n\t\tstruct stat s;\n\t\t// access call checks as real UID/GID, not as effective UID/GID\n\t\tif (stat(shells[i], &s) == 0 && access(shells[i], R_OK) == 0) {\n\t\t\tshell = shells[i];\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\n\treturn shell;\n}",
          "includes": [
            "#include <sys/times.h>",
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/times.h>\n#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nchar *guess_shell(void) {\n\tchar *shell = NULL;\n\t// shells in order of preference\n\tchar *shells[] = {\"/bin/bash\", \"/bin/csh\", \"/usr/bin/zsh\", \"/bin/sh\", \"/bin/ash\", NULL };\n\n\tint i = 0;\n\twhile (shells[i] != NULL) {\n\t\tstruct stat s;\n\t\t// access call checks as real UID/GID, not as effective UID/GID\n\t\tif (stat(shells[i], &s) == 0 && access(shells[i], R_OK) == 0) {\n\t\t\tshell = shells[i];\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\n\treturn shell;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: cannot set nice value\\n\""
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nice",
          "args": [
            "cfg.nice"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"setenv\""
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"PROMPT_COMMAND\"",
            "\"export PS1=\\\"\\\\[\\\\e[1;32m\\\\][\\\\u@\\\\h \\\\W]\\\\$\\\\[\\\\e[0m\\\\] \\\"\"",
            "1"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "prompt",
            "\"yes\""
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"FIREJAIL_PROMPT\""
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "drop_privs",
          "args": [
            "arg_nogroups"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "drop_privs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/util.c",
          "lines": "36-81",
          "snippet": "void drop_privs(int nogroups) {\n\tEUID_ROOT();\n\tgid_t gid = getgid();\n\n\t// configure supplementary groups\n\tif (gid == 0 || nogroups) {\n\t\tif (setgroups(0, NULL) < 0)\n\t\t\terrExit(\"setgroups\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Username %s, no supplementary groups\\n\", cfg.username);\n\t}\n\telse {\n\t\tassert(cfg.username);\n\t\tgid_t groups[MAX_GROUPS];\n\t\tint ngroups = MAX_GROUPS;\n\t\tint rv = getgrouplist(cfg.username, gid, groups, &ngroups);\n\n\t\tif (arg_debug && rv) {\n\t\t\tprintf(\"Username %s, groups \", cfg.username);\n\t\t\tint i;\n\t\t\tfor (i = 0; i < ngroups; i++)\n\t\t\t\tprintf(\"%u, \", groups[i]);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\n\t\tif (rv == -1) {\n\t\t\tfprintf(stderr, \"Warning: cannot extract supplementary group list, dropping them\\n\");\n\t\t\tif (setgroups(0, NULL) < 0)\n\t\t\t\terrExit(\"setgroups\");\n\t\t}\n\t\telse {\n\t\t\trv = setgroups(ngroups, groups);\n\t\t\tif (rv) {\n\t\t\t\tfprintf(stderr, \"Warning: cannot set supplementary group list, dropping them\\n\");\n\t\t\t\tif (setgroups(0, NULL) < 0)\n\t\t\t\t\terrExit(\"setgroups\");\n\t\t\t}\n\t\t}\n\t}\n\n\t// set uid/gid\n\tif (setgid(getgid()) < 0)\n\t\terrExit(\"setgid/getgid\");\n\tif (setuid(getuid()) < 0)\n\t\terrExit(\"setuid/getuid\");\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAX_GROUPS 1024"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\n#define MAX_GROUPS 1024\n\nvoid drop_privs(int nogroups) {\n\tEUID_ROOT();\n\tgid_t gid = getgid();\n\n\t// configure supplementary groups\n\tif (gid == 0 || nogroups) {\n\t\tif (setgroups(0, NULL) < 0)\n\t\t\terrExit(\"setgroups\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Username %s, no supplementary groups\\n\", cfg.username);\n\t}\n\telse {\n\t\tassert(cfg.username);\n\t\tgid_t groups[MAX_GROUPS];\n\t\tint ngroups = MAX_GROUPS;\n\t\tint rv = getgrouplist(cfg.username, gid, groups, &ngroups);\n\n\t\tif (arg_debug && rv) {\n\t\t\tprintf(\"Username %s, groups \", cfg.username);\n\t\t\tint i;\n\t\t\tfor (i = 0; i < ngroups; i++)\n\t\t\t\tprintf(\"%u, \", groups[i]);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\n\t\tif (rv == -1) {\n\t\t\tfprintf(stderr, \"Warning: cannot extract supplementary group list, dropping them\\n\");\n\t\t\tif (setgroups(0, NULL) < 0)\n\t\t\t\terrExit(\"setgroups\");\n\t\t}\n\t\telse {\n\t\t\trv = setgroups(ngroups, groups);\n\t\t\tif (rv) {\n\t\t\t\tfprintf(stderr, \"Warning: cannot set supplementary group list, dropping them\\n\");\n\t\t\t\tif (setgroups(0, NULL) < 0)\n\t\t\t\t\terrExit(\"setgroups\");\n\t\t\t}\n\t\t}\n\t}\n\n\t// set uid/gid\n\tif (setgid(getgid()) < 0)\n\t\terrExit(\"setgid/getgid\");\n\tif (setuid(getuid()) < 0)\n\t\terrExit(\"setuid/getuid\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "caps_set",
          "args": [
            "caps"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "caps_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/caps.c",
          "lines": "346-349",
          "snippet": "static void caps_set_bit(int nr) {\n\tuint64_t mask = 1LLU << nr;\n\tfilter |= mask;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>",
            "#include <stddef.h>",
            "#include <linux/filter.h>",
            "#include <errno.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static uint64_t filter;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n#include <stddef.h>\n#include <linux/filter.h>\n#include <errno.h>\n#include \"firejail.h\"\n\nstatic uint64_t filter;\n\nstatic void caps_set_bit(int nr) {\n\tuint64_t mask = 1LLU << nr;\n\tfilter |= mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "join_namespace",
          "args": [
            "1",
            "\"user\""
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Joining user namespace\\n\""
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"setenv\""
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"container\"",
            "\"firejail\"",
            "1"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"setenv\""
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"QT_X11_NO_MITSHM\"",
            "\"1\"",
            "1"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_set",
          "args": [],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/seccomp.c",
          "lines": "821-838",
          "snippet": "void seccomp_set(void) {\n\t// read seccomp filter from  /runp/firejail/mnt/seccomp\n\tread_seccomp_file(RUN_SECCOMP_CFG);\n\t\n\t// apply filter\n\tstruct sock_fprog prog = {\n\t\t.len = sfilter_index,\n\t\t.filter = sfilter,\n\t};\n\t\n\tif (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog) || prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {\n\t\tfprintf(stderr, \"Warning: seccomp disabled, it requires a Linux kernel version 3.5 or newer.\\n\");\n\t\treturn;\n\t}\n\telse if (arg_debug) {\n\t\tprintf(\"seccomp enabled\\n\");\n\t}\n}",
          "includes": [
            "#include \"seccomp.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"seccomp.h\"\n#include \"firejail.h\"\n\nvoid seccomp_set(void) {\n\t// read seccomp filter from  /runp/firejail/mnt/seccomp\n\tread_seccomp_file(RUN_SECCOMP_CFG);\n\t\n\t// apply filter\n\tstruct sock_fprog prog = {\n\t\t.len = sfilter_index,\n\t\t.filter = sfilter,\n\t};\n\t\n\tif (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog) || prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {\n\t\tfprintf(stderr, \"Warning: seccomp disabled, it requires a Linux kernel version 3.5 or newer.\\n\");\n\t\treturn;\n\t}\n\telse if (arg_debug) {\n\t\tprintf(\"seccomp enabled\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "protocol_filter",
          "args": [],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "protocol_filter_save",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/protocol.c",
          "lines": "268-278",
          "snippet": "void protocol_filter_save(void) {\n\t// save protocol filter configuration in PROTOCOL_CFG\n\tfs_build_mnt_dir();\n\n\tFILE *fp = fopen(RUN_PROTOCOL_CFG, \"w\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\tfprintf(fp, \"%s\\n\", cfg.protocol);\n\tSET_PERMS_STREAM(fp, 0, 0, 0600);\n\tfclose(fp);\n}",
          "includes": [
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"seccomp.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/socket.h>\n#include <sys/types.h>\n#include \"seccomp.h\"\n#include \"firejail.h\"\n\nvoid protocol_filter_save(void) {\n\t// save protocol filter configuration in PROTOCOL_CFG\n\tfs_build_mnt_dir();\n\n\tFILE *fp = fopen(RUN_PROTOCOL_CFG, \"w\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\tfprintf(fp, \"%s\\n\", cfg.protocol);\n\tSET_PERMS_STREAM(fp, 0, 0, 0600);\n\tfclose(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "protocol_filter_load",
          "args": [
            "RUN_PROTOCOL_CFG"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "protocol_filter_load",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/protocol.c",
          "lines": "280-303",
          "snippet": "void protocol_filter_load(const char *fname) {\n\tassert(fname);\n\t\n\t// read protocol filter configuration from PROTOCOL_CFG\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp)\n\t\treturn;\n\n\tconst int MAXBUF = 4098;\n\tchar buf[MAXBUF];\n\tif (fgets(buf, MAXBUF, fp) == NULL) {\n\t\t// empty file\n\t\tfclose(fp);\n\t\treturn;\n\t}\n\tfclose(fp);\n\t\n\tchar *ptr = strchr(buf, '\\n');\n\tif (ptr)\n\t\t*ptr = '\\0';\n\tcfg.protocol = strdup(buf);\n\tif (!cfg.protocol)\n\t\terrExit(\"strdup\");\n}",
          "includes": [
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"seccomp.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/socket.h>\n#include <sys/types.h>\n#include \"seccomp.h\"\n#include \"firejail.h\"\n\nvoid protocol_filter_load(const char *fname) {\n\tassert(fname);\n\t\n\t// read protocol filter configuration from PROTOCOL_CFG\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp)\n\t\treturn;\n\n\tconst int MAXBUF = 4098;\n\tchar buf[MAXBUF];\n\tif (fgets(buf, MAXBUF, fp) == NULL) {\n\t\t// empty file\n\t\tfclose(fp);\n\t\treturn;\n\t}\n\tfclose(fp);\n\t\n\tchar *ptr = strchr(buf, '\\n');\n\tif (ptr)\n\t\t*ptr = '\\0';\n\tcfg.protocol = strdup(buf);\n\tif (!cfg.protocol)\n\t\terrExit(\"strdup\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_cpu_affinity",
          "args": [],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "set_cpu_affinity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/cpu.c",
          "lines": "106-138",
          "snippet": "void set_cpu_affinity(void) {\n\t// set cpu affinity\n\tcpu_set_t mask;\n\tCPU_ZERO(&mask);\n\t\n\tint i;\n\tuint32_t m = 1;\n\tfor (i = 0; i < 32; i++, m <<= 1) {\n\t\tif (cfg.cpus & m)\n\t\t\tCPU_SET(i, &mask);\n\t}\n\t\n        \tif (sched_setaffinity(0, sizeof(mask), &mask) == -1) {\n        \t\tfprintf(stderr, \"Warning: cannot set cpu affinity\\n\");\n        \t\tfprintf(stderr, \"  \");\n        \t\tperror(\"sched_setaffinity\");\n        \t}\n        \t\n        \t// verify cpu affinity\n\tcpu_set_t mask2;\n\tCPU_ZERO(&mask2);\n        \tif (sched_getaffinity(0, sizeof(mask2), &mask2) == -1) {\n        \t\tfprintf(stderr, \"Warning: cannot verify cpu affinity\\n\");\n        \t\tfprintf(stderr, \"   \");\n        \t\tperror(\"sched_getaffinity\");\n        \t}\n        \telse if (arg_debug) {\n\t        \tif (CPU_EQUAL(&mask, &mask2))\n        \t\t\tprintf(\"CPU affinity set\\n\");\n\t\telse\n        \t\t\tprintf(\"CPU affinity not set\\n\");\n        \t}\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <sched.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <unistd.h>\n#include <sched.h>\n#include \"firejail.h\"\n\nvoid set_cpu_affinity(void) {\n\t// set cpu affinity\n\tcpu_set_t mask;\n\tCPU_ZERO(&mask);\n\t\n\tint i;\n\tuint32_t m = 1;\n\tfor (i = 0; i < 32; i++, m <<= 1) {\n\t\tif (cfg.cpus & m)\n\t\t\tCPU_SET(i, &mask);\n\t}\n\t\n        \tif (sched_setaffinity(0, sizeof(mask), &mask) == -1) {\n        \t\tfprintf(stderr, \"Warning: cannot set cpu affinity\\n\");\n        \t\tfprintf(stderr, \"  \");\n        \t\tperror(\"sched_setaffinity\");\n        \t}\n        \t\n        \t// verify cpu affinity\n\tcpu_set_t mask2;\n\tCPU_ZERO(&mask2);\n        \tif (sched_getaffinity(0, sizeof(mask2), &mask2) == -1) {\n        \t\tfprintf(stderr, \"Warning: cannot verify cpu affinity\\n\");\n        \t\tfprintf(stderr, \"   \");\n        \t\tperror(\"sched_getaffinity\");\n        \t}\n        \telse if (arg_debug) {\n\t        \tif (CPU_EQUAL(&mask, &mask2))\n        \t\t\tprintf(\"CPU affinity set\\n\");\n\t\telse\n        \t\t\tprintf(\"CPU affinity not set\\n\");\n        \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"chdir\""
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chdir",
          "args": [
            "homedir"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "homedir",
            "&s"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"chdir\""
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chdir",
          "args": [
            "\"/\""
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prctl",
          "args": [
            "PR_SET_PDEATHSIG",
            "SIGKILL",
            "0",
            "0",
            "0"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"changing root to %s\\n\"",
            "rootdir"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chroot",
          "args": [
            "rootdir"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "fs_chroot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
          "lines": "1184-1268",
          "snippet": "void fs_chroot(const char *rootdir) {\n\tassert(rootdir);\n\t\n\tif (checkcfg(CFG_CHROOT_DESKTOP)) {\n\t\t// mount-bind a /dev in rootdir\n\t\tchar *newdev;\n\t\tif (asprintf(&newdev, \"%s/dev\", rootdir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting /dev on %s\\n\", newdev);\n\t\tif (mount(\"/dev\", newdev, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mounting /dev\");\n\t\tfree(newdev);\n\t\t\n\t\t// x11\n\t\tif (getenv(\"FIREJAIL_X11\")) {\n\t\t\tmask_x11_abstract_socket = 1;\n\t\t\tchar *newx11;\n\t\t\tif (asprintf(&newx11, \"%s/tmp/.X11-unix\", rootdir) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Mounting /tmp/.X11-unix on %s\\n\", newx11);\n\t\t\tif (mount(\"/tmp/.X11-unix\", newx11, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mounting /tmp/.X11-unix\");\n\t\t\tfree(newx11);\n\t\t}\n\t\t\n\t\t// some older distros don't have a /run directory\n\t\t// create one by default\n\t\t// no exit on error, let the user deal with any problems\n\t\tchar *rundir;\n\t\tif (asprintf(&rundir, \"%s/run\", rootdir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (!is_dir(rundir)) {\n\t\t\tint rv = mkdir(rundir, 0755);\n\t\t\t(void) rv;\n\t\t\trv = chown(rundir, 0, 0);\n\t\t\t(void) rv;\n\t\t}\n\t\t\n\t\t// copy /etc/resolv.conf in chroot directory\n\t\t// if resolv.conf in chroot is a symbolic link, this will fail\n\t\t// no exit on error, let the user deal with the problem\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"%s/etc/resolv.conf\", rootdir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Updating /etc/resolv.conf in %s\\n\", fname);\n\t\tif (is_link(fname)) {\n\t\t\tfprintf(stderr, \"Error: invalid %s file\\n\", fname);\n\t\t\texit(1);\n\t\t}\n\t\tif (copy_file(\"/etc/resolv.conf\", fname, 0, 0, 0644) == -1)\n\t\t\tfprintf(stderr, \"Warning: /etc/resolv.conf not initialized\\n\");\n\t}\n\t\n\t// chroot into the new directory\n\tif (arg_debug)\n\t\tprintf(\"Chrooting into %s\\n\", rootdir);\n\tif (chroot(rootdir) < 0)\n\t\terrExit(\"chroot\");\n\t// mount a new tmpfs in /run/firejail/mnt - the old one was lost in chroot\n\tfs_build_remount_mnt_dir();\n\t\t\n\tif (checkcfg(CFG_CHROOT_DESKTOP)) {\n\t\t// update /var directory in order to support multiple sandboxes running on the same root directory\n\t\tif (!arg_private_dev)\n\t\t\tfs_dev_shm();\n\t\tfs_var_lock();\n\t\tfs_var_tmp();\n\t\tfs_var_log();\n\t\tfs_var_lib();\n\t\tfs_var_cache();\n\t\tfs_var_utmp();\n\t\n\t\t// don't leak user information\n\t\trestrict_users();\n\t\n\t\t// when starting as root, firejail config is not disabled;\n\t\t// this mode could be used to install and test new software by chaining\n\t\t// firejail sandboxes (firejail --force)\n\t\tif (getuid() != 0)\n\t\t\tdisable_config();\n\t}\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_chroot(const char *rootdir) {\n\tassert(rootdir);\n\t\n\tif (checkcfg(CFG_CHROOT_DESKTOP)) {\n\t\t// mount-bind a /dev in rootdir\n\t\tchar *newdev;\n\t\tif (asprintf(&newdev, \"%s/dev\", rootdir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting /dev on %s\\n\", newdev);\n\t\tif (mount(\"/dev\", newdev, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mounting /dev\");\n\t\tfree(newdev);\n\t\t\n\t\t// x11\n\t\tif (getenv(\"FIREJAIL_X11\")) {\n\t\t\tmask_x11_abstract_socket = 1;\n\t\t\tchar *newx11;\n\t\t\tif (asprintf(&newx11, \"%s/tmp/.X11-unix\", rootdir) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Mounting /tmp/.X11-unix on %s\\n\", newx11);\n\t\t\tif (mount(\"/tmp/.X11-unix\", newx11, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mounting /tmp/.X11-unix\");\n\t\t\tfree(newx11);\n\t\t}\n\t\t\n\t\t// some older distros don't have a /run directory\n\t\t// create one by default\n\t\t// no exit on error, let the user deal with any problems\n\t\tchar *rundir;\n\t\tif (asprintf(&rundir, \"%s/run\", rootdir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (!is_dir(rundir)) {\n\t\t\tint rv = mkdir(rundir, 0755);\n\t\t\t(void) rv;\n\t\t\trv = chown(rundir, 0, 0);\n\t\t\t(void) rv;\n\t\t}\n\t\t\n\t\t// copy /etc/resolv.conf in chroot directory\n\t\t// if resolv.conf in chroot is a symbolic link, this will fail\n\t\t// no exit on error, let the user deal with the problem\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"%s/etc/resolv.conf\", rootdir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Updating /etc/resolv.conf in %s\\n\", fname);\n\t\tif (is_link(fname)) {\n\t\t\tfprintf(stderr, \"Error: invalid %s file\\n\", fname);\n\t\t\texit(1);\n\t\t}\n\t\tif (copy_file(\"/etc/resolv.conf\", fname, 0, 0, 0644) == -1)\n\t\t\tfprintf(stderr, \"Warning: /etc/resolv.conf not initialized\\n\");\n\t}\n\t\n\t// chroot into the new directory\n\tif (arg_debug)\n\t\tprintf(\"Chrooting into %s\\n\", rootdir);\n\tif (chroot(rootdir) < 0)\n\t\terrExit(\"chroot\");\n\t// mount a new tmpfs in /run/firejail/mnt - the old one was lost in chroot\n\tfs_build_remount_mnt_dir();\n\t\t\n\tif (checkcfg(CFG_CHROOT_DESKTOP)) {\n\t\t// update /var directory in order to support multiple sandboxes running on the same root directory\n\t\tif (!arg_private_dev)\n\t\t\tfs_dev_shm();\n\t\tfs_var_lock();\n\t\tfs_var_tmp();\n\t\tfs_var_log();\n\t\tfs_var_lib();\n\t\tfs_var_cache();\n\t\tfs_var_utmp();\n\t\n\t\t// don't leak user information\n\t\trestrict_users();\n\t\n\t\t// when starting as root, firejail config is not disabled;\n\t\t// this mode could be used to install and test new software by chaining\n\t\t// firejail sandboxes (firejail --force)\n\t\tif (getuid() != 0)\n\t\t\tdisable_config();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&rootdir",
            "\"/proc/%d/root\"",
            "pid"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fork\""
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "join_namespace",
          "args": [
            "pid",
            "\"mnt\""
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "join_namespace",
          "args": [
            "pid",
            "\"uts\""
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "join_namespace",
          "args": [
            "pid",
            "\"pid\""
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "join_namespace",
          "args": [
            "pid",
            "\"net\""
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "join_namespace",
          "args": [
            "pid",
            "\"ipc\""
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "join_namespace",
          "args": [
            "pid",
            "\"mnt\""
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "join_namespace",
          "args": [
            "pid",
            "\"net\""
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_cgroup",
          "args": [
            "cfg.cgroup"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "set_cgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/cgroup.c",
          "lines": "72-119",
          "snippet": "void set_cgroup(const char *path) {\n\tEUID_ASSERT();\n\t\n\tinvalid_filename(path);\n\t\n\t// path starts with /sys/fs/cgroup\n\tif (strncmp(path, \"/sys/fs/cgroup\", 14) != 0)\n\t\tgoto errout;\n\t\n\t// path ends in tasks\n\tchar *ptr = strstr(path, \"tasks\");\n\tif (!ptr)\n\t\tgoto errout;\n\tif (*(ptr + 5) != '\\0')\n\t\tgoto errout;\n\t\n\t// no .. traversal\n\tptr = strstr(path, \"..\");\n\tif (ptr)\n\t\tgoto errout;\n\t\n\t// tasks file exists\n\tstruct stat s;\n\tif (stat(path, &s) == -1)\n\t\tgoto errout;\n\t\n\t// task file belongs to the user running the sandbox\n\tif (s.st_uid != getuid() && s.st_gid != getgid())\n\t\tgoto errout2;\n\t\t\n\t// add the task to cgroup\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(path,\t\"a\");\n\tif (!fp)\n\t\tgoto errout;\n\tpid_t pid = getpid();\n\tint rv = fprintf(fp, \"%d\\n\", pid);\n\t(void) rv;\n\tfclose(fp);\n\treturn;\n\nerrout:\t\t\n\tfprintf(stderr, \"Error: invalid cgroup\\n\");\n\texit(1);\nerrout2:\t\t\n\tfprintf(stderr, \"Error: you don't have permissions to use this control group\\n\");\n\texit(1);\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include \"firejail.h\"\n\nvoid set_cgroup(const char *path) {\n\tEUID_ASSERT();\n\t\n\tinvalid_filename(path);\n\t\n\t// path starts with /sys/fs/cgroup\n\tif (strncmp(path, \"/sys/fs/cgroup\", 14) != 0)\n\t\tgoto errout;\n\t\n\t// path ends in tasks\n\tchar *ptr = strstr(path, \"tasks\");\n\tif (!ptr)\n\t\tgoto errout;\n\tif (*(ptr + 5) != '\\0')\n\t\tgoto errout;\n\t\n\t// no .. traversal\n\tptr = strstr(path, \"..\");\n\tif (ptr)\n\t\tgoto errout;\n\t\n\t// tasks file exists\n\tstruct stat s;\n\tif (stat(path, &s) == -1)\n\t\tgoto errout;\n\t\n\t// task file belongs to the user running the sandbox\n\tif (s.st_uid != getuid() && s.st_gid != getgid())\n\t\tgoto errout2;\n\t\t\n\t// add the task to cgroup\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(path,\t\"a\");\n\tif (!fp)\n\t\tgoto errout;\n\tpid_t pid = getpid();\n\tint rv = fprintf(fp, \"%d\\n\", pid);\n\t(void) rv;\n\tfclose(fp);\n\treturn;\n\nerrout:\t\t\n\tfprintf(stderr, \"Error: invalid cgroup\\n\");\n\texit(1);\nerrout2:\t\t\n\tfprintf(stderr, \"Error: you don't have permissions to use this control group\\n\");\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "extract_user_namespace",
          "args": [
            "pid"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "extract_user_namespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/join.c",
          "lines": "142-174",
          "snippet": "static void extract_user_namespace(pid_t pid) {\n\t// test user namespaces available in the kernel\n\tstruct stat s1;\n\tstruct stat s2;\n\tstruct stat s3;\n\tif (stat(\"/proc/self/ns/user\", &s1) == 0 &&\n\t    stat(\"/proc/self/uid_map\", &s2) == 0 &&\n\t    stat(\"/proc/self/gid_map\", &s3) == 0);\n\telse\n\t\treturn;\n\t\t\t\n\t// read uid map\n\tchar *uidmap;\n\tif (asprintf(&uidmap, \"/proc/%u/uid_map\", pid) == -1)\n\t\terrExit(\"asprintf\");\n\tFILE *fp = fopen(uidmap, \"r\");\n\tif (!fp) {\n\t\tfree(uidmap);\n\t\treturn;\n\t}\n\n\t// check uid map\n\tint u1;\n\tint u2;\n\tif (fscanf(fp, \"%d %d\", &u1, &u2) == 2) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"User namespace detected: %s, %d, %d\\n\", uidmap, u1, u2);\n\t\tif (u1 != 0 || u2 != 0)\n\t\t\targ_noroot = 1;\n\t}\n\tfclose(fp);\n\tfree(uidmap);\n}",
          "includes": [
            "#include <errno.h>",
            "#include <sys/prctl.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <sys/prctl.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\nstatic void extract_user_namespace(pid_t pid) {\n\t// test user namespaces available in the kernel\n\tstruct stat s1;\n\tstruct stat s2;\n\tstruct stat s3;\n\tif (stat(\"/proc/self/ns/user\", &s1) == 0 &&\n\t    stat(\"/proc/self/uid_map\", &s2) == 0 &&\n\t    stat(\"/proc/self/gid_map\", &s3) == 0);\n\telse\n\t\treturn;\n\t\t\t\n\t// read uid map\n\tchar *uidmap;\n\tif (asprintf(&uidmap, \"/proc/%u/uid_map\", pid) == -1)\n\t\terrExit(\"asprintf\");\n\tFILE *fp = fopen(uidmap, \"r\");\n\tif (!fp) {\n\t\tfree(uidmap);\n\t\treturn;\n\t}\n\n\t// check uid map\n\tint u1;\n\tint u2;\n\tif (fscanf(fp, \"%d %d\", &u1, &u2) == 2) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"User namespace detected: %s, %d, %d\\n\", uidmap, u1, u2);\n\t\tif (u1 != 0 || u2 != 0)\n\t\t\targ_noroot = 1;\n\t}\n\tfclose(fp);\n\tfree(uidmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "extract_nogroups",
          "args": [
            "pid"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "extract_nogroups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/join.c",
          "lines": "65-76",
          "snippet": "static void extract_nogroups(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_GROUPS_CFG) == -1)\n\t\terrExit(\"asprintf\");\n\t\t\n\tstruct stat s;\n\tif (stat(fname, &s) == -1)\n\t\treturn;\n\n\targ_nogroups = 1;\n\tfree(fname);\n}",
          "includes": [
            "#include <errno.h>",
            "#include <sys/prctl.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <sys/prctl.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\nstatic void extract_nogroups(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_GROUPS_CFG) == -1)\n\t\terrExit(\"asprintf\");\n\t\t\n\tstruct stat s;\n\tif (stat(fname, &s) == -1)\n\t\treturn;\n\n\targ_nogroups = 1;\n\tfree(fname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "extract_cgroup",
          "args": [
            "pid"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "extract_cgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/join.c",
          "lines": "92-104",
          "snippet": "static void extract_cgroup(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_CGROUP_CFG) == -1)\n\t\terrExit(\"asprintf\");\n\t\t\n\tstruct stat s;\n\tif (stat(fname, &s) == -1)\n\t\treturn;\n\t\n\t// there is a cgroup file CGROUP_CFG, load it!\n\tload_cgroup(fname);\n\tfree(fname);\n}",
          "includes": [
            "#include <errno.h>",
            "#include <sys/prctl.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <sys/prctl.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\nstatic void extract_cgroup(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_CGROUP_CFG) == -1)\n\t\terrExit(\"asprintf\");\n\t\t\n\tstruct stat s;\n\tif (stat(fname, &s) == -1)\n\t\treturn;\n\t\n\t// there is a cgroup file CGROUP_CFG, load it!\n\tload_cgroup(fname);\n\tfree(fname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "extract_cpu",
          "args": [
            "pid"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "extract_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/join.c",
          "lines": "78-90",
          "snippet": "static void extract_cpu(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_CPU_CFG) == -1)\n\t\terrExit(\"asprintf\");\n\t\t\n\tstruct stat s;\n\tif (stat(fname, &s) == -1)\n\t\treturn;\n\t\n\t// there is a CPU_CFG file, load it!\n\tload_cpu(fname);\n\tfree(fname);\n}",
          "includes": [
            "#include <errno.h>",
            "#include <sys/prctl.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <sys/prctl.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\nstatic void extract_cpu(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_CPU_CFG) == -1)\n\t\terrExit(\"asprintf\");\n\t\t\n\tstruct stat s;\n\tif (stat(fname, &s) == -1)\n\t\treturn;\n\t\n\t// there is a CPU_CFG file, load it!\n\tload_cpu(fname);\n\tfree(fname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "extract_caps_seccomp",
          "args": [
            "pid"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "extract_caps_seccomp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/join.c",
          "lines": "106-140",
          "snippet": "static void extract_caps_seccomp(pid_t pid) {\n\t// open stat file\n\tchar *file;\n\tif (asprintf(&file, \"/proc/%u/status\", pid) == -1) {\n\t\tperror(\"asprintf\");\n\t\texit(1);\n\t}\n\tFILE *fp = fopen(file, \"r\");\n\tif (!fp) {\n\t\tfree(file);\n\t\tfprintf(stderr, \"Error: cannot open stat file for process %u\\n\", pid);\n\t\texit(1);\n\t}\n\n\tchar buf[BUFLEN];\n\twhile (fgets(buf, BUFLEN - 1, fp)) {\n\t\tif (strncmp(buf, \"Seccomp:\", 8) == 0) {\n\t\t\tchar *ptr = buf + 8;\n\t\t\tint val;\n\t\t\tsscanf(ptr, \"%d\", &val);\n\t\t\tif (val == 2)\n\t\t\t\tapply_seccomp = 1;\n\t\t\tbreak;\n\t\t}\n\t\telse if (strncmp(buf, \"CapBnd:\", 7) == 0) {\t\t\n\t\t\tchar *ptr = buf + 7;\n\t\t\tunsigned long long val;\n\t\t\tsscanf(ptr, \"%llx\", &val);\n\t\t\tapply_caps = 1;\n\t\t\tcaps = val;\n\t\t}\n\t}\n\tfclose(fp);\n\tfree(file);\n}",
          "includes": [
            "#include <errno.h>",
            "#include <sys/prctl.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define BUFLEN 4096"
          ],
          "globals_used": [
            "static int apply_caps = 0;",
            "static uint64_t caps = 0;",
            "static int apply_seccomp = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <sys/prctl.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\n#define BUFLEN 4096\n\nstatic int apply_caps = 0;\nstatic uint64_t caps = 0;\nstatic int apply_seccomp = 0;\n\nstatic void extract_caps_seccomp(pid_t pid) {\n\t// open stat file\n\tchar *file;\n\tif (asprintf(&file, \"/proc/%u/status\", pid) == -1) {\n\t\tperror(\"asprintf\");\n\t\texit(1);\n\t}\n\tFILE *fp = fopen(file, \"r\");\n\tif (!fp) {\n\t\tfree(file);\n\t\tfprintf(stderr, \"Error: cannot open stat file for process %u\\n\", pid);\n\t\texit(1);\n\t}\n\n\tchar buf[BUFLEN];\n\twhile (fgets(buf, BUFLEN - 1, fp)) {\n\t\tif (strncmp(buf, \"Seccomp:\", 8) == 0) {\n\t\t\tchar *ptr = buf + 8;\n\t\t\tint val;\n\t\t\tsscanf(ptr, \"%d\", &val);\n\t\t\tif (val == 2)\n\t\t\t\tapply_seccomp = 1;\n\t\t\tbreak;\n\t\t}\n\t\telse if (strncmp(buf, \"CapBnd:\", 7) == 0) {\t\t\n\t\t\tchar *ptr = buf + 7;\n\t\t\tunsigned long long val;\n\t\t\tsscanf(ptr, \"%llx\", &val);\n\t\t\tapply_caps = 1;\n\t\t\tcaps = val;\n\t\t}\n\t}\n\tfclose(fp);\n\tfree(file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ROOT",
          "args": [],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: permission is denied to join a sandbox created by a different user.\\n\""
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pid_get_uid",
          "args": [
            "pid"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "pid_get_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/util.c",
          "lines": "621-665",
          "snippet": "uid_t pid_get_uid(pid_t pid) {\n\tEUID_ASSERT();\n\tuid_t rv = 0;\n\n\t// open status file\n\tchar *file;\n\tif (asprintf(&file, \"/proc/%u/status\", pid) == -1) {\n\t\tperror(\"asprintf\");\n\t\texit(1);\n\t}\n\tEUID_ROOT();\t\t\t\t  // grsecurity fix\n\tFILE *fp = fopen(file, \"r\");\n\tif (!fp) {\n\t\tfree(file);\n\t\tfprintf(stderr, \"Error: cannot open /proc file\\n\");\n\t\texit(1);\n\t}\n\n\t// extract uid\n\tstatic const int PIDS_BUFLEN = 1024;\n\tchar buf[PIDS_BUFLEN];\n\twhile (fgets(buf, PIDS_BUFLEN - 1, fp)) {\n\t\tif (strncmp(buf, \"Uid:\", 4) == 0) {\n\t\t\tchar *ptr = buf + 5;\n\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\tptr++;\n\t\t\t}\n\t\t\tif (*ptr == '\\0')\n\t\t\t\tbreak;\n\n\t\t\trv = atoi(ptr);\n\t\t\tbreak;\t\t\t  // break regardless!\n\t\t}\n\t}\n\n\tfclose(fp);\n\tfree(file);\n\tEUID_USER();\t\t\t\t  // grsecurity fix\n\n\tif (rv == 0) {\n\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\texit(1);\n\t}\n\treturn rv;\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nuid_t pid_get_uid(pid_t pid) {\n\tEUID_ASSERT();\n\tuid_t rv = 0;\n\n\t// open status file\n\tchar *file;\n\tif (asprintf(&file, \"/proc/%u/status\", pid) == -1) {\n\t\tperror(\"asprintf\");\n\t\texit(1);\n\t}\n\tEUID_ROOT();\t\t\t\t  // grsecurity fix\n\tFILE *fp = fopen(file, \"r\");\n\tif (!fp) {\n\t\tfree(file);\n\t\tfprintf(stderr, \"Error: cannot open /proc file\\n\");\n\t\texit(1);\n\t}\n\n\t// extract uid\n\tstatic const int PIDS_BUFLEN = 1024;\n\tchar buf[PIDS_BUFLEN];\n\twhile (fgets(buf, PIDS_BUFLEN - 1, fp)) {\n\t\tif (strncmp(buf, \"Uid:\", 4) == 0) {\n\t\t\tchar *ptr = buf + 5;\n\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\tptr++;\n\t\t\t}\n\t\t\tif (*ptr == '\\0')\n\t\t\t\tbreak;\n\n\t\t\trv = atoi(ptr);\n\t\t\tbreak;\t\t\t  // break regardless!\n\t\t}\n\t}\n\n\tfclose(fp);\n\tfree(file);\n\tEUID_USER();\t\t\t\t  // grsecurity fix\n\n\tif (rv == 0) {\n\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\texit(1);\n\t}\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "comm"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Switching to pid %u, the first child process inside the sandbox\\n\"",
            "(unsigned) pid"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_child",
          "args": [
            "pid",
            "&child"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "find_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/util.c",
          "lines": "395-454",
          "snippet": "int find_child(pid_t parent, pid_t *child) {\n\tEUID_ASSERT();\n\t*child = 0;\t\t\t\t  // use it to flag a found child\n\n\tDIR *dir;\n\tEUID_ROOT();\t\t\t\t  // grsecurity fix\n\tif (!(dir = opendir(\"/proc\"))) {\n\t\t// sleep 2 seconds and try again\n\t\tsleep(2);\n\t\tif (!(dir = opendir(\"/proc\"))) {\n\t\t\tfprintf(stderr, \"Error: cannot open /proc directory\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tstruct dirent *entry;\n\tchar *end;\n\twhile (*child == 0 && (entry = readdir(dir))) {\n\t\tpid_t pid = strtol(entry->d_name, &end, 10);\n\t\tif (end == entry->d_name || *end)\n\t\t\tcontinue;\n\t\tif (pid == parent)\n\t\t\tcontinue;\n\n\t\t// open stat file\n\t\tchar *file;\n\t\tif (asprintf(&file, \"/proc/%u/status\", pid) == -1) {\n\t\t\tperror(\"asprintf\");\n\t\t\texit(1);\n\t\t}\n\t\tFILE *fp = fopen(file, \"r\");\n\t\tif (!fp) {\n\t\t\tfree(file);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// look for firejail executable name\n\t\tchar buf[BUFLEN];\n\t\twhile (fgets(buf, BUFLEN - 1, fp)) {\n\t\t\tif (strncmp(buf, \"PPid:\", 5) == 0) {\n\t\t\t\tchar *ptr = buf + 5;\n\t\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\tif (*ptr == '\\0') {\n\t\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tif (parent == atoi(ptr))\n\t\t\t\t\t*child = pid;\n\t\t\t\tbreak;\t\t  // stop reading the file\n\t\t\t}\n\t\t}\n\t\tfclose(fp);\n\t\tfree(file);\n\t}\n\tclosedir(dir);\n\tEUID_USER();\n\treturn (*child)? 0:1;\t\t\t  // 0 = found, 1 = not found\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define BUFLEN 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\n#define BUFLEN 4096\n\nint find_child(pid_t parent, pid_t *child) {\n\tEUID_ASSERT();\n\t*child = 0;\t\t\t\t  // use it to flag a found child\n\n\tDIR *dir;\n\tEUID_ROOT();\t\t\t\t  // grsecurity fix\n\tif (!(dir = opendir(\"/proc\"))) {\n\t\t// sleep 2 seconds and try again\n\t\tsleep(2);\n\t\tif (!(dir = opendir(\"/proc\"))) {\n\t\t\tfprintf(stderr, \"Error: cannot open /proc directory\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tstruct dirent *entry;\n\tchar *end;\n\twhile (*child == 0 && (entry = readdir(dir))) {\n\t\tpid_t pid = strtol(entry->d_name, &end, 10);\n\t\tif (end == entry->d_name || *end)\n\t\t\tcontinue;\n\t\tif (pid == parent)\n\t\t\tcontinue;\n\n\t\t// open stat file\n\t\tchar *file;\n\t\tif (asprintf(&file, \"/proc/%u/status\", pid) == -1) {\n\t\t\tperror(\"asprintf\");\n\t\t\texit(1);\n\t\t}\n\t\tFILE *fp = fopen(file, \"r\");\n\t\tif (!fp) {\n\t\t\tfree(file);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// look for firejail executable name\n\t\tchar buf[BUFLEN];\n\t\twhile (fgets(buf, BUFLEN - 1, fp)) {\n\t\t\tif (strncmp(buf, \"PPid:\", 5) == 0) {\n\t\t\t\tchar *ptr = buf + 5;\n\t\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\tif (*ptr == '\\0') {\n\t\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tif (parent == atoi(ptr))\n\t\t\t\t\t*child = pid;\n\t\t\t\tbreak;\t\t  // stop reading the file\n\t\t\t}\n\t\t}\n\t\tfclose(fp);\n\t\tfree(file);\n\t}\n\tclosedir(dir);\n\tEUID_USER();\n\treturn (*child)? 0:1;\t\t\t  // 0 = found, 1 = not found\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "comm",
            "\"firejail\""
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_USER",
          "args": [],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pid_proc_comm",
          "args": [
            "pid"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ROOT",
          "args": [],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGTERM",
            "signal_handler"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extract_command",
          "args": [
            "argc",
            "argv",
            "index"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "extract_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/join.c",
          "lines": "39-63",
          "snippet": "static void extract_command(int argc, char **argv, int index) {\n\tEUID_ASSERT();\n\tif (index >= argc)\n\t\treturn;\n\n\t// doubledash followed by positional parameters\n\tif (strcmp(argv[index], \"--\") == 0) {\n\t\targ_doubledash = 1;\n\t\tindex++;\n\t\tif (index >= argc)\n\t\t\treturn;\n\t}\n\t\t\n\t// first argv needs to be a valid command\n\tif (arg_doubledash == 0 && *argv[index] == '-') {\n\t\tfprintf(stderr, \"Error: invalid option %s after --join\\n\", argv[index]);\n\t\texit(1);\n\t}\n\n\t// build command\n\tbuild_cmdline(&cfg.command_line, &cfg.window_title, argc, argv, index);\n\n\tif (arg_debug)\n\t\tprintf(\"Extracted command #%s#\\n\", cfg.command_line);\n}",
          "includes": [
            "#include <errno.h>",
            "#include <sys/prctl.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <sys/prctl.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\nstatic void extract_command(int argc, char **argv, int index) {\n\tEUID_ASSERT();\n\tif (index >= argc)\n\t\treturn;\n\n\t// doubledash followed by positional parameters\n\tif (strcmp(argv[index], \"--\") == 0) {\n\t\targ_doubledash = 1;\n\t\tindex++;\n\t\tif (index >= argc)\n\t\t\treturn;\n\t}\n\t\t\n\t// first argv needs to be a valid command\n\tif (arg_doubledash == 0 && *argv[index] == '-') {\n\t\tfprintf(stderr, \"Error: invalid option %s after --join\\n\", argv[index]);\n\t\texit(1);\n\t}\n\n\t// build command\n\tbuild_cmdline(&cfg.command_line, &cfg.window_title, argc, argv, index);\n\n\tif (arg_debug)\n\t\tprintf(\"Extracted command #%s#\\n\", cfg.command_line);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <sys/prctl.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\nstatic int apply_caps = 0;\nstatic uint64_t caps = 0;\nstatic int apply_seccomp = 0;\n\nvoid join(pid_t pid, int argc, char **argv, int index) {\n\tEUID_ASSERT();\n\tchar *homedir = cfg.homedir;\n\t\n\textract_command(argc, argv, index);\n\tsignal (SIGTERM, signal_handler);\n\n\t// if the pid is that of a firejail  process, use the pid of the first child process\n\tEUID_ROOT();\n\tchar *comm = pid_proc_comm(pid);\n\tEUID_USER();\n\tif (comm) {\n\t\tif (strcmp(comm, \"firejail\") == 0) {\n\t\t\tpid_t child;\n\t\t\tif (find_child(pid, &child) == 0) {\n\t\t\t\tpid = child;\n\t\t\t\tprintf(\"Switching to pid %u, the first child process inside the sandbox\\n\", (unsigned) pid);\n\t\t\t}\n\t\t}\n\t\tfree(comm);\n\t}\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission is denied to join a sandbox created by a different user.\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tEUID_ROOT();\n\t// in user mode set caps seccomp, cpu, cgroup, etc\n\tif (getuid() != 0) {\n\t\textract_caps_seccomp(pid);\n\t\textract_cpu(pid);\n\t\textract_cgroup(pid);\n\t\textract_nogroups(pid);\n\t\textract_user_namespace(pid);\n\t}\n\t\n\t// set cgroup\n\tif (cfg.cgroup)\t// not available for uid 0\n\t\tset_cgroup(cfg.cgroup);\n\t\t\n\t// join namespaces\n\tif (arg_join_network) {\n\t\tif (join_namespace(pid, \"net\"))\n\t\t\texit(1);\n\t}\n\telse if (arg_join_filesystem) {\n\t\tif (join_namespace(pid, \"mnt\"))\n\t\t\texit(1);\n\t}\n\telse {\n\t\tif (join_namespace(pid, \"ipc\"))\n\t\t\texit(1);\n\t\tif (join_namespace(pid, \"net\"))\n\t\t\texit(1);\n\t\tif (join_namespace(pid, \"pid\"))\n\t\t\texit(1);\n\t\tif (join_namespace(pid, \"uts\"))\n\t\t\texit(1);\n\t\tif (join_namespace(pid, \"mnt\"))\n\t\t\texit(1);\n\t}\n\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// chroot into /proc/PID/root directory\n\t\tchar *rootdir;\n\t\tif (asprintf(&rootdir, \"/proc/%d/root\", pid) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\t\t\n\t\tint rv;\n\t\tif (!arg_join_network) {\n\t\t\trv = chroot(rootdir); // this will fail for processes in sandboxes not started with --chroot option\n\t\t\tif (rv == 0)\n\t\t\t\tprintf(\"changing root to %s\\n\", rootdir);\n\t\t}\n\t\t\n\t\tprctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0); // kill the child in case the parent died\n\t\tif (chdir(\"/\") < 0)\n\t\t\terrExit(\"chdir\");\n\t\tif (homedir) {\n\t\t\tstruct stat s;\n\t\t\tif (stat(homedir, &s) == 0) {\n\t\t\t\t/* coverity[toctou] */\n\t\t\t\tif (chdir(homedir) < 0)\n\t\t\t\t\terrExit(\"chdir\");\n\t\t\t}\n\t\t}\n\t\t\n\t\t// set cpu affinity\n\t\tif (cfg.cpus)\t// not available for uid 0\n\t\t\tset_cpu_affinity();\n\t\t\t\t\t\n\t\t// set caps filter\n\t\tif (apply_caps == 1)\t// not available for uid 0\n\t\t\tcaps_set(caps);\n#ifdef HAVE_SECCOMP\n\t\t// set protocol filter\n\t\tif (getuid() != 0)\n\t\t\tprotocol_filter_load(RUN_PROTOCOL_CFG);\n\t\tif (cfg.protocol) {\t// not available for uid 0\n\t\t\tprotocol_filter();\n\t\t}\n\t\t\t\t\n\t\t// set seccomp filter\n\t\tif (apply_seccomp == 1)\t// not available for uid 0\n\t\t\tseccomp_set();\n#endif\n\n\t\t// fix qt 4.8\n\t\tif (setenv(\"QT_X11_NO_MITSHM\", \"1\", 1) < 0)\n\t\t\terrExit(\"setenv\");\n\t\tif (setenv(\"container\", \"firejail\", 1) < 0) // LXC sets container=lxc,\n\t\t\terrExit(\"setenv\");\n\n\t\t// mount user namespace or drop privileges\n\t\tif (arg_noroot) {\t// not available for uid 0\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Joining user namespace\\n\");\n\t\t\tif (join_namespace(1, \"user\"))\n\t\t\t\texit(1);\n\n\t\t\t// user namespace resets capabilities\n\t\t\t// set caps filter\n\t\t\tif (apply_caps == 1)\t// not available for uid 0\n\t\t\t\tcaps_set(caps);\n\t\t}\n\t\telse \n\t\t\tdrop_privs(arg_nogroups);\t// nogroups not available for uid 0\n\n\n\t\t// set prompt color to green\n\t\tchar *prompt = getenv(\"FIREJAIL_PROMPT\");\n\t\tif (prompt && strcmp(prompt, \"yes\") == 0) {\n\t\t\t//export PS1='\\[\\e[1;32m\\][\\u@\\h \\W]\\$\\[\\e[0m\\] '\n\t\t\tif (setenv(\"PROMPT_COMMAND\", \"export PS1=\\\"\\\\[\\\\e[1;32m\\\\][\\\\u@\\\\h \\\\W]\\\\$\\\\[\\\\e[0m\\\\] \\\"\", 1) < 0)\n\t\t\t\terrExit(\"setenv\");\n\t\t}\n\t\t\n\t\t// set nice\n\t\tif (arg_nice) {\n\t\t\terrno = 0;\n\t\t\tint rv = nice(cfg.nice);\n\t\t\t(void) rv;\n\t\t\tif (errno) {\n\t\t\t\tfprintf(stderr, \"Warning: cannot set nice value\\n\");\n\t\t\t\terrno = 0;\n\t\t\t}\n\t\t}\n\n\t\t// run cmdline trough shell\n\t\tif (cfg.command_line == NULL) {\n\t\t\t// if the sandbox was started with --shell=none, it is possible we don't have a shell\n\t\t\t// inside the sandbox\n\t\t\tif (cfg.shell == NULL) {\n\t\t\t\tcfg.shell = guess_shell();\n\t\t\t\tif (!cfg.shell) {\n\t\t\t\t\tfprintf(stderr, \"Error: no POSIX shell found, please use --shell command line option\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t\n\t\t\tstruct stat s;\n\t\t\tif (stat(cfg.shell, &s) == -1)  {\n\t\t\t\tfprintf(stderr, \"Error: %s shell not found inside the sandbox\\n\", cfg.shell);\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tcfg.command_line = cfg.shell;\n\t\t\tcfg.window_title = cfg.shell;\n\t\t}\n\n\t\tint cwd = 0;\n\t\tif (cfg.cwd) {\n\t\t\tif (chdir(cfg.cwd) == 0)\n\t\t\t\tcwd = 1;\n\t\t}\n\n\t\tif (!cwd) {\n\t\t\tif (chdir(\"/\") < 0)\n\t\t\t\terrExit(\"chdir\");\n\t\t\tif (cfg.homedir) {\n\t\t\t\tstruct stat s;\n\t\t\t\tif (stat(cfg.homedir, &s) == 0) {\n\t\t\t\t\t/* coverity[toctou] */\n\t\t\t\t\tif (chdir(cfg.homedir) < 0)\n\t\t\t\t\t\terrExit(\"chdir\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstart_application();\n\n\t\t// it will never get here!!!\n\t}\n\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n\tflush_stdin();\n\texit(0);\n}"
  },
  {
    "function_name": "join_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/join.c",
    "lines": "176-189",
    "snippet": "void join_name(const char *name, int argc, char **argv, int index) {\n\tEUID_ASSERT();\n\tif (!name || strlen(name) == 0) {\n\t\tfprintf(stderr, \"Error: invalid sandbox name\\n\");\n\t\texit(1);\n\t}\n\n\tpid_t pid;\n\tif (name2pid(name, &pid)) {\n\t\tfprintf(stderr, \"Error: cannot find sandbox %s\\n\", name);\n\t\texit(1);\n\t}\n\tjoin(pid, argc, argv, index);\n}",
    "includes": [
      "#include <errno.h>",
      "#include <sys/prctl.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "join",
          "args": [
            "pid",
            "argc",
            "argv",
            "index"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "join",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/join.c",
          "lines": "191-398",
          "snippet": "void join(pid_t pid, int argc, char **argv, int index) {\n\tEUID_ASSERT();\n\tchar *homedir = cfg.homedir;\n\t\n\textract_command(argc, argv, index);\n\tsignal (SIGTERM, signal_handler);\n\n\t// if the pid is that of a firejail  process, use the pid of the first child process\n\tEUID_ROOT();\n\tchar *comm = pid_proc_comm(pid);\n\tEUID_USER();\n\tif (comm) {\n\t\tif (strcmp(comm, \"firejail\") == 0) {\n\t\t\tpid_t child;\n\t\t\tif (find_child(pid, &child) == 0) {\n\t\t\t\tpid = child;\n\t\t\t\tprintf(\"Switching to pid %u, the first child process inside the sandbox\\n\", (unsigned) pid);\n\t\t\t}\n\t\t}\n\t\tfree(comm);\n\t}\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission is denied to join a sandbox created by a different user.\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tEUID_ROOT();\n\t// in user mode set caps seccomp, cpu, cgroup, etc\n\tif (getuid() != 0) {\n\t\textract_caps_seccomp(pid);\n\t\textract_cpu(pid);\n\t\textract_cgroup(pid);\n\t\textract_nogroups(pid);\n\t\textract_user_namespace(pid);\n\t}\n\t\n\t// set cgroup\n\tif (cfg.cgroup)\t// not available for uid 0\n\t\tset_cgroup(cfg.cgroup);\n\t\t\n\t// join namespaces\n\tif (arg_join_network) {\n\t\tif (join_namespace(pid, \"net\"))\n\t\t\texit(1);\n\t}\n\telse if (arg_join_filesystem) {\n\t\tif (join_namespace(pid, \"mnt\"))\n\t\t\texit(1);\n\t}\n\telse {\n\t\tif (join_namespace(pid, \"ipc\"))\n\t\t\texit(1);\n\t\tif (join_namespace(pid, \"net\"))\n\t\t\texit(1);\n\t\tif (join_namespace(pid, \"pid\"))\n\t\t\texit(1);\n\t\tif (join_namespace(pid, \"uts\"))\n\t\t\texit(1);\n\t\tif (join_namespace(pid, \"mnt\"))\n\t\t\texit(1);\n\t}\n\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// chroot into /proc/PID/root directory\n\t\tchar *rootdir;\n\t\tif (asprintf(&rootdir, \"/proc/%d/root\", pid) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\t\t\n\t\tint rv;\n\t\tif (!arg_join_network) {\n\t\t\trv = chroot(rootdir); // this will fail for processes in sandboxes not started with --chroot option\n\t\t\tif (rv == 0)\n\t\t\t\tprintf(\"changing root to %s\\n\", rootdir);\n\t\t}\n\t\t\n\t\tprctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0); // kill the child in case the parent died\n\t\tif (chdir(\"/\") < 0)\n\t\t\terrExit(\"chdir\");\n\t\tif (homedir) {\n\t\t\tstruct stat s;\n\t\t\tif (stat(homedir, &s) == 0) {\n\t\t\t\t/* coverity[toctou] */\n\t\t\t\tif (chdir(homedir) < 0)\n\t\t\t\t\terrExit(\"chdir\");\n\t\t\t}\n\t\t}\n\t\t\n\t\t// set cpu affinity\n\t\tif (cfg.cpus)\t// not available for uid 0\n\t\t\tset_cpu_affinity();\n\t\t\t\t\t\n\t\t// set caps filter\n\t\tif (apply_caps == 1)\t// not available for uid 0\n\t\t\tcaps_set(caps);\n#ifdef HAVE_SECCOMP\n\t\t// set protocol filter\n\t\tif (getuid() != 0)\n\t\t\tprotocol_filter_load(RUN_PROTOCOL_CFG);\n\t\tif (cfg.protocol) {\t// not available for uid 0\n\t\t\tprotocol_filter();\n\t\t}\n\t\t\t\t\n\t\t// set seccomp filter\n\t\tif (apply_seccomp == 1)\t// not available for uid 0\n\t\t\tseccomp_set();\n#endif\n\n\t\t// fix qt 4.8\n\t\tif (setenv(\"QT_X11_NO_MITSHM\", \"1\", 1) < 0)\n\t\t\terrExit(\"setenv\");\n\t\tif (setenv(\"container\", \"firejail\", 1) < 0) // LXC sets container=lxc,\n\t\t\terrExit(\"setenv\");\n\n\t\t// mount user namespace or drop privileges\n\t\tif (arg_noroot) {\t// not available for uid 0\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Joining user namespace\\n\");\n\t\t\tif (join_namespace(1, \"user\"))\n\t\t\t\texit(1);\n\n\t\t\t// user namespace resets capabilities\n\t\t\t// set caps filter\n\t\t\tif (apply_caps == 1)\t// not available for uid 0\n\t\t\t\tcaps_set(caps);\n\t\t}\n\t\telse \n\t\t\tdrop_privs(arg_nogroups);\t// nogroups not available for uid 0\n\n\n\t\t// set prompt color to green\n\t\tchar *prompt = getenv(\"FIREJAIL_PROMPT\");\n\t\tif (prompt && strcmp(prompt, \"yes\") == 0) {\n\t\t\t//export PS1='\\[\\e[1;32m\\][\\u@\\h \\W]\\$\\[\\e[0m\\] '\n\t\t\tif (setenv(\"PROMPT_COMMAND\", \"export PS1=\\\"\\\\[\\\\e[1;32m\\\\][\\\\u@\\\\h \\\\W]\\\\$\\\\[\\\\e[0m\\\\] \\\"\", 1) < 0)\n\t\t\t\terrExit(\"setenv\");\n\t\t}\n\t\t\n\t\t// set nice\n\t\tif (arg_nice) {\n\t\t\terrno = 0;\n\t\t\tint rv = nice(cfg.nice);\n\t\t\t(void) rv;\n\t\t\tif (errno) {\n\t\t\t\tfprintf(stderr, \"Warning: cannot set nice value\\n\");\n\t\t\t\terrno = 0;\n\t\t\t}\n\t\t}\n\n\t\t// run cmdline trough shell\n\t\tif (cfg.command_line == NULL) {\n\t\t\t// if the sandbox was started with --shell=none, it is possible we don't have a shell\n\t\t\t// inside the sandbox\n\t\t\tif (cfg.shell == NULL) {\n\t\t\t\tcfg.shell = guess_shell();\n\t\t\t\tif (!cfg.shell) {\n\t\t\t\t\tfprintf(stderr, \"Error: no POSIX shell found, please use --shell command line option\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t\n\t\t\tstruct stat s;\n\t\t\tif (stat(cfg.shell, &s) == -1)  {\n\t\t\t\tfprintf(stderr, \"Error: %s shell not found inside the sandbox\\n\", cfg.shell);\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tcfg.command_line = cfg.shell;\n\t\t\tcfg.window_title = cfg.shell;\n\t\t}\n\n\t\tint cwd = 0;\n\t\tif (cfg.cwd) {\n\t\t\tif (chdir(cfg.cwd) == 0)\n\t\t\t\tcwd = 1;\n\t\t}\n\n\t\tif (!cwd) {\n\t\t\tif (chdir(\"/\") < 0)\n\t\t\t\terrExit(\"chdir\");\n\t\t\tif (cfg.homedir) {\n\t\t\t\tstruct stat s;\n\t\t\t\tif (stat(cfg.homedir, &s) == 0) {\n\t\t\t\t\t/* coverity[toctou] */\n\t\t\t\t\tif (chdir(cfg.homedir) < 0)\n\t\t\t\t\t\terrExit(\"chdir\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstart_application();\n\n\t\t// it will never get here!!!\n\t}\n\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n\tflush_stdin();\n\texit(0);\n}",
          "includes": [
            "#include <errno.h>",
            "#include <sys/prctl.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int apply_caps = 0;",
            "static uint64_t caps = 0;",
            "static int apply_seccomp = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <sys/prctl.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\nstatic int apply_caps = 0;\nstatic uint64_t caps = 0;\nstatic int apply_seccomp = 0;\n\nvoid join(pid_t pid, int argc, char **argv, int index) {\n\tEUID_ASSERT();\n\tchar *homedir = cfg.homedir;\n\t\n\textract_command(argc, argv, index);\n\tsignal (SIGTERM, signal_handler);\n\n\t// if the pid is that of a firejail  process, use the pid of the first child process\n\tEUID_ROOT();\n\tchar *comm = pid_proc_comm(pid);\n\tEUID_USER();\n\tif (comm) {\n\t\tif (strcmp(comm, \"firejail\") == 0) {\n\t\t\tpid_t child;\n\t\t\tif (find_child(pid, &child) == 0) {\n\t\t\t\tpid = child;\n\t\t\t\tprintf(\"Switching to pid %u, the first child process inside the sandbox\\n\", (unsigned) pid);\n\t\t\t}\n\t\t}\n\t\tfree(comm);\n\t}\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission is denied to join a sandbox created by a different user.\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tEUID_ROOT();\n\t// in user mode set caps seccomp, cpu, cgroup, etc\n\tif (getuid() != 0) {\n\t\textract_caps_seccomp(pid);\n\t\textract_cpu(pid);\n\t\textract_cgroup(pid);\n\t\textract_nogroups(pid);\n\t\textract_user_namespace(pid);\n\t}\n\t\n\t// set cgroup\n\tif (cfg.cgroup)\t// not available for uid 0\n\t\tset_cgroup(cfg.cgroup);\n\t\t\n\t// join namespaces\n\tif (arg_join_network) {\n\t\tif (join_namespace(pid, \"net\"))\n\t\t\texit(1);\n\t}\n\telse if (arg_join_filesystem) {\n\t\tif (join_namespace(pid, \"mnt\"))\n\t\t\texit(1);\n\t}\n\telse {\n\t\tif (join_namespace(pid, \"ipc\"))\n\t\t\texit(1);\n\t\tif (join_namespace(pid, \"net\"))\n\t\t\texit(1);\n\t\tif (join_namespace(pid, \"pid\"))\n\t\t\texit(1);\n\t\tif (join_namespace(pid, \"uts\"))\n\t\t\texit(1);\n\t\tif (join_namespace(pid, \"mnt\"))\n\t\t\texit(1);\n\t}\n\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// chroot into /proc/PID/root directory\n\t\tchar *rootdir;\n\t\tif (asprintf(&rootdir, \"/proc/%d/root\", pid) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\t\t\n\t\tint rv;\n\t\tif (!arg_join_network) {\n\t\t\trv = chroot(rootdir); // this will fail for processes in sandboxes not started with --chroot option\n\t\t\tif (rv == 0)\n\t\t\t\tprintf(\"changing root to %s\\n\", rootdir);\n\t\t}\n\t\t\n\t\tprctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0); // kill the child in case the parent died\n\t\tif (chdir(\"/\") < 0)\n\t\t\terrExit(\"chdir\");\n\t\tif (homedir) {\n\t\t\tstruct stat s;\n\t\t\tif (stat(homedir, &s) == 0) {\n\t\t\t\t/* coverity[toctou] */\n\t\t\t\tif (chdir(homedir) < 0)\n\t\t\t\t\terrExit(\"chdir\");\n\t\t\t}\n\t\t}\n\t\t\n\t\t// set cpu affinity\n\t\tif (cfg.cpus)\t// not available for uid 0\n\t\t\tset_cpu_affinity();\n\t\t\t\t\t\n\t\t// set caps filter\n\t\tif (apply_caps == 1)\t// not available for uid 0\n\t\t\tcaps_set(caps);\n#ifdef HAVE_SECCOMP\n\t\t// set protocol filter\n\t\tif (getuid() != 0)\n\t\t\tprotocol_filter_load(RUN_PROTOCOL_CFG);\n\t\tif (cfg.protocol) {\t// not available for uid 0\n\t\t\tprotocol_filter();\n\t\t}\n\t\t\t\t\n\t\t// set seccomp filter\n\t\tif (apply_seccomp == 1)\t// not available for uid 0\n\t\t\tseccomp_set();\n#endif\n\n\t\t// fix qt 4.8\n\t\tif (setenv(\"QT_X11_NO_MITSHM\", \"1\", 1) < 0)\n\t\t\terrExit(\"setenv\");\n\t\tif (setenv(\"container\", \"firejail\", 1) < 0) // LXC sets container=lxc,\n\t\t\terrExit(\"setenv\");\n\n\t\t// mount user namespace or drop privileges\n\t\tif (arg_noroot) {\t// not available for uid 0\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Joining user namespace\\n\");\n\t\t\tif (join_namespace(1, \"user\"))\n\t\t\t\texit(1);\n\n\t\t\t// user namespace resets capabilities\n\t\t\t// set caps filter\n\t\t\tif (apply_caps == 1)\t// not available for uid 0\n\t\t\t\tcaps_set(caps);\n\t\t}\n\t\telse \n\t\t\tdrop_privs(arg_nogroups);\t// nogroups not available for uid 0\n\n\n\t\t// set prompt color to green\n\t\tchar *prompt = getenv(\"FIREJAIL_PROMPT\");\n\t\tif (prompt && strcmp(prompt, \"yes\") == 0) {\n\t\t\t//export PS1='\\[\\e[1;32m\\][\\u@\\h \\W]\\$\\[\\e[0m\\] '\n\t\t\tif (setenv(\"PROMPT_COMMAND\", \"export PS1=\\\"\\\\[\\\\e[1;32m\\\\][\\\\u@\\\\h \\\\W]\\\\$\\\\[\\\\e[0m\\\\] \\\"\", 1) < 0)\n\t\t\t\terrExit(\"setenv\");\n\t\t}\n\t\t\n\t\t// set nice\n\t\tif (arg_nice) {\n\t\t\terrno = 0;\n\t\t\tint rv = nice(cfg.nice);\n\t\t\t(void) rv;\n\t\t\tif (errno) {\n\t\t\t\tfprintf(stderr, \"Warning: cannot set nice value\\n\");\n\t\t\t\terrno = 0;\n\t\t\t}\n\t\t}\n\n\t\t// run cmdline trough shell\n\t\tif (cfg.command_line == NULL) {\n\t\t\t// if the sandbox was started with --shell=none, it is possible we don't have a shell\n\t\t\t// inside the sandbox\n\t\t\tif (cfg.shell == NULL) {\n\t\t\t\tcfg.shell = guess_shell();\n\t\t\t\tif (!cfg.shell) {\n\t\t\t\t\tfprintf(stderr, \"Error: no POSIX shell found, please use --shell command line option\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t\n\t\t\tstruct stat s;\n\t\t\tif (stat(cfg.shell, &s) == -1)  {\n\t\t\t\tfprintf(stderr, \"Error: %s shell not found inside the sandbox\\n\", cfg.shell);\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tcfg.command_line = cfg.shell;\n\t\t\tcfg.window_title = cfg.shell;\n\t\t}\n\n\t\tint cwd = 0;\n\t\tif (cfg.cwd) {\n\t\t\tif (chdir(cfg.cwd) == 0)\n\t\t\t\tcwd = 1;\n\t\t}\n\n\t\tif (!cwd) {\n\t\t\tif (chdir(\"/\") < 0)\n\t\t\t\terrExit(\"chdir\");\n\t\t\tif (cfg.homedir) {\n\t\t\t\tstruct stat s;\n\t\t\t\tif (stat(cfg.homedir, &s) == 0) {\n\t\t\t\t\t/* coverity[toctou] */\n\t\t\t\t\tif (chdir(cfg.homedir) < 0)\n\t\t\t\t\t\terrExit(\"chdir\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstart_application();\n\n\t\t// it will never get here!!!\n\t}\n\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n\tflush_stdin();\n\texit(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "myexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/main.c",
          "lines": "137-149",
          "snippet": "static void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}",
          "includes": [
            "#include <sys/times.h>",
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int arg_command = 0;",
            "int arg_quiet = 0;",
            "pid_t sandbox_pid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/times.h>\n#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nint arg_command = 0;\nint arg_quiet = 0;\npid_t sandbox_pid;\n\nstatic void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot find sandbox %s\\n\"",
            "name"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name2pid",
          "args": [
            "name",
            "&pid"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid sandbox name\\n\""
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <sys/prctl.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\nvoid join_name(const char *name, int argc, char **argv, int index) {\n\tEUID_ASSERT();\n\tif (!name || strlen(name) == 0) {\n\t\tfprintf(stderr, \"Error: invalid sandbox name\\n\");\n\t\texit(1);\n\t}\n\n\tpid_t pid;\n\tif (name2pid(name, &pid)) {\n\t\tfprintf(stderr, \"Error: cannot find sandbox %s\\n\", name);\n\t\texit(1);\n\t}\n\tjoin(pid, argc, argv, index);\n}"
  },
  {
    "function_name": "extract_user_namespace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/join.c",
    "lines": "142-174",
    "snippet": "static void extract_user_namespace(pid_t pid) {\n\t// test user namespaces available in the kernel\n\tstruct stat s1;\n\tstruct stat s2;\n\tstruct stat s3;\n\tif (stat(\"/proc/self/ns/user\", &s1) == 0 &&\n\t    stat(\"/proc/self/uid_map\", &s2) == 0 &&\n\t    stat(\"/proc/self/gid_map\", &s3) == 0);\n\telse\n\t\treturn;\n\t\t\t\n\t// read uid map\n\tchar *uidmap;\n\tif (asprintf(&uidmap, \"/proc/%u/uid_map\", pid) == -1)\n\t\terrExit(\"asprintf\");\n\tFILE *fp = fopen(uidmap, \"r\");\n\tif (!fp) {\n\t\tfree(uidmap);\n\t\treturn;\n\t}\n\n\t// check uid map\n\tint u1;\n\tint u2;\n\tif (fscanf(fp, \"%d %d\", &u1, &u2) == 2) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"User namespace detected: %s, %d, %d\\n\", uidmap, u1, u2);\n\t\tif (u1 != 0 || u2 != 0)\n\t\t\targ_noroot = 1;\n\t}\n\tfclose(fp);\n\tfree(uidmap);\n}",
    "includes": [
      "#include <errno.h>",
      "#include <sys/prctl.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "uidmap"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"User namespace detected: %s, %d, %d\\n\"",
            "uidmap",
            "u1",
            "u2"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscanf",
          "args": [
            "fp",
            "\"%d %d\"",
            "&u1",
            "&u2"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "uidmap"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "uidmap",
            "\"r\""
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&uidmap",
            "\"/proc/%u/uid_map\"",
            "pid"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "\"/proc/self/gid_map\"",
            "&s3"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "\"/proc/self/uid_map\"",
            "&s2"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "\"/proc/self/ns/user\"",
            "&s1"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <sys/prctl.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\nstatic void extract_user_namespace(pid_t pid) {\n\t// test user namespaces available in the kernel\n\tstruct stat s1;\n\tstruct stat s2;\n\tstruct stat s3;\n\tif (stat(\"/proc/self/ns/user\", &s1) == 0 &&\n\t    stat(\"/proc/self/uid_map\", &s2) == 0 &&\n\t    stat(\"/proc/self/gid_map\", &s3) == 0);\n\telse\n\t\treturn;\n\t\t\t\n\t// read uid map\n\tchar *uidmap;\n\tif (asprintf(&uidmap, \"/proc/%u/uid_map\", pid) == -1)\n\t\terrExit(\"asprintf\");\n\tFILE *fp = fopen(uidmap, \"r\");\n\tif (!fp) {\n\t\tfree(uidmap);\n\t\treturn;\n\t}\n\n\t// check uid map\n\tint u1;\n\tint u2;\n\tif (fscanf(fp, \"%d %d\", &u1, &u2) == 2) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"User namespace detected: %s, %d, %d\\n\", uidmap, u1, u2);\n\t\tif (u1 != 0 || u2 != 0)\n\t\t\targ_noroot = 1;\n\t}\n\tfclose(fp);\n\tfree(uidmap);\n}"
  },
  {
    "function_name": "extract_caps_seccomp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/join.c",
    "lines": "106-140",
    "snippet": "static void extract_caps_seccomp(pid_t pid) {\n\t// open stat file\n\tchar *file;\n\tif (asprintf(&file, \"/proc/%u/status\", pid) == -1) {\n\t\tperror(\"asprintf\");\n\t\texit(1);\n\t}\n\tFILE *fp = fopen(file, \"r\");\n\tif (!fp) {\n\t\tfree(file);\n\t\tfprintf(stderr, \"Error: cannot open stat file for process %u\\n\", pid);\n\t\texit(1);\n\t}\n\n\tchar buf[BUFLEN];\n\twhile (fgets(buf, BUFLEN - 1, fp)) {\n\t\tif (strncmp(buf, \"Seccomp:\", 8) == 0) {\n\t\t\tchar *ptr = buf + 8;\n\t\t\tint val;\n\t\t\tsscanf(ptr, \"%d\", &val);\n\t\t\tif (val == 2)\n\t\t\t\tapply_seccomp = 1;\n\t\t\tbreak;\n\t\t}\n\t\telse if (strncmp(buf, \"CapBnd:\", 7) == 0) {\t\t\n\t\t\tchar *ptr = buf + 7;\n\t\t\tunsigned long long val;\n\t\t\tsscanf(ptr, \"%llx\", &val);\n\t\t\tapply_caps = 1;\n\t\t\tcaps = val;\n\t\t}\n\t}\n\tfclose(fp);\n\tfree(file);\n}",
    "includes": [
      "#include <errno.h>",
      "#include <sys/prctl.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [
      "#define BUFLEN 4096"
    ],
    "globals_used": [
      "static int apply_caps = 0;",
      "static uint64_t caps = 0;",
      "static int apply_seccomp = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "file"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "ptr",
            "\"%llx\"",
            "&val"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "\"CapBnd:\"",
            "7"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "ptr",
            "\"%d\"",
            "&val"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "\"Seccomp:\"",
            "8"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buf",
            "BUFLEN - 1",
            "fp"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "myexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/main.c",
          "lines": "137-149",
          "snippet": "static void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}",
          "includes": [
            "#include <sys/times.h>",
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int arg_command = 0;",
            "int arg_quiet = 0;",
            "pid_t sandbox_pid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/times.h>\n#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nint arg_command = 0;\nint arg_quiet = 0;\npid_t sandbox_pid;\n\nstatic void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot open stat file for process %u\\n\"",
            "pid"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "file"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "file",
            "\"r\""
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"asprintf\""
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&file",
            "\"/proc/%u/status\"",
            "pid"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <sys/prctl.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\n#define BUFLEN 4096\n\nstatic int apply_caps = 0;\nstatic uint64_t caps = 0;\nstatic int apply_seccomp = 0;\n\nstatic void extract_caps_seccomp(pid_t pid) {\n\t// open stat file\n\tchar *file;\n\tif (asprintf(&file, \"/proc/%u/status\", pid) == -1) {\n\t\tperror(\"asprintf\");\n\t\texit(1);\n\t}\n\tFILE *fp = fopen(file, \"r\");\n\tif (!fp) {\n\t\tfree(file);\n\t\tfprintf(stderr, \"Error: cannot open stat file for process %u\\n\", pid);\n\t\texit(1);\n\t}\n\n\tchar buf[BUFLEN];\n\twhile (fgets(buf, BUFLEN - 1, fp)) {\n\t\tif (strncmp(buf, \"Seccomp:\", 8) == 0) {\n\t\t\tchar *ptr = buf + 8;\n\t\t\tint val;\n\t\t\tsscanf(ptr, \"%d\", &val);\n\t\t\tif (val == 2)\n\t\t\t\tapply_seccomp = 1;\n\t\t\tbreak;\n\t\t}\n\t\telse if (strncmp(buf, \"CapBnd:\", 7) == 0) {\t\t\n\t\t\tchar *ptr = buf + 7;\n\t\t\tunsigned long long val;\n\t\t\tsscanf(ptr, \"%llx\", &val);\n\t\t\tapply_caps = 1;\n\t\t\tcaps = val;\n\t\t}\n\t}\n\tfclose(fp);\n\tfree(file);\n}"
  },
  {
    "function_name": "extract_cgroup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/join.c",
    "lines": "92-104",
    "snippet": "static void extract_cgroup(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_CGROUP_CFG) == -1)\n\t\terrExit(\"asprintf\");\n\t\t\n\tstruct stat s;\n\tif (stat(fname, &s) == -1)\n\t\treturn;\n\t\n\t// there is a cgroup file CGROUP_CFG, load it!\n\tload_cgroup(fname);\n\tfree(fname);\n}",
    "includes": [
      "#include <errno.h>",
      "#include <sys/prctl.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "load_cgroup",
          "args": [
            "fname"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "load_cgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/cgroup.c",
          "lines": "47-69",
          "snippet": "void load_cgroup(const char *fname) {\n\tif (!fname)\n\t\treturn;\n\n\tFILE *fp = fopen(fname, \"r\");\n\tif (fp) {\n\t\tchar buf[MAXBUF];\n\t\tif (fgets(buf, MAXBUF, fp)) {\n\t\t\tcfg.cgroup = strdup(buf);\n\t\t\tif (!cfg.cgroup)\n\t\t\t\terrExit(\"strdup\");\n\t\t}\n\t\telse\n\t\t\tgoto errout;\n\t\t\n\t\tfclose(fp);\n\t\treturn;\n\t}\nerrout:\n\tfprintf(stderr, \"Warning: cannot load control group\\n\");\n\tif (fp)\n\t\tfclose(fp);\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAXBUF 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include \"firejail.h\"\n\n#define MAXBUF 4096\n\nvoid load_cgroup(const char *fname) {\n\tif (!fname)\n\t\treturn;\n\n\tFILE *fp = fopen(fname, \"r\");\n\tif (fp) {\n\t\tchar buf[MAXBUF];\n\t\tif (fgets(buf, MAXBUF, fp)) {\n\t\t\tcfg.cgroup = strdup(buf);\n\t\t\tif (!cfg.cgroup)\n\t\t\t\terrExit(\"strdup\");\n\t\t}\n\t\telse\n\t\t\tgoto errout;\n\t\t\n\t\tfclose(fp);\n\t\treturn;\n\t}\nerrout:\n\tfprintf(stderr, \"Warning: cannot load control group\\n\");\n\tif (fp)\n\t\tfclose(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "fname",
            "&s"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&fname",
            "\"/proc/%d/root%s\"",
            "pid",
            "RUN_CGROUP_CFG"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <sys/prctl.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\nstatic void extract_cgroup(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_CGROUP_CFG) == -1)\n\t\terrExit(\"asprintf\");\n\t\t\n\tstruct stat s;\n\tif (stat(fname, &s) == -1)\n\t\treturn;\n\t\n\t// there is a cgroup file CGROUP_CFG, load it!\n\tload_cgroup(fname);\n\tfree(fname);\n}"
  },
  {
    "function_name": "extract_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/join.c",
    "lines": "78-90",
    "snippet": "static void extract_cpu(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_CPU_CFG) == -1)\n\t\terrExit(\"asprintf\");\n\t\t\n\tstruct stat s;\n\tif (stat(fname, &s) == -1)\n\t\treturn;\n\t\n\t// there is a CPU_CFG file, load it!\n\tload_cpu(fname);\n\tfree(fname);\n}",
    "includes": [
      "#include <errno.h>",
      "#include <sys/prctl.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "load_cpu",
          "args": [
            "fname"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "load_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/cpu.c",
          "lines": "90-104",
          "snippet": "void load_cpu(const char *fname) {\n\tif (!fname)\n\t\treturn;\n\n\tFILE *fp = fopen(fname, \"r\");\n\tif (fp) {\n\t\tunsigned tmp;\n\t\tint rv = fscanf(fp, \"%x\", &tmp);\n\t\tif (rv)\n\t\t\tcfg.cpus = (uint32_t) tmp;\n\t\tfclose(fp);\n\t}\n\telse\n\t\tfprintf(stderr, \"Warning: cannot load cpu affinity mask\\n\");\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <sched.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <unistd.h>\n#include <sched.h>\n#include \"firejail.h\"\n\nvoid load_cpu(const char *fname) {\n\tif (!fname)\n\t\treturn;\n\n\tFILE *fp = fopen(fname, \"r\");\n\tif (fp) {\n\t\tunsigned tmp;\n\t\tint rv = fscanf(fp, \"%x\", &tmp);\n\t\tif (rv)\n\t\t\tcfg.cpus = (uint32_t) tmp;\n\t\tfclose(fp);\n\t}\n\telse\n\t\tfprintf(stderr, \"Warning: cannot load cpu affinity mask\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "fname",
            "&s"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&fname",
            "\"/proc/%d/root%s\"",
            "pid",
            "RUN_CPU_CFG"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <sys/prctl.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\nstatic void extract_cpu(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_CPU_CFG) == -1)\n\t\terrExit(\"asprintf\");\n\t\t\n\tstruct stat s;\n\tif (stat(fname, &s) == -1)\n\t\treturn;\n\t\n\t// there is a CPU_CFG file, load it!\n\tload_cpu(fname);\n\tfree(fname);\n}"
  },
  {
    "function_name": "extract_nogroups",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/join.c",
    "lines": "65-76",
    "snippet": "static void extract_nogroups(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_GROUPS_CFG) == -1)\n\t\terrExit(\"asprintf\");\n\t\t\n\tstruct stat s;\n\tif (stat(fname, &s) == -1)\n\t\treturn;\n\n\targ_nogroups = 1;\n\tfree(fname);\n}",
    "includes": [
      "#include <errno.h>",
      "#include <sys/prctl.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "fname",
            "&s"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&fname",
            "\"/proc/%d/root%s\"",
            "pid",
            "RUN_GROUPS_CFG"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <sys/prctl.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\nstatic void extract_nogroups(pid_t pid) {\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_GROUPS_CFG) == -1)\n\t\terrExit(\"asprintf\");\n\t\t\n\tstruct stat s;\n\tif (stat(fname, &s) == -1)\n\t\treturn;\n\n\targ_nogroups = 1;\n\tfree(fname);\n}"
  },
  {
    "function_name": "extract_command",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/join.c",
    "lines": "39-63",
    "snippet": "static void extract_command(int argc, char **argv, int index) {\n\tEUID_ASSERT();\n\tif (index >= argc)\n\t\treturn;\n\n\t// doubledash followed by positional parameters\n\tif (strcmp(argv[index], \"--\") == 0) {\n\t\targ_doubledash = 1;\n\t\tindex++;\n\t\tif (index >= argc)\n\t\t\treturn;\n\t}\n\t\t\n\t// first argv needs to be a valid command\n\tif (arg_doubledash == 0 && *argv[index] == '-') {\n\t\tfprintf(stderr, \"Error: invalid option %s after --join\\n\", argv[index]);\n\t\texit(1);\n\t}\n\n\t// build command\n\tbuild_cmdline(&cfg.command_line, &cfg.window_title, argc, argv, index);\n\n\tif (arg_debug)\n\t\tprintf(\"Extracted command #%s#\\n\", cfg.command_line);\n}",
    "includes": [
      "#include <errno.h>",
      "#include <sys/prctl.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Extracted command #%s#\\n\"",
            "cfg.command_line"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_cmdline",
          "args": [
            "&cfg.command_line",
            "&cfg.window_title",
            "argc",
            "argv",
            "index"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "build_cmdline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/cmdline.c",
          "lines": "137-159",
          "snippet": "void build_cmdline(char **command_line, char **window_title, int argc, char **argv, int index) {\n\t// index == -1 could happen if we have --shell=none and no program was specified\n\t// the program should exit with an error before entering this function\n\tassert(index != -1);\n\n\tint len = cmdline_length(argc, argv, index);\n\tif (len > ARG_MAX) {\n\t\terrno = E2BIG;\n\t\terrExit(\"cmdline_length\");\n\t}\n\n\t*command_line = malloc(len + 1);\n\tif (!*command_line)\n\t\t\terrExit(\"malloc\");\n\t*window_title = malloc(len + 1);\n\tif (!*window_title)\n\t\t\terrExit(\"malloc\");\n\t\n\tquote_cmdline(*command_line, *window_title, len, argc, argv, index);\n\n\tassert(*command_line);\n\tassert(*window_title);\n}",
          "includes": [
            "#include <errno.h>",
            "#include <assert.h>",
            "#include <linux/limits.h>",
            "#include <stdio.h>",
            "#include <stdbool.h>",
            "#include <string.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <assert.h>\n#include <linux/limits.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n#include \"firejail.h\"\n\nvoid build_cmdline(char **command_line, char **window_title, int argc, char **argv, int index) {\n\t// index == -1 could happen if we have --shell=none and no program was specified\n\t// the program should exit with an error before entering this function\n\tassert(index != -1);\n\n\tint len = cmdline_length(argc, argv, index);\n\tif (len > ARG_MAX) {\n\t\terrno = E2BIG;\n\t\terrExit(\"cmdline_length\");\n\t}\n\n\t*command_line = malloc(len + 1);\n\tif (!*command_line)\n\t\t\terrExit(\"malloc\");\n\t*window_title = malloc(len + 1);\n\tif (!*window_title)\n\t\t\terrExit(\"malloc\");\n\t\n\tquote_cmdline(*command_line, *window_title, len, argc, argv, index);\n\n\tassert(*command_line);\n\tassert(*window_title);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "myexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/main.c",
          "lines": "137-149",
          "snippet": "static void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}",
          "includes": [
            "#include <sys/times.h>",
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int arg_command = 0;",
            "int arg_quiet = 0;",
            "pid_t sandbox_pid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/times.h>\n#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nint arg_command = 0;\nint arg_quiet = 0;\npid_t sandbox_pid;\n\nstatic void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid option %s after --join\\n\"",
            "argv[index]"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[index]",
            "\"--\""
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <sys/prctl.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\nstatic void extract_command(int argc, char **argv, int index) {\n\tEUID_ASSERT();\n\tif (index >= argc)\n\t\treturn;\n\n\t// doubledash followed by positional parameters\n\tif (strcmp(argv[index], \"--\") == 0) {\n\t\targ_doubledash = 1;\n\t\tindex++;\n\t\tif (index >= argc)\n\t\t\treturn;\n\t}\n\t\t\n\t// first argv needs to be a valid command\n\tif (arg_doubledash == 0 && *argv[index] == '-') {\n\t\tfprintf(stderr, \"Error: invalid option %s after --join\\n\", argv[index]);\n\t\texit(1);\n\t}\n\n\t// build command\n\tbuild_cmdline(&cfg.command_line, &cfg.window_title, argc, argv, index);\n\n\tif (arg_debug)\n\t\tprintf(\"Extracted command #%s#\\n\", cfg.command_line);\n}"
  },
  {
    "function_name": "signal_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/join.c",
    "lines": "33-37",
    "snippet": "static void signal_handler(int sig){\n\tflush_stdin();\n\n\texit(sig);\n}",
    "includes": [
      "#include <errno.h>",
      "#include <sys/prctl.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "sig"
          ],
          "line": 36
        },
        "resolved": true,
        "details": {
          "function_name": "myexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/main.c",
          "lines": "137-149",
          "snippet": "static void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}",
          "includes": [
            "#include <sys/times.h>",
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int arg_command = 0;",
            "int arg_quiet = 0;",
            "pid_t sandbox_pid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/times.h>\n#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nint arg_command = 0;\nint arg_quiet = 0;\npid_t sandbox_pid;\n\nstatic void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_stdin",
          "args": [],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "flush_stdin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/util.c",
          "lines": "721-731",
          "snippet": "void flush_stdin(void) {\n\tif (isatty(STDIN_FILENO)) {\n\t\tint cnt = 0;\n\t\tioctl(STDIN_FILENO, FIONREAD, &cnt);\n\t\tif (cnt) {\n\t\t\tif (!arg_quiet)\n\t\t\t\tprintf(\"Warning: removing %d bytes from stdin\\n\", cnt);\n\t\t\tioctl(STDIN_FILENO, TCFLSH, TCIFLUSH);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid flush_stdin(void) {\n\tif (isatty(STDIN_FILENO)) {\n\t\tint cnt = 0;\n\t\tioctl(STDIN_FILENO, FIONREAD, &cnt);\n\t\tif (cnt) {\n\t\t\tif (!arg_quiet)\n\t\t\t\tprintf(\"Warning: removing %d bytes from stdin\\n\", cnt);\n\t\t\tioctl(STDIN_FILENO, TCFLSH, TCIFLUSH);\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <sys/prctl.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\nstatic void signal_handler(int sig){\n\tflush_stdin();\n\n\texit(sig);\n}"
  }
]