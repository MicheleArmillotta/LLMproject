[
  {
    "function_name": "net_get_mac",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/network.c",
    "lines": "530-548",
    "snippet": "int net_get_mac(const char *ifname, unsigned char mac[6]) {\n\n\tstruct ifreq ifr;\n\tint sock;\n\n\tif ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0)\n              \terrExit(\"socket\");\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ);\n\tifr.ifr_hwaddr.sa_family = ARPHRD_ETHER;\n\t\n\tif (ioctl(sock, SIOCGIFHWADDR, &ifr) == -1)\n\t\terrExit(\"ioctl\");\n\tmemcpy(mac, ifr.ifr_hwaddr.sa_data, 6);\n\n\tclose(sock);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/if_bridge.h>",
      "#include <net/route.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <ifaddrs.h>",
      "#include <netdb.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <arpa/inet.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sock"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "mac",
            "ifr.ifr_hwaddr.sa_data",
            "6"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"ioctl\""
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "sock",
            "SIOCGIFHWADDR",
            "&ifr"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "ifr.ifr_name",
            "ifname",
            "IFNAMSIZ"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ifr",
            "0",
            "sizeof(ifr)"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"socket\""
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_INET",
            "SOCK_STREAM",
            "0"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"firejail.h\"\n\nint net_get_mac(const char *ifname, unsigned char mac[6]) {\n\n\tstruct ifreq ifr;\n\tint sock;\n\n\tif ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0)\n              \terrExit(\"socket\");\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ);\n\tifr.ifr_hwaddr.sa_family = ARPHRD_ETHER;\n\t\n\tif (ioctl(sock, SIOCGIFHWADDR, &ifr) == -1)\n\t\terrExit(\"ioctl\");\n\tmemcpy(mac, ifr.ifr_hwaddr.sa_data, 6);\n\n\tclose(sock);\n\treturn 0;\n}"
  },
  {
    "function_name": "net_config_mac",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/network.c",
    "lines": "512-528",
    "snippet": "int net_config_mac(const char *ifname, const unsigned char mac[6]) {\n\tstruct ifreq ifr;\n\tint sock;\n\n\tif ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0)\n              \terrExit(\"socket\");\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ);\n\tifr.ifr_hwaddr.sa_family = ARPHRD_ETHER;\n\tmemcpy(ifr.ifr_hwaddr.sa_data, mac, 6);\n\t\n\tif (ioctl(sock, SIOCSIFHWADDR, &ifr) == -1)\n\t\terrExit(\"ioctl\");\n\tclose(sock);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/if_bridge.h>",
      "#include <net/route.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <ifaddrs.h>",
      "#include <netdb.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <arpa/inet.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sock"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"ioctl\""
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "sock",
            "SIOCSIFHWADDR",
            "&ifr"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ifr.ifr_hwaddr.sa_data",
            "mac",
            "6"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "ifr.ifr_name",
            "ifname",
            "IFNAMSIZ"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ifr",
            "0",
            "sizeof(ifr)"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"socket\""
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_INET",
            "SOCK_STREAM",
            "0"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"firejail.h\"\n\nint net_config_mac(const char *ifname, const unsigned char mac[6]) {\n\tstruct ifreq ifr;\n\tint sock;\n\n\tif ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0)\n              \terrExit(\"socket\");\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ);\n\tifr.ifr_hwaddr.sa_family = ARPHRD_ETHER;\n\tmemcpy(ifr.ifr_hwaddr.sa_data, mac, 6);\n\t\n\tif (ioctl(sock, SIOCSIFHWADDR, &ifr) == -1)\n\t\terrExit(\"ioctl\");\n\tclose(sock);\n\treturn 0;\n}"
  },
  {
    "function_name": "network_get_defaultgw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/network.c",
    "lines": "482-510",
    "snippet": "uint32_t network_get_defaultgw(void) {\n\tFILE *fp = fopen(\"/proc/self/net/route\", \"r\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\t\n\tchar buf[BUFSIZE];\n\tuint32_t retval = 0;\n\twhile (fgets(buf, BUFSIZE, fp)) {\n\t\tif (strncmp(buf, \"Iface\", 5) == 0)\n\t\t\tcontinue;\n\t\t\n\t\tchar *ptr = buf;\n\t\twhile (*ptr != ' ' && *ptr != '\\t')\n\t\t\tptr++;\n\t\twhile (*ptr == ' ' || *ptr == '\\t')\n\t\t\tptr++;\n\t\t\t\n\t\tunsigned dest;\n\t\tunsigned gw;\n\t\tint rv = sscanf(ptr, \"%x %x\", &dest, &gw);\n\t\tif (rv == 2 && dest == 0) {\n\t\t\tretval = ntohl(gw);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfclose(fp);\n\treturn retval;\n}",
    "includes": [
      "#include <linux/if_bridge.h>",
      "#include <net/route.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <ifaddrs.h>",
      "#include <netdb.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <arpa/inet.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [
      "#define BUFSIZE 1024"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "gw"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "ptr",
            "\"%x %x\"",
            "&dest",
            "&gw"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "\"Iface\"",
            "5"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buf",
            "BUFSIZE",
            "fp"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fopen\""
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "\"/proc/self/net/route\"",
            "\"r\""
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"firejail.h\"\n\n#define BUFSIZE 1024\n\nuint32_t network_get_defaultgw(void) {\n\tFILE *fp = fopen(\"/proc/self/net/route\", \"r\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\t\n\tchar buf[BUFSIZE];\n\tuint32_t retval = 0;\n\twhile (fgets(buf, BUFSIZE, fp)) {\n\t\tif (strncmp(buf, \"Iface\", 5) == 0)\n\t\t\tcontinue;\n\t\t\n\t\tchar *ptr = buf;\n\t\twhile (*ptr != ' ' && *ptr != '\\t')\n\t\t\tptr++;\n\t\twhile (*ptr == ' ' || *ptr == '\\t')\n\t\t\tptr++;\n\t\t\t\n\t\tunsigned dest;\n\t\tunsigned gw;\n\t\tint rv = sscanf(ptr, \"%x %x\", &dest, &gw);\n\t\tif (rv == 2 && dest == 0) {\n\t\t\tretval = ntohl(gw);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfclose(fp);\n\treturn retval;\n}"
  },
  {
    "function_name": "net_bridge_add_interface",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/network.c",
    "lines": "435-479",
    "snippet": "void net_bridge_add_interface(const char *bridge, const char *dev) {\n\tif (strlen(bridge) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error: invalid network device name %s\\n\", bridge);\n\t\texit(1);\n\t}\n\n\t// somehow adding the interface to the bridge resets MTU on bridge device!!!\n\t// workaround: restore MTU on the bridge device\n\t// todo: put a real fix in\n\tint mtu1 = net_get_mtu(bridge);\n\n\tstruct ifreq ifr;\n\tint err;\n\tint ifindex = if_nametoindex(dev);\n\n\tif (ifindex <= 0)\n\t\terrExit(\"if_nametoindex\");\n\n\tint sock;\n\tif ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0)\n              \terrExit(\"socket\");\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, bridge, IFNAMSIZ);\n#ifdef SIOCBRADDIF\n\tifr.ifr_ifindex = ifindex;\n\terr = ioctl(sock, SIOCBRADDIF, &ifr);\n\tif (err < 0)\n#endif\n\t{\n\t\tunsigned long args[4] = { BRCTL_ADD_IF, ifindex, 0, 0 };\n\n\t\tifr.ifr_data = (char *) args;\n\t\terr = ioctl(sock, SIOCDEVPRIVATE, &ifr);\n\t}\n\t(void) err;\n\tclose(sock);\n\n\tint mtu2 = net_get_mtu(bridge);\n\tif (mtu1 != mtu2) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Restoring MTU for %s\\n\", bridge);\n\t\tnet_set_mtu(bridge, mtu1);\n\t}\n}",
    "includes": [
      "#include <linux/if_bridge.h>",
      "#include <net/route.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <ifaddrs.h>",
      "#include <netdb.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <arpa/inet.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "net_set_mtu",
          "args": [
            "bridge",
            "mtu1"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "net_set_mtu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/network.c",
          "lines": "122-144",
          "snippet": "void net_set_mtu(const char *ifname, int mtu) {\n\tif (strlen(ifname) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error: invalid network device name %s\\n\", ifname);\n\t\texit(1);\n\t}\n\n\tif (arg_debug)\n\t\tprintf(\"set interface %s MTU %d.\\n\", ifname, mtu);\n\n\tint s;\n\tstruct ifreq ifr;\n\n\tif ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0)\n\t\terrExit(\"socket\");\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tifr.ifr_addr.sa_family = AF_INET;\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ);\n\tifr.ifr_mtu = mtu;\n\tif (ioctl(s, SIOCSIFMTU, (caddr_t)&ifr) != 0)\n\t\tfprintf(stderr, \"Warning: cannot set mtu for interface %s\\n\", ifname);\n\tclose(s);\n}",
          "includes": [
            "#include <linux/if_bridge.h>",
            "#include <net/route.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <ifaddrs.h>",
            "#include <netdb.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <arpa/inet.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"firejail.h\"\n\nvoid net_set_mtu(const char *ifname, int mtu) {\n\tif (strlen(ifname) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error: invalid network device name %s\\n\", ifname);\n\t\texit(1);\n\t}\n\n\tif (arg_debug)\n\t\tprintf(\"set interface %s MTU %d.\\n\", ifname, mtu);\n\n\tint s;\n\tstruct ifreq ifr;\n\n\tif ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0)\n\t\terrExit(\"socket\");\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tifr.ifr_addr.sa_family = AF_INET;\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ);\n\tifr.ifr_mtu = mtu;\n\tif (ioctl(s, SIOCSIFMTU, (caddr_t)&ifr) != 0)\n\t\tfprintf(stderr, \"Warning: cannot set mtu for interface %s\\n\", ifname);\n\tclose(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Restoring MTU for %s\\n\"",
            "bridge"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_get_mtu",
          "args": [
            "bridge"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "net_get_mtu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/network.c",
          "lines": "96-120",
          "snippet": "int net_get_mtu(const char *ifname) {\n\tint mtu = 0;\n\tif (strlen(ifname) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error: invalid network device name %s\\n\", ifname);\n\t\texit(1);\n\t}\n\n\tint s;\n\tstruct ifreq ifr;\n\n\tif ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0)\n\t\terrExit(\"socket\");\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tifr.ifr_addr.sa_family = AF_INET;\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ);\n\tif (ioctl(s, SIOCGIFMTU, (caddr_t)&ifr) == 0)\n\t\tmtu = ifr.ifr_mtu;\n\tif (arg_debug)\n\t\tprintf(\"MTU of %s is %d.\\n\", ifname, ifr.ifr_mtu);\n\tclose(s);\n\t\n\t\n\treturn mtu;\n}",
          "includes": [
            "#include <linux/if_bridge.h>",
            "#include <net/route.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <ifaddrs.h>",
            "#include <netdb.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <arpa/inet.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"firejail.h\"\n\nint net_get_mtu(const char *ifname) {\n\tint mtu = 0;\n\tif (strlen(ifname) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error: invalid network device name %s\\n\", ifname);\n\t\texit(1);\n\t}\n\n\tint s;\n\tstruct ifreq ifr;\n\n\tif ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0)\n\t\terrExit(\"socket\");\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tifr.ifr_addr.sa_family = AF_INET;\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ);\n\tif (ioctl(s, SIOCGIFMTU, (caddr_t)&ifr) == 0)\n\t\tmtu = ifr.ifr_mtu;\n\tif (arg_debug)\n\t\tprintf(\"MTU of %s is %d.\\n\", ifname, ifr.ifr_mtu);\n\tclose(s);\n\t\n\t\n\treturn mtu;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sock"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "sock",
            "SIOCDEVPRIVATE",
            "&ifr"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "sock",
            "SIOCBRADDIF",
            "&ifr"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "ifr.ifr_name",
            "bridge",
            "IFNAMSIZ"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ifr",
            "0",
            "sizeof(ifr)"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"socket\""
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_INET",
            "SOCK_STREAM",
            "0"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"if_nametoindex\""
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_nametoindex",
          "args": [
            "dev"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "myexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/main.c",
          "lines": "137-149",
          "snippet": "static void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}",
          "includes": [
            "#include <sys/times.h>",
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int arg_command = 0;",
            "int arg_quiet = 0;",
            "pid_t sandbox_pid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/times.h>\n#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nint arg_command = 0;\nint arg_quiet = 0;\npid_t sandbox_pid;\n\nstatic void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid network device name %s\\n\"",
            "bridge"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "bridge"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"firejail.h\"\n\nvoid net_bridge_add_interface(const char *bridge, const char *dev) {\n\tif (strlen(bridge) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error: invalid network device name %s\\n\", bridge);\n\t\texit(1);\n\t}\n\n\t// somehow adding the interface to the bridge resets MTU on bridge device!!!\n\t// workaround: restore MTU on the bridge device\n\t// todo: put a real fix in\n\tint mtu1 = net_get_mtu(bridge);\n\n\tstruct ifreq ifr;\n\tint err;\n\tint ifindex = if_nametoindex(dev);\n\n\tif (ifindex <= 0)\n\t\terrExit(\"if_nametoindex\");\n\n\tint sock;\n\tif ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0)\n              \terrExit(\"socket\");\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, bridge, IFNAMSIZ);\n#ifdef SIOCBRADDIF\n\tifr.ifr_ifindex = ifindex;\n\terr = ioctl(sock, SIOCBRADDIF, &ifr);\n\tif (err < 0)\n#endif\n\t{\n\t\tunsigned long args[4] = { BRCTL_ADD_IF, ifindex, 0, 0 };\n\n\t\tifr.ifr_data = (char *) args;\n\t\terr = ioctl(sock, SIOCDEVPRIVATE, &ifr);\n\t}\n\t(void) err;\n\tclose(sock);\n\n\tint mtu2 = net_get_mtu(bridge);\n\tif (mtu1 != mtu2) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Restoring MTU for %s\\n\", bridge);\n\t\tnet_set_mtu(bridge, mtu1);\n\t}\n}"
  },
  {
    "function_name": "net_add_route",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/network.c",
    "lines": "398-431",
    "snippet": "int net_add_route(uint32_t ip, uint32_t mask, uint32_t gw) {\n\tint sock;\n\tstruct rtentry route;\n\tstruct sockaddr_in *addr;\n\tint err = 0;\n\n\t// create the socket\n\tif((sock = socket(AF_INET, SOCK_DGRAM, 0)) < 0)\n\t\terrExit(\"socket\");\n\n\tmemset(&route, 0, sizeof(route));\n\n\taddr = (struct sockaddr_in*) &route.rt_gateway;\n\taddr->sin_family = AF_INET;\n\taddr->sin_addr.s_addr = htonl(gw);\n\n\taddr = (struct sockaddr_in*) &route.rt_dst;\n\taddr->sin_family = AF_INET;\n\taddr->sin_addr.s_addr = htonl(ip);\n\n\taddr = (struct sockaddr_in*) &route.rt_genmask;\n\taddr->sin_family = AF_INET;\n\taddr->sin_addr.s_addr = htonl(mask);\n\n\troute.rt_flags = RTF_UP | RTF_GATEWAY;\n\troute.rt_metric = 0;\n\tif ((err = ioctl(sock, SIOCADDRT, &route)) != 0) {\n\t\tclose(sock);\n\t\treturn -1;\n\t}\n\n\tclose(sock);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/if_bridge.h>",
      "#include <net/route.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <ifaddrs.h>",
      "#include <netdb.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <arpa/inet.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sock"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sock"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "sock",
            "SIOCADDRT",
            "&route"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "mask"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "ip"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "gw"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&route",
            "0",
            "sizeof(route)"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"socket\""
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_INET",
            "SOCK_DGRAM",
            "0"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"firejail.h\"\n\nint net_add_route(uint32_t ip, uint32_t mask, uint32_t gw) {\n\tint sock;\n\tstruct rtentry route;\n\tstruct sockaddr_in *addr;\n\tint err = 0;\n\n\t// create the socket\n\tif((sock = socket(AF_INET, SOCK_DGRAM, 0)) < 0)\n\t\terrExit(\"socket\");\n\n\tmemset(&route, 0, sizeof(route));\n\n\taddr = (struct sockaddr_in*) &route.rt_gateway;\n\taddr->sin_family = AF_INET;\n\taddr->sin_addr.s_addr = htonl(gw);\n\n\taddr = (struct sockaddr_in*) &route.rt_dst;\n\taddr->sin_family = AF_INET;\n\taddr->sin_addr.s_addr = htonl(ip);\n\n\taddr = (struct sockaddr_in*) &route.rt_genmask;\n\taddr->sin_family = AF_INET;\n\taddr->sin_addr.s_addr = htonl(mask);\n\n\troute.rt_flags = RTF_UP | RTF_GATEWAY;\n\troute.rt_metric = 0;\n\tif ((err = ioctl(sock, SIOCADDRT, &route)) != 0) {\n\t\tclose(sock);\n\t\treturn -1;\n\t}\n\n\tclose(sock);\n\treturn 0;\n}"
  },
  {
    "function_name": "net_if_ip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/network.c",
    "lines": "352-394",
    "snippet": "void net_if_ip(const char *ifname, uint32_t ip, uint32_t mask, int mtu) {\n\tif (strlen(ifname) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error: invalid network device name %s\\n\", ifname);\n\t\texit(1);\n\t}\n\tif (arg_debug)\n\t\tprintf(\"configure interface %s\\n\", ifname);\n\n\tint sock = socket(AF_INET,SOCK_DGRAM,0);\n\tif (sock < 0)\n\t\terrExit(\"socket\");\n\n\tstruct ifreq ifr;\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ);\n\tifr.ifr_addr.sa_family = AF_INET;\n\n\t((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr.s_addr = htonl(ip);\n\tif (ioctl( sock, SIOCSIFADDR, &ifr ) < 0) {\n\t\tclose(sock);\n\t\terrExit(\"ioctl\");\n\t}\n\n\tif (ip != 0) {\n\t\t((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr.s_addr =  htonl(mask);\n\t\tif (ioctl( sock, SIOCSIFNETMASK, &ifr ) < 0) {\n\t\t\tclose(sock);\n\t\t\terrExit(\"ioctl\");\n\t\t}\n\t}\n\t\n\t// configure mtu\n\tif (mtu > 0) {\n\t\tifr.ifr_mtu = mtu;\n\t\tif (ioctl( sock, SIOCSIFMTU, &ifr ) < 0) {\n\t\t\tclose(sock);\n\t\t\terrExit(\"ioctl\");\n\t\t}\n\t}\n\n\tclose(sock);\n\tusleep(10000);\t\t\t\t  // sleep 10ms\n}",
    "includes": [
      "#include <linux/if_bridge.h>",
      "#include <net/route.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <ifaddrs.h>",
      "#include <netdb.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <arpa/inet.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "10000"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sock"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"ioctl\""
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sock"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "sock",
            "SIOCSIFMTU",
            "&ifr"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"ioctl\""
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sock"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "sock",
            "SIOCSIFNETMASK",
            "&ifr"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "mask"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"ioctl\""
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sock"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "sock",
            "SIOCSIFADDR",
            "&ifr"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "ip"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "ifr.ifr_name",
            "ifname",
            "IFNAMSIZ"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ifr",
            "0",
            "sizeof(ifr)"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"socket\""
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_INET",
            "SOCK_DGRAM",
            "0"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"configure interface %s\\n\"",
            "ifname"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "myexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/main.c",
          "lines": "137-149",
          "snippet": "static void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}",
          "includes": [
            "#include <sys/times.h>",
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int arg_command = 0;",
            "int arg_quiet = 0;",
            "pid_t sandbox_pid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/times.h>\n#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nint arg_command = 0;\nint arg_quiet = 0;\npid_t sandbox_pid;\n\nstatic void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid network device name %s\\n\"",
            "ifname"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ifname"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"firejail.h\"\n\nvoid net_if_ip(const char *ifname, uint32_t ip, uint32_t mask, int mtu) {\n\tif (strlen(ifname) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error: invalid network device name %s\\n\", ifname);\n\t\texit(1);\n\t}\n\tif (arg_debug)\n\t\tprintf(\"configure interface %s\\n\", ifname);\n\n\tint sock = socket(AF_INET,SOCK_DGRAM,0);\n\tif (sock < 0)\n\t\terrExit(\"socket\");\n\n\tstruct ifreq ifr;\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ);\n\tifr.ifr_addr.sa_family = AF_INET;\n\n\t((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr.s_addr = htonl(ip);\n\tif (ioctl( sock, SIOCSIFADDR, &ifr ) < 0) {\n\t\tclose(sock);\n\t\terrExit(\"ioctl\");\n\t}\n\n\tif (ip != 0) {\n\t\t((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr.s_addr =  htonl(mask);\n\t\tif (ioctl( sock, SIOCSIFNETMASK, &ifr ) < 0) {\n\t\t\tclose(sock);\n\t\t\terrExit(\"ioctl\");\n\t\t}\n\t}\n\t\n\t// configure mtu\n\tif (mtu > 0) {\n\t\tifr.ifr_mtu = mtu;\n\t\tif (ioctl( sock, SIOCSIFMTU, &ifr ) < 0) {\n\t\t\tclose(sock);\n\t\t\terrExit(\"ioctl\");\n\t\t}\n\t}\n\n\tclose(sock);\n\tusleep(10000);\t\t\t\t  // sleep 10ms\n}"
  },
  {
    "function_name": "net_if_ip6",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/network.c",
    "lines": "290-349",
    "snippet": "void net_if_ip6(const char *ifname, const char *addr6) {\n\tif (strchr(addr6, ':') == NULL) {\n\t\tfprintf(stderr, \"Error: invalid IPv6 address %s\\n\", addr6);\n\t\texit(1);\n\t}\n\t\n\t// extract prefix\n\tunsigned long prefix;\n\tchar *ptr;\n\tif ((ptr = strchr(addr6, '/'))) {\n\t\tprefix = atol(ptr + 1);\n\t\tif (prefix > 128) {\n\t\t\tfprintf(stderr, \"Error: invalid prefix for IPv6 address %s\\n\", addr6);\n\t\t\texit(1);\n\t\t}\n\t\t*ptr = '\\0';\t// mark the end of the address\n\t}\n\telse\n\t\tprefix = 128;\n\n\t// extract address\n\tstruct sockaddr_in6 sin6;\n\tmemset(&sin6, 0, sizeof(sin6));\n\tsin6.sin6_family = AF_INET6;\n\tint rv = inet_pton(AF_INET6, addr6, sin6.sin6_addr.s6_addr);\n\tif (rv <= 0) {\n\t\tfprintf(stderr, \"Error: invalid IPv6 address %s\\n\", addr6);\n\t\texit(1);\n\t}\n\n\t// open socket\n\tint sock = socket(PF_INET6, SOCK_DGRAM, IPPROTO_IP);\n\tif (sock < 0) {\n\t\tfprintf(stderr, \"Error: IPv6 is not supported on this system\\n\");\n\t\texit(1);\n\t}\n\n\t// find interface index\n\tstruct ifreq ifr;\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ);\n\tifr.ifr_addr.sa_family = AF_INET;\n\tif (ioctl(sock, SIOGIFINDEX, &ifr) < 0) {\n\t\tperror(\"ioctl SIOGIFINDEX\");\n\t\texit(1);\n\t}\n\n\t// configure address\n\tstruct ifreq6 ifr6;\n\tmemset(&ifr6, 0, sizeof(ifr6));\n\tifr6.ifr6_prefixlen = prefix;\n\tifr6.ifr6_ifindex = ifr.ifr_ifindex;\n\tmemcpy((char *) &ifr6.ifr6_addr, (char *) &sin6.sin6_addr, sizeof(struct in6_addr));\n\tif (ioctl(sock, SIOCSIFADDR, &ifr6) < 0) {\n\t\tperror(\"ioctl SIOCSIFADDR\");\n\t\texit(1);\n\t}\n\t\n\tclose(sock);\n}",
    "includes": [
      "#include <linux/if_bridge.h>",
      "#include <net/route.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <ifaddrs.h>",
      "#include <netdb.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <arpa/inet.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sock"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "myexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/main.c",
          "lines": "137-149",
          "snippet": "static void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}",
          "includes": [
            "#include <sys/times.h>",
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int arg_command = 0;",
            "int arg_quiet = 0;",
            "pid_t sandbox_pid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/times.h>\n#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nint arg_command = 0;\nint arg_quiet = 0;\npid_t sandbox_pid;\n\nstatic void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}"
        }
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"ioctl SIOCSIFADDR\""
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "sock",
            "SIOCSIFADDR",
            "&ifr6"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(char *) &ifr6.ifr6_addr",
            "(char *) &sin6.sin6_addr",
            "sizeof(struct in6_addr)"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ifr6",
            "0",
            "sizeof(ifr6)"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"ioctl SIOGIFINDEX\""
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "sock",
            "SIOGIFINDEX",
            "&ifr"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "ifr.ifr_name",
            "ifname",
            "IFNAMSIZ"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ifr",
            "0",
            "sizeof(ifr)"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: IPv6 is not supported on this system\\n\""
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "PF_INET6",
            "SOCK_DGRAM",
            "IPPROTO_IP"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid IPv6 address %s\\n\"",
            "addr6"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_pton",
          "args": [
            "AF_INET6",
            "addr6",
            "sin6.sin6_addr.s6_addr"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&sin6",
            "0",
            "sizeof(sin6)"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid prefix for IPv6 address %s\\n\"",
            "addr6"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atol",
          "args": [
            "ptr + 1"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "addr6",
            "'/'"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid IPv6 address %s\\n\"",
            "addr6"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "addr6",
            "':'"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"firejail.h\"\n\nvoid net_if_ip6(const char *ifname, const char *addr6) {\n\tif (strchr(addr6, ':') == NULL) {\n\t\tfprintf(stderr, \"Error: invalid IPv6 address %s\\n\", addr6);\n\t\texit(1);\n\t}\n\t\n\t// extract prefix\n\tunsigned long prefix;\n\tchar *ptr;\n\tif ((ptr = strchr(addr6, '/'))) {\n\t\tprefix = atol(ptr + 1);\n\t\tif (prefix > 128) {\n\t\t\tfprintf(stderr, \"Error: invalid prefix for IPv6 address %s\\n\", addr6);\n\t\t\texit(1);\n\t\t}\n\t\t*ptr = '\\0';\t// mark the end of the address\n\t}\n\telse\n\t\tprefix = 128;\n\n\t// extract address\n\tstruct sockaddr_in6 sin6;\n\tmemset(&sin6, 0, sizeof(sin6));\n\tsin6.sin6_family = AF_INET6;\n\tint rv = inet_pton(AF_INET6, addr6, sin6.sin6_addr.s6_addr);\n\tif (rv <= 0) {\n\t\tfprintf(stderr, \"Error: invalid IPv6 address %s\\n\", addr6);\n\t\texit(1);\n\t}\n\n\t// open socket\n\tint sock = socket(PF_INET6, SOCK_DGRAM, IPPROTO_IP);\n\tif (sock < 0) {\n\t\tfprintf(stderr, \"Error: IPv6 is not supported on this system\\n\");\n\t\texit(1);\n\t}\n\n\t// find interface index\n\tstruct ifreq ifr;\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ);\n\tifr.ifr_addr.sa_family = AF_INET;\n\tif (ioctl(sock, SIOGIFINDEX, &ifr) < 0) {\n\t\tperror(\"ioctl SIOGIFINDEX\");\n\t\texit(1);\n\t}\n\n\t// configure address\n\tstruct ifreq6 ifr6;\n\tmemset(&ifr6, 0, sizeof(ifr6));\n\tifr6.ifr6_prefixlen = prefix;\n\tifr6.ifr6_ifindex = ifr.ifr_ifindex;\n\tmemcpy((char *) &ifr6.ifr6_addr, (char *) &sin6.sin6_addr, sizeof(struct in6_addr));\n\tif (ioctl(sock, SIOCSIFADDR, &ifr6) < 0) {\n\t\tperror(\"ioctl SIOCSIFADDR\");\n\t\texit(1);\n\t}\n\t\n\tclose(sock);\n}"
  },
  {
    "function_name": "net_if_down",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/network.c",
    "lines": "248-281",
    "snippet": "void net_if_down(const char *ifname) {\n\tif (strlen(ifname) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error: invalid network device name %s\\n\", ifname);\n\t\texit(1);\n\t}\n\t\n\tint sock = socket(AF_INET,SOCK_DGRAM,0);\n\tif (sock < 0)\n\t\terrExit(\"socket\");\n\n\t// get the existing interface flags\n\tstruct ifreq ifr;\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ);\n\tifr.ifr_addr.sa_family = AF_INET;\n\n\t// read the existing flags\n\tif (ioctl(sock, SIOCGIFFLAGS, &ifr ) < 0) {\n\t\tclose(sock);\n\t\tprintf(\"Error: cannot shut down interface %s\\n\", ifname);\n\t\terrExit(\"ioctl\");\n\t}\n\n\tifr.ifr_flags &= ~IFF_UP;\n\n\t// set the new flags\n\tif (ioctl( sock, SIOCSIFFLAGS, &ifr ) < 0) {\n\t\tclose(sock);\n\t\tprintf(\"Error: cannot shut down interface %s\\n\", ifname);\n\t\terrExit(\"ioctl\");\n\t}\n\n\tclose(sock);\n}",
    "includes": [
      "#include <linux/if_bridge.h>",
      "#include <net/route.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <ifaddrs.h>",
      "#include <netdb.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <arpa/inet.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sock"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"ioctl\""
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Error: cannot shut down interface %s\\n\"",
            "ifname"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sock"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "sock",
            "SIOCSIFFLAGS",
            "&ifr"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"ioctl\""
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Error: cannot shut down interface %s\\n\"",
            "ifname"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sock"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "sock",
            "SIOCGIFFLAGS",
            "&ifr"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "ifr.ifr_name",
            "ifname",
            "IFNAMSIZ"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ifr",
            "0",
            "sizeof(ifr)"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"socket\""
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_INET",
            "SOCK_DGRAM",
            "0"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "myexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/main.c",
          "lines": "137-149",
          "snippet": "static void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}",
          "includes": [
            "#include <sys/times.h>",
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int arg_command = 0;",
            "int arg_quiet = 0;",
            "pid_t sandbox_pid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/times.h>\n#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nint arg_command = 0;\nint arg_quiet = 0;\npid_t sandbox_pid;\n\nstatic void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid network device name %s\\n\"",
            "ifname"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ifname"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"firejail.h\"\n\nvoid net_if_down(const char *ifname) {\n\tif (strlen(ifname) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error: invalid network device name %s\\n\", ifname);\n\t\texit(1);\n\t}\n\t\n\tint sock = socket(AF_INET,SOCK_DGRAM,0);\n\tif (sock < 0)\n\t\terrExit(\"socket\");\n\n\t// get the existing interface flags\n\tstruct ifreq ifr;\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ);\n\tifr.ifr_addr.sa_family = AF_INET;\n\n\t// read the existing flags\n\tif (ioctl(sock, SIOCGIFFLAGS, &ifr ) < 0) {\n\t\tclose(sock);\n\t\tprintf(\"Error: cannot shut down interface %s\\n\", ifname);\n\t\terrExit(\"ioctl\");\n\t}\n\n\tifr.ifr_flags &= ~IFF_UP;\n\n\t// set the new flags\n\tif (ioctl( sock, SIOCSIFFLAGS, &ifr ) < 0) {\n\t\tclose(sock);\n\t\tprintf(\"Error: cannot shut down interface %s\\n\", ifname);\n\t\terrExit(\"ioctl\");\n\t}\n\n\tclose(sock);\n}"
  },
  {
    "function_name": "net_if_up",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/network.c",
    "lines": "188-245",
    "snippet": "void net_if_up(const char *ifname) {\n\tif (strlen(ifname) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error: invalid network device name %s\\n\", ifname);\n\t\texit(1);\n\t}\n\t\n\tint sock = socket(AF_INET,SOCK_DGRAM,0);\n\tif (sock < 0)\n\t\terrExit(\"socket\");\n\n\t// get the existing interface flags\n\tstruct ifreq ifr;\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ);\n\tifr.ifr_addr.sa_family = AF_INET;\n\n\t// read the existing flags\n\tif (ioctl(sock, SIOCGIFFLAGS, &ifr ) < 0) {\n\t\tclose(sock);\n\t\tprintf(\"Error: cannot bring up interface %s\\n\", ifname);\n\t\terrExit(\"ioctl\");\n\t}\n\n\tifr.ifr_flags |= IFF_UP;\n\n\t// set the new flags\n\tif (ioctl( sock, SIOCSIFFLAGS, &ifr ) < 0) {\n\t\tclose(sock);\n\t\tprintf(\"Error: cannot bring up interface %s\\n\", ifname);\n\t\terrExit(\"ioctl\");\n\t}\n\n\t// checking\n\t// read the existing flags\n\tif (ioctl(sock, SIOCGIFFLAGS, &ifr ) < 0) {\n\t\tclose(sock);\n\t\tprintf(\"Error: cannot bring up interface %s\\n\", ifname);\n\t\terrExit(\"ioctl\");\n\t}\n\n\t// wait not more than 500ms for the interface to come up\n\tint cnt = 0;\n\twhile (cnt < 50) {\n\t\tusleep(10000);\t\t\t  // sleep 10ms\n\n\t\t// read the existing flags\n\t\tif (ioctl(sock, SIOCGIFFLAGS, &ifr ) < 0) {\n\t\t\tclose(sock);\n\t\t\tprintf(\"Error: cannot bring up interface %s\\n\", ifname);\n\t\t\terrExit(\"ioctl\");\n\t\t}\n\t\tif (ifr.ifr_flags & IFF_RUNNING)\n\t\t\tbreak;\n\t\tcnt++;\n\t}\n\n\tclose(sock);\n}",
    "includes": [
      "#include <linux/if_bridge.h>",
      "#include <net/route.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <ifaddrs.h>",
      "#include <netdb.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <arpa/inet.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sock"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"ioctl\""
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Error: cannot bring up interface %s\\n\"",
            "ifname"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sock"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "sock",
            "SIOCGIFFLAGS",
            "&ifr"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "10000"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"ioctl\""
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Error: cannot bring up interface %s\\n\"",
            "ifname"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sock"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "sock",
            "SIOCGIFFLAGS",
            "&ifr"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"ioctl\""
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Error: cannot bring up interface %s\\n\"",
            "ifname"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sock"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "sock",
            "SIOCSIFFLAGS",
            "&ifr"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"ioctl\""
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Error: cannot bring up interface %s\\n\"",
            "ifname"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "sock"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "sock",
            "SIOCGIFFLAGS",
            "&ifr"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "ifr.ifr_name",
            "ifname",
            "IFNAMSIZ"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ifr",
            "0",
            "sizeof(ifr)"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"socket\""
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_INET",
            "SOCK_DGRAM",
            "0"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "myexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/main.c",
          "lines": "137-149",
          "snippet": "static void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}",
          "includes": [
            "#include <sys/times.h>",
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int arg_command = 0;",
            "int arg_quiet = 0;",
            "pid_t sandbox_pid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/times.h>\n#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nint arg_command = 0;\nint arg_quiet = 0;\npid_t sandbox_pid;\n\nstatic void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid network device name %s\\n\"",
            "ifname"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ifname"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"firejail.h\"\n\nvoid net_if_up(const char *ifname) {\n\tif (strlen(ifname) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error: invalid network device name %s\\n\", ifname);\n\t\texit(1);\n\t}\n\t\n\tint sock = socket(AF_INET,SOCK_DGRAM,0);\n\tif (sock < 0)\n\t\terrExit(\"socket\");\n\n\t// get the existing interface flags\n\tstruct ifreq ifr;\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ);\n\tifr.ifr_addr.sa_family = AF_INET;\n\n\t// read the existing flags\n\tif (ioctl(sock, SIOCGIFFLAGS, &ifr ) < 0) {\n\t\tclose(sock);\n\t\tprintf(\"Error: cannot bring up interface %s\\n\", ifname);\n\t\terrExit(\"ioctl\");\n\t}\n\n\tifr.ifr_flags |= IFF_UP;\n\n\t// set the new flags\n\tif (ioctl( sock, SIOCSIFFLAGS, &ifr ) < 0) {\n\t\tclose(sock);\n\t\tprintf(\"Error: cannot bring up interface %s\\n\", ifname);\n\t\terrExit(\"ioctl\");\n\t}\n\n\t// checking\n\t// read the existing flags\n\tif (ioctl(sock, SIOCGIFFLAGS, &ifr ) < 0) {\n\t\tclose(sock);\n\t\tprintf(\"Error: cannot bring up interface %s\\n\", ifname);\n\t\terrExit(\"ioctl\");\n\t}\n\n\t// wait not more than 500ms for the interface to come up\n\tint cnt = 0;\n\twhile (cnt < 50) {\n\t\tusleep(10000);\t\t\t  // sleep 10ms\n\n\t\t// read the existing flags\n\t\tif (ioctl(sock, SIOCGIFFLAGS, &ifr ) < 0) {\n\t\t\tclose(sock);\n\t\t\tprintf(\"Error: cannot bring up interface %s\\n\", ifname);\n\t\t\terrExit(\"ioctl\");\n\t\t}\n\t\tif (ifr.ifr_flags & IFF_RUNNING)\n\t\t\tbreak;\n\t\tcnt++;\n\t}\n\n\tclose(sock);\n}"
  },
  {
    "function_name": "net_get_if_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/network.c",
    "lines": "147-185",
    "snippet": "int net_get_if_addr(const char *bridge, uint32_t *ip, uint32_t *mask, uint8_t mac[6], int *mtu) {\n\tassert(bridge);\n\tassert(ip);\n\tassert(mask);\n\t\n\tif (arg_debug)\n\t\tprintf(\"get interface %s configuration\\n\", bridge);\n\t\t\n\tint rv = -1;\n\tstruct ifaddrs *ifaddr, *ifa;\n\n\tif (getifaddrs(&ifaddr) == -1)\n\t\terrExit(\"getifaddrs\");\n\n\t// walk through the linked list; if the interface is found, extract IP address and mask\n\tfor (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {\n\t\tif (ifa->ifa_addr == NULL)\n\t\t\tcontinue;\n\t\tif (strcmp(ifa->ifa_name, bridge) != 0)\n\t\t\tcontinue;\n\n\t\tif (ifa->ifa_addr->sa_family == AF_INET) {\n\t\t\tstruct sockaddr_in *si = (struct sockaddr_in *) ifa->ifa_netmask;\n\t\t\t*mask = ntohl(si->sin_addr.s_addr);\n\t\t\tsi = (struct sockaddr_in *) ifa->ifa_addr;\n\t\t\t*ip = ntohl(si->sin_addr.s_addr);\n\t\t\tif (strcmp(ifa->ifa_name, \"lo\") != 0) {\n\t\t\t\tnet_get_mac(ifa->ifa_name, mac);\n\t\t\t\t*mtu = net_get_mtu(bridge);\n\t\t\t}\n\t\t\t\n\t\t\trv = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfreeifaddrs(ifaddr);\n\treturn rv;\n}",
    "includes": [
      "#include <linux/if_bridge.h>",
      "#include <net/route.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <ifaddrs.h>",
      "#include <netdb.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <arpa/inet.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "freeifaddrs",
          "args": [
            "ifaddr"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_get_mtu",
          "args": [
            "bridge"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "net_get_mtu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/network.c",
          "lines": "96-120",
          "snippet": "int net_get_mtu(const char *ifname) {\n\tint mtu = 0;\n\tif (strlen(ifname) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error: invalid network device name %s\\n\", ifname);\n\t\texit(1);\n\t}\n\n\tint s;\n\tstruct ifreq ifr;\n\n\tif ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0)\n\t\terrExit(\"socket\");\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tifr.ifr_addr.sa_family = AF_INET;\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ);\n\tif (ioctl(s, SIOCGIFMTU, (caddr_t)&ifr) == 0)\n\t\tmtu = ifr.ifr_mtu;\n\tif (arg_debug)\n\t\tprintf(\"MTU of %s is %d.\\n\", ifname, ifr.ifr_mtu);\n\tclose(s);\n\t\n\t\n\treturn mtu;\n}",
          "includes": [
            "#include <linux/if_bridge.h>",
            "#include <net/route.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <ifaddrs.h>",
            "#include <netdb.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <arpa/inet.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"firejail.h\"\n\nint net_get_mtu(const char *ifname) {\n\tint mtu = 0;\n\tif (strlen(ifname) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error: invalid network device name %s\\n\", ifname);\n\t\texit(1);\n\t}\n\n\tint s;\n\tstruct ifreq ifr;\n\n\tif ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0)\n\t\terrExit(\"socket\");\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tifr.ifr_addr.sa_family = AF_INET;\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ);\n\tif (ioctl(s, SIOCGIFMTU, (caddr_t)&ifr) == 0)\n\t\tmtu = ifr.ifr_mtu;\n\tif (arg_debug)\n\t\tprintf(\"MTU of %s is %d.\\n\", ifname, ifr.ifr_mtu);\n\tclose(s);\n\t\n\t\n\treturn mtu;\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_get_mac",
          "args": [
            "ifa->ifa_name",
            "mac"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "net_get_mac",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/network.c",
          "lines": "530-548",
          "snippet": "int net_get_mac(const char *ifname, unsigned char mac[6]) {\n\n\tstruct ifreq ifr;\n\tint sock;\n\n\tif ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0)\n              \terrExit(\"socket\");\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ);\n\tifr.ifr_hwaddr.sa_family = ARPHRD_ETHER;\n\t\n\tif (ioctl(sock, SIOCGIFHWADDR, &ifr) == -1)\n\t\terrExit(\"ioctl\");\n\tmemcpy(mac, ifr.ifr_hwaddr.sa_data, 6);\n\n\tclose(sock);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/if_bridge.h>",
            "#include <net/route.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <ifaddrs.h>",
            "#include <netdb.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <arpa/inet.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"firejail.h\"\n\nint net_get_mac(const char *ifname, unsigned char mac[6]) {\n\n\tstruct ifreq ifr;\n\tint sock;\n\n\tif ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0)\n              \terrExit(\"socket\");\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ);\n\tifr.ifr_hwaddr.sa_family = ARPHRD_ETHER;\n\t\n\tif (ioctl(sock, SIOCGIFHWADDR, &ifr) == -1)\n\t\terrExit(\"ioctl\");\n\tmemcpy(mac, ifr.ifr_hwaddr.sa_data, 6);\n\n\tclose(sock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ifa->ifa_name",
            "\"lo\""
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "si->sin_addr.s_addr"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "si->sin_addr.s_addr"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ifa->ifa_name",
            "bridge"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"getifaddrs\""
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getifaddrs",
          "args": [
            "&ifaddr"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"get interface %s configuration\\n\"",
            "bridge"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "mask"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "ip"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "bridge"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"firejail.h\"\n\nint net_get_if_addr(const char *bridge, uint32_t *ip, uint32_t *mask, uint8_t mac[6], int *mtu) {\n\tassert(bridge);\n\tassert(ip);\n\tassert(mask);\n\t\n\tif (arg_debug)\n\t\tprintf(\"get interface %s configuration\\n\", bridge);\n\t\t\n\tint rv = -1;\n\tstruct ifaddrs *ifaddr, *ifa;\n\n\tif (getifaddrs(&ifaddr) == -1)\n\t\terrExit(\"getifaddrs\");\n\n\t// walk through the linked list; if the interface is found, extract IP address and mask\n\tfor (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {\n\t\tif (ifa->ifa_addr == NULL)\n\t\t\tcontinue;\n\t\tif (strcmp(ifa->ifa_name, bridge) != 0)\n\t\t\tcontinue;\n\n\t\tif (ifa->ifa_addr->sa_family == AF_INET) {\n\t\t\tstruct sockaddr_in *si = (struct sockaddr_in *) ifa->ifa_netmask;\n\t\t\t*mask = ntohl(si->sin_addr.s_addr);\n\t\t\tsi = (struct sockaddr_in *) ifa->ifa_addr;\n\t\t\t*ip = ntohl(si->sin_addr.s_addr);\n\t\t\tif (strcmp(ifa->ifa_name, \"lo\") != 0) {\n\t\t\t\tnet_get_mac(ifa->ifa_name, mac);\n\t\t\t\t*mtu = net_get_mtu(bridge);\n\t\t\t}\n\t\t\t\n\t\t\trv = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfreeifaddrs(ifaddr);\n\treturn rv;\n}"
  },
  {
    "function_name": "net_set_mtu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/network.c",
    "lines": "122-144",
    "snippet": "void net_set_mtu(const char *ifname, int mtu) {\n\tif (strlen(ifname) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error: invalid network device name %s\\n\", ifname);\n\t\texit(1);\n\t}\n\n\tif (arg_debug)\n\t\tprintf(\"set interface %s MTU %d.\\n\", ifname, mtu);\n\n\tint s;\n\tstruct ifreq ifr;\n\n\tif ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0)\n\t\terrExit(\"socket\");\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tifr.ifr_addr.sa_family = AF_INET;\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ);\n\tifr.ifr_mtu = mtu;\n\tif (ioctl(s, SIOCSIFMTU, (caddr_t)&ifr) != 0)\n\t\tfprintf(stderr, \"Warning: cannot set mtu for interface %s\\n\", ifname);\n\tclose(s);\n}",
    "includes": [
      "#include <linux/if_bridge.h>",
      "#include <net/route.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <ifaddrs.h>",
      "#include <netdb.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <arpa/inet.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "s"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: cannot set mtu for interface %s\\n\"",
            "ifname"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "s",
            "SIOCSIFMTU",
            "(caddr_t)&ifr"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "ifr.ifr_name",
            "ifname",
            "IFNAMSIZ"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ifr",
            "0",
            "sizeof(ifr)"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"socket\""
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_INET",
            "SOCK_DGRAM",
            "0"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"set interface %s MTU %d.\\n\"",
            "ifname",
            "mtu"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "myexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/main.c",
          "lines": "137-149",
          "snippet": "static void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}",
          "includes": [
            "#include <sys/times.h>",
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int arg_command = 0;",
            "int arg_quiet = 0;",
            "pid_t sandbox_pid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/times.h>\n#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nint arg_command = 0;\nint arg_quiet = 0;\npid_t sandbox_pid;\n\nstatic void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid network device name %s\\n\"",
            "ifname"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ifname"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"firejail.h\"\n\nvoid net_set_mtu(const char *ifname, int mtu) {\n\tif (strlen(ifname) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error: invalid network device name %s\\n\", ifname);\n\t\texit(1);\n\t}\n\n\tif (arg_debug)\n\t\tprintf(\"set interface %s MTU %d.\\n\", ifname, mtu);\n\n\tint s;\n\tstruct ifreq ifr;\n\n\tif ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0)\n\t\terrExit(\"socket\");\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tifr.ifr_addr.sa_family = AF_INET;\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ);\n\tifr.ifr_mtu = mtu;\n\tif (ioctl(s, SIOCSIFMTU, (caddr_t)&ifr) != 0)\n\t\tfprintf(stderr, \"Warning: cannot set mtu for interface %s\\n\", ifname);\n\tclose(s);\n}"
  },
  {
    "function_name": "net_get_mtu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/network.c",
    "lines": "96-120",
    "snippet": "int net_get_mtu(const char *ifname) {\n\tint mtu = 0;\n\tif (strlen(ifname) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error: invalid network device name %s\\n\", ifname);\n\t\texit(1);\n\t}\n\n\tint s;\n\tstruct ifreq ifr;\n\n\tif ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0)\n\t\terrExit(\"socket\");\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tifr.ifr_addr.sa_family = AF_INET;\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ);\n\tif (ioctl(s, SIOCGIFMTU, (caddr_t)&ifr) == 0)\n\t\tmtu = ifr.ifr_mtu;\n\tif (arg_debug)\n\t\tprintf(\"MTU of %s is %d.\\n\", ifname, ifr.ifr_mtu);\n\tclose(s);\n\t\n\t\n\treturn mtu;\n}",
    "includes": [
      "#include <linux/if_bridge.h>",
      "#include <net/route.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <ifaddrs.h>",
      "#include <netdb.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <arpa/inet.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "s"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"MTU of %s is %d.\\n\"",
            "ifname",
            "ifr.ifr_mtu"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "s",
            "SIOCGIFMTU",
            "(caddr_t)&ifr"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "ifr.ifr_name",
            "ifname",
            "IFNAMSIZ"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ifr",
            "0",
            "sizeof(ifr)"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"socket\""
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_INET",
            "SOCK_DGRAM",
            "0"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "myexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/main.c",
          "lines": "137-149",
          "snippet": "static void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}",
          "includes": [
            "#include <sys/times.h>",
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int arg_command = 0;",
            "int arg_quiet = 0;",
            "pid_t sandbox_pid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/times.h>\n#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nint arg_command = 0;\nint arg_quiet = 0;\npid_t sandbox_pid;\n\nstatic void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid network device name %s\\n\"",
            "ifname"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ifname"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"firejail.h\"\n\nint net_get_mtu(const char *ifname) {\n\tint mtu = 0;\n\tif (strlen(ifname) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error: invalid network device name %s\\n\", ifname);\n\t\texit(1);\n\t}\n\n\tint s;\n\tstruct ifreq ifr;\n\n\tif ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0)\n\t\terrExit(\"socket\");\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tifr.ifr_addr.sa_family = AF_INET;\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ);\n\tif (ioctl(s, SIOCGIFMTU, (caddr_t)&ifr) == 0)\n\t\tmtu = ifr.ifr_mtu;\n\tif (arg_debug)\n\t\tprintf(\"MTU of %s is %d.\\n\", ifname, ifr.ifr_mtu);\n\tclose(s);\n\t\n\t\n\treturn mtu;\n}"
  },
  {
    "function_name": "net_ifprint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/network.c",
    "lines": "32-94",
    "snippet": "void net_ifprint(void) {\n\tuint32_t ip;\n\tuint32_t mask;\n\tstruct ifaddrs *ifaddr, *ifa;\n\n\tif (getifaddrs(&ifaddr) == -1)\n\t\terrExit(\"getifaddrs\");\n\n\tprintf(\"%-17.17s%-19.19s%-17.17s%-17.17s%-6.6s\\n\",\n\t\t\"Interface\", \"MAC\", \"IP\", \"Mask\", \"Status\");\n\t// walk through the linked list\n\tfor (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {\n\t\tif (ifa->ifa_addr == NULL)\n\t\t\tcontinue;\n\n\t\tif (ifa->ifa_addr->sa_family == AF_INET) {\n\t\t\tstruct sockaddr_in *si = (struct sockaddr_in *) ifa->ifa_netmask;\n\t\t\tmask = ntohl(si->sin_addr.s_addr);\n\t\t\tsi = (struct sockaddr_in *) ifa->ifa_addr;\n\t\t\tip = ntohl(si->sin_addr.s_addr);\n\n\t\t\t// interface status\n\t\t\tchar *status;\n\t\t\tif (ifa->ifa_flags & IFF_RUNNING && ifa->ifa_flags & IFF_UP)\n\t\t\t\tstatus = \"UP\";\n\t\t\telse\n\t\t\t\tstatus = \"DOWN\";\n\n\t\t\t// ip address and mask\n\t\t\tchar ipstr[30];\n\t\t\tsprintf(ipstr, \"%d.%d.%d.%d\", PRINT_IP(ip));\n\t\t\tchar maskstr[30];\n\t\t\tsprintf(maskstr, \"%d.%d.%d.%d\", PRINT_IP(mask));\n\t\t\t\n\t\t\t// mac address\n\t\t\tunsigned char mac[6];\n\t\t\tnet_get_mac(ifa->ifa_name, mac);\n\t\t\tchar macstr[30];\n\t\t\tif (strcmp(ifa->ifa_name, \"lo\") == 0)\n\t\t\t\tmacstr[0] = '\\0';\n\t\t\telse\n\t\t\t\tsprintf(macstr, \"%02x:%02x:%02x:%02x:%02x:%02x\", PRINT_MAC(mac));\n\n\t\t\t// print\t\t\t\t\n\t\t\tprintf(\"%-17.17s%-19.19s%-17.17s%-17.17s%-6.6s\\n\",\n\t\t\t\tifa->ifa_name, macstr, ipstr, maskstr, status);\n\n\t\t\t// network scanning\n\t\t\tif (!arg_scan)\t\t\t\t// scanning disabled\n\t\t\t\tcontinue;\n\t\t\tif (strcmp(ifa->ifa_name, \"lo\") == 0)\t// no loopbabck scanning\n\t\t\t\tcontinue;\n\t\t\tif (mask2bits(mask) < 16)\t\t// not scanning large networks\n\t\t\t\tcontinue;\n\t\t\tif (!ip)\t\t\t\t\t// if not configured\n\t\t\t\tcontinue;\n\t\t\t// only if the interface is up and running\n\t\t\tif (ifa->ifa_flags & IFF_RUNNING && ifa->ifa_flags & IFF_UP)\n\t\t\t\tarp_scan(ifa->ifa_name, ip, mask);\n\t\t}\n\t}\n\tfreeifaddrs(ifaddr);\n}",
    "includes": [
      "#include <linux/if_bridge.h>",
      "#include <net/route.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <ifaddrs.h>",
      "#include <netdb.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <arpa/inet.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "freeifaddrs",
          "args": [
            "ifaddr"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arp_scan",
          "args": [
            "ifa->ifa_name",
            "ip",
            "mask"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "arp_scan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/arp.c",
          "lines": "290-472",
          "snippet": "void arp_scan(const char *dev, uint32_t ifip, uint32_t ifmask) {\n\tassert(dev);\n\tassert(ifip);\n\n//\tprintf(\"Scanning interface %s (%d.%d.%d.%d/%d)\\n\",\n//\t\tdev, PRINT_IP(ifip & ifmask), mask2bits(ifmask));\n\t\t\t\n\tif (strlen(dev) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error: invalid network device name %s\\n\", dev);\n\t\texit(1);\n\t}\n\t\n\t// find interface mac address\n\tint sock;\n\tif ((sock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0)\n\t\terrExit(\"socket\");\n\tstruct ifreq ifr;\n\tmemset(&ifr, 0, sizeof (ifr));\n\tstrncpy(ifr.ifr_name, dev, IFNAMSIZ);\n\tif (ioctl(sock, SIOCGIFHWADDR, &ifr) < 0)\n\t\terrExit(\"ioctl\");\n\tclose(sock);\n\tuint8_t mac[6];\n\tmemcpy (mac, ifr.ifr_hwaddr.sa_data, 6);\n\n\t// open layer2 socket\n\tif ((sock = socket(PF_PACKET, SOCK_RAW, htons (ETH_P_ALL))) < 0)\n\t\terrExit(\"socket\");\n\t\n\t// try all possible ip addresses in ascending order\n\tuint32_t range = ~ifmask + 1; // the number of potential addresses\n\t// this software is not supported for /31 networks\n\tif (range < 4) {\n\t\tfprintf(stderr, \"Warning: this option is not supported for /31 networks\\n\");\n\t\tclose(sock);\n\t\treturn;\n\t}\n\n\tuint32_t dest = (ifip & ifmask) + 1;\n\tuint32_t last = dest + range - 1;\n\tuint32_t src = htonl(ifip);\n\n\t// wait not more than one second for an answer\n\tint header_printed = 0;\n\tuint32_t last_ip = 0;\n\tstruct timeval ts;\n\tts.tv_sec = 2; // 2 seconds receive timeout\n\tts.tv_usec = 0;\n\t\n\twhile (1) {\n\t\tfd_set rfds;\n\t\tFD_ZERO(&rfds);\n\t\tFD_SET(sock, &rfds);\n\t\tfd_set wfds;\n\t\tFD_ZERO(&wfds);\n\t\tFD_SET(sock, &wfds);\n\t\tint maxfd = sock;\n\n\t\tuint8_t frame[ETH_FRAME_LEN]; // includes eht header, vlan, and crc\n\t\tmemset(frame, 0, ETH_FRAME_LEN);\t\n\n\t\tint nready;\n\t\tif (dest < last)\n\t\t\tnready = select(maxfd + 1,  &rfds, &wfds, (fd_set *) 0, NULL);\n\t\telse\t\t\n\t\t\tnready = select(maxfd + 1,  &rfds,  (fd_set *) 0, (fd_set *) 0, &ts);\n\t\t\n\t\tif (nready < 0)\n\t\t\terrExit(\"select\");\n\t\t\t\n\t\tif (nready == 0) { // timeout\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif (FD_ISSET(sock, &wfds) && dest < last) {\n\t\t\t// configure layer2 socket address information\n\t\t\tstruct sockaddr_ll addr;\n\t\t\tmemset(&addr, 0, sizeof(addr));\n\t\t\tif ((addr.sll_ifindex = if_nametoindex(dev)) == 0)\n\t\t\t\terrExit(\"if_nametoindex\");\n\t\t\taddr.sll_family = AF_PACKET;\n\t\t\tmemcpy (addr.sll_addr, mac, 6);\n\t\t\taddr.sll_halen = htons(6);\n\t\t\n\t\t\t// build the arp packet header\n\t\t\tArpHdr hdr;\n\t\t\tmemset(&hdr, 0, sizeof(hdr));\n\t\t\thdr.htype = htons(1);\n\t\t\thdr.ptype = htons(ETH_P_IP);\n\t\t\thdr.hlen = 6;\n\t\t\thdr.plen = 4;\n\t\t\thdr.opcode = htons(1); //ARPOP_REQUEST\n\t\t\tmemcpy(hdr.sender_mac, mac, 6);\n\t\t\tmemcpy(hdr.sender_ip, (uint8_t *)&src, 4);\n\t\t\tuint32_t dst = htonl(dest);\n\t\t\tmemcpy(hdr.target_ip, (uint8_t *)&dst, 4);\n\t\t\n\t\t\t// build ethernet frame\n\t\t\tuint8_t frame[ETH_FRAME_LEN]; // includes eht header, vlan, and crc\n\t\t\tmemset(frame, 0, sizeof(frame));\n\t\t\tframe[0] = frame[1] = frame[2] = frame[3] = frame[4] = frame[5] = 0xff;\n\t\t\tmemcpy(frame + 6, mac, 6);\n\t\t\tframe[12] = ETH_P_ARP / 256;\n\t\t\tframe[13] = ETH_P_ARP % 256;\n\t\t\tmemcpy (frame + 14, &hdr, sizeof(hdr));\n\t\t\n\t\t\t// send packet\n\t\t\tint len;\n\t\t\tif ((len = sendto (sock, frame, 14 + sizeof(ArpHdr), 0, (struct sockaddr *) &addr, sizeof (addr))) <= 0)\n\t\t\t\terrExit(\"send\");\n//printf(\"send %d bytes to %d.%d.%d.%d\\n\", len, PRINT_IP(dest));\t\t\n\t\t\tfflush(0);\n\t\t\tdest++;\n\t\t}\n\t\t\n\t\tif (FD_ISSET(sock, &rfds)) {\n\t\t\t// read the incoming packet\n\t\t\tint len = recvfrom(sock, frame, ETH_FRAME_LEN, 0, NULL, NULL);\n\t\t\tif (len < 0) {\n\t\t\t\tperror(\"recvfrom\");\n\t\t\t}\n\n\t\t\t// parse the incoming packet\n\t\t\tif ((unsigned int) len < 14 + sizeof(ArpHdr))\n\t\t\t\tcontinue;\n\n\t\t\t// look only at ARP packets\n\t\t\tif (frame[12] != (ETH_P_ARP / 256) || frame[13] != (ETH_P_ARP % 256))\n\t\t\t\tcontinue;\n\n\t\t\tArpHdr hdr;\n\t\t\tmemcpy(&hdr, frame + 14, sizeof(ArpHdr));\n\n\t\t\tif (hdr.opcode == htons(2)) {\n\t\t\t\t// check my mac and my address\n\t\t\t\tif (memcmp(mac, hdr.target_mac, 6) != 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tuint32_t ip;\n\t\t\t\tmemcpy(&ip, hdr.target_ip, 4);\n\t\t\t\tif (ip != src)\n\t\t\t\t\tcontinue;\n\t\t\t\tmemcpy(&ip, hdr.sender_ip, 4);\n\t\t\t\tip = ntohl(ip);\n\t\t\t\t\n\t\t\t\tif (ip == last_ip) // filter duplicates\n\t\t\t\t\tcontinue;\n\t\t\t\tlast_ip = ip;\n\t\t\t\t\t\n\t\t\t\t// printing\n\t\t\t\tif (header_printed == 0) {\n\t\t\t\t\tprintf(\"   Network scan:\\n\");\n\t\t\t\t\t\n\t\t\t\t\t// print parent interface\n\t\t\t\t\tif (cfg.bridge0.configured && cfg.bridge0.ip && cfg.bridge0.macvlan &&\n\t\t\t\t\t    (cfg.bridge0.ip & cfg.bridge0.mask) == (ifip & cfg.bridge0.mask))\n\t\t\t\t\t\tprintf(\"   %02x:%02x:%02x:%02x:%02x:%02x\\t%d.%d.%d.%d\\n\",\n\t\t\t\t\t\t\tPRINT_MAC(cfg.bridge0.mac), PRINT_IP(cfg.bridge0.ip));\n\t\t\t\t\t\n\t\t\t\t\tif (cfg.bridge1.configured && cfg.bridge1.ip &&  cfg.bridge1.macvlan &&\n\t\t\t\t\t    (cfg.bridge1.ip & cfg.bridge1.mask) == (ifip & cfg.bridge1.mask))\n\t\t\t\t\t\tprintf(\"   %02x:%02x:%02x:%02x:%02x:%02x\\t%d.%d.%d.%d\\n\",\n\t\t\t\t\t\t\tPRINT_MAC(cfg.bridge1.mac), PRINT_IP(cfg.bridge1.ip));\n\t\t\t\t\t\n\t\t\t\t\tif (cfg.bridge2.configured && cfg.bridge2.ip &&  cfg.bridge2.macvlan &&\n\t\t\t\t\t    (cfg.bridge2.ip & cfg.bridge2.mask) == (ifip & cfg.bridge2.mask))\n\t\t\t\t\t\tprintf(\"   %02x:%02x:%02x:%02x:%02x:%02x\\t%d.%d.%d.%d\\n\",\n\t\t\t\t\t\t\tPRINT_MAC(cfg.bridge2.mac), PRINT_IP(cfg.bridge2.ip));\n\t\t\t\t\t\n\t\t\t\t\tif (cfg.bridge3.configured && cfg.bridge3.ip &&  cfg.bridge3.macvlan &&\n\t\t\t\t\t    (cfg.bridge3.ip & cfg.bridge3.mask) == (ifip & cfg.bridge3.mask))\n\t\t\t\t\t\tprintf(\"   %02x:%02x:%02x:%02x:%02x:%02x\\t%d.%d.%d.%d\\n\",\n\t\t\t\t\t\t\tPRINT_MAC(cfg.bridge3.mac), PRINT_IP(cfg.bridge3.ip));\n\t\t\t\t\t\n\t\t\t\t\theader_printed = 1;\n\t\t\t\t}\n\t\t\t\tprintf(\"   %02x:%02x:%02x:%02x:%02x:%02x\\t%d.%d.%d.%d\\n\",\n\t\t\t\t\tPRINT_MAC(hdr.sender_mac), PRINT_IP(ip));\t\t\t\t\t\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclose(sock);\n}",
          "includes": [
            "#include <linux/if_packet.h>",
            "#include <linux/tcp.h>",
            "#include <linux/udp.h>",
            "#include <linux/ip.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/if_ether.h>\t\t\t  //TCP/IP Protocol Suite for Linux",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_packet.h>\n#include <linux/tcp.h>\n#include <linux/udp.h>\n#include <linux/ip.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/if_ether.h>\t\t\t  //TCP/IP Protocol Suite for Linux\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include \"firejail.h\"\n\nvoid arp_scan(const char *dev, uint32_t ifip, uint32_t ifmask) {\n\tassert(dev);\n\tassert(ifip);\n\n//\tprintf(\"Scanning interface %s (%d.%d.%d.%d/%d)\\n\",\n//\t\tdev, PRINT_IP(ifip & ifmask), mask2bits(ifmask));\n\t\t\t\n\tif (strlen(dev) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error: invalid network device name %s\\n\", dev);\n\t\texit(1);\n\t}\n\t\n\t// find interface mac address\n\tint sock;\n\tif ((sock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0)\n\t\terrExit(\"socket\");\n\tstruct ifreq ifr;\n\tmemset(&ifr, 0, sizeof (ifr));\n\tstrncpy(ifr.ifr_name, dev, IFNAMSIZ);\n\tif (ioctl(sock, SIOCGIFHWADDR, &ifr) < 0)\n\t\terrExit(\"ioctl\");\n\tclose(sock);\n\tuint8_t mac[6];\n\tmemcpy (mac, ifr.ifr_hwaddr.sa_data, 6);\n\n\t// open layer2 socket\n\tif ((sock = socket(PF_PACKET, SOCK_RAW, htons (ETH_P_ALL))) < 0)\n\t\terrExit(\"socket\");\n\t\n\t// try all possible ip addresses in ascending order\n\tuint32_t range = ~ifmask + 1; // the number of potential addresses\n\t// this software is not supported for /31 networks\n\tif (range < 4) {\n\t\tfprintf(stderr, \"Warning: this option is not supported for /31 networks\\n\");\n\t\tclose(sock);\n\t\treturn;\n\t}\n\n\tuint32_t dest = (ifip & ifmask) + 1;\n\tuint32_t last = dest + range - 1;\n\tuint32_t src = htonl(ifip);\n\n\t// wait not more than one second for an answer\n\tint header_printed = 0;\n\tuint32_t last_ip = 0;\n\tstruct timeval ts;\n\tts.tv_sec = 2; // 2 seconds receive timeout\n\tts.tv_usec = 0;\n\t\n\twhile (1) {\n\t\tfd_set rfds;\n\t\tFD_ZERO(&rfds);\n\t\tFD_SET(sock, &rfds);\n\t\tfd_set wfds;\n\t\tFD_ZERO(&wfds);\n\t\tFD_SET(sock, &wfds);\n\t\tint maxfd = sock;\n\n\t\tuint8_t frame[ETH_FRAME_LEN]; // includes eht header, vlan, and crc\n\t\tmemset(frame, 0, ETH_FRAME_LEN);\t\n\n\t\tint nready;\n\t\tif (dest < last)\n\t\t\tnready = select(maxfd + 1,  &rfds, &wfds, (fd_set *) 0, NULL);\n\t\telse\t\t\n\t\t\tnready = select(maxfd + 1,  &rfds,  (fd_set *) 0, (fd_set *) 0, &ts);\n\t\t\n\t\tif (nready < 0)\n\t\t\terrExit(\"select\");\n\t\t\t\n\t\tif (nready == 0) { // timeout\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif (FD_ISSET(sock, &wfds) && dest < last) {\n\t\t\t// configure layer2 socket address information\n\t\t\tstruct sockaddr_ll addr;\n\t\t\tmemset(&addr, 0, sizeof(addr));\n\t\t\tif ((addr.sll_ifindex = if_nametoindex(dev)) == 0)\n\t\t\t\terrExit(\"if_nametoindex\");\n\t\t\taddr.sll_family = AF_PACKET;\n\t\t\tmemcpy (addr.sll_addr, mac, 6);\n\t\t\taddr.sll_halen = htons(6);\n\t\t\n\t\t\t// build the arp packet header\n\t\t\tArpHdr hdr;\n\t\t\tmemset(&hdr, 0, sizeof(hdr));\n\t\t\thdr.htype = htons(1);\n\t\t\thdr.ptype = htons(ETH_P_IP);\n\t\t\thdr.hlen = 6;\n\t\t\thdr.plen = 4;\n\t\t\thdr.opcode = htons(1); //ARPOP_REQUEST\n\t\t\tmemcpy(hdr.sender_mac, mac, 6);\n\t\t\tmemcpy(hdr.sender_ip, (uint8_t *)&src, 4);\n\t\t\tuint32_t dst = htonl(dest);\n\t\t\tmemcpy(hdr.target_ip, (uint8_t *)&dst, 4);\n\t\t\n\t\t\t// build ethernet frame\n\t\t\tuint8_t frame[ETH_FRAME_LEN]; // includes eht header, vlan, and crc\n\t\t\tmemset(frame, 0, sizeof(frame));\n\t\t\tframe[0] = frame[1] = frame[2] = frame[3] = frame[4] = frame[5] = 0xff;\n\t\t\tmemcpy(frame + 6, mac, 6);\n\t\t\tframe[12] = ETH_P_ARP / 256;\n\t\t\tframe[13] = ETH_P_ARP % 256;\n\t\t\tmemcpy (frame + 14, &hdr, sizeof(hdr));\n\t\t\n\t\t\t// send packet\n\t\t\tint len;\n\t\t\tif ((len = sendto (sock, frame, 14 + sizeof(ArpHdr), 0, (struct sockaddr *) &addr, sizeof (addr))) <= 0)\n\t\t\t\terrExit(\"send\");\n//printf(\"send %d bytes to %d.%d.%d.%d\\n\", len, PRINT_IP(dest));\t\t\n\t\t\tfflush(0);\n\t\t\tdest++;\n\t\t}\n\t\t\n\t\tif (FD_ISSET(sock, &rfds)) {\n\t\t\t// read the incoming packet\n\t\t\tint len = recvfrom(sock, frame, ETH_FRAME_LEN, 0, NULL, NULL);\n\t\t\tif (len < 0) {\n\t\t\t\tperror(\"recvfrom\");\n\t\t\t}\n\n\t\t\t// parse the incoming packet\n\t\t\tif ((unsigned int) len < 14 + sizeof(ArpHdr))\n\t\t\t\tcontinue;\n\n\t\t\t// look only at ARP packets\n\t\t\tif (frame[12] != (ETH_P_ARP / 256) || frame[13] != (ETH_P_ARP % 256))\n\t\t\t\tcontinue;\n\n\t\t\tArpHdr hdr;\n\t\t\tmemcpy(&hdr, frame + 14, sizeof(ArpHdr));\n\n\t\t\tif (hdr.opcode == htons(2)) {\n\t\t\t\t// check my mac and my address\n\t\t\t\tif (memcmp(mac, hdr.target_mac, 6) != 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tuint32_t ip;\n\t\t\t\tmemcpy(&ip, hdr.target_ip, 4);\n\t\t\t\tif (ip != src)\n\t\t\t\t\tcontinue;\n\t\t\t\tmemcpy(&ip, hdr.sender_ip, 4);\n\t\t\t\tip = ntohl(ip);\n\t\t\t\t\n\t\t\t\tif (ip == last_ip) // filter duplicates\n\t\t\t\t\tcontinue;\n\t\t\t\tlast_ip = ip;\n\t\t\t\t\t\n\t\t\t\t// printing\n\t\t\t\tif (header_printed == 0) {\n\t\t\t\t\tprintf(\"   Network scan:\\n\");\n\t\t\t\t\t\n\t\t\t\t\t// print parent interface\n\t\t\t\t\tif (cfg.bridge0.configured && cfg.bridge0.ip && cfg.bridge0.macvlan &&\n\t\t\t\t\t    (cfg.bridge0.ip & cfg.bridge0.mask) == (ifip & cfg.bridge0.mask))\n\t\t\t\t\t\tprintf(\"   %02x:%02x:%02x:%02x:%02x:%02x\\t%d.%d.%d.%d\\n\",\n\t\t\t\t\t\t\tPRINT_MAC(cfg.bridge0.mac), PRINT_IP(cfg.bridge0.ip));\n\t\t\t\t\t\n\t\t\t\t\tif (cfg.bridge1.configured && cfg.bridge1.ip &&  cfg.bridge1.macvlan &&\n\t\t\t\t\t    (cfg.bridge1.ip & cfg.bridge1.mask) == (ifip & cfg.bridge1.mask))\n\t\t\t\t\t\tprintf(\"   %02x:%02x:%02x:%02x:%02x:%02x\\t%d.%d.%d.%d\\n\",\n\t\t\t\t\t\t\tPRINT_MAC(cfg.bridge1.mac), PRINT_IP(cfg.bridge1.ip));\n\t\t\t\t\t\n\t\t\t\t\tif (cfg.bridge2.configured && cfg.bridge2.ip &&  cfg.bridge2.macvlan &&\n\t\t\t\t\t    (cfg.bridge2.ip & cfg.bridge2.mask) == (ifip & cfg.bridge2.mask))\n\t\t\t\t\t\tprintf(\"   %02x:%02x:%02x:%02x:%02x:%02x\\t%d.%d.%d.%d\\n\",\n\t\t\t\t\t\t\tPRINT_MAC(cfg.bridge2.mac), PRINT_IP(cfg.bridge2.ip));\n\t\t\t\t\t\n\t\t\t\t\tif (cfg.bridge3.configured && cfg.bridge3.ip &&  cfg.bridge3.macvlan &&\n\t\t\t\t\t    (cfg.bridge3.ip & cfg.bridge3.mask) == (ifip & cfg.bridge3.mask))\n\t\t\t\t\t\tprintf(\"   %02x:%02x:%02x:%02x:%02x:%02x\\t%d.%d.%d.%d\\n\",\n\t\t\t\t\t\t\tPRINT_MAC(cfg.bridge3.mac), PRINT_IP(cfg.bridge3.ip));\n\t\t\t\t\t\n\t\t\t\t\theader_printed = 1;\n\t\t\t\t}\n\t\t\t\tprintf(\"   %02x:%02x:%02x:%02x:%02x:%02x\\t%d.%d.%d.%d\\n\",\n\t\t\t\t\tPRINT_MAC(hdr.sender_mac), PRINT_IP(ip));\t\t\t\t\t\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mask2bits",
          "args": [
            "mask"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ifa->ifa_name",
            "\"lo\""
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%-17.17s%-19.19s%-17.17s%-17.17s%-6.6s\\n\"",
            "ifa->ifa_name",
            "macstr",
            "ipstr",
            "maskstr",
            "status"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "macstr",
            "\"%02x:%02x:%02x:%02x:%02x:%02x\"",
            "PRINT_MAC(mac)"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_MAC",
          "args": [
            "mac"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ifa->ifa_name",
            "\"lo\""
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_get_mac",
          "args": [
            "ifa->ifa_name",
            "mac"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "net_get_mac",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/network.c",
          "lines": "530-548",
          "snippet": "int net_get_mac(const char *ifname, unsigned char mac[6]) {\n\n\tstruct ifreq ifr;\n\tint sock;\n\n\tif ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0)\n              \terrExit(\"socket\");\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ);\n\tifr.ifr_hwaddr.sa_family = ARPHRD_ETHER;\n\t\n\tif (ioctl(sock, SIOCGIFHWADDR, &ifr) == -1)\n\t\terrExit(\"ioctl\");\n\tmemcpy(mac, ifr.ifr_hwaddr.sa_data, 6);\n\n\tclose(sock);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/if_bridge.h>",
            "#include <net/route.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <ifaddrs.h>",
            "#include <netdb.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <arpa/inet.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"firejail.h\"\n\nint net_get_mac(const char *ifname, unsigned char mac[6]) {\n\n\tstruct ifreq ifr;\n\tint sock;\n\n\tif ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0)\n              \terrExit(\"socket\");\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ);\n\tifr.ifr_hwaddr.sa_family = ARPHRD_ETHER;\n\t\n\tif (ioctl(sock, SIOCGIFHWADDR, &ifr) == -1)\n\t\terrExit(\"ioctl\");\n\tmemcpy(mac, ifr.ifr_hwaddr.sa_data, 6);\n\n\tclose(sock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "maskstr",
            "\"%d.%d.%d.%d\"",
            "PRINT_IP(mask)"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_IP",
          "args": [
            "mask"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "ipstr",
            "\"%d.%d.%d.%d\"",
            "PRINT_IP(ip)"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_IP",
          "args": [
            "ip"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "si->sin_addr.s_addr"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "si->sin_addr.s_addr"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%-17.17s%-19.19s%-17.17s%-17.17s%-6.6s\\n\"",
            "\"Interface\"",
            "\"MAC\"",
            "\"IP\"",
            "\"Mask\"",
            "\"Status\""
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"getifaddrs\""
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getifaddrs",
          "args": [
            "&ifaddr"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"firejail.h\"\n\nvoid net_ifprint(void) {\n\tuint32_t ip;\n\tuint32_t mask;\n\tstruct ifaddrs *ifaddr, *ifa;\n\n\tif (getifaddrs(&ifaddr) == -1)\n\t\terrExit(\"getifaddrs\");\n\n\tprintf(\"%-17.17s%-19.19s%-17.17s%-17.17s%-6.6s\\n\",\n\t\t\"Interface\", \"MAC\", \"IP\", \"Mask\", \"Status\");\n\t// walk through the linked list\n\tfor (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {\n\t\tif (ifa->ifa_addr == NULL)\n\t\t\tcontinue;\n\n\t\tif (ifa->ifa_addr->sa_family == AF_INET) {\n\t\t\tstruct sockaddr_in *si = (struct sockaddr_in *) ifa->ifa_netmask;\n\t\t\tmask = ntohl(si->sin_addr.s_addr);\n\t\t\tsi = (struct sockaddr_in *) ifa->ifa_addr;\n\t\t\tip = ntohl(si->sin_addr.s_addr);\n\n\t\t\t// interface status\n\t\t\tchar *status;\n\t\t\tif (ifa->ifa_flags & IFF_RUNNING && ifa->ifa_flags & IFF_UP)\n\t\t\t\tstatus = \"UP\";\n\t\t\telse\n\t\t\t\tstatus = \"DOWN\";\n\n\t\t\t// ip address and mask\n\t\t\tchar ipstr[30];\n\t\t\tsprintf(ipstr, \"%d.%d.%d.%d\", PRINT_IP(ip));\n\t\t\tchar maskstr[30];\n\t\t\tsprintf(maskstr, \"%d.%d.%d.%d\", PRINT_IP(mask));\n\t\t\t\n\t\t\t// mac address\n\t\t\tunsigned char mac[6];\n\t\t\tnet_get_mac(ifa->ifa_name, mac);\n\t\t\tchar macstr[30];\n\t\t\tif (strcmp(ifa->ifa_name, \"lo\") == 0)\n\t\t\t\tmacstr[0] = '\\0';\n\t\t\telse\n\t\t\t\tsprintf(macstr, \"%02x:%02x:%02x:%02x:%02x:%02x\", PRINT_MAC(mac));\n\n\t\t\t// print\t\t\t\t\n\t\t\tprintf(\"%-17.17s%-19.19s%-17.17s%-17.17s%-6.6s\\n\",\n\t\t\t\tifa->ifa_name, macstr, ipstr, maskstr, status);\n\n\t\t\t// network scanning\n\t\t\tif (!arg_scan)\t\t\t\t// scanning disabled\n\t\t\t\tcontinue;\n\t\t\tif (strcmp(ifa->ifa_name, \"lo\") == 0)\t// no loopbabck scanning\n\t\t\t\tcontinue;\n\t\t\tif (mask2bits(mask) < 16)\t\t// not scanning large networks\n\t\t\t\tcontinue;\n\t\t\tif (!ip)\t\t\t\t\t// if not configured\n\t\t\t\tcontinue;\n\t\t\t// only if the interface is up and running\n\t\t\tif (ifa->ifa_flags & IFF_RUNNING && ifa->ifa_flags & IFF_UP)\n\t\t\t\tarp_scan(ifa->ifa_name, ip, mask);\n\t\t}\n\t}\n\tfreeifaddrs(ifaddr);\n}"
  }
]