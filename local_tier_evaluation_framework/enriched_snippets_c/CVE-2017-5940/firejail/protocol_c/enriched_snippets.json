[
  {
    "function_name": "protocol_print_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/protocol.c",
    "lines": "330-381",
    "snippet": "void protocol_print_filter(pid_t pid) {\n\tEUID_ASSERT();\n\t\n\t(void) pid;\n#ifdef SYS_socket\n\t// if the pid is that of a firejail  process, use the pid of the first child process\n\tEUID_ROOT();\n\tchar *comm = pid_proc_comm(pid);\n\tEUID_USER();\n\tif (comm) {\n\t\tif (strcmp(comm, \"firejail\") == 0) {\n\t\t\tpid_t child;\n\t\t\tif (find_child(pid, &child) == 0) {\n\t\t\t\tpid = child;\n\t\t\t}\n\t\t}\n\t\tfree(comm);\n\t}\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission denied.\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// find the seccomp filter\n\tEUID_ROOT();\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_PROTOCOL_CFG) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct stat s;\n\tif (stat(fname, &s) == -1) {\n\t\tprintf(\"Cannot access seccomp filter.\\n\");\n\t\texit(1);\n\t}\n\n\t// read and print the filter\n\tprotocol_filter_load(fname);\n\tfree(fname);\n\tif (cfg.protocol)\n\t\tprintf(\"%s\\n\", cfg.protocol);\n\texit(0);\n#else\n        fprintf(stderr, \"Warning: --protocol not supported on this platform\\n\");\n        return;\n#endif  \n}",
    "includes": [
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"seccomp.h\"",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: --protocol not supported on this platform\\n\""
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "myexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/main.c",
          "lines": "137-149",
          "snippet": "static void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}",
          "includes": [
            "#include <sys/times.h>",
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int arg_command = 0;",
            "int arg_quiet = 0;",
            "pid_t sandbox_pid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/times.h>\n#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nint arg_command = 0;\nint arg_quiet = 0;\npid_t sandbox_pid;\n\nstatic void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s\\n\"",
            "cfg.protocol"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "fname"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "protocol_filter_load",
          "args": [
            "fname"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "protocol_filter_load",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/protocol.c",
          "lines": "280-303",
          "snippet": "void protocol_filter_load(const char *fname) {\n\tassert(fname);\n\t\n\t// read protocol filter configuration from PROTOCOL_CFG\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp)\n\t\treturn;\n\n\tconst int MAXBUF = 4098;\n\tchar buf[MAXBUF];\n\tif (fgets(buf, MAXBUF, fp) == NULL) {\n\t\t// empty file\n\t\tfclose(fp);\n\t\treturn;\n\t}\n\tfclose(fp);\n\t\n\tchar *ptr = strchr(buf, '\\n');\n\tif (ptr)\n\t\t*ptr = '\\0';\n\tcfg.protocol = strdup(buf);\n\tif (!cfg.protocol)\n\t\terrExit(\"strdup\");\n}",
          "includes": [
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"seccomp.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/socket.h>\n#include <sys/types.h>\n#include \"seccomp.h\"\n#include \"firejail.h\"\n\nvoid protocol_filter_load(const char *fname) {\n\tassert(fname);\n\t\n\t// read protocol filter configuration from PROTOCOL_CFG\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp)\n\t\treturn;\n\n\tconst int MAXBUF = 4098;\n\tchar buf[MAXBUF];\n\tif (fgets(buf, MAXBUF, fp) == NULL) {\n\t\t// empty file\n\t\tfclose(fp);\n\t\treturn;\n\t}\n\tfclose(fp);\n\t\n\tchar *ptr = strchr(buf, '\\n');\n\tif (ptr)\n\t\t*ptr = '\\0';\n\tcfg.protocol = strdup(buf);\n\tif (!cfg.protocol)\n\t\terrExit(\"strdup\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Cannot access seccomp filter.\\n\""
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "fname",
            "&s"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&fname",
            "\"/proc/%d/root%s\"",
            "pid",
            "RUN_PROTOCOL_CFG"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ROOT",
          "args": [],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: permission denied.\\n\""
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pid_get_uid",
          "args": [
            "pid"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "pid_get_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/util.c",
          "lines": "621-665",
          "snippet": "uid_t pid_get_uid(pid_t pid) {\n\tEUID_ASSERT();\n\tuid_t rv = 0;\n\n\t// open status file\n\tchar *file;\n\tif (asprintf(&file, \"/proc/%u/status\", pid) == -1) {\n\t\tperror(\"asprintf\");\n\t\texit(1);\n\t}\n\tEUID_ROOT();\t\t\t\t  // grsecurity fix\n\tFILE *fp = fopen(file, \"r\");\n\tif (!fp) {\n\t\tfree(file);\n\t\tfprintf(stderr, \"Error: cannot open /proc file\\n\");\n\t\texit(1);\n\t}\n\n\t// extract uid\n\tstatic const int PIDS_BUFLEN = 1024;\n\tchar buf[PIDS_BUFLEN];\n\twhile (fgets(buf, PIDS_BUFLEN - 1, fp)) {\n\t\tif (strncmp(buf, \"Uid:\", 4) == 0) {\n\t\t\tchar *ptr = buf + 5;\n\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\tptr++;\n\t\t\t}\n\t\t\tif (*ptr == '\\0')\n\t\t\t\tbreak;\n\n\t\t\trv = atoi(ptr);\n\t\t\tbreak;\t\t\t  // break regardless!\n\t\t}\n\t}\n\n\tfclose(fp);\n\tfree(file);\n\tEUID_USER();\t\t\t\t  // grsecurity fix\n\n\tif (rv == 0) {\n\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\texit(1);\n\t}\n\treturn rv;\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nuid_t pid_get_uid(pid_t pid) {\n\tEUID_ASSERT();\n\tuid_t rv = 0;\n\n\t// open status file\n\tchar *file;\n\tif (asprintf(&file, \"/proc/%u/status\", pid) == -1) {\n\t\tperror(\"asprintf\");\n\t\texit(1);\n\t}\n\tEUID_ROOT();\t\t\t\t  // grsecurity fix\n\tFILE *fp = fopen(file, \"r\");\n\tif (!fp) {\n\t\tfree(file);\n\t\tfprintf(stderr, \"Error: cannot open /proc file\\n\");\n\t\texit(1);\n\t}\n\n\t// extract uid\n\tstatic const int PIDS_BUFLEN = 1024;\n\tchar buf[PIDS_BUFLEN];\n\twhile (fgets(buf, PIDS_BUFLEN - 1, fp)) {\n\t\tif (strncmp(buf, \"Uid:\", 4) == 0) {\n\t\t\tchar *ptr = buf + 5;\n\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\tptr++;\n\t\t\t}\n\t\t\tif (*ptr == '\\0')\n\t\t\t\tbreak;\n\n\t\t\trv = atoi(ptr);\n\t\t\tbreak;\t\t\t  // break regardless!\n\t\t}\n\t}\n\n\tfclose(fp);\n\tfree(file);\n\tEUID_USER();\t\t\t\t  // grsecurity fix\n\n\tif (rv == 0) {\n\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\texit(1);\n\t}\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "comm"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_child",
          "args": [
            "pid",
            "&child"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "find_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/util.c",
          "lines": "395-454",
          "snippet": "int find_child(pid_t parent, pid_t *child) {\n\tEUID_ASSERT();\n\t*child = 0;\t\t\t\t  // use it to flag a found child\n\n\tDIR *dir;\n\tEUID_ROOT();\t\t\t\t  // grsecurity fix\n\tif (!(dir = opendir(\"/proc\"))) {\n\t\t// sleep 2 seconds and try again\n\t\tsleep(2);\n\t\tif (!(dir = opendir(\"/proc\"))) {\n\t\t\tfprintf(stderr, \"Error: cannot open /proc directory\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tstruct dirent *entry;\n\tchar *end;\n\twhile (*child == 0 && (entry = readdir(dir))) {\n\t\tpid_t pid = strtol(entry->d_name, &end, 10);\n\t\tif (end == entry->d_name || *end)\n\t\t\tcontinue;\n\t\tif (pid == parent)\n\t\t\tcontinue;\n\n\t\t// open stat file\n\t\tchar *file;\n\t\tif (asprintf(&file, \"/proc/%u/status\", pid) == -1) {\n\t\t\tperror(\"asprintf\");\n\t\t\texit(1);\n\t\t}\n\t\tFILE *fp = fopen(file, \"r\");\n\t\tif (!fp) {\n\t\t\tfree(file);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// look for firejail executable name\n\t\tchar buf[BUFLEN];\n\t\twhile (fgets(buf, BUFLEN - 1, fp)) {\n\t\t\tif (strncmp(buf, \"PPid:\", 5) == 0) {\n\t\t\t\tchar *ptr = buf + 5;\n\t\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\tif (*ptr == '\\0') {\n\t\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tif (parent == atoi(ptr))\n\t\t\t\t\t*child = pid;\n\t\t\t\tbreak;\t\t  // stop reading the file\n\t\t\t}\n\t\t}\n\t\tfclose(fp);\n\t\tfree(file);\n\t}\n\tclosedir(dir);\n\tEUID_USER();\n\treturn (*child)? 0:1;\t\t\t  // 0 = found, 1 = not found\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define BUFLEN 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\n#define BUFLEN 4096\n\nint find_child(pid_t parent, pid_t *child) {\n\tEUID_ASSERT();\n\t*child = 0;\t\t\t\t  // use it to flag a found child\n\n\tDIR *dir;\n\tEUID_ROOT();\t\t\t\t  // grsecurity fix\n\tif (!(dir = opendir(\"/proc\"))) {\n\t\t// sleep 2 seconds and try again\n\t\tsleep(2);\n\t\tif (!(dir = opendir(\"/proc\"))) {\n\t\t\tfprintf(stderr, \"Error: cannot open /proc directory\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tstruct dirent *entry;\n\tchar *end;\n\twhile (*child == 0 && (entry = readdir(dir))) {\n\t\tpid_t pid = strtol(entry->d_name, &end, 10);\n\t\tif (end == entry->d_name || *end)\n\t\t\tcontinue;\n\t\tif (pid == parent)\n\t\t\tcontinue;\n\n\t\t// open stat file\n\t\tchar *file;\n\t\tif (asprintf(&file, \"/proc/%u/status\", pid) == -1) {\n\t\t\tperror(\"asprintf\");\n\t\t\texit(1);\n\t\t}\n\t\tFILE *fp = fopen(file, \"r\");\n\t\tif (!fp) {\n\t\t\tfree(file);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// look for firejail executable name\n\t\tchar buf[BUFLEN];\n\t\twhile (fgets(buf, BUFLEN - 1, fp)) {\n\t\t\tif (strncmp(buf, \"PPid:\", 5) == 0) {\n\t\t\t\tchar *ptr = buf + 5;\n\t\t\t\twhile (*ptr != '\\0' && (*ptr == ' ' || *ptr == '\\t')) {\n\t\t\t\t\tptr++;\n\t\t\t\t}\n\t\t\t\tif (*ptr == '\\0') {\n\t\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tif (parent == atoi(ptr))\n\t\t\t\t\t*child = pid;\n\t\t\t\tbreak;\t\t  // stop reading the file\n\t\t\t}\n\t\t}\n\t\tfclose(fp);\n\t\tfree(file);\n\t}\n\tclosedir(dir);\n\tEUID_USER();\n\treturn (*child)? 0:1;\t\t\t  // 0 = found, 1 = not found\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "comm",
            "\"firejail\""
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_USER",
          "args": [],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pid_proc_comm",
          "args": [
            "pid"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ROOT",
          "args": [],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/socket.h>\n#include <sys/types.h>\n#include \"seccomp.h\"\n#include \"firejail.h\"\n\nvoid protocol_print_filter(pid_t pid) {\n\tEUID_ASSERT();\n\t\n\t(void) pid;\n#ifdef SYS_socket\n\t// if the pid is that of a firejail  process, use the pid of the first child process\n\tEUID_ROOT();\n\tchar *comm = pid_proc_comm(pid);\n\tEUID_USER();\n\tif (comm) {\n\t\tif (strcmp(comm, \"firejail\") == 0) {\n\t\t\tpid_t child;\n\t\t\tif (find_child(pid, &child) == 0) {\n\t\t\t\tpid = child;\n\t\t\t}\n\t\t}\n\t\tfree(comm);\n\t}\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission denied.\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// find the seccomp filter\n\tEUID_ROOT();\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_PROTOCOL_CFG) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct stat s;\n\tif (stat(fname, &s) == -1) {\n\t\tprintf(\"Cannot access seccomp filter.\\n\");\n\t\texit(1);\n\t}\n\n\t// read and print the filter\n\tprotocol_filter_load(fname);\n\tfree(fname);\n\tif (cfg.protocol)\n\t\tprintf(\"%s\\n\", cfg.protocol);\n\texit(0);\n#else\n        fprintf(stderr, \"Warning: --protocol not supported on this platform\\n\");\n        return;\n#endif  \n}"
  },
  {
    "function_name": "protocol_print_filter_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/protocol.c",
    "lines": "307-327",
    "snippet": "void protocol_print_filter_name(const char *name) {\n\tEUID_ASSERT();\n\t\n\t(void) name;\n#ifdef SYS_socket\n\tif (!name || strlen(name) == 0) {\n\t\tfprintf(stderr, \"Error: invalid sandbox name\\n\");\n\t\texit(1);\n\t}\n\tpid_t pid;\n\tif (name2pid(name, &pid)) {\n\t\tfprintf(stderr, \"Error: cannot find sandbox %s\\n\", name);\n\t\texit(1);\n\t}\n\n\tprotocol_print_filter(pid);\n#else\n\tfprintf(stderr, \"Warning: --protocol not supported on this platform\\n\");\n\treturn;\n#endif\n}",
    "includes": [
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"seccomp.h\"",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: --protocol not supported on this platform\\n\""
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "protocol_print_filter",
          "args": [
            "pid"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "protocol_print_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/protocol.c",
          "lines": "330-381",
          "snippet": "void protocol_print_filter(pid_t pid) {\n\tEUID_ASSERT();\n\t\n\t(void) pid;\n#ifdef SYS_socket\n\t// if the pid is that of a firejail  process, use the pid of the first child process\n\tEUID_ROOT();\n\tchar *comm = pid_proc_comm(pid);\n\tEUID_USER();\n\tif (comm) {\n\t\tif (strcmp(comm, \"firejail\") == 0) {\n\t\t\tpid_t child;\n\t\t\tif (find_child(pid, &child) == 0) {\n\t\t\t\tpid = child;\n\t\t\t}\n\t\t}\n\t\tfree(comm);\n\t}\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission denied.\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// find the seccomp filter\n\tEUID_ROOT();\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_PROTOCOL_CFG) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct stat s;\n\tif (stat(fname, &s) == -1) {\n\t\tprintf(\"Cannot access seccomp filter.\\n\");\n\t\texit(1);\n\t}\n\n\t// read and print the filter\n\tprotocol_filter_load(fname);\n\tfree(fname);\n\tif (cfg.protocol)\n\t\tprintf(\"%s\\n\", cfg.protocol);\n\texit(0);\n#else\n        fprintf(stderr, \"Warning: --protocol not supported on this platform\\n\");\n        return;\n#endif  \n}",
          "includes": [
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"seccomp.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/socket.h>\n#include <sys/types.h>\n#include \"seccomp.h\"\n#include \"firejail.h\"\n\nvoid protocol_print_filter(pid_t pid) {\n\tEUID_ASSERT();\n\t\n\t(void) pid;\n#ifdef SYS_socket\n\t// if the pid is that of a firejail  process, use the pid of the first child process\n\tEUID_ROOT();\n\tchar *comm = pid_proc_comm(pid);\n\tEUID_USER();\n\tif (comm) {\n\t\tif (strcmp(comm, \"firejail\") == 0) {\n\t\t\tpid_t child;\n\t\t\tif (find_child(pid, &child) == 0) {\n\t\t\t\tpid = child;\n\t\t\t}\n\t\t}\n\t\tfree(comm);\n\t}\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission denied.\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// find the seccomp filter\n\tEUID_ROOT();\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_PROTOCOL_CFG) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct stat s;\n\tif (stat(fname, &s) == -1) {\n\t\tprintf(\"Cannot access seccomp filter.\\n\");\n\t\texit(1);\n\t}\n\n\t// read and print the filter\n\tprotocol_filter_load(fname);\n\tfree(fname);\n\tif (cfg.protocol)\n\t\tprintf(\"%s\\n\", cfg.protocol);\n\texit(0);\n#else\n        fprintf(stderr, \"Warning: --protocol not supported on this platform\\n\");\n        return;\n#endif  \n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "myexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/main.c",
          "lines": "137-149",
          "snippet": "static void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}",
          "includes": [
            "#include <sys/times.h>",
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int arg_command = 0;",
            "int arg_quiet = 0;",
            "pid_t sandbox_pid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/times.h>\n#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nint arg_command = 0;\nint arg_quiet = 0;\npid_t sandbox_pid;\n\nstatic void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot find sandbox %s\\n\"",
            "name"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name2pid",
          "args": [
            "name",
            "&pid"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid sandbox name\\n\""
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/socket.h>\n#include <sys/types.h>\n#include \"seccomp.h\"\n#include \"firejail.h\"\n\nvoid protocol_print_filter_name(const char *name) {\n\tEUID_ASSERT();\n\t\n\t(void) name;\n#ifdef SYS_socket\n\tif (!name || strlen(name) == 0) {\n\t\tfprintf(stderr, \"Error: invalid sandbox name\\n\");\n\t\texit(1);\n\t}\n\tpid_t pid;\n\tif (name2pid(name, &pid)) {\n\t\tfprintf(stderr, \"Error: cannot find sandbox %s\\n\", name);\n\t\texit(1);\n\t}\n\n\tprotocol_print_filter(pid);\n#else\n\tfprintf(stderr, \"Warning: --protocol not supported on this platform\\n\");\n\treturn;\n#endif\n}"
  },
  {
    "function_name": "protocol_filter_load",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/protocol.c",
    "lines": "280-303",
    "snippet": "void protocol_filter_load(const char *fname) {\n\tassert(fname);\n\t\n\t// read protocol filter configuration from PROTOCOL_CFG\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp)\n\t\treturn;\n\n\tconst int MAXBUF = 4098;\n\tchar buf[MAXBUF];\n\tif (fgets(buf, MAXBUF, fp) == NULL) {\n\t\t// empty file\n\t\tfclose(fp);\n\t\treturn;\n\t}\n\tfclose(fp);\n\t\n\tchar *ptr = strchr(buf, '\\n');\n\tif (ptr)\n\t\t*ptr = '\\0';\n\tcfg.protocol = strdup(buf);\n\tif (!cfg.protocol)\n\t\terrExit(\"strdup\");\n}",
    "includes": [
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"seccomp.h\"",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"strdup\""
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "buf"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "buf",
            "'\\n'"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buf",
            "MAXBUF",
            "fp"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "fname",
            "\"r\""
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "fname"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/socket.h>\n#include <sys/types.h>\n#include \"seccomp.h\"\n#include \"firejail.h\"\n\nvoid protocol_filter_load(const char *fname) {\n\tassert(fname);\n\t\n\t// read protocol filter configuration from PROTOCOL_CFG\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp)\n\t\treturn;\n\n\tconst int MAXBUF = 4098;\n\tchar buf[MAXBUF];\n\tif (fgets(buf, MAXBUF, fp) == NULL) {\n\t\t// empty file\n\t\tfclose(fp);\n\t\treturn;\n\t}\n\tfclose(fp);\n\t\n\tchar *ptr = strchr(buf, '\\n');\n\tif (ptr)\n\t\t*ptr = '\\0';\n\tcfg.protocol = strdup(buf);\n\tif (!cfg.protocol)\n\t\terrExit(\"strdup\");\n}"
  },
  {
    "function_name": "protocol_filter_save",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/protocol.c",
    "lines": "268-278",
    "snippet": "void protocol_filter_save(void) {\n\t// save protocol filter configuration in PROTOCOL_CFG\n\tfs_build_mnt_dir();\n\n\tFILE *fp = fopen(RUN_PROTOCOL_CFG, \"w\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\tfprintf(fp, \"%s\\n\", cfg.protocol);\n\tSET_PERMS_STREAM(fp, 0, 0, 0600);\n\tfclose(fp);\n}",
    "includes": [
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"seccomp.h\"",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_PERMS_STREAM",
          "args": [
            "fp",
            "0",
            "0",
            "0600"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"%s\\n\"",
            "cfg.protocol"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fopen\""
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "RUN_PROTOCOL_CFG",
            "\"w\""
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_build_mnt_dir",
          "args": [],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "fs_build_mnt_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
          "lines": "126-145",
          "snippet": "void fs_build_mnt_dir(void) {\n\tstruct stat s;\n\tfs_build_firejail_dir();\n\t\n\t// create /run/firejail/mnt directory\n\tif (stat(RUN_MNT_DIR, &s)) {\n\t\tcreate_dir_as_root(RUN_MNT_DIR, 0755);\n\t}\n\n\t// ... and mount tmpfs on top of it\n\tif (!tmpfs_mounted) {\n\t\t// mount tmpfs on top of /run/firejail/mnt\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on %s directory\\n\", RUN_MNT_DIR);\n\t\tif (mount(\"tmpfs\", RUN_MNT_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /run/firejail/mnt\");\n\t\ttmpfs_mounted = 1;\n\t\tfs_logger2(\"tmpfs\", RUN_MNT_DIR);\n\t}\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int tmpfs_mounted = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic int tmpfs_mounted = 0;\n\nvoid fs_build_mnt_dir(void) {\n\tstruct stat s;\n\tfs_build_firejail_dir();\n\t\n\t// create /run/firejail/mnt directory\n\tif (stat(RUN_MNT_DIR, &s)) {\n\t\tcreate_dir_as_root(RUN_MNT_DIR, 0755);\n\t}\n\n\t// ... and mount tmpfs on top of it\n\tif (!tmpfs_mounted) {\n\t\t// mount tmpfs on top of /run/firejail/mnt\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on %s directory\\n\", RUN_MNT_DIR);\n\t\tif (mount(\"tmpfs\", RUN_MNT_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /run/firejail/mnt\");\n\t\ttmpfs_mounted = 1;\n\t\tfs_logger2(\"tmpfs\", RUN_MNT_DIR);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/socket.h>\n#include <sys/types.h>\n#include \"seccomp.h\"\n#include \"firejail.h\"\n\nvoid protocol_filter_save(void) {\n\t// save protocol filter configuration in PROTOCOL_CFG\n\tfs_build_mnt_dir();\n\n\tFILE *fp = fopen(RUN_PROTOCOL_CFG, \"w\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\tfprintf(fp, \"%s\\n\", cfg.protocol);\n\tSET_PERMS_STREAM(fp, 0, 0, 0600);\n\tfclose(fp);\n}"
  },
  {
    "function_name": "protocol_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/protocol.c",
    "lines": "159-266",
    "snippet": "void protocol_filter(void) {\n\tassert(cfg.protocol);\n\tif (arg_debug)\n\t\tprintf(\"Set protocol filter: %s\\n\", cfg.protocol);\n\n#ifndef SYS_socket\n\t(void) find_protocol_domain;\n        fprintf(stderr, \"Warning: --protocol not supported on this platform\\n\");\n        return;\n#else\n\t// build the filter\n\tstruct sock_filter filter[32];\t// big enough\n\tmemset(&filter[0], 0, sizeof(filter));\n\tuint8_t *ptr = (uint8_t *) &filter[0];\n\t\n\t// header\n\tstruct sock_filter filter_start[] = {\n\t\tVALIDATE_ARCHITECTURE,\n\t\tEXAMINE_SYSCALL,\n\t\tONLY(SYS_socket),\n\t\tEXAMINE_ARGUMENT(0)\n\t};\n\tmemcpy(ptr, &filter_start[0], sizeof(filter_start));\n\tptr += sizeof(filter_start);\n\n#if 0\nprintf(\"entries %u\\n\", (unsigned) (sizeof(filter_start) / sizeof(struct sock_filter)));\n{\n\tunsigned j;\n\tunsigned char *ptr2 = (unsigned char *) &filter[0];\n\tfor (j = 0; j < sizeof(filter); j++, ptr2++) {\n\t\tif ((j % (sizeof(struct sock_filter))) == 0)\n\t\t\tprintf(\"\\n%u: \", 1 + (unsigned) (j / (sizeof(struct sock_filter))));\n\t\tprintf(\"%02x, \", (*ptr2) & 0xff);\n\t}\n\tprintf(\"\\n\");\n}\nprintf(\"whitelist_len %u, struct sock_filter len %u\\n\", whitelist_len, (unsigned) sizeof(struct sock_filter));\n#endif\n\n\n\t// parse list and add commands\n\tchar *tmplist = strdup(cfg.protocol);\n\tif (!tmplist)\n\t\terrExit(\"strdup\");\n\tchar *token = strtok(tmplist, \",\");\n\tif (!token)\n\t\terrExit(\"strtok\");\n\t\t\n\twhile (token) {\n\t\tstruct sock_filter *domain = find_protocol_domain(token);\n\t\tassert(domain);\n\t\tmemcpy(ptr, domain, whitelist_len * sizeof(struct sock_filter));\n\t\tptr += whitelist_len * sizeof(struct sock_filter);\n\t\ttoken = strtok(NULL, \",\");\n\n#if 0\nprintf(\"entries %u\\n\",  (unsigned) ((uint64_t) ptr - (uint64_t) (filter)) / (unsigned) sizeof(struct sock_filter));\n{\n\tunsigned j;\n\tunsigned char *ptr2 = (unsigned char *) &filter[0];\n\tfor (j = 0; j < sizeof(filter); j++, ptr2++) {\n\t\tif ((j % (sizeof(struct sock_filter))) == 0)\n\t\t\tprintf(\"\\n%u: \", 1 + (unsigned) (j / (sizeof(struct sock_filter))));\n\t\tprintf(\"%02x, \", (*ptr2) & 0xff);\n\t}\n\tprintf(\"\\n\");\n}\n#endif\n\n\n\t}\t\n\tfree(tmplist);\n\n\t// add end of filter\n\tstruct sock_filter filter_end[] = {\n\t\tRETURN_ERRNO(ENOTSUP)\n\t};\n\tmemcpy(ptr, &filter_end[0], sizeof(filter_end));\n\tptr += sizeof(filter_end);\n\n#if 0\nprintf(\"entries %u\\n\",  (unsigned) ((uint64_t) ptr - (uint64_t) (filter)) / (unsigned) sizeof(struct sock_filter));\n{\n\tunsigned j;\n\tunsigned char *ptr2 = (unsigned char *) &filter[0];\n\tfor (j = 0; j < sizeof(filter); j++, ptr2++) {\n\t\tif ((j % (sizeof(struct sock_filter))) == 0)\n\t\t\tprintf(\"\\n%u: \", 1 + (unsigned) (j / (sizeof(struct sock_filter))));\n\t\tprintf(\"%02x, \", (*ptr2) & 0xff);\n\t}\n\tprintf(\"\\n\");\n}\n#endif\t\n\n\t// install filter\n\tunsigned short entries = (unsigned short) ((uintptr_t) ptr - (uintptr_t) (filter)) / (unsigned) sizeof(struct sock_filter);\n\tstruct sock_fprog prog = {\n\t\t.len = entries,\n\t\t.filter = filter,\n\t};\n\n\tif (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog) || prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {\n\t\tfprintf(stderr, \"Warning: seccomp disabled, it requires a Linux kernel version 3.5 or newer.\\n\");\n\t\treturn;\n\t}\n#endif // SYS_socket\t\n}",
    "includes": [
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"seccomp.h\"",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: seccomp disabled, it requires a Linux kernel version 3.5 or newer.\\n\""
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prctl",
          "args": [
            "PR_SET_NO_NEW_PRIVS",
            "1",
            "0",
            "0",
            "0"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prctl",
          "args": [
            "PR_SET_SECCOMP",
            "SECCOMP_MODE_FILTER",
            "&prog"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%02x, \"",
            "(*ptr2) & 0xff"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n%u: \"",
            "1 + (unsigned) (j / (sizeof(struct sock_filter)))"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"entries %u\\n\"",
            "(unsigned) ((uint64_t) ptr - (uint64_t) (filter)) / (unsigned) sizeof(struct sock_filter)"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ptr",
            "&filter_end[0]",
            "sizeof(filter_end)"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RETURN_ERRNO",
          "args": [
            "ENOTSUP"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "tmplist"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%02x, \"",
            "(*ptr2) & 0xff"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n%u: \"",
            "1 + (unsigned) (j / (sizeof(struct sock_filter)))"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"entries %u\\n\"",
            "(unsigned) ((uint64_t) ptr - (uint64_t) (filter)) / (unsigned) sizeof(struct sock_filter)"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\",\""
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ptr",
            "domain",
            "whitelist_len * sizeof(struct sock_filter)"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "domain"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_protocol_domain",
          "args": [
            "token"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "find_protocol_domain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/protocol.c",
          "lines": "91-100",
          "snippet": "static struct sock_filter *find_protocol_domain(const char *p) {\n\tint i = 0;\n\twhile (protocol[i] != NULL) {\n\t\tif (strcmp(protocol[i], p) == 0)\n\t\t\treturn &protocol_filter_command[i * whitelist_len];\n\t\ti++;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"seccomp.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/socket.h>\n#include <sys/types.h>\n#include \"seccomp.h\"\n#include \"firejail.h\"\n\nstatic struct sock_filter *find_protocol_domain(const char *p) {\n\tint i = 0;\n\twhile (protocol[i] != NULL) {\n\t\tif (strcmp(protocol[i], p) == 0)\n\t\t\treturn &protocol_filter_command[i * whitelist_len];\n\t\ti++;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"strtok\""
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "tmplist",
            "\",\""
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"strdup\""
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "cfg.protocol"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"whitelist_len %u, struct sock_filter len %u\\n\"",
            "whitelist_len",
            "(unsigned) sizeof(struct sock_filter)"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%02x, \"",
            "(*ptr2) & 0xff"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n%u: \"",
            "1 + (unsigned) (j / (sizeof(struct sock_filter)))"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"entries %u\\n\"",
            "(unsigned) (sizeof(filter_start) / sizeof(struct sock_filter))"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ptr",
            "&filter_start[0]",
            "sizeof(filter_start)"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXAMINE_ARGUMENT",
          "args": [
            "0"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ONLY",
          "args": [
            "SYS_socket"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&filter[0]",
            "0",
            "sizeof(filter)"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: --protocol not supported on this platform\\n\""
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Set protocol filter: %s\\n\"",
            "cfg.protocol"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "cfg.protocol"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/socket.h>\n#include <sys/types.h>\n#include \"seccomp.h\"\n#include \"firejail.h\"\n\nvoid protocol_filter(void) {\n\tassert(cfg.protocol);\n\tif (arg_debug)\n\t\tprintf(\"Set protocol filter: %s\\n\", cfg.protocol);\n\n#ifndef SYS_socket\n\t(void) find_protocol_domain;\n        fprintf(stderr, \"Warning: --protocol not supported on this platform\\n\");\n        return;\n#else\n\t// build the filter\n\tstruct sock_filter filter[32];\t// big enough\n\tmemset(&filter[0], 0, sizeof(filter));\n\tuint8_t *ptr = (uint8_t *) &filter[0];\n\t\n\t// header\n\tstruct sock_filter filter_start[] = {\n\t\tVALIDATE_ARCHITECTURE,\n\t\tEXAMINE_SYSCALL,\n\t\tONLY(SYS_socket),\n\t\tEXAMINE_ARGUMENT(0)\n\t};\n\tmemcpy(ptr, &filter_start[0], sizeof(filter_start));\n\tptr += sizeof(filter_start);\n\n#if 0\nprintf(\"entries %u\\n\", (unsigned) (sizeof(filter_start) / sizeof(struct sock_filter)));\n{\n\tunsigned j;\n\tunsigned char *ptr2 = (unsigned char *) &filter[0];\n\tfor (j = 0; j < sizeof(filter); j++, ptr2++) {\n\t\tif ((j % (sizeof(struct sock_filter))) == 0)\n\t\t\tprintf(\"\\n%u: \", 1 + (unsigned) (j / (sizeof(struct sock_filter))));\n\t\tprintf(\"%02x, \", (*ptr2) & 0xff);\n\t}\n\tprintf(\"\\n\");\n}\nprintf(\"whitelist_len %u, struct sock_filter len %u\\n\", whitelist_len, (unsigned) sizeof(struct sock_filter));\n#endif\n\n\n\t// parse list and add commands\n\tchar *tmplist = strdup(cfg.protocol);\n\tif (!tmplist)\n\t\terrExit(\"strdup\");\n\tchar *token = strtok(tmplist, \",\");\n\tif (!token)\n\t\terrExit(\"strtok\");\n\t\t\n\twhile (token) {\n\t\tstruct sock_filter *domain = find_protocol_domain(token);\n\t\tassert(domain);\n\t\tmemcpy(ptr, domain, whitelist_len * sizeof(struct sock_filter));\n\t\tptr += whitelist_len * sizeof(struct sock_filter);\n\t\ttoken = strtok(NULL, \",\");\n\n#if 0\nprintf(\"entries %u\\n\",  (unsigned) ((uint64_t) ptr - (uint64_t) (filter)) / (unsigned) sizeof(struct sock_filter));\n{\n\tunsigned j;\n\tunsigned char *ptr2 = (unsigned char *) &filter[0];\n\tfor (j = 0; j < sizeof(filter); j++, ptr2++) {\n\t\tif ((j % (sizeof(struct sock_filter))) == 0)\n\t\t\tprintf(\"\\n%u: \", 1 + (unsigned) (j / (sizeof(struct sock_filter))));\n\t\tprintf(\"%02x, \", (*ptr2) & 0xff);\n\t}\n\tprintf(\"\\n\");\n}\n#endif\n\n\n\t}\t\n\tfree(tmplist);\n\n\t// add end of filter\n\tstruct sock_filter filter_end[] = {\n\t\tRETURN_ERRNO(ENOTSUP)\n\t};\n\tmemcpy(ptr, &filter_end[0], sizeof(filter_end));\n\tptr += sizeof(filter_end);\n\n#if 0\nprintf(\"entries %u\\n\",  (unsigned) ((uint64_t) ptr - (uint64_t) (filter)) / (unsigned) sizeof(struct sock_filter));\n{\n\tunsigned j;\n\tunsigned char *ptr2 = (unsigned char *) &filter[0];\n\tfor (j = 0; j < sizeof(filter); j++, ptr2++) {\n\t\tif ((j % (sizeof(struct sock_filter))) == 0)\n\t\t\tprintf(\"\\n%u: \", 1 + (unsigned) (j / (sizeof(struct sock_filter))));\n\t\tprintf(\"%02x, \", (*ptr2) & 0xff);\n\t}\n\tprintf(\"\\n\");\n}\n#endif\t\n\n\t// install filter\n\tunsigned short entries = (unsigned short) ((uintptr_t) ptr - (uintptr_t) (filter)) / (unsigned) sizeof(struct sock_filter);\n\tstruct sock_fprog prog = {\n\t\t.len = entries,\n\t\t.filter = filter,\n\t};\n\n\tif (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog) || prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {\n\t\tfprintf(stderr, \"Warning: seccomp disabled, it requires a Linux kernel version 3.5 or newer.\\n\");\n\t\treturn;\n\t}\n#endif // SYS_socket\t\n}"
  },
  {
    "function_name": "protocol_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/protocol.c",
    "lines": "121-156",
    "snippet": "void protocol_store(const char *prlist) {\n\tEUID_ASSERT();\n\tassert(prlist);\n\t\n\tif (cfg.protocol && !arg_quiet) {\n\t\tfprintf(stderr, \"Warning: a protocol list is present, the new list \\\"%s\\\" will not be installed\\n\", prlist);\n\t\treturn;\n\t}\n\t\n\t// temporary list\n\tchar *tmplist = strdup(prlist);\n\tif (!tmplist)\n\t\terrExit(\"strdup\");\n\t\n\t// check list\n\tchar *token = strtok(tmplist, \",\");\n\tif (!token)\n\t\tgoto errout;\n\t\t\n\twhile (token) {\n\t\tif (!is_protocol(token))\n\t\t\tgoto errout;\n\t\ttoken = strtok(NULL, \",\");\n\t}\t\n\tfree(tmplist);\n\t\n\t// store list\n\tcfg.protocol = strdup(prlist);\n\tif (!cfg.protocol)\n\t\terrExit(\"strdup\");\n\treturn;\n\t\t\nerrout:\n\tfprintf(stderr, \"Error: invalid protocol list\\n\");\n\texit(1);\n}",
    "includes": [
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"seccomp.h\"",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "myexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/main.c",
          "lines": "137-149",
          "snippet": "static void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}",
          "includes": [
            "#include <sys/times.h>",
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int arg_command = 0;",
            "int arg_quiet = 0;",
            "pid_t sandbox_pid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/times.h>\n#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nint arg_command = 0;\nint arg_quiet = 0;\npid_t sandbox_pid;\n\nstatic void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid protocol list\\n\""
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"strdup\""
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "prlist"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "tmplist"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\",\""
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_protocol",
          "args": [
            "token"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "is_protocol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/protocol.c",
          "lines": "80-89",
          "snippet": "static int is_protocol(const char *p) {\n\tint i = 0;\n\twhile (protocol[i] != NULL) {\n\t\tif (strcmp(protocol[i], p) == 0)\n\t\t\treturn 1;\n\t\ti++;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"seccomp.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/socket.h>\n#include <sys/types.h>\n#include \"seccomp.h\"\n#include \"firejail.h\"\n\nstatic int is_protocol(const char *p) {\n\tint i = 0;\n\twhile (protocol[i] != NULL) {\n\t\tif (strcmp(protocol[i], p) == 0)\n\t\t\treturn 1;\n\t\ti++;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "tmplist",
            "\",\""
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"strdup\""
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "prlist"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: a protocol list is present, the new list \\\"%s\\\" will not be installed\\n\"",
            "prlist"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "prlist"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/socket.h>\n#include <sys/types.h>\n#include \"seccomp.h\"\n#include \"firejail.h\"\n\nvoid protocol_store(const char *prlist) {\n\tEUID_ASSERT();\n\tassert(prlist);\n\t\n\tif (cfg.protocol && !arg_quiet) {\n\t\tfprintf(stderr, \"Warning: a protocol list is present, the new list \\\"%s\\\" will not be installed\\n\", prlist);\n\t\treturn;\n\t}\n\t\n\t// temporary list\n\tchar *tmplist = strdup(prlist);\n\tif (!tmplist)\n\t\terrExit(\"strdup\");\n\t\n\t// check list\n\tchar *token = strtok(tmplist, \",\");\n\tif (!token)\n\t\tgoto errout;\n\t\t\n\twhile (token) {\n\t\tif (!is_protocol(token))\n\t\t\tgoto errout;\n\t\ttoken = strtok(NULL, \",\");\n\t}\t\n\tfree(tmplist);\n\t\n\t// store list\n\tcfg.protocol = strdup(prlist);\n\tif (!cfg.protocol)\n\t\terrExit(\"strdup\");\n\treturn;\n\t\t\nerrout:\n\tfprintf(stderr, \"Error: invalid protocol list\\n\");\n\texit(1);\n}"
  },
  {
    "function_name": "protocol_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/protocol.c",
    "lines": "103-117",
    "snippet": "void protocol_list(void) {\n\tEUID_ASSERT();\n\t\n#ifndef SYS_socket\n\tfprintf(stderr, \"Warning: --protocol not supported on this platform\\n\");\n\treturn;\n#endif\n\n\tint i = 0;\n\twhile (protocol[i] != NULL) {\n\t\tprintf(\"%s, \", protocol[i]);\n\t\ti++;\n\t}\n\tprintf(\"\\n\");\n}",
    "includes": [
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"seccomp.h\"",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s, \"",
            "protocol[i]"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: --protocol not supported on this platform\\n\""
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/socket.h>\n#include <sys/types.h>\n#include \"seccomp.h\"\n#include \"firejail.h\"\n\nvoid protocol_list(void) {\n\tEUID_ASSERT();\n\t\n#ifndef SYS_socket\n\tfprintf(stderr, \"Warning: --protocol not supported on this platform\\n\");\n\treturn;\n#endif\n\n\tint i = 0;\n\twhile (protocol[i] != NULL) {\n\t\tprintf(\"%s, \", protocol[i]);\n\t\ti++;\n\t}\n\tprintf(\"\\n\");\n}"
  },
  {
    "function_name": "find_protocol_domain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/protocol.c",
    "lines": "91-100",
    "snippet": "static struct sock_filter *find_protocol_domain(const char *p) {\n\tint i = 0;\n\twhile (protocol[i] != NULL) {\n\t\tif (strcmp(protocol[i], p) == 0)\n\t\t\treturn &protocol_filter_command[i * whitelist_len];\n\t\ti++;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"seccomp.h\"",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "protocol[i]",
            "p"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/socket.h>\n#include <sys/types.h>\n#include \"seccomp.h\"\n#include \"firejail.h\"\n\nstatic struct sock_filter *find_protocol_domain(const char *p) {\n\tint i = 0;\n\twhile (protocol[i] != NULL) {\n\t\tif (strcmp(protocol[i], p) == 0)\n\t\t\treturn &protocol_filter_command[i * whitelist_len];\n\t\ti++;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "is_protocol",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/protocol.c",
    "lines": "80-89",
    "snippet": "static int is_protocol(const char *p) {\n\tint i = 0;\n\twhile (protocol[i] != NULL) {\n\t\tif (strcmp(protocol[i], p) == 0)\n\t\t\treturn 1;\n\t\ti++;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include \"seccomp.h\"",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "protocol[i]",
            "p"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/socket.h>\n#include <sys/types.h>\n#include \"seccomp.h\"\n#include \"firejail.h\"\n\nstatic int is_protocol(const char *p) {\n\tint i = 0;\n\twhile (protocol[i] != NULL) {\n\t\tif (strcmp(protocol[i], p) == 0)\n\t\t\treturn 1;\n\t\ti++;\n\t}\n\n\treturn 0;\n}"
  }
]