[
  {
    "function_name": "profile_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/profile.c",
    "lines": "942-1030",
    "snippet": "void profile_read(const char *fname) {\n\tEUID_ASSERT();\n\t\n\t// exit program if maximum include level was reached\n\tif (include_level > MAX_INCLUDE_LEVEL) {\n\t\tfprintf(stderr, \"Error: maximum profile include level was reached\\n\");\n\t\texit(1);\t\n\t}\n\n\tif (strlen(fname) == 0) {\n\t\tfprintf(stderr, \"Error: invalid profile file\\n\");\n\t\texit(1);\n\t}\n\n\t// allow debuggers\n\tif (arg_allow_debuggers) {\n\t\tchar *tmp = strrchr(fname, '/');\n\t\tif (tmp && *(tmp + 1) != '\\0') {\n\t\t\ttmp++;\n\t\t\tif (strcmp(tmp, \"disable-devel.inc\") == 0)\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\t// open profile file:\n\tFILE *fp = fopen(fname, \"r\");\n\tif (fp == NULL) {\n\t\tfprintf(stderr, \"Error: cannot open profile file %s\\n\", fname);\n\t\texit(1);\n\t}\n\n\tint msg_printed = 0;\n\n\t// read the file line by line\n\tchar buf[MAX_READ + 1];\n\tint lineno = 0;\n\twhile (fgets(buf, MAX_READ, fp)) {\n\t\t++lineno;\n\t\t// remove empty space - ptr in allocated memory\n\t\tchar *ptr = line_remove_spaces(buf);\n\t\tif (ptr == NULL)\n\t\t\tcontinue;\n\t\t\n\t\t// comments\n\t\tif (*ptr == '#' || *ptr == '\\0') {\n\t\t\tfree(ptr);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t// process quiet\n\t\tif (strcmp(ptr, \"quiet\") == 0) {\n\t\t\targ_quiet = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!msg_printed) {\n\t\t\tif (!arg_quiet)\n\t\t\t\tfprintf(stderr, \"Reading profile %s\\n\", fname);\n\t\t\tmsg_printed = 1;\n\t\t}\n\n\t\t// process include\n\t\tif (strncmp(ptr, \"include \", 8) == 0) {\n\t\t\tinclude_level++;\n\t\t\t\n\t\t\t// extract profile filename and new skip params\n\t\t\tchar *newprofile = ptr + 8; // profile name\n\t\t\t\n\t\t\t// expand ${HOME}/ in front of the new profile file\n\t\t\tchar *newprofile2 = expand_home(newprofile, cfg.homedir);\n\t\t\t\n\t\t\t// recursivity\n\t\t\tprofile_read((newprofile2)? newprofile2:newprofile);\n\t\t\tinclude_level--;\n\t\t\tif (newprofile2)\n\t\t\t\tfree(newprofile2);\n\t\t\tfree(ptr);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t// verify syntax, exit in case of error\n\t\tif (profile_check_line(ptr, lineno, fname))\n\t\t\tprofile_add(ptr);\n// we cannot free ptr here, data is extracted from ptr and linked as a pointer in cfg structure\n//\t\telse {\n//\t\t\tfree(ptr);\n//\t\t}\n\t}\n\tfclose(fp);\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <dirent.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [
      "#define MAX_READ 8192\t\t\t\t  // line buffer for profile files"
    ],
    "globals_used": [
      "static int include_level = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "profile_add",
          "args": [
            "ptr"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "profile_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/profile.c",
          "lines": "919-938",
          "snippet": "void profile_add(char *str) {\n\tEUID_ASSERT();\n\t\n\tProfileEntry *prf = malloc(sizeof(ProfileEntry));\n\tif (!prf)\n\t\terrExit(\"malloc\");\n\tmemset(prf, 0, sizeof(ProfileEntry));\n\tprf->next = NULL;\n\tprf->data = str;\t\n\n\t// add prf to the list\n\tif (cfg.profile == NULL) {\n\t\tcfg.profile = prf;\n\t\treturn;\n\t}\n\tProfileEntry *ptr = cfg.profile;\n\twhile (ptr->next != NULL)\n\t\tptr = ptr->next;\n\tptr->next = prf;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <dirent.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <dirent.h>\n#include \"firejail.h\"\n\nvoid profile_add(char *str) {\n\tEUID_ASSERT();\n\t\n\tProfileEntry *prf = malloc(sizeof(ProfileEntry));\n\tif (!prf)\n\t\terrExit(\"malloc\");\n\tmemset(prf, 0, sizeof(ProfileEntry));\n\tprf->next = NULL;\n\tprf->data = str;\t\n\n\t// add prf to the list\n\tif (cfg.profile == NULL) {\n\t\tcfg.profile = prf;\n\t\treturn;\n\t}\n\tProfileEntry *ptr = cfg.profile;\n\twhile (ptr->next != NULL)\n\t\tptr = ptr->next;\n\tptr->next = prf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "profile_check_line",
          "args": [
            "ptr",
            "lineno",
            "fname"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "profile_check_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/profile.c",
          "lines": "69-916",
          "snippet": "int profile_check_line(char *ptr, int lineno, const char *fname) {\n\tEUID_ASSERT();\n\t\n\t// check ignore list\n\tint i;\n\tfor (i = 0; i < MAX_PROFILE_IGNORE; i++) {\n\t\tif (cfg.profile_ignore[i] == NULL)\n\t\t\tbreak;\n\t\t\n\t\tif (strncmp(ptr, cfg.profile_ignore[i], strlen(cfg.profile_ignore[i])) == 0)\n\t\t\treturn 0;\t// ignore line\n\t}\n\t\n\tif (strncmp(ptr, \"ignore \", 7) == 0) {\n\t\tchar *str = strdup(ptr + 7);\n\t\tif (*str == '\\0') {\n\t\t\tfprintf(stderr, \"Error: invalid ignore option\\n\");\n\t\t\texit(1);\n\t\t}\n\t\t// find an empty entry in profile_ignore array\n\t\tint j;\n\t\tfor (j = 0; j < MAX_PROFILE_IGNORE; j++) {\n\t\t\tif (cfg.profile_ignore[j] == NULL) \n\t\t\t\tbreak;\n\t\t}\n\t\tif (j >= MAX_PROFILE_IGNORE) {\n\t\t\tfprintf(stderr, \"Error: maximum %d --ignore options are permitted\\n\", MAX_PROFILE_IGNORE);\n\t\t\texit(1);\n\t\t}\n\t\t// ... and configure it\n\t\telse \n\t\t\tcfg.profile_ignore[j] = str;\n\n\t\treturn 0;\n\t}\n\n\t// mkdir \n\tif (strncmp(ptr, \"mkdir \", 6) == 0) {\n\t\tfs_mkdir(ptr + 6);\n\t\treturn 1;\n\t}\n\t// mkfile \n\tif (strncmp(ptr, \"mkfile \", 7) == 0) {\n\t\tfs_mkfile(ptr + 7);\n\t\treturn 1;\n\t}\n\t// sandbox name\n\telse if (strncmp(ptr, \"name \", 5) == 0) {\n\t\tcfg.name = ptr + 5;\n\t\tif (strlen(cfg.name) == 0) {\n\t\t\tfprintf(stderr, \"Error: invalid sandbox name\\n\");\n\t\t\texit(1);\n\t\t}\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"ipc-namespace\") == 0) {\n\t\targ_ipc = 1;\n\t\treturn 0;\n\t}\n\t// seccomp, caps, private, user namespace\n\telse if (strcmp(ptr, \"noroot\") == 0) {\n#if HAVE_USERNS\n\t\tif (checkcfg(CFG_USERNS))\n\t\t\tcheck_user_namespace();\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: user namespace feature is disabled in Firejail configuration file\\n\");\n#endif\n\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nonewprivs\") == 0) {\n\t\targ_nonewprivs = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"seccomp\") == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP))\n\t\t\targ_seccomp = 1;\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: user seccomp feature is disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"caps\") == 0) {\n\t\targ_caps_default_filter = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"caps.drop all\") == 0) {\n\t\targ_caps_drop_all = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"shell none\") == 0) {\n\t\targ_shell_none = 1;\n\t\treturn 0;\n\t}\t\n\telse if (strcmp(ptr, \"tracelog\") == 0) {\n\t\targ_tracelog = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"private\") == 0) {\n\t\targ_private = 1;\n\t\treturn 0;\n\t}\n\tif (strncmp(ptr, \"private-home \", 13) == 0) {\n#ifdef HAVE_PRIVATE_HOME\n\t\tif (checkcfg(CFG_PRIVATE_HOME)) {\n\t\t\tcfg.home_private_keep = ptr + 13;\n\t\t\tfs_check_home_list();\n\t\t\targ_private = 1;\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: private-home is disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"allusers\") == 0) {\n\t\targ_allusers = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"private-dev\") == 0) {\n\t\targ_private_dev = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"private-tmp\") == 0) {\n\t\targ_private_tmp = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nogroups\") == 0) {\n\t\targ_nogroups = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nosound\") == 0) {\n\t\targ_nosound = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"no3d\") == 0) {\n\t\targ_no3d = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"netfilter\") == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK))\n\t\t\targ_netfilter = 1;\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strncmp(ptr, \"netfilter \", 10) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\targ_netfilter = 1;\n\t\t\targ_netfilter_file = strdup(ptr + 10);\n\t\t\tif (!arg_netfilter_file)\n\t\t\t\terrExit(\"strdup\");\n\t\t\tcheck_netfilter_file(arg_netfilter_file);\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strncmp(ptr, \"netfilter6 \", 11) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\targ_netfilter6 = 1;\n\t\t\targ_netfilter6_file = strdup(ptr + 11);\n\t\t\tif (!arg_netfilter6_file)\n\t\t\t\terrExit(\"strdup\");\n\t\t\tcheck_netfilter_file(arg_netfilter6_file);\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"net none\") == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\targ_nonetwork  = 1;\n\t\t\tcfg.bridge0.configured = 0;\n\t\t\tcfg.bridge1.configured = 0;\n\t\t\tcfg.bridge2.configured = 0;\n\t\t\tcfg.bridge3.configured = 0;\n\t\t\tcfg.interface0.configured = 0;\n\t\t\tcfg.interface1.configured = 0;\n\t\t\tcfg.interface2.configured = 0;\n\t\t\tcfg.interface3.configured = 0;\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strncmp(ptr, \"net \", 4) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n#ifdef HAVE_NETWORK_RESTRICTED\n\t\t\t// compile time restricted networking\n\t\t\tif (getuid() != 0) {\n\t\t\t\tfprintf(stderr, \"Error: only \\\"net none\\\" is allowed to non-root users\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n#endif\n\t\t\t// run time restricted networking\n\t\t\tif (checkcfg(CFG_RESTRICTED_NETWORK) && getuid() != 0) {\n\t\t\t\tfprintf(stderr, \"Error: only \\\"net none\\\" is allowed to non-root users\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t\n\t\t\tif (strcmp(ptr + 4, \"lo\") == 0) {\n\t\t\t\tfprintf(stderr, \"Error: cannot attach to lo device\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tBridge *br;\n\t\t\tif (cfg.bridge0.configured == 0)\n\t\t\t\tbr = &cfg.bridge0;\n\t\t\telse if (cfg.bridge1.configured == 0)\n\t\t\t\tbr = &cfg.bridge1;\n\t\t\telse if (cfg.bridge2.configured == 0)\n\t\t\t\tbr = &cfg.bridge2;\n\t\t\telse if (cfg.bridge3.configured == 0)\n\t\t\t\tbr = &cfg.bridge3;\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"Error: maximum 4 network devices are allowed\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tnet_configure_bridge(br, ptr + 4);\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\t\n\telse if (strncmp(ptr, \"veth-name \", 10) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tbr->veth_name = strdup(ptr + 10);\n\t\t\tif (br->veth_name == NULL)\n\t\t\t\terrExit(\"strdup\");\n\t\t\tif (*br->veth_name == '\\0') {\n\t\t\t\tfprintf(stderr, \"Error: no veth-name configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"iprange \", 8) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (br->iprange_start || br->iprange_end) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the IP range twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// parse option arguments\n\t\t\tchar *firstip = ptr + 8;\n\t\t\tchar *secondip = firstip;\n\t\t\twhile (*secondip != '\\0') {\n\t\t\t\tif (*secondip == ',')\n\t\t\t\t\tbreak;\n\t\t\t\tsecondip++;\n\t\t\t}\n\t\t\tif (*secondip == '\\0') {\n\t\t\t\tfprintf(stderr, \"Error: invalid IP range\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t*secondip = '\\0';\n\t\t\tsecondip++;\n\t\t\t\n\t\t\t// check addresses\n\t\t\tif (atoip(firstip, &br->iprange_start) || atoip(secondip, &br->iprange_end) ||\n\t\t\t    br->iprange_start >= br->iprange_end) {\n\t\t\t\tfprintf(stderr, \"Error: invalid IP range\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (in_netrange(br->iprange_start, br->ip, br->mask) || in_netrange(br->iprange_end, br->ip, br->mask)) {\n\t\t\t\tfprintf(stderr, \"Error: IP range addresses not in network range\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\n\n\telse if (strncmp(ptr, \"mac \", 4) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t\n\t\t\tif (mac_not_zero(br->macsandbox)) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the MAC address twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// read the address\n\t\t\tif (atomac(ptr + 4, br->macsandbox)) {\n\t\t\t\tfprintf(stderr, \"Error: invalid MAC address\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"mtu \", 4) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t\n\t\t\tif (sscanf(ptr + 4, \"%d\", &br->mtu) != 1 || br->mtu < 576 || br->mtu > 9198) {\n\t\t\t\tfprintf(stderr, \"Error: invalid mtu value\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"ip \", 3) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (br->arg_ip_none || br->ipsandbox) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the IP address twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// configure this IP address for the last bridge defined\n\t\t\tif (strcmp(ptr + 3, \"none\") == 0)\n\t\t\t\tbr->arg_ip_none = 1;\n\t\t\telse {\n\t\t\t\tif (atoip(ptr + 3, &br->ipsandbox)) {\n\t\t\t\t\tfprintf(stderr, \"Error: invalid IP address\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"ip6 \", 4) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (br->arg_ip_none || br->ip6sandbox) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the IP address twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// configure this IP address for the last bridge defined\n\t\t\t// todo: verify ipv6 syntax\n\t\t\tbr->ip6sandbox = ptr + 4;\n//\t\t\tif (atoip(argv[i] + 5, &br->ipsandbox)) {\n//\t\t\t\tfprintf(stderr, \"Error: invalid IP address\\n\");\n//\t\t\t\texit(1);\n//\t\t\t}\n\t\t\t\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"defaultgw \", 10) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tif (atoip(ptr + 10, &cfg.defaultgw)) {\n\t\t\t\tfprintf(stderr, \"Error: invalid IP address\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"apparmor\") == 0) {\n#ifdef HAVE_APPARMOR\t\t\n\t\targ_apparmor = 1;\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strncmp(ptr, \"protocol \", 9) == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP))\n\t\t\tprotocol_store(ptr + 9);\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: user seccomp feature is disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\t\n\tif (strncmp(ptr, \"env \", 4) == 0) {\n\t\tenv_store(ptr + 4, SETENV);\n\t\treturn 0;\n\t}\n\tif (strncmp(ptr, \"rmenv \", 6) == 0) {\n\t\tenv_store(ptr + 6, RMENV);\n\t\treturn 0;\n\t}\n\t\n\t// seccomp drop list on top of default list\n\tif (strncmp(ptr, \"seccomp \", 8) == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\targ_seccomp = 1;\n\t\t\tcfg.seccomp_list = strdup(ptr + 8);\n\t\t\tif (!cfg.seccomp_list)\n\t\t\t\terrExit(\"strdup\");\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: user seccomp feature is disabled in Firejail configuration file\\n\");\n#endif\n\n\t\treturn 0;\n\t}\n\t\n\t// seccomp drop list without default list\n\tif (strncmp(ptr, \"seccomp.drop \", 13) == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\targ_seccomp = 1;\n\t\t\tcfg.seccomp_list_drop = strdup(ptr + 13);\n\t\t\tif (!cfg.seccomp_list_drop)\n\t\t\t\terrExit(\"strdup\");\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: user seccomp feature is disabled in Firejail configuration file\\n\");\n#endif\t\t\n\t\treturn 0;\n\t}\n\n\t// seccomp keep list\n\tif (strncmp(ptr, \"seccomp.keep \", 13) == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\targ_seccomp = 1;\n\t\t\tcfg.seccomp_list_keep= strdup(ptr + 13);\n\t\t\tif (!cfg.seccomp_list_keep)\n\t\t\t\terrExit(\"strdup\");\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: user seccomp feature is disabled in Firejail configuration file\\n\");\n#endif\t\t\n\t\treturn 0;\n\t}\n\t\n\t// caps drop list\n\tif (strncmp(ptr, \"caps.drop \", 10) == 0) {\n\t\targ_caps_drop = 1;\n\t\targ_caps_list = strdup(ptr + 10);\n\t\tif (!arg_caps_list)\n\t\t\terrExit(\"strdup\");\n\t\t// verify seccomp list and exit if problems\n\t\tif (caps_check_list(arg_caps_list, NULL))\n\t\t\texit(1);\n\t\treturn 0;\n\t}\n\t\n\t// caps keep list\n\tif (strncmp(ptr, \"caps.keep \", 10) == 0) {\n\t\targ_caps_keep = 1;\n\t\targ_caps_list = strdup(ptr + 10);\n\t\tif (!arg_caps_list)\n\t\t\terrExit(\"strdup\");\n\t\t// verify seccomp list and exit if problems\n\t\tif (caps_check_list(arg_caps_list, NULL))\n\t\t\texit(1);\n\t\treturn 0;\n\t}\n\n\t// hostname\n\tif (strncmp(ptr, \"hostname \", 9) == 0) {\n\t\tcfg.hostname = ptr + 9;\n\t\treturn 0;\n\t}\n\t\n\t// dns\n\tif (strncmp(ptr, \"dns \", 4) == 0) {\n\t\tuint32_t dns;\n\t\tif (atoip(ptr + 4, &dns)) {\n\t\t\tfprintf(stderr, \"Error: invalid DNS server IP address\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\t\n\t\tif (cfg.dns1 == 0)\n\t\t\tcfg.dns1 = dns;\n\t\telse if (cfg.dns2 == 0)\n\t\t\tcfg.dns2 = dns;\n\t\telse if (cfg.dns3 == 0)\n\t\t\tcfg.dns3 = dns;\n\t\telse {\n\t\t\tfprintf(stderr, \"Error: up to 3 DNS servers can be specified\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\t// cpu affinity\n\tif (strncmp(ptr, \"cpu \", 4) == 0) {\n\t\tread_cpu_list(ptr + 4);\n\t\treturn 0;\n\t}\n\t\n\t// nice value\n\tif (strncmp(ptr, \"nice \", 4) == 0) {\n\t\tcfg.nice = atoi(ptr + 5);\n\t\tif (getuid() != 0 &&cfg.nice < 0)\n\t\t\tcfg.nice = 0;\n\t\targ_nice = 1;\n\t\treturn 0;\n\t}\n\n\t// cgroup\n\tif (strncmp(ptr, \"cgroup \", 7) == 0) {\n\t\tset_cgroup(ptr + 7);\n\t\treturn 0;\n\t}\n\t\n\t// writable-etc\n\tif (strcmp(ptr, \"writable-etc\") == 0) {\n\t\tif (cfg.etc_private_keep) {\n\t\t\tfprintf(stderr, \"Error: private-etc and writable-etc are mutually exclusive\\n\");\n\t\t\texit(1);\n\t\t}\n\t\targ_writable_etc = 1;\n\t\treturn 0;\n\t}\n\t\n\t// writable-var\n\tif (strcmp(ptr, \"writable-var\") == 0) {\n\t\targ_writable_var = 1;\n\t\treturn 0;\n\t}\n\t\n\t// private directory\n\tif (strncmp(ptr, \"private \", 8) == 0) {\n\t\tcfg.home_private = ptr + 8;\n\t\tfs_check_private_dir();\n\t\targ_private = 1;\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 none\") == 0) {\n\t\targ_x11_block = 1;\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 xephyr\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\tchar *x11env = getenv(\"FIREJAIL_X11\");\n\t\t\tif (x11env && strcmp(x11env, \"yes\") == 0) {\n\t\t\t\tmask_x11_abstract_socket = 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// start x11\n\t\t\t\tx11_start_xephyr(cfg.original_argc, cfg.original_argv);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 xorg\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11))\n\t\t\targ_x11_xorg = 1;\n\t\telse {\n\t\t\tfprintf(stderr, \"Error: --x11 feature is disabled in Firejail configuration file\\n\");\n\t\t\treturn 0;\n\t\t}\n#endif\n\t\treturn 0;\n\t}\n\tif (strcmp(ptr, \"x11 xpra\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\tchar *x11env = getenv(\"FIREJAIL_X11\");\n\t\t\tif (x11env && strcmp(x11env, \"yes\") == 0) {\n\t\t\t\tmask_x11_abstract_socket = 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// start x11\n\t\t\t\tx11_start_xpra(cfg.original_argc, cfg.original_argv);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n#endif\n\t\treturn 0;\n\t}\n\t\n\tif (strcmp(ptr, \"x11\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\tchar *x11env = getenv(\"FIREJAIL_X11\");\n\t\t\tif (x11env && strcmp(x11env, \"yes\") == 0) {\n\t\t\t\tmask_x11_abstract_socket = 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// start x11\n\t\t\t\tx11_start(cfg.original_argc, cfg.original_argv);\n\t\t\t\texit(0);\t\t\n\t\t\t}\n\t\t}\n#endif\t\t\n\t\treturn 0;\n\t}\n\t\n\t// private /etc list of files and directories\n\tif (strncmp(ptr, \"private-etc \", 12) == 0) {\n\t\tif (arg_writable_etc) {\n\t\t\tfprintf(stderr, \"Error: --private-etc and --writable-etc are mutually exclusive\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tcfg.etc_private_keep = ptr + 12;\n\t\tfs_check_etc_list();\n\t\targ_private_etc = 1;\n\t\t\n\t\treturn 0;\n\t}\n\n\t// private /bin list of files\n\tif (strncmp(ptr, \"private-bin \", 12) == 0) {\n\t\tcfg.bin_private_keep = ptr + 12;\n\t\targ_private_bin = 1;\n\t\tfs_check_bin_list();\n\t\treturn 0;\n\t}\n\n\t// filesystem bind\n\tif (strncmp(ptr, \"bind \", 5) == 0) {\n#ifdef HAVE_BIND\t\t\n\t\tif (checkcfg(CFG_BIND)) {\n\t\t\tif (getuid() != 0) {\n\t\t\t\tfprintf(stderr, \"Error: --bind option is available only if running as root\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\n\t\t\t// extract two directories\n\t\t\tchar *dname1 = ptr + 5;\n\t\t\tchar *dname2 = split_comma(dname1); // this inserts a '0 to separate the two dierctories\n\t\t\tif (dname2 == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: missing second directory for bind\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t\n\t\t\t// check directories\n\t\t\tinvalid_filename(dname1);\n\t\t\tinvalid_filename(dname2);\n\t\t\tif (strstr(dname1, \"..\") || strstr(dname2, \"..\")) {\n\t\t\t\tfprintf(stderr, \"Error: invalid file name.\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (is_link(dname1) || is_link(dname2)) {\n\t\t\t\tfprintf(stderr, \"Symbolic links are not allowed for bind command\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t\n\t\t\t// insert comma back\n\t\t\t*(dname2 - 1) = ',';\n\t\t\treturn 1;\n\t\t}\n\t\telse if (!arg_quiet) {\n\t\t\tfprintf(stderr, \"Warning: bind feature is disabled in Firejail configuration file\\n\");\n\t\t\treturn 0;\t\t\t\n\t\t}\n#else\n\t\treturn 0;\n#endif\t\t\n\t}\n\n\t// rlimit\n\tif (strncmp(ptr, \"rlimit\", 6) == 0) {\n\t\tif (strncmp(ptr, \"rlimit-nofile \", 14) == 0) {\n\t\t\tptr += 14;\n\t\t\tif (not_unsigned(ptr)) {\n\t\t\t\tfprintf(stderr, \"Invalid rlimit option on line %d\\n\", lineno);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tsscanf(ptr, \"%u\", &cfg.rlimit_nofile);\n\t\t\targ_rlimit_nofile = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-nproc \", 13) == 0) {\n\t\t\tptr += 13;\n\t\t\tif (not_unsigned(ptr)) {\n\t\t\t\tfprintf(stderr, \"Invalid rlimit option on line %d\\n\", lineno);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tsscanf(ptr, \"%u\", &cfg.rlimit_nproc);\n\t\t\targ_rlimit_nproc = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-fsize \", 13) == 0) {\n\t\t\tptr += 13;\n\t\t\tif (not_unsigned(ptr)) {\n\t\t\t\tfprintf(stderr, \"Invalid rlimit option on line %d\\n\", lineno);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tsscanf(ptr, \"%u\", &cfg.rlimit_fsize);\n\t\t\targ_rlimit_fsize = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-sigpending \", 18) == 0) {\n\t\t\tptr += 18;\n\t\t\tif (not_unsigned(ptr)) {\n\t\t\t\tfprintf(stderr, \"Invalid rlimit option on line %d\\n\", lineno);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tsscanf(ptr, \"%u\", &cfg.rlimit_sigpending);\n\t\t\targ_rlimit_sigpending = 1;\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"Invalid rlimit option on line %d\\n\", lineno);\n\t\t\texit(1);\n\t\t}\n\t\t\n\t\treturn 0;\t\t\n\t}\n\n\tif (strncmp(ptr, \"join-or-start \", 14) == 0) {\n\t\t// try to join by name only\n\t\tpid_t pid;\n\t\tif (!name2pid(ptr + 14, &pid)) {\n\t\t\tif (!cfg.shell && !arg_shell_none)\n\t\t\t\tcfg.shell = guess_shell();\n\n\t\t\t// find first non-option arg\n\t\t\tint i;\n\t\t\tfor (i = 1; i < cfg.original_argc && strncmp(cfg.original_argv[i], \"--\", 2) != 0; i++);\n\n\t\t\tjoin(pid, cfg.original_argc,cfg.original_argv, i + 1);\n\t\t\texit(0);\n\t\t}\n\n\t\t// set sandbox name and start normally\n\t\tcfg.name = ptr + 14;\n\t\tif (strlen(cfg.name) == 0) {\n\t\t\tfprintf(stderr, \"Error: invalid sandbox name\\n\");\n\t\t\texit(1);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t// rest of filesystem\n\tif (strncmp(ptr, \"blacklist \", 10) == 0)\n\t\tptr += 10;\n\telse if (strncmp(ptr, \"blacklist-nolog \", 16) == 0)\n\t\tptr += 16;\n\telse if (strncmp(ptr, \"noblacklist \", 12) == 0)\n\t\tptr += 12;\n\telse if (strncmp(ptr, \"whitelist \", 10) == 0) {\n#ifdef HAVE_WHITELIST\t\t\n\t\tif (checkcfg(CFG_WHITELIST)) {\n\t\t\targ_whitelist = 1;\n\t\t\tptr += 10;\n\t\t}\n\t\telse\n\t\t\treturn 0;\n#else\t\t\n\t\treturn 0;\n#endif\n\t}\n\telse if (strncmp(ptr, \"read-only \", 10) == 0)\n\t\tptr += 10;\n\telse if (strncmp(ptr, \"read-write \", 11) == 0)\n\t\tptr += 11;\n\telse if (strncmp(ptr, \"noexec \", 7) == 0)\n\t\tptr += 7;\n\telse if (strncmp(ptr, \"tmpfs \", 6) == 0) {\n\t\tif (getuid() != 0) {\n\t\t\tfprintf(stderr, \"Error: tmpfs available only when running the sandbox as root\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tptr += 6;\n\t}\n\telse {\n\t\tif (lineno == 0)\n\t\t\tfprintf(stderr, \"Error: \\\"%s\\\" as a command line option is invalid\\n\", ptr);\n\t\telse if (fname != NULL)\n\t\t\tfprintf(stderr, \"Error: line %d in %s is invalid\\n\", lineno, fname);\n\t\telse\n\t\t\tfprintf(stderr, \"Error: line %d in the custom profile is invalid\\n\", lineno);\n\t\texit(1);\n\t}\n\n\t// some characters just don't belong in filenames\n\tinvalid_filename(ptr);\n\tif (strstr(ptr, \"..\")) {\n\t\tif (lineno == 0)\n\t\t\tfprintf(stderr, \"Error: \\\"%s\\\" is an invalid filename\\n\", ptr);\n\t\telse if (fname != NULL)\n\t\t\tfprintf(stderr, \"Error: line %d in %s is invalid\\n\", lineno, fname);\n\t\telse\n\t\t\tfprintf(stderr, \"Error: line %d in the custom profile is invalid\\n\", lineno);\n\t\texit(1);\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <dirent.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <dirent.h>\n#include \"firejail.h\"\n\nint profile_check_line(char *ptr, int lineno, const char *fname) {\n\tEUID_ASSERT();\n\t\n\t// check ignore list\n\tint i;\n\tfor (i = 0; i < MAX_PROFILE_IGNORE; i++) {\n\t\tif (cfg.profile_ignore[i] == NULL)\n\t\t\tbreak;\n\t\t\n\t\tif (strncmp(ptr, cfg.profile_ignore[i], strlen(cfg.profile_ignore[i])) == 0)\n\t\t\treturn 0;\t// ignore line\n\t}\n\t\n\tif (strncmp(ptr, \"ignore \", 7) == 0) {\n\t\tchar *str = strdup(ptr + 7);\n\t\tif (*str == '\\0') {\n\t\t\tfprintf(stderr, \"Error: invalid ignore option\\n\");\n\t\t\texit(1);\n\t\t}\n\t\t// find an empty entry in profile_ignore array\n\t\tint j;\n\t\tfor (j = 0; j < MAX_PROFILE_IGNORE; j++) {\n\t\t\tif (cfg.profile_ignore[j] == NULL) \n\t\t\t\tbreak;\n\t\t}\n\t\tif (j >= MAX_PROFILE_IGNORE) {\n\t\t\tfprintf(stderr, \"Error: maximum %d --ignore options are permitted\\n\", MAX_PROFILE_IGNORE);\n\t\t\texit(1);\n\t\t}\n\t\t// ... and configure it\n\t\telse \n\t\t\tcfg.profile_ignore[j] = str;\n\n\t\treturn 0;\n\t}\n\n\t// mkdir \n\tif (strncmp(ptr, \"mkdir \", 6) == 0) {\n\t\tfs_mkdir(ptr + 6);\n\t\treturn 1;\n\t}\n\t// mkfile \n\tif (strncmp(ptr, \"mkfile \", 7) == 0) {\n\t\tfs_mkfile(ptr + 7);\n\t\treturn 1;\n\t}\n\t// sandbox name\n\telse if (strncmp(ptr, \"name \", 5) == 0) {\n\t\tcfg.name = ptr + 5;\n\t\tif (strlen(cfg.name) == 0) {\n\t\t\tfprintf(stderr, \"Error: invalid sandbox name\\n\");\n\t\t\texit(1);\n\t\t}\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"ipc-namespace\") == 0) {\n\t\targ_ipc = 1;\n\t\treturn 0;\n\t}\n\t// seccomp, caps, private, user namespace\n\telse if (strcmp(ptr, \"noroot\") == 0) {\n#if HAVE_USERNS\n\t\tif (checkcfg(CFG_USERNS))\n\t\t\tcheck_user_namespace();\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: user namespace feature is disabled in Firejail configuration file\\n\");\n#endif\n\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nonewprivs\") == 0) {\n\t\targ_nonewprivs = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"seccomp\") == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP))\n\t\t\targ_seccomp = 1;\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: user seccomp feature is disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"caps\") == 0) {\n\t\targ_caps_default_filter = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"caps.drop all\") == 0) {\n\t\targ_caps_drop_all = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"shell none\") == 0) {\n\t\targ_shell_none = 1;\n\t\treturn 0;\n\t}\t\n\telse if (strcmp(ptr, \"tracelog\") == 0) {\n\t\targ_tracelog = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"private\") == 0) {\n\t\targ_private = 1;\n\t\treturn 0;\n\t}\n\tif (strncmp(ptr, \"private-home \", 13) == 0) {\n#ifdef HAVE_PRIVATE_HOME\n\t\tif (checkcfg(CFG_PRIVATE_HOME)) {\n\t\t\tcfg.home_private_keep = ptr + 13;\n\t\t\tfs_check_home_list();\n\t\t\targ_private = 1;\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: private-home is disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"allusers\") == 0) {\n\t\targ_allusers = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"private-dev\") == 0) {\n\t\targ_private_dev = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"private-tmp\") == 0) {\n\t\targ_private_tmp = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nogroups\") == 0) {\n\t\targ_nogroups = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nosound\") == 0) {\n\t\targ_nosound = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"no3d\") == 0) {\n\t\targ_no3d = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"netfilter\") == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK))\n\t\t\targ_netfilter = 1;\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strncmp(ptr, \"netfilter \", 10) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\targ_netfilter = 1;\n\t\t\targ_netfilter_file = strdup(ptr + 10);\n\t\t\tif (!arg_netfilter_file)\n\t\t\t\terrExit(\"strdup\");\n\t\t\tcheck_netfilter_file(arg_netfilter_file);\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strncmp(ptr, \"netfilter6 \", 11) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\targ_netfilter6 = 1;\n\t\t\targ_netfilter6_file = strdup(ptr + 11);\n\t\t\tif (!arg_netfilter6_file)\n\t\t\t\terrExit(\"strdup\");\n\t\t\tcheck_netfilter_file(arg_netfilter6_file);\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"net none\") == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\targ_nonetwork  = 1;\n\t\t\tcfg.bridge0.configured = 0;\n\t\t\tcfg.bridge1.configured = 0;\n\t\t\tcfg.bridge2.configured = 0;\n\t\t\tcfg.bridge3.configured = 0;\n\t\t\tcfg.interface0.configured = 0;\n\t\t\tcfg.interface1.configured = 0;\n\t\t\tcfg.interface2.configured = 0;\n\t\t\tcfg.interface3.configured = 0;\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strncmp(ptr, \"net \", 4) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n#ifdef HAVE_NETWORK_RESTRICTED\n\t\t\t// compile time restricted networking\n\t\t\tif (getuid() != 0) {\n\t\t\t\tfprintf(stderr, \"Error: only \\\"net none\\\" is allowed to non-root users\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n#endif\n\t\t\t// run time restricted networking\n\t\t\tif (checkcfg(CFG_RESTRICTED_NETWORK) && getuid() != 0) {\n\t\t\t\tfprintf(stderr, \"Error: only \\\"net none\\\" is allowed to non-root users\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t\n\t\t\tif (strcmp(ptr + 4, \"lo\") == 0) {\n\t\t\t\tfprintf(stderr, \"Error: cannot attach to lo device\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tBridge *br;\n\t\t\tif (cfg.bridge0.configured == 0)\n\t\t\t\tbr = &cfg.bridge0;\n\t\t\telse if (cfg.bridge1.configured == 0)\n\t\t\t\tbr = &cfg.bridge1;\n\t\t\telse if (cfg.bridge2.configured == 0)\n\t\t\t\tbr = &cfg.bridge2;\n\t\t\telse if (cfg.bridge3.configured == 0)\n\t\t\t\tbr = &cfg.bridge3;\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"Error: maximum 4 network devices are allowed\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tnet_configure_bridge(br, ptr + 4);\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\t\n\telse if (strncmp(ptr, \"veth-name \", 10) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tbr->veth_name = strdup(ptr + 10);\n\t\t\tif (br->veth_name == NULL)\n\t\t\t\terrExit(\"strdup\");\n\t\t\tif (*br->veth_name == '\\0') {\n\t\t\t\tfprintf(stderr, \"Error: no veth-name configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"iprange \", 8) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (br->iprange_start || br->iprange_end) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the IP range twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// parse option arguments\n\t\t\tchar *firstip = ptr + 8;\n\t\t\tchar *secondip = firstip;\n\t\t\twhile (*secondip != '\\0') {\n\t\t\t\tif (*secondip == ',')\n\t\t\t\t\tbreak;\n\t\t\t\tsecondip++;\n\t\t\t}\n\t\t\tif (*secondip == '\\0') {\n\t\t\t\tfprintf(stderr, \"Error: invalid IP range\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t*secondip = '\\0';\n\t\t\tsecondip++;\n\t\t\t\n\t\t\t// check addresses\n\t\t\tif (atoip(firstip, &br->iprange_start) || atoip(secondip, &br->iprange_end) ||\n\t\t\t    br->iprange_start >= br->iprange_end) {\n\t\t\t\tfprintf(stderr, \"Error: invalid IP range\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (in_netrange(br->iprange_start, br->ip, br->mask) || in_netrange(br->iprange_end, br->ip, br->mask)) {\n\t\t\t\tfprintf(stderr, \"Error: IP range addresses not in network range\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\n\n\telse if (strncmp(ptr, \"mac \", 4) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t\n\t\t\tif (mac_not_zero(br->macsandbox)) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the MAC address twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// read the address\n\t\t\tif (atomac(ptr + 4, br->macsandbox)) {\n\t\t\t\tfprintf(stderr, \"Error: invalid MAC address\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"mtu \", 4) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t\n\t\t\tif (sscanf(ptr + 4, \"%d\", &br->mtu) != 1 || br->mtu < 576 || br->mtu > 9198) {\n\t\t\t\tfprintf(stderr, \"Error: invalid mtu value\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"ip \", 3) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (br->arg_ip_none || br->ipsandbox) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the IP address twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// configure this IP address for the last bridge defined\n\t\t\tif (strcmp(ptr + 3, \"none\") == 0)\n\t\t\t\tbr->arg_ip_none = 1;\n\t\t\telse {\n\t\t\t\tif (atoip(ptr + 3, &br->ipsandbox)) {\n\t\t\t\t\tfprintf(stderr, \"Error: invalid IP address\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"ip6 \", 4) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (br->arg_ip_none || br->ip6sandbox) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the IP address twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// configure this IP address for the last bridge defined\n\t\t\t// todo: verify ipv6 syntax\n\t\t\tbr->ip6sandbox = ptr + 4;\n//\t\t\tif (atoip(argv[i] + 5, &br->ipsandbox)) {\n//\t\t\t\tfprintf(stderr, \"Error: invalid IP address\\n\");\n//\t\t\t\texit(1);\n//\t\t\t}\n\t\t\t\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"defaultgw \", 10) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tif (atoip(ptr + 10, &cfg.defaultgw)) {\n\t\t\t\tfprintf(stderr, \"Error: invalid IP address\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"apparmor\") == 0) {\n#ifdef HAVE_APPARMOR\t\t\n\t\targ_apparmor = 1;\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strncmp(ptr, \"protocol \", 9) == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP))\n\t\t\tprotocol_store(ptr + 9);\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: user seccomp feature is disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\t\n\tif (strncmp(ptr, \"env \", 4) == 0) {\n\t\tenv_store(ptr + 4, SETENV);\n\t\treturn 0;\n\t}\n\tif (strncmp(ptr, \"rmenv \", 6) == 0) {\n\t\tenv_store(ptr + 6, RMENV);\n\t\treturn 0;\n\t}\n\t\n\t// seccomp drop list on top of default list\n\tif (strncmp(ptr, \"seccomp \", 8) == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\targ_seccomp = 1;\n\t\t\tcfg.seccomp_list = strdup(ptr + 8);\n\t\t\tif (!cfg.seccomp_list)\n\t\t\t\terrExit(\"strdup\");\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: user seccomp feature is disabled in Firejail configuration file\\n\");\n#endif\n\n\t\treturn 0;\n\t}\n\t\n\t// seccomp drop list without default list\n\tif (strncmp(ptr, \"seccomp.drop \", 13) == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\targ_seccomp = 1;\n\t\t\tcfg.seccomp_list_drop = strdup(ptr + 13);\n\t\t\tif (!cfg.seccomp_list_drop)\n\t\t\t\terrExit(\"strdup\");\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: user seccomp feature is disabled in Firejail configuration file\\n\");\n#endif\t\t\n\t\treturn 0;\n\t}\n\n\t// seccomp keep list\n\tif (strncmp(ptr, \"seccomp.keep \", 13) == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\targ_seccomp = 1;\n\t\t\tcfg.seccomp_list_keep= strdup(ptr + 13);\n\t\t\tif (!cfg.seccomp_list_keep)\n\t\t\t\terrExit(\"strdup\");\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: user seccomp feature is disabled in Firejail configuration file\\n\");\n#endif\t\t\n\t\treturn 0;\n\t}\n\t\n\t// caps drop list\n\tif (strncmp(ptr, \"caps.drop \", 10) == 0) {\n\t\targ_caps_drop = 1;\n\t\targ_caps_list = strdup(ptr + 10);\n\t\tif (!arg_caps_list)\n\t\t\terrExit(\"strdup\");\n\t\t// verify seccomp list and exit if problems\n\t\tif (caps_check_list(arg_caps_list, NULL))\n\t\t\texit(1);\n\t\treturn 0;\n\t}\n\t\n\t// caps keep list\n\tif (strncmp(ptr, \"caps.keep \", 10) == 0) {\n\t\targ_caps_keep = 1;\n\t\targ_caps_list = strdup(ptr + 10);\n\t\tif (!arg_caps_list)\n\t\t\terrExit(\"strdup\");\n\t\t// verify seccomp list and exit if problems\n\t\tif (caps_check_list(arg_caps_list, NULL))\n\t\t\texit(1);\n\t\treturn 0;\n\t}\n\n\t// hostname\n\tif (strncmp(ptr, \"hostname \", 9) == 0) {\n\t\tcfg.hostname = ptr + 9;\n\t\treturn 0;\n\t}\n\t\n\t// dns\n\tif (strncmp(ptr, \"dns \", 4) == 0) {\n\t\tuint32_t dns;\n\t\tif (atoip(ptr + 4, &dns)) {\n\t\t\tfprintf(stderr, \"Error: invalid DNS server IP address\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\t\n\t\tif (cfg.dns1 == 0)\n\t\t\tcfg.dns1 = dns;\n\t\telse if (cfg.dns2 == 0)\n\t\t\tcfg.dns2 = dns;\n\t\telse if (cfg.dns3 == 0)\n\t\t\tcfg.dns3 = dns;\n\t\telse {\n\t\t\tfprintf(stderr, \"Error: up to 3 DNS servers can be specified\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\t// cpu affinity\n\tif (strncmp(ptr, \"cpu \", 4) == 0) {\n\t\tread_cpu_list(ptr + 4);\n\t\treturn 0;\n\t}\n\t\n\t// nice value\n\tif (strncmp(ptr, \"nice \", 4) == 0) {\n\t\tcfg.nice = atoi(ptr + 5);\n\t\tif (getuid() != 0 &&cfg.nice < 0)\n\t\t\tcfg.nice = 0;\n\t\targ_nice = 1;\n\t\treturn 0;\n\t}\n\n\t// cgroup\n\tif (strncmp(ptr, \"cgroup \", 7) == 0) {\n\t\tset_cgroup(ptr + 7);\n\t\treturn 0;\n\t}\n\t\n\t// writable-etc\n\tif (strcmp(ptr, \"writable-etc\") == 0) {\n\t\tif (cfg.etc_private_keep) {\n\t\t\tfprintf(stderr, \"Error: private-etc and writable-etc are mutually exclusive\\n\");\n\t\t\texit(1);\n\t\t}\n\t\targ_writable_etc = 1;\n\t\treturn 0;\n\t}\n\t\n\t// writable-var\n\tif (strcmp(ptr, \"writable-var\") == 0) {\n\t\targ_writable_var = 1;\n\t\treturn 0;\n\t}\n\t\n\t// private directory\n\tif (strncmp(ptr, \"private \", 8) == 0) {\n\t\tcfg.home_private = ptr + 8;\n\t\tfs_check_private_dir();\n\t\targ_private = 1;\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 none\") == 0) {\n\t\targ_x11_block = 1;\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 xephyr\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\tchar *x11env = getenv(\"FIREJAIL_X11\");\n\t\t\tif (x11env && strcmp(x11env, \"yes\") == 0) {\n\t\t\t\tmask_x11_abstract_socket = 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// start x11\n\t\t\t\tx11_start_xephyr(cfg.original_argc, cfg.original_argv);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 xorg\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11))\n\t\t\targ_x11_xorg = 1;\n\t\telse {\n\t\t\tfprintf(stderr, \"Error: --x11 feature is disabled in Firejail configuration file\\n\");\n\t\t\treturn 0;\n\t\t}\n#endif\n\t\treturn 0;\n\t}\n\tif (strcmp(ptr, \"x11 xpra\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\tchar *x11env = getenv(\"FIREJAIL_X11\");\n\t\t\tif (x11env && strcmp(x11env, \"yes\") == 0) {\n\t\t\t\tmask_x11_abstract_socket = 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// start x11\n\t\t\t\tx11_start_xpra(cfg.original_argc, cfg.original_argv);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n#endif\n\t\treturn 0;\n\t}\n\t\n\tif (strcmp(ptr, \"x11\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\tchar *x11env = getenv(\"FIREJAIL_X11\");\n\t\t\tif (x11env && strcmp(x11env, \"yes\") == 0) {\n\t\t\t\tmask_x11_abstract_socket = 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// start x11\n\t\t\t\tx11_start(cfg.original_argc, cfg.original_argv);\n\t\t\t\texit(0);\t\t\n\t\t\t}\n\t\t}\n#endif\t\t\n\t\treturn 0;\n\t}\n\t\n\t// private /etc list of files and directories\n\tif (strncmp(ptr, \"private-etc \", 12) == 0) {\n\t\tif (arg_writable_etc) {\n\t\t\tfprintf(stderr, \"Error: --private-etc and --writable-etc are mutually exclusive\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tcfg.etc_private_keep = ptr + 12;\n\t\tfs_check_etc_list();\n\t\targ_private_etc = 1;\n\t\t\n\t\treturn 0;\n\t}\n\n\t// private /bin list of files\n\tif (strncmp(ptr, \"private-bin \", 12) == 0) {\n\t\tcfg.bin_private_keep = ptr + 12;\n\t\targ_private_bin = 1;\n\t\tfs_check_bin_list();\n\t\treturn 0;\n\t}\n\n\t// filesystem bind\n\tif (strncmp(ptr, \"bind \", 5) == 0) {\n#ifdef HAVE_BIND\t\t\n\t\tif (checkcfg(CFG_BIND)) {\n\t\t\tif (getuid() != 0) {\n\t\t\t\tfprintf(stderr, \"Error: --bind option is available only if running as root\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\n\t\t\t// extract two directories\n\t\t\tchar *dname1 = ptr + 5;\n\t\t\tchar *dname2 = split_comma(dname1); // this inserts a '0 to separate the two dierctories\n\t\t\tif (dname2 == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: missing second directory for bind\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t\n\t\t\t// check directories\n\t\t\tinvalid_filename(dname1);\n\t\t\tinvalid_filename(dname2);\n\t\t\tif (strstr(dname1, \"..\") || strstr(dname2, \"..\")) {\n\t\t\t\tfprintf(stderr, \"Error: invalid file name.\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (is_link(dname1) || is_link(dname2)) {\n\t\t\t\tfprintf(stderr, \"Symbolic links are not allowed for bind command\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t\n\t\t\t// insert comma back\n\t\t\t*(dname2 - 1) = ',';\n\t\t\treturn 1;\n\t\t}\n\t\telse if (!arg_quiet) {\n\t\t\tfprintf(stderr, \"Warning: bind feature is disabled in Firejail configuration file\\n\");\n\t\t\treturn 0;\t\t\t\n\t\t}\n#else\n\t\treturn 0;\n#endif\t\t\n\t}\n\n\t// rlimit\n\tif (strncmp(ptr, \"rlimit\", 6) == 0) {\n\t\tif (strncmp(ptr, \"rlimit-nofile \", 14) == 0) {\n\t\t\tptr += 14;\n\t\t\tif (not_unsigned(ptr)) {\n\t\t\t\tfprintf(stderr, \"Invalid rlimit option on line %d\\n\", lineno);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tsscanf(ptr, \"%u\", &cfg.rlimit_nofile);\n\t\t\targ_rlimit_nofile = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-nproc \", 13) == 0) {\n\t\t\tptr += 13;\n\t\t\tif (not_unsigned(ptr)) {\n\t\t\t\tfprintf(stderr, \"Invalid rlimit option on line %d\\n\", lineno);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tsscanf(ptr, \"%u\", &cfg.rlimit_nproc);\n\t\t\targ_rlimit_nproc = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-fsize \", 13) == 0) {\n\t\t\tptr += 13;\n\t\t\tif (not_unsigned(ptr)) {\n\t\t\t\tfprintf(stderr, \"Invalid rlimit option on line %d\\n\", lineno);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tsscanf(ptr, \"%u\", &cfg.rlimit_fsize);\n\t\t\targ_rlimit_fsize = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-sigpending \", 18) == 0) {\n\t\t\tptr += 18;\n\t\t\tif (not_unsigned(ptr)) {\n\t\t\t\tfprintf(stderr, \"Invalid rlimit option on line %d\\n\", lineno);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tsscanf(ptr, \"%u\", &cfg.rlimit_sigpending);\n\t\t\targ_rlimit_sigpending = 1;\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"Invalid rlimit option on line %d\\n\", lineno);\n\t\t\texit(1);\n\t\t}\n\t\t\n\t\treturn 0;\t\t\n\t}\n\n\tif (strncmp(ptr, \"join-or-start \", 14) == 0) {\n\t\t// try to join by name only\n\t\tpid_t pid;\n\t\tif (!name2pid(ptr + 14, &pid)) {\n\t\t\tif (!cfg.shell && !arg_shell_none)\n\t\t\t\tcfg.shell = guess_shell();\n\n\t\t\t// find first non-option arg\n\t\t\tint i;\n\t\t\tfor (i = 1; i < cfg.original_argc && strncmp(cfg.original_argv[i], \"--\", 2) != 0; i++);\n\n\t\t\tjoin(pid, cfg.original_argc,cfg.original_argv, i + 1);\n\t\t\texit(0);\n\t\t}\n\n\t\t// set sandbox name and start normally\n\t\tcfg.name = ptr + 14;\n\t\tif (strlen(cfg.name) == 0) {\n\t\t\tfprintf(stderr, \"Error: invalid sandbox name\\n\");\n\t\t\texit(1);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t// rest of filesystem\n\tif (strncmp(ptr, \"blacklist \", 10) == 0)\n\t\tptr += 10;\n\telse if (strncmp(ptr, \"blacklist-nolog \", 16) == 0)\n\t\tptr += 16;\n\telse if (strncmp(ptr, \"noblacklist \", 12) == 0)\n\t\tptr += 12;\n\telse if (strncmp(ptr, \"whitelist \", 10) == 0) {\n#ifdef HAVE_WHITELIST\t\t\n\t\tif (checkcfg(CFG_WHITELIST)) {\n\t\t\targ_whitelist = 1;\n\t\t\tptr += 10;\n\t\t}\n\t\telse\n\t\t\treturn 0;\n#else\t\t\n\t\treturn 0;\n#endif\n\t}\n\telse if (strncmp(ptr, \"read-only \", 10) == 0)\n\t\tptr += 10;\n\telse if (strncmp(ptr, \"read-write \", 11) == 0)\n\t\tptr += 11;\n\telse if (strncmp(ptr, \"noexec \", 7) == 0)\n\t\tptr += 7;\n\telse if (strncmp(ptr, \"tmpfs \", 6) == 0) {\n\t\tif (getuid() != 0) {\n\t\t\tfprintf(stderr, \"Error: tmpfs available only when running the sandbox as root\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tptr += 6;\n\t}\n\telse {\n\t\tif (lineno == 0)\n\t\t\tfprintf(stderr, \"Error: \\\"%s\\\" as a command line option is invalid\\n\", ptr);\n\t\telse if (fname != NULL)\n\t\t\tfprintf(stderr, \"Error: line %d in %s is invalid\\n\", lineno, fname);\n\t\telse\n\t\t\tfprintf(stderr, \"Error: line %d in the custom profile is invalid\\n\", lineno);\n\t\texit(1);\n\t}\n\n\t// some characters just don't belong in filenames\n\tinvalid_filename(ptr);\n\tif (strstr(ptr, \"..\")) {\n\t\tif (lineno == 0)\n\t\t\tfprintf(stderr, \"Error: \\\"%s\\\" is an invalid filename\\n\", ptr);\n\t\telse if (fname != NULL)\n\t\t\tfprintf(stderr, \"Error: line %d in %s is invalid\\n\", lineno, fname);\n\t\telse\n\t\t\tfprintf(stderr, \"Error: line %d in the custom profile is invalid\\n\", lineno);\n\t\texit(1);\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ptr"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "newprofile2"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "profile_read",
          "args": [
            "(newprofile2)? newprofile2:newprofile"
          ],
          "line": 1013
        },
        "resolved": true,
        "details": {
          "function_name": "profile_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/profile.c",
          "lines": "942-1030",
          "snippet": "void profile_read(const char *fname) {\n\tEUID_ASSERT();\n\t\n\t// exit program if maximum include level was reached\n\tif (include_level > MAX_INCLUDE_LEVEL) {\n\t\tfprintf(stderr, \"Error: maximum profile include level was reached\\n\");\n\t\texit(1);\t\n\t}\n\n\tif (strlen(fname) == 0) {\n\t\tfprintf(stderr, \"Error: invalid profile file\\n\");\n\t\texit(1);\n\t}\n\n\t// allow debuggers\n\tif (arg_allow_debuggers) {\n\t\tchar *tmp = strrchr(fname, '/');\n\t\tif (tmp && *(tmp + 1) != '\\0') {\n\t\t\ttmp++;\n\t\t\tif (strcmp(tmp, \"disable-devel.inc\") == 0)\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\t// open profile file:\n\tFILE *fp = fopen(fname, \"r\");\n\tif (fp == NULL) {\n\t\tfprintf(stderr, \"Error: cannot open profile file %s\\n\", fname);\n\t\texit(1);\n\t}\n\n\tint msg_printed = 0;\n\n\t// read the file line by line\n\tchar buf[MAX_READ + 1];\n\tint lineno = 0;\n\twhile (fgets(buf, MAX_READ, fp)) {\n\t\t++lineno;\n\t\t// remove empty space - ptr in allocated memory\n\t\tchar *ptr = line_remove_spaces(buf);\n\t\tif (ptr == NULL)\n\t\t\tcontinue;\n\t\t\n\t\t// comments\n\t\tif (*ptr == '#' || *ptr == '\\0') {\n\t\t\tfree(ptr);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t// process quiet\n\t\tif (strcmp(ptr, \"quiet\") == 0) {\n\t\t\targ_quiet = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!msg_printed) {\n\t\t\tif (!arg_quiet)\n\t\t\t\tfprintf(stderr, \"Reading profile %s\\n\", fname);\n\t\t\tmsg_printed = 1;\n\t\t}\n\n\t\t// process include\n\t\tif (strncmp(ptr, \"include \", 8) == 0) {\n\t\t\tinclude_level++;\n\t\t\t\n\t\t\t// extract profile filename and new skip params\n\t\t\tchar *newprofile = ptr + 8; // profile name\n\t\t\t\n\t\t\t// expand ${HOME}/ in front of the new profile file\n\t\t\tchar *newprofile2 = expand_home(newprofile, cfg.homedir);\n\t\t\t\n\t\t\t// recursivity\n\t\t\tprofile_read((newprofile2)? newprofile2:newprofile);\n\t\t\tinclude_level--;\n\t\t\tif (newprofile2)\n\t\t\t\tfree(newprofile2);\n\t\t\tfree(ptr);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t// verify syntax, exit in case of error\n\t\tif (profile_check_line(ptr, lineno, fname))\n\t\t\tprofile_add(ptr);\n// we cannot free ptr here, data is extracted from ptr and linked as a pointer in cfg structure\n//\t\telse {\n//\t\t\tfree(ptr);\n//\t\t}\n\t}\n\tfclose(fp);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "expand_home",
          "args": [
            "newprofile",
            "cfg.homedir"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "expand_home",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/util.c",
          "lines": "589-607",
          "snippet": "char *expand_home(const char *path, const char* homedir) {\n\tassert(path);\n\tassert(homedir);\n\n\t// Replace home macro\n\tchar *new_name = NULL;\n\tif (strncmp(path, \"${HOME}\", 7) == 0) {\n\t\tif (asprintf(&new_name, \"%s%s\", homedir, path + 7) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\treturn new_name;\n\t}\n\telse if (*path == '~') {\n\t\tif (asprintf(&new_name, \"%s%s\", homedir, path + 1) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\treturn new_name;\n\t}\n\n\treturn strdup(path);\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nchar *expand_home(const char *path, const char* homedir) {\n\tassert(path);\n\tassert(homedir);\n\n\t// Replace home macro\n\tchar *new_name = NULL;\n\tif (strncmp(path, \"${HOME}\", 7) == 0) {\n\t\tif (asprintf(&new_name, \"%s%s\", homedir, path + 7) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\treturn new_name;\n\t}\n\telse if (*path == '~') {\n\t\tif (asprintf(&new_name, \"%s%s\", homedir, path + 1) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\treturn new_name;\n\t}\n\n\treturn strdup(path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"include \"",
            "8"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Reading profile %s\\n\"",
            "fname"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"quiet\""
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ptr"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "line_remove_spaces",
          "args": [
            "buf"
          ],
          "line": 981
        },
        "resolved": true,
        "details": {
          "function_name": "line_remove_spaces",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/util.c",
          "lines": "311-358",
          "snippet": "char *line_remove_spaces(const char *buf) {\n\tEUID_ASSERT();\n\tassert(buf);\n\tif (strlen(buf) == 0)\n\t\treturn NULL;\n\n\t// allocate memory for the new string\n\tchar *rv = malloc(strlen(buf) + 1);\n\tif (rv == NULL)\n\t\terrExit(\"malloc\");\n\n\t// remove space at start of line\n\tconst char *ptr1 = buf;\n\twhile (*ptr1 == ' ' || *ptr1 == '\\t')\n\t\tptr1++;\n\n\t// copy data and remove additional spaces\n\tchar *ptr2 = rv;\n\tint state = 0;\n\twhile (*ptr1 != '\\0') {\n\t\tif (*ptr1 == '\\n' || *ptr1 == '\\r')\n\t\t\tbreak;\n\n\t\tif (state == 0) {\n\t\t\tif (*ptr1 != ' ' && *ptr1 != '\\t')\n\t\t\t\t*ptr2++ = *ptr1++;\n\t\t\telse {\n\t\t\t\t*ptr2++ = ' ';\n\t\t\t\tptr1++;\n\t\t\t\tstate = 1;\n\t\t\t}\n\t\t}\n\t\telse {\t\t\t\t  // state == 1\n\t\t\twhile (*ptr1 == ' ' || *ptr1 == '\\t')\n\t\t\t\tptr1++;\n\t\t\tstate = 0;\n\t\t}\n\t}\n\n\t// strip last blank character if any\n\tif (ptr2 > rv && *(ptr2 - 1) == ' ')\n\t\t--ptr2;\n\t*ptr2 = '\\0';\n\t//\tif (arg_debug)\n\t//\t\tprintf(\"Processing line #%s#\\n\", rv);\n\n\treturn rv;\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nchar *line_remove_spaces(const char *buf) {\n\tEUID_ASSERT();\n\tassert(buf);\n\tif (strlen(buf) == 0)\n\t\treturn NULL;\n\n\t// allocate memory for the new string\n\tchar *rv = malloc(strlen(buf) + 1);\n\tif (rv == NULL)\n\t\terrExit(\"malloc\");\n\n\t// remove space at start of line\n\tconst char *ptr1 = buf;\n\twhile (*ptr1 == ' ' || *ptr1 == '\\t')\n\t\tptr1++;\n\n\t// copy data and remove additional spaces\n\tchar *ptr2 = rv;\n\tint state = 0;\n\twhile (*ptr1 != '\\0') {\n\t\tif (*ptr1 == '\\n' || *ptr1 == '\\r')\n\t\t\tbreak;\n\n\t\tif (state == 0) {\n\t\t\tif (*ptr1 != ' ' && *ptr1 != '\\t')\n\t\t\t\t*ptr2++ = *ptr1++;\n\t\t\telse {\n\t\t\t\t*ptr2++ = ' ';\n\t\t\t\tptr1++;\n\t\t\t\tstate = 1;\n\t\t\t}\n\t\t}\n\t\telse {\t\t\t\t  // state == 1\n\t\t\twhile (*ptr1 == ' ' || *ptr1 == '\\t')\n\t\t\t\tptr1++;\n\t\t\tstate = 0;\n\t\t}\n\t}\n\n\t// strip last blank character if any\n\tif (ptr2 > rv && *(ptr2 - 1) == ' ')\n\t\t--ptr2;\n\t*ptr2 = '\\0';\n\t//\tif (arg_debug)\n\t//\t\tprintf(\"Processing line #%s#\\n\", rv);\n\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buf",
            "MAX_READ",
            "fp"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "myexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/main.c",
          "lines": "137-149",
          "snippet": "static void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}",
          "includes": [
            "#include <sys/times.h>",
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int arg_command = 0;",
            "int arg_quiet = 0;",
            "pid_t sandbox_pid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/times.h>\n#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nint arg_command = 0;\nint arg_quiet = 0;\npid_t sandbox_pid;\n\nstatic void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot open profile file %s\\n\"",
            "fname"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "fname",
            "\"r\""
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "tmp",
            "\"disable-devel.inc\""
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "fname",
            "'/'"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid profile file\\n\""
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "fname"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: maximum profile include level was reached\\n\""
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <dirent.h>\n#include \"firejail.h\"\n\n#define MAX_READ 8192\t\t\t\t  // line buffer for profile files\n\nstatic int include_level = 0;\n\nvoid profile_read(const char *fname) {\n\tEUID_ASSERT();\n\t\n\t// exit program if maximum include level was reached\n\tif (include_level > MAX_INCLUDE_LEVEL) {\n\t\tfprintf(stderr, \"Error: maximum profile include level was reached\\n\");\n\t\texit(1);\t\n\t}\n\n\tif (strlen(fname) == 0) {\n\t\tfprintf(stderr, \"Error: invalid profile file\\n\");\n\t\texit(1);\n\t}\n\n\t// allow debuggers\n\tif (arg_allow_debuggers) {\n\t\tchar *tmp = strrchr(fname, '/');\n\t\tif (tmp && *(tmp + 1) != '\\0') {\n\t\t\ttmp++;\n\t\t\tif (strcmp(tmp, \"disable-devel.inc\") == 0)\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\t// open profile file:\n\tFILE *fp = fopen(fname, \"r\");\n\tif (fp == NULL) {\n\t\tfprintf(stderr, \"Error: cannot open profile file %s\\n\", fname);\n\t\texit(1);\n\t}\n\n\tint msg_printed = 0;\n\n\t// read the file line by line\n\tchar buf[MAX_READ + 1];\n\tint lineno = 0;\n\twhile (fgets(buf, MAX_READ, fp)) {\n\t\t++lineno;\n\t\t// remove empty space - ptr in allocated memory\n\t\tchar *ptr = line_remove_spaces(buf);\n\t\tif (ptr == NULL)\n\t\t\tcontinue;\n\t\t\n\t\t// comments\n\t\tif (*ptr == '#' || *ptr == '\\0') {\n\t\t\tfree(ptr);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t// process quiet\n\t\tif (strcmp(ptr, \"quiet\") == 0) {\n\t\t\targ_quiet = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!msg_printed) {\n\t\t\tif (!arg_quiet)\n\t\t\t\tfprintf(stderr, \"Reading profile %s\\n\", fname);\n\t\t\tmsg_printed = 1;\n\t\t}\n\n\t\t// process include\n\t\tif (strncmp(ptr, \"include \", 8) == 0) {\n\t\t\tinclude_level++;\n\t\t\t\n\t\t\t// extract profile filename and new skip params\n\t\t\tchar *newprofile = ptr + 8; // profile name\n\t\t\t\n\t\t\t// expand ${HOME}/ in front of the new profile file\n\t\t\tchar *newprofile2 = expand_home(newprofile, cfg.homedir);\n\t\t\t\n\t\t\t// recursivity\n\t\t\tprofile_read((newprofile2)? newprofile2:newprofile);\n\t\t\tinclude_level--;\n\t\t\tif (newprofile2)\n\t\t\t\tfree(newprofile2);\n\t\t\tfree(ptr);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t// verify syntax, exit in case of error\n\t\tif (profile_check_line(ptr, lineno, fname))\n\t\t\tprofile_add(ptr);\n// we cannot free ptr here, data is extracted from ptr and linked as a pointer in cfg structure\n//\t\telse {\n//\t\t\tfree(ptr);\n//\t\t}\n\t}\n\tfclose(fp);\n}"
  },
  {
    "function_name": "profile_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/profile.c",
    "lines": "919-938",
    "snippet": "void profile_add(char *str) {\n\tEUID_ASSERT();\n\t\n\tProfileEntry *prf = malloc(sizeof(ProfileEntry));\n\tif (!prf)\n\t\terrExit(\"malloc\");\n\tmemset(prf, 0, sizeof(ProfileEntry));\n\tprf->next = NULL;\n\tprf->data = str;\t\n\n\t// add prf to the list\n\tif (cfg.profile == NULL) {\n\t\tcfg.profile = prf;\n\t\treturn;\n\t}\n\tProfileEntry *ptr = cfg.profile;\n\twhile (ptr->next != NULL)\n\t\tptr = ptr->next;\n\tptr->next = prf;\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <dirent.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "prf",
            "0",
            "sizeof(ProfileEntry)"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"malloc\""
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(ProfileEntry)"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <dirent.h>\n#include \"firejail.h\"\n\nvoid profile_add(char *str) {\n\tEUID_ASSERT();\n\t\n\tProfileEntry *prf = malloc(sizeof(ProfileEntry));\n\tif (!prf)\n\t\terrExit(\"malloc\");\n\tmemset(prf, 0, sizeof(ProfileEntry));\n\tprf->next = NULL;\n\tprf->data = str;\t\n\n\t// add prf to the list\n\tif (cfg.profile == NULL) {\n\t\tcfg.profile = prf;\n\t\treturn;\n\t}\n\tProfileEntry *ptr = cfg.profile;\n\twhile (ptr->next != NULL)\n\t\tptr = ptr->next;\n\tptr->next = prf;\n}"
  },
  {
    "function_name": "profile_check_line",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/profile.c",
    "lines": "69-916",
    "snippet": "int profile_check_line(char *ptr, int lineno, const char *fname) {\n\tEUID_ASSERT();\n\t\n\t// check ignore list\n\tint i;\n\tfor (i = 0; i < MAX_PROFILE_IGNORE; i++) {\n\t\tif (cfg.profile_ignore[i] == NULL)\n\t\t\tbreak;\n\t\t\n\t\tif (strncmp(ptr, cfg.profile_ignore[i], strlen(cfg.profile_ignore[i])) == 0)\n\t\t\treturn 0;\t// ignore line\n\t}\n\t\n\tif (strncmp(ptr, \"ignore \", 7) == 0) {\n\t\tchar *str = strdup(ptr + 7);\n\t\tif (*str == '\\0') {\n\t\t\tfprintf(stderr, \"Error: invalid ignore option\\n\");\n\t\t\texit(1);\n\t\t}\n\t\t// find an empty entry in profile_ignore array\n\t\tint j;\n\t\tfor (j = 0; j < MAX_PROFILE_IGNORE; j++) {\n\t\t\tif (cfg.profile_ignore[j] == NULL) \n\t\t\t\tbreak;\n\t\t}\n\t\tif (j >= MAX_PROFILE_IGNORE) {\n\t\t\tfprintf(stderr, \"Error: maximum %d --ignore options are permitted\\n\", MAX_PROFILE_IGNORE);\n\t\t\texit(1);\n\t\t}\n\t\t// ... and configure it\n\t\telse \n\t\t\tcfg.profile_ignore[j] = str;\n\n\t\treturn 0;\n\t}\n\n\t// mkdir \n\tif (strncmp(ptr, \"mkdir \", 6) == 0) {\n\t\tfs_mkdir(ptr + 6);\n\t\treturn 1;\n\t}\n\t// mkfile \n\tif (strncmp(ptr, \"mkfile \", 7) == 0) {\n\t\tfs_mkfile(ptr + 7);\n\t\treturn 1;\n\t}\n\t// sandbox name\n\telse if (strncmp(ptr, \"name \", 5) == 0) {\n\t\tcfg.name = ptr + 5;\n\t\tif (strlen(cfg.name) == 0) {\n\t\t\tfprintf(stderr, \"Error: invalid sandbox name\\n\");\n\t\t\texit(1);\n\t\t}\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"ipc-namespace\") == 0) {\n\t\targ_ipc = 1;\n\t\treturn 0;\n\t}\n\t// seccomp, caps, private, user namespace\n\telse if (strcmp(ptr, \"noroot\") == 0) {\n#if HAVE_USERNS\n\t\tif (checkcfg(CFG_USERNS))\n\t\t\tcheck_user_namespace();\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: user namespace feature is disabled in Firejail configuration file\\n\");\n#endif\n\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nonewprivs\") == 0) {\n\t\targ_nonewprivs = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"seccomp\") == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP))\n\t\t\targ_seccomp = 1;\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: user seccomp feature is disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"caps\") == 0) {\n\t\targ_caps_default_filter = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"caps.drop all\") == 0) {\n\t\targ_caps_drop_all = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"shell none\") == 0) {\n\t\targ_shell_none = 1;\n\t\treturn 0;\n\t}\t\n\telse if (strcmp(ptr, \"tracelog\") == 0) {\n\t\targ_tracelog = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"private\") == 0) {\n\t\targ_private = 1;\n\t\treturn 0;\n\t}\n\tif (strncmp(ptr, \"private-home \", 13) == 0) {\n#ifdef HAVE_PRIVATE_HOME\n\t\tif (checkcfg(CFG_PRIVATE_HOME)) {\n\t\t\tcfg.home_private_keep = ptr + 13;\n\t\t\tfs_check_home_list();\n\t\t\targ_private = 1;\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: private-home is disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"allusers\") == 0) {\n\t\targ_allusers = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"private-dev\") == 0) {\n\t\targ_private_dev = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"private-tmp\") == 0) {\n\t\targ_private_tmp = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nogroups\") == 0) {\n\t\targ_nogroups = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nosound\") == 0) {\n\t\targ_nosound = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"no3d\") == 0) {\n\t\targ_no3d = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"netfilter\") == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK))\n\t\t\targ_netfilter = 1;\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strncmp(ptr, \"netfilter \", 10) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\targ_netfilter = 1;\n\t\t\targ_netfilter_file = strdup(ptr + 10);\n\t\t\tif (!arg_netfilter_file)\n\t\t\t\terrExit(\"strdup\");\n\t\t\tcheck_netfilter_file(arg_netfilter_file);\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strncmp(ptr, \"netfilter6 \", 11) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\targ_netfilter6 = 1;\n\t\t\targ_netfilter6_file = strdup(ptr + 11);\n\t\t\tif (!arg_netfilter6_file)\n\t\t\t\terrExit(\"strdup\");\n\t\t\tcheck_netfilter_file(arg_netfilter6_file);\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"net none\") == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\targ_nonetwork  = 1;\n\t\t\tcfg.bridge0.configured = 0;\n\t\t\tcfg.bridge1.configured = 0;\n\t\t\tcfg.bridge2.configured = 0;\n\t\t\tcfg.bridge3.configured = 0;\n\t\t\tcfg.interface0.configured = 0;\n\t\t\tcfg.interface1.configured = 0;\n\t\t\tcfg.interface2.configured = 0;\n\t\t\tcfg.interface3.configured = 0;\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strncmp(ptr, \"net \", 4) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n#ifdef HAVE_NETWORK_RESTRICTED\n\t\t\t// compile time restricted networking\n\t\t\tif (getuid() != 0) {\n\t\t\t\tfprintf(stderr, \"Error: only \\\"net none\\\" is allowed to non-root users\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n#endif\n\t\t\t// run time restricted networking\n\t\t\tif (checkcfg(CFG_RESTRICTED_NETWORK) && getuid() != 0) {\n\t\t\t\tfprintf(stderr, \"Error: only \\\"net none\\\" is allowed to non-root users\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t\n\t\t\tif (strcmp(ptr + 4, \"lo\") == 0) {\n\t\t\t\tfprintf(stderr, \"Error: cannot attach to lo device\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tBridge *br;\n\t\t\tif (cfg.bridge0.configured == 0)\n\t\t\t\tbr = &cfg.bridge0;\n\t\t\telse if (cfg.bridge1.configured == 0)\n\t\t\t\tbr = &cfg.bridge1;\n\t\t\telse if (cfg.bridge2.configured == 0)\n\t\t\t\tbr = &cfg.bridge2;\n\t\t\telse if (cfg.bridge3.configured == 0)\n\t\t\t\tbr = &cfg.bridge3;\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"Error: maximum 4 network devices are allowed\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tnet_configure_bridge(br, ptr + 4);\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\t\n\telse if (strncmp(ptr, \"veth-name \", 10) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tbr->veth_name = strdup(ptr + 10);\n\t\t\tif (br->veth_name == NULL)\n\t\t\t\terrExit(\"strdup\");\n\t\t\tif (*br->veth_name == '\\0') {\n\t\t\t\tfprintf(stderr, \"Error: no veth-name configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"iprange \", 8) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (br->iprange_start || br->iprange_end) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the IP range twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// parse option arguments\n\t\t\tchar *firstip = ptr + 8;\n\t\t\tchar *secondip = firstip;\n\t\t\twhile (*secondip != '\\0') {\n\t\t\t\tif (*secondip == ',')\n\t\t\t\t\tbreak;\n\t\t\t\tsecondip++;\n\t\t\t}\n\t\t\tif (*secondip == '\\0') {\n\t\t\t\tfprintf(stderr, \"Error: invalid IP range\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t*secondip = '\\0';\n\t\t\tsecondip++;\n\t\t\t\n\t\t\t// check addresses\n\t\t\tif (atoip(firstip, &br->iprange_start) || atoip(secondip, &br->iprange_end) ||\n\t\t\t    br->iprange_start >= br->iprange_end) {\n\t\t\t\tfprintf(stderr, \"Error: invalid IP range\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (in_netrange(br->iprange_start, br->ip, br->mask) || in_netrange(br->iprange_end, br->ip, br->mask)) {\n\t\t\t\tfprintf(stderr, \"Error: IP range addresses not in network range\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\n\n\telse if (strncmp(ptr, \"mac \", 4) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t\n\t\t\tif (mac_not_zero(br->macsandbox)) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the MAC address twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// read the address\n\t\t\tif (atomac(ptr + 4, br->macsandbox)) {\n\t\t\t\tfprintf(stderr, \"Error: invalid MAC address\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"mtu \", 4) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t\n\t\t\tif (sscanf(ptr + 4, \"%d\", &br->mtu) != 1 || br->mtu < 576 || br->mtu > 9198) {\n\t\t\t\tfprintf(stderr, \"Error: invalid mtu value\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"ip \", 3) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (br->arg_ip_none || br->ipsandbox) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the IP address twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// configure this IP address for the last bridge defined\n\t\t\tif (strcmp(ptr + 3, \"none\") == 0)\n\t\t\t\tbr->arg_ip_none = 1;\n\t\t\telse {\n\t\t\t\tif (atoip(ptr + 3, &br->ipsandbox)) {\n\t\t\t\t\tfprintf(stderr, \"Error: invalid IP address\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"ip6 \", 4) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (br->arg_ip_none || br->ip6sandbox) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the IP address twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// configure this IP address for the last bridge defined\n\t\t\t// todo: verify ipv6 syntax\n\t\t\tbr->ip6sandbox = ptr + 4;\n//\t\t\tif (atoip(argv[i] + 5, &br->ipsandbox)) {\n//\t\t\t\tfprintf(stderr, \"Error: invalid IP address\\n\");\n//\t\t\t\texit(1);\n//\t\t\t}\n\t\t\t\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"defaultgw \", 10) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tif (atoip(ptr + 10, &cfg.defaultgw)) {\n\t\t\t\tfprintf(stderr, \"Error: invalid IP address\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"apparmor\") == 0) {\n#ifdef HAVE_APPARMOR\t\t\n\t\targ_apparmor = 1;\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strncmp(ptr, \"protocol \", 9) == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP))\n\t\t\tprotocol_store(ptr + 9);\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: user seccomp feature is disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\t\n\tif (strncmp(ptr, \"env \", 4) == 0) {\n\t\tenv_store(ptr + 4, SETENV);\n\t\treturn 0;\n\t}\n\tif (strncmp(ptr, \"rmenv \", 6) == 0) {\n\t\tenv_store(ptr + 6, RMENV);\n\t\treturn 0;\n\t}\n\t\n\t// seccomp drop list on top of default list\n\tif (strncmp(ptr, \"seccomp \", 8) == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\targ_seccomp = 1;\n\t\t\tcfg.seccomp_list = strdup(ptr + 8);\n\t\t\tif (!cfg.seccomp_list)\n\t\t\t\terrExit(\"strdup\");\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: user seccomp feature is disabled in Firejail configuration file\\n\");\n#endif\n\n\t\treturn 0;\n\t}\n\t\n\t// seccomp drop list without default list\n\tif (strncmp(ptr, \"seccomp.drop \", 13) == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\targ_seccomp = 1;\n\t\t\tcfg.seccomp_list_drop = strdup(ptr + 13);\n\t\t\tif (!cfg.seccomp_list_drop)\n\t\t\t\terrExit(\"strdup\");\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: user seccomp feature is disabled in Firejail configuration file\\n\");\n#endif\t\t\n\t\treturn 0;\n\t}\n\n\t// seccomp keep list\n\tif (strncmp(ptr, \"seccomp.keep \", 13) == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\targ_seccomp = 1;\n\t\t\tcfg.seccomp_list_keep= strdup(ptr + 13);\n\t\t\tif (!cfg.seccomp_list_keep)\n\t\t\t\terrExit(\"strdup\");\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: user seccomp feature is disabled in Firejail configuration file\\n\");\n#endif\t\t\n\t\treturn 0;\n\t}\n\t\n\t// caps drop list\n\tif (strncmp(ptr, \"caps.drop \", 10) == 0) {\n\t\targ_caps_drop = 1;\n\t\targ_caps_list = strdup(ptr + 10);\n\t\tif (!arg_caps_list)\n\t\t\terrExit(\"strdup\");\n\t\t// verify seccomp list and exit if problems\n\t\tif (caps_check_list(arg_caps_list, NULL))\n\t\t\texit(1);\n\t\treturn 0;\n\t}\n\t\n\t// caps keep list\n\tif (strncmp(ptr, \"caps.keep \", 10) == 0) {\n\t\targ_caps_keep = 1;\n\t\targ_caps_list = strdup(ptr + 10);\n\t\tif (!arg_caps_list)\n\t\t\terrExit(\"strdup\");\n\t\t// verify seccomp list and exit if problems\n\t\tif (caps_check_list(arg_caps_list, NULL))\n\t\t\texit(1);\n\t\treturn 0;\n\t}\n\n\t// hostname\n\tif (strncmp(ptr, \"hostname \", 9) == 0) {\n\t\tcfg.hostname = ptr + 9;\n\t\treturn 0;\n\t}\n\t\n\t// dns\n\tif (strncmp(ptr, \"dns \", 4) == 0) {\n\t\tuint32_t dns;\n\t\tif (atoip(ptr + 4, &dns)) {\n\t\t\tfprintf(stderr, \"Error: invalid DNS server IP address\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\t\n\t\tif (cfg.dns1 == 0)\n\t\t\tcfg.dns1 = dns;\n\t\telse if (cfg.dns2 == 0)\n\t\t\tcfg.dns2 = dns;\n\t\telse if (cfg.dns3 == 0)\n\t\t\tcfg.dns3 = dns;\n\t\telse {\n\t\t\tfprintf(stderr, \"Error: up to 3 DNS servers can be specified\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\t// cpu affinity\n\tif (strncmp(ptr, \"cpu \", 4) == 0) {\n\t\tread_cpu_list(ptr + 4);\n\t\treturn 0;\n\t}\n\t\n\t// nice value\n\tif (strncmp(ptr, \"nice \", 4) == 0) {\n\t\tcfg.nice = atoi(ptr + 5);\n\t\tif (getuid() != 0 &&cfg.nice < 0)\n\t\t\tcfg.nice = 0;\n\t\targ_nice = 1;\n\t\treturn 0;\n\t}\n\n\t// cgroup\n\tif (strncmp(ptr, \"cgroup \", 7) == 0) {\n\t\tset_cgroup(ptr + 7);\n\t\treturn 0;\n\t}\n\t\n\t// writable-etc\n\tif (strcmp(ptr, \"writable-etc\") == 0) {\n\t\tif (cfg.etc_private_keep) {\n\t\t\tfprintf(stderr, \"Error: private-etc and writable-etc are mutually exclusive\\n\");\n\t\t\texit(1);\n\t\t}\n\t\targ_writable_etc = 1;\n\t\treturn 0;\n\t}\n\t\n\t// writable-var\n\tif (strcmp(ptr, \"writable-var\") == 0) {\n\t\targ_writable_var = 1;\n\t\treturn 0;\n\t}\n\t\n\t// private directory\n\tif (strncmp(ptr, \"private \", 8) == 0) {\n\t\tcfg.home_private = ptr + 8;\n\t\tfs_check_private_dir();\n\t\targ_private = 1;\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 none\") == 0) {\n\t\targ_x11_block = 1;\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 xephyr\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\tchar *x11env = getenv(\"FIREJAIL_X11\");\n\t\t\tif (x11env && strcmp(x11env, \"yes\") == 0) {\n\t\t\t\tmask_x11_abstract_socket = 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// start x11\n\t\t\t\tx11_start_xephyr(cfg.original_argc, cfg.original_argv);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 xorg\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11))\n\t\t\targ_x11_xorg = 1;\n\t\telse {\n\t\t\tfprintf(stderr, \"Error: --x11 feature is disabled in Firejail configuration file\\n\");\n\t\t\treturn 0;\n\t\t}\n#endif\n\t\treturn 0;\n\t}\n\tif (strcmp(ptr, \"x11 xpra\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\tchar *x11env = getenv(\"FIREJAIL_X11\");\n\t\t\tif (x11env && strcmp(x11env, \"yes\") == 0) {\n\t\t\t\tmask_x11_abstract_socket = 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// start x11\n\t\t\t\tx11_start_xpra(cfg.original_argc, cfg.original_argv);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n#endif\n\t\treturn 0;\n\t}\n\t\n\tif (strcmp(ptr, \"x11\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\tchar *x11env = getenv(\"FIREJAIL_X11\");\n\t\t\tif (x11env && strcmp(x11env, \"yes\") == 0) {\n\t\t\t\tmask_x11_abstract_socket = 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// start x11\n\t\t\t\tx11_start(cfg.original_argc, cfg.original_argv);\n\t\t\t\texit(0);\t\t\n\t\t\t}\n\t\t}\n#endif\t\t\n\t\treturn 0;\n\t}\n\t\n\t// private /etc list of files and directories\n\tif (strncmp(ptr, \"private-etc \", 12) == 0) {\n\t\tif (arg_writable_etc) {\n\t\t\tfprintf(stderr, \"Error: --private-etc and --writable-etc are mutually exclusive\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tcfg.etc_private_keep = ptr + 12;\n\t\tfs_check_etc_list();\n\t\targ_private_etc = 1;\n\t\t\n\t\treturn 0;\n\t}\n\n\t// private /bin list of files\n\tif (strncmp(ptr, \"private-bin \", 12) == 0) {\n\t\tcfg.bin_private_keep = ptr + 12;\n\t\targ_private_bin = 1;\n\t\tfs_check_bin_list();\n\t\treturn 0;\n\t}\n\n\t// filesystem bind\n\tif (strncmp(ptr, \"bind \", 5) == 0) {\n#ifdef HAVE_BIND\t\t\n\t\tif (checkcfg(CFG_BIND)) {\n\t\t\tif (getuid() != 0) {\n\t\t\t\tfprintf(stderr, \"Error: --bind option is available only if running as root\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\n\t\t\t// extract two directories\n\t\t\tchar *dname1 = ptr + 5;\n\t\t\tchar *dname2 = split_comma(dname1); // this inserts a '0 to separate the two dierctories\n\t\t\tif (dname2 == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: missing second directory for bind\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t\n\t\t\t// check directories\n\t\t\tinvalid_filename(dname1);\n\t\t\tinvalid_filename(dname2);\n\t\t\tif (strstr(dname1, \"..\") || strstr(dname2, \"..\")) {\n\t\t\t\tfprintf(stderr, \"Error: invalid file name.\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (is_link(dname1) || is_link(dname2)) {\n\t\t\t\tfprintf(stderr, \"Symbolic links are not allowed for bind command\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t\n\t\t\t// insert comma back\n\t\t\t*(dname2 - 1) = ',';\n\t\t\treturn 1;\n\t\t}\n\t\telse if (!arg_quiet) {\n\t\t\tfprintf(stderr, \"Warning: bind feature is disabled in Firejail configuration file\\n\");\n\t\t\treturn 0;\t\t\t\n\t\t}\n#else\n\t\treturn 0;\n#endif\t\t\n\t}\n\n\t// rlimit\n\tif (strncmp(ptr, \"rlimit\", 6) == 0) {\n\t\tif (strncmp(ptr, \"rlimit-nofile \", 14) == 0) {\n\t\t\tptr += 14;\n\t\t\tif (not_unsigned(ptr)) {\n\t\t\t\tfprintf(stderr, \"Invalid rlimit option on line %d\\n\", lineno);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tsscanf(ptr, \"%u\", &cfg.rlimit_nofile);\n\t\t\targ_rlimit_nofile = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-nproc \", 13) == 0) {\n\t\t\tptr += 13;\n\t\t\tif (not_unsigned(ptr)) {\n\t\t\t\tfprintf(stderr, \"Invalid rlimit option on line %d\\n\", lineno);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tsscanf(ptr, \"%u\", &cfg.rlimit_nproc);\n\t\t\targ_rlimit_nproc = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-fsize \", 13) == 0) {\n\t\t\tptr += 13;\n\t\t\tif (not_unsigned(ptr)) {\n\t\t\t\tfprintf(stderr, \"Invalid rlimit option on line %d\\n\", lineno);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tsscanf(ptr, \"%u\", &cfg.rlimit_fsize);\n\t\t\targ_rlimit_fsize = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-sigpending \", 18) == 0) {\n\t\t\tptr += 18;\n\t\t\tif (not_unsigned(ptr)) {\n\t\t\t\tfprintf(stderr, \"Invalid rlimit option on line %d\\n\", lineno);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tsscanf(ptr, \"%u\", &cfg.rlimit_sigpending);\n\t\t\targ_rlimit_sigpending = 1;\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"Invalid rlimit option on line %d\\n\", lineno);\n\t\t\texit(1);\n\t\t}\n\t\t\n\t\treturn 0;\t\t\n\t}\n\n\tif (strncmp(ptr, \"join-or-start \", 14) == 0) {\n\t\t// try to join by name only\n\t\tpid_t pid;\n\t\tif (!name2pid(ptr + 14, &pid)) {\n\t\t\tif (!cfg.shell && !arg_shell_none)\n\t\t\t\tcfg.shell = guess_shell();\n\n\t\t\t// find first non-option arg\n\t\t\tint i;\n\t\t\tfor (i = 1; i < cfg.original_argc && strncmp(cfg.original_argv[i], \"--\", 2) != 0; i++);\n\n\t\t\tjoin(pid, cfg.original_argc,cfg.original_argv, i + 1);\n\t\t\texit(0);\n\t\t}\n\n\t\t// set sandbox name and start normally\n\t\tcfg.name = ptr + 14;\n\t\tif (strlen(cfg.name) == 0) {\n\t\t\tfprintf(stderr, \"Error: invalid sandbox name\\n\");\n\t\t\texit(1);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t// rest of filesystem\n\tif (strncmp(ptr, \"blacklist \", 10) == 0)\n\t\tptr += 10;\n\telse if (strncmp(ptr, \"blacklist-nolog \", 16) == 0)\n\t\tptr += 16;\n\telse if (strncmp(ptr, \"noblacklist \", 12) == 0)\n\t\tptr += 12;\n\telse if (strncmp(ptr, \"whitelist \", 10) == 0) {\n#ifdef HAVE_WHITELIST\t\t\n\t\tif (checkcfg(CFG_WHITELIST)) {\n\t\t\targ_whitelist = 1;\n\t\t\tptr += 10;\n\t\t}\n\t\telse\n\t\t\treturn 0;\n#else\t\t\n\t\treturn 0;\n#endif\n\t}\n\telse if (strncmp(ptr, \"read-only \", 10) == 0)\n\t\tptr += 10;\n\telse if (strncmp(ptr, \"read-write \", 11) == 0)\n\t\tptr += 11;\n\telse if (strncmp(ptr, \"noexec \", 7) == 0)\n\t\tptr += 7;\n\telse if (strncmp(ptr, \"tmpfs \", 6) == 0) {\n\t\tif (getuid() != 0) {\n\t\t\tfprintf(stderr, \"Error: tmpfs available only when running the sandbox as root\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tptr += 6;\n\t}\n\telse {\n\t\tif (lineno == 0)\n\t\t\tfprintf(stderr, \"Error: \\\"%s\\\" as a command line option is invalid\\n\", ptr);\n\t\telse if (fname != NULL)\n\t\t\tfprintf(stderr, \"Error: line %d in %s is invalid\\n\", lineno, fname);\n\t\telse\n\t\t\tfprintf(stderr, \"Error: line %d in the custom profile is invalid\\n\", lineno);\n\t\texit(1);\n\t}\n\n\t// some characters just don't belong in filenames\n\tinvalid_filename(ptr);\n\tif (strstr(ptr, \"..\")) {\n\t\tif (lineno == 0)\n\t\t\tfprintf(stderr, \"Error: \\\"%s\\\" is an invalid filename\\n\", ptr);\n\t\telse if (fname != NULL)\n\t\t\tfprintf(stderr, \"Error: line %d in %s is invalid\\n\", lineno, fname);\n\t\telse\n\t\t\tfprintf(stderr, \"Error: line %d in the custom profile is invalid\\n\", lineno);\n\t\texit(1);\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <dirent.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 913
        },
        "resolved": true,
        "details": {
          "function_name": "myexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/main.c",
          "lines": "137-149",
          "snippet": "static void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}",
          "includes": [
            "#include <sys/times.h>",
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int arg_command = 0;",
            "int arg_quiet = 0;",
            "pid_t sandbox_pid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/times.h>\n#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nint arg_command = 0;\nint arg_quiet = 0;\npid_t sandbox_pid;\n\nstatic void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: line %d in the custom profile is invalid\\n\"",
            "lineno"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: line %d in %s is invalid\\n\"",
            "lineno",
            "fname"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: \\\"%s\\\" is an invalid filename\\n\"",
            "ptr"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "ptr",
            "\"..\""
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invalid_filename",
          "args": [
            "ptr"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "invalid_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/util.c",
          "lines": "668-689",
          "snippet": "void invalid_filename(const char *fname) {\n\tEUID_ASSERT();\n\tassert(fname);\n\tconst char *ptr = fname;\n\n\tif (arg_debug_check_filename)\n\t\tprintf(\"Checking filename %s\\n\", fname);\n\n\tif (strncmp(ptr, \"${HOME}\", 7) == 0)\n\t\tptr = fname + 7;\n\telse if (strncmp(ptr, \"${PATH}\", 7) == 0)\n\t\tptr = fname + 7;\n\telse if (strcmp(fname, \"${DOWNLOADS}\") == 0)\n\t\treturn;\n\n\tint len = strlen(ptr);\n\t// file globbing ('*') is allowed\n\tif (strcspn(ptr, \"\\\\&!?\\\"'<>%^(){}[];,\") != (size_t)len) {\n\t\tfprintf(stderr, \"Error: \\\"%s\\\" is an invalid filename\\n\", ptr);\n\t\texit(1);\n\t}\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid invalid_filename(const char *fname) {\n\tEUID_ASSERT();\n\tassert(fname);\n\tconst char *ptr = fname;\n\n\tif (arg_debug_check_filename)\n\t\tprintf(\"Checking filename %s\\n\", fname);\n\n\tif (strncmp(ptr, \"${HOME}\", 7) == 0)\n\t\tptr = fname + 7;\n\telse if (strncmp(ptr, \"${PATH}\", 7) == 0)\n\t\tptr = fname + 7;\n\telse if (strcmp(fname, \"${DOWNLOADS}\") == 0)\n\t\treturn;\n\n\tint len = strlen(ptr);\n\t// file globbing ('*') is allowed\n\tif (strcspn(ptr, \"\\\\&!?\\\"'<>%^(){}[];,\") != (size_t)len) {\n\t\tfprintf(stderr, \"Error: \\\"%s\\\" is an invalid filename\\n\", ptr);\n\t\texit(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: line %d in the custom profile is invalid\\n\"",
            "lineno"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: line %d in %s is invalid\\n\"",
            "lineno",
            "fname"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: \\\"%s\\\" as a command line option is invalid\\n\"",
            "ptr"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: tmpfs available only when running the sandbox as root\\n\""
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"tmpfs \"",
            "6"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"noexec \"",
            "7"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"read-write \"",
            "11"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"read-only \"",
            "10"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "checkcfg",
          "args": [
            "CFG_WHITELIST"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "checkcfg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/checkcfg.c",
          "lines": "32-286",
          "snippet": "int checkcfg(int val) {\n\tassert(val < CFG_MAX);\n\tint line = 0;\n\n\tif (!initialized) {\n\t\t// initialize defaults\n\t\tint i;\n\t\tfor (i = 0; i < CFG_MAX; i++)\n\t\t\tcfg_val[i] = 1; // most of them are enabled by default\n\t\tcfg_val[CFG_RESTRICTED_NETWORK] = 0; // disabled by default\n\t\tcfg_val[CFG_FORCE_NONEWPRIVS] = 0; // disabled by default\n\t\tcfg_val[CFG_PRIVATE_BIN_NO_LOCAL] = 0; // disabled by default\n\t\t\n\t\t// open configuration file\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"%s/firejail.config\", SYSCONFDIR) == -1)\n\t\t\terrExit(\"asprintf\");\n\n\t\tFILE *fp = fopen(fname, \"r\");\n\t\tif (!fp) {\n#ifdef HAVE_GLOBALCFG\t\t\t\n\t\t\tfprintf(stderr, \"Error: Firejail configuration file %s not found\\n\", fname);\n\t\t\texit(1);\n#else\n\t\t\tinitialized = 1;\n\t\t\treturn\tcfg_val[val];\n#endif\t\n\t\t}\n\t\t\n\t\t// if the file exists, it should be owned by root\n\t\tstruct stat s;\n\t\tif (stat(fname, &s) == -1)\n\t\t\terrExit(\"stat\");\n\t\tif (s.st_uid != 0) {\n\t\t\tfprintf(stderr, \"Error: configuration file should be owned by root\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\t// read configuration file\n\t\tchar buf[MAX_READ];\n\t\twhile (fgets(buf,MAX_READ, fp)) {\n\t\t\tline++;\n\t\t\tif (*buf == '#' || *buf == '\\n') \n\t\t\t\tcontinue;\n\n\t\t\t// parse line\t\t\t\t\n\t\t\tchar *ptr = line_remove_spaces(buf);\n\t\t\tif (!ptr)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\t// file transfer\t\n\t\t\tif (strncmp(ptr, \"file-transfer \", 14) == 0) {\n\t\t\t\tif (strcmp(ptr + 14, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_FILE_TRANSFER] = 1;\n\t\t\t\telse if (strcmp(ptr + 14, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_FILE_TRANSFER] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// x11\n\t\t\telse if (strncmp(ptr, \"x11 \", 4) == 0) {\n\t\t\t\tif (strcmp(ptr + 4, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_X11] = 1;\n\t\t\t\telse if (strcmp(ptr + 4, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_X11] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// bind\n\t\t\telse if (strncmp(ptr, \"bind \", 5) == 0) {\n\t\t\t\tif (strcmp(ptr + 5, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_BIND] = 1;\n\t\t\t\telse if (strcmp(ptr + 5, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_BIND] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// user namespace\n\t\t\telse if (strncmp(ptr, \"userns \", 7) == 0) {\n\t\t\t\tif (strcmp(ptr + 7, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_USERNS] = 1;\n\t\t\t\telse if (strcmp(ptr + 7, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_USERNS] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// chroot\n\t\t\telse if (strncmp(ptr, \"chroot \", 7) == 0) {\n\t\t\t\tif (strcmp(ptr + 7, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_CHROOT] = 1;\n\t\t\t\telse if (strcmp(ptr + 7, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_CHROOT] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// nonewprivs\n\t\t\telse if (strncmp(ptr, \"force-nonewprivs \", 17) == 0) {\n\t\t\t\tif (strcmp(ptr + 17, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_SECCOMP] = 1;\n\t\t\t\telse if (strcmp(ptr + 17, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_SECCOMP] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// seccomp\n\t\t\telse if (strncmp(ptr, \"seccomp \", 8) == 0) {\n\t\t\t\tif (strcmp(ptr + 8, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_SECCOMP] = 1;\n\t\t\t\telse if (strcmp(ptr + 8, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_SECCOMP] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// whitelist\n\t\t\telse if (strncmp(ptr, \"whitelist \", 10) == 0) {\n\t\t\t\tif (strcmp(ptr + 10, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_WHITELIST] = 1;\n\t\t\t\telse if (strcmp(ptr + 10, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_WHITELIST] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// network\n\t\t\telse if (strncmp(ptr, \"network \", 8) == 0) {\n\t\t\t\tif (strcmp(ptr + 8, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_NETWORK] = 1;\n\t\t\t\telse if (strcmp(ptr + 8, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_NETWORK] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// network\n\t\t\telse if (strncmp(ptr, \"restricted-network \", 19) == 0) {\n\t\t\t\tif (strcmp(ptr + 19, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_RESTRICTED_NETWORK] = 1;\n\t\t\t\telse if (strcmp(ptr + 19, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_RESTRICTED_NETWORK] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// netfilter\n\t\t\telse if (strncmp(ptr, \"netfilter-default \", 18) == 0) {\n\t\t\t\tchar *fname = ptr + 18;\n\t\t\t\twhile (*fname == ' ' || *fname == '\\t')\n\t\t\t\t\tptr++;\n\t\t\t\tchar *end = strchr(fname, ' ');\n\t\t\t\tif (end)\n\t\t\t\t\t*end = '\\0';\n\t\t\t\t\n\t\t\t\t// is the file present?\n\t\t\t\tstruct stat s;\n\t\t\t\tif (stat(fname, &s) == -1) {\n\t\t\t\t\tfprintf(stderr, \"Error: netfilter-default file %s not available\\n\", fname);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tnetfilter_default = strdup(fname);\n\t\t\t\tif (!netfilter_default)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t\tif (arg_debug)\n\t\t\t\t\tprintf(\"netfilter default file %s\\n\", fname);\n\t\t\t}\n\t\t\t\n\t\t\t// Xephyr screen size\n\t\t\telse if (strncmp(ptr, \"xephyr-screen \", 14) == 0) {\n\t\t\t\t// expecting two numbers and an x between them\n\t\t\t\tint n1;\n\t\t\t\tint n2;\n\t\t\t\tint rv = sscanf(ptr + 14, \"%dx%d\", &n1, &n2);\n\t\t\t\tif (rv != 2)\n\t\t\t\t\tgoto errout;\n\t\t\t\tif (asprintf(&xephyr_screen, \"%dx%d\", n1, n2) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t}\n\t\n\t\t\t// xephyr window title\n\t\t\telse if (strncmp(ptr, \"xephyr-window-title \", 20) == 0) {\n\t\t\t\tif (strcmp(ptr + 20, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_XEPHYR_WINDOW_TITLE] = 1;\n\t\t\t\telse if (strcmp(ptr + 20, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_XEPHYR_WINDOW_TITLE] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t\t\n\t\t\t// Xephyr command extra parameters\n\t\t\telse if (strncmp(ptr, \"xephyr-extra-params \", 19) == 0) {\n\t\t\t\txephyr_extra_params = strdup(ptr + 19);\n\t\t\t\tif (!xephyr_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\t\t\t\n\t\t\t// quiet by default\n\t\t\telse if (strncmp(ptr, \"quiet-by-default \", 17) == 0) {\n\t\t\t\tif (strcmp(ptr + 17, \"yes\") == 0)\n\t\t\t\t\targ_quiet = 1;\n\t\t\t}\n\t\t\t// remount /proc and /sys\n\t\t\telse if (strncmp(ptr, \"remount-proc-sys \", 17) == 0) {\n\t\t\t\tif (strcmp(ptr + 17, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_REMOUNT_PROC_SYS] = 1;\n\t\t\t\telse if (strcmp(ptr + 17, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_REMOUNT_PROC_SYS] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\telse if (strncmp(ptr, \"overlayfs \", 10) == 0) {\n\t\t\t\tif (strcmp(ptr + 10, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_OVERLAYFS] = 1;\n\t\t\t\telse if (strcmp(ptr + 10, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_OVERLAYFS] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\telse if (strncmp(ptr, \"private-home \", 13) == 0) {\n\t\t\t\tif (strcmp(ptr + 13, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_PRIVATE_HOME] = 1;\n\t\t\t\telse if (strcmp(ptr + 13, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_PRIVATE_HOME] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\telse if (strncmp(ptr, \"chroot-desktop \", 15) == 0) {\n\t\t\t\tif (strcmp(ptr + 15, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_CHROOT_DESKTOP] = 1;\n\t\t\t\telse if (strcmp(ptr + 15, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_CHROOT_DESKTOP] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\telse if (strncmp(ptr, \"private-bin-no-local \", 21) == 0) {\n\t\t\t\tif (strcmp(ptr + 21, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_PRIVATE_BIN_NO_LOCAL] = 1;\n\t\t\t\telse if (strcmp(ptr + 21, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_PRIVATE_BIN_NO_LOCAL] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\telse\n\t\t\t\tgoto errout;\n\n\t\t\tfree(ptr);\n\t\t}\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t\tinitialized = 1;\n\t}\n\t\n\treturn cfg_val[val];\n\t\nerrout:\n\tfprintf(stderr, \"Error: invalid line %d in firejail configuration file\\n\", line );\n\texit(1);\n}",
          "includes": [
            "#include <linux/loop.h>",
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAX_READ 8192\t\t\t\t  // line buffer for profile files"
          ],
          "globals_used": [
            "static int initialized = 0;",
            "static int cfg_val[CFG_MAX];",
            "char *xephyr_screen = \"800x600\";",
            "char *xephyr_extra_params = \"\";",
            "char *netfilter_default = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/loop.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\n#define MAX_READ 8192\t\t\t\t  // line buffer for profile files\n\nstatic int initialized = 0;\nstatic int cfg_val[CFG_MAX];\nchar *xephyr_screen = \"800x600\";\nchar *xephyr_extra_params = \"\";\nchar *netfilter_default = NULL;\n\nint checkcfg(int val) {\n\tassert(val < CFG_MAX);\n\tint line = 0;\n\n\tif (!initialized) {\n\t\t// initialize defaults\n\t\tint i;\n\t\tfor (i = 0; i < CFG_MAX; i++)\n\t\t\tcfg_val[i] = 1; // most of them are enabled by default\n\t\tcfg_val[CFG_RESTRICTED_NETWORK] = 0; // disabled by default\n\t\tcfg_val[CFG_FORCE_NONEWPRIVS] = 0; // disabled by default\n\t\tcfg_val[CFG_PRIVATE_BIN_NO_LOCAL] = 0; // disabled by default\n\t\t\n\t\t// open configuration file\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"%s/firejail.config\", SYSCONFDIR) == -1)\n\t\t\terrExit(\"asprintf\");\n\n\t\tFILE *fp = fopen(fname, \"r\");\n\t\tif (!fp) {\n#ifdef HAVE_GLOBALCFG\t\t\t\n\t\t\tfprintf(stderr, \"Error: Firejail configuration file %s not found\\n\", fname);\n\t\t\texit(1);\n#else\n\t\t\tinitialized = 1;\n\t\t\treturn\tcfg_val[val];\n#endif\t\n\t\t}\n\t\t\n\t\t// if the file exists, it should be owned by root\n\t\tstruct stat s;\n\t\tif (stat(fname, &s) == -1)\n\t\t\terrExit(\"stat\");\n\t\tif (s.st_uid != 0) {\n\t\t\tfprintf(stderr, \"Error: configuration file should be owned by root\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\t// read configuration file\n\t\tchar buf[MAX_READ];\n\t\twhile (fgets(buf,MAX_READ, fp)) {\n\t\t\tline++;\n\t\t\tif (*buf == '#' || *buf == '\\n') \n\t\t\t\tcontinue;\n\n\t\t\t// parse line\t\t\t\t\n\t\t\tchar *ptr = line_remove_spaces(buf);\n\t\t\tif (!ptr)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\t// file transfer\t\n\t\t\tif (strncmp(ptr, \"file-transfer \", 14) == 0) {\n\t\t\t\tif (strcmp(ptr + 14, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_FILE_TRANSFER] = 1;\n\t\t\t\telse if (strcmp(ptr + 14, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_FILE_TRANSFER] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// x11\n\t\t\telse if (strncmp(ptr, \"x11 \", 4) == 0) {\n\t\t\t\tif (strcmp(ptr + 4, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_X11] = 1;\n\t\t\t\telse if (strcmp(ptr + 4, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_X11] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// bind\n\t\t\telse if (strncmp(ptr, \"bind \", 5) == 0) {\n\t\t\t\tif (strcmp(ptr + 5, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_BIND] = 1;\n\t\t\t\telse if (strcmp(ptr + 5, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_BIND] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// user namespace\n\t\t\telse if (strncmp(ptr, \"userns \", 7) == 0) {\n\t\t\t\tif (strcmp(ptr + 7, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_USERNS] = 1;\n\t\t\t\telse if (strcmp(ptr + 7, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_USERNS] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// chroot\n\t\t\telse if (strncmp(ptr, \"chroot \", 7) == 0) {\n\t\t\t\tif (strcmp(ptr + 7, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_CHROOT] = 1;\n\t\t\t\telse if (strcmp(ptr + 7, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_CHROOT] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// nonewprivs\n\t\t\telse if (strncmp(ptr, \"force-nonewprivs \", 17) == 0) {\n\t\t\t\tif (strcmp(ptr + 17, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_SECCOMP] = 1;\n\t\t\t\telse if (strcmp(ptr + 17, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_SECCOMP] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// seccomp\n\t\t\telse if (strncmp(ptr, \"seccomp \", 8) == 0) {\n\t\t\t\tif (strcmp(ptr + 8, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_SECCOMP] = 1;\n\t\t\t\telse if (strcmp(ptr + 8, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_SECCOMP] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// whitelist\n\t\t\telse if (strncmp(ptr, \"whitelist \", 10) == 0) {\n\t\t\t\tif (strcmp(ptr + 10, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_WHITELIST] = 1;\n\t\t\t\telse if (strcmp(ptr + 10, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_WHITELIST] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// network\n\t\t\telse if (strncmp(ptr, \"network \", 8) == 0) {\n\t\t\t\tif (strcmp(ptr + 8, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_NETWORK] = 1;\n\t\t\t\telse if (strcmp(ptr + 8, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_NETWORK] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// network\n\t\t\telse if (strncmp(ptr, \"restricted-network \", 19) == 0) {\n\t\t\t\tif (strcmp(ptr + 19, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_RESTRICTED_NETWORK] = 1;\n\t\t\t\telse if (strcmp(ptr + 19, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_RESTRICTED_NETWORK] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// netfilter\n\t\t\telse if (strncmp(ptr, \"netfilter-default \", 18) == 0) {\n\t\t\t\tchar *fname = ptr + 18;\n\t\t\t\twhile (*fname == ' ' || *fname == '\\t')\n\t\t\t\t\tptr++;\n\t\t\t\tchar *end = strchr(fname, ' ');\n\t\t\t\tif (end)\n\t\t\t\t\t*end = '\\0';\n\t\t\t\t\n\t\t\t\t// is the file present?\n\t\t\t\tstruct stat s;\n\t\t\t\tif (stat(fname, &s) == -1) {\n\t\t\t\t\tfprintf(stderr, \"Error: netfilter-default file %s not available\\n\", fname);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tnetfilter_default = strdup(fname);\n\t\t\t\tif (!netfilter_default)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t\tif (arg_debug)\n\t\t\t\t\tprintf(\"netfilter default file %s\\n\", fname);\n\t\t\t}\n\t\t\t\n\t\t\t// Xephyr screen size\n\t\t\telse if (strncmp(ptr, \"xephyr-screen \", 14) == 0) {\n\t\t\t\t// expecting two numbers and an x between them\n\t\t\t\tint n1;\n\t\t\t\tint n2;\n\t\t\t\tint rv = sscanf(ptr + 14, \"%dx%d\", &n1, &n2);\n\t\t\t\tif (rv != 2)\n\t\t\t\t\tgoto errout;\n\t\t\t\tif (asprintf(&xephyr_screen, \"%dx%d\", n1, n2) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t}\n\t\n\t\t\t// xephyr window title\n\t\t\telse if (strncmp(ptr, \"xephyr-window-title \", 20) == 0) {\n\t\t\t\tif (strcmp(ptr + 20, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_XEPHYR_WINDOW_TITLE] = 1;\n\t\t\t\telse if (strcmp(ptr + 20, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_XEPHYR_WINDOW_TITLE] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t\t\n\t\t\t// Xephyr command extra parameters\n\t\t\telse if (strncmp(ptr, \"xephyr-extra-params \", 19) == 0) {\n\t\t\t\txephyr_extra_params = strdup(ptr + 19);\n\t\t\t\tif (!xephyr_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\t\t\t\n\t\t\t// quiet by default\n\t\t\telse if (strncmp(ptr, \"quiet-by-default \", 17) == 0) {\n\t\t\t\tif (strcmp(ptr + 17, \"yes\") == 0)\n\t\t\t\t\targ_quiet = 1;\n\t\t\t}\n\t\t\t// remount /proc and /sys\n\t\t\telse if (strncmp(ptr, \"remount-proc-sys \", 17) == 0) {\n\t\t\t\tif (strcmp(ptr + 17, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_REMOUNT_PROC_SYS] = 1;\n\t\t\t\telse if (strcmp(ptr + 17, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_REMOUNT_PROC_SYS] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\telse if (strncmp(ptr, \"overlayfs \", 10) == 0) {\n\t\t\t\tif (strcmp(ptr + 10, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_OVERLAYFS] = 1;\n\t\t\t\telse if (strcmp(ptr + 10, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_OVERLAYFS] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\telse if (strncmp(ptr, \"private-home \", 13) == 0) {\n\t\t\t\tif (strcmp(ptr + 13, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_PRIVATE_HOME] = 1;\n\t\t\t\telse if (strcmp(ptr + 13, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_PRIVATE_HOME] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\telse if (strncmp(ptr, \"chroot-desktop \", 15) == 0) {\n\t\t\t\tif (strcmp(ptr + 15, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_CHROOT_DESKTOP] = 1;\n\t\t\t\telse if (strcmp(ptr + 15, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_CHROOT_DESKTOP] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\telse if (strncmp(ptr, \"private-bin-no-local \", 21) == 0) {\n\t\t\t\tif (strcmp(ptr + 21, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_PRIVATE_BIN_NO_LOCAL] = 1;\n\t\t\t\telse if (strcmp(ptr + 21, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_PRIVATE_BIN_NO_LOCAL] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\telse\n\t\t\t\tgoto errout;\n\n\t\t\tfree(ptr);\n\t\t}\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t\tinitialized = 1;\n\t}\n\t\n\treturn cfg_val[val];\n\t\nerrout:\n\tfprintf(stderr, \"Error: invalid line %d in firejail configuration file\\n\", line );\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"whitelist \"",
            "10"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"noblacklist \"",
            "12"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"blacklist-nolog \"",
            "16"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"blacklist \"",
            "10"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid sandbox name\\n\""
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cfg.name"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "join",
          "args": [
            "pid",
            "cfg.original_argc",
            "cfg.original_argv",
            "i + 1"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "join",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/join.c",
          "lines": "191-398",
          "snippet": "void join(pid_t pid, int argc, char **argv, int index) {\n\tEUID_ASSERT();\n\tchar *homedir = cfg.homedir;\n\t\n\textract_command(argc, argv, index);\n\tsignal (SIGTERM, signal_handler);\n\n\t// if the pid is that of a firejail  process, use the pid of the first child process\n\tEUID_ROOT();\n\tchar *comm = pid_proc_comm(pid);\n\tEUID_USER();\n\tif (comm) {\n\t\tif (strcmp(comm, \"firejail\") == 0) {\n\t\t\tpid_t child;\n\t\t\tif (find_child(pid, &child) == 0) {\n\t\t\t\tpid = child;\n\t\t\t\tprintf(\"Switching to pid %u, the first child process inside the sandbox\\n\", (unsigned) pid);\n\t\t\t}\n\t\t}\n\t\tfree(comm);\n\t}\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission is denied to join a sandbox created by a different user.\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tEUID_ROOT();\n\t// in user mode set caps seccomp, cpu, cgroup, etc\n\tif (getuid() != 0) {\n\t\textract_caps_seccomp(pid);\n\t\textract_cpu(pid);\n\t\textract_cgroup(pid);\n\t\textract_nogroups(pid);\n\t\textract_user_namespace(pid);\n\t}\n\t\n\t// set cgroup\n\tif (cfg.cgroup)\t// not available for uid 0\n\t\tset_cgroup(cfg.cgroup);\n\t\t\n\t// join namespaces\n\tif (arg_join_network) {\n\t\tif (join_namespace(pid, \"net\"))\n\t\t\texit(1);\n\t}\n\telse if (arg_join_filesystem) {\n\t\tif (join_namespace(pid, \"mnt\"))\n\t\t\texit(1);\n\t}\n\telse {\n\t\tif (join_namespace(pid, \"ipc\"))\n\t\t\texit(1);\n\t\tif (join_namespace(pid, \"net\"))\n\t\t\texit(1);\n\t\tif (join_namespace(pid, \"pid\"))\n\t\t\texit(1);\n\t\tif (join_namespace(pid, \"uts\"))\n\t\t\texit(1);\n\t\tif (join_namespace(pid, \"mnt\"))\n\t\t\texit(1);\n\t}\n\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// chroot into /proc/PID/root directory\n\t\tchar *rootdir;\n\t\tif (asprintf(&rootdir, \"/proc/%d/root\", pid) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\t\t\n\t\tint rv;\n\t\tif (!arg_join_network) {\n\t\t\trv = chroot(rootdir); // this will fail for processes in sandboxes not started with --chroot option\n\t\t\tif (rv == 0)\n\t\t\t\tprintf(\"changing root to %s\\n\", rootdir);\n\t\t}\n\t\t\n\t\tprctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0); // kill the child in case the parent died\n\t\tif (chdir(\"/\") < 0)\n\t\t\terrExit(\"chdir\");\n\t\tif (homedir) {\n\t\t\tstruct stat s;\n\t\t\tif (stat(homedir, &s) == 0) {\n\t\t\t\t/* coverity[toctou] */\n\t\t\t\tif (chdir(homedir) < 0)\n\t\t\t\t\terrExit(\"chdir\");\n\t\t\t}\n\t\t}\n\t\t\n\t\t// set cpu affinity\n\t\tif (cfg.cpus)\t// not available for uid 0\n\t\t\tset_cpu_affinity();\n\t\t\t\t\t\n\t\t// set caps filter\n\t\tif (apply_caps == 1)\t// not available for uid 0\n\t\t\tcaps_set(caps);\n#ifdef HAVE_SECCOMP\n\t\t// set protocol filter\n\t\tif (getuid() != 0)\n\t\t\tprotocol_filter_load(RUN_PROTOCOL_CFG);\n\t\tif (cfg.protocol) {\t// not available for uid 0\n\t\t\tprotocol_filter();\n\t\t}\n\t\t\t\t\n\t\t// set seccomp filter\n\t\tif (apply_seccomp == 1)\t// not available for uid 0\n\t\t\tseccomp_set();\n#endif\n\n\t\t// fix qt 4.8\n\t\tif (setenv(\"QT_X11_NO_MITSHM\", \"1\", 1) < 0)\n\t\t\terrExit(\"setenv\");\n\t\tif (setenv(\"container\", \"firejail\", 1) < 0) // LXC sets container=lxc,\n\t\t\terrExit(\"setenv\");\n\n\t\t// mount user namespace or drop privileges\n\t\tif (arg_noroot) {\t// not available for uid 0\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Joining user namespace\\n\");\n\t\t\tif (join_namespace(1, \"user\"))\n\t\t\t\texit(1);\n\n\t\t\t// user namespace resets capabilities\n\t\t\t// set caps filter\n\t\t\tif (apply_caps == 1)\t// not available for uid 0\n\t\t\t\tcaps_set(caps);\n\t\t}\n\t\telse \n\t\t\tdrop_privs(arg_nogroups);\t// nogroups not available for uid 0\n\n\n\t\t// set prompt color to green\n\t\tchar *prompt = getenv(\"FIREJAIL_PROMPT\");\n\t\tif (prompt && strcmp(prompt, \"yes\") == 0) {\n\t\t\t//export PS1='\\[\\e[1;32m\\][\\u@\\h \\W]\\$\\[\\e[0m\\] '\n\t\t\tif (setenv(\"PROMPT_COMMAND\", \"export PS1=\\\"\\\\[\\\\e[1;32m\\\\][\\\\u@\\\\h \\\\W]\\\\$\\\\[\\\\e[0m\\\\] \\\"\", 1) < 0)\n\t\t\t\terrExit(\"setenv\");\n\t\t}\n\t\t\n\t\t// set nice\n\t\tif (arg_nice) {\n\t\t\terrno = 0;\n\t\t\tint rv = nice(cfg.nice);\n\t\t\t(void) rv;\n\t\t\tif (errno) {\n\t\t\t\tfprintf(stderr, \"Warning: cannot set nice value\\n\");\n\t\t\t\terrno = 0;\n\t\t\t}\n\t\t}\n\n\t\t// run cmdline trough shell\n\t\tif (cfg.command_line == NULL) {\n\t\t\t// if the sandbox was started with --shell=none, it is possible we don't have a shell\n\t\t\t// inside the sandbox\n\t\t\tif (cfg.shell == NULL) {\n\t\t\t\tcfg.shell = guess_shell();\n\t\t\t\tif (!cfg.shell) {\n\t\t\t\t\tfprintf(stderr, \"Error: no POSIX shell found, please use --shell command line option\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t\n\t\t\tstruct stat s;\n\t\t\tif (stat(cfg.shell, &s) == -1)  {\n\t\t\t\tfprintf(stderr, \"Error: %s shell not found inside the sandbox\\n\", cfg.shell);\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tcfg.command_line = cfg.shell;\n\t\t\tcfg.window_title = cfg.shell;\n\t\t}\n\n\t\tint cwd = 0;\n\t\tif (cfg.cwd) {\n\t\t\tif (chdir(cfg.cwd) == 0)\n\t\t\t\tcwd = 1;\n\t\t}\n\n\t\tif (!cwd) {\n\t\t\tif (chdir(\"/\") < 0)\n\t\t\t\terrExit(\"chdir\");\n\t\t\tif (cfg.homedir) {\n\t\t\t\tstruct stat s;\n\t\t\t\tif (stat(cfg.homedir, &s) == 0) {\n\t\t\t\t\t/* coverity[toctou] */\n\t\t\t\t\tif (chdir(cfg.homedir) < 0)\n\t\t\t\t\t\terrExit(\"chdir\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstart_application();\n\n\t\t// it will never get here!!!\n\t}\n\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n\tflush_stdin();\n\texit(0);\n}",
          "includes": [
            "#include <errno.h>",
            "#include <sys/prctl.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int apply_caps = 0;",
            "static uint64_t caps = 0;",
            "static int apply_seccomp = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <sys/prctl.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\nstatic int apply_caps = 0;\nstatic uint64_t caps = 0;\nstatic int apply_seccomp = 0;\n\nvoid join(pid_t pid, int argc, char **argv, int index) {\n\tEUID_ASSERT();\n\tchar *homedir = cfg.homedir;\n\t\n\textract_command(argc, argv, index);\n\tsignal (SIGTERM, signal_handler);\n\n\t// if the pid is that of a firejail  process, use the pid of the first child process\n\tEUID_ROOT();\n\tchar *comm = pid_proc_comm(pid);\n\tEUID_USER();\n\tif (comm) {\n\t\tif (strcmp(comm, \"firejail\") == 0) {\n\t\t\tpid_t child;\n\t\t\tif (find_child(pid, &child) == 0) {\n\t\t\t\tpid = child;\n\t\t\t\tprintf(\"Switching to pid %u, the first child process inside the sandbox\\n\", (unsigned) pid);\n\t\t\t}\n\t\t}\n\t\tfree(comm);\n\t}\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission is denied to join a sandbox created by a different user.\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tEUID_ROOT();\n\t// in user mode set caps seccomp, cpu, cgroup, etc\n\tif (getuid() != 0) {\n\t\textract_caps_seccomp(pid);\n\t\textract_cpu(pid);\n\t\textract_cgroup(pid);\n\t\textract_nogroups(pid);\n\t\textract_user_namespace(pid);\n\t}\n\t\n\t// set cgroup\n\tif (cfg.cgroup)\t// not available for uid 0\n\t\tset_cgroup(cfg.cgroup);\n\t\t\n\t// join namespaces\n\tif (arg_join_network) {\n\t\tif (join_namespace(pid, \"net\"))\n\t\t\texit(1);\n\t}\n\telse if (arg_join_filesystem) {\n\t\tif (join_namespace(pid, \"mnt\"))\n\t\t\texit(1);\n\t}\n\telse {\n\t\tif (join_namespace(pid, \"ipc\"))\n\t\t\texit(1);\n\t\tif (join_namespace(pid, \"net\"))\n\t\t\texit(1);\n\t\tif (join_namespace(pid, \"pid\"))\n\t\t\texit(1);\n\t\tif (join_namespace(pid, \"uts\"))\n\t\t\texit(1);\n\t\tif (join_namespace(pid, \"mnt\"))\n\t\t\texit(1);\n\t}\n\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// chroot into /proc/PID/root directory\n\t\tchar *rootdir;\n\t\tif (asprintf(&rootdir, \"/proc/%d/root\", pid) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\t\t\n\t\tint rv;\n\t\tif (!arg_join_network) {\n\t\t\trv = chroot(rootdir); // this will fail for processes in sandboxes not started with --chroot option\n\t\t\tif (rv == 0)\n\t\t\t\tprintf(\"changing root to %s\\n\", rootdir);\n\t\t}\n\t\t\n\t\tprctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0); // kill the child in case the parent died\n\t\tif (chdir(\"/\") < 0)\n\t\t\terrExit(\"chdir\");\n\t\tif (homedir) {\n\t\t\tstruct stat s;\n\t\t\tif (stat(homedir, &s) == 0) {\n\t\t\t\t/* coverity[toctou] */\n\t\t\t\tif (chdir(homedir) < 0)\n\t\t\t\t\terrExit(\"chdir\");\n\t\t\t}\n\t\t}\n\t\t\n\t\t// set cpu affinity\n\t\tif (cfg.cpus)\t// not available for uid 0\n\t\t\tset_cpu_affinity();\n\t\t\t\t\t\n\t\t// set caps filter\n\t\tif (apply_caps == 1)\t// not available for uid 0\n\t\t\tcaps_set(caps);\n#ifdef HAVE_SECCOMP\n\t\t// set protocol filter\n\t\tif (getuid() != 0)\n\t\t\tprotocol_filter_load(RUN_PROTOCOL_CFG);\n\t\tif (cfg.protocol) {\t// not available for uid 0\n\t\t\tprotocol_filter();\n\t\t}\n\t\t\t\t\n\t\t// set seccomp filter\n\t\tif (apply_seccomp == 1)\t// not available for uid 0\n\t\t\tseccomp_set();\n#endif\n\n\t\t// fix qt 4.8\n\t\tif (setenv(\"QT_X11_NO_MITSHM\", \"1\", 1) < 0)\n\t\t\terrExit(\"setenv\");\n\t\tif (setenv(\"container\", \"firejail\", 1) < 0) // LXC sets container=lxc,\n\t\t\terrExit(\"setenv\");\n\n\t\t// mount user namespace or drop privileges\n\t\tif (arg_noroot) {\t// not available for uid 0\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Joining user namespace\\n\");\n\t\t\tif (join_namespace(1, \"user\"))\n\t\t\t\texit(1);\n\n\t\t\t// user namespace resets capabilities\n\t\t\t// set caps filter\n\t\t\tif (apply_caps == 1)\t// not available for uid 0\n\t\t\t\tcaps_set(caps);\n\t\t}\n\t\telse \n\t\t\tdrop_privs(arg_nogroups);\t// nogroups not available for uid 0\n\n\n\t\t// set prompt color to green\n\t\tchar *prompt = getenv(\"FIREJAIL_PROMPT\");\n\t\tif (prompt && strcmp(prompt, \"yes\") == 0) {\n\t\t\t//export PS1='\\[\\e[1;32m\\][\\u@\\h \\W]\\$\\[\\e[0m\\] '\n\t\t\tif (setenv(\"PROMPT_COMMAND\", \"export PS1=\\\"\\\\[\\\\e[1;32m\\\\][\\\\u@\\\\h \\\\W]\\\\$\\\\[\\\\e[0m\\\\] \\\"\", 1) < 0)\n\t\t\t\terrExit(\"setenv\");\n\t\t}\n\t\t\n\t\t// set nice\n\t\tif (arg_nice) {\n\t\t\terrno = 0;\n\t\t\tint rv = nice(cfg.nice);\n\t\t\t(void) rv;\n\t\t\tif (errno) {\n\t\t\t\tfprintf(stderr, \"Warning: cannot set nice value\\n\");\n\t\t\t\terrno = 0;\n\t\t\t}\n\t\t}\n\n\t\t// run cmdline trough shell\n\t\tif (cfg.command_line == NULL) {\n\t\t\t// if the sandbox was started with --shell=none, it is possible we don't have a shell\n\t\t\t// inside the sandbox\n\t\t\tif (cfg.shell == NULL) {\n\t\t\t\tcfg.shell = guess_shell();\n\t\t\t\tif (!cfg.shell) {\n\t\t\t\t\tfprintf(stderr, \"Error: no POSIX shell found, please use --shell command line option\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t\n\t\t\tstruct stat s;\n\t\t\tif (stat(cfg.shell, &s) == -1)  {\n\t\t\t\tfprintf(stderr, \"Error: %s shell not found inside the sandbox\\n\", cfg.shell);\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tcfg.command_line = cfg.shell;\n\t\t\tcfg.window_title = cfg.shell;\n\t\t}\n\n\t\tint cwd = 0;\n\t\tif (cfg.cwd) {\n\t\t\tif (chdir(cfg.cwd) == 0)\n\t\t\t\tcwd = 1;\n\t\t}\n\n\t\tif (!cwd) {\n\t\t\tif (chdir(\"/\") < 0)\n\t\t\t\terrExit(\"chdir\");\n\t\t\tif (cfg.homedir) {\n\t\t\t\tstruct stat s;\n\t\t\t\tif (stat(cfg.homedir, &s) == 0) {\n\t\t\t\t\t/* coverity[toctou] */\n\t\t\t\t\tif (chdir(cfg.homedir) < 0)\n\t\t\t\t\t\terrExit(\"chdir\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstart_application();\n\n\t\t// it will never get here!!!\n\t}\n\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n\tflush_stdin();\n\texit(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "cfg.original_argv[i]",
            "\"--\"",
            "2"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "guess_shell",
          "args": [],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "guess_shell",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/main.c",
          "lines": "836-853",
          "snippet": "char *guess_shell(void) {\n\tchar *shell = NULL;\n\t// shells in order of preference\n\tchar *shells[] = {\"/bin/bash\", \"/bin/csh\", \"/usr/bin/zsh\", \"/bin/sh\", \"/bin/ash\", NULL };\n\n\tint i = 0;\n\twhile (shells[i] != NULL) {\n\t\tstruct stat s;\n\t\t// access call checks as real UID/GID, not as effective UID/GID\n\t\tif (stat(shells[i], &s) == 0 && access(shells[i], R_OK) == 0) {\n\t\t\tshell = shells[i];\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\n\treturn shell;\n}",
          "includes": [
            "#include <sys/times.h>",
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/times.h>\n#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nchar *guess_shell(void) {\n\tchar *shell = NULL;\n\t// shells in order of preference\n\tchar *shells[] = {\"/bin/bash\", \"/bin/csh\", \"/usr/bin/zsh\", \"/bin/sh\", \"/bin/ash\", NULL };\n\n\tint i = 0;\n\twhile (shells[i] != NULL) {\n\t\tstruct stat s;\n\t\t// access call checks as real UID/GID, not as effective UID/GID\n\t\tif (stat(shells[i], &s) == 0 && access(shells[i], R_OK) == 0) {\n\t\t\tshell = shells[i];\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\n\treturn shell;\n}"
        }
      },
      {
        "call_info": {
          "callee": "name2pid",
          "args": [
            "ptr + 14",
            "&pid"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"join-or-start \"",
            "14"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Invalid rlimit option on line %d\\n\"",
            "lineno"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "ptr",
            "\"%u\"",
            "&cfg.rlimit_sigpending"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Invalid rlimit option on line %d\\n\"",
            "lineno"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "not_unsigned",
          "args": [
            "ptr"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "not_unsigned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/util.c",
          "lines": "376-390",
          "snippet": "int not_unsigned(const char *str) {\n\tEUID_ASSERT();\n\n\tint rv = 0;\n\tconst char *ptr = str;\n\twhile (*ptr != ' ' && *ptr != '\\t' && *ptr != '\\0') {\n\t\tif (!isdigit(*ptr)) {\n\t\t\trv = 1;\n\t\t\tbreak;\n\t\t}\n\t\tptr++;\n\t}\n\n\treturn rv;\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nint not_unsigned(const char *str) {\n\tEUID_ASSERT();\n\n\tint rv = 0;\n\tconst char *ptr = str;\n\twhile (*ptr != ' ' && *ptr != '\\t' && *ptr != '\\0') {\n\t\tif (!isdigit(*ptr)) {\n\t\t\trv = 1;\n\t\t\tbreak;\n\t\t}\n\t\tptr++;\n\t}\n\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"rlimit-sigpending \"",
            "18"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "ptr",
            "\"%u\"",
            "&cfg.rlimit_fsize"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Invalid rlimit option on line %d\\n\"",
            "lineno"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"rlimit-fsize \"",
            "13"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "ptr",
            "\"%u\"",
            "&cfg.rlimit_nproc"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Invalid rlimit option on line %d\\n\"",
            "lineno"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"rlimit-nproc \"",
            "13"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "ptr",
            "\"%u\"",
            "&cfg.rlimit_nofile"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Invalid rlimit option on line %d\\n\"",
            "lineno"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"rlimit-nofile \"",
            "14"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"rlimit\"",
            "6"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: bind feature is disabled in Firejail configuration file\\n\""
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Symbolic links are not allowed for bind command\\n\""
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_link",
          "args": [
            "dname2"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "is_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/util.c",
          "lines": "295-307",
          "snippet": "int is_link(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\tstruct stat s;\n\tif (lstat(fname, &s) == 0) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nint is_link(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\tstruct stat s;\n\tif (lstat(fname, &s) == 0) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid file name.\\n\""
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "dname2",
            "\"..\""
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "dname1",
            "\"..\""
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: missing second directory for bind\\n\""
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "split_comma",
          "args": [
            "dname1"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "split_comma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/util.c",
          "lines": "361-373",
          "snippet": "char *split_comma(char *str) {\n\tEUID_ASSERT();\n\tif (str == NULL || *str == '\\0')\n\t\treturn NULL;\n\tchar *ptr = strchr(str, ',');\n\tif (!ptr)\n\t\treturn NULL;\n\t*ptr = '\\0';\n\tptr++;\n\tif (*ptr == '\\0')\n\t\treturn NULL;\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nchar *split_comma(char *str) {\n\tEUID_ASSERT();\n\tif (str == NULL || *str == '\\0')\n\t\treturn NULL;\n\tchar *ptr = strchr(str, ',');\n\tif (!ptr)\n\t\treturn NULL;\n\t*ptr = '\\0';\n\tptr++;\n\tif (*ptr == '\\0')\n\t\treturn NULL;\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: --bind option is available only if running as root\\n\""
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"bind \"",
            "5"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_check_bin_list",
          "args": [],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "fs_check_bin_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_bin.c",
          "lines": "97-156",
          "snippet": "void fs_check_bin_list(void) {\n\tEUID_ASSERT();\n\tif (strstr(cfg.bin_private_keep, \"..\")) {\n\t\tfprintf(stderr, \"Error: invalid private bin list\\n\");\n\t\texit(1);\n\t}\n\t\n\tchar *dlist = strdup(cfg.bin_private_keep);\n\tif (!dlist)\n\t\terrExit(\"strdup\");\n\n\t// create a new list removing files not found\n\tchar *newlist = malloc(strlen(dlist) + 1 + 1); // +',' + '\\0'\n\tif (!newlist)\n\t\terrExit(\"malloc\");\n\t*newlist = '\\0';\n\tchar *newlistptr = newlist;\n\n\t// check the first file\n\tchar *ptr = strtok(dlist, \",\");\n\tint notfound = 0;\n\tif (check_dir_or_file(ptr)) {\n\t\t// file found, copy the name in the new list\n\t\tstrcpy(newlistptr, ptr);\n\t\tstrcat(newlistptr, \",\");\n\t\tnewlistptr += strlen(newlistptr);\n\t}\n\telse\n\t\tnotfound = 1;\n\n\t// check the rest of the list\n\twhile ((ptr = strtok(NULL, \",\")) != NULL) {\n\t\tif (check_dir_or_file(ptr)) {\n\t\t\t// file found, copy the name in the new list\n\t\t\tstrcpy(newlistptr, ptr);\n\t\t\tstrcat(newlistptr, \",\");\n\t\t\tnewlistptr += strlen(newlistptr);\n\t\t}\n\t\telse\n\t\t\tnotfound = 1;\n\t}\n\t\n\tif (*newlist == '\\0') {\n//\t\tfprintf(stderr, \"Warning: no --private-bin list executable found, option disabled\\n\");\n//\t\tcfg.bin_private_keep = NULL;\n//\t\targ_private_bin = 0;\n\t\tfree(newlist);\n\t}\n\telse {\n\t\tptr = strrchr(newlist, ',');\n\t\tassert(ptr);\n\t\t*ptr = '\\0';\n\t\tif (notfound && !arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: not all executables from --private-bin list were found. The current list is %s\\n\", newlist);\n\t\t\n\t\tcfg.bin_private_keep = newlist;\n\t}\n\t\n\tfree(dlist);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_check_bin_list(void) {\n\tEUID_ASSERT();\n\tif (strstr(cfg.bin_private_keep, \"..\")) {\n\t\tfprintf(stderr, \"Error: invalid private bin list\\n\");\n\t\texit(1);\n\t}\n\t\n\tchar *dlist = strdup(cfg.bin_private_keep);\n\tif (!dlist)\n\t\terrExit(\"strdup\");\n\n\t// create a new list removing files not found\n\tchar *newlist = malloc(strlen(dlist) + 1 + 1); // +',' + '\\0'\n\tif (!newlist)\n\t\terrExit(\"malloc\");\n\t*newlist = '\\0';\n\tchar *newlistptr = newlist;\n\n\t// check the first file\n\tchar *ptr = strtok(dlist, \",\");\n\tint notfound = 0;\n\tif (check_dir_or_file(ptr)) {\n\t\t// file found, copy the name in the new list\n\t\tstrcpy(newlistptr, ptr);\n\t\tstrcat(newlistptr, \",\");\n\t\tnewlistptr += strlen(newlistptr);\n\t}\n\telse\n\t\tnotfound = 1;\n\n\t// check the rest of the list\n\twhile ((ptr = strtok(NULL, \",\")) != NULL) {\n\t\tif (check_dir_or_file(ptr)) {\n\t\t\t// file found, copy the name in the new list\n\t\t\tstrcpy(newlistptr, ptr);\n\t\t\tstrcat(newlistptr, \",\");\n\t\t\tnewlistptr += strlen(newlistptr);\n\t\t}\n\t\telse\n\t\t\tnotfound = 1;\n\t}\n\t\n\tif (*newlist == '\\0') {\n//\t\tfprintf(stderr, \"Warning: no --private-bin list executable found, option disabled\\n\");\n//\t\tcfg.bin_private_keep = NULL;\n//\t\targ_private_bin = 0;\n\t\tfree(newlist);\n\t}\n\telse {\n\t\tptr = strrchr(newlist, ',');\n\t\tassert(ptr);\n\t\t*ptr = '\\0';\n\t\tif (notfound && !arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: not all executables from --private-bin list were found. The current list is %s\\n\", newlist);\n\t\t\n\t\tcfg.bin_private_keep = newlist;\n\t}\n\t\n\tfree(dlist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"private-bin \"",
            "12"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_check_etc_list",
          "args": [],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "fs_check_etc_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_etc.c",
          "lines": "65-94",
          "snippet": "void fs_check_etc_list(void) {\n\tEUID_ASSERT();\n\tif (strstr(cfg.etc_private_keep, \"..\")) {\n\t\tfprintf(stderr, \"Error: invalid private etc list\\n\");\n\t\texit(1);\n\t}\n\t\n\tchar *dlist = strdup(cfg.etc_private_keep);\n\tif (!dlist)\n\t\terrExit(\"strdup\");\n\t\n\t// build a new list only with the files found\n\tchar *newlist = malloc(strlen(cfg.etc_private_keep) + 1);\n\tif (!newlist)\n\t\terrExit(\"malloc\");\n\t*newlist = '\\0';\n\n\tchar *ptr = strtok(dlist, \",\");\n\tif (check_dir_or_file(ptr))\n\t\tstrcat(newlist, ptr);\n\twhile ((ptr = strtok(NULL, \",\")) != NULL) {\n\t\tif (check_dir_or_file(ptr)) {\n\t\t\tstrcat(newlist, \",\");\n\t\t\tstrcat(newlist, ptr);\n\t\t}\n\t}\n\tcfg.etc_private_keep = newlist;\n\t\n\tfree(dlist);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_check_etc_list(void) {\n\tEUID_ASSERT();\n\tif (strstr(cfg.etc_private_keep, \"..\")) {\n\t\tfprintf(stderr, \"Error: invalid private etc list\\n\");\n\t\texit(1);\n\t}\n\t\n\tchar *dlist = strdup(cfg.etc_private_keep);\n\tif (!dlist)\n\t\terrExit(\"strdup\");\n\t\n\t// build a new list only with the files found\n\tchar *newlist = malloc(strlen(cfg.etc_private_keep) + 1);\n\tif (!newlist)\n\t\terrExit(\"malloc\");\n\t*newlist = '\\0';\n\n\tchar *ptr = strtok(dlist, \",\");\n\tif (check_dir_or_file(ptr))\n\t\tstrcat(newlist, ptr);\n\twhile ((ptr = strtok(NULL, \",\")) != NULL) {\n\t\tif (check_dir_or_file(ptr)) {\n\t\t\tstrcat(newlist, \",\");\n\t\t\tstrcat(newlist, ptr);\n\t\t}\n\t}\n\tcfg.etc_private_keep = newlist;\n\t\n\tfree(dlist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: --private-etc and --writable-etc are mutually exclusive\\n\""
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"private-etc \"",
            "12"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x11_start",
          "args": [
            "cfg.original_argc",
            "cfg.original_argv"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "x11_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/x11.c",
          "lines": "584-604",
          "snippet": "void x11_start(int argc, char **argv) {\n\tEUID_ASSERT();\n\n\t// unfortunately, xpra does a number of weird things when started by root user!!!\n\tif (getuid() == 0) {\n\t\tfprintf(stderr, \"Error: X11 sandboxing is not available when running as root\\n\");\n\t\texit(1);\n\t}\n\n\t// check xpra\n\tif (x11_check_xpra() == 1)\n\t\tx11_start_xpra(argc, argv);\n\telse if (x11_check_xephyr() == 1)\n\t\tx11_start_xephyr(argc, argv);\n\telse {\n\t\tfprintf(stderr, \"\\nError: Xpra or Xephyr not found in /usr/bin directory, please install one of them:\\n\");\n\t\tfprintf(stderr, \"   Debian/Ubuntu/Mint: sudo apt-get install xpra\\n\");\n\t\tfprintf(stderr, \"   Debian/Ubuntu/Mint: sudo apt-get install xserver-xephyr\\n\");\n\t\texit(0);\n\t}\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <sys/mount.h>\n#include <dirent.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid x11_start(int argc, char **argv) {\n\tEUID_ASSERT();\n\n\t// unfortunately, xpra does a number of weird things when started by root user!!!\n\tif (getuid() == 0) {\n\t\tfprintf(stderr, \"Error: X11 sandboxing is not available when running as root\\n\");\n\t\texit(1);\n\t}\n\n\t// check xpra\n\tif (x11_check_xpra() == 1)\n\t\tx11_start_xpra(argc, argv);\n\telse if (x11_check_xephyr() == 1)\n\t\tx11_start_xephyr(argc, argv);\n\telse {\n\t\tfprintf(stderr, \"\\nError: Xpra or Xephyr not found in /usr/bin directory, please install one of them:\\n\");\n\t\tfprintf(stderr, \"   Debian/Ubuntu/Mint: sudo apt-get install xpra\\n\");\n\t\tfprintf(stderr, \"   Debian/Ubuntu/Mint: sudo apt-get install xserver-xephyr\\n\");\n\t\texit(0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "x11env",
            "\"yes\""
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"FIREJAIL_X11\""
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"x11\""
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x11_start_xpra",
          "args": [
            "cfg.original_argc",
            "cfg.original_argv"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "x11_start_xpra",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/x11.c",
          "lines": "387-582",
          "snippet": "void x11_start_xpra(int argc, char **argv) {\n\tEUID_ASSERT();\n\tint i;\n\tstruct stat s;\n\tpid_t client = 0;\n\tpid_t server = 0;\n\t\n\tsetenv(\"FIREJAIL_X11\", \"yes\", 1);\n\n\t// unfortunately, xpra does a number of weird things when started by root user!!!\n\tif (getuid() == 0) {\n\t\tfprintf(stderr, \"Error: X11 sandboxing is not available when running as root\\n\");\n\t\texit(1);\n\t}\n\tdrop_privs(0);\n\n\t// check xpra\n\tif (x11_check_xpra() == 0) {\n\t\tfprintf(stderr, \"\\nError: Xpra program was not found in /usr/bin directory, please install it:\\n\");\n\t\tfprintf(stderr, \"   Debian/Ubuntu/Mint: sudo apt-get install xpra\\n\");\n\t\texit(0);\n\t}\n\t\n\tint display = random_display_number();\n\tchar *display_str;\n\tif (asprintf(&display_str, \":%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// build the start command\n\tchar *server_argv[] = { \"xpra\", \"start\", display_str, \"--no-daemon\",  NULL };\n\n\tint fd_null = -1;\n\tif (arg_quiet) {\n\t\tfd_null = open(\"/dev/null\", O_RDWR);\n\t\tif (fd_null == -1)\n\t\t\terrExit(\"open\");\n\t}\n\n\t// start\n\tserver = fork();\n\tif (server < 0)\n\t\terrExit(\"fork\");\n\tif (server == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Starting xpra...\\n\");\n\n\t\tif (arg_quiet && fd_null != -1) {\n\t\t\tdup2(fd_null,0);\n\t\t\tdup2(fd_null,1);\n\t\t\tdup2(fd_null,2);\n\t\t}\n\t\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\t\n\t\texecvp(server_argv[0], server_argv);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\t// check X11 socket\n\tchar *fname;\n\tif (asprintf(&fname, \"/tmp/.X11-unix/X%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\tint n = 0;\n\t// wait for x11 server to start\n\twhile (++n < 10) {\n\t\tsleep(1);\n\t\tif (stat(fname, &s) == 0)\n\t\t\tbreak;\n\t}\n\t\n\tif (n == 10) {\n\t\tfprintf(stderr, \"Error: failed to start xpra\\n\");\n\t\texit(1);\n\t}\n\tfree(fname);\n\t\n\tif (arg_debug) {\n                printf(\"X11 sockets: \"); fflush(0);\n                int rv = system(\"ls /tmp/.X11-unix\");\n                (void) rv;\n        }\n\n\t// build attach command\n\tchar *attach_argv[] = { \"xpra\", \"--title=\\\"firejail x11 sandbox\\\"\", \"attach\", display_str, NULL };\n\n\t// run attach command\n\tclient = fork();\n\tif (client < 0)\n\t\terrExit(\"fork\");\n\tif (client == 0) {\n\t\tif (arg_quiet && fd_null != -1) {\n\t\t\tdup2(fd_null,0);\n\t\t\tdup2(fd_null,1);\n\t\t\tdup2(fd_null,2);\n\t\t}\n\n\t\tif (!arg_quiet)\n\t\t\tprintf(\"\\n*** Attaching to xpra display %d ***\\n\\n\", display);\n\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\t\n\t\texecvp(attach_argv[0], attach_argv);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\tsetenv(\"DISPLAY\", display_str, 1);\n\n\t// build jail command\n\tchar *firejail_argv[argc+2];\n\tint pos = 0;\n\tfor (i = 0; i < argc; i++) {\n\t\tif (strcmp(argv[i], \"--x11\") == 0)\n\t\t\tcontinue;\n\t\tif (strcmp(argv[i], \"--x11=xpra\") == 0)\n\t\t\tcontinue;\n\t\tif (strcmp(argv[i], \"--x11=xephyr\") == 0)\n\t\t\tcontinue;\n\t\tfirejail_argv[pos] = argv[i];\n\t\tpos++;\n\t}\n\tfirejail_argv[pos] = NULL;\n\n\tassert(pos < (argc+2));\n\tassert(!firejail_argv[pos]);\n\n\t// start jail\n\tpid_t jail = fork();\n\tif (jail < 0)\n\t\terrExit(\"fork\");\n\tif (jail == 0) {\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\t\n\t\tif (firejail_argv[0]) // shut up llvm scan-build\n\t\t\texecvp(firejail_argv[0], firejail_argv);\n\t\tperror(\"execvp\");\n\t\texit(1);\n\t}\n\n\tif (!arg_quiet)\n\t\tprintf(\"Xpra server pid %d, xpra client pid %d, jail %d\\n\", server, client, jail);\n\n\tsleep(1); // let jail start\n\n\t// wait for jail or server to end\n\twhile (1) {\n\t\tpid_t pid = wait(NULL);\n\n\t\tif (pid == jail) {\n\t\t\tchar *stop_argv[] = { \"xpra\", \"stop\", display_str, NULL };\n\t\t\tpid_t stop = fork();\n\t\t\tif (stop < 0)\n\t\t\t\terrExit(\"fork\");\n\t\t\tif (stop == 0) {\n\t\t\t\tif (arg_quiet && fd_null != -1) {\n\t\t\t\t\tdup2(fd_null,0);\n\t\t\t\t\tdup2(fd_null,1);\n\t\t\t\t\tdup2(fd_null,2);\n\t\t\t\t}\n\t\t\t\t// running without privileges - see drop_privs call above\n\t\t\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\t\n\t\t\t\texecvp(stop_argv[0], stop_argv);\n\t\t\t\tperror(\"execvp\");\n\t\t\t\t_exit(1);\n\t\t\t}\n\n\t\t\t// wait for xpra server to stop, 10 seconds limit\n\t\t\twhile (++n < 10) {\n\t\t\t\tsleep(1);\n\t\t\t\tpid = waitpid(server, NULL, WNOHANG);\n\t\t\t\tif (pid == server)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (arg_debug) {\n\t\t\t\tif (n == 10)\n\t\t\t\t\tprintf(\"failed to stop xpra server gratefully\\n\");\n\t\t\t\telse\n\t\t\t\t\tprintf(\"xpra server successfully stopped in %d secs\\n\", n);\n\t\t\t}\n\t\t\t\n\t\t\t// kill xpra server and xpra client\n\t\t\tkill(client, SIGTERM);\n\t\t\tkill(server, SIGTERM);\n\t\t\texit(0);\n\t\t}\n\t\telse if (pid == server) {\n\t\t\t// kill firejail process\n\t\t\tkill(jail, SIGTERM);\n\t\t\t// kill xpra client (should die with server, but...)\n\t\t\tkill(client, SIGTERM);\n\t\t\texit(0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <sys/mount.h>\n#include <dirent.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid x11_start_xpra(int argc, char **argv) {\n\tEUID_ASSERT();\n\tint i;\n\tstruct stat s;\n\tpid_t client = 0;\n\tpid_t server = 0;\n\t\n\tsetenv(\"FIREJAIL_X11\", \"yes\", 1);\n\n\t// unfortunately, xpra does a number of weird things when started by root user!!!\n\tif (getuid() == 0) {\n\t\tfprintf(stderr, \"Error: X11 sandboxing is not available when running as root\\n\");\n\t\texit(1);\n\t}\n\tdrop_privs(0);\n\n\t// check xpra\n\tif (x11_check_xpra() == 0) {\n\t\tfprintf(stderr, \"\\nError: Xpra program was not found in /usr/bin directory, please install it:\\n\");\n\t\tfprintf(stderr, \"   Debian/Ubuntu/Mint: sudo apt-get install xpra\\n\");\n\t\texit(0);\n\t}\n\t\n\tint display = random_display_number();\n\tchar *display_str;\n\tif (asprintf(&display_str, \":%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// build the start command\n\tchar *server_argv[] = { \"xpra\", \"start\", display_str, \"--no-daemon\",  NULL };\n\n\tint fd_null = -1;\n\tif (arg_quiet) {\n\t\tfd_null = open(\"/dev/null\", O_RDWR);\n\t\tif (fd_null == -1)\n\t\t\terrExit(\"open\");\n\t}\n\n\t// start\n\tserver = fork();\n\tif (server < 0)\n\t\terrExit(\"fork\");\n\tif (server == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Starting xpra...\\n\");\n\n\t\tif (arg_quiet && fd_null != -1) {\n\t\t\tdup2(fd_null,0);\n\t\t\tdup2(fd_null,1);\n\t\t\tdup2(fd_null,2);\n\t\t}\n\t\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\t\n\t\texecvp(server_argv[0], server_argv);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\t// check X11 socket\n\tchar *fname;\n\tif (asprintf(&fname, \"/tmp/.X11-unix/X%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\tint n = 0;\n\t// wait for x11 server to start\n\twhile (++n < 10) {\n\t\tsleep(1);\n\t\tif (stat(fname, &s) == 0)\n\t\t\tbreak;\n\t}\n\t\n\tif (n == 10) {\n\t\tfprintf(stderr, \"Error: failed to start xpra\\n\");\n\t\texit(1);\n\t}\n\tfree(fname);\n\t\n\tif (arg_debug) {\n                printf(\"X11 sockets: \"); fflush(0);\n                int rv = system(\"ls /tmp/.X11-unix\");\n                (void) rv;\n        }\n\n\t// build attach command\n\tchar *attach_argv[] = { \"xpra\", \"--title=\\\"firejail x11 sandbox\\\"\", \"attach\", display_str, NULL };\n\n\t// run attach command\n\tclient = fork();\n\tif (client < 0)\n\t\terrExit(\"fork\");\n\tif (client == 0) {\n\t\tif (arg_quiet && fd_null != -1) {\n\t\t\tdup2(fd_null,0);\n\t\t\tdup2(fd_null,1);\n\t\t\tdup2(fd_null,2);\n\t\t}\n\n\t\tif (!arg_quiet)\n\t\t\tprintf(\"\\n*** Attaching to xpra display %d ***\\n\\n\", display);\n\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\t\n\t\texecvp(attach_argv[0], attach_argv);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\tsetenv(\"DISPLAY\", display_str, 1);\n\n\t// build jail command\n\tchar *firejail_argv[argc+2];\n\tint pos = 0;\n\tfor (i = 0; i < argc; i++) {\n\t\tif (strcmp(argv[i], \"--x11\") == 0)\n\t\t\tcontinue;\n\t\tif (strcmp(argv[i], \"--x11=xpra\") == 0)\n\t\t\tcontinue;\n\t\tif (strcmp(argv[i], \"--x11=xephyr\") == 0)\n\t\t\tcontinue;\n\t\tfirejail_argv[pos] = argv[i];\n\t\tpos++;\n\t}\n\tfirejail_argv[pos] = NULL;\n\n\tassert(pos < (argc+2));\n\tassert(!firejail_argv[pos]);\n\n\t// start jail\n\tpid_t jail = fork();\n\tif (jail < 0)\n\t\terrExit(\"fork\");\n\tif (jail == 0) {\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\t\n\t\tif (firejail_argv[0]) // shut up llvm scan-build\n\t\t\texecvp(firejail_argv[0], firejail_argv);\n\t\tperror(\"execvp\");\n\t\texit(1);\n\t}\n\n\tif (!arg_quiet)\n\t\tprintf(\"Xpra server pid %d, xpra client pid %d, jail %d\\n\", server, client, jail);\n\n\tsleep(1); // let jail start\n\n\t// wait for jail or server to end\n\twhile (1) {\n\t\tpid_t pid = wait(NULL);\n\n\t\tif (pid == jail) {\n\t\t\tchar *stop_argv[] = { \"xpra\", \"stop\", display_str, NULL };\n\t\t\tpid_t stop = fork();\n\t\t\tif (stop < 0)\n\t\t\t\terrExit(\"fork\");\n\t\t\tif (stop == 0) {\n\t\t\t\tif (arg_quiet && fd_null != -1) {\n\t\t\t\t\tdup2(fd_null,0);\n\t\t\t\t\tdup2(fd_null,1);\n\t\t\t\t\tdup2(fd_null,2);\n\t\t\t\t}\n\t\t\t\t// running without privileges - see drop_privs call above\n\t\t\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\t\n\t\t\t\texecvp(stop_argv[0], stop_argv);\n\t\t\t\tperror(\"execvp\");\n\t\t\t\t_exit(1);\n\t\t\t}\n\n\t\t\t// wait for xpra server to stop, 10 seconds limit\n\t\t\twhile (++n < 10) {\n\t\t\t\tsleep(1);\n\t\t\t\tpid = waitpid(server, NULL, WNOHANG);\n\t\t\t\tif (pid == server)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (arg_debug) {\n\t\t\t\tif (n == 10)\n\t\t\t\t\tprintf(\"failed to stop xpra server gratefully\\n\");\n\t\t\t\telse\n\t\t\t\t\tprintf(\"xpra server successfully stopped in %d secs\\n\", n);\n\t\t\t}\n\t\t\t\n\t\t\t// kill xpra server and xpra client\n\t\t\tkill(client, SIGTERM);\n\t\t\tkill(server, SIGTERM);\n\t\t\texit(0);\n\t\t}\n\t\telse if (pid == server) {\n\t\t\t// kill firejail process\n\t\t\tkill(jail, SIGTERM);\n\t\t\t// kill xpra client (should die with server, but...)\n\t\t\tkill(client, SIGTERM);\n\t\t\texit(0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "x11env",
            "\"yes\""
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"FIREJAIL_X11\""
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"x11 xpra\""
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: --x11 feature is disabled in Firejail configuration file\\n\""
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"x11 xorg\""
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x11_start_xephyr",
          "args": [
            "cfg.original_argc",
            "cfg.original_argv"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "x11_start_xephyr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/x11.c",
          "lines": "187-385",
          "snippet": "void x11_start_xephyr(int argc, char **argv) {\n\tEUID_ASSERT();\n\tint i;\n\tstruct stat s;\n\tpid_t jail = 0;\n\tpid_t server = 0;\n\t\n\tsetenv(\"FIREJAIL_X11\", \"yes\", 1);\n\n\t// unfortunately, xephyr does a number of weird things when started by root user!!!\n\tif (getuid() == 0) {\n\t\tfprintf(stderr, \"Error: X11 sandboxing is not available when running as root\\n\");\n\t\texit(1);\n\t}\n\tdrop_privs(0);\n\n\t// check xephyr\n\tif (x11_check_xephyr() == 0) {\n\t\tfprintf(stderr, \"\\nError: Xephyr program was not found in /usr/bin directory, please install it:\\n\");\n\t\tfprintf(stderr, \"   Debian/Ubuntu/Mint: sudo apt-get install xserver-xephyr\\n\");\n\t\tfprintf(stderr, \"   Arch: sudo pacman -S xorg-server-xephyr\\n\");\n\t\texit(0);\n\t}\n\t\n\tint display = random_display_number();\n\tchar *display_str;\n\tif (asprintf(&display_str, \":%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\n\tassert(xephyr_screen);\n\tchar *server_argv[256] = { \"Xephyr\", \"-ac\", \"-br\", \"-noreset\", \"-screen\", xephyr_screen }; // rest initialyzed to NULL\n\tunsigned pos = 0;\n\twhile (server_argv[pos] != NULL) pos++;\n\tif (checkcfg(CFG_XEPHYR_WINDOW_TITLE)) {\n\t\tserver_argv[pos++] = \"-title\";\n\t\tserver_argv[pos++] = \"firejail x11 sandbox\";\n\t}\n\n\tassert(xephyr_extra_params); // should be \"\" if empty\n\n\t// parse xephyr_extra_params\n\t// very basic quoting support\n\tchar *temp = strdup(xephyr_extra_params);\n\tif (*xephyr_extra_params != '\\0') {\n\t\tif (!temp)\n\t\t\terrExit(\"strdup\");\n\t\tbool dquote = false;\n\t\tbool squote = false;\n\t\tfor (i = 0; i < (int) strlen(xephyr_extra_params); i++) {\n\t\t\tif (temp[i] == '\\\"') {\n\t\t\t\tdquote = !dquote;\n\t\t\t\tif (dquote) temp[i] = '\\0'; // replace closing quote by \\0\n\t\t\t}\n\t\t\tif (temp[i] == '\\'') {\n\t\t\t\tsquote = !squote;\n\t\t\t\tif (squote) temp[i] = '\\0'; // replace closing quote by \\0\n\t\t\t}\n\t\t\tif (!dquote && !squote && temp[i] == ' ') temp[i] = '\\0';\n\t\t\tif (dquote && squote) {\n\t\t\t\tfprintf(stderr, \"Error: mixed quoting found while parsing xephyr_extra_params\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\tif (dquote) {\n\t\t\tfprintf(stderr, \"Error: unclosed quote found while parsing xephyr_extra_params\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tfor (i = 0; i < (int) strlen(xephyr_extra_params)-1; i++) {\n\t\t\tif (pos >= (sizeof(server_argv)/sizeof(*server_argv)) - 2) {\n\t\t\t\tfprintf(stderr, \"Error: arg count limit exceeded while parsing xephyr_extra_params\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (temp[i] == '\\0' && (temp[i+1] == '\\\"' || temp[i+1] == '\\'')) server_argv[pos++] = temp + i + 2;\n\t\t\telse if (temp[i] == '\\0' && temp[i+1] != '\\0') server_argv[pos++] = temp + i + 1;\n\t\t}\n\t}\n\t\n\tserver_argv[pos++] = display_str;\n\tserver_argv[pos++] = NULL;\n\n\tassert(pos < (sizeof(server_argv)/sizeof(*server_argv))); // no overrun\n\tassert(server_argv[pos-1] == NULL); // last element is null\n\t\n\tif (arg_debug) {\n\t\tsize_t i = 0;\n\t\tprintf(\"xephyr server:\");\n\t\twhile (server_argv[i]!=NULL) {\n\t\t\tprintf(\" \\\"%s\\\"\", server_argv[i]);\n\t\t\ti++;\n\t\t}\n\t\tputchar('\\n');\n\t}\n\n\t// remove --x11 arg\n\tchar *jail_argv[argc+2];\n\tint j = 0;\n\tfor (i = 0; i < argc; i++) {\n\t\tif (strcmp(argv[i], \"--x11\") == 0)\n\t\t\tcontinue;\n\t\tif (strcmp(argv[i], \"--x11=xpra\") == 0)\n\t\t\tcontinue;\n\t\tif (strcmp(argv[i], \"--x11=xephyr\") == 0)\n\t\t\tcontinue;\n\t\tjail_argv[j] = argv[i];\n\t\tj++;\n\t}\n\tjail_argv[j] = NULL;\n\n\tassert(j < argc+2); // no overrun\n\n\tif (arg_debug) {\n\t\tsize_t i = 0;\n\t\tprintf(\"xephyr client:\");\n\t\twhile (jail_argv[i]!=NULL) {\n\t\t\tprintf(\" \\\"%s\\\"\", jail_argv[i]);\n\t\t\ti++;\n\t\t}\n\t\tputchar('\\n');\n\t}\n\t\n\tserver = fork();\n\tif (server < 0)\n\t\terrExit(\"fork\");\n\tif (server == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Starting xephyr...\\n\");\n\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\t\n\t\texecvp(server_argv[0], server_argv);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\tif (arg_debug)\n\t\tprintf(\"xephyr server pid %d\\n\", server);\n\n\t// check X11 socket\n\tchar *fname;\n\tif (asprintf(&fname, \"/tmp/.X11-unix/X%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\tint n = 0;\n\t// wait for x11 server to start\n\twhile (++n < 10) {\n\t\tsleep(1);\n\t\tif (stat(fname, &s) == 0)\n\t\t\tbreak;\n\t};\n\t\n\tif (n == 10) {\n\t\tfprintf(stderr, \"Error: failed to start xephyr\\n\");\n\t\texit(1);\n\t}\n\tfree(fname);\n\t\n\tif (arg_debug) {\n            \tprintf(\"X11 sockets: \"); fflush(0);\n            \tint rv = system(\"ls /tmp/.X11-unix\");\n            \t(void) rv;\n\t}\n\n\tsetenv(\"DISPLAY\", display_str, 1);\n\t// run attach command\n\tjail = fork();\n\tif (jail < 0)\n\t\terrExit(\"fork\");\n\tif (jail == 0) {\n\t\tif (!arg_quiet)\n\t\t\tprintf(\"\\n*** Attaching to Xephyr display %d ***\\n\\n\", display);\n\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\t\n\t\texecvp(jail_argv[0], jail_argv);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\t// cleanup\n\tfree(display_str);\n\tfree(temp);\n\n\t// wait for either server or jail termination\n\tpid_t pid = wait(NULL);\n\n\t// see which process terminated and kill other\n\tif (pid == server) {\n\t\tkill(jail, SIGTERM);\n\t} else if (pid == jail) {\n\t\tkill(server, SIGTERM);\n\t}\n\n\t// without this closing Xephyr window may mess your terminal:\n\t// \"monitoring\" process will release terminal before\n\t// jail process ends and releases terminal\n\twait(NULL); // fulneral\n\n\texit(0);\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <sys/mount.h>\n#include <dirent.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid x11_start_xephyr(int argc, char **argv) {\n\tEUID_ASSERT();\n\tint i;\n\tstruct stat s;\n\tpid_t jail = 0;\n\tpid_t server = 0;\n\t\n\tsetenv(\"FIREJAIL_X11\", \"yes\", 1);\n\n\t// unfortunately, xephyr does a number of weird things when started by root user!!!\n\tif (getuid() == 0) {\n\t\tfprintf(stderr, \"Error: X11 sandboxing is not available when running as root\\n\");\n\t\texit(1);\n\t}\n\tdrop_privs(0);\n\n\t// check xephyr\n\tif (x11_check_xephyr() == 0) {\n\t\tfprintf(stderr, \"\\nError: Xephyr program was not found in /usr/bin directory, please install it:\\n\");\n\t\tfprintf(stderr, \"   Debian/Ubuntu/Mint: sudo apt-get install xserver-xephyr\\n\");\n\t\tfprintf(stderr, \"   Arch: sudo pacman -S xorg-server-xephyr\\n\");\n\t\texit(0);\n\t}\n\t\n\tint display = random_display_number();\n\tchar *display_str;\n\tif (asprintf(&display_str, \":%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\n\tassert(xephyr_screen);\n\tchar *server_argv[256] = { \"Xephyr\", \"-ac\", \"-br\", \"-noreset\", \"-screen\", xephyr_screen }; // rest initialyzed to NULL\n\tunsigned pos = 0;\n\twhile (server_argv[pos] != NULL) pos++;\n\tif (checkcfg(CFG_XEPHYR_WINDOW_TITLE)) {\n\t\tserver_argv[pos++] = \"-title\";\n\t\tserver_argv[pos++] = \"firejail x11 sandbox\";\n\t}\n\n\tassert(xephyr_extra_params); // should be \"\" if empty\n\n\t// parse xephyr_extra_params\n\t// very basic quoting support\n\tchar *temp = strdup(xephyr_extra_params);\n\tif (*xephyr_extra_params != '\\0') {\n\t\tif (!temp)\n\t\t\terrExit(\"strdup\");\n\t\tbool dquote = false;\n\t\tbool squote = false;\n\t\tfor (i = 0; i < (int) strlen(xephyr_extra_params); i++) {\n\t\t\tif (temp[i] == '\\\"') {\n\t\t\t\tdquote = !dquote;\n\t\t\t\tif (dquote) temp[i] = '\\0'; // replace closing quote by \\0\n\t\t\t}\n\t\t\tif (temp[i] == '\\'') {\n\t\t\t\tsquote = !squote;\n\t\t\t\tif (squote) temp[i] = '\\0'; // replace closing quote by \\0\n\t\t\t}\n\t\t\tif (!dquote && !squote && temp[i] == ' ') temp[i] = '\\0';\n\t\t\tif (dquote && squote) {\n\t\t\t\tfprintf(stderr, \"Error: mixed quoting found while parsing xephyr_extra_params\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\tif (dquote) {\n\t\t\tfprintf(stderr, \"Error: unclosed quote found while parsing xephyr_extra_params\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tfor (i = 0; i < (int) strlen(xephyr_extra_params)-1; i++) {\n\t\t\tif (pos >= (sizeof(server_argv)/sizeof(*server_argv)) - 2) {\n\t\t\t\tfprintf(stderr, \"Error: arg count limit exceeded while parsing xephyr_extra_params\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (temp[i] == '\\0' && (temp[i+1] == '\\\"' || temp[i+1] == '\\'')) server_argv[pos++] = temp + i + 2;\n\t\t\telse if (temp[i] == '\\0' && temp[i+1] != '\\0') server_argv[pos++] = temp + i + 1;\n\t\t}\n\t}\n\t\n\tserver_argv[pos++] = display_str;\n\tserver_argv[pos++] = NULL;\n\n\tassert(pos < (sizeof(server_argv)/sizeof(*server_argv))); // no overrun\n\tassert(server_argv[pos-1] == NULL); // last element is null\n\t\n\tif (arg_debug) {\n\t\tsize_t i = 0;\n\t\tprintf(\"xephyr server:\");\n\t\twhile (server_argv[i]!=NULL) {\n\t\t\tprintf(\" \\\"%s\\\"\", server_argv[i]);\n\t\t\ti++;\n\t\t}\n\t\tputchar('\\n');\n\t}\n\n\t// remove --x11 arg\n\tchar *jail_argv[argc+2];\n\tint j = 0;\n\tfor (i = 0; i < argc; i++) {\n\t\tif (strcmp(argv[i], \"--x11\") == 0)\n\t\t\tcontinue;\n\t\tif (strcmp(argv[i], \"--x11=xpra\") == 0)\n\t\t\tcontinue;\n\t\tif (strcmp(argv[i], \"--x11=xephyr\") == 0)\n\t\t\tcontinue;\n\t\tjail_argv[j] = argv[i];\n\t\tj++;\n\t}\n\tjail_argv[j] = NULL;\n\n\tassert(j < argc+2); // no overrun\n\n\tif (arg_debug) {\n\t\tsize_t i = 0;\n\t\tprintf(\"xephyr client:\");\n\t\twhile (jail_argv[i]!=NULL) {\n\t\t\tprintf(\" \\\"%s\\\"\", jail_argv[i]);\n\t\t\ti++;\n\t\t}\n\t\tputchar('\\n');\n\t}\n\t\n\tserver = fork();\n\tif (server < 0)\n\t\terrExit(\"fork\");\n\tif (server == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Starting xephyr...\\n\");\n\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\t\n\t\texecvp(server_argv[0], server_argv);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\tif (arg_debug)\n\t\tprintf(\"xephyr server pid %d\\n\", server);\n\n\t// check X11 socket\n\tchar *fname;\n\tif (asprintf(&fname, \"/tmp/.X11-unix/X%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\tint n = 0;\n\t// wait for x11 server to start\n\twhile (++n < 10) {\n\t\tsleep(1);\n\t\tif (stat(fname, &s) == 0)\n\t\t\tbreak;\n\t};\n\t\n\tif (n == 10) {\n\t\tfprintf(stderr, \"Error: failed to start xephyr\\n\");\n\t\texit(1);\n\t}\n\tfree(fname);\n\t\n\tif (arg_debug) {\n            \tprintf(\"X11 sockets: \"); fflush(0);\n            \tint rv = system(\"ls /tmp/.X11-unix\");\n            \t(void) rv;\n\t}\n\n\tsetenv(\"DISPLAY\", display_str, 1);\n\t// run attach command\n\tjail = fork();\n\tif (jail < 0)\n\t\terrExit(\"fork\");\n\tif (jail == 0) {\n\t\tif (!arg_quiet)\n\t\t\tprintf(\"\\n*** Attaching to Xephyr display %d ***\\n\\n\", display);\n\n\t\t// running without privileges - see drop_privs call above\n\t\tassert(getenv(\"LD_PRELOAD\") == NULL);\t\n\t\texecvp(jail_argv[0], jail_argv);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\t// cleanup\n\tfree(display_str);\n\tfree(temp);\n\n\t// wait for either server or jail termination\n\tpid_t pid = wait(NULL);\n\n\t// see which process terminated and kill other\n\tif (pid == server) {\n\t\tkill(jail, SIGTERM);\n\t} else if (pid == jail) {\n\t\tkill(server, SIGTERM);\n\t}\n\n\t// without this closing Xephyr window may mess your terminal:\n\t// \"monitoring\" process will release terminal before\n\t// jail process ends and releases terminal\n\twait(NULL); // fulneral\n\n\texit(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "x11env",
            "\"yes\""
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"FIREJAIL_X11\""
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"x11 xephyr\""
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"x11 none\""
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_check_private_dir",
          "args": [],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "fs_check_private_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_home.c",
          "lines": "319-354",
          "snippet": "void fs_check_private_dir(void) {\n\tEUID_ASSERT();\n\tinvalid_filename(cfg.home_private);\n\t\n\t// Expand the home directory\n\tchar *tmp = expand_home(cfg.home_private, cfg.homedir);\n\tcfg.home_private = realpath(tmp, NULL);\n\tfree(tmp);\n\t\n\tif (!cfg.home_private\n\t || !is_dir(cfg.home_private)\n\t || is_link(cfg.home_private)\n\t || strstr(cfg.home_private, \"..\")) {\n\t\tfprintf(stderr, \"Error: invalid private directory\\n\");\n\t\texit(1);\n\t}\n\n\t// check home directory and chroot home directory have the same owner\n\tstruct stat s2;\n\tint rv = stat(cfg.home_private, &s2);\n\tif (rv < 0) {\n\t\tfprintf(stderr, \"Error: cannot find %s directory\\n\", cfg.home_private);\n\t\texit(1);\n\t}\n\n\tstruct stat s1;\n\trv = stat(cfg.homedir, &s1);\n\tif (rv < 0) {\n\t\tfprintf(stderr, \"Error: cannot find %s directory, full path name required\\n\", cfg.homedir);\n\t\texit(1);\n\t}\n\tif (s1.st_uid != s2.st_uid) {\n\t\tprintf(\"Error: --private directory should be owned by the current user\\n\");\n\t\texit(1);\n\t}\n}",
          "includes": [
            "#include <ftw.h>",
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *check_dir_or_file(const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ftw.h>\n#include <grp.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic char *check_dir_or_file(const char *name);\n\nvoid fs_check_private_dir(void) {\n\tEUID_ASSERT();\n\tinvalid_filename(cfg.home_private);\n\t\n\t// Expand the home directory\n\tchar *tmp = expand_home(cfg.home_private, cfg.homedir);\n\tcfg.home_private = realpath(tmp, NULL);\n\tfree(tmp);\n\t\n\tif (!cfg.home_private\n\t || !is_dir(cfg.home_private)\n\t || is_link(cfg.home_private)\n\t || strstr(cfg.home_private, \"..\")) {\n\t\tfprintf(stderr, \"Error: invalid private directory\\n\");\n\t\texit(1);\n\t}\n\n\t// check home directory and chroot home directory have the same owner\n\tstruct stat s2;\n\tint rv = stat(cfg.home_private, &s2);\n\tif (rv < 0) {\n\t\tfprintf(stderr, \"Error: cannot find %s directory\\n\", cfg.home_private);\n\t\texit(1);\n\t}\n\n\tstruct stat s1;\n\trv = stat(cfg.homedir, &s1);\n\tif (rv < 0) {\n\t\tfprintf(stderr, \"Error: cannot find %s directory, full path name required\\n\", cfg.homedir);\n\t\texit(1);\n\t}\n\tif (s1.st_uid != s2.st_uid) {\n\t\tprintf(\"Error: --private directory should be owned by the current user\\n\");\n\t\texit(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"private \"",
            "8"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"writable-var\""
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: private-etc and writable-etc are mutually exclusive\\n\""
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"writable-etc\""
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_cgroup",
          "args": [
            "ptr + 7"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "set_cgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/cgroup.c",
          "lines": "72-119",
          "snippet": "void set_cgroup(const char *path) {\n\tEUID_ASSERT();\n\t\n\tinvalid_filename(path);\n\t\n\t// path starts with /sys/fs/cgroup\n\tif (strncmp(path, \"/sys/fs/cgroup\", 14) != 0)\n\t\tgoto errout;\n\t\n\t// path ends in tasks\n\tchar *ptr = strstr(path, \"tasks\");\n\tif (!ptr)\n\t\tgoto errout;\n\tif (*(ptr + 5) != '\\0')\n\t\tgoto errout;\n\t\n\t// no .. traversal\n\tptr = strstr(path, \"..\");\n\tif (ptr)\n\t\tgoto errout;\n\t\n\t// tasks file exists\n\tstruct stat s;\n\tif (stat(path, &s) == -1)\n\t\tgoto errout;\n\t\n\t// task file belongs to the user running the sandbox\n\tif (s.st_uid != getuid() && s.st_gid != getgid())\n\t\tgoto errout2;\n\t\t\n\t// add the task to cgroup\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(path,\t\"a\");\n\tif (!fp)\n\t\tgoto errout;\n\tpid_t pid = getpid();\n\tint rv = fprintf(fp, \"%d\\n\", pid);\n\t(void) rv;\n\tfclose(fp);\n\treturn;\n\nerrout:\t\t\n\tfprintf(stderr, \"Error: invalid cgroup\\n\");\n\texit(1);\nerrout2:\t\t\n\tfprintf(stderr, \"Error: you don't have permissions to use this control group\\n\");\n\texit(1);\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include \"firejail.h\"\n\nvoid set_cgroup(const char *path) {\n\tEUID_ASSERT();\n\t\n\tinvalid_filename(path);\n\t\n\t// path starts with /sys/fs/cgroup\n\tif (strncmp(path, \"/sys/fs/cgroup\", 14) != 0)\n\t\tgoto errout;\n\t\n\t// path ends in tasks\n\tchar *ptr = strstr(path, \"tasks\");\n\tif (!ptr)\n\t\tgoto errout;\n\tif (*(ptr + 5) != '\\0')\n\t\tgoto errout;\n\t\n\t// no .. traversal\n\tptr = strstr(path, \"..\");\n\tif (ptr)\n\t\tgoto errout;\n\t\n\t// tasks file exists\n\tstruct stat s;\n\tif (stat(path, &s) == -1)\n\t\tgoto errout;\n\t\n\t// task file belongs to the user running the sandbox\n\tif (s.st_uid != getuid() && s.st_gid != getgid())\n\t\tgoto errout2;\n\t\t\n\t// add the task to cgroup\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(path,\t\"a\");\n\tif (!fp)\n\t\tgoto errout;\n\tpid_t pid = getpid();\n\tint rv = fprintf(fp, \"%d\\n\", pid);\n\t(void) rv;\n\tfclose(fp);\n\treturn;\n\nerrout:\t\t\n\tfprintf(stderr, \"Error: invalid cgroup\\n\");\n\texit(1);\nerrout2:\t\t\n\tfprintf(stderr, \"Error: you don't have permissions to use this control group\\n\");\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"cgroup \"",
            "7"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "ptr + 5"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"nice \"",
            "4"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_cpu_list",
          "args": [
            "ptr + 4"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "read_cpu_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/cpu.c",
          "lines": "42-72",
          "snippet": "void read_cpu_list(const char *str) {\n\tEUID_ASSERT();\n\t\n\tchar *tmp = strdup(str);\n\tif (tmp == NULL)\n\t\terrExit(\"strdup\");\n\t\n\tchar *ptr = tmp;\n\twhile (*ptr != '\\0') {\n\t\tif (*ptr == ',' || isdigit(*ptr))\n\t\t\t;\n\t\telse {\n\t\t\tfprintf(stderr, \"Error: invalid cpu list\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tptr++;\n\t}\n\t\n\tchar *start = tmp;\n\tptr = tmp;\n\twhile (*ptr != '\\0') {\n\t\tif (*ptr == ',') {\n\t\t\t*ptr = '\\0';\n\t\t\tset_cpu(start);\n\t\t\tstart = ptr + 1;\n\t\t}\n\t\tptr++;\n\t}\n\tset_cpu(start);\n\tfree(tmp);\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <sched.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <unistd.h>\n#include <sched.h>\n#include \"firejail.h\"\n\nvoid read_cpu_list(const char *str) {\n\tEUID_ASSERT();\n\t\n\tchar *tmp = strdup(str);\n\tif (tmp == NULL)\n\t\terrExit(\"strdup\");\n\t\n\tchar *ptr = tmp;\n\twhile (*ptr != '\\0') {\n\t\tif (*ptr == ',' || isdigit(*ptr))\n\t\t\t;\n\t\telse {\n\t\t\tfprintf(stderr, \"Error: invalid cpu list\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tptr++;\n\t}\n\t\n\tchar *start = tmp;\n\tptr = tmp;\n\twhile (*ptr != '\\0') {\n\t\tif (*ptr == ',') {\n\t\t\t*ptr = '\\0';\n\t\t\tset_cpu(start);\n\t\t\tstart = ptr + 1;\n\t\t}\n\t\tptr++;\n\t}\n\tset_cpu(start);\n\tfree(tmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"cpu \"",
            "4"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: up to 3 DNS servers can be specified\\n\""
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid DNS server IP address\\n\""
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoip",
          "args": [
            "ptr + 4",
            "&dns"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"dns \"",
            "4"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"hostname \"",
            "9"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "caps_check_list",
          "args": [
            "arg_caps_list",
            "NULL"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "caps_check_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/caps.c",
          "lines": "195-240",
          "snippet": "int caps_check_list(const char *clist, void (*callback)(int)) {\n\t// don't allow empty lists\n\tif (clist == NULL || *clist == '\\0') {\n\t\tfprintf(stderr, \"Error: empty capabilities lists are not allowed\\n\");\n\t\treturn -1;\n\t}\n\n\t// work on a copy of the string\n\tchar *str = strdup(clist);\n\tif (!str)\n\t\terrExit(\"strdup\");\n\n\tchar *ptr = str;\n\tchar *start = str;\n\twhile (*ptr != '\\0') {\n\t\tif (islower(*ptr) || isdigit(*ptr) || *ptr == '_')\n\t\t\t;\n\t\telse if (*ptr == ',') {\n\t\t\t*ptr = '\\0';\n\t\t\tint nr = caps_find_name(start);\n\t\t\tif (nr == -1) {\n\t\t\t\tfprintf(stderr, \"Error: capability %s not found\\n\", start);\n\t\t\t\tfree(str);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse if (callback != NULL)\n\t\t\t\tcallback(nr);\n\t\t\t\t\n\t\t\tstart = ptr + 1;\n\t\t}\n\t\tptr++;\n\t}\n\tif (*start != '\\0') {\n\t\tint nr = caps_find_name(start);\n\t\tif (nr == -1) {\n\t\t\tfprintf(stderr, \"Error: capability %s not found\\n\", start);\n\t\t\tfree(str);\t\n\t\t\treturn -1;\n\t\t}\n\t\telse if (callback != NULL)\n\t\t\tcallback(nr);\n\t}\n\n\tfree(str);\t\n\treturn 0;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>",
            "#include <stddef.h>",
            "#include <linux/filter.h>",
            "#include <errno.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n#include <stddef.h>\n#include <linux/filter.h>\n#include <errno.h>\n#include \"firejail.h\"\n\nint caps_check_list(const char *clist, void (*callback)(int)) {\n\t// don't allow empty lists\n\tif (clist == NULL || *clist == '\\0') {\n\t\tfprintf(stderr, \"Error: empty capabilities lists are not allowed\\n\");\n\t\treturn -1;\n\t}\n\n\t// work on a copy of the string\n\tchar *str = strdup(clist);\n\tif (!str)\n\t\terrExit(\"strdup\");\n\n\tchar *ptr = str;\n\tchar *start = str;\n\twhile (*ptr != '\\0') {\n\t\tif (islower(*ptr) || isdigit(*ptr) || *ptr == '_')\n\t\t\t;\n\t\telse if (*ptr == ',') {\n\t\t\t*ptr = '\\0';\n\t\t\tint nr = caps_find_name(start);\n\t\t\tif (nr == -1) {\n\t\t\t\tfprintf(stderr, \"Error: capability %s not found\\n\", start);\n\t\t\t\tfree(str);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse if (callback != NULL)\n\t\t\t\tcallback(nr);\n\t\t\t\t\n\t\t\tstart = ptr + 1;\n\t\t}\n\t\tptr++;\n\t}\n\tif (*start != '\\0') {\n\t\tint nr = caps_find_name(start);\n\t\tif (nr == -1) {\n\t\t\tfprintf(stderr, \"Error: capability %s not found\\n\", start);\n\t\t\tfree(str);\t\n\t\t\treturn -1;\n\t\t}\n\t\telse if (callback != NULL)\n\t\t\tcallback(nr);\n\t}\n\n\tfree(str);\t\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"strdup\""
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "ptr + 10"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"caps.keep \"",
            "10"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"strdup\""
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "ptr + 10"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"caps.drop \"",
            "10"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: user seccomp feature is disabled in Firejail configuration file\\n\""
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"strdup\""
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "ptr + 13"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"seccomp.keep \"",
            "13"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: user seccomp feature is disabled in Firejail configuration file\\n\""
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"strdup\""
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "ptr + 13"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"seccomp.drop \"",
            "13"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: user seccomp feature is disabled in Firejail configuration file\\n\""
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"strdup\""
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "ptr + 8"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"seccomp \"",
            "8"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "env_store",
          "args": [
            "ptr + 6",
            "RMENV"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "env_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/env.c",
          "lines": "146-185",
          "snippet": "void env_store(const char *str, ENV_OP op) {\n\tEUID_ASSERT();\n\tassert(str);\n\t\n\t// some basic checking\n\tif (*str == '\\0')\n\t\tgoto errexit;\n\tchar *ptr = strchr(str, '=');\n\tif (op == SETENV) {\n\t\tif (!ptr)\n\t\t\tgoto errexit;\n\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errexit;\n\t}\n\n\t// build list entry\n\tEnv *env = malloc(sizeof(Env));\n\tif (!env)\n\t\terrExit(\"malloc\");\n\tmemset(env, 0, sizeof(Env));\n\tenv->name = strdup(str);\n\tif (env->name == NULL)\n\t\terrExit(\"strdup\");\n\tif (op == SETENV) {\n\t\tchar *ptr2 = strchr(env->name, '=');\n\t\tassert(ptr2);\n\t\t*ptr2 = '\\0';\n\t\tenv->value = ptr2 + 1;\n\t}\n\tenv->op = op;\n\t\n\t// add entry to the list\n\tenv_add(env);\n\treturn;\n\t\nerrexit:\n\tfprintf(stderr, \"Error: invalid --env setting\\n\");\n\texit(1);\n}",
          "includes": [
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid env_store(const char *str, ENV_OP op) {\n\tEUID_ASSERT();\n\tassert(str);\n\t\n\t// some basic checking\n\tif (*str == '\\0')\n\t\tgoto errexit;\n\tchar *ptr = strchr(str, '=');\n\tif (op == SETENV) {\n\t\tif (!ptr)\n\t\t\tgoto errexit;\n\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errexit;\n\t}\n\n\t// build list entry\n\tEnv *env = malloc(sizeof(Env));\n\tif (!env)\n\t\terrExit(\"malloc\");\n\tmemset(env, 0, sizeof(Env));\n\tenv->name = strdup(str);\n\tif (env->name == NULL)\n\t\terrExit(\"strdup\");\n\tif (op == SETENV) {\n\t\tchar *ptr2 = strchr(env->name, '=');\n\t\tassert(ptr2);\n\t\t*ptr2 = '\\0';\n\t\tenv->value = ptr2 + 1;\n\t}\n\tenv->op = op;\n\t\n\t// add entry to the list\n\tenv_add(env);\n\treturn;\n\t\nerrexit:\n\tfprintf(stderr, \"Error: invalid --env setting\\n\");\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"rmenv \"",
            "6"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"env \"",
            "4"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: user seccomp feature is disabled in Firejail configuration file\\n\""
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "protocol_store",
          "args": [
            "ptr + 9"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "protocol_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/protocol.c",
          "lines": "121-156",
          "snippet": "void protocol_store(const char *prlist) {\n\tEUID_ASSERT();\n\tassert(prlist);\n\t\n\tif (cfg.protocol && !arg_quiet) {\n\t\tfprintf(stderr, \"Warning: a protocol list is present, the new list \\\"%s\\\" will not be installed\\n\", prlist);\n\t\treturn;\n\t}\n\t\n\t// temporary list\n\tchar *tmplist = strdup(prlist);\n\tif (!tmplist)\n\t\terrExit(\"strdup\");\n\t\n\t// check list\n\tchar *token = strtok(tmplist, \",\");\n\tif (!token)\n\t\tgoto errout;\n\t\t\n\twhile (token) {\n\t\tif (!is_protocol(token))\n\t\t\tgoto errout;\n\t\ttoken = strtok(NULL, \",\");\n\t}\t\n\tfree(tmplist);\n\t\n\t// store list\n\tcfg.protocol = strdup(prlist);\n\tif (!cfg.protocol)\n\t\terrExit(\"strdup\");\n\treturn;\n\t\t\nerrout:\n\tfprintf(stderr, \"Error: invalid protocol list\\n\");\n\texit(1);\n}",
          "includes": [
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"seccomp.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/socket.h>\n#include <sys/types.h>\n#include \"seccomp.h\"\n#include \"firejail.h\"\n\nvoid protocol_store(const char *prlist) {\n\tEUID_ASSERT();\n\tassert(prlist);\n\t\n\tif (cfg.protocol && !arg_quiet) {\n\t\tfprintf(stderr, \"Warning: a protocol list is present, the new list \\\"%s\\\" will not be installed\\n\", prlist);\n\t\treturn;\n\t}\n\t\n\t// temporary list\n\tchar *tmplist = strdup(prlist);\n\tif (!tmplist)\n\t\terrExit(\"strdup\");\n\t\n\t// check list\n\tchar *token = strtok(tmplist, \",\");\n\tif (!token)\n\t\tgoto errout;\n\t\t\n\twhile (token) {\n\t\tif (!is_protocol(token))\n\t\t\tgoto errout;\n\t\ttoken = strtok(NULL, \",\");\n\t}\t\n\tfree(tmplist);\n\t\n\t// store list\n\tcfg.protocol = strdup(prlist);\n\tif (!cfg.protocol)\n\t\terrExit(\"strdup\");\n\treturn;\n\t\t\nerrout:\n\tfprintf(stderr, \"Error: invalid protocol list\\n\");\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"protocol \"",
            "9"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"apparmor\""
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: networking features are disabled in Firejail configuration file\\n\""
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid IP address\\n\""
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoip",
          "args": [
            "ptr + 10",
            "&cfg.defaultgw"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"defaultgw \"",
            "10"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: networking features are disabled in Firejail configuration file\\n\""
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot configure the IP address twice for the same interface\\n\""
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: no network device configured\\n\""
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "last_bridge_configured",
          "args": [],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "last_bridge_configured",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/firejail.h",
          "lines": "244-255",
          "snippet": "static inline Bridge *last_bridge_configured(void) {\n\tif (cfg.bridge3.configured)\n\t\treturn &cfg.bridge3;\n\telse if (cfg.bridge2.configured)\n\t\treturn &cfg.bridge2;\n\telse if (cfg.bridge1.configured)\n\t\treturn &cfg.bridge1;\n\telse if (cfg.bridge0.configured)\n\t\treturn &cfg.bridge0;\n\telse\n\t\treturn NULL;\n}",
          "includes": [
            "#include \"../include/euid_common.h\"",
            "#include \"../include/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/euid_common.h\"\n#include \"../include/common.h\"\n\nstatic inline Bridge *last_bridge_configured(void) {\n\tif (cfg.bridge3.configured)\n\t\treturn &cfg.bridge3;\n\telse if (cfg.bridge2.configured)\n\t\treturn &cfg.bridge2;\n\telse if (cfg.bridge1.configured)\n\t\treturn &cfg.bridge1;\n\telse if (cfg.bridge0.configured)\n\t\treturn &cfg.bridge0;\n\telse\n\t\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"ip6 \"",
            "4"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: networking features are disabled in Firejail configuration file\\n\""
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid IP address\\n\""
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoip",
          "args": [
            "ptr + 3",
            "&br->ipsandbox"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr + 3",
            "\"none\""
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot configure the IP address twice for the same interface\\n\""
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: no network device configured\\n\""
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"ip \"",
            "3"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: networking features are disabled in Firejail configuration file\\n\""
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid mtu value\\n\""
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "ptr + 4",
            "\"%d\"",
            "&br->mtu"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: no network device configured\\n\""
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"mtu \"",
            "4"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: networking features are disabled in Firejail configuration file\\n\""
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid MAC address\\n\""
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomac",
          "args": [
            "ptr + 4",
            "br->macsandbox"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot configure the MAC address twice for the same interface\\n\""
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mac_not_zero",
          "args": [
            "br->macsandbox"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: no network device configured\\n\""
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"mac \"",
            "4"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: networking features are disabled in Firejail configuration file\\n\""
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: IP range addresses not in network range\\n\""
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_netrange",
          "args": [
            "br->iprange_end",
            "br->ip",
            "br->mask"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_netrange",
          "args": [
            "br->iprange_start",
            "br->ip",
            "br->mask"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid IP range\\n\""
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoip",
          "args": [
            "secondip",
            "&br->iprange_end"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoip",
          "args": [
            "firstip",
            "&br->iprange_start"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid IP range\\n\""
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot configure the IP range twice for the same interface\\n\""
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: no network device configured\\n\""
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"iprange \"",
            "8"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: networking features are disabled in Firejail configuration file\\n\""
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: no veth-name configured\\n\""
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"strdup\""
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "ptr + 10"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: no network device configured\\n\""
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"veth-name \"",
            "10"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: networking features are disabled in Firejail configuration file\\n\""
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_configure_bridge",
          "args": [
            "br",
            "ptr + 4"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "net_configure_bridge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/network_main.c",
          "lines": "29-82",
          "snippet": "void net_configure_bridge(Bridge *br, char *dev_name) {\n\tassert(br);\n\tassert(dev_name);\n\n\tbr->dev = dev_name;\n\n\t// check the bridge device exists\n\tchar sysbridge[30 + strlen(br->dev)];\n\tsprintf(sysbridge, \"/sys/class/net/%s/bridge\", br->dev);\n\tstruct stat s;\n\tint rv = stat(sysbridge, &s);\n\tif (rv == 0) {\n\t\t// this is a bridge device\n\t\tbr->macvlan = 0;\n\t}\n\telse {\n\t\t// is this a regular Ethernet interface\n\t\tif (if_nametoindex(br->dev) > 0) {\n\t\t\tbr->macvlan = 1;\n\t\t\tchar *newname;\n\t\t\tif (asprintf(&newname, \"%s-%u\", br->devsandbox, getpid()) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tbr->devsandbox = newname;\n\t\t}\t\t\t\n\t\telse {\n\t\t\tfprintf(stderr, \"Error: cannot find network device %s\\n\", br->dev);\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// allow unconfigured interfaces\n\tif (net_get_if_addr(br->dev, &br->ip, &br->mask, br->mac, &br->mtu)) {\n\t\tfprintf(stderr, \"Warning: the network interface %s is not configured\\n\", br->dev);\n\t\tbr->configured = 1;\n\t\tbr->arg_ip_none = 1;\n\t\treturn;\n\t}\n\tif (arg_debug) {\n\t\tif (br->macvlan == 0)\n\t\t\tprintf(\"Bridge device %s at %d.%d.%d.%d/%d\\n\",\n\t\t\t\tbr->dev, PRINT_IP(br->ip), mask2bits(br->mask));\n\t\telse\n\t\t\tprintf(\"macvlan parent device %s at %d.%d.%d.%d/%d\\n\",\n\t\t\t\tbr->dev, PRINT_IP(br->ip), mask2bits(br->mask));\n\t}\n\t\n\tuint32_t range = ~br->mask + 1;\t\t  // the number of potential addresses\n\t// this software is not supported for /31 networks\n\tif (range < 4) {\n\t\tfprintf(stderr, \"Error: the software is not supported for /31 networks\\n\");\n\t\texit(1);\n\t}\n\tbr->configured = 1;\n}",
          "includes": [
            "#include <net/if.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/if.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid net_configure_bridge(Bridge *br, char *dev_name) {\n\tassert(br);\n\tassert(dev_name);\n\n\tbr->dev = dev_name;\n\n\t// check the bridge device exists\n\tchar sysbridge[30 + strlen(br->dev)];\n\tsprintf(sysbridge, \"/sys/class/net/%s/bridge\", br->dev);\n\tstruct stat s;\n\tint rv = stat(sysbridge, &s);\n\tif (rv == 0) {\n\t\t// this is a bridge device\n\t\tbr->macvlan = 0;\n\t}\n\telse {\n\t\t// is this a regular Ethernet interface\n\t\tif (if_nametoindex(br->dev) > 0) {\n\t\t\tbr->macvlan = 1;\n\t\t\tchar *newname;\n\t\t\tif (asprintf(&newname, \"%s-%u\", br->devsandbox, getpid()) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tbr->devsandbox = newname;\n\t\t}\t\t\t\n\t\telse {\n\t\t\tfprintf(stderr, \"Error: cannot find network device %s\\n\", br->dev);\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// allow unconfigured interfaces\n\tif (net_get_if_addr(br->dev, &br->ip, &br->mask, br->mac, &br->mtu)) {\n\t\tfprintf(stderr, \"Warning: the network interface %s is not configured\\n\", br->dev);\n\t\tbr->configured = 1;\n\t\tbr->arg_ip_none = 1;\n\t\treturn;\n\t}\n\tif (arg_debug) {\n\t\tif (br->macvlan == 0)\n\t\t\tprintf(\"Bridge device %s at %d.%d.%d.%d/%d\\n\",\n\t\t\t\tbr->dev, PRINT_IP(br->ip), mask2bits(br->mask));\n\t\telse\n\t\t\tprintf(\"macvlan parent device %s at %d.%d.%d.%d/%d\\n\",\n\t\t\t\tbr->dev, PRINT_IP(br->ip), mask2bits(br->mask));\n\t}\n\t\n\tuint32_t range = ~br->mask + 1;\t\t  // the number of potential addresses\n\t// this software is not supported for /31 networks\n\tif (range < 4) {\n\t\tfprintf(stderr, \"Error: the software is not supported for /31 networks\\n\");\n\t\texit(1);\n\t}\n\tbr->configured = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: maximum 4 network devices are allowed\\n\""
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot attach to lo device\\n\""
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr + 4",
            "\"lo\""
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: only \\\"net none\\\" is allowed to non-root users\\n\""
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: only \\\"net none\\\" is allowed to non-root users\\n\""
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"net \"",
            "4"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: networking features are disabled in Firejail configuration file\\n\""
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"net none\""
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: networking features are disabled in Firejail configuration file\\n\""
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_netfilter_file",
          "args": [
            "arg_netfilter6_file"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "check_netfilter_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/netfilter.c",
          "lines": "46-60",
          "snippet": "void check_netfilter_file(const char *fname) {\n\tEUID_ASSERT();\n\tinvalid_filename(fname);\n\t\n\tif (is_dir(fname) || is_link(fname) || strstr(fname, \"..\")) {\n\t\tfprintf(stderr, \"Error: invalid network filter file\\n\");\n\t\texit(1);\n\t}\n\n\t// access call checks as real UID/GID, not as effective UID/GID\n\tif (access(fname, R_OK)) {\n\t\tfprintf(stderr, \"Error: cannot access network filter file\\n\");\n\t\texit(1);\n\t}\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid check_netfilter_file(const char *fname) {\n\tEUID_ASSERT();\n\tinvalid_filename(fname);\n\t\n\tif (is_dir(fname) || is_link(fname) || strstr(fname, \"..\")) {\n\t\tfprintf(stderr, \"Error: invalid network filter file\\n\");\n\t\texit(1);\n\t}\n\n\t// access call checks as real UID/GID, not as effective UID/GID\n\tif (access(fname, R_OK)) {\n\t\tfprintf(stderr, \"Error: cannot access network filter file\\n\");\n\t\texit(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"strdup\""
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "ptr + 11"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"netfilter6 \"",
            "11"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: networking features are disabled in Firejail configuration file\\n\""
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"strdup\""
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "ptr + 10"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"netfilter \"",
            "10"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: networking features are disabled in Firejail configuration file\\n\""
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"netfilter\""
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"no3d\""
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"nosound\""
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"nogroups\""
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"private-tmp\""
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"private-dev\""
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"allusers\""
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: private-home is disabled in Firejail configuration file\\n\""
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_check_home_list",
          "args": [],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "fs_check_home_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_home.c",
          "lines": "549-569",
          "snippet": "void fs_check_home_list(void) {\n\tif (strstr(cfg.home_private_keep, \"..\")) {\n\t\tfprintf(stderr, \"Error: invalid private-home list\\n\");\n\t\texit(1);\n\t}\n\n\tchar *dlist = strdup(cfg.home_private_keep);\n\tif (!dlist)\n\t\terrExit(\"strdup\");\n\n\tchar *ptr = strtok(dlist, \",\");\n\tchar *tmp = check_dir_or_file(ptr);\n\tfree(tmp);\n\n\twhile ((ptr = strtok(NULL, \",\")) != NULL) {\n\t\ttmp = check_dir_or_file(ptr);\n\t\tfree(tmp);\n\t}\n\n\tfree(dlist);\n}",
          "includes": [
            "#include <ftw.h>",
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ftw.h>\n#include <grp.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_check_home_list(void) {\n\tif (strstr(cfg.home_private_keep, \"..\")) {\n\t\tfprintf(stderr, \"Error: invalid private-home list\\n\");\n\t\texit(1);\n\t}\n\n\tchar *dlist = strdup(cfg.home_private_keep);\n\tif (!dlist)\n\t\terrExit(\"strdup\");\n\n\tchar *ptr = strtok(dlist, \",\");\n\tchar *tmp = check_dir_or_file(ptr);\n\tfree(tmp);\n\n\twhile ((ptr = strtok(NULL, \",\")) != NULL) {\n\t\ttmp = check_dir_or_file(ptr);\n\t\tfree(tmp);\n\t}\n\n\tfree(dlist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"private-home \"",
            "13"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"private\""
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"tracelog\""
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"shell none\""
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"caps.drop all\""
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"caps\""
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: user seccomp feature is disabled in Firejail configuration file\\n\""
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"seccomp\""
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"nonewprivs\""
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: user namespace feature is disabled in Firejail configuration file\\n\""
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_user_namespace",
          "args": [],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "check_user_namespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/main.c",
          "lines": "234-254",
          "snippet": "void check_user_namespace(void) {\n\tEUID_ASSERT();\n\tif (getuid() == 0) {\n\t\tfprintf(stderr, \"Error: --noroot option cannot be used when starting the sandbox as root.\\n\");\n\t\texit(1);\n\t}\n\t\n\t// test user namespaces available in the kernel\n\tstruct stat s1;\n\tstruct stat s2;\n\tstruct stat s3;\n\tif (stat(\"/proc/self/ns/user\", &s1) == 0 &&\n\t    stat(\"/proc/self/uid_map\", &s2) == 0 &&\n\t    stat(\"/proc/self/gid_map\", &s3) == 0)\n\t\targ_noroot = 1;\n\telse {\n\t\tif (!arg_quiet || arg_debug)\n\t\t\tfprintf(stderr, \"Warning: user namespaces not available in the current kernel.\\n\");\n\t\targ_noroot = 0;\n\t}\n}",
          "includes": [
            "#include <sys/times.h>",
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int arg_debug = 0;",
            "int arg_noroot = 0;",
            "int arg_quiet = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/times.h>\n#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nint arg_debug = 0;\nint arg_noroot = 0;\nint arg_quiet = 0;\n\nvoid check_user_namespace(void) {\n\tEUID_ASSERT();\n\tif (getuid() == 0) {\n\t\tfprintf(stderr, \"Error: --noroot option cannot be used when starting the sandbox as root.\\n\");\n\t\texit(1);\n\t}\n\t\n\t// test user namespaces available in the kernel\n\tstruct stat s1;\n\tstruct stat s2;\n\tstruct stat s3;\n\tif (stat(\"/proc/self/ns/user\", &s1) == 0 &&\n\t    stat(\"/proc/self/uid_map\", &s2) == 0 &&\n\t    stat(\"/proc/self/gid_map\", &s3) == 0)\n\t\targ_noroot = 1;\n\telse {\n\t\tif (!arg_quiet || arg_debug)\n\t\t\tfprintf(stderr, \"Warning: user namespaces not available in the current kernel.\\n\");\n\t\targ_noroot = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"noroot\""
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr",
            "\"ipc-namespace\""
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid sandbox name\\n\""
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cfg.name"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"name \"",
            "5"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_mkfile",
          "args": [
            "ptr + 7"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "fs_mkfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_mkdir.c",
          "lines": "93-136",
          "snippet": "void fs_mkfile(const char *name) {\n\tEUID_ASSERT();\n\t\n\t// check file name\n\tinvalid_filename(name);\n\tchar *expanded = expand_home(name, cfg.homedir);\n\tif (strncmp(expanded, cfg.homedir, strlen(cfg.homedir)) != 0) {\n\t\tfprintf(stderr, \"Error: only files in user home are supported by mkfile\\n\");\n\t\texit(1);\n\t}\n\n\tstruct stat s;\n\tif (stat(expanded, &s) == 0) {\n\t\t// file exists, do nothing\n\t\tgoto doexit;\n\t}\n\n\t// create file\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// drop privileges\n\t\tdrop_privs(0);\n\n\t\tFILE *fp = fopen(expanded, \"w\");\n\t\tif (!fp)\n\t\t\tfprintf(stderr, \"Warning: cannot create %s file\\n\", expanded);\n\t\telse {\n\t\t\tint fd = fileno(fp);\n\t\t\tif (fd == -1)\n\t\t\t\terrExit(\"fileno\");\n\t\t\tint rv = fchmod(fd, 0600);\n\t\t\t(void) rv;\n\t\t\tfclose(fp);\n\t\t}\n\t\t_exit(0);\n\t}\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n\ndoexit:\n\tfree(expanded);\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/wait.h>",
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/wait.h>\n#include <grp.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid fs_mkfile(const char *name) {\n\tEUID_ASSERT();\n\t\n\t// check file name\n\tinvalid_filename(name);\n\tchar *expanded = expand_home(name, cfg.homedir);\n\tif (strncmp(expanded, cfg.homedir, strlen(cfg.homedir)) != 0) {\n\t\tfprintf(stderr, \"Error: only files in user home are supported by mkfile\\n\");\n\t\texit(1);\n\t}\n\n\tstruct stat s;\n\tif (stat(expanded, &s) == 0) {\n\t\t// file exists, do nothing\n\t\tgoto doexit;\n\t}\n\n\t// create file\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// drop privileges\n\t\tdrop_privs(0);\n\n\t\tFILE *fp = fopen(expanded, \"w\");\n\t\tif (!fp)\n\t\t\tfprintf(stderr, \"Warning: cannot create %s file\\n\", expanded);\n\t\telse {\n\t\t\tint fd = fileno(fp);\n\t\t\tif (fd == -1)\n\t\t\t\terrExit(\"fileno\");\n\t\t\tint rv = fchmod(fd, 0600);\n\t\t\t(void) rv;\n\t\t\tfclose(fp);\n\t\t}\n\t\t_exit(0);\n\t}\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n\ndoexit:\n\tfree(expanded);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"mkfile \"",
            "7"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_mkdir",
          "args": [
            "ptr + 6"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "fs_mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_mkdir.c",
          "lines": "57-91",
          "snippet": "void fs_mkdir(const char *name) {\n\tEUID_ASSERT();\n\t\n\t// check directory name\n\tinvalid_filename(name);\n\tchar *expanded = expand_home(name, cfg.homedir);\n\tif (strncmp(expanded, cfg.homedir, strlen(cfg.homedir)) != 0) {\n\t\tfprintf(stderr, \"Error: only directories in user home are supported by mkdir\\n\");\n\t\texit(1);\n\t}\n\n\tstruct stat s;\n\tif (stat(expanded, &s) == 0) {\n\t\t// file exists, do nothing\n\t\tgoto doexit;\n\t}\n\n\t// create directory\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// drop privileges\n\t\tdrop_privs(0);\n\n\t\t// create directory\n\t\tmkdir_recursive(expanded);\n\t\t_exit(0);\n\t}\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n\ndoexit:\n\tfree(expanded);\n}",
          "includes": [
            "#include <string.h>",
            "#include <sys/wait.h>",
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <sys/wait.h>\n#include <grp.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid fs_mkdir(const char *name) {\n\tEUID_ASSERT();\n\t\n\t// check directory name\n\tinvalid_filename(name);\n\tchar *expanded = expand_home(name, cfg.homedir);\n\tif (strncmp(expanded, cfg.homedir, strlen(cfg.homedir)) != 0) {\n\t\tfprintf(stderr, \"Error: only directories in user home are supported by mkdir\\n\");\n\t\texit(1);\n\t}\n\n\tstruct stat s;\n\tif (stat(expanded, &s) == 0) {\n\t\t// file exists, do nothing\n\t\tgoto doexit;\n\t}\n\n\t// create directory\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// drop privileges\n\t\tdrop_privs(0);\n\n\t\t// create directory\n\t\tmkdir_recursive(expanded);\n\t\t_exit(0);\n\t}\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n\ndoexit:\n\tfree(expanded);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"mkdir \"",
            "6"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: maximum %d --ignore options are permitted\\n\"",
            "MAX_PROFILE_IGNORE"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid ignore option\\n\""
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "ptr + 7"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "\"ignore \"",
            "7"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ptr",
            "cfg.profile_ignore[i]",
            "strlen(cfg.profile_ignore[i])"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cfg.profile_ignore[i]"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <dirent.h>\n#include \"firejail.h\"\n\nint profile_check_line(char *ptr, int lineno, const char *fname) {\n\tEUID_ASSERT();\n\t\n\t// check ignore list\n\tint i;\n\tfor (i = 0; i < MAX_PROFILE_IGNORE; i++) {\n\t\tif (cfg.profile_ignore[i] == NULL)\n\t\t\tbreak;\n\t\t\n\t\tif (strncmp(ptr, cfg.profile_ignore[i], strlen(cfg.profile_ignore[i])) == 0)\n\t\t\treturn 0;\t// ignore line\n\t}\n\t\n\tif (strncmp(ptr, \"ignore \", 7) == 0) {\n\t\tchar *str = strdup(ptr + 7);\n\t\tif (*str == '\\0') {\n\t\t\tfprintf(stderr, \"Error: invalid ignore option\\n\");\n\t\t\texit(1);\n\t\t}\n\t\t// find an empty entry in profile_ignore array\n\t\tint j;\n\t\tfor (j = 0; j < MAX_PROFILE_IGNORE; j++) {\n\t\t\tif (cfg.profile_ignore[j] == NULL) \n\t\t\t\tbreak;\n\t\t}\n\t\tif (j >= MAX_PROFILE_IGNORE) {\n\t\t\tfprintf(stderr, \"Error: maximum %d --ignore options are permitted\\n\", MAX_PROFILE_IGNORE);\n\t\t\texit(1);\n\t\t}\n\t\t// ... and configure it\n\t\telse \n\t\t\tcfg.profile_ignore[j] = str;\n\n\t\treturn 0;\n\t}\n\n\t// mkdir \n\tif (strncmp(ptr, \"mkdir \", 6) == 0) {\n\t\tfs_mkdir(ptr + 6);\n\t\treturn 1;\n\t}\n\t// mkfile \n\tif (strncmp(ptr, \"mkfile \", 7) == 0) {\n\t\tfs_mkfile(ptr + 7);\n\t\treturn 1;\n\t}\n\t// sandbox name\n\telse if (strncmp(ptr, \"name \", 5) == 0) {\n\t\tcfg.name = ptr + 5;\n\t\tif (strlen(cfg.name) == 0) {\n\t\t\tfprintf(stderr, \"Error: invalid sandbox name\\n\");\n\t\t\texit(1);\n\t\t}\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"ipc-namespace\") == 0) {\n\t\targ_ipc = 1;\n\t\treturn 0;\n\t}\n\t// seccomp, caps, private, user namespace\n\telse if (strcmp(ptr, \"noroot\") == 0) {\n#if HAVE_USERNS\n\t\tif (checkcfg(CFG_USERNS))\n\t\t\tcheck_user_namespace();\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: user namespace feature is disabled in Firejail configuration file\\n\");\n#endif\n\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nonewprivs\") == 0) {\n\t\targ_nonewprivs = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"seccomp\") == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP))\n\t\t\targ_seccomp = 1;\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: user seccomp feature is disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"caps\") == 0) {\n\t\targ_caps_default_filter = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"caps.drop all\") == 0) {\n\t\targ_caps_drop_all = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"shell none\") == 0) {\n\t\targ_shell_none = 1;\n\t\treturn 0;\n\t}\t\n\telse if (strcmp(ptr, \"tracelog\") == 0) {\n\t\targ_tracelog = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"private\") == 0) {\n\t\targ_private = 1;\n\t\treturn 0;\n\t}\n\tif (strncmp(ptr, \"private-home \", 13) == 0) {\n#ifdef HAVE_PRIVATE_HOME\n\t\tif (checkcfg(CFG_PRIVATE_HOME)) {\n\t\t\tcfg.home_private_keep = ptr + 13;\n\t\t\tfs_check_home_list();\n\t\t\targ_private = 1;\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: private-home is disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"allusers\") == 0) {\n\t\targ_allusers = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"private-dev\") == 0) {\n\t\targ_private_dev = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"private-tmp\") == 0) {\n\t\targ_private_tmp = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nogroups\") == 0) {\n\t\targ_nogroups = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"nosound\") == 0) {\n\t\targ_nosound = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"no3d\") == 0) {\n\t\targ_no3d = 1;\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"netfilter\") == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK))\n\t\t\targ_netfilter = 1;\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strncmp(ptr, \"netfilter \", 10) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\targ_netfilter = 1;\n\t\t\targ_netfilter_file = strdup(ptr + 10);\n\t\t\tif (!arg_netfilter_file)\n\t\t\t\terrExit(\"strdup\");\n\t\t\tcheck_netfilter_file(arg_netfilter_file);\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strncmp(ptr, \"netfilter6 \", 11) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\targ_netfilter6 = 1;\n\t\t\targ_netfilter6_file = strdup(ptr + 11);\n\t\t\tif (!arg_netfilter6_file)\n\t\t\t\terrExit(\"strdup\");\n\t\t\tcheck_netfilter_file(arg_netfilter6_file);\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strcmp(ptr, \"net none\") == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\targ_nonetwork  = 1;\n\t\t\tcfg.bridge0.configured = 0;\n\t\t\tcfg.bridge1.configured = 0;\n\t\t\tcfg.bridge2.configured = 0;\n\t\t\tcfg.bridge3.configured = 0;\n\t\t\tcfg.interface0.configured = 0;\n\t\t\tcfg.interface1.configured = 0;\n\t\t\tcfg.interface2.configured = 0;\n\t\t\tcfg.interface3.configured = 0;\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\telse if (strncmp(ptr, \"net \", 4) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n#ifdef HAVE_NETWORK_RESTRICTED\n\t\t\t// compile time restricted networking\n\t\t\tif (getuid() != 0) {\n\t\t\t\tfprintf(stderr, \"Error: only \\\"net none\\\" is allowed to non-root users\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n#endif\n\t\t\t// run time restricted networking\n\t\t\tif (checkcfg(CFG_RESTRICTED_NETWORK) && getuid() != 0) {\n\t\t\t\tfprintf(stderr, \"Error: only \\\"net none\\\" is allowed to non-root users\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t\n\t\t\tif (strcmp(ptr + 4, \"lo\") == 0) {\n\t\t\t\tfprintf(stderr, \"Error: cannot attach to lo device\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tBridge *br;\n\t\t\tif (cfg.bridge0.configured == 0)\n\t\t\t\tbr = &cfg.bridge0;\n\t\t\telse if (cfg.bridge1.configured == 0)\n\t\t\t\tbr = &cfg.bridge1;\n\t\t\telse if (cfg.bridge2.configured == 0)\n\t\t\t\tbr = &cfg.bridge2;\n\t\t\telse if (cfg.bridge3.configured == 0)\n\t\t\t\tbr = &cfg.bridge3;\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"Error: maximum 4 network devices are allowed\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tnet_configure_bridge(br, ptr + 4);\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\t\n\telse if (strncmp(ptr, \"veth-name \", 10) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tbr->veth_name = strdup(ptr + 10);\n\t\t\tif (br->veth_name == NULL)\n\t\t\t\terrExit(\"strdup\");\n\t\t\tif (*br->veth_name == '\\0') {\n\t\t\t\tfprintf(stderr, \"Error: no veth-name configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"iprange \", 8) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (br->iprange_start || br->iprange_end) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the IP range twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// parse option arguments\n\t\t\tchar *firstip = ptr + 8;\n\t\t\tchar *secondip = firstip;\n\t\t\twhile (*secondip != '\\0') {\n\t\t\t\tif (*secondip == ',')\n\t\t\t\t\tbreak;\n\t\t\t\tsecondip++;\n\t\t\t}\n\t\t\tif (*secondip == '\\0') {\n\t\t\t\tfprintf(stderr, \"Error: invalid IP range\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t*secondip = '\\0';\n\t\t\tsecondip++;\n\t\t\t\n\t\t\t// check addresses\n\t\t\tif (atoip(firstip, &br->iprange_start) || atoip(secondip, &br->iprange_end) ||\n\t\t\t    br->iprange_start >= br->iprange_end) {\n\t\t\t\tfprintf(stderr, \"Error: invalid IP range\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (in_netrange(br->iprange_start, br->ip, br->mask) || in_netrange(br->iprange_end, br->ip, br->mask)) {\n\t\t\t\tfprintf(stderr, \"Error: IP range addresses not in network range\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\n\n\telse if (strncmp(ptr, \"mac \", 4) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t\n\t\t\tif (mac_not_zero(br->macsandbox)) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the MAC address twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// read the address\n\t\t\tif (atomac(ptr + 4, br->macsandbox)) {\n\t\t\t\tfprintf(stderr, \"Error: invalid MAC address\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"mtu \", 4) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t\n\t\t\tif (sscanf(ptr + 4, \"%d\", &br->mtu) != 1 || br->mtu < 576 || br->mtu > 9198) {\n\t\t\t\tfprintf(stderr, \"Error: invalid mtu value\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"ip \", 3) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (br->arg_ip_none || br->ipsandbox) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the IP address twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// configure this IP address for the last bridge defined\n\t\t\tif (strcmp(ptr + 3, \"none\") == 0)\n\t\t\t\tbr->arg_ip_none = 1;\n\t\t\telse {\n\t\t\t\tif (atoip(ptr + 3, &br->ipsandbox)) {\n\t\t\t\t\tfprintf(stderr, \"Error: invalid IP address\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"ip6 \", 4) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tBridge *br = last_bridge_configured();\n\t\t\tif (br == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: no network device configured\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (br->arg_ip_none || br->ip6sandbox) {\n\t\t\t\tfprintf(stderr, \"Error: cannot configure the IP address twice for the same interface\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// configure this IP address for the last bridge defined\n\t\t\t// todo: verify ipv6 syntax\n\t\t\tbr->ip6sandbox = ptr + 4;\n//\t\t\tif (atoip(argv[i] + 5, &br->ipsandbox)) {\n//\t\t\t\tfprintf(stderr, \"Error: invalid IP address\\n\");\n//\t\t\t\texit(1);\n//\t\t\t}\n\t\t\t\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\n\telse if (strncmp(ptr, \"defaultgw \", 10) == 0) {\n#ifdef HAVE_NETWORK\n\t\tif (checkcfg(CFG_NETWORK)) {\n\t\t\tif (atoip(ptr + 10, &cfg.defaultgw)) {\n\t\t\t\tfprintf(stderr, \"Error: invalid IP address\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: networking features are disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"apparmor\") == 0) {\n#ifdef HAVE_APPARMOR\t\t\n\t\targ_apparmor = 1;\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strncmp(ptr, \"protocol \", 9) == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP))\n\t\t\tprotocol_store(ptr + 9);\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: user seccomp feature is disabled in Firejail configuration file\\n\");\n#endif\n\t\treturn 0;\n\t}\n\t\n\tif (strncmp(ptr, \"env \", 4) == 0) {\n\t\tenv_store(ptr + 4, SETENV);\n\t\treturn 0;\n\t}\n\tif (strncmp(ptr, \"rmenv \", 6) == 0) {\n\t\tenv_store(ptr + 6, RMENV);\n\t\treturn 0;\n\t}\n\t\n\t// seccomp drop list on top of default list\n\tif (strncmp(ptr, \"seccomp \", 8) == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\targ_seccomp = 1;\n\t\t\tcfg.seccomp_list = strdup(ptr + 8);\n\t\t\tif (!cfg.seccomp_list)\n\t\t\t\terrExit(\"strdup\");\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: user seccomp feature is disabled in Firejail configuration file\\n\");\n#endif\n\n\t\treturn 0;\n\t}\n\t\n\t// seccomp drop list without default list\n\tif (strncmp(ptr, \"seccomp.drop \", 13) == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\targ_seccomp = 1;\n\t\t\tcfg.seccomp_list_drop = strdup(ptr + 13);\n\t\t\tif (!cfg.seccomp_list_drop)\n\t\t\t\terrExit(\"strdup\");\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: user seccomp feature is disabled in Firejail configuration file\\n\");\n#endif\t\t\n\t\treturn 0;\n\t}\n\n\t// seccomp keep list\n\tif (strncmp(ptr, \"seccomp.keep \", 13) == 0) {\n#ifdef HAVE_SECCOMP\n\t\tif (checkcfg(CFG_SECCOMP)) {\n\t\t\targ_seccomp = 1;\n\t\t\tcfg.seccomp_list_keep= strdup(ptr + 13);\n\t\t\tif (!cfg.seccomp_list_keep)\n\t\t\t\terrExit(\"strdup\");\n\t\t}\n\t\telse if (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: user seccomp feature is disabled in Firejail configuration file\\n\");\n#endif\t\t\n\t\treturn 0;\n\t}\n\t\n\t// caps drop list\n\tif (strncmp(ptr, \"caps.drop \", 10) == 0) {\n\t\targ_caps_drop = 1;\n\t\targ_caps_list = strdup(ptr + 10);\n\t\tif (!arg_caps_list)\n\t\t\terrExit(\"strdup\");\n\t\t// verify seccomp list and exit if problems\n\t\tif (caps_check_list(arg_caps_list, NULL))\n\t\t\texit(1);\n\t\treturn 0;\n\t}\n\t\n\t// caps keep list\n\tif (strncmp(ptr, \"caps.keep \", 10) == 0) {\n\t\targ_caps_keep = 1;\n\t\targ_caps_list = strdup(ptr + 10);\n\t\tif (!arg_caps_list)\n\t\t\terrExit(\"strdup\");\n\t\t// verify seccomp list and exit if problems\n\t\tif (caps_check_list(arg_caps_list, NULL))\n\t\t\texit(1);\n\t\treturn 0;\n\t}\n\n\t// hostname\n\tif (strncmp(ptr, \"hostname \", 9) == 0) {\n\t\tcfg.hostname = ptr + 9;\n\t\treturn 0;\n\t}\n\t\n\t// dns\n\tif (strncmp(ptr, \"dns \", 4) == 0) {\n\t\tuint32_t dns;\n\t\tif (atoip(ptr + 4, &dns)) {\n\t\t\tfprintf(stderr, \"Error: invalid DNS server IP address\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\t\n\t\tif (cfg.dns1 == 0)\n\t\t\tcfg.dns1 = dns;\n\t\telse if (cfg.dns2 == 0)\n\t\t\tcfg.dns2 = dns;\n\t\telse if (cfg.dns3 == 0)\n\t\t\tcfg.dns3 = dns;\n\t\telse {\n\t\t\tfprintf(stderr, \"Error: up to 3 DNS servers can be specified\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\t// cpu affinity\n\tif (strncmp(ptr, \"cpu \", 4) == 0) {\n\t\tread_cpu_list(ptr + 4);\n\t\treturn 0;\n\t}\n\t\n\t// nice value\n\tif (strncmp(ptr, \"nice \", 4) == 0) {\n\t\tcfg.nice = atoi(ptr + 5);\n\t\tif (getuid() != 0 &&cfg.nice < 0)\n\t\t\tcfg.nice = 0;\n\t\targ_nice = 1;\n\t\treturn 0;\n\t}\n\n\t// cgroup\n\tif (strncmp(ptr, \"cgroup \", 7) == 0) {\n\t\tset_cgroup(ptr + 7);\n\t\treturn 0;\n\t}\n\t\n\t// writable-etc\n\tif (strcmp(ptr, \"writable-etc\") == 0) {\n\t\tif (cfg.etc_private_keep) {\n\t\t\tfprintf(stderr, \"Error: private-etc and writable-etc are mutually exclusive\\n\");\n\t\t\texit(1);\n\t\t}\n\t\targ_writable_etc = 1;\n\t\treturn 0;\n\t}\n\t\n\t// writable-var\n\tif (strcmp(ptr, \"writable-var\") == 0) {\n\t\targ_writable_var = 1;\n\t\treturn 0;\n\t}\n\t\n\t// private directory\n\tif (strncmp(ptr, \"private \", 8) == 0) {\n\t\tcfg.home_private = ptr + 8;\n\t\tfs_check_private_dir();\n\t\targ_private = 1;\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 none\") == 0) {\n\t\targ_x11_block = 1;\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 xephyr\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\tchar *x11env = getenv(\"FIREJAIL_X11\");\n\t\t\tif (x11env && strcmp(x11env, \"yes\") == 0) {\n\t\t\t\tmask_x11_abstract_socket = 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// start x11\n\t\t\t\tx11_start_xephyr(cfg.original_argc, cfg.original_argv);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n#endif\n\t\treturn 0;\n\t}\n\n\tif (strcmp(ptr, \"x11 xorg\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11))\n\t\t\targ_x11_xorg = 1;\n\t\telse {\n\t\t\tfprintf(stderr, \"Error: --x11 feature is disabled in Firejail configuration file\\n\");\n\t\t\treturn 0;\n\t\t}\n#endif\n\t\treturn 0;\n\t}\n\tif (strcmp(ptr, \"x11 xpra\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\tchar *x11env = getenv(\"FIREJAIL_X11\");\n\t\t\tif (x11env && strcmp(x11env, \"yes\") == 0) {\n\t\t\t\tmask_x11_abstract_socket = 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// start x11\n\t\t\t\tx11_start_xpra(cfg.original_argc, cfg.original_argv);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n#endif\n\t\treturn 0;\n\t}\n\t\n\tif (strcmp(ptr, \"x11\") == 0) {\n#ifdef HAVE_X11\n\t\tif (checkcfg(CFG_X11)) {\n\t\t\tchar *x11env = getenv(\"FIREJAIL_X11\");\n\t\t\tif (x11env && strcmp(x11env, \"yes\") == 0) {\n\t\t\t\tmask_x11_abstract_socket = 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// start x11\n\t\t\t\tx11_start(cfg.original_argc, cfg.original_argv);\n\t\t\t\texit(0);\t\t\n\t\t\t}\n\t\t}\n#endif\t\t\n\t\treturn 0;\n\t}\n\t\n\t// private /etc list of files and directories\n\tif (strncmp(ptr, \"private-etc \", 12) == 0) {\n\t\tif (arg_writable_etc) {\n\t\t\tfprintf(stderr, \"Error: --private-etc and --writable-etc are mutually exclusive\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tcfg.etc_private_keep = ptr + 12;\n\t\tfs_check_etc_list();\n\t\targ_private_etc = 1;\n\t\t\n\t\treturn 0;\n\t}\n\n\t// private /bin list of files\n\tif (strncmp(ptr, \"private-bin \", 12) == 0) {\n\t\tcfg.bin_private_keep = ptr + 12;\n\t\targ_private_bin = 1;\n\t\tfs_check_bin_list();\n\t\treturn 0;\n\t}\n\n\t// filesystem bind\n\tif (strncmp(ptr, \"bind \", 5) == 0) {\n#ifdef HAVE_BIND\t\t\n\t\tif (checkcfg(CFG_BIND)) {\n\t\t\tif (getuid() != 0) {\n\t\t\t\tfprintf(stderr, \"Error: --bind option is available only if running as root\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\n\t\t\t// extract two directories\n\t\t\tchar *dname1 = ptr + 5;\n\t\t\tchar *dname2 = split_comma(dname1); // this inserts a '0 to separate the two dierctories\n\t\t\tif (dname2 == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: missing second directory for bind\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t\n\t\t\t// check directories\n\t\t\tinvalid_filename(dname1);\n\t\t\tinvalid_filename(dname2);\n\t\t\tif (strstr(dname1, \"..\") || strstr(dname2, \"..\")) {\n\t\t\t\tfprintf(stderr, \"Error: invalid file name.\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (is_link(dname1) || is_link(dname2)) {\n\t\t\t\tfprintf(stderr, \"Symbolic links are not allowed for bind command\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t\n\t\t\t// insert comma back\n\t\t\t*(dname2 - 1) = ',';\n\t\t\treturn 1;\n\t\t}\n\t\telse if (!arg_quiet) {\n\t\t\tfprintf(stderr, \"Warning: bind feature is disabled in Firejail configuration file\\n\");\n\t\t\treturn 0;\t\t\t\n\t\t}\n#else\n\t\treturn 0;\n#endif\t\t\n\t}\n\n\t// rlimit\n\tif (strncmp(ptr, \"rlimit\", 6) == 0) {\n\t\tif (strncmp(ptr, \"rlimit-nofile \", 14) == 0) {\n\t\t\tptr += 14;\n\t\t\tif (not_unsigned(ptr)) {\n\t\t\t\tfprintf(stderr, \"Invalid rlimit option on line %d\\n\", lineno);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tsscanf(ptr, \"%u\", &cfg.rlimit_nofile);\n\t\t\targ_rlimit_nofile = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-nproc \", 13) == 0) {\n\t\t\tptr += 13;\n\t\t\tif (not_unsigned(ptr)) {\n\t\t\t\tfprintf(stderr, \"Invalid rlimit option on line %d\\n\", lineno);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tsscanf(ptr, \"%u\", &cfg.rlimit_nproc);\n\t\t\targ_rlimit_nproc = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-fsize \", 13) == 0) {\n\t\t\tptr += 13;\n\t\t\tif (not_unsigned(ptr)) {\n\t\t\t\tfprintf(stderr, \"Invalid rlimit option on line %d\\n\", lineno);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tsscanf(ptr, \"%u\", &cfg.rlimit_fsize);\n\t\t\targ_rlimit_fsize = 1;\n\t\t}\n\t\telse if (strncmp(ptr, \"rlimit-sigpending \", 18) == 0) {\n\t\t\tptr += 18;\n\t\t\tif (not_unsigned(ptr)) {\n\t\t\t\tfprintf(stderr, \"Invalid rlimit option on line %d\\n\", lineno);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tsscanf(ptr, \"%u\", &cfg.rlimit_sigpending);\n\t\t\targ_rlimit_sigpending = 1;\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"Invalid rlimit option on line %d\\n\", lineno);\n\t\t\texit(1);\n\t\t}\n\t\t\n\t\treturn 0;\t\t\n\t}\n\n\tif (strncmp(ptr, \"join-or-start \", 14) == 0) {\n\t\t// try to join by name only\n\t\tpid_t pid;\n\t\tif (!name2pid(ptr + 14, &pid)) {\n\t\t\tif (!cfg.shell && !arg_shell_none)\n\t\t\t\tcfg.shell = guess_shell();\n\n\t\t\t// find first non-option arg\n\t\t\tint i;\n\t\t\tfor (i = 1; i < cfg.original_argc && strncmp(cfg.original_argv[i], \"--\", 2) != 0; i++);\n\n\t\t\tjoin(pid, cfg.original_argc,cfg.original_argv, i + 1);\n\t\t\texit(0);\n\t\t}\n\n\t\t// set sandbox name and start normally\n\t\tcfg.name = ptr + 14;\n\t\tif (strlen(cfg.name) == 0) {\n\t\t\tfprintf(stderr, \"Error: invalid sandbox name\\n\");\n\t\t\texit(1);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t// rest of filesystem\n\tif (strncmp(ptr, \"blacklist \", 10) == 0)\n\t\tptr += 10;\n\telse if (strncmp(ptr, \"blacklist-nolog \", 16) == 0)\n\t\tptr += 16;\n\telse if (strncmp(ptr, \"noblacklist \", 12) == 0)\n\t\tptr += 12;\n\telse if (strncmp(ptr, \"whitelist \", 10) == 0) {\n#ifdef HAVE_WHITELIST\t\t\n\t\tif (checkcfg(CFG_WHITELIST)) {\n\t\t\targ_whitelist = 1;\n\t\t\tptr += 10;\n\t\t}\n\t\telse\n\t\t\treturn 0;\n#else\t\t\n\t\treturn 0;\n#endif\n\t}\n\telse if (strncmp(ptr, \"read-only \", 10) == 0)\n\t\tptr += 10;\n\telse if (strncmp(ptr, \"read-write \", 11) == 0)\n\t\tptr += 11;\n\telse if (strncmp(ptr, \"noexec \", 7) == 0)\n\t\tptr += 7;\n\telse if (strncmp(ptr, \"tmpfs \", 6) == 0) {\n\t\tif (getuid() != 0) {\n\t\t\tfprintf(stderr, \"Error: tmpfs available only when running the sandbox as root\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tptr += 6;\n\t}\n\telse {\n\t\tif (lineno == 0)\n\t\t\tfprintf(stderr, \"Error: \\\"%s\\\" as a command line option is invalid\\n\", ptr);\n\t\telse if (fname != NULL)\n\t\t\tfprintf(stderr, \"Error: line %d in %s is invalid\\n\", lineno, fname);\n\t\telse\n\t\t\tfprintf(stderr, \"Error: line %d in the custom profile is invalid\\n\", lineno);\n\t\texit(1);\n\t}\n\n\t// some characters just don't belong in filenames\n\tinvalid_filename(ptr);\n\tif (strstr(ptr, \"..\")) {\n\t\tif (lineno == 0)\n\t\t\tfprintf(stderr, \"Error: \\\"%s\\\" is an invalid filename\\n\", ptr);\n\t\telse if (fname != NULL)\n\t\t\tfprintf(stderr, \"Error: line %d in %s is invalid\\n\", lineno, fname);\n\t\telse\n\t\t\tfprintf(stderr, \"Error: line %d in the custom profile is invalid\\n\", lineno);\n\t\texit(1);\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "profile_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/profile.c",
    "lines": "27-59",
    "snippet": "int profile_find(const char *name, const char *dir) {\n\tEUID_ASSERT();\n\tassert(name);\n\tassert(dir);\n\t\n\tint rv = 0;\t\n\tDIR *dp;\n\tchar *pname;\n\tif (asprintf(&pname, \"%s.profile\", name) == -1)\n\t\terrExit(\"asprintf\");\n\n\tdp = opendir (dir);\n\tif (dp != NULL) {\n\t\tstruct dirent *ep;\n\t\twhile ((ep = readdir(dp)) != NULL) {\n\t\t\tif (strcmp(ep->d_name, pname) == 0) {\n\t\t\t\tif (arg_debug)\n\t\t\t\t\tprintf(\"Found %s profile in %s directory\\n\", name, dir);\n\t\t\t\tchar *etcpname;\n\t\t\t\tif (asprintf(&etcpname, \"%s/%s\", dir, pname) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\tprofile_read(etcpname);\n\t\t\t\tfree(etcpname);\n\t\t\t\trv = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t(void) closedir (dp);\n\t}\n\n\tfree(pname);\n\treturn rv;\n}",
    "includes": [
      "#include <sys/stat.h>",
      "#include <dirent.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "pname"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "dp"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "etcpname"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "profile_read",
          "args": [
            "etcpname"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "profile_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/profile.c",
          "lines": "942-1030",
          "snippet": "void profile_read(const char *fname) {\n\tEUID_ASSERT();\n\t\n\t// exit program if maximum include level was reached\n\tif (include_level > MAX_INCLUDE_LEVEL) {\n\t\tfprintf(stderr, \"Error: maximum profile include level was reached\\n\");\n\t\texit(1);\t\n\t}\n\n\tif (strlen(fname) == 0) {\n\t\tfprintf(stderr, \"Error: invalid profile file\\n\");\n\t\texit(1);\n\t}\n\n\t// allow debuggers\n\tif (arg_allow_debuggers) {\n\t\tchar *tmp = strrchr(fname, '/');\n\t\tif (tmp && *(tmp + 1) != '\\0') {\n\t\t\ttmp++;\n\t\t\tif (strcmp(tmp, \"disable-devel.inc\") == 0)\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\t// open profile file:\n\tFILE *fp = fopen(fname, \"r\");\n\tif (fp == NULL) {\n\t\tfprintf(stderr, \"Error: cannot open profile file %s\\n\", fname);\n\t\texit(1);\n\t}\n\n\tint msg_printed = 0;\n\n\t// read the file line by line\n\tchar buf[MAX_READ + 1];\n\tint lineno = 0;\n\twhile (fgets(buf, MAX_READ, fp)) {\n\t\t++lineno;\n\t\t// remove empty space - ptr in allocated memory\n\t\tchar *ptr = line_remove_spaces(buf);\n\t\tif (ptr == NULL)\n\t\t\tcontinue;\n\t\t\n\t\t// comments\n\t\tif (*ptr == '#' || *ptr == '\\0') {\n\t\t\tfree(ptr);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t// process quiet\n\t\tif (strcmp(ptr, \"quiet\") == 0) {\n\t\t\targ_quiet = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!msg_printed) {\n\t\t\tif (!arg_quiet)\n\t\t\t\tfprintf(stderr, \"Reading profile %s\\n\", fname);\n\t\t\tmsg_printed = 1;\n\t\t}\n\n\t\t// process include\n\t\tif (strncmp(ptr, \"include \", 8) == 0) {\n\t\t\tinclude_level++;\n\t\t\t\n\t\t\t// extract profile filename and new skip params\n\t\t\tchar *newprofile = ptr + 8; // profile name\n\t\t\t\n\t\t\t// expand ${HOME}/ in front of the new profile file\n\t\t\tchar *newprofile2 = expand_home(newprofile, cfg.homedir);\n\t\t\t\n\t\t\t// recursivity\n\t\t\tprofile_read((newprofile2)? newprofile2:newprofile);\n\t\t\tinclude_level--;\n\t\t\tif (newprofile2)\n\t\t\t\tfree(newprofile2);\n\t\t\tfree(ptr);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t// verify syntax, exit in case of error\n\t\tif (profile_check_line(ptr, lineno, fname))\n\t\t\tprofile_add(ptr);\n// we cannot free ptr here, data is extracted from ptr and linked as a pointer in cfg structure\n//\t\telse {\n//\t\t\tfree(ptr);\n//\t\t}\n\t}\n\tfclose(fp);\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <dirent.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAX_READ 8192\t\t\t\t  // line buffer for profile files"
          ],
          "globals_used": [
            "static int include_level = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <dirent.h>\n#include \"firejail.h\"\n\n#define MAX_READ 8192\t\t\t\t  // line buffer for profile files\n\nstatic int include_level = 0;\n\nvoid profile_read(const char *fname) {\n\tEUID_ASSERT();\n\t\n\t// exit program if maximum include level was reached\n\tif (include_level > MAX_INCLUDE_LEVEL) {\n\t\tfprintf(stderr, \"Error: maximum profile include level was reached\\n\");\n\t\texit(1);\t\n\t}\n\n\tif (strlen(fname) == 0) {\n\t\tfprintf(stderr, \"Error: invalid profile file\\n\");\n\t\texit(1);\n\t}\n\n\t// allow debuggers\n\tif (arg_allow_debuggers) {\n\t\tchar *tmp = strrchr(fname, '/');\n\t\tif (tmp && *(tmp + 1) != '\\0') {\n\t\t\ttmp++;\n\t\t\tif (strcmp(tmp, \"disable-devel.inc\") == 0)\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\t// open profile file:\n\tFILE *fp = fopen(fname, \"r\");\n\tif (fp == NULL) {\n\t\tfprintf(stderr, \"Error: cannot open profile file %s\\n\", fname);\n\t\texit(1);\n\t}\n\n\tint msg_printed = 0;\n\n\t// read the file line by line\n\tchar buf[MAX_READ + 1];\n\tint lineno = 0;\n\twhile (fgets(buf, MAX_READ, fp)) {\n\t\t++lineno;\n\t\t// remove empty space - ptr in allocated memory\n\t\tchar *ptr = line_remove_spaces(buf);\n\t\tif (ptr == NULL)\n\t\t\tcontinue;\n\t\t\n\t\t// comments\n\t\tif (*ptr == '#' || *ptr == '\\0') {\n\t\t\tfree(ptr);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t// process quiet\n\t\tif (strcmp(ptr, \"quiet\") == 0) {\n\t\t\targ_quiet = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!msg_printed) {\n\t\t\tif (!arg_quiet)\n\t\t\t\tfprintf(stderr, \"Reading profile %s\\n\", fname);\n\t\t\tmsg_printed = 1;\n\t\t}\n\n\t\t// process include\n\t\tif (strncmp(ptr, \"include \", 8) == 0) {\n\t\t\tinclude_level++;\n\t\t\t\n\t\t\t// extract profile filename and new skip params\n\t\t\tchar *newprofile = ptr + 8; // profile name\n\t\t\t\n\t\t\t// expand ${HOME}/ in front of the new profile file\n\t\t\tchar *newprofile2 = expand_home(newprofile, cfg.homedir);\n\t\t\t\n\t\t\t// recursivity\n\t\t\tprofile_read((newprofile2)? newprofile2:newprofile);\n\t\t\tinclude_level--;\n\t\t\tif (newprofile2)\n\t\t\t\tfree(newprofile2);\n\t\t\tfree(ptr);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t// verify syntax, exit in case of error\n\t\tif (profile_check_line(ptr, lineno, fname))\n\t\t\tprofile_add(ptr);\n// we cannot free ptr here, data is extracted from ptr and linked as a pointer in cfg structure\n//\t\telse {\n//\t\t\tfree(ptr);\n//\t\t}\n\t}\n\tfclose(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&etcpname",
            "\"%s/%s\"",
            "dir",
            "pname"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Found %s profile in %s directory\\n\"",
            "name",
            "dir"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ep->d_name",
            "pname"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readdir",
          "args": [
            "dp"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opendir",
          "args": [
            "dir"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&pname",
            "\"%s.profile\"",
            "name"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "dir"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "name"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/stat.h>\n#include <dirent.h>\n#include \"firejail.h\"\n\nint profile_find(const char *name, const char *dir) {\n\tEUID_ASSERT();\n\tassert(name);\n\tassert(dir);\n\t\n\tint rv = 0;\t\n\tDIR *dp;\n\tchar *pname;\n\tif (asprintf(&pname, \"%s.profile\", name) == -1)\n\t\terrExit(\"asprintf\");\n\n\tdp = opendir (dir);\n\tif (dp != NULL) {\n\t\tstruct dirent *ep;\n\t\twhile ((ep = readdir(dp)) != NULL) {\n\t\t\tif (strcmp(ep->d_name, pname) == 0) {\n\t\t\t\tif (arg_debug)\n\t\t\t\t\tprintf(\"Found %s profile in %s directory\\n\", name, dir);\n\t\t\t\tchar *etcpname;\n\t\t\t\tif (asprintf(&etcpname, \"%s/%s\", dir, pname) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\tprofile_read(etcpname);\n\t\t\t\tfree(etcpname);\n\t\t\t\trv = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t(void) closedir (dp);\n\t}\n\n\tfree(pname);\n\treturn rv;\n}"
  }
]