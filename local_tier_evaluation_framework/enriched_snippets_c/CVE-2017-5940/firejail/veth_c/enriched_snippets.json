[
  {
    "function_name": "net_move_interface",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/veth.c",
    "lines": "185-219",
    "snippet": "int net_move_interface(const char *dev, unsigned pid) {\n\tstruct iplink_req req;\n\tif (arg_debug)\n\t\tprintf(\"move device %s inside the namespace\\n\", dev);\n\tassert(dev);\n\n\tif (rtnl_open(&rth, 0) < 0) {\n\t\tfprintf(stderr, \"cannot open netlink\\n\");\n\t\texit(1);\n\t}\n\n\tmemset(&req, 0, sizeof(req));\n\n\treq.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg));\n\treq.n.nlmsg_flags = NLM_F_REQUEST;\n\treq.n.nlmsg_type = RTM_NEWLINK;\n\treq.i.ifi_family = 0;\n\t\n\t// find ifindex\n\tint ifindex = if_nametoindex(dev);\n\tif (ifindex <= 0) {\n\t\tfprintf(stderr, \"Error: cannot find interface %s\\n\", dev);\n\t\texit(1);\n\t}\n\treq.i.ifi_index = ifindex;\n\t\t\t\t\n\t// place the interface in child namespace\n\taddattr_l (&req.n, sizeof(req), IFLA_NET_NS_PID, &pid, 4);\n\n\t// send message\n\tif (rtnl_talk(&rth, &req.n, 0, 0, NULL) < 0)\n\t\texit(2);\n\n\treturn 0;\n}",
    "includes": [
      "#include <net/if.h>",
      "#include <linux/veth.h>",
      "#include \"../include/libnetlink.h\"",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rtnl_handle rth = { .fd = -1 };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "2"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "myexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/main.c",
          "lines": "137-149",
          "snippet": "static void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}",
          "includes": [
            "#include <sys/times.h>",
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int arg_command = 0;",
            "int arg_quiet = 0;",
            "pid_t sandbox_pid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/times.h>\n#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nint arg_command = 0;\nint arg_quiet = 0;\npid_t sandbox_pid;\n\nstatic void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}"
        }
      },
      {
        "call_info": {
          "callee": "rtnl_talk",
          "args": [
            "&rth",
            "&req.n",
            "0",
            "0",
            "NULL"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addattr_l",
          "args": [
            "&req.n",
            "sizeof(req)",
            "IFLA_NET_NS_PID",
            "&pid",
            "4"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot find interface %s\\n\"",
            "dev"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_nametoindex",
          "args": [
            "dev"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_LENGTH",
          "args": [
            "sizeof(struct ifinfomsg)"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&req",
            "0",
            "sizeof(req)"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"cannot open netlink\\n\""
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtnl_open",
          "args": [
            "&rth",
            "0"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "dev"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"move device %s inside the namespace\\n\"",
            "dev"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/if.h>\n#include <linux/veth.h>\n#include \"../include/libnetlink.h\"\n#include \"firejail.h\"\n\nstatic struct rtnl_handle rth = { .fd = -1 };\n\nint net_move_interface(const char *dev, unsigned pid) {\n\tstruct iplink_req req;\n\tif (arg_debug)\n\t\tprintf(\"move device %s inside the namespace\\n\", dev);\n\tassert(dev);\n\n\tif (rtnl_open(&rth, 0) < 0) {\n\t\tfprintf(stderr, \"cannot open netlink\\n\");\n\t\texit(1);\n\t}\n\n\tmemset(&req, 0, sizeof(req));\n\n\treq.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg));\n\treq.n.nlmsg_flags = NLM_F_REQUEST;\n\treq.n.nlmsg_type = RTM_NEWLINK;\n\treq.i.ifi_family = 0;\n\t\n\t// find ifindex\n\tint ifindex = if_nametoindex(dev);\n\tif (ifindex <= 0) {\n\t\tfprintf(stderr, \"Error: cannot find interface %s\\n\", dev);\n\t\texit(1);\n\t}\n\treq.i.ifi_index = ifindex;\n\t\t\t\t\n\t// place the interface in child namespace\n\taddattr_l (&req.n, sizeof(req), IFLA_NET_NS_PID, &pid, 4);\n\n\t// send message\n\tif (rtnl_talk(&rth, &req.n, 0, 0, NULL) < 0)\n\t\texit(2);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "net_create_macvlan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/veth.c",
    "lines": "120-181",
    "snippet": "int net_create_macvlan(const char *dev, const char *parent, unsigned pid) {\n\tint len;\n\tstruct iplink_req req;\n\tif (arg_debug)\n\t\tprintf(\"create macvlan %s, parent %s\\n\", dev, parent);\n\tassert(dev);\n\tassert(parent);\n\n\tif (rtnl_open(&rth, 0) < 0) {\n\t\tfprintf(stderr, \"cannot open netlink\\n\");\n\t\texit(1);\n\t}\n\n\tmemset(&req, 0, sizeof(req));\n\n\treq.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg));\n\treq.n.nlmsg_flags = NLM_F_REQUEST|NLM_F_CREATE|NLM_F_EXCL;\n\treq.n.nlmsg_type = RTM_NEWLINK;\n\treq.i.ifi_family = 0;\n\t\n\t// find parent ifindex\n\tint parent_ifindex = if_nametoindex(parent);\n\tif (parent_ifindex <= 0) {\n\t\tfprintf(stderr, \"Error: cannot find network device %s\\n\", parent);\n\t\texit(1);\n\t}\t\t\t\n\n\t// add parent\n\taddattr_l(&req.n, sizeof(req), IFLA_LINK, &parent_ifindex, 4);\n\n\t// add new interface name\n\tlen = strlen(dev) + 1;\n\taddattr_l(&req.n, sizeof(req), IFLA_IFNAME, dev, len);\n\t\n\t// place the interface in child namespace\n\taddattr_l (&req.n, sizeof(req), IFLA_NET_NS_PID, &pid, 4);\n\n\n\t// add  link info for the new interface\n\tstruct rtattr *linkinfo = NLMSG_TAIL(&req.n);\n\taddattr_l(&req.n, sizeof(req), IFLA_LINKINFO, NULL, 0);\n\taddattr_l(&req.n, sizeof(req), IFLA_INFO_KIND, \"macvlan\", strlen(\"macvlan\"));\n\n\t// set macvlan bridge mode\n\tstruct rtattr * data = NLMSG_TAIL(&req.n);\n\taddattr_l(&req.n, sizeof(req), IFLA_INFO_DATA, NULL, 0);\n\tint macvlan_type = MACVLAN_MODE_BRIDGE;\n\taddattr_l (&req.n, sizeof(req), IFLA_INFO_KIND, &macvlan_type, 4);\n\n\tdata->rta_len = (void *)NLMSG_TAIL(&req.n) - (void *)data;\n//\treq.n.nlmsg_len += sizeof(struct ifinfomsg);\n\n\n\tdata->rta_len = (void *)NLMSG_TAIL(&req.n) - (void *)data;\n\tlinkinfo->rta_len = (void *)NLMSG_TAIL(&req.n) - (void *)linkinfo;\n\n\t// send message\n\tif (rtnl_talk(&rth, &req.n, 0, 0, NULL) < 0)\n\t\texit(2);\n\n\treturn 0;\n}",
    "includes": [
      "#include <net/if.h>",
      "#include <linux/veth.h>",
      "#include \"../include/libnetlink.h\"",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rtnl_handle rth = { .fd = -1 };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "2"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "myexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/main.c",
          "lines": "137-149",
          "snippet": "static void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}",
          "includes": [
            "#include <sys/times.h>",
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int arg_command = 0;",
            "int arg_quiet = 0;",
            "pid_t sandbox_pid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/times.h>\n#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nint arg_command = 0;\nint arg_quiet = 0;\npid_t sandbox_pid;\n\nstatic void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}"
        }
      },
      {
        "call_info": {
          "callee": "rtnl_talk",
          "args": [
            "&rth",
            "&req.n",
            "0",
            "0",
            "NULL"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_TAIL",
          "args": [
            "&req.n"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_TAIL",
          "args": [
            "&req.n"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_TAIL",
          "args": [
            "&req.n"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addattr_l",
          "args": [
            "&req.n",
            "sizeof(req)",
            "IFLA_INFO_KIND",
            "&macvlan_type",
            "4"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addattr_l",
          "args": [
            "&req.n",
            "sizeof(req)",
            "IFLA_INFO_DATA",
            "NULL",
            "0"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_TAIL",
          "args": [
            "&req.n"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addattr_l",
          "args": [
            "&req.n",
            "sizeof(req)",
            "IFLA_INFO_KIND",
            "\"macvlan\"",
            "strlen(\"macvlan\")"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"macvlan\""
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addattr_l",
          "args": [
            "&req.n",
            "sizeof(req)",
            "IFLA_LINKINFO",
            "NULL",
            "0"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_TAIL",
          "args": [
            "&req.n"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addattr_l",
          "args": [
            "&req.n",
            "sizeof(req)",
            "IFLA_NET_NS_PID",
            "&pid",
            "4"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addattr_l",
          "args": [
            "&req.n",
            "sizeof(req)",
            "IFLA_IFNAME",
            "dev",
            "len"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dev"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addattr_l",
          "args": [
            "&req.n",
            "sizeof(req)",
            "IFLA_LINK",
            "&parent_ifindex",
            "4"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot find network device %s\\n\"",
            "parent"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_nametoindex",
          "args": [
            "parent"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_LENGTH",
          "args": [
            "sizeof(struct ifinfomsg)"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&req",
            "0",
            "sizeof(req)"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"cannot open netlink\\n\""
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtnl_open",
          "args": [
            "&rth",
            "0"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "parent"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "dev"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"create macvlan %s, parent %s\\n\"",
            "dev",
            "parent"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/if.h>\n#include <linux/veth.h>\n#include \"../include/libnetlink.h\"\n#include \"firejail.h\"\n\nstatic struct rtnl_handle rth = { .fd = -1 };\n\nint net_create_macvlan(const char *dev, const char *parent, unsigned pid) {\n\tint len;\n\tstruct iplink_req req;\n\tif (arg_debug)\n\t\tprintf(\"create macvlan %s, parent %s\\n\", dev, parent);\n\tassert(dev);\n\tassert(parent);\n\n\tif (rtnl_open(&rth, 0) < 0) {\n\t\tfprintf(stderr, \"cannot open netlink\\n\");\n\t\texit(1);\n\t}\n\n\tmemset(&req, 0, sizeof(req));\n\n\treq.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg));\n\treq.n.nlmsg_flags = NLM_F_REQUEST|NLM_F_CREATE|NLM_F_EXCL;\n\treq.n.nlmsg_type = RTM_NEWLINK;\n\treq.i.ifi_family = 0;\n\t\n\t// find parent ifindex\n\tint parent_ifindex = if_nametoindex(parent);\n\tif (parent_ifindex <= 0) {\n\t\tfprintf(stderr, \"Error: cannot find network device %s\\n\", parent);\n\t\texit(1);\n\t}\t\t\t\n\n\t// add parent\n\taddattr_l(&req.n, sizeof(req), IFLA_LINK, &parent_ifindex, 4);\n\n\t// add new interface name\n\tlen = strlen(dev) + 1;\n\taddattr_l(&req.n, sizeof(req), IFLA_IFNAME, dev, len);\n\t\n\t// place the interface in child namespace\n\taddattr_l (&req.n, sizeof(req), IFLA_NET_NS_PID, &pid, 4);\n\n\n\t// add  link info for the new interface\n\tstruct rtattr *linkinfo = NLMSG_TAIL(&req.n);\n\taddattr_l(&req.n, sizeof(req), IFLA_LINKINFO, NULL, 0);\n\taddattr_l(&req.n, sizeof(req), IFLA_INFO_KIND, \"macvlan\", strlen(\"macvlan\"));\n\n\t// set macvlan bridge mode\n\tstruct rtattr * data = NLMSG_TAIL(&req.n);\n\taddattr_l(&req.n, sizeof(req), IFLA_INFO_DATA, NULL, 0);\n\tint macvlan_type = MACVLAN_MODE_BRIDGE;\n\taddattr_l (&req.n, sizeof(req), IFLA_INFO_KIND, &macvlan_type, 4);\n\n\tdata->rta_len = (void *)NLMSG_TAIL(&req.n) - (void *)data;\n//\treq.n.nlmsg_len += sizeof(struct ifinfomsg);\n\n\n\tdata->rta_len = (void *)NLMSG_TAIL(&req.n) - (void *)data;\n\tlinkinfo->rta_len = (void *)NLMSG_TAIL(&req.n) - (void *)linkinfo;\n\n\t// send message\n\tif (rtnl_talk(&rth, &req.n, 0, 0, NULL) < 0)\n\t\texit(2);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "net_create_veth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/veth.c",
    "lines": "62-117",
    "snippet": "int net_create_veth(const char *dev, const char *nsdev, unsigned pid) {\n\tint len;\n\tstruct iplink_req req;\n\n\tif (arg_debug)\n\t\tprintf(\"create veth %s/%s/%u\\n\", dev, nsdev, pid);\n\tassert(dev);\n\tassert(nsdev);\n\tassert(pid);\n\n\tif (rtnl_open(&rth, 0) < 0) {\n\t\tfprintf(stderr, \"cannot open netlink\\n\");\n\t\texit(1);\n\t}\n\n\tmemset(&req, 0, sizeof(req));\n\n\treq.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg));\n\treq.n.nlmsg_flags = NLM_F_REQUEST|NLM_F_CREATE|NLM_F_EXCL;\n\treq.n.nlmsg_type = RTM_NEWLINK;\n\treq.i.ifi_family = 0;\n\n\tif (dev) {\n\t\tlen = strlen(dev) + 1;\n\t\taddattr_l(&req.n, sizeof(req), IFLA_IFNAME, dev, len);\n\t}\n\n\tstruct rtattr *linkinfo = NLMSG_TAIL(&req.n);\n\taddattr_l(&req.n, sizeof(req), IFLA_LINKINFO, NULL, 0);\n\taddattr_l(&req.n, sizeof(req), IFLA_INFO_KIND, \"veth\", strlen(\"veth\"));\n\n\tstruct rtattr * data = NLMSG_TAIL(&req.n);\n\taddattr_l(&req.n, sizeof(req), IFLA_INFO_DATA, NULL, 0);\n\n\tstruct rtattr * peerdata = NLMSG_TAIL(&req.n);\n\taddattr_l (&req.n, sizeof(req), VETH_INFO_PEER, NULL, 0);\n\treq.n.nlmsg_len += sizeof(struct ifinfomsg);\n\n\t// place the link in the child namespace\n\taddattr_l (&req.n, sizeof(req), IFLA_NET_NS_PID, &pid, 4);\n\n\tif (nsdev) {\n\t\tint len = strlen(nsdev) + 1;\n\t\taddattr_l(&req.n, sizeof(req), IFLA_IFNAME, nsdev, len);\n\t}\n\tpeerdata->rta_len = (void *)NLMSG_TAIL(&req.n) - (void *)peerdata;\n\n\tdata->rta_len = (void *)NLMSG_TAIL(&req.n) - (void *)data;\n\tlinkinfo->rta_len = (void *)NLMSG_TAIL(&req.n) - (void *)linkinfo;\n\n\t// send message\n\tif (rtnl_talk(&rth, &req.n, 0, 0, NULL) < 0)\n\t\texit(2);\n\n\treturn 0;\n}",
    "includes": [
      "#include <net/if.h>",
      "#include <linux/veth.h>",
      "#include \"../include/libnetlink.h\"",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rtnl_handle rth = { .fd = -1 };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "2"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "myexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/main.c",
          "lines": "137-149",
          "snippet": "static void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}",
          "includes": [
            "#include <sys/times.h>",
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int arg_command = 0;",
            "int arg_quiet = 0;",
            "pid_t sandbox_pid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/times.h>\n#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nint arg_command = 0;\nint arg_quiet = 0;\npid_t sandbox_pid;\n\nstatic void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}"
        }
      },
      {
        "call_info": {
          "callee": "rtnl_talk",
          "args": [
            "&rth",
            "&req.n",
            "0",
            "0",
            "NULL"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_TAIL",
          "args": [
            "&req.n"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_TAIL",
          "args": [
            "&req.n"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_TAIL",
          "args": [
            "&req.n"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addattr_l",
          "args": [
            "&req.n",
            "sizeof(req)",
            "IFLA_IFNAME",
            "nsdev",
            "len"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "nsdev"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addattr_l",
          "args": [
            "&req.n",
            "sizeof(req)",
            "IFLA_NET_NS_PID",
            "&pid",
            "4"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addattr_l",
          "args": [
            "&req.n",
            "sizeof(req)",
            "VETH_INFO_PEER",
            "NULL",
            "0"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_TAIL",
          "args": [
            "&req.n"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addattr_l",
          "args": [
            "&req.n",
            "sizeof(req)",
            "IFLA_INFO_DATA",
            "NULL",
            "0"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_TAIL",
          "args": [
            "&req.n"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addattr_l",
          "args": [
            "&req.n",
            "sizeof(req)",
            "IFLA_INFO_KIND",
            "\"veth\"",
            "strlen(\"veth\")"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"veth\""
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addattr_l",
          "args": [
            "&req.n",
            "sizeof(req)",
            "IFLA_LINKINFO",
            "NULL",
            "0"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_TAIL",
          "args": [
            "&req.n"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addattr_l",
          "args": [
            "&req.n",
            "sizeof(req)",
            "IFLA_IFNAME",
            "dev",
            "len"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dev"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_LENGTH",
          "args": [
            "sizeof(struct ifinfomsg)"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&req",
            "0",
            "sizeof(req)"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"cannot open netlink\\n\""
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtnl_open",
          "args": [
            "&rth",
            "0"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "pid"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "nsdev"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "dev"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"create veth %s/%s/%u\\n\"",
            "dev",
            "nsdev",
            "pid"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/if.h>\n#include <linux/veth.h>\n#include \"../include/libnetlink.h\"\n#include \"firejail.h\"\n\nstatic struct rtnl_handle rth = { .fd = -1 };\n\nint net_create_veth(const char *dev, const char *nsdev, unsigned pid) {\n\tint len;\n\tstruct iplink_req req;\n\n\tif (arg_debug)\n\t\tprintf(\"create veth %s/%s/%u\\n\", dev, nsdev, pid);\n\tassert(dev);\n\tassert(nsdev);\n\tassert(pid);\n\n\tif (rtnl_open(&rth, 0) < 0) {\n\t\tfprintf(stderr, \"cannot open netlink\\n\");\n\t\texit(1);\n\t}\n\n\tmemset(&req, 0, sizeof(req));\n\n\treq.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg));\n\treq.n.nlmsg_flags = NLM_F_REQUEST|NLM_F_CREATE|NLM_F_EXCL;\n\treq.n.nlmsg_type = RTM_NEWLINK;\n\treq.i.ifi_family = 0;\n\n\tif (dev) {\n\t\tlen = strlen(dev) + 1;\n\t\taddattr_l(&req.n, sizeof(req), IFLA_IFNAME, dev, len);\n\t}\n\n\tstruct rtattr *linkinfo = NLMSG_TAIL(&req.n);\n\taddattr_l(&req.n, sizeof(req), IFLA_LINKINFO, NULL, 0);\n\taddattr_l(&req.n, sizeof(req), IFLA_INFO_KIND, \"veth\", strlen(\"veth\"));\n\n\tstruct rtattr * data = NLMSG_TAIL(&req.n);\n\taddattr_l(&req.n, sizeof(req), IFLA_INFO_DATA, NULL, 0);\n\n\tstruct rtattr * peerdata = NLMSG_TAIL(&req.n);\n\taddattr_l (&req.n, sizeof(req), VETH_INFO_PEER, NULL, 0);\n\treq.n.nlmsg_len += sizeof(struct ifinfomsg);\n\n\t// place the link in the child namespace\n\taddattr_l (&req.n, sizeof(req), IFLA_NET_NS_PID, &pid, 4);\n\n\tif (nsdev) {\n\t\tint len = strlen(nsdev) + 1;\n\t\taddattr_l(&req.n, sizeof(req), IFLA_IFNAME, nsdev, len);\n\t}\n\tpeerdata->rta_len = (void *)NLMSG_TAIL(&req.n) - (void *)peerdata;\n\n\tdata->rta_len = (void *)NLMSG_TAIL(&req.n) - (void *)data;\n\tlinkinfo->rta_len = (void *)NLMSG_TAIL(&req.n) - (void *)linkinfo;\n\n\t// send message\n\tif (rtnl_talk(&rth, &req.n, 0, 0, NULL) < 0)\n\t\texit(2);\n\n\treturn 0;\n}"
  }
]