[
  {
    "function_name": "sandbox",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/sandbox.c",
    "lines": "420-924",
    "snippet": "int sandbox(void* sandbox_arg) {\n\t// Get rid of unused parameter warning\n\t(void)sandbox_arg;\n\n\tpid_t child_pid = getpid();\n\tif (arg_debug)\n\t\tprintf(\"Initializing child process\\n\");\t\n\n \t// close each end of the unused pipes\n \tclose(parent_to_child_fds[1]);\n \tclose(child_to_parent_fds[0]);\n \n \t// wait for parent to do base setup\n \twait_for_other(parent_to_child_fds[0]);\n\n\tif (arg_debug && child_pid == 1)\n\t\tprintf(\"PID namespace installed\\n\");\n\n\n\t//****************************\n\t// set hostname\n\t//****************************\n\tif (cfg.hostname) {\n\t\tif (sethostname(cfg.hostname, strlen(cfg.hostname)) < 0)\n\t\t\terrExit(\"sethostname\");\n\t}\n\n\t//****************************\n\t// mount namespace\n\t//****************************\n\t// mount events are not forwarded between the host the sandbox\n\tif (mount(NULL, \"/\", NULL, MS_SLAVE | MS_REC, NULL) < 0) {\n\t\tchk_chroot();\n\t}\n\t\n\t\n\t//****************************\n\t// log sandbox data\n\t//****************************\n\tif (cfg.name)\n\t\tfs_logger2(\"sandbox name:\", cfg.name);\n\tfs_logger2int(\"sandbox pid:\", (int) sandbox_pid);\n\tif (cfg.chrootdir)\n\t\tfs_logger(\"sandbox filesystem: chroot\");\n\telse if (arg_overlay)\t\n\t\tfs_logger(\"sandbox filesystem: overlay\");\n\telse\n\t\tfs_logger(\"sandbox filesystem: local\");\n\tfs_logger(\"install mount namespace\");\n\t\n\t//****************************\n\t// netfilter etc.\n\t//****************************\n\tif (arg_netfilter && any_bridge_configured()) { // assuming by default the client filter\n\t\tnetfilter(arg_netfilter_file);\n\t}\n\tif (arg_netfilter6 && any_bridge_configured()) { // assuming by default the client filter\n\t\tnetfilter6(arg_netfilter6_file);\n\t}\n\n\t// load IBUS env variables\n\tif (arg_nonetwork || any_bridge_configured() || any_interface_configured()) {\n\t\t// do nothing - there are problems with ibus version 1.5.11\n\t}\n\telse\n\t\tenv_ibus_load();\n\t\n\t// grab a copy of cp command\n\tfs_build_cp_command();\n\t\n\t// trace pre-install\n\tif (arg_trace || arg_tracelog || mask_x11_abstract_socket)\n\t\tfs_trace_preload();\n\n\t//****************************\n\t// configure filesystem\n\t//****************************\n#ifdef HAVE_SECCOMP\n\tint enforce_seccomp = 0;\n#endif\n#ifdef HAVE_CHROOT\t\t\n\tif (cfg.chrootdir) {\n\t\tfs_chroot(cfg.chrootdir);\n\t\t\n\t\t// force caps and seccomp if not started as root\n\t\tif (getuid() != 0) {\n\t\t\tenforce_filters();\n#ifdef HAVE_SECCOMP\n\t\t\tenforce_seccomp = 1;\n#endif\n\t\t}\n\t\telse\n\t\t\targ_seccomp = 1;\n\t\t\t\t\t\t\n\t\t//****************************\n\t\t// trace pre-install, this time inside chroot\n\t\t//****************************\n\t\tif (arg_trace || arg_tracelog || mask_x11_abstract_socket)\n\t\t\tfs_trace_preload();\n\t}\n\telse \n#endif\t\t\n#ifdef HAVE_OVERLAYFS\n\tif (arg_overlay)\t{\n\t\tfs_overlayfs();\n\t\t// force caps and seccomp if not started as root\n\t\tif (getuid() != 0) {\n\t\t\tenforce_filters();\n#ifdef HAVE_SECCOMP\n\t\t\tenforce_seccomp = 1;\n#endif\n\t\t}\n\t\telse\n\t\t\targ_seccomp = 1;\n\t}\n\telse\n#endif\n\t\tfs_basic_fs();\n\t\n\t//****************************\n\t// set hostname in /etc/hostname\n\t//****************************\n\tif (cfg.hostname) {\n\t\tfs_hostname(cfg.hostname);\n\t}\n\t\n\t//****************************\n\t// private mode\n\t//****************************\n\tif (arg_private) {\n\t\tif (cfg.home_private) {\t// --private=\n\t\t\tif (cfg.chrootdir)\n\t\t\t\tfprintf(stderr, \"Warning: private=directory feature is disabled in chroot\\n\");\n\t\t\telse if (arg_overlay)\n\t\t\t\tfprintf(stderr, \"Warning: private=directory feature is disabled in overlay\\n\");\n\t\t\telse\n\t\t\t\tfs_private_homedir();\n\t\t}\n\t\telse if (cfg.home_private_keep) { // --private-home=\n\t\t\tif (cfg.chrootdir)\n\t\t\t\tfprintf(stderr, \"Warning: private-home= feature is disabled in chroot\\n\");\n\t\t\telse if (arg_overlay)\n\t\t\t\tfprintf(stderr, \"Warning: private-home= feature is disabled in overlay\\n\");\n\t\t\telse\n\t\t\t\tfs_private_home_list();\n\t\t}\n\t\telse // --private\n\t\t\tfs_private();\n\t}\n\n\tif (arg_private_dev) {\n\t\tif (cfg.chrootdir)\n\t\t\tfprintf(stderr, \"Warning: private-dev feature is disabled in chroot\\n\");\n\t\telse if (arg_overlay)\n\t\t\tfprintf(stderr, \"Warning: private-dev feature is disabled in overlay\\n\");\n\t\telse\n\t\t\tfs_private_dev();\n\t}\n\t\t\n\tif (arg_private_etc) {\n\t\tif (cfg.chrootdir)\n\t\t\tfprintf(stderr, \"Warning: private-etc feature is disabled in chroot\\n\");\n\t\telse if (arg_overlay)\n\t\t\tfprintf(stderr, \"Warning: private-etc feature is disabled in overlay\\n\");\n\t\telse {\n\t\t\tfs_private_etc_list();\n\t\t\t// create /etc/ld.so.preload file again\n\t\t\tif (arg_trace || arg_tracelog || mask_x11_abstract_socket)\n\t\t\t\tfs_trace_preload();\n\t\t}\n\t}\n\t\n\tif (arg_private_bin) {\n\t\tif (cfg.chrootdir)\n\t\t\tfprintf(stderr, \"Warning: private-bin feature is disabled in chroot\\n\");\n\t\telse if (arg_overlay)\n\t\t\tfprintf(stderr, \"Warning: private-bin feature is disabled in overlay\\n\");\n\t\telse {\n\t\t\t// for --x11=xorg we need to add xauth command\n\t\t\tif (arg_x11_xorg) {\n\t\t\t\tEUID_USER();\n\t\t\t\tchar *tmp;\n\t\t\t\tif (asprintf(&tmp, \"%s,xauth\", cfg.bin_private_keep) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\tcfg.bin_private_keep = tmp;\n\t\t\t\tfs_check_bin_list();\n\t\t\t\tEUID_ROOT();\n\t\t\t}\n\t\t\tfs_private_bin_list();\n\t\t}\n\t}\n\t\n\tif (arg_private_tmp) {\n\t\tif (cfg.chrootdir)\n\t\t\tfprintf(stderr, \"Warning: private-tmp feature is disabled in chroot\\n\");\n\t\telse if (arg_overlay)\n\t\t\tfprintf(stderr, \"Warning: private-tmp feature is disabled in overlay\\n\");\n\t\telse {\n\t\t\t// private-tmp is implemented as a whitelist\n\t\t\tEUID_USER();\n\t\t\tprofile_add(\"whitelist /tmp/.X11-unix\");\n\t\t\tEUID_ROOT();\n//\t\t\tfs_private_tmp();\n\t\t}\n\t}\n\t\n\t//****************************\n\t// update /proc, /sys, /dev, /boot directorymy\n\t//****************************\n\tif (checkcfg(CFG_REMOUNT_PROC_SYS))\n\t\tfs_proc_sys_dev_boot();\n\t\n\t//****************************\n\t// apply the profile file\n\t//****************************\n\t// apply all whitelist commands ... \n\tif (cfg.chrootdir)\n\t\tfprintf(stderr, \"Warning: whitelist feature is disabled in chroot\\n\");\n\telse if (arg_overlay)\n\t\tfprintf(stderr, \"Warning: whitelist feature is disabled in overlay\\n\");\n\telse\n\t\tfs_whitelist();\n\t\n\t// ... followed by blacklist commands\n\tfs_blacklist();\n\t\n\t//****************************\n\t// install trace\n\t//****************************\n\tif (arg_trace || arg_tracelog || mask_x11_abstract_socket)\n\t\tfs_trace();\n\t\t\n\t//****************************\n\t// nosound/no3d and fix for pulseaudio 7.0\n\t//****************************\n\tif (arg_nosound) {\n\t\t// disable pulseaudio\n\t\tpulseaudio_disable();\n\n\t\t// disable /dev/snd\n\t\tfs_dev_disable_sound();\n\t}\n\telse\n\t\tpulseaudio_init();\n\t\n\tif (arg_no3d)\n\t\tfs_dev_disable_3d();\n\t\n\t//****************************\n\t// networking\n\t//****************************\n\tint gw_cfg_failed = 0; // default gw configuration flag\n\tif (arg_nonetwork) {\n\t\tnet_if_up(\"lo\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Network namespace enabled, only loopback interface available\\n\");\n\t}\n\telse if (any_bridge_configured() || any_interface_configured()) {\n\t\t// configure lo and eth0...eth3\n\t\tnet_if_up(\"lo\");\n\t\t\n\t\tif (mac_not_zero(cfg.bridge0.macsandbox))\n\t\t\tnet_config_mac(cfg.bridge0.devsandbox, cfg.bridge0.macsandbox);\n\t\tsandbox_if_up(&cfg.bridge0);\n\t\t\n\t\tif (mac_not_zero(cfg.bridge1.macsandbox))\n\t\t\tnet_config_mac(cfg.bridge1.devsandbox, cfg.bridge1.macsandbox);\n\t\tsandbox_if_up(&cfg.bridge1);\n\t\t\n\t\tif (mac_not_zero(cfg.bridge2.macsandbox))\n\t\t\tnet_config_mac(cfg.bridge2.devsandbox, cfg.bridge2.macsandbox);\n\t\tsandbox_if_up(&cfg.bridge2);\n\t\t\n\t\tif (mac_not_zero(cfg.bridge3.macsandbox))\n\t\t\tnet_config_mac(cfg.bridge3.devsandbox, cfg.bridge3.macsandbox);\n\t\tsandbox_if_up(&cfg.bridge3);\n\t\t\n\t\t// enable interfaces\n\t\tif (cfg.interface0.configured && cfg.interface0.ip) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(cfg.interface0.ip), cfg.interface0.dev);\n\t\t\tnet_if_ip(cfg.interface0.dev, cfg.interface0.ip, cfg.interface0.mask, cfg.interface0.mtu);\n\t\t\tnet_if_up(cfg.interface0.dev);\n\t\t}\t\t\t\n\t\tif (cfg.interface1.configured && cfg.interface1.ip) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(cfg.interface1.ip), cfg.interface1.dev);\n\t\t\tnet_if_ip(cfg.interface1.dev, cfg.interface1.ip, cfg.interface1.mask, cfg.interface1.mtu);\n\t\t\tnet_if_up(cfg.interface1.dev);\n\t\t}\t\t\t\n\t\tif (cfg.interface2.configured && cfg.interface2.ip) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(cfg.interface2.ip), cfg.interface2.dev);\n\t\t\tnet_if_ip(cfg.interface2.dev, cfg.interface2.ip, cfg.interface2.mask, cfg.interface2.mtu);\n\t\t\tnet_if_up(cfg.interface2.dev);\n\t\t}\t\t\t\n\t\tif (cfg.interface3.configured && cfg.interface3.ip) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(cfg.interface3.ip), cfg.interface3.dev);\n\t\t\tnet_if_ip(cfg.interface3.dev, cfg.interface3.ip, cfg.interface3.mask, cfg.interface3.mtu);\n\t\t\tnet_if_up(cfg.interface3.dev);\n\t\t}\t\t\t\n\t\t\t\n\t\t// add a default route\n\t\tif (cfg.defaultgw) {\n\t\t\t// set the default route\n\t\t\tif (net_add_route(0, 0, cfg.defaultgw)) {\n\t\t\t\tfprintf(stderr, \"Warning: cannot configure default route\\n\");\n\t\t\t\tgw_cfg_failed = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (arg_debug)\n\t\t\tprintf(\"Network namespace enabled\\n\");\n\t}\n\t\n\t// if any dns server is configured, it is time to set it now\n\tfs_resolvconf();\n\tfs_logger_print();\n\tfs_logger_change_owner();\n\n\t// print network configuration\n\tif (!arg_quiet) {\n\t\tif (any_bridge_configured() || any_interface_configured() || cfg.defaultgw || cfg.dns1) {\n\t\t\tprintf(\"\\n\");\n\t\t\tif (any_bridge_configured() || any_interface_configured())\n\t\t\t\tnet_ifprint();\n\t\t\tif (cfg.defaultgw != 0) {\n\t\t\t\tif (gw_cfg_failed)\n\t\t\t\t\tprintf(\"Default gateway configuration failed\\n\");\n\t\t\t\telse\n\t\t\t\t\tprintf(\"Default gateway %d.%d.%d.%d\\n\", PRINT_IP(cfg.defaultgw));\n\t\t\t}\n\t\t\tif (cfg.dns1 != 0)\n\t\t\t\tprintf(\"DNS server %d.%d.%d.%d\\n\", PRINT_IP(cfg.dns1));\n\t\t\tif (cfg.dns2 != 0)\n\t\t\t\tprintf(\"DNS server %d.%d.%d.%d\\n\", PRINT_IP(cfg.dns2));\n\t\t\tif (cfg.dns3 != 0)\n\t\t\t\tprintf(\"DNS server %d.%d.%d.%d\\n\", PRINT_IP(cfg.dns3));\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\t\n\tfs_delete_cp_command();\n\n\t//****************************\n\t// set application environment\n\t//****************************\n\tprctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0); // kill the child in case the parent died\n\tint cwd = 0;\n\tif (cfg.cwd) {\n\t\tif (chdir(cfg.cwd) == 0)\n\t\t\tcwd = 1;\n\t}\n\t\n\tif (!cwd) {\n\t\tif (chdir(\"/\") < 0)\n\t\t\terrExit(\"chdir\");\n\t\tif (cfg.homedir) {\n\t\t\tstruct stat s;\n\t\t\tif (stat(cfg.homedir, &s) == 0) {\n\t\t\t\t/* coverity[toctou] */\n\t\t\t\tif (chdir(cfg.homedir) < 0)\n\t\t\t\t\terrExit(\"chdir\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// set nice\n\tif (arg_nice) {\n\t\terrno = 0;\n\t\tint rv = nice(cfg.nice);\n\t\t(void) rv;\n\t\tif (errno) {\n\t\t\tfprintf(stderr, \"Warning: cannot set nice value\\n\");\n\t\t\terrno = 0;\n\t\t}\n\t}\n\t\n\t// clean /tmp/.X11-unix sockets\n\tfs_x11();\n\tif (arg_x11_xorg)\n\t\tx11_xorg();\n\t\n\t//****************************\n\t// set security filters\n\t//****************************\n\t// set capabilities\n//\tif (!arg_noroot)\n\t\tset_caps();\n\n\t// set rlimits\n\tset_rlimits();\n\n\t// set seccomp\n#ifdef HAVE_SECCOMP\n\t// install protocol filter\n\tif (cfg.protocol) {\n\t\tprotocol_filter();\t// install filter\t\n\t\tprotocol_filter_save();\t// save filter in PROTOCOL_CFG\n\t}\n\n\t// if a keep list is available, disregard the drop list\n\tif (arg_seccomp == 1) {\n\t\tif (cfg.seccomp_list_keep)\n\t\t\tseccomp_filter_keep();\n\t\telse if (cfg.seccomp_list_errno)\n\t\t\tseccomp_filter_errno(); \n\t\telse\n\t\t\tseccomp_filter_drop(enforce_seccomp);\n\t}\n#endif\n\n\t// set cpu affinity\n\tif (cfg.cpus) {\n\t\tsave_cpu(); // save cpu affinity mask to CPU_CFG file\n\t\tset_cpu_affinity();\n\t}\n\t\n\t// save cgroup in CGROUP_CFG file\n\tif (cfg.cgroup)\n\t\tsave_cgroup();\n\n\t//****************************************\n\t// drop privileges or create a new user namespace\n\t//****************************************\n\tsave_nogroups();\n\tif (arg_noroot) {\n\t\tint rv = unshare(CLONE_NEWUSER);\n\t\tif (rv == -1) {\n\t\t\tfprintf(stderr, \"Warning: cannot create a new user namespace, going forward without it...\\n\");\n\t\t\tdrop_privs(arg_nogroups);\n\t\t\targ_noroot = 0;\n\t\t}\n\t}\n\telse\n\t\tdrop_privs(arg_nogroups);\n\t\n\t// notify parent that new user namespace has been created so a proper\n \t// UID/GID map can be setup\n \tnotify_other(child_to_parent_fds[1]);\n \tclose(child_to_parent_fds[1]);\n \n \t// wait for parent to finish setting up a proper UID/GID map\n \twait_for_other(parent_to_child_fds[0]);\n \tclose(parent_to_child_fds[0]);\n\n\t// somehow, the new user namespace resets capabilities;\n\t// we need to do them again\n\tif (arg_noroot) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"noroot user namespace installed\\n\");\n\t\tset_caps();\n\t}\n\t\n\t//****************************************\n\t// Set NO_NEW_PRIVS if desired\n\t//****************************************\n\tif (arg_nonewprivs) {\n\t\tint no_new_privs = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\n\t\tif(no_new_privs != 0)\n\t\t\tfprintf(stderr, \"Warning: NO_NEW_PRIVS disabled, it requires a Linux kernel version 3.5 or newer.\\n\");\n\t\telse if (arg_debug)\n\t\t\tprintf(\"NO_NEW_PRIVS set\\n\");\n\t}\n\n\t//****************************************\n\t// fork the application and monitor it\n\t//****************************************\n\tpid_t app_pid = fork();\n\tif (app_pid == -1)\n\t\terrExit(\"fork\");\n\n\tif (app_pid == 0) {\n#ifdef HAVE_APPARMOR\n\t\tif (arg_apparmor) {\n\t\t\terrno = 0;\n\t\t\tif (aa_change_onexec(\"firejail-default\")) {\n\t\t\t\tfprintf(stderr, \"Error: cannot confine the application using AppArmor.\\n\");\n\t\t\t\tfprintf(stderr, \"Maybe firejail-default AppArmor profile is not loaded into the kernel.\\n\");\n\t\t\t\tfprintf(stderr, \"As root, run \\\"aa-enforce firejail-default\\\" to load it.\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\telse if (arg_debug)\n\t\t\t\tprintf(\"AppArmor enabled\\n\");\n\t\t}\n#endif\t\t\n\t\tprctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0); // kill the child in case the parent died\n\t\tstart_application();\t// start app\n\t}\n\n\tint status = monitor_application(app_pid);\t// monitor application\n\tflush_stdin();\n\n\n\n\tif (WIFEXITED(status)) {\n\t\t// if we had a proper exit, return that exit status\n\t\treturn WEXITSTATUS(status);\n\t} else {\n\t\t// something else went wrong!\n\t\treturn -1;\n\t}\n}",
    "includes": [
      "#include <sys/apparmor.h>",
      "#include <sys/prctl.h>",
      "#include <sched.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/prctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [
      "#define CLONE_NEWUSER\t0x10000000"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "status"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "status"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_stdin",
          "args": [],
          "line": 913
        },
        "resolved": true,
        "details": {
          "function_name": "flush_stdin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/util.c",
          "lines": "721-731",
          "snippet": "void flush_stdin(void) {\n\tif (isatty(STDIN_FILENO)) {\n\t\tint cnt = 0;\n\t\tioctl(STDIN_FILENO, FIONREAD, &cnt);\n\t\tif (cnt) {\n\t\t\tif (!arg_quiet)\n\t\t\t\tprintf(\"Warning: removing %d bytes from stdin\\n\", cnt);\n\t\t\tioctl(STDIN_FILENO, TCFLSH, TCIFLUSH);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid flush_stdin(void) {\n\tif (isatty(STDIN_FILENO)) {\n\t\tint cnt = 0;\n\t\tioctl(STDIN_FILENO, FIONREAD, &cnt);\n\t\tif (cnt) {\n\t\t\tif (!arg_quiet)\n\t\t\t\tprintf(\"Warning: removing %d bytes from stdin\\n\", cnt);\n\t\t\tioctl(STDIN_FILENO, TCFLSH, TCIFLUSH);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "monitor_application",
          "args": [
            "app_pid"
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "monitor_application",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/sandbox.c",
          "lines": "188-285",
          "snippet": "static int monitor_application(pid_t app_pid) {\n\tmonitored_pid = app_pid;\n\tsignal (SIGTERM, sandbox_handler);\n\tEUID_USER();\n\n\tint status = 0;\n\twhile (monitored_pid) {\n\t\tusleep(20000);\n\t\tchar *msg;\n\t\tif (asprintf(&msg, \"monitoring pid %d\\n\", monitored_pid) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tlogmsg(msg);\n\t\tif (arg_debug)\n\t\t\tprintf(\"%s\\n\", msg);\n\t\tfree(msg);\n\n\t\tpid_t rv;\n\t\tdo {\n\t\t\trv = waitpid(-1, &status, 0);\n\t\t\tif (rv == -1)\n\t\t\t\tbreak;\n\t\t}\n\t\twhile(rv != monitored_pid);\n\t\tif (arg_debug)\n\t\t\tprintf(\"Sandbox monitor: waitpid %u retval %d status %d\\n\", monitored_pid, rv, status);\n\n\t\t// if /proc is not remounted, we cannot check /proc directory,\n\t\t// for now we just get out of here\n\t\t// todo: find another way of checking child processes!\n\t\tif (!checkcfg(CFG_REMOUNT_PROC_SYS))\n\t\t\tbreak;\n\n\t\tDIR *dir;\n\t\tif (!(dir = opendir(\"/proc\"))) {\n\t\t\t// sleep 2 seconds and try again\n\t\t\tsleep(2);\n\t\t\tif (!(dir = opendir(\"/proc\"))) {\n\t\t\t\tfprintf(stderr, \"Error: cannot open /proc directory\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\n\t\tstruct dirent *entry;\n\t\tmonitored_pid = 0;\n\t\twhile ((entry = readdir(dir)) != NULL) {\n\t\t\tunsigned pid;\n\t\t\tif (sscanf(entry->d_name, \"%u\", &pid) != 1)\n\t\t\t\tcontinue;\n\t\t\tif (pid == 1)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\t// todo: make this generic\n\t\t\t// Dillo browser leaves a dpid process running, we need to shut it down\n\t\t\tif (strcmp(cfg.command_name, \"dillo\") == 0) {\n\t\t\t\tchar *pidname = pid_proc_comm(pid);\n\t\t\t\tif (pidname && strcmp(pidname, \"dpid\") == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tfree(pidname);\n\t\t\t}\n\n\t\t\tmonitored_pid = pid;\n\t\t\tbreak;\n\t\t}\n\t\tclosedir(dir);\n\n\t\tif (monitored_pid != 0 && arg_debug)\n\t\t\tprintf(\"Sandbox monitor: monitoring %u\\n\", monitored_pid);\n\t}\n\n\t// return the latest exit status.\n\treturn status;\n\n#if 0\n// todo: find a way to shut down interfaces before closing the namespace\n// the problem is we don't have enough privileges to shutdown interfaces in this moment\n\t// shut down bridge/macvlan interfaces\n\tif (any_bridge_configured()) {\n\t\t\n\t\tif (cfg.bridge0.configured) {\n\t\t\tprintf(\"Shutting down %s\\n\", cfg.bridge0.devsandbox);\n\t\t\tnet_if_down( cfg.bridge0.devsandbox);\n\t\t}\n\t\tif (cfg.bridge1.configured) {\n\t\t\tprintf(\"Shutting down %s\\n\", cfg.bridge1.devsandbox);\n\t\t\tnet_if_down( cfg.bridge1.devsandbox);\n\t\t}\n\t\tif (cfg.bridge2.configured) {\n\t\t\tprintf(\"Shutting down %s\\n\", cfg.bridge2.devsandbox);\n\t\t\tnet_if_down( cfg.bridge2.devsandbox);\n\t\t}\n\t\tif (cfg.bridge3.configured) {\n\t\t\tprintf(\"Shutting down %s\\n\", cfg.bridge3.devsandbox);\n\t\t\tnet_if_down( cfg.bridge3.devsandbox);\n\t\t}\n\t\tusleep(20000);\t// 20 ms sleep\n\t}\t\n#endif\t\n}",
          "includes": [
            "#include <sys/apparmor.h>",
            "#include <sys/prctl.h>",
            "#include <sched.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/prctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int monitored_pid = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/apparmor.h>\n#include <sys/prctl.h>\n#include <sched.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/prctl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic int monitored_pid = 0;\n\nstatic int monitor_application(pid_t app_pid) {\n\tmonitored_pid = app_pid;\n\tsignal (SIGTERM, sandbox_handler);\n\tEUID_USER();\n\n\tint status = 0;\n\twhile (monitored_pid) {\n\t\tusleep(20000);\n\t\tchar *msg;\n\t\tif (asprintf(&msg, \"monitoring pid %d\\n\", monitored_pid) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tlogmsg(msg);\n\t\tif (arg_debug)\n\t\t\tprintf(\"%s\\n\", msg);\n\t\tfree(msg);\n\n\t\tpid_t rv;\n\t\tdo {\n\t\t\trv = waitpid(-1, &status, 0);\n\t\t\tif (rv == -1)\n\t\t\t\tbreak;\n\t\t}\n\t\twhile(rv != monitored_pid);\n\t\tif (arg_debug)\n\t\t\tprintf(\"Sandbox monitor: waitpid %u retval %d status %d\\n\", monitored_pid, rv, status);\n\n\t\t// if /proc is not remounted, we cannot check /proc directory,\n\t\t// for now we just get out of here\n\t\t// todo: find another way of checking child processes!\n\t\tif (!checkcfg(CFG_REMOUNT_PROC_SYS))\n\t\t\tbreak;\n\n\t\tDIR *dir;\n\t\tif (!(dir = opendir(\"/proc\"))) {\n\t\t\t// sleep 2 seconds and try again\n\t\t\tsleep(2);\n\t\t\tif (!(dir = opendir(\"/proc\"))) {\n\t\t\t\tfprintf(stderr, \"Error: cannot open /proc directory\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\n\t\tstruct dirent *entry;\n\t\tmonitored_pid = 0;\n\t\twhile ((entry = readdir(dir)) != NULL) {\n\t\t\tunsigned pid;\n\t\t\tif (sscanf(entry->d_name, \"%u\", &pid) != 1)\n\t\t\t\tcontinue;\n\t\t\tif (pid == 1)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\t// todo: make this generic\n\t\t\t// Dillo browser leaves a dpid process running, we need to shut it down\n\t\t\tif (strcmp(cfg.command_name, \"dillo\") == 0) {\n\t\t\t\tchar *pidname = pid_proc_comm(pid);\n\t\t\t\tif (pidname && strcmp(pidname, \"dpid\") == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tfree(pidname);\n\t\t\t}\n\n\t\t\tmonitored_pid = pid;\n\t\t\tbreak;\n\t\t}\n\t\tclosedir(dir);\n\n\t\tif (monitored_pid != 0 && arg_debug)\n\t\t\tprintf(\"Sandbox monitor: monitoring %u\\n\", monitored_pid);\n\t}\n\n\t// return the latest exit status.\n\treturn status;\n\n#if 0\n// todo: find a way to shut down interfaces before closing the namespace\n// the problem is we don't have enough privileges to shutdown interfaces in this moment\n\t// shut down bridge/macvlan interfaces\n\tif (any_bridge_configured()) {\n\t\t\n\t\tif (cfg.bridge0.configured) {\n\t\t\tprintf(\"Shutting down %s\\n\", cfg.bridge0.devsandbox);\n\t\t\tnet_if_down( cfg.bridge0.devsandbox);\n\t\t}\n\t\tif (cfg.bridge1.configured) {\n\t\t\tprintf(\"Shutting down %s\\n\", cfg.bridge1.devsandbox);\n\t\t\tnet_if_down( cfg.bridge1.devsandbox);\n\t\t}\n\t\tif (cfg.bridge2.configured) {\n\t\t\tprintf(\"Shutting down %s\\n\", cfg.bridge2.devsandbox);\n\t\t\tnet_if_down( cfg.bridge2.devsandbox);\n\t\t}\n\t\tif (cfg.bridge3.configured) {\n\t\t\tprintf(\"Shutting down %s\\n\", cfg.bridge3.devsandbox);\n\t\t\tnet_if_down( cfg.bridge3.devsandbox);\n\t\t}\n\t\tusleep(20000);\t// 20 ms sleep\n\t}\t\n#endif\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "start_application",
          "args": [],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "start_application",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/sandbox.c",
          "lines": "296-393",
          "snippet": "void start_application(void) {\n//if (setsid() == -1)\n//errExit(\"setsid\");\n\n\t// set environment\n\tenv_defaults();\n\tenv_apply();\n\tif (arg_debug) {\n\t\tprintf(\"starting application\\n\");\n\t\tprintf(\"LD_PRELOAD=%s\\n\", getenv(\"LD_PRELOAD\"));\n\t}\n\n\t//****************************************\n\t// audit\n\t//****************************************\n\tif (arg_audit) {\n\t\tassert(arg_audit_prog);\n\t\tstruct stat s;\n\t\tif (stat(arg_audit_prog, &s) != 0) {\n\t\t\tfprintf(stderr, \"Error: cannot find the audit program\\n\");\n\t\t\texit(1);\n\t\t}\n\t\texecl(arg_audit_prog, arg_audit_prog, NULL);\n\t}\n\t//****************************************\n\t// start the program without using a shell\n\t//****************************************\n\telse if (arg_shell_none) {\n\t\tif (arg_debug) {\n\t\t\tint i;\n\t\t\tfor (i = cfg.original_program_index; i < cfg.original_argc; i++) {\n\t\t\t\tif (cfg.original_argv[i] == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tprintf(\"execvp argument %d: %s\\n\", i - cfg.original_program_index, cfg.original_argv[i]);\n\t\t\t}\n\t\t}\n\n\t\tif (cfg.original_program_index == 0) {\n\t\t\tfprintf(stderr, \"Error: --shell=none configured, but no program specified\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tif (!arg_command && !arg_quiet)\n\t\t\tprintf(\"Child process initialized\\n\");\n\n\t\texecvp(cfg.original_argv[cfg.original_program_index], &cfg.original_argv[cfg.original_program_index]);\n\t\texit(1);\n\t}\n\t//****************************************\n\t// start the program using a shell\n\t//****************************************\n\telse {\n\t\tassert(cfg.shell);\n\t\tassert(cfg.command_line);\n\n\t\tchar *arg[5];\n\t\tint index = 0;\n\t\targ[index++] = cfg.shell;\n\t\tif (login_shell) {\n\t\t\targ[index++] = \"-l\";\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Starting %s login shell\\n\", cfg.shell);\n\t\t} else {\n\t\t\targ[index++] = \"-c\";\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Running %s command through %s\\n\", cfg.command_line, cfg.shell);\n\t\t\tif (arg_doubledash)\n\t\t\t\targ[index++] = \"--\";\n\t\t\targ[index++] = cfg.command_line;\n\t\t}\n\t\targ[index] = NULL;\n\t\tassert(index < 5);\n\n\t\tif (arg_debug) {\n\t\t\tchar *msg;\n\t\t\tif (asprintf(&msg, \"sandbox %d, execvp into %s\", sandbox_pid, cfg.command_line) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tlogmsg(msg);\n\t\t\tfree(msg);\n\t\t}\n\n\t\tif (arg_debug) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < 5; i++) {\n\t\t\t\tif (arg[i] == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tprintf(\"execvp argument %d: %s\\n\", i, arg[i]);\n\t\t\t}\n\t\t}\n\n\t\tif (!arg_command && !arg_quiet)\n\t\t\tprintf(\"Child process initialized\\n\");\n\t\texecvp(arg[0], arg);\n\t}\n\n\tperror(\"execvp\");\n\texit(1); // it should never get here!!!\n}",
          "includes": [
            "#include <sys/apparmor.h>",
            "#include <sys/prctl.h>",
            "#include <sched.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/prctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/apparmor.h>\n#include <sys/prctl.h>\n#include <sched.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/prctl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid start_application(void) {\n//if (setsid() == -1)\n//errExit(\"setsid\");\n\n\t// set environment\n\tenv_defaults();\n\tenv_apply();\n\tif (arg_debug) {\n\t\tprintf(\"starting application\\n\");\n\t\tprintf(\"LD_PRELOAD=%s\\n\", getenv(\"LD_PRELOAD\"));\n\t}\n\n\t//****************************************\n\t// audit\n\t//****************************************\n\tif (arg_audit) {\n\t\tassert(arg_audit_prog);\n\t\tstruct stat s;\n\t\tif (stat(arg_audit_prog, &s) != 0) {\n\t\t\tfprintf(stderr, \"Error: cannot find the audit program\\n\");\n\t\t\texit(1);\n\t\t}\n\t\texecl(arg_audit_prog, arg_audit_prog, NULL);\n\t}\n\t//****************************************\n\t// start the program without using a shell\n\t//****************************************\n\telse if (arg_shell_none) {\n\t\tif (arg_debug) {\n\t\t\tint i;\n\t\t\tfor (i = cfg.original_program_index; i < cfg.original_argc; i++) {\n\t\t\t\tif (cfg.original_argv[i] == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tprintf(\"execvp argument %d: %s\\n\", i - cfg.original_program_index, cfg.original_argv[i]);\n\t\t\t}\n\t\t}\n\n\t\tif (cfg.original_program_index == 0) {\n\t\t\tfprintf(stderr, \"Error: --shell=none configured, but no program specified\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tif (!arg_command && !arg_quiet)\n\t\t\tprintf(\"Child process initialized\\n\");\n\n\t\texecvp(cfg.original_argv[cfg.original_program_index], &cfg.original_argv[cfg.original_program_index]);\n\t\texit(1);\n\t}\n\t//****************************************\n\t// start the program using a shell\n\t//****************************************\n\telse {\n\t\tassert(cfg.shell);\n\t\tassert(cfg.command_line);\n\n\t\tchar *arg[5];\n\t\tint index = 0;\n\t\targ[index++] = cfg.shell;\n\t\tif (login_shell) {\n\t\t\targ[index++] = \"-l\";\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Starting %s login shell\\n\", cfg.shell);\n\t\t} else {\n\t\t\targ[index++] = \"-c\";\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Running %s command through %s\\n\", cfg.command_line, cfg.shell);\n\t\t\tif (arg_doubledash)\n\t\t\t\targ[index++] = \"--\";\n\t\t\targ[index++] = cfg.command_line;\n\t\t}\n\t\targ[index] = NULL;\n\t\tassert(index < 5);\n\n\t\tif (arg_debug) {\n\t\t\tchar *msg;\n\t\t\tif (asprintf(&msg, \"sandbox %d, execvp into %s\", sandbox_pid, cfg.command_line) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tlogmsg(msg);\n\t\t\tfree(msg);\n\t\t}\n\n\t\tif (arg_debug) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < 5; i++) {\n\t\t\t\tif (arg[i] == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tprintf(\"execvp argument %d: %s\\n\", i, arg[i]);\n\t\t\t}\n\t\t}\n\n\t\tif (!arg_command && !arg_quiet)\n\t\t\tprintf(\"Child process initialized\\n\");\n\t\texecvp(arg[0], arg);\n\t}\n\n\tperror(\"execvp\");\n\texit(1); // it should never get here!!!\n}"
        }
      },
      {
        "call_info": {
          "callee": "prctl",
          "args": [
            "PR_SET_PDEATHSIG",
            "SIGKILL",
            "0",
            "0",
            "0"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"AppArmor enabled\\n\""
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 902
        },
        "resolved": true,
        "details": {
          "function_name": "myexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/main.c",
          "lines": "137-149",
          "snippet": "static void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}",
          "includes": [
            "#include <sys/times.h>",
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int arg_command = 0;",
            "int arg_quiet = 0;",
            "pid_t sandbox_pid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/times.h>\n#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nint arg_command = 0;\nint arg_quiet = 0;\npid_t sandbox_pid;\n\nstatic void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"As root, run \\\"aa-enforce firejail-default\\\" to load it.\\n\""
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Maybe firejail-default AppArmor profile is not loaded into the kernel.\\n\""
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot confine the application using AppArmor.\\n\""
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_change_onexec",
          "args": [
            "\"firejail-default\""
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"fork\""
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"NO_NEW_PRIVS set\\n\""
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: NO_NEW_PRIVS disabled, it requires a Linux kernel version 3.5 or newer.\\n\""
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prctl",
          "args": [
            "PR_SET_NO_NEW_PRIVS",
            "1",
            "0",
            "0",
            "0"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_caps",
          "args": [],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "set_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/sandbox.c",
          "lines": "93-102",
          "snippet": "static void set_caps(void) {\n\tif (arg_caps_drop_all)\n\t\tcaps_drop_all();\n\telse if (arg_caps_drop)\n\t\tcaps_drop_list(arg_caps_list);\n\telse if (arg_caps_keep)\n\t\tcaps_keep_list(arg_caps_list);\n\telse if (arg_caps_default_filter)\n\t\tcaps_default_filter();\n}",
          "includes": [
            "#include <sys/apparmor.h>",
            "#include <sys/prctl.h>",
            "#include <sched.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/prctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/apparmor.h>\n#include <sys/prctl.h>\n#include <sched.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/prctl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void set_caps(void) {\n\tif (arg_caps_drop_all)\n\t\tcaps_drop_all();\n\telse if (arg_caps_drop)\n\t\tcaps_drop_list(arg_caps_list);\n\telse if (arg_caps_keep)\n\t\tcaps_keep_list(arg_caps_list);\n\telse if (arg_caps_default_filter)\n\t\tcaps_default_filter();\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"noroot user namespace installed\\n\""
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "parent_to_child_fds[0]"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_other",
          "args": [
            "parent_to_child_fds[0]"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "wait_for_other",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/util.c",
          "lines": "541-569",
          "snippet": "void wait_for_other(int fd) {\n\t//****************************\n\t// wait for the parent to be initialized\n\t//****************************\n\tchar childstr[BUFLEN + 1];\n\tint newfd = dup(fd);\n\tif (newfd == -1)\n\t\terrExit(\"dup\");\n\tFILE* stream;\n\tstream = fdopen(newfd, \"r\");\n\t*childstr = '\\0';\n\tif (fgets(childstr, BUFLEN, stream)) {\n\t\t// remove \\n)\n\t\tchar *ptr = childstr;\n\t\twhile(*ptr !='\\0' && *ptr != '\\n')\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\terrExit(\"fgets\");\n\t\t*ptr = '\\0';\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: cannot establish communication with the parent, exiting...\\n\");\n\t\texit(1);\n\t}\n\tif (strcmp(childstr, \"arg_noroot=0\") == 0)\n\t\targ_noroot = 0;\n\n\tfclose(stream);\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define BUFLEN 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\n#define BUFLEN 4096\n\nvoid wait_for_other(int fd) {\n\t//****************************\n\t// wait for the parent to be initialized\n\t//****************************\n\tchar childstr[BUFLEN + 1];\n\tint newfd = dup(fd);\n\tif (newfd == -1)\n\t\terrExit(\"dup\");\n\tFILE* stream;\n\tstream = fdopen(newfd, \"r\");\n\t*childstr = '\\0';\n\tif (fgets(childstr, BUFLEN, stream)) {\n\t\t// remove \\n)\n\t\tchar *ptr = childstr;\n\t\twhile(*ptr !='\\0' && *ptr != '\\n')\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\terrExit(\"fgets\");\n\t\t*ptr = '\\0';\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: cannot establish communication with the parent, exiting...\\n\");\n\t\texit(1);\n\t}\n\tif (strcmp(childstr, \"arg_noroot=0\") == 0)\n\t\targ_noroot = 0;\n\n\tfclose(stream);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "child_to_parent_fds[1]"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "notify_other",
          "args": [
            "child_to_parent_fds[1]"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "notify_other",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/util.c",
          "lines": "572-581",
          "snippet": "void notify_other(int fd) {\n\tFILE* stream;\n\tint newfd = dup(fd);\n\tif (newfd == -1)\n\t\terrExit(\"dup\");\n\tstream = fdopen(newfd, \"w\");\n\tfprintf(stream, \"arg_noroot=%d\\n\", arg_noroot);\n\tfflush(stream);\n\tfclose(stream);\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid notify_other(int fd) {\n\tFILE* stream;\n\tint newfd = dup(fd);\n\tif (newfd == -1)\n\t\terrExit(\"dup\");\n\tstream = fdopen(newfd, \"w\");\n\tfprintf(stream, \"arg_noroot=%d\\n\", arg_noroot);\n\tfflush(stream);\n\tfclose(stream);\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_privs",
          "args": [
            "arg_nogroups"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "drop_privs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/util.c",
          "lines": "36-81",
          "snippet": "void drop_privs(int nogroups) {\n\tEUID_ROOT();\n\tgid_t gid = getgid();\n\n\t// configure supplementary groups\n\tif (gid == 0 || nogroups) {\n\t\tif (setgroups(0, NULL) < 0)\n\t\t\terrExit(\"setgroups\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Username %s, no supplementary groups\\n\", cfg.username);\n\t}\n\telse {\n\t\tassert(cfg.username);\n\t\tgid_t groups[MAX_GROUPS];\n\t\tint ngroups = MAX_GROUPS;\n\t\tint rv = getgrouplist(cfg.username, gid, groups, &ngroups);\n\n\t\tif (arg_debug && rv) {\n\t\t\tprintf(\"Username %s, groups \", cfg.username);\n\t\t\tint i;\n\t\t\tfor (i = 0; i < ngroups; i++)\n\t\t\t\tprintf(\"%u, \", groups[i]);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\n\t\tif (rv == -1) {\n\t\t\tfprintf(stderr, \"Warning: cannot extract supplementary group list, dropping them\\n\");\n\t\t\tif (setgroups(0, NULL) < 0)\n\t\t\t\terrExit(\"setgroups\");\n\t\t}\n\t\telse {\n\t\t\trv = setgroups(ngroups, groups);\n\t\t\tif (rv) {\n\t\t\t\tfprintf(stderr, \"Warning: cannot set supplementary group list, dropping them\\n\");\n\t\t\t\tif (setgroups(0, NULL) < 0)\n\t\t\t\t\terrExit(\"setgroups\");\n\t\t\t}\n\t\t}\n\t}\n\n\t// set uid/gid\n\tif (setgid(getgid()) < 0)\n\t\terrExit(\"setgid/getgid\");\n\tif (setuid(getuid()) < 0)\n\t\terrExit(\"setuid/getuid\");\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAX_GROUPS 1024"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\n#define MAX_GROUPS 1024\n\nvoid drop_privs(int nogroups) {\n\tEUID_ROOT();\n\tgid_t gid = getgid();\n\n\t// configure supplementary groups\n\tif (gid == 0 || nogroups) {\n\t\tif (setgroups(0, NULL) < 0)\n\t\t\terrExit(\"setgroups\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Username %s, no supplementary groups\\n\", cfg.username);\n\t}\n\telse {\n\t\tassert(cfg.username);\n\t\tgid_t groups[MAX_GROUPS];\n\t\tint ngroups = MAX_GROUPS;\n\t\tint rv = getgrouplist(cfg.username, gid, groups, &ngroups);\n\n\t\tif (arg_debug && rv) {\n\t\t\tprintf(\"Username %s, groups \", cfg.username);\n\t\t\tint i;\n\t\t\tfor (i = 0; i < ngroups; i++)\n\t\t\t\tprintf(\"%u, \", groups[i]);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\n\t\tif (rv == -1) {\n\t\t\tfprintf(stderr, \"Warning: cannot extract supplementary group list, dropping them\\n\");\n\t\t\tif (setgroups(0, NULL) < 0)\n\t\t\t\terrExit(\"setgroups\");\n\t\t}\n\t\telse {\n\t\t\trv = setgroups(ngroups, groups);\n\t\t\tif (rv) {\n\t\t\t\tfprintf(stderr, \"Warning: cannot set supplementary group list, dropping them\\n\");\n\t\t\t\tif (setgroups(0, NULL) < 0)\n\t\t\t\t\terrExit(\"setgroups\");\n\t\t\t}\n\t\t}\n\t}\n\n\t// set uid/gid\n\tif (setgid(getgid()) < 0)\n\t\terrExit(\"setgid/getgid\");\n\tif (setuid(getuid()) < 0)\n\t\terrExit(\"setuid/getuid\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: cannot create a new user namespace, going forward without it...\\n\""
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unshare",
          "args": [
            "CLONE_NEWUSER"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "save_nogroups",
          "args": [],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "save_nogroups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/sandbox.c",
          "lines": "104-119",
          "snippet": "void save_nogroups(void) {\n\tif (arg_nogroups == 0)\n\t\treturn;\n\n\tFILE *fp = fopen(RUN_GROUPS_CFG, \"w\");\n\tif (fp) {\n\t\tfprintf(fp, \"\\n\");\n\t\tSET_PERMS_STREAM(fp, 0, 0, 0644); // assume mode 0644\n\t\tfclose(fp);\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: cannot save nogroups state\\n\");\n\t\texit(1);\n\t}\n\t\n}",
          "includes": [
            "#include <sys/apparmor.h>",
            "#include <sys/prctl.h>",
            "#include <sched.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/prctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/apparmor.h>\n#include <sys/prctl.h>\n#include <sched.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/prctl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid save_nogroups(void) {\n\tif (arg_nogroups == 0)\n\t\treturn;\n\n\tFILE *fp = fopen(RUN_GROUPS_CFG, \"w\");\n\tif (fp) {\n\t\tfprintf(fp, \"\\n\");\n\t\tSET_PERMS_STREAM(fp, 0, 0, 0644); // assume mode 0644\n\t\tfclose(fp);\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: cannot save nogroups state\\n\");\n\t\texit(1);\n\t}\n\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "save_cgroup",
          "args": [],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "save_cgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/cgroup.c",
          "lines": "25-45",
          "snippet": "void save_cgroup(void) {\n\tif (cfg.cgroup == NULL)\n\t\treturn;\n\t\n\tFILE *fp = fopen(RUN_CGROUP_CFG, \"w\");\n\tif (fp) {\n\t\tfprintf(fp, \"%s\", cfg.cgroup);\n\t\tfflush(0);\n\t\tSET_PERMS_STREAM(fp, 0, 0, 0644);\n\t\tif (fclose(fp))\n\t\t\tgoto errout;\n\t}\n\telse\n\t\tgoto errout;\n\t\n\treturn;\n\nerrout:\n\tfprintf(stderr, \"Error: cannot save cgroup\\n\");\n\texit(1);\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include \"firejail.h\"\n\nvoid save_cgroup(void) {\n\tif (cfg.cgroup == NULL)\n\t\treturn;\n\t\n\tFILE *fp = fopen(RUN_CGROUP_CFG, \"w\");\n\tif (fp) {\n\t\tfprintf(fp, \"%s\", cfg.cgroup);\n\t\tfflush(0);\n\t\tSET_PERMS_STREAM(fp, 0, 0, 0644);\n\t\tif (fclose(fp))\n\t\t\tgoto errout;\n\t}\n\telse\n\t\tgoto errout;\n\t\n\treturn;\n\nerrout:\n\tfprintf(stderr, \"Error: cannot save cgroup\\n\");\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_cpu_affinity",
          "args": [],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "set_cpu_affinity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/cpu.c",
          "lines": "106-138",
          "snippet": "void set_cpu_affinity(void) {\n\t// set cpu affinity\n\tcpu_set_t mask;\n\tCPU_ZERO(&mask);\n\t\n\tint i;\n\tuint32_t m = 1;\n\tfor (i = 0; i < 32; i++, m <<= 1) {\n\t\tif (cfg.cpus & m)\n\t\t\tCPU_SET(i, &mask);\n\t}\n\t\n        \tif (sched_setaffinity(0, sizeof(mask), &mask) == -1) {\n        \t\tfprintf(stderr, \"Warning: cannot set cpu affinity\\n\");\n        \t\tfprintf(stderr, \"  \");\n        \t\tperror(\"sched_setaffinity\");\n        \t}\n        \t\n        \t// verify cpu affinity\n\tcpu_set_t mask2;\n\tCPU_ZERO(&mask2);\n        \tif (sched_getaffinity(0, sizeof(mask2), &mask2) == -1) {\n        \t\tfprintf(stderr, \"Warning: cannot verify cpu affinity\\n\");\n        \t\tfprintf(stderr, \"   \");\n        \t\tperror(\"sched_getaffinity\");\n        \t}\n        \telse if (arg_debug) {\n\t        \tif (CPU_EQUAL(&mask, &mask2))\n        \t\t\tprintf(\"CPU affinity set\\n\");\n\t\telse\n        \t\t\tprintf(\"CPU affinity not set\\n\");\n        \t}\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <sched.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <unistd.h>\n#include <sched.h>\n#include \"firejail.h\"\n\nvoid set_cpu_affinity(void) {\n\t// set cpu affinity\n\tcpu_set_t mask;\n\tCPU_ZERO(&mask);\n\t\n\tint i;\n\tuint32_t m = 1;\n\tfor (i = 0; i < 32; i++, m <<= 1) {\n\t\tif (cfg.cpus & m)\n\t\t\tCPU_SET(i, &mask);\n\t}\n\t\n        \tif (sched_setaffinity(0, sizeof(mask), &mask) == -1) {\n        \t\tfprintf(stderr, \"Warning: cannot set cpu affinity\\n\");\n        \t\tfprintf(stderr, \"  \");\n        \t\tperror(\"sched_setaffinity\");\n        \t}\n        \t\n        \t// verify cpu affinity\n\tcpu_set_t mask2;\n\tCPU_ZERO(&mask2);\n        \tif (sched_getaffinity(0, sizeof(mask2), &mask2) == -1) {\n        \t\tfprintf(stderr, \"Warning: cannot verify cpu affinity\\n\");\n        \t\tfprintf(stderr, \"   \");\n        \t\tperror(\"sched_getaffinity\");\n        \t}\n        \telse if (arg_debug) {\n\t        \tif (CPU_EQUAL(&mask, &mask2))\n        \t\t\tprintf(\"CPU affinity set\\n\");\n\t\telse\n        \t\t\tprintf(\"CPU affinity not set\\n\");\n        \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "save_cpu",
          "args": [],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "save_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/cpu.c",
          "lines": "74-88",
          "snippet": "void save_cpu(void) {\n\tif (cfg.cpus == 0)\n\t\treturn;\n\n\tFILE *fp = fopen(RUN_CPU_CFG, \"w\");\n\tif (fp) {\n\t\tfprintf(fp, \"%x\\n\", cfg.cpus);\n\t\tSET_PERMS_STREAM(fp, 0, 0, 0600);\n\t\tfclose(fp);\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: cannot save cpu affinity mask\\n\");\n\t\texit(1);\n\t}\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <sched.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <unistd.h>\n#include <sched.h>\n#include \"firejail.h\"\n\nvoid save_cpu(void) {\n\tif (cfg.cpus == 0)\n\t\treturn;\n\n\tFILE *fp = fopen(RUN_CPU_CFG, \"w\");\n\tif (fp) {\n\t\tfprintf(fp, \"%x\\n\", cfg.cpus);\n\t\tSET_PERMS_STREAM(fp, 0, 0, 0600);\n\t\tfclose(fp);\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: cannot save cpu affinity mask\\n\");\n\t\texit(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "seccomp_filter_drop",
          "args": [
            "enforce_seccomp"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_filter_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/seccomp.c",
          "lines": "487-733",
          "snippet": "int seccomp_filter_drop(int enforce_seccomp) {\n\tfilter_init();\n\t\n\t// default seccomp\n\tif (cfg.seccomp_list_drop == NULL) {\n#if defined(__x86_64__)\n\t\tseccomp_filter_32();\n#endif\n#if defined(__i386__)\n\t\tseccomp_filter_64();\n#endif\n\n#ifdef SYS_mount\t\t\n\t\tfilter_add_blacklist(SYS_mount, 0);\n#endif\n#ifdef SYS_umount2\t\t\n\t\tfilter_add_blacklist(SYS_umount2, 0);\n#endif\n\n\t\tif (!arg_allow_debuggers) {\n#ifdef SYS_ptrace \t\t\n\t\t\tfilter_add_blacklist(SYS_ptrace, 0);\n#endif\n\t\t}\n\n#ifdef SYS_kexec_load\t\t\n\t\tfilter_add_blacklist(SYS_kexec_load, 0);\n#endif\n#ifdef SYS_kexec_file_load\t\t\n\t\tfilter_add_blacklist(SYS_kexec_file_load, 0);\n#endif\n#ifdef SYS_open_by_handle_at\t\t\n\t\tfilter_add_blacklist(SYS_open_by_handle_at, 0);\n#endif\n#ifdef SYS_name_to_handle_at\t\t\n\t\tfilter_add_blacklist(SYS_name_to_handle_at, 0);\n#endif\n#ifdef SYS_init_module\t\t\n\t\tfilter_add_blacklist(SYS_init_module, 0);\n#endif\n#ifdef SYS_finit_module // introduced in 2013\n\t\tfilter_add_blacklist(SYS_finit_module, 0);\n#endif\n#ifdef SYS_create_module\n\t\tfilter_add_blacklist(SYS_create_module, 0);\n#endif\n#ifdef SYS_delete_module\t\t\n\t\tfilter_add_blacklist(SYS_delete_module, 0);\n#endif\n#ifdef SYS_iopl\t\t\n\t\tfilter_add_blacklist(SYS_iopl, 0);\n#endif\n#ifdef \tSYS_ioperm\t\n\t\tfilter_add_blacklist(SYS_ioperm, 0);\n#endif\n#ifdef \tSYS_ioprio_set\t\n\t\tfilter_add_blacklist(SYS_ioprio_set, 0);\n#endif\n#ifdef SYS_ni_syscall // new io permissions call on arm devices\n\t\tfilter_add_blacklist(SYS_ni_syscall, 0);\n#endif\n#ifdef SYS_swapon\t\t\n\t\tfilter_add_blacklist(SYS_swapon, 0);\n#endif\n#ifdef SYS_swapoff\t\t\n\t\tfilter_add_blacklist(SYS_swapoff, 0);\n#endif\n#ifdef SYS_syslog\t\t\n\t\tfilter_add_blacklist(SYS_syslog, 0);\n#endif\n\t\tif (!arg_allow_debuggers) {\n#ifdef SYS_process_vm_readv\t\t\n\t\t\tfilter_add_blacklist(SYS_process_vm_readv, 0);\n#endif\n\t\t}\n\t\t\n#ifdef SYS_process_vm_writev\t\t\n\t\tfilter_add_blacklist(SYS_process_vm_writev, 0);\n#endif\n\n// mknod removed in 0.9.29 - it brakes Zotero extension\n//#ifdef SYS_mknod\t\t\n//\t\tfilter_add_blacklist(SYS_mknod, 0);\n//#endif\n\t\t\n\t\t// new syscalls in 0.9,23\t\t\n#ifdef SYS_sysfs\t\t\n\t\tfilter_add_blacklist(SYS_sysfs, 0);\n#endif\n#ifdef SYS__sysctl\t\n\t\tfilter_add_blacklist(SYS__sysctl, 0);\n#endif\n#ifdef SYS_adjtimex\t\t\n\t\tfilter_add_blacklist(SYS_adjtimex, 0);\n#endif\n#ifdef \tSYS_clock_adjtime\t\n\t\tfilter_add_blacklist(SYS_clock_adjtime, 0);\n#endif\n#ifdef SYS_lookup_dcookie\t\t\n\t\tfilter_add_blacklist(SYS_lookup_dcookie, 0);\n#endif\n#ifdef \tSYS_perf_event_open\t\n\t\tfilter_add_blacklist(SYS_perf_event_open, 0);\n#endif\n#ifdef\tSYS_fanotify_init \t\n\t\tfilter_add_blacklist(SYS_fanotify_init, 0);\n#endif\n#ifdef SYS_kcmp\n\t\tfilter_add_blacklist(SYS_kcmp, 0);\n#endif\n\n// 0.9.32\n#ifdef SYS_add_key\n\t\tfilter_add_blacklist(SYS_add_key, 0);\n#endif\n#ifdef SYS_request_key\n\t\tfilter_add_blacklist(SYS_request_key, 0);\n#endif\n#ifdef SYS_keyctl\n\t\tfilter_add_blacklist(SYS_keyctl, 0);\n#endif\n#ifdef SYS_uselib\n\t\tfilter_add_blacklist(SYS_uselib, 0);\n#endif\n#ifdef SYS_acct\n\t\tfilter_add_blacklist(SYS_acct, 0);\n#endif\n#ifdef SYS_modify_ldt\n\t\tfilter_add_blacklist(SYS_modify_ldt, 0);\n#endif\n\t//#ifdef SYS_unshare\n\t//\t\tfilter_add_blacklist(SYS_unshare, 0);\n\t//#endif\n#ifdef SYS_pivot_root\n\t\tfilter_add_blacklist(SYS_pivot_root, 0);\n#endif\n\t//#ifdef SYS_quotactl\n\t//\t\tfilter_add_blacklist(SYS_quotactl, 0);\n\t//#endif\n#ifdef SYS_io_setup\n\t\tfilter_add_blacklist(SYS_io_setup, 0);\n#endif\n#ifdef SYS_io_destroy\n\t\tfilter_add_blacklist(SYS_io_destroy, 0);\n#endif\n#ifdef SYS_io_getevents\n\t\tfilter_add_blacklist(SYS_io_getevents, 0);\n#endif\n#ifdef SYS_io_submit\n\t\tfilter_add_blacklist(SYS_io_submit, 0);\n#endif\n#ifdef SYS_io_cancel\n\t\tfilter_add_blacklist(SYS_io_cancel, 0);\n#endif\n#ifdef SYS_remap_file_pages\n\t\tfilter_add_blacklist(SYS_remap_file_pages, 0);\n#endif\n#ifdef SYS_mbind\n\t\tfilter_add_blacklist(SYS_mbind, 0);\n#endif\n#ifdef SYS_get_mempolicy\n\t\tfilter_add_blacklist(SYS_get_mempolicy, 0);\n#endif\n#ifdef SYS_set_mempolicy\n\t\tfilter_add_blacklist(SYS_set_mempolicy, 0);\n#endif\n#ifdef SYS_migrate_pages\n\t\tfilter_add_blacklist(SYS_migrate_pages, 0);\n#endif\n#ifdef SYS_move_pages\n\t\tfilter_add_blacklist(SYS_move_pages, 0);\n#endif\n#ifdef SYS_vmsplice\n\t\tfilter_add_blacklist(SYS_vmsplice, 0);\n#endif\n#ifdef SYS_chroot\n\t\tfilter_add_blacklist(SYS_chroot, 0);\n#endif\n\t//#ifdef SYS_set_robust_list\n\t//\t\tfilter_add_blacklist(SYS_set_robust_list, 0);\n\t//#endif\n\t//#ifdef SYS_get_robust_list\n\t//\t\tfilter_add_blacklist(SYS_get_robust_list, 0);\n\t//#endif\n\n // CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), SCMP_SYS(clone), 1,\n //     SCMP_A0(SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)));\n\n// 0.9.39\n#ifdef SYS_tuxcall\n\t\tfilter_add_blacklist(SYS_tuxcall, 0);\n#endif\n#ifdef SYS_reboot\n\t\tfilter_add_blacklist(SYS_reboot, 0);\n#endif\n#ifdef SYS_nfsservctl\n\t\tfilter_add_blacklist(SYS_nfsservctl, 0);\n#endif\n#ifdef SYS_get_kernel_syms\n\t\tfilter_add_blacklist(SYS_get_kernel_syms, 0);\n#endif\n\n\t}\n\n\t// default seccomp filter with additional drop list\n\tif (cfg.seccomp_list && cfg.seccomp_list_drop == NULL) {\n\t\tif (syscall_check_list(cfg.seccomp_list, filter_add_blacklist, 0)) {\n\t\t\tfprintf(stderr, \"Error: cannot load seccomp filter\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\t// drop list\n\telse if (cfg.seccomp_list == NULL && cfg.seccomp_list_drop) {\n\t\tif (syscall_check_list(cfg.seccomp_list_drop, filter_add_blacklist, 0)) {\n\t\t\tfprintf(stderr, \"Error: cannot load seccomp filter\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\t\n\t\n\tfilter_end_blacklist();\n\tif (arg_debug)\n\t\tfilter_debug();\n\n\t// save seccomp filter in  /run/firejail/mnt/seccomp\n\t// in order to use it in --join operations\n\twrite_seccomp_file();\n\n\n\tstruct sock_fprog prog = {\n\t\t.len = sfilter_index,\n\t\t.filter = sfilter,\n\t};\n\n\tif (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog) || prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {\n\t\tif (enforce_seccomp) {\n\t\t\tfprintf(stderr, \"Error: a seccomp-enabled Linux kernel is required, exiting...\\n\");\n\t\t\texit(1);\n\t\t}\n\t\telse\n\t\t\tfprintf(stderr, \"Warning: seccomp disabled, it requires a Linux kernel version 3.5 or newer.\\n\");\n\n\t\treturn 1;\n\t}\n\t\n\treturn 0;\n}",
          "includes": [
            "#include \"seccomp.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"seccomp.h\"\n#include \"firejail.h\"\n\nint seccomp_filter_drop(int enforce_seccomp) {\n\tfilter_init();\n\t\n\t// default seccomp\n\tif (cfg.seccomp_list_drop == NULL) {\n#if defined(__x86_64__)\n\t\tseccomp_filter_32();\n#endif\n#if defined(__i386__)\n\t\tseccomp_filter_64();\n#endif\n\n#ifdef SYS_mount\t\t\n\t\tfilter_add_blacklist(SYS_mount, 0);\n#endif\n#ifdef SYS_umount2\t\t\n\t\tfilter_add_blacklist(SYS_umount2, 0);\n#endif\n\n\t\tif (!arg_allow_debuggers) {\n#ifdef SYS_ptrace \t\t\n\t\t\tfilter_add_blacklist(SYS_ptrace, 0);\n#endif\n\t\t}\n\n#ifdef SYS_kexec_load\t\t\n\t\tfilter_add_blacklist(SYS_kexec_load, 0);\n#endif\n#ifdef SYS_kexec_file_load\t\t\n\t\tfilter_add_blacklist(SYS_kexec_file_load, 0);\n#endif\n#ifdef SYS_open_by_handle_at\t\t\n\t\tfilter_add_blacklist(SYS_open_by_handle_at, 0);\n#endif\n#ifdef SYS_name_to_handle_at\t\t\n\t\tfilter_add_blacklist(SYS_name_to_handle_at, 0);\n#endif\n#ifdef SYS_init_module\t\t\n\t\tfilter_add_blacklist(SYS_init_module, 0);\n#endif\n#ifdef SYS_finit_module // introduced in 2013\n\t\tfilter_add_blacklist(SYS_finit_module, 0);\n#endif\n#ifdef SYS_create_module\n\t\tfilter_add_blacklist(SYS_create_module, 0);\n#endif\n#ifdef SYS_delete_module\t\t\n\t\tfilter_add_blacklist(SYS_delete_module, 0);\n#endif\n#ifdef SYS_iopl\t\t\n\t\tfilter_add_blacklist(SYS_iopl, 0);\n#endif\n#ifdef \tSYS_ioperm\t\n\t\tfilter_add_blacklist(SYS_ioperm, 0);\n#endif\n#ifdef \tSYS_ioprio_set\t\n\t\tfilter_add_blacklist(SYS_ioprio_set, 0);\n#endif\n#ifdef SYS_ni_syscall // new io permissions call on arm devices\n\t\tfilter_add_blacklist(SYS_ni_syscall, 0);\n#endif\n#ifdef SYS_swapon\t\t\n\t\tfilter_add_blacklist(SYS_swapon, 0);\n#endif\n#ifdef SYS_swapoff\t\t\n\t\tfilter_add_blacklist(SYS_swapoff, 0);\n#endif\n#ifdef SYS_syslog\t\t\n\t\tfilter_add_blacklist(SYS_syslog, 0);\n#endif\n\t\tif (!arg_allow_debuggers) {\n#ifdef SYS_process_vm_readv\t\t\n\t\t\tfilter_add_blacklist(SYS_process_vm_readv, 0);\n#endif\n\t\t}\n\t\t\n#ifdef SYS_process_vm_writev\t\t\n\t\tfilter_add_blacklist(SYS_process_vm_writev, 0);\n#endif\n\n// mknod removed in 0.9.29 - it brakes Zotero extension\n//#ifdef SYS_mknod\t\t\n//\t\tfilter_add_blacklist(SYS_mknod, 0);\n//#endif\n\t\t\n\t\t// new syscalls in 0.9,23\t\t\n#ifdef SYS_sysfs\t\t\n\t\tfilter_add_blacklist(SYS_sysfs, 0);\n#endif\n#ifdef SYS__sysctl\t\n\t\tfilter_add_blacklist(SYS__sysctl, 0);\n#endif\n#ifdef SYS_adjtimex\t\t\n\t\tfilter_add_blacklist(SYS_adjtimex, 0);\n#endif\n#ifdef \tSYS_clock_adjtime\t\n\t\tfilter_add_blacklist(SYS_clock_adjtime, 0);\n#endif\n#ifdef SYS_lookup_dcookie\t\t\n\t\tfilter_add_blacklist(SYS_lookup_dcookie, 0);\n#endif\n#ifdef \tSYS_perf_event_open\t\n\t\tfilter_add_blacklist(SYS_perf_event_open, 0);\n#endif\n#ifdef\tSYS_fanotify_init \t\n\t\tfilter_add_blacklist(SYS_fanotify_init, 0);\n#endif\n#ifdef SYS_kcmp\n\t\tfilter_add_blacklist(SYS_kcmp, 0);\n#endif\n\n// 0.9.32\n#ifdef SYS_add_key\n\t\tfilter_add_blacklist(SYS_add_key, 0);\n#endif\n#ifdef SYS_request_key\n\t\tfilter_add_blacklist(SYS_request_key, 0);\n#endif\n#ifdef SYS_keyctl\n\t\tfilter_add_blacklist(SYS_keyctl, 0);\n#endif\n#ifdef SYS_uselib\n\t\tfilter_add_blacklist(SYS_uselib, 0);\n#endif\n#ifdef SYS_acct\n\t\tfilter_add_blacklist(SYS_acct, 0);\n#endif\n#ifdef SYS_modify_ldt\n\t\tfilter_add_blacklist(SYS_modify_ldt, 0);\n#endif\n\t//#ifdef SYS_unshare\n\t//\t\tfilter_add_blacklist(SYS_unshare, 0);\n\t//#endif\n#ifdef SYS_pivot_root\n\t\tfilter_add_blacklist(SYS_pivot_root, 0);\n#endif\n\t//#ifdef SYS_quotactl\n\t//\t\tfilter_add_blacklist(SYS_quotactl, 0);\n\t//#endif\n#ifdef SYS_io_setup\n\t\tfilter_add_blacklist(SYS_io_setup, 0);\n#endif\n#ifdef SYS_io_destroy\n\t\tfilter_add_blacklist(SYS_io_destroy, 0);\n#endif\n#ifdef SYS_io_getevents\n\t\tfilter_add_blacklist(SYS_io_getevents, 0);\n#endif\n#ifdef SYS_io_submit\n\t\tfilter_add_blacklist(SYS_io_submit, 0);\n#endif\n#ifdef SYS_io_cancel\n\t\tfilter_add_blacklist(SYS_io_cancel, 0);\n#endif\n#ifdef SYS_remap_file_pages\n\t\tfilter_add_blacklist(SYS_remap_file_pages, 0);\n#endif\n#ifdef SYS_mbind\n\t\tfilter_add_blacklist(SYS_mbind, 0);\n#endif\n#ifdef SYS_get_mempolicy\n\t\tfilter_add_blacklist(SYS_get_mempolicy, 0);\n#endif\n#ifdef SYS_set_mempolicy\n\t\tfilter_add_blacklist(SYS_set_mempolicy, 0);\n#endif\n#ifdef SYS_migrate_pages\n\t\tfilter_add_blacklist(SYS_migrate_pages, 0);\n#endif\n#ifdef SYS_move_pages\n\t\tfilter_add_blacklist(SYS_move_pages, 0);\n#endif\n#ifdef SYS_vmsplice\n\t\tfilter_add_blacklist(SYS_vmsplice, 0);\n#endif\n#ifdef SYS_chroot\n\t\tfilter_add_blacklist(SYS_chroot, 0);\n#endif\n\t//#ifdef SYS_set_robust_list\n\t//\t\tfilter_add_blacklist(SYS_set_robust_list, 0);\n\t//#endif\n\t//#ifdef SYS_get_robust_list\n\t//\t\tfilter_add_blacklist(SYS_get_robust_list, 0);\n\t//#endif\n\n // CHECK_SECCOMP(seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), SCMP_SYS(clone), 1,\n //     SCMP_A0(SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)));\n\n// 0.9.39\n#ifdef SYS_tuxcall\n\t\tfilter_add_blacklist(SYS_tuxcall, 0);\n#endif\n#ifdef SYS_reboot\n\t\tfilter_add_blacklist(SYS_reboot, 0);\n#endif\n#ifdef SYS_nfsservctl\n\t\tfilter_add_blacklist(SYS_nfsservctl, 0);\n#endif\n#ifdef SYS_get_kernel_syms\n\t\tfilter_add_blacklist(SYS_get_kernel_syms, 0);\n#endif\n\n\t}\n\n\t// default seccomp filter with additional drop list\n\tif (cfg.seccomp_list && cfg.seccomp_list_drop == NULL) {\n\t\tif (syscall_check_list(cfg.seccomp_list, filter_add_blacklist, 0)) {\n\t\t\tfprintf(stderr, \"Error: cannot load seccomp filter\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\t// drop list\n\telse if (cfg.seccomp_list == NULL && cfg.seccomp_list_drop) {\n\t\tif (syscall_check_list(cfg.seccomp_list_drop, filter_add_blacklist, 0)) {\n\t\t\tfprintf(stderr, \"Error: cannot load seccomp filter\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\t\n\t\n\tfilter_end_blacklist();\n\tif (arg_debug)\n\t\tfilter_debug();\n\n\t// save seccomp filter in  /run/firejail/mnt/seccomp\n\t// in order to use it in --join operations\n\twrite_seccomp_file();\n\n\n\tstruct sock_fprog prog = {\n\t\t.len = sfilter_index,\n\t\t.filter = sfilter,\n\t};\n\n\tif (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog) || prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {\n\t\tif (enforce_seccomp) {\n\t\t\tfprintf(stderr, \"Error: a seccomp-enabled Linux kernel is required, exiting...\\n\");\n\t\t\texit(1);\n\t\t}\n\t\telse\n\t\t\tfprintf(stderr, \"Warning: seccomp disabled, it requires a Linux kernel version 3.5 or newer.\\n\");\n\n\t\treturn 1;\n\t}\n\t\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seccomp_filter_errno",
          "args": [],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_filter_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/seccomp.c",
          "lines": "779-817",
          "snippet": "int seccomp_filter_errno(void) {\n\tint i;\n\tint higest_errno = errno_highest_nr();\n\tfilter_init();\n\n\t// apply errno list\n\n\tfor (i = 0; i < higest_errno; i++) {\n\t\tif (cfg.seccomp_list_errno[i]) {\n\t\t\tif (syscall_check_list(cfg.seccomp_list_errno[i], filter_add_errno, i)) {\n\t\t\t\tfprintf(stderr, \"Error: cannot load seccomp filter\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t}\n\n\tfilter_end_blacklist();\n\tif (arg_debug)\n\t\tfilter_debug();\n\n\t// save seccomp filter in  /run/firejail/mnt/seccomp\n\t// in order to use it in --join operations\n\twrite_seccomp_file();\n\n\tstruct sock_fprog prog = {\n\t\t.len = sfilter_index,\n\t\t.filter = sfilter,\n\t};\n\n\tif (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog) || prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {\n\t\tfprintf(stderr, \"Warning: seccomp disabled, it requires a Linux kernel version 3.5 or newer.\\n\");\n\t\treturn 1;\n\t}\n\telse if (arg_debug) {\n\t\tprintf(\"seccomp enabled\\n\");\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"seccomp.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"seccomp.h\"\n#include \"firejail.h\"\n\nint seccomp_filter_errno(void) {\n\tint i;\n\tint higest_errno = errno_highest_nr();\n\tfilter_init();\n\n\t// apply errno list\n\n\tfor (i = 0; i < higest_errno; i++) {\n\t\tif (cfg.seccomp_list_errno[i]) {\n\t\t\tif (syscall_check_list(cfg.seccomp_list_errno[i], filter_add_errno, i)) {\n\t\t\t\tfprintf(stderr, \"Error: cannot load seccomp filter\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t}\n\n\tfilter_end_blacklist();\n\tif (arg_debug)\n\t\tfilter_debug();\n\n\t// save seccomp filter in  /run/firejail/mnt/seccomp\n\t// in order to use it in --join operations\n\twrite_seccomp_file();\n\n\tstruct sock_fprog prog = {\n\t\t.len = sfilter_index,\n\t\t.filter = sfilter,\n\t};\n\n\tif (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog) || prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {\n\t\tfprintf(stderr, \"Warning: seccomp disabled, it requires a Linux kernel version 3.5 or newer.\\n\");\n\t\treturn 1;\n\t}\n\telse if (arg_debug) {\n\t\tprintf(\"seccomp enabled\\n\");\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seccomp_filter_keep",
          "args": [],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "seccomp_filter_keep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/seccomp.c",
          "lines": "736-776",
          "snippet": "int seccomp_filter_keep(void) {\n\tfilter_init();\n\n\t// these 4 syscalls are used by firejail after the seccomp filter is initialized\n\tfilter_add_whitelist(SYS_setuid, 0);\n\tfilter_add_whitelist(SYS_setgid, 0);\n\tfilter_add_whitelist(SYS_setgroups, 0);\n\tfilter_add_whitelist(SYS_dup, 0);\n\t\n\t// apply keep list\n\tif (cfg.seccomp_list_keep) {\n\t\tif (syscall_check_list(cfg.seccomp_list_keep, filter_add_whitelist, 0)) {\n\t\t\tfprintf(stderr, \"Error: cannot load seccomp filter\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\t\n\tfilter_end_whitelist();\n\tif (arg_debug)\n\t\tfilter_debug();\n\n\t// save seccomp filter in  /run/firejail/mnt/seccomp\n\t// in order to use it in --join operations\n\twrite_seccomp_file();\n\n\n\tstruct sock_fprog prog = {\n\t\t.len = sfilter_index,\n\t\t.filter = sfilter,\n\t};\n\n\tif (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog) || prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {\n\t\tfprintf(stderr, \"Warning: seccomp disabled, it requires a Linux kernel version 3.5 or newer.\\n\");\n\t\treturn 1;\n\t}\n\telse if (arg_debug) {\n\t\tprintf(\"seccomp enabled\\n\");\n\t}\n\t\n\treturn 0;\n}",
          "includes": [
            "#include \"seccomp.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"seccomp.h\"\n#include \"firejail.h\"\n\nint seccomp_filter_keep(void) {\n\tfilter_init();\n\n\t// these 4 syscalls are used by firejail after the seccomp filter is initialized\n\tfilter_add_whitelist(SYS_setuid, 0);\n\tfilter_add_whitelist(SYS_setgid, 0);\n\tfilter_add_whitelist(SYS_setgroups, 0);\n\tfilter_add_whitelist(SYS_dup, 0);\n\t\n\t// apply keep list\n\tif (cfg.seccomp_list_keep) {\n\t\tif (syscall_check_list(cfg.seccomp_list_keep, filter_add_whitelist, 0)) {\n\t\t\tfprintf(stderr, \"Error: cannot load seccomp filter\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\t\n\tfilter_end_whitelist();\n\tif (arg_debug)\n\t\tfilter_debug();\n\n\t// save seccomp filter in  /run/firejail/mnt/seccomp\n\t// in order to use it in --join operations\n\twrite_seccomp_file();\n\n\n\tstruct sock_fprog prog = {\n\t\t.len = sfilter_index,\n\t\t.filter = sfilter,\n\t};\n\n\tif (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog) || prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {\n\t\tfprintf(stderr, \"Warning: seccomp disabled, it requires a Linux kernel version 3.5 or newer.\\n\");\n\t\treturn 1;\n\t}\n\telse if (arg_debug) {\n\t\tprintf(\"seccomp enabled\\n\");\n\t}\n\t\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "protocol_filter_save",
          "args": [],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "protocol_filter_save",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/protocol.c",
          "lines": "268-278",
          "snippet": "void protocol_filter_save(void) {\n\t// save protocol filter configuration in PROTOCOL_CFG\n\tfs_build_mnt_dir();\n\n\tFILE *fp = fopen(RUN_PROTOCOL_CFG, \"w\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\tfprintf(fp, \"%s\\n\", cfg.protocol);\n\tSET_PERMS_STREAM(fp, 0, 0, 0600);\n\tfclose(fp);\n}",
          "includes": [
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include \"seccomp.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/socket.h>\n#include <sys/types.h>\n#include \"seccomp.h\"\n#include \"firejail.h\"\n\nvoid protocol_filter_save(void) {\n\t// save protocol filter configuration in PROTOCOL_CFG\n\tfs_build_mnt_dir();\n\n\tFILE *fp = fopen(RUN_PROTOCOL_CFG, \"w\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\tfprintf(fp, \"%s\\n\", cfg.protocol);\n\tSET_PERMS_STREAM(fp, 0, 0, 0600);\n\tfclose(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_rlimits",
          "args": [],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "set_rlimits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/rlimit.c",
          "lines": "24-62",
          "snippet": "void set_rlimits(void) {\n\t// resource limits\n\tstruct rlimit rl;\n\tif (arg_rlimit_nofile) {\n\t\trl.rlim_cur = (rlim_t) cfg.rlimit_nofile;\n\t\trl.rlim_max = (rlim_t) cfg.rlimit_nofile;\n\t\tif (setrlimit(RLIMIT_NOFILE, &rl) == -1)\n\t\t\terrExit(\"setrlimit\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Config rlimit: number of open file descriptors %u\\n\", cfg.rlimit_nofile);\n\t}\n\n\tif (arg_rlimit_nproc) {\n\t\trl.rlim_cur = (rlim_t) cfg.rlimit_nproc;\n\t\trl.rlim_max = (rlim_t) cfg.rlimit_nproc;\n\t\tif (setrlimit(RLIMIT_NPROC, &rl) == -1)\n\t\t\terrExit(\"setrlimit\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Config rlimit: number of processes %u\\n\", cfg.rlimit_nproc);\n\t}\n\t\n\tif (arg_rlimit_fsize) {\n\t\trl.rlim_cur = (rlim_t) cfg.rlimit_fsize;\n\t\trl.rlim_max = (rlim_t) cfg.rlimit_fsize;\n\t\tif (setrlimit(RLIMIT_FSIZE, &rl) == -1)\n\t\t\terrExit(\"setrlimit\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Config rlimit: maximum file size %u\\n\", cfg.rlimit_fsize);\n\t}\n\t\n\tif (arg_rlimit_sigpending) {\n\t\trl.rlim_cur = (rlim_t) cfg.rlimit_sigpending;\n\t\trl.rlim_max = (rlim_t) cfg.rlimit_sigpending;\n\t\tif (setrlimit(RLIMIT_SIGPENDING, &rl) == -1)\n\t\t\terrExit(\"setrlimit\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Config rlimit: maximum number of signals pending %u\\n\", cfg.rlimit_sigpending);\n\t}\n}",
          "includes": [
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/resource.h>\n#include <sys/time.h>\n#include \"firejail.h\"\n\nvoid set_rlimits(void) {\n\t// resource limits\n\tstruct rlimit rl;\n\tif (arg_rlimit_nofile) {\n\t\trl.rlim_cur = (rlim_t) cfg.rlimit_nofile;\n\t\trl.rlim_max = (rlim_t) cfg.rlimit_nofile;\n\t\tif (setrlimit(RLIMIT_NOFILE, &rl) == -1)\n\t\t\terrExit(\"setrlimit\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Config rlimit: number of open file descriptors %u\\n\", cfg.rlimit_nofile);\n\t}\n\n\tif (arg_rlimit_nproc) {\n\t\trl.rlim_cur = (rlim_t) cfg.rlimit_nproc;\n\t\trl.rlim_max = (rlim_t) cfg.rlimit_nproc;\n\t\tif (setrlimit(RLIMIT_NPROC, &rl) == -1)\n\t\t\terrExit(\"setrlimit\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Config rlimit: number of processes %u\\n\", cfg.rlimit_nproc);\n\t}\n\t\n\tif (arg_rlimit_fsize) {\n\t\trl.rlim_cur = (rlim_t) cfg.rlimit_fsize;\n\t\trl.rlim_max = (rlim_t) cfg.rlimit_fsize;\n\t\tif (setrlimit(RLIMIT_FSIZE, &rl) == -1)\n\t\t\terrExit(\"setrlimit\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Config rlimit: maximum file size %u\\n\", cfg.rlimit_fsize);\n\t}\n\t\n\tif (arg_rlimit_sigpending) {\n\t\trl.rlim_cur = (rlim_t) cfg.rlimit_sigpending;\n\t\trl.rlim_max = (rlim_t) cfg.rlimit_sigpending;\n\t\tif (setrlimit(RLIMIT_SIGPENDING, &rl) == -1)\n\t\t\terrExit(\"setrlimit\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Config rlimit: maximum number of signals pending %u\\n\", cfg.rlimit_sigpending);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "x11_xorg",
          "args": [],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "x11_xorg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/x11.c",
          "lines": "645-734",
          "snippet": "void x11_xorg(void) {\n#ifdef HAVE_X11\n\t// destination - create an empty ~/.Xauthotrity file if it doesn't exist already, and use it as a mount point\n\tchar *dest;\n\tif (asprintf(&dest, \"%s/.Xauthority\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\tstruct stat s;\n\tif (stat(dest, &s) == -1) {\n\t\t// create an .Xauthority file\n\t\tFILE *fp = fopen(dest, \"w\");\n\t\tif (!fp)\n\t\t\terrExit(\"fopen\");\n\t\tSET_PERMS_STREAM(fp, getuid(), getgid(), 0600);\n\t\tfclose(fp);\n\t}\n\n\t// check xauth utility is present in the system\n\tif (stat(\"/usr/bin/xauth\", &s) == -1) {\n\t\tfprintf(stderr, \"Error: cannot find /usr/bin/xauth executable\\n\");\n\t\texit(1);\n\t}\n\n\t// create a temporary .Xauthority file\n\tchar tmpfname[] = \"/tmp/.tmpXauth-XXXXXX\";\n\tint fd = mkstemp(tmpfname);\n\tif (fd == -1) {\n\t\tfprintf(stderr, \"Error: cannot create .Xauthority file\\n\");\n\t\texit(1);\n\t}\n\tclose(fd);\n\tif (chown(tmpfname, getuid(), getgid()) == -1)\n\t\terrExit(\"chown\");\n\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// generate the new .Xauthority file using xauth utility\n\t\tif (arg_debug)\n\t\t\tprintf(\"Generating a new .Xauthority file\\n\");\n\t\tdrop_privs(1);\n\n\t\tchar *display = getenv(\"DISPLAY\");\n\t\tif (!display)\n\t\t\tdisplay = \":0.0\";\n\t\t\n\t\tclearenv();\n\t\texeclp(\"/usr/bin/xauth\", \"/usr/bin/xauth\", \"-f\", tmpfname,\n\t\t\t\"generate\", display, \"MIT-MAGIC-COOKIE-1\", \"untrusted\", NULL); \n\t\t\n\t\t_exit(0);\n\t}\n\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n\n\t// check the file was created and set mode and ownership\n\tif (stat(tmpfname, &s) == -1) {\n\t\tfprintf(stderr, \"Error: cannot create the new .Xauthority file\\n\");\n\t\texit(1);\n\t}\n\tif (chown(tmpfname, getuid(), getgid()) == -1)\n\t\terrExit(\"chown\");\n\tif (chmod(tmpfname, 0600) == -1)\n\t\terrExit(\"chmod\");\n\t\n\t// move the temporary file in RUN_XAUTHORITY_SEC_FILE in order to have it deleted\n\t// automatically when the sandbox is closed\n\tif (copy_file(tmpfname, RUN_XAUTHORITY_SEC_FILE, getuid(), getgid(), 0600)) {\n\t\tfprintf(stderr, \"asdfdsfError: cannot create the new .Xauthority file\\n\");\n\t\texit(1);\n\t}\n\tif (chown(RUN_XAUTHORITY_SEC_FILE, getuid(), getgid()) == -1)\n\t\terrExit(\"chown\");\n\tif (chmod(RUN_XAUTHORITY_SEC_FILE, 0600) == -1)\n\t\terrExit(\"chmod\");\n\tunlink(tmpfname);\n\t\n\t// mount\n\tif (mount(RUN_XAUTHORITY_SEC_FILE, dest, \"none\", MS_BIND, \"mode=0600\") == -1) {\n\t\tfprintf(stderr, \"Error: cannot mount the new .Xauthority file\\n\");\n\t\texit(1);\n\t}\n\tif (chown(dest, getuid(), getgid()) == -1)\n\t\terrExit(\"chown\");\n\tif (chmod(dest, 0600) == -1)\n\t\terrExit(\"chmod\");\n\tfree(dest);\n#endif\t\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <sys/mount.h>\n#include <dirent.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid x11_xorg(void) {\n#ifdef HAVE_X11\n\t// destination - create an empty ~/.Xauthotrity file if it doesn't exist already, and use it as a mount point\n\tchar *dest;\n\tif (asprintf(&dest, \"%s/.Xauthority\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\tstruct stat s;\n\tif (stat(dest, &s) == -1) {\n\t\t// create an .Xauthority file\n\t\tFILE *fp = fopen(dest, \"w\");\n\t\tif (!fp)\n\t\t\terrExit(\"fopen\");\n\t\tSET_PERMS_STREAM(fp, getuid(), getgid(), 0600);\n\t\tfclose(fp);\n\t}\n\n\t// check xauth utility is present in the system\n\tif (stat(\"/usr/bin/xauth\", &s) == -1) {\n\t\tfprintf(stderr, \"Error: cannot find /usr/bin/xauth executable\\n\");\n\t\texit(1);\n\t}\n\n\t// create a temporary .Xauthority file\n\tchar tmpfname[] = \"/tmp/.tmpXauth-XXXXXX\";\n\tint fd = mkstemp(tmpfname);\n\tif (fd == -1) {\n\t\tfprintf(stderr, \"Error: cannot create .Xauthority file\\n\");\n\t\texit(1);\n\t}\n\tclose(fd);\n\tif (chown(tmpfname, getuid(), getgid()) == -1)\n\t\terrExit(\"chown\");\n\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// generate the new .Xauthority file using xauth utility\n\t\tif (arg_debug)\n\t\t\tprintf(\"Generating a new .Xauthority file\\n\");\n\t\tdrop_privs(1);\n\n\t\tchar *display = getenv(\"DISPLAY\");\n\t\tif (!display)\n\t\t\tdisplay = \":0.0\";\n\t\t\n\t\tclearenv();\n\t\texeclp(\"/usr/bin/xauth\", \"/usr/bin/xauth\", \"-f\", tmpfname,\n\t\t\t\"generate\", display, \"MIT-MAGIC-COOKIE-1\", \"untrusted\", NULL); \n\t\t\n\t\t_exit(0);\n\t}\n\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n\n\t// check the file was created and set mode and ownership\n\tif (stat(tmpfname, &s) == -1) {\n\t\tfprintf(stderr, \"Error: cannot create the new .Xauthority file\\n\");\n\t\texit(1);\n\t}\n\tif (chown(tmpfname, getuid(), getgid()) == -1)\n\t\terrExit(\"chown\");\n\tif (chmod(tmpfname, 0600) == -1)\n\t\terrExit(\"chmod\");\n\t\n\t// move the temporary file in RUN_XAUTHORITY_SEC_FILE in order to have it deleted\n\t// automatically when the sandbox is closed\n\tif (copy_file(tmpfname, RUN_XAUTHORITY_SEC_FILE, getuid(), getgid(), 0600)) {\n\t\tfprintf(stderr, \"asdfdsfError: cannot create the new .Xauthority file\\n\");\n\t\texit(1);\n\t}\n\tif (chown(RUN_XAUTHORITY_SEC_FILE, getuid(), getgid()) == -1)\n\t\terrExit(\"chown\");\n\tif (chmod(RUN_XAUTHORITY_SEC_FILE, 0600) == -1)\n\t\terrExit(\"chmod\");\n\tunlink(tmpfname);\n\t\n\t// mount\n\tif (mount(RUN_XAUTHORITY_SEC_FILE, dest, \"none\", MS_BIND, \"mode=0600\") == -1) {\n\t\tfprintf(stderr, \"Error: cannot mount the new .Xauthority file\\n\");\n\t\texit(1);\n\t}\n\tif (chown(dest, getuid(), getgid()) == -1)\n\t\terrExit(\"chown\");\n\tif (chmod(dest, 0600) == -1)\n\t\terrExit(\"chmod\");\n\tfree(dest);\n#endif\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_x11",
          "args": [],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "fs_x11",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/x11.c",
          "lines": "123-181",
          "snippet": "void fs_x11(void) {\n#ifdef HAVE_X11\n\tint display = x11_display();\n\tif (display <= 0)\n\t\treturn;\n\n\tchar *x11file;\n\tif (asprintf(&x11file, \"/tmp/.X11-unix/X%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\tstruct stat s;\n\tif (stat(x11file, &s) == -1)\n\t\treturn;\n\n\t// keep a copy of real /tmp/.X11-unix directory in WHITELIST_TMP_DIR\n\tint rv = mkdir(RUN_WHITELIST_X11_DIR, 1777);\n\tif (rv == -1)\n\t\terrExit(\"mkdir\");\n\tif (chown(RUN_WHITELIST_X11_DIR, 0, 0) < 0)\n\t\terrExit(\"chown\");\n\tif (chmod(RUN_WHITELIST_X11_DIR, 1777) < 0)\n\t\terrExit(\"chmod\");\n\n\tif (mount(\"/tmp/.X11-unix\", RUN_WHITELIST_X11_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\n\t// mount tmpfs on /tmp/.X11-unix\n\tif (arg_debug || arg_debug_whitelists)\n\t\tprintf(\"Mounting tmpfs on /tmp/.X11-unix directory\\n\");\n\tif (mount(\"tmpfs\", \"/tmp/.X11-unix\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME | MS_REC,  \"mode=1777,gid=0\") < 0)\n\t\terrExit(\"mounting tmpfs on /tmp\");\n\tfs_logger(\"tmpfs /tmp/.X11-unix\");\n\n\t// create an empty file\n\tFILE *fp = fopen(x11file, \"w\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: cannot create empty file in x11 directory\\n\");\n\t\texit(1);\n\t}\n\t// set file properties\n\tSET_PERMS_STREAM(fp, s.st_uid, s.st_gid, s.st_mode);\n\tfclose(fp);\n\n\t// mount\n\tchar *wx11file;\n\tif (asprintf(&wx11file, \"%s/X%d\", RUN_WHITELIST_X11_DIR, display) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(wx11file, x11file, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\t fs_logger2(\"whitelist\", x11file);\n\n\tfree(x11file);\n\tfree(wx11file);\n\t\n\t// block access to RUN_WHITELIST_X11_DIR\n\t if (mount(RUN_RO_DIR, RUN_WHITELIST_X11_DIR, \"none\", MS_BIND, \"mode=400,gid=0\") == -1)\n\t \terrExit(\"mount\");\n\t fs_logger2(\"blacklist\", RUN_WHITELIST_X11_DIR);\n#endif\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <sys/mount.h>\n#include <dirent.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid fs_x11(void) {\n#ifdef HAVE_X11\n\tint display = x11_display();\n\tif (display <= 0)\n\t\treturn;\n\n\tchar *x11file;\n\tif (asprintf(&x11file, \"/tmp/.X11-unix/X%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\tstruct stat s;\n\tif (stat(x11file, &s) == -1)\n\t\treturn;\n\n\t// keep a copy of real /tmp/.X11-unix directory in WHITELIST_TMP_DIR\n\tint rv = mkdir(RUN_WHITELIST_X11_DIR, 1777);\n\tif (rv == -1)\n\t\terrExit(\"mkdir\");\n\tif (chown(RUN_WHITELIST_X11_DIR, 0, 0) < 0)\n\t\terrExit(\"chown\");\n\tif (chmod(RUN_WHITELIST_X11_DIR, 1777) < 0)\n\t\terrExit(\"chmod\");\n\n\tif (mount(\"/tmp/.X11-unix\", RUN_WHITELIST_X11_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\n\t// mount tmpfs on /tmp/.X11-unix\n\tif (arg_debug || arg_debug_whitelists)\n\t\tprintf(\"Mounting tmpfs on /tmp/.X11-unix directory\\n\");\n\tif (mount(\"tmpfs\", \"/tmp/.X11-unix\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME | MS_REC,  \"mode=1777,gid=0\") < 0)\n\t\terrExit(\"mounting tmpfs on /tmp\");\n\tfs_logger(\"tmpfs /tmp/.X11-unix\");\n\n\t// create an empty file\n\tFILE *fp = fopen(x11file, \"w\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: cannot create empty file in x11 directory\\n\");\n\t\texit(1);\n\t}\n\t// set file properties\n\tSET_PERMS_STREAM(fp, s.st_uid, s.st_gid, s.st_mode);\n\tfclose(fp);\n\n\t// mount\n\tchar *wx11file;\n\tif (asprintf(&wx11file, \"%s/X%d\", RUN_WHITELIST_X11_DIR, display) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(wx11file, x11file, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\t fs_logger2(\"whitelist\", x11file);\n\n\tfree(x11file);\n\tfree(wx11file);\n\t\n\t// block access to RUN_WHITELIST_X11_DIR\n\t if (mount(RUN_RO_DIR, RUN_WHITELIST_X11_DIR, \"none\", MS_BIND, \"mode=400,gid=0\") == -1)\n\t \terrExit(\"mount\");\n\t fs_logger2(\"blacklist\", RUN_WHITELIST_X11_DIR);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: cannot set nice value\\n\""
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nice",
          "args": [
            "cfg.nice"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"chdir\""
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chdir",
          "args": [
            "cfg.homedir"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "cfg.homedir",
            "&s"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"chdir\""
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chdir",
          "args": [
            "\"/\""
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chdir",
          "args": [
            "cfg.cwd"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prctl",
          "args": [
            "PR_SET_PDEATHSIG",
            "SIGKILL",
            "0",
            "0",
            "0"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_delete_cp_command",
          "args": [],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "fs_delete_cp_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
          "lines": "177-179",
          "snippet": "void fs_delete_cp_command(void) {\n\tunlink(RUN_CP_COMMAND);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_delete_cp_command(void) {\n\tunlink(RUN_CP_COMMAND);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"DNS server %d.%d.%d.%d\\n\"",
            "PRINT_IP(cfg.dns3)"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_IP",
          "args": [
            "cfg.dns3"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"DNS server %d.%d.%d.%d\\n\"",
            "PRINT_IP(cfg.dns2)"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_IP",
          "args": [
            "cfg.dns2"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"DNS server %d.%d.%d.%d\\n\"",
            "PRINT_IP(cfg.dns1)"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_IP",
          "args": [
            "cfg.dns1"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Default gateway %d.%d.%d.%d\\n\"",
            "PRINT_IP(cfg.defaultgw)"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_IP",
          "args": [
            "cfg.defaultgw"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Default gateway configuration failed\\n\""
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_ifprint",
          "args": [],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "net_ifprint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/network.c",
          "lines": "32-94",
          "snippet": "void net_ifprint(void) {\n\tuint32_t ip;\n\tuint32_t mask;\n\tstruct ifaddrs *ifaddr, *ifa;\n\n\tif (getifaddrs(&ifaddr) == -1)\n\t\terrExit(\"getifaddrs\");\n\n\tprintf(\"%-17.17s%-19.19s%-17.17s%-17.17s%-6.6s\\n\",\n\t\t\"Interface\", \"MAC\", \"IP\", \"Mask\", \"Status\");\n\t// walk through the linked list\n\tfor (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {\n\t\tif (ifa->ifa_addr == NULL)\n\t\t\tcontinue;\n\n\t\tif (ifa->ifa_addr->sa_family == AF_INET) {\n\t\t\tstruct sockaddr_in *si = (struct sockaddr_in *) ifa->ifa_netmask;\n\t\t\tmask = ntohl(si->sin_addr.s_addr);\n\t\t\tsi = (struct sockaddr_in *) ifa->ifa_addr;\n\t\t\tip = ntohl(si->sin_addr.s_addr);\n\n\t\t\t// interface status\n\t\t\tchar *status;\n\t\t\tif (ifa->ifa_flags & IFF_RUNNING && ifa->ifa_flags & IFF_UP)\n\t\t\t\tstatus = \"UP\";\n\t\t\telse\n\t\t\t\tstatus = \"DOWN\";\n\n\t\t\t// ip address and mask\n\t\t\tchar ipstr[30];\n\t\t\tsprintf(ipstr, \"%d.%d.%d.%d\", PRINT_IP(ip));\n\t\t\tchar maskstr[30];\n\t\t\tsprintf(maskstr, \"%d.%d.%d.%d\", PRINT_IP(mask));\n\t\t\t\n\t\t\t// mac address\n\t\t\tunsigned char mac[6];\n\t\t\tnet_get_mac(ifa->ifa_name, mac);\n\t\t\tchar macstr[30];\n\t\t\tif (strcmp(ifa->ifa_name, \"lo\") == 0)\n\t\t\t\tmacstr[0] = '\\0';\n\t\t\telse\n\t\t\t\tsprintf(macstr, \"%02x:%02x:%02x:%02x:%02x:%02x\", PRINT_MAC(mac));\n\n\t\t\t// print\t\t\t\t\n\t\t\tprintf(\"%-17.17s%-19.19s%-17.17s%-17.17s%-6.6s\\n\",\n\t\t\t\tifa->ifa_name, macstr, ipstr, maskstr, status);\n\n\t\t\t// network scanning\n\t\t\tif (!arg_scan)\t\t\t\t// scanning disabled\n\t\t\t\tcontinue;\n\t\t\tif (strcmp(ifa->ifa_name, \"lo\") == 0)\t// no loopbabck scanning\n\t\t\t\tcontinue;\n\t\t\tif (mask2bits(mask) < 16)\t\t// not scanning large networks\n\t\t\t\tcontinue;\n\t\t\tif (!ip)\t\t\t\t\t// if not configured\n\t\t\t\tcontinue;\n\t\t\t// only if the interface is up and running\n\t\t\tif (ifa->ifa_flags & IFF_RUNNING && ifa->ifa_flags & IFF_UP)\n\t\t\t\tarp_scan(ifa->ifa_name, ip, mask);\n\t\t}\n\t}\n\tfreeifaddrs(ifaddr);\n}",
          "includes": [
            "#include <linux/if_bridge.h>",
            "#include <net/route.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <ifaddrs.h>",
            "#include <netdb.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <arpa/inet.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"firejail.h\"\n\nvoid net_ifprint(void) {\n\tuint32_t ip;\n\tuint32_t mask;\n\tstruct ifaddrs *ifaddr, *ifa;\n\n\tif (getifaddrs(&ifaddr) == -1)\n\t\terrExit(\"getifaddrs\");\n\n\tprintf(\"%-17.17s%-19.19s%-17.17s%-17.17s%-6.6s\\n\",\n\t\t\"Interface\", \"MAC\", \"IP\", \"Mask\", \"Status\");\n\t// walk through the linked list\n\tfor (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {\n\t\tif (ifa->ifa_addr == NULL)\n\t\t\tcontinue;\n\n\t\tif (ifa->ifa_addr->sa_family == AF_INET) {\n\t\t\tstruct sockaddr_in *si = (struct sockaddr_in *) ifa->ifa_netmask;\n\t\t\tmask = ntohl(si->sin_addr.s_addr);\n\t\t\tsi = (struct sockaddr_in *) ifa->ifa_addr;\n\t\t\tip = ntohl(si->sin_addr.s_addr);\n\n\t\t\t// interface status\n\t\t\tchar *status;\n\t\t\tif (ifa->ifa_flags & IFF_RUNNING && ifa->ifa_flags & IFF_UP)\n\t\t\t\tstatus = \"UP\";\n\t\t\telse\n\t\t\t\tstatus = \"DOWN\";\n\n\t\t\t// ip address and mask\n\t\t\tchar ipstr[30];\n\t\t\tsprintf(ipstr, \"%d.%d.%d.%d\", PRINT_IP(ip));\n\t\t\tchar maskstr[30];\n\t\t\tsprintf(maskstr, \"%d.%d.%d.%d\", PRINT_IP(mask));\n\t\t\t\n\t\t\t// mac address\n\t\t\tunsigned char mac[6];\n\t\t\tnet_get_mac(ifa->ifa_name, mac);\n\t\t\tchar macstr[30];\n\t\t\tif (strcmp(ifa->ifa_name, \"lo\") == 0)\n\t\t\t\tmacstr[0] = '\\0';\n\t\t\telse\n\t\t\t\tsprintf(macstr, \"%02x:%02x:%02x:%02x:%02x:%02x\", PRINT_MAC(mac));\n\n\t\t\t// print\t\t\t\t\n\t\t\tprintf(\"%-17.17s%-19.19s%-17.17s%-17.17s%-6.6s\\n\",\n\t\t\t\tifa->ifa_name, macstr, ipstr, maskstr, status);\n\n\t\t\t// network scanning\n\t\t\tif (!arg_scan)\t\t\t\t// scanning disabled\n\t\t\t\tcontinue;\n\t\t\tif (strcmp(ifa->ifa_name, \"lo\") == 0)\t// no loopbabck scanning\n\t\t\t\tcontinue;\n\t\t\tif (mask2bits(mask) < 16)\t\t// not scanning large networks\n\t\t\t\tcontinue;\n\t\t\tif (!ip)\t\t\t\t\t// if not configured\n\t\t\t\tcontinue;\n\t\t\t// only if the interface is up and running\n\t\t\tif (ifa->ifa_flags & IFF_RUNNING && ifa->ifa_flags & IFF_UP)\n\t\t\t\tarp_scan(ifa->ifa_name, ip, mask);\n\t\t}\n\t}\n\tfreeifaddrs(ifaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "any_interface_configured",
          "args": [],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "any_interface_configured",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/firejail.h",
          "lines": "264-269",
          "snippet": "static inline int any_interface_configured(void) {\n\tif (cfg.interface0.configured || cfg.interface1.configured || cfg.interface2.configured || cfg.interface3.configured)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include \"../include/euid_common.h\"",
            "#include \"../include/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/euid_common.h\"\n#include \"../include/common.h\"\n\nstatic inline int any_interface_configured(void) {\n\tif (cfg.interface0.configured || cfg.interface1.configured || cfg.interface2.configured || cfg.interface3.configured)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "any_bridge_configured",
          "args": [],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "any_bridge_configured",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/firejail.h",
          "lines": "257-262",
          "snippet": "static inline int any_bridge_configured(void) {\n\tif (cfg.bridge0.configured || cfg.bridge1.configured || cfg.bridge2.configured || cfg.bridge3.configured)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include \"../include/euid_common.h\"",
            "#include \"../include/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/euid_common.h\"\n#include \"../include/common.h\"\n\nstatic inline int any_bridge_configured(void) {\n\tif (cfg.bridge0.configured || cfg.bridge1.configured || cfg.bridge2.configured || cfg.bridge3.configured)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_logger_change_owner",
          "args": [],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger_change_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_logger.c",
          "lines": "115-118",
          "snippet": "void fs_logger_change_owner(void) {\n\tif (chown(RUN_FSLOGGER_FILE, 0, 0) == -1)\n\t\terrExit(\"chown\");\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid fs_logger_change_owner(void) {\n\tif (chown(RUN_FSLOGGER_FILE, 0, 0) == -1)\n\t\terrExit(\"chown\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_logger_print",
          "args": [],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_logger.c",
          "lines": "91-113",
          "snippet": "void fs_logger_print(void) {\n\tif (!head)\n\t\treturn;\n\t\n\tFILE *fp = fopen(RUN_FSLOGGER_FILE, \"a\");\n\tif (!fp) {\n\t\tperror(\"fopen\");\t\t\n\t\treturn;\n\t}\n\tSET_PERMS_STREAM_NOERR(fp, getuid(), getgid(), 0644);\n\t\n\tFsMsg *ptr = head;\n\twhile (ptr) {\n\t\tfprintf(fp, \"%s\\n\", ptr->msg);\n\t\tFsMsg *next = ptr->next;\n\t\t// remove message\n\t\tfree(ptr->msg);\n\t\tfree(ptr);\n\t\tptr = next;\n\t}\n\thead = NULL;\n\tfclose(fp);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static FsMsg *head = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nstatic FsMsg *head = NULL;\n\nvoid fs_logger_print(void) {\n\tif (!head)\n\t\treturn;\n\t\n\tFILE *fp = fopen(RUN_FSLOGGER_FILE, \"a\");\n\tif (!fp) {\n\t\tperror(\"fopen\");\t\t\n\t\treturn;\n\t}\n\tSET_PERMS_STREAM_NOERR(fp, getuid(), getgid(), 0644);\n\t\n\tFsMsg *ptr = head;\n\twhile (ptr) {\n\t\tfprintf(fp, \"%s\\n\", ptr->msg);\n\t\tFsMsg *next = ptr->next;\n\t\t// remove message\n\t\tfree(ptr->msg);\n\t\tfree(ptr);\n\t\tptr = next;\n\t}\n\thead = NULL;\n\tfclose(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_resolvconf",
          "args": [],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "fs_resolvconf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_hostname.c",
          "lines": "98-136",
          "snippet": "void fs_resolvconf(void) {\n\tif (cfg.dns1 == 0)\n\t\treturn;\n\n\tstruct stat s;\n\tfs_build_mnt_dir();\n\t\n\t// create a new /etc/hostname\n\tif (stat(\"/etc/resolv.conf\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Creating a new /etc/resolv.conf file\\n\");\n\t\tFILE *fp = fopen(RUN_RESOLVCONF_FILE, \"w\");\n\t\tif (!fp) {\n\t\t\tfprintf(stderr, \"Error: cannot create %s\\n\", RUN_RESOLVCONF_FILE);\n\t\t\texit(1);\n\t\t}\n\t\t\n\t\tif (cfg.dns1)\n\t\t\tfprintf(fp, \"nameserver %d.%d.%d.%d\\n\", PRINT_IP(cfg.dns1));\n\t\tif (cfg.dns2)\n\t\t\tfprintf(fp, \"nameserver %d.%d.%d.%d\\n\", PRINT_IP(cfg.dns2));\n\t\tif (cfg.dns3)\n\t\t\tfprintf(fp, \"nameserver %d.%d.%d.%d\\n\", PRINT_IP(cfg.dns3));\n\n\t\t// mode and owner\n\t\tSET_PERMS_STREAM(fp, 0, 0, S_IRUSR | S_IWRITE | S_IRGRP | S_IROTH);\n\n\t\tfclose(fp);\n\t\t\n\t\t// bind-mount the file on top of /etc/hostname\n\t\tif (mount(RUN_RESOLVCONF_FILE, \"/etc/resolv.conf\", NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mount bind /etc/resolv.conf\");\n\t\tfs_logger(\"create /etc/resolv.conf\");\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: cannot set DNS servers, /etc/resolv.conf file is missing\\n\");\n\t\texit(1);\n\t}\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_resolvconf(void) {\n\tif (cfg.dns1 == 0)\n\t\treturn;\n\n\tstruct stat s;\n\tfs_build_mnt_dir();\n\t\n\t// create a new /etc/hostname\n\tif (stat(\"/etc/resolv.conf\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Creating a new /etc/resolv.conf file\\n\");\n\t\tFILE *fp = fopen(RUN_RESOLVCONF_FILE, \"w\");\n\t\tif (!fp) {\n\t\t\tfprintf(stderr, \"Error: cannot create %s\\n\", RUN_RESOLVCONF_FILE);\n\t\t\texit(1);\n\t\t}\n\t\t\n\t\tif (cfg.dns1)\n\t\t\tfprintf(fp, \"nameserver %d.%d.%d.%d\\n\", PRINT_IP(cfg.dns1));\n\t\tif (cfg.dns2)\n\t\t\tfprintf(fp, \"nameserver %d.%d.%d.%d\\n\", PRINT_IP(cfg.dns2));\n\t\tif (cfg.dns3)\n\t\t\tfprintf(fp, \"nameserver %d.%d.%d.%d\\n\", PRINT_IP(cfg.dns3));\n\n\t\t// mode and owner\n\t\tSET_PERMS_STREAM(fp, 0, 0, S_IRUSR | S_IWRITE | S_IRGRP | S_IROTH);\n\n\t\tfclose(fp);\n\t\t\n\t\t// bind-mount the file on top of /etc/hostname\n\t\tif (mount(RUN_RESOLVCONF_FILE, \"/etc/resolv.conf\", NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mount bind /etc/resolv.conf\");\n\t\tfs_logger(\"create /etc/resolv.conf\");\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: cannot set DNS servers, /etc/resolv.conf file is missing\\n\");\n\t\texit(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Network namespace enabled\\n\""
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: cannot configure default route\\n\""
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_add_route",
          "args": [
            "0",
            "0",
            "cfg.defaultgw"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "net_add_route",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/network.c",
          "lines": "398-431",
          "snippet": "int net_add_route(uint32_t ip, uint32_t mask, uint32_t gw) {\n\tint sock;\n\tstruct rtentry route;\n\tstruct sockaddr_in *addr;\n\tint err = 0;\n\n\t// create the socket\n\tif((sock = socket(AF_INET, SOCK_DGRAM, 0)) < 0)\n\t\terrExit(\"socket\");\n\n\tmemset(&route, 0, sizeof(route));\n\n\taddr = (struct sockaddr_in*) &route.rt_gateway;\n\taddr->sin_family = AF_INET;\n\taddr->sin_addr.s_addr = htonl(gw);\n\n\taddr = (struct sockaddr_in*) &route.rt_dst;\n\taddr->sin_family = AF_INET;\n\taddr->sin_addr.s_addr = htonl(ip);\n\n\taddr = (struct sockaddr_in*) &route.rt_genmask;\n\taddr->sin_family = AF_INET;\n\taddr->sin_addr.s_addr = htonl(mask);\n\n\troute.rt_flags = RTF_UP | RTF_GATEWAY;\n\troute.rt_metric = 0;\n\tif ((err = ioctl(sock, SIOCADDRT, &route)) != 0) {\n\t\tclose(sock);\n\t\treturn -1;\n\t}\n\n\tclose(sock);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/if_bridge.h>",
            "#include <net/route.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <ifaddrs.h>",
            "#include <netdb.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <arpa/inet.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"firejail.h\"\n\nint net_add_route(uint32_t ip, uint32_t mask, uint32_t gw) {\n\tint sock;\n\tstruct rtentry route;\n\tstruct sockaddr_in *addr;\n\tint err = 0;\n\n\t// create the socket\n\tif((sock = socket(AF_INET, SOCK_DGRAM, 0)) < 0)\n\t\terrExit(\"socket\");\n\n\tmemset(&route, 0, sizeof(route));\n\n\taddr = (struct sockaddr_in*) &route.rt_gateway;\n\taddr->sin_family = AF_INET;\n\taddr->sin_addr.s_addr = htonl(gw);\n\n\taddr = (struct sockaddr_in*) &route.rt_dst;\n\taddr->sin_family = AF_INET;\n\taddr->sin_addr.s_addr = htonl(ip);\n\n\taddr = (struct sockaddr_in*) &route.rt_genmask;\n\taddr->sin_family = AF_INET;\n\taddr->sin_addr.s_addr = htonl(mask);\n\n\troute.rt_flags = RTF_UP | RTF_GATEWAY;\n\troute.rt_metric = 0;\n\tif ((err = ioctl(sock, SIOCADDRT, &route)) != 0) {\n\t\tclose(sock);\n\t\treturn -1;\n\t}\n\n\tclose(sock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_if_up",
          "args": [
            "cfg.interface3.dev"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "net_if_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/network.c",
          "lines": "188-245",
          "snippet": "void net_if_up(const char *ifname) {\n\tif (strlen(ifname) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error: invalid network device name %s\\n\", ifname);\n\t\texit(1);\n\t}\n\t\n\tint sock = socket(AF_INET,SOCK_DGRAM,0);\n\tif (sock < 0)\n\t\terrExit(\"socket\");\n\n\t// get the existing interface flags\n\tstruct ifreq ifr;\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ);\n\tifr.ifr_addr.sa_family = AF_INET;\n\n\t// read the existing flags\n\tif (ioctl(sock, SIOCGIFFLAGS, &ifr ) < 0) {\n\t\tclose(sock);\n\t\tprintf(\"Error: cannot bring up interface %s\\n\", ifname);\n\t\terrExit(\"ioctl\");\n\t}\n\n\tifr.ifr_flags |= IFF_UP;\n\n\t// set the new flags\n\tif (ioctl( sock, SIOCSIFFLAGS, &ifr ) < 0) {\n\t\tclose(sock);\n\t\tprintf(\"Error: cannot bring up interface %s\\n\", ifname);\n\t\terrExit(\"ioctl\");\n\t}\n\n\t// checking\n\t// read the existing flags\n\tif (ioctl(sock, SIOCGIFFLAGS, &ifr ) < 0) {\n\t\tclose(sock);\n\t\tprintf(\"Error: cannot bring up interface %s\\n\", ifname);\n\t\terrExit(\"ioctl\");\n\t}\n\n\t// wait not more than 500ms for the interface to come up\n\tint cnt = 0;\n\twhile (cnt < 50) {\n\t\tusleep(10000);\t\t\t  // sleep 10ms\n\n\t\t// read the existing flags\n\t\tif (ioctl(sock, SIOCGIFFLAGS, &ifr ) < 0) {\n\t\t\tclose(sock);\n\t\t\tprintf(\"Error: cannot bring up interface %s\\n\", ifname);\n\t\t\terrExit(\"ioctl\");\n\t\t}\n\t\tif (ifr.ifr_flags & IFF_RUNNING)\n\t\t\tbreak;\n\t\tcnt++;\n\t}\n\n\tclose(sock);\n}",
          "includes": [
            "#include <linux/if_bridge.h>",
            "#include <net/route.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <ifaddrs.h>",
            "#include <netdb.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <arpa/inet.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"firejail.h\"\n\nvoid net_if_up(const char *ifname) {\n\tif (strlen(ifname) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error: invalid network device name %s\\n\", ifname);\n\t\texit(1);\n\t}\n\t\n\tint sock = socket(AF_INET,SOCK_DGRAM,0);\n\tif (sock < 0)\n\t\terrExit(\"socket\");\n\n\t// get the existing interface flags\n\tstruct ifreq ifr;\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ);\n\tifr.ifr_addr.sa_family = AF_INET;\n\n\t// read the existing flags\n\tif (ioctl(sock, SIOCGIFFLAGS, &ifr ) < 0) {\n\t\tclose(sock);\n\t\tprintf(\"Error: cannot bring up interface %s\\n\", ifname);\n\t\terrExit(\"ioctl\");\n\t}\n\n\tifr.ifr_flags |= IFF_UP;\n\n\t// set the new flags\n\tif (ioctl( sock, SIOCSIFFLAGS, &ifr ) < 0) {\n\t\tclose(sock);\n\t\tprintf(\"Error: cannot bring up interface %s\\n\", ifname);\n\t\terrExit(\"ioctl\");\n\t}\n\n\t// checking\n\t// read the existing flags\n\tif (ioctl(sock, SIOCGIFFLAGS, &ifr ) < 0) {\n\t\tclose(sock);\n\t\tprintf(\"Error: cannot bring up interface %s\\n\", ifname);\n\t\terrExit(\"ioctl\");\n\t}\n\n\t// wait not more than 500ms for the interface to come up\n\tint cnt = 0;\n\twhile (cnt < 50) {\n\t\tusleep(10000);\t\t\t  // sleep 10ms\n\n\t\t// read the existing flags\n\t\tif (ioctl(sock, SIOCGIFFLAGS, &ifr ) < 0) {\n\t\t\tclose(sock);\n\t\t\tprintf(\"Error: cannot bring up interface %s\\n\", ifname);\n\t\t\terrExit(\"ioctl\");\n\t\t}\n\t\tif (ifr.ifr_flags & IFF_RUNNING)\n\t\t\tbreak;\n\t\tcnt++;\n\t}\n\n\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_if_ip",
          "args": [
            "cfg.interface3.dev",
            "cfg.interface3.ip",
            "cfg.interface3.mask",
            "cfg.interface3.mtu"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "net_if_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/network.c",
          "lines": "352-394",
          "snippet": "void net_if_ip(const char *ifname, uint32_t ip, uint32_t mask, int mtu) {\n\tif (strlen(ifname) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error: invalid network device name %s\\n\", ifname);\n\t\texit(1);\n\t}\n\tif (arg_debug)\n\t\tprintf(\"configure interface %s\\n\", ifname);\n\n\tint sock = socket(AF_INET,SOCK_DGRAM,0);\n\tif (sock < 0)\n\t\terrExit(\"socket\");\n\n\tstruct ifreq ifr;\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ);\n\tifr.ifr_addr.sa_family = AF_INET;\n\n\t((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr.s_addr = htonl(ip);\n\tif (ioctl( sock, SIOCSIFADDR, &ifr ) < 0) {\n\t\tclose(sock);\n\t\terrExit(\"ioctl\");\n\t}\n\n\tif (ip != 0) {\n\t\t((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr.s_addr =  htonl(mask);\n\t\tif (ioctl( sock, SIOCSIFNETMASK, &ifr ) < 0) {\n\t\t\tclose(sock);\n\t\t\terrExit(\"ioctl\");\n\t\t}\n\t}\n\t\n\t// configure mtu\n\tif (mtu > 0) {\n\t\tifr.ifr_mtu = mtu;\n\t\tif (ioctl( sock, SIOCSIFMTU, &ifr ) < 0) {\n\t\t\tclose(sock);\n\t\t\terrExit(\"ioctl\");\n\t\t}\n\t}\n\n\tclose(sock);\n\tusleep(10000);\t\t\t\t  // sleep 10ms\n}",
          "includes": [
            "#include <linux/if_bridge.h>",
            "#include <net/route.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <ifaddrs.h>",
            "#include <netdb.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <arpa/inet.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"firejail.h\"\n\nvoid net_if_ip(const char *ifname, uint32_t ip, uint32_t mask, int mtu) {\n\tif (strlen(ifname) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error: invalid network device name %s\\n\", ifname);\n\t\texit(1);\n\t}\n\tif (arg_debug)\n\t\tprintf(\"configure interface %s\\n\", ifname);\n\n\tint sock = socket(AF_INET,SOCK_DGRAM,0);\n\tif (sock < 0)\n\t\terrExit(\"socket\");\n\n\tstruct ifreq ifr;\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ);\n\tifr.ifr_addr.sa_family = AF_INET;\n\n\t((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr.s_addr = htonl(ip);\n\tif (ioctl( sock, SIOCSIFADDR, &ifr ) < 0) {\n\t\tclose(sock);\n\t\terrExit(\"ioctl\");\n\t}\n\n\tif (ip != 0) {\n\t\t((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr.s_addr =  htonl(mask);\n\t\tif (ioctl( sock, SIOCSIFNETMASK, &ifr ) < 0) {\n\t\t\tclose(sock);\n\t\t\terrExit(\"ioctl\");\n\t\t}\n\t}\n\t\n\t// configure mtu\n\tif (mtu > 0) {\n\t\tifr.ifr_mtu = mtu;\n\t\tif (ioctl( sock, SIOCSIFMTU, &ifr ) < 0) {\n\t\t\tclose(sock);\n\t\t\terrExit(\"ioctl\");\n\t\t}\n\t}\n\n\tclose(sock);\n\tusleep(10000);\t\t\t\t  // sleep 10ms\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Configuring %d.%d.%d.%d address on interface %s\\n\"",
            "PRINT_IP(cfg.interface3.ip)",
            "cfg.interface3.dev"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_IP",
          "args": [
            "cfg.interface3.ip"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Configuring %d.%d.%d.%d address on interface %s\\n\"",
            "PRINT_IP(cfg.interface2.ip)",
            "cfg.interface2.dev"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_IP",
          "args": [
            "cfg.interface2.ip"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Configuring %d.%d.%d.%d address on interface %s\\n\"",
            "PRINT_IP(cfg.interface1.ip)",
            "cfg.interface1.dev"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_IP",
          "args": [
            "cfg.interface1.ip"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Configuring %d.%d.%d.%d address on interface %s\\n\"",
            "PRINT_IP(cfg.interface0.ip)",
            "cfg.interface0.dev"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_IP",
          "args": [
            "cfg.interface0.ip"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sandbox_if_up",
          "args": [
            "&cfg.bridge3"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "sandbox_if_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/sandbox.c",
          "lines": "121-169",
          "snippet": "static void sandbox_if_up(Bridge *br) {\n\tassert(br);\n\tif (!br->configured)\n\t\treturn;\n\t\t\n\tchar *dev = br->devsandbox;\n\tnet_if_up(dev);\n\n\tif (br->arg_ip_none == 1);\t// do nothing\n\telse if (br->arg_ip_none == 0 && br->macvlan == 0) {\n\t\tif (br->ipsandbox == br->ip) {\n\t\t\tfprintf(stderr, \"Error: %d.%d.%d.%d is interface %s address.\\n\", PRINT_IP(br->ipsandbox), br->dev);\n\t\t\texit(1);\n\t\t}\n\t\t\n\t\t// just assign the address\n\t\tassert(br->ipsandbox);\n\t\tif (arg_debug)\n\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(br->ipsandbox), dev);\n\t\tnet_if_ip(dev, br->ipsandbox, br->mask, br->mtu);\n\t\tnet_if_up(dev);\n\t}\n\telse if (br->arg_ip_none == 0 && br->macvlan == 1) {\n\t\t// reassign the macvlan address\n\t\tif (br->ipsandbox == 0)\n\t\t\t// ip address assigned by arp-scan for a macvlan device\n\t\t\tbr->ipsandbox = arp_assign(dev, br); //br->ip, br->mask);\n\t\telse {\n\t\t\tif (br->ipsandbox == br->ip) {\n\t\t\t\tfprintf(stderr, \"Error: %d.%d.%d.%d is interface %s address.\\n\", PRINT_IP(br->ipsandbox), br->dev);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t\n\t\t\tuint32_t rv = arp_check(dev, br->ipsandbox, br->ip);\n\t\t\tif (rv) {\n\t\t\t\tfprintf(stderr, \"Error: the address %d.%d.%d.%d is already in use.\\n\", PRINT_IP(br->ipsandbox));\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\t\t\n\t\tif (arg_debug)\n\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(br->ipsandbox), dev);\n\t\tnet_if_ip(dev, br->ipsandbox, br->mask, br->mtu);\n\t\tnet_if_up(dev);\n\t}\n\t\n\tif (br->ip6sandbox)\n\t\t net_if_ip6(dev, br->ip6sandbox);\n}",
          "includes": [
            "#include <sys/apparmor.h>",
            "#include <sys/prctl.h>",
            "#include <sched.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/prctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/apparmor.h>\n#include <sys/prctl.h>\n#include <sched.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/prctl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void sandbox_if_up(Bridge *br) {\n\tassert(br);\n\tif (!br->configured)\n\t\treturn;\n\t\t\n\tchar *dev = br->devsandbox;\n\tnet_if_up(dev);\n\n\tif (br->arg_ip_none == 1);\t// do nothing\n\telse if (br->arg_ip_none == 0 && br->macvlan == 0) {\n\t\tif (br->ipsandbox == br->ip) {\n\t\t\tfprintf(stderr, \"Error: %d.%d.%d.%d is interface %s address.\\n\", PRINT_IP(br->ipsandbox), br->dev);\n\t\t\texit(1);\n\t\t}\n\t\t\n\t\t// just assign the address\n\t\tassert(br->ipsandbox);\n\t\tif (arg_debug)\n\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(br->ipsandbox), dev);\n\t\tnet_if_ip(dev, br->ipsandbox, br->mask, br->mtu);\n\t\tnet_if_up(dev);\n\t}\n\telse if (br->arg_ip_none == 0 && br->macvlan == 1) {\n\t\t// reassign the macvlan address\n\t\tif (br->ipsandbox == 0)\n\t\t\t// ip address assigned by arp-scan for a macvlan device\n\t\t\tbr->ipsandbox = arp_assign(dev, br); //br->ip, br->mask);\n\t\telse {\n\t\t\tif (br->ipsandbox == br->ip) {\n\t\t\t\tfprintf(stderr, \"Error: %d.%d.%d.%d is interface %s address.\\n\", PRINT_IP(br->ipsandbox), br->dev);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t\n\t\t\tuint32_t rv = arp_check(dev, br->ipsandbox, br->ip);\n\t\t\tif (rv) {\n\t\t\t\tfprintf(stderr, \"Error: the address %d.%d.%d.%d is already in use.\\n\", PRINT_IP(br->ipsandbox));\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\t\t\n\t\tif (arg_debug)\n\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(br->ipsandbox), dev);\n\t\tnet_if_ip(dev, br->ipsandbox, br->mask, br->mtu);\n\t\tnet_if_up(dev);\n\t}\n\t\n\tif (br->ip6sandbox)\n\t\t net_if_ip6(dev, br->ip6sandbox);\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_config_mac",
          "args": [
            "cfg.bridge3.devsandbox",
            "cfg.bridge3.macsandbox"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "net_config_mac",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/network.c",
          "lines": "512-528",
          "snippet": "int net_config_mac(const char *ifname, const unsigned char mac[6]) {\n\tstruct ifreq ifr;\n\tint sock;\n\n\tif ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0)\n              \terrExit(\"socket\");\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ);\n\tifr.ifr_hwaddr.sa_family = ARPHRD_ETHER;\n\tmemcpy(ifr.ifr_hwaddr.sa_data, mac, 6);\n\t\n\tif (ioctl(sock, SIOCSIFHWADDR, &ifr) == -1)\n\t\terrExit(\"ioctl\");\n\tclose(sock);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/if_bridge.h>",
            "#include <net/route.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <ifaddrs.h>",
            "#include <netdb.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <arpa/inet.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"firejail.h\"\n\nint net_config_mac(const char *ifname, const unsigned char mac[6]) {\n\tstruct ifreq ifr;\n\tint sock;\n\n\tif ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0)\n              \terrExit(\"socket\");\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ);\n\tifr.ifr_hwaddr.sa_family = ARPHRD_ETHER;\n\tmemcpy(ifr.ifr_hwaddr.sa_data, mac, 6);\n\t\n\tif (ioctl(sock, SIOCSIFHWADDR, &ifr) == -1)\n\t\terrExit(\"ioctl\");\n\tclose(sock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mac_not_zero",
          "args": [
            "cfg.bridge3.macsandbox"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mac_not_zero",
          "args": [
            "cfg.bridge2.macsandbox"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mac_not_zero",
          "args": [
            "cfg.bridge1.macsandbox"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mac_not_zero",
          "args": [
            "cfg.bridge0.macsandbox"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Network namespace enabled, only loopback interface available\\n\""
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_dev_disable_3d",
          "args": [],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "fs_dev_disable_3d",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_dev.c",
          "lines": "313-320",
          "snippet": "void fs_dev_disable_3d(void) {\n\tint i = 0;\n\twhile (dev[i].dev_fname != NULL) {\n\t\tif (dev[i].hw3d)\n\t\t\tdisable_file_or_dir(dev[i].dev_fname);\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_dev_disable_3d(void) {\n\tint i = 0;\n\twhile (dev[i].dev_fname != NULL) {\n\t\tif (dev[i].hw3d)\n\t\t\tdisable_file_or_dir(dev[i].dev_fname);\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pulseaudio_init",
          "args": [],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "pulseaudio_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/pulseaudio.c",
          "lines": "100-207",
          "snippet": "void pulseaudio_init(void) {\n\tstruct stat s;\n\t\n\t// do we have pulseaudio in the system?\n\tif (stat(\"/etc/pulse/client.conf\", &s) == -1)\n\t\treturn;\n\t \n \t// create the new user pulseaudio directory\n\t fs_build_mnt_dir();\n\tint rv = mkdir(RUN_PULSE_DIR, 0700);\n\t(void) rv; // in --chroot mode the directory can already be there\n\tif (chown(RUN_PULSE_DIR, getuid(), getgid()) < 0)\n\t\terrExit(\"chown\");\n\tif (chmod(RUN_PULSE_DIR, 0700) < 0)\n\t\terrExit(\"chmod\");\n\n\t// create the new client.conf file\n\tchar *pulsecfg = NULL;\n\tif (asprintf(&pulsecfg, \"%s/client.conf\", RUN_PULSE_DIR) == -1)\n\t\terrExit(\"asprintf\");\n\tif (copy_file(\"/etc/pulse/client.conf\", pulsecfg, -1, -1, 0644))\n\t\terrExit(\"copy_file\");\n\tFILE *fp = fopen(pulsecfg, \"a+\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\tfprintf(fp, \"%s\", \"\\nenable-shm = no\\n\");\n\tSET_PERMS_STREAM(fp, getuid(), getgid(), 0644);\n\tfclose(fp);\n\n\n\t// create ~/.config/pulse directory if not present\n\tchar *dir1;\n\tif (asprintf(&dir1, \"%s/.config\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (stat(dir1, &s) == -1) {\n\t\tpid_t child = fork();\n\t\tif (child < 0)\n\t\t\terrExit(\"fork\");\n\t\tif (child == 0) {\n\t\t\t// drop privileges\n\t\t\tdrop_privs(0);\n\t\n\t\t\tint rv = mkdir(dir1, 0755);\n\t\t\tif (rv == 0) {\n\t\t\t\tif (set_perms(dir1, getuid(), getgid(), 0755))\n\t\t\t\t\t{;} // do nothing\n\t\t\t}\n\t\t\t_exit(0);\n\t\t}\n\t\t// wait for the child to finish\n\t\twaitpid(child, NULL, 0);\n\t}\n\telse {\n\t\t// make sure the directory is owned by the user\n\t\tif (s.st_uid != getuid()) {\n\t\t\tfprintf(stderr, \"Error: user .config directory is not owned by the current user\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\tfree(dir1);\n\t\n\tif (asprintf(&dir1, \"%s/.config/pulse\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (stat(dir1, &s) == -1) {\n\t\tpid_t child = fork();\n\t\tif (child < 0)\n\t\t\terrExit(\"fork\");\n\t\tif (child == 0) {\n\t\t\t// drop privileges\n\t\t\tdrop_privs(0);\n\t\n\t\t\tint rv = mkdir(dir1, 0700);\n\t\t\tif (rv == 0) {\n\t\t\t\tif (set_perms(dir1, getuid(), getgid(), 0700))\n\t\t\t\t\t{;} // do nothing\n\t\t\t}\n\t\t\t_exit(0);\n\t\t}\n\t\t// wait for the child to finish\n\t\twaitpid(child, NULL, 0);\n\t}\n\telse {\n\t\t// make sure the directory is owned by the user\n\t\tif (s.st_uid != getuid()) {\n\t\t\tfprintf(stderr, \"Error: user .config/pulse directory is not owned by the current user\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\tfree(dir1);\n\t\n\t// if we have ~/.config/pulse mount the new directory, else set environment variable\n\tchar *homeusercfg;\n\tif (asprintf(&homeusercfg, \"%s/.config/pulse\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (stat(homeusercfg, &s) == 0) {\n\t\tif (mount(RUN_PULSE_DIR, homeusercfg, \"none\", MS_BIND, NULL) < 0)\n\t\t\terrExit(\"mount pulseaudio\");\n\t\tfs_logger2(\"tmpfs\", homeusercfg);\n\t}\n\telse {\n\t\t// set environment\n\t\tif (setenv(\"PULSE_CLIENTCONFIG\", pulsecfg, 1) < 0)\n\t\t\terrExit(\"setenv\");\n\t}\n\t\t\n\tfree(pulsecfg);\n\tfree(homeusercfg);\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <dirent.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <dirent.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid pulseaudio_init(void) {\n\tstruct stat s;\n\t\n\t// do we have pulseaudio in the system?\n\tif (stat(\"/etc/pulse/client.conf\", &s) == -1)\n\t\treturn;\n\t \n \t// create the new user pulseaudio directory\n\t fs_build_mnt_dir();\n\tint rv = mkdir(RUN_PULSE_DIR, 0700);\n\t(void) rv; // in --chroot mode the directory can already be there\n\tif (chown(RUN_PULSE_DIR, getuid(), getgid()) < 0)\n\t\terrExit(\"chown\");\n\tif (chmod(RUN_PULSE_DIR, 0700) < 0)\n\t\terrExit(\"chmod\");\n\n\t// create the new client.conf file\n\tchar *pulsecfg = NULL;\n\tif (asprintf(&pulsecfg, \"%s/client.conf\", RUN_PULSE_DIR) == -1)\n\t\terrExit(\"asprintf\");\n\tif (copy_file(\"/etc/pulse/client.conf\", pulsecfg, -1, -1, 0644))\n\t\terrExit(\"copy_file\");\n\tFILE *fp = fopen(pulsecfg, \"a+\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\tfprintf(fp, \"%s\", \"\\nenable-shm = no\\n\");\n\tSET_PERMS_STREAM(fp, getuid(), getgid(), 0644);\n\tfclose(fp);\n\n\n\t// create ~/.config/pulse directory if not present\n\tchar *dir1;\n\tif (asprintf(&dir1, \"%s/.config\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (stat(dir1, &s) == -1) {\n\t\tpid_t child = fork();\n\t\tif (child < 0)\n\t\t\terrExit(\"fork\");\n\t\tif (child == 0) {\n\t\t\t// drop privileges\n\t\t\tdrop_privs(0);\n\t\n\t\t\tint rv = mkdir(dir1, 0755);\n\t\t\tif (rv == 0) {\n\t\t\t\tif (set_perms(dir1, getuid(), getgid(), 0755))\n\t\t\t\t\t{;} // do nothing\n\t\t\t}\n\t\t\t_exit(0);\n\t\t}\n\t\t// wait for the child to finish\n\t\twaitpid(child, NULL, 0);\n\t}\n\telse {\n\t\t// make sure the directory is owned by the user\n\t\tif (s.st_uid != getuid()) {\n\t\t\tfprintf(stderr, \"Error: user .config directory is not owned by the current user\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\tfree(dir1);\n\t\n\tif (asprintf(&dir1, \"%s/.config/pulse\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (stat(dir1, &s) == -1) {\n\t\tpid_t child = fork();\n\t\tif (child < 0)\n\t\t\terrExit(\"fork\");\n\t\tif (child == 0) {\n\t\t\t// drop privileges\n\t\t\tdrop_privs(0);\n\t\n\t\t\tint rv = mkdir(dir1, 0700);\n\t\t\tif (rv == 0) {\n\t\t\t\tif (set_perms(dir1, getuid(), getgid(), 0700))\n\t\t\t\t\t{;} // do nothing\n\t\t\t}\n\t\t\t_exit(0);\n\t\t}\n\t\t// wait for the child to finish\n\t\twaitpid(child, NULL, 0);\n\t}\n\telse {\n\t\t// make sure the directory is owned by the user\n\t\tif (s.st_uid != getuid()) {\n\t\t\tfprintf(stderr, \"Error: user .config/pulse directory is not owned by the current user\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\tfree(dir1);\n\t\n\t// if we have ~/.config/pulse mount the new directory, else set environment variable\n\tchar *homeusercfg;\n\tif (asprintf(&homeusercfg, \"%s/.config/pulse\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (stat(homeusercfg, &s) == 0) {\n\t\tif (mount(RUN_PULSE_DIR, homeusercfg, \"none\", MS_BIND, NULL) < 0)\n\t\t\terrExit(\"mount pulseaudio\");\n\t\tfs_logger2(\"tmpfs\", homeusercfg);\n\t}\n\telse {\n\t\t// set environment\n\t\tif (setenv(\"PULSE_CLIENTCONFIG\", pulsecfg, 1) < 0)\n\t\t\terrExit(\"setenv\");\n\t}\n\t\t\n\tfree(pulsecfg);\n\tfree(homeusercfg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_dev_disable_sound",
          "args": [],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "fs_dev_disable_sound",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_dev.c",
          "lines": "304-311",
          "snippet": "void fs_dev_disable_sound(void) {\n\tint i = 0;\n\twhile (dev[i].dev_fname != NULL) {\n\t\tif (dev[i].sound)\n\t\t\tdisable_file_or_dir(dev[i].dev_fname);\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_dev_disable_sound(void) {\n\tint i = 0;\n\twhile (dev[i].dev_fname != NULL) {\n\t\tif (dev[i].sound)\n\t\t\tdisable_file_or_dir(dev[i].dev_fname);\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pulseaudio_disable",
          "args": [],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "pulseaudio_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/pulseaudio.c",
          "lines": "56-96",
          "snippet": "void pulseaudio_disable(void) {\n\tif (arg_debug)\n\t\tprintf(\"disable pulseaudio\\n\");\n\t// blacklist user config directory\n\tdisable_file(cfg.homedir, \".config/pulse\");\n\n\n\t// blacklist pulseaudio socket in XDG_RUNTIME_DIR\n\tchar *name = getenv(\"XDG_RUNTIME_DIR\");\n\tif (name)\n\t\tdisable_file(name, \"pulse/native\");\n\n\t// try the default location anyway\n\tchar *path;\n\tif (asprintf(&path, \"/run/user/%d\", getuid()) == -1)\n\t\terrExit(\"asprintf\");\n\tdisable_file(path, \"pulse/native\");\n\tfree(path);\n\t\t\n\n\n\t// blacklist any pulse* file in /tmp directory\n\tDIR *dir;\n\tif (!(dir = opendir(\"/tmp\"))) {\n\t\t// sleep 2 seconds and try again\n\t\tsleep(2);\n\t\tif (!(dir = opendir(\"/tmp\"))) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tstruct dirent *entry;\n\twhile ((entry = readdir(dir))) {\n\t\tif (strncmp(entry->d_name, \"pulse-\", 6) == 0) {\n\t\t\tdisable_file(\"/tmp\", entry->d_name);\n\t\t}\n\t}\n\n\tclosedir(dir);\n\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <dirent.h>",
            "#include <sys/mount.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <dirent.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid pulseaudio_disable(void) {\n\tif (arg_debug)\n\t\tprintf(\"disable pulseaudio\\n\");\n\t// blacklist user config directory\n\tdisable_file(cfg.homedir, \".config/pulse\");\n\n\n\t// blacklist pulseaudio socket in XDG_RUNTIME_DIR\n\tchar *name = getenv(\"XDG_RUNTIME_DIR\");\n\tif (name)\n\t\tdisable_file(name, \"pulse/native\");\n\n\t// try the default location anyway\n\tchar *path;\n\tif (asprintf(&path, \"/run/user/%d\", getuid()) == -1)\n\t\terrExit(\"asprintf\");\n\tdisable_file(path, \"pulse/native\");\n\tfree(path);\n\t\t\n\n\n\t// blacklist any pulse* file in /tmp directory\n\tDIR *dir;\n\tif (!(dir = opendir(\"/tmp\"))) {\n\t\t// sleep 2 seconds and try again\n\t\tsleep(2);\n\t\tif (!(dir = opendir(\"/tmp\"))) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tstruct dirent *entry;\n\twhile ((entry = readdir(dir))) {\n\t\tif (strncmp(entry->d_name, \"pulse-\", 6) == 0) {\n\t\t\tdisable_file(\"/tmp\", entry->d_name);\n\t\t}\n\t}\n\n\tclosedir(dir);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_trace",
          "args": [],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "fs_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_trace.c",
          "lines": "46-78",
          "snippet": "void fs_trace(void) {\n\t// create /run/firejail/mnt directory\n\tfs_build_mnt_dir();\n\t\n\t// create the new ld.so.preload file and mount-bind it\n\tif (arg_debug)\n\t\tprintf(\"Create the new ld.so.preload file\\n\");\n\n\tFILE *fp = fopen(RUN_LDPRELOAD_FILE, \"w\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\tif (arg_trace) {\n\t\tfprintf(fp, \"%s/firejail/libtrace.so\\n\", LIBDIR);\n\t}\n\telse if (arg_tracelog) {\n\t\tfprintf(fp, \"%s/firejail/libtracelog.so\\n\", LIBDIR);\n\t\tif (!arg_quiet)\n\t\t\tprintf(\"Blacklist violations are logged to syslog\\n\");\n\t}\t\n\n\tif (mask_x11_abstract_socket)\n\t\tfprintf(fp, \"%s/firejail/libconnect.so\\n\", LIBDIR);\n\n\tSET_PERMS_STREAM(fp, 0, 0, S_IRUSR | S_IWRITE | S_IRGRP | S_IROTH);\n\tfclose(fp);\n\t\n\t// mount the new preload file\n\tif (arg_debug)\n\t\tprintf(\"Mount the new ld.so.preload file\\n\");\n\tif (mount(RUN_LDPRELOAD_FILE, \"/etc/ld.so.preload\", NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind ld.so.preload\");\n\tfs_logger(\"create /etc/ld.so.preload\");\n}",
          "includes": [
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pwd.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_trace(void) {\n\t// create /run/firejail/mnt directory\n\tfs_build_mnt_dir();\n\t\n\t// create the new ld.so.preload file and mount-bind it\n\tif (arg_debug)\n\t\tprintf(\"Create the new ld.so.preload file\\n\");\n\n\tFILE *fp = fopen(RUN_LDPRELOAD_FILE, \"w\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\tif (arg_trace) {\n\t\tfprintf(fp, \"%s/firejail/libtrace.so\\n\", LIBDIR);\n\t}\n\telse if (arg_tracelog) {\n\t\tfprintf(fp, \"%s/firejail/libtracelog.so\\n\", LIBDIR);\n\t\tif (!arg_quiet)\n\t\t\tprintf(\"Blacklist violations are logged to syslog\\n\");\n\t}\t\n\n\tif (mask_x11_abstract_socket)\n\t\tfprintf(fp, \"%s/firejail/libconnect.so\\n\", LIBDIR);\n\n\tSET_PERMS_STREAM(fp, 0, 0, S_IRUSR | S_IWRITE | S_IRGRP | S_IROTH);\n\tfclose(fp);\n\t\n\t// mount the new preload file\n\tif (arg_debug)\n\t\tprintf(\"Mount the new ld.so.preload file\\n\");\n\tif (mount(RUN_LDPRELOAD_FILE, \"/etc/ld.so.preload\", NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind ld.so.preload\");\n\tfs_logger(\"create /etc/ld.so.preload\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_blacklist",
          "args": [],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "fs_blacklist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
          "lines": "373-551",
          "snippet": "void fs_blacklist(void) {\n\tchar *homedir = cfg.homedir;\n\tassert(homedir);\n\tProfileEntry *entry = cfg.profile;\n\tif (!entry)\n\t\treturn;\n\t\t\n\tsize_t noblacklist_c = 0;\n\tsize_t noblacklist_m = 32;\n\tchar **noblacklist = calloc(noblacklist_m, sizeof(*noblacklist));\n\n\tif (noblacklist == NULL)\n\t\terrExit(\"failed allocating memory for noblacklist entries\");\n\n\twhile (entry) {\n\t\tOPERATION op = OPERATION_MAX;\n\t\tchar *ptr;\n\n\t\t// whitelist commands handled by fs_whitelist()\n\t\tif (strncmp(entry->data, \"whitelist \", 10) == 0 || *entry->data == '\\0') {\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// process bind command\n\t\tif (strncmp(entry->data, \"bind \", 5) == 0)  {\n\t\t\tchar *dname1 = entry->data + 5;\n\t\t\tchar *dname2 = split_comma(dname1);\n\t\t\tif (dname2 == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: second directory missing in bind command\\n\");\n\t\t\t\tentry = entry->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstruct stat s;\n\t\t\tif (stat(dname1, &s) == -1) {\n\t\t\t\tfprintf(stderr, \"Error: cannot find %s for bind command\\n\", dname1);\n\t\t\t\tentry = entry->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (stat(dname2, &s) == -1) {\n\t\t\t\tfprintf(stderr, \"Error: cannot find %s for bind command\\n\", dname2);\n\t\t\t\tentry = entry->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t// mount --bind olddir newdir\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Mount-bind %s on top of %s\\n\", dname1, dname2);\n\t\t\t// preserve dname2 mode and ownership\n\t\t\tif (mount(dname1, dname2, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\t\t\t/* coverity[toctou] */\n\t\t\tif (chown(dname2, s.st_uid, s.st_gid) == -1)\n\t\t\t\terrExit(\"mount-bind chown\");\n\t\t\t/* coverity[toctou] */\n\t\t\tif (chmod(dname2, s.st_mode) == -1)\n\t\t\t\terrExit(\"mount-bind chmod\");\n\t\t\t\t\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Process noblacklist command\n\t\tif (strncmp(entry->data, \"noblacklist \", 12) == 0) {\n\t\t\tchar **paths = build_paths();\n\n\t\t\tchar *enames[sizeof(paths)+1] = {0};\n\t\t\tint i = 0;\n\n\t\t\tif (strncmp(entry->data + 12, \"${PATH}\", 7) == 0) {\n\t\t\t\t// expand ${PATH} macro\n\t\t\t\twhile (paths[i] != NULL) {\n\t\t\t\t\tif (asprintf(&enames[i], \"%s%s\", paths[i], entry->data + 19) == -1)\n\t\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// expand ${HOME} macro if found or pass as is\n\t\t\t\tenames[0] = expand_home(entry->data + 12, homedir);\n\t\t\t\tenames[1] = NULL;\n\t\t\t}\n\n\t\t\ti = 0;\n\t\t\twhile (enames[i] != NULL) {\n\t\t\t\tif (noblacklist_c >= noblacklist_m) {\n\t\t\t\t\tnoblacklist_m *= 2;\n\t\t\t\t\tnoblacklist = realloc(noblacklist, sizeof(*noblacklist) * noblacklist_m);\n\t\t\t\t\tif (noblacklist == NULL)\n\t\t\t\t\t\terrExit(\"failed increasing memory for noblacklist entries\");\n\t\t\t\t}\n\t\t\t\tnoblacklist[noblacklist_c++] = enames[i];\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\twhile (enames[i] != NULL) {\n\t\t\t\tfree(enames[i]);\n\t\t\t}\n\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// process blacklist command\n\t\tif (strncmp(entry->data, \"blacklist \", 10) == 0)  {\n\t\t\tptr = entry->data + 10;\n\t\t\top = BLACKLIST_FILE;\n\t\t}\n\t\telse if (strncmp(entry->data, \"blacklist-nolog \", 16) == 0)  {\n\t\t\tptr = entry->data + 16;\n\t\t\top = BLACKLIST_NOLOG;\n\t\t}\n\t\telse if (strncmp(entry->data, \"read-only \", 10) == 0) {\n\t\t\tptr = entry->data + 10;\n\t\t\top = MOUNT_READONLY;\n\t\t}\t\t\t\n\t\telse if (strncmp(entry->data, \"read-write \", 11) == 0) {\n\t\t\tptr = entry->data + 11;\n\t\t\top = MOUNT_RDWR;\n\t\t}\t\t\t\n\t\telse if (strncmp(entry->data, \"noexec \", 7) == 0) {\n\t\t\tptr = entry->data + 7;\n\t\t\top = MOUNT_NOEXEC;\n\t\t}\t\t\t\n\t\telse if (strncmp(entry->data, \"tmpfs \", 6) == 0) {\n\t\t\tptr = entry->data + 6;\n\t\t\top = MOUNT_TMPFS;\n\t\t}\t\t\t\n\t\telse if (strncmp(entry->data, \"mkdir \", 6) == 0) {\n\t\t\tEUID_USER();\n\t\t\tfs_mkdir(entry->data + 6);\n\t\t\tEUID_ROOT();\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\t\t\t\n\t\telse if (strncmp(entry->data, \"mkfile \", 7) == 0) {\n\t\t\tEUID_USER();\n\t\t\tfs_mkfile(entry->data + 7);\n\t\t\tEUID_ROOT();\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\t\t\t\n\t\telse {\n\t\t\tfprintf(stderr, \"Error: invalid profile line %s\\n\", entry->data);\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// replace home macro in blacklist array\n\t\tchar *new_name = expand_home(ptr, homedir);\n\t\tptr = new_name;\n\n\t\t// expand path macro - look for the file in /usr/local/bin,  /usr/local/sbin, /bin, /usr/bin, /sbin and  /usr/sbin directories\n\t\tif (ptr) {\n\t\t\tif (strncmp(ptr, \"${PATH}\", 7) == 0) {\n\t\t\t\tchar *fname = ptr + 7;\n\t\t\t\tsize_t fname_len = strlen(fname);\n\t\t\t\tchar **paths = build_paths(); //{\"/usr/local/bin\", \"/usr/local/sbin\", \"/bin\", \"/usr/bin/\", \"/sbin\", \"/usr/sbin\", NULL};\n\t\t\t\tint i = 0;\n\t\t\t\twhile (paths[i] != NULL) {\n\t\t\t\t\tchar *path = paths[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tchar newname[strlen(path) + fname_len + 1];\n\t\t\t\t\tsprintf(newname, \"%s%s\", path, fname);\n\t\t\t\t\tglobbing(op, newname, (const char**)noblacklist, noblacklist_c);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tglobbing(op, ptr, (const char**)noblacklist, noblacklist_c);\n\t\t}\n\n\t\tif (new_name)\n\t\t\tfree(new_name);\n\t\tentry = entry->next;\n\t}\n\n\tsize_t i;\n\tfor (i = 0; i < noblacklist_c; i++) free(noblacklist[i]);\n        free(noblacklist);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_blacklist(void) {\n\tchar *homedir = cfg.homedir;\n\tassert(homedir);\n\tProfileEntry *entry = cfg.profile;\n\tif (!entry)\n\t\treturn;\n\t\t\n\tsize_t noblacklist_c = 0;\n\tsize_t noblacklist_m = 32;\n\tchar **noblacklist = calloc(noblacklist_m, sizeof(*noblacklist));\n\n\tif (noblacklist == NULL)\n\t\terrExit(\"failed allocating memory for noblacklist entries\");\n\n\twhile (entry) {\n\t\tOPERATION op = OPERATION_MAX;\n\t\tchar *ptr;\n\n\t\t// whitelist commands handled by fs_whitelist()\n\t\tif (strncmp(entry->data, \"whitelist \", 10) == 0 || *entry->data == '\\0') {\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// process bind command\n\t\tif (strncmp(entry->data, \"bind \", 5) == 0)  {\n\t\t\tchar *dname1 = entry->data + 5;\n\t\t\tchar *dname2 = split_comma(dname1);\n\t\t\tif (dname2 == NULL) {\n\t\t\t\tfprintf(stderr, \"Error: second directory missing in bind command\\n\");\n\t\t\t\tentry = entry->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstruct stat s;\n\t\t\tif (stat(dname1, &s) == -1) {\n\t\t\t\tfprintf(stderr, \"Error: cannot find %s for bind command\\n\", dname1);\n\t\t\t\tentry = entry->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (stat(dname2, &s) == -1) {\n\t\t\t\tfprintf(stderr, \"Error: cannot find %s for bind command\\n\", dname2);\n\t\t\t\tentry = entry->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t// mount --bind olddir newdir\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Mount-bind %s on top of %s\\n\", dname1, dname2);\n\t\t\t// preserve dname2 mode and ownership\n\t\t\tif (mount(dname1, dname2, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\t\t\t/* coverity[toctou] */\n\t\t\tif (chown(dname2, s.st_uid, s.st_gid) == -1)\n\t\t\t\terrExit(\"mount-bind chown\");\n\t\t\t/* coverity[toctou] */\n\t\t\tif (chmod(dname2, s.st_mode) == -1)\n\t\t\t\terrExit(\"mount-bind chmod\");\n\t\t\t\t\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Process noblacklist command\n\t\tif (strncmp(entry->data, \"noblacklist \", 12) == 0) {\n\t\t\tchar **paths = build_paths();\n\n\t\t\tchar *enames[sizeof(paths)+1] = {0};\n\t\t\tint i = 0;\n\n\t\t\tif (strncmp(entry->data + 12, \"${PATH}\", 7) == 0) {\n\t\t\t\t// expand ${PATH} macro\n\t\t\t\twhile (paths[i] != NULL) {\n\t\t\t\t\tif (asprintf(&enames[i], \"%s%s\", paths[i], entry->data + 19) == -1)\n\t\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// expand ${HOME} macro if found or pass as is\n\t\t\t\tenames[0] = expand_home(entry->data + 12, homedir);\n\t\t\t\tenames[1] = NULL;\n\t\t\t}\n\n\t\t\ti = 0;\n\t\t\twhile (enames[i] != NULL) {\n\t\t\t\tif (noblacklist_c >= noblacklist_m) {\n\t\t\t\t\tnoblacklist_m *= 2;\n\t\t\t\t\tnoblacklist = realloc(noblacklist, sizeof(*noblacklist) * noblacklist_m);\n\t\t\t\t\tif (noblacklist == NULL)\n\t\t\t\t\t\terrExit(\"failed increasing memory for noblacklist entries\");\n\t\t\t\t}\n\t\t\t\tnoblacklist[noblacklist_c++] = enames[i];\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\twhile (enames[i] != NULL) {\n\t\t\t\tfree(enames[i]);\n\t\t\t}\n\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// process blacklist command\n\t\tif (strncmp(entry->data, \"blacklist \", 10) == 0)  {\n\t\t\tptr = entry->data + 10;\n\t\t\top = BLACKLIST_FILE;\n\t\t}\n\t\telse if (strncmp(entry->data, \"blacklist-nolog \", 16) == 0)  {\n\t\t\tptr = entry->data + 16;\n\t\t\top = BLACKLIST_NOLOG;\n\t\t}\n\t\telse if (strncmp(entry->data, \"read-only \", 10) == 0) {\n\t\t\tptr = entry->data + 10;\n\t\t\top = MOUNT_READONLY;\n\t\t}\t\t\t\n\t\telse if (strncmp(entry->data, \"read-write \", 11) == 0) {\n\t\t\tptr = entry->data + 11;\n\t\t\top = MOUNT_RDWR;\n\t\t}\t\t\t\n\t\telse if (strncmp(entry->data, \"noexec \", 7) == 0) {\n\t\t\tptr = entry->data + 7;\n\t\t\top = MOUNT_NOEXEC;\n\t\t}\t\t\t\n\t\telse if (strncmp(entry->data, \"tmpfs \", 6) == 0) {\n\t\t\tptr = entry->data + 6;\n\t\t\top = MOUNT_TMPFS;\n\t\t}\t\t\t\n\t\telse if (strncmp(entry->data, \"mkdir \", 6) == 0) {\n\t\t\tEUID_USER();\n\t\t\tfs_mkdir(entry->data + 6);\n\t\t\tEUID_ROOT();\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\t\t\t\n\t\telse if (strncmp(entry->data, \"mkfile \", 7) == 0) {\n\t\t\tEUID_USER();\n\t\t\tfs_mkfile(entry->data + 7);\n\t\t\tEUID_ROOT();\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\t\t\t\n\t\telse {\n\t\t\tfprintf(stderr, \"Error: invalid profile line %s\\n\", entry->data);\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// replace home macro in blacklist array\n\t\tchar *new_name = expand_home(ptr, homedir);\n\t\tptr = new_name;\n\n\t\t// expand path macro - look for the file in /usr/local/bin,  /usr/local/sbin, /bin, /usr/bin, /sbin and  /usr/sbin directories\n\t\tif (ptr) {\n\t\t\tif (strncmp(ptr, \"${PATH}\", 7) == 0) {\n\t\t\t\tchar *fname = ptr + 7;\n\t\t\t\tsize_t fname_len = strlen(fname);\n\t\t\t\tchar **paths = build_paths(); //{\"/usr/local/bin\", \"/usr/local/sbin\", \"/bin\", \"/usr/bin/\", \"/sbin\", \"/usr/sbin\", NULL};\n\t\t\t\tint i = 0;\n\t\t\t\twhile (paths[i] != NULL) {\n\t\t\t\t\tchar *path = paths[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tchar newname[strlen(path) + fname_len + 1];\n\t\t\t\t\tsprintf(newname, \"%s%s\", path, fname);\n\t\t\t\t\tglobbing(op, newname, (const char**)noblacklist, noblacklist_c);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tglobbing(op, ptr, (const char**)noblacklist, noblacklist_c);\n\t\t}\n\n\t\tif (new_name)\n\t\t\tfree(new_name);\n\t\tentry = entry->next;\n\t}\n\n\tsize_t i;\n\tfor (i = 0; i < noblacklist_c; i++) free(noblacklist[i]);\n        free(noblacklist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_whitelist",
          "args": [],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: whitelist feature is disabled in overlay\\n\""
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: whitelist feature is disabled in chroot\\n\""
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_proc_sys_dev_boot",
          "args": [],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "fs_proc_sys_dev_boot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
          "lines": "636-718",
          "snippet": "void fs_proc_sys_dev_boot(void) {\n\tif (arg_debug)\n\t\tprintf(\"Remounting /proc and /proc/sys filesystems\\n\");\n\tif (mount(\"proc\", \"/proc\", \"proc\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /proc\");\n\tfs_logger(\"remount /proc\");\n\n\t// remount /proc/sys readonly\n\tif (mount(\"/proc/sys\", \"/proc/sys\", NULL, MS_BIND | MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /proc/sys\");\n\n\tif (mount(NULL, \"/proc/sys\", NULL, MS_BIND | MS_REMOUNT | MS_RDONLY | MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /proc/sys\");\n\tfs_logger(\"read-only /proc/sys\");\n\n\n\t/* Mount a version of /sys that describes the network namespace */\n\tif (arg_debug)\n\t\tprintf(\"Remounting /sys directory\\n\");\n\tif (umount2(\"/sys\", MNT_DETACH) < 0)\n\t\tfprintf(stderr, \"Warning: failed to unmount /sys\\n\");\n\telse {\n\t\tif (mount(\"sysfs\", \"/sys\", \"sysfs\", MS_RDONLY|MS_NOSUID|MS_NOEXEC|MS_NODEV|MS_REC, NULL) < 0)\n\t\t\tfprintf(stderr, \"Warning: failed to mount /sys\\n\");\n\t\telse\n\t\t\tfs_logger(\"remount /sys\");\n\t}\n\t\t\n\tdisable_file(BLACKLIST_FILE, \"/sys/firmware\");\n\tdisable_file(BLACKLIST_FILE, \"/sys/hypervisor\");\n\t{ // allow user access to /sys/fs if \"--noblacklist=/sys/fs\" is present on the command line\n\t\tEUID_USER();\t\n\t\tprofile_add(\"blacklist /sys/fs\");\n\t\tEUID_ROOT();\n\t}\n\tdisable_file(BLACKLIST_FILE, \"/sys/module\");\n\tdisable_file(BLACKLIST_FILE, \"/sys/power\");\n\tdisable_file(BLACKLIST_FILE, \"/sys/kernel/debug\");\n\tdisable_file(BLACKLIST_FILE, \"/sys/kernel/vmcoreinfo\");\n\tdisable_file(BLACKLIST_FILE, \"/sys/kernel/uevent_helper\");\n\n\t// various /proc/sys files\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/security\");\t\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/efi/vars\");\t\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/fs/binfmt_misc\");\t\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/kernel/core_pattern\");\t\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/kernel/modprobe\");\t\n\tdisable_file(BLACKLIST_FILE, \"/proc/sysrq-trigger\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/kernel/hotplug\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/vm/panic_on_oom\");\n\n\t// various /proc files\n\tdisable_file(BLACKLIST_FILE, \"/proc/irq\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/bus\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/config.gz\");\t\n\tdisable_file(BLACKLIST_FILE, \"/proc/sched_debug\");\t\n\tdisable_file(BLACKLIST_FILE, \"/proc/timer_list\");\t\n\tdisable_file(BLACKLIST_FILE, \"/proc/timer_stats\");\t\n\tdisable_file(BLACKLIST_FILE, \"/proc/kcore\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/kallsyms\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/mem\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/kmem\");\n\t\n\t// remove kernel symbol information\n\tif (!arg_allow_debuggers) {\n\t\tdisable_file(BLACKLIST_FILE, \"/usr/src/linux\");\n\t\tdisable_file(BLACKLIST_FILE, \"/lib/modules\");\n\t\tdisable_file(BLACKLIST_FILE, \"/usr/lib/debug\");\n\t\tdisable_file(BLACKLIST_FILE, \"/boot\");\n\t}\n\t\t\n\t// disable /selinux\n\tdisable_file(BLACKLIST_FILE, \"/selinux\");\n\t\n\t// disable /dev/port\n\tdisable_file(BLACKLIST_FILE, \"/dev/port\");\n\t\n\tif (getuid() != 0) {\n\t\t// disable /dev/kmsg and /proc/kmsg\n\t\tdisable_file(BLACKLIST_FILE, \"/dev/kmsg\");\n\t\tdisable_file(BLACKLIST_FILE, \"/proc/kmsg\");\n\t}\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_proc_sys_dev_boot(void) {\n\tif (arg_debug)\n\t\tprintf(\"Remounting /proc and /proc/sys filesystems\\n\");\n\tif (mount(\"proc\", \"/proc\", \"proc\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /proc\");\n\tfs_logger(\"remount /proc\");\n\n\t// remount /proc/sys readonly\n\tif (mount(\"/proc/sys\", \"/proc/sys\", NULL, MS_BIND | MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /proc/sys\");\n\n\tif (mount(NULL, \"/proc/sys\", NULL, MS_BIND | MS_REMOUNT | MS_RDONLY | MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /proc/sys\");\n\tfs_logger(\"read-only /proc/sys\");\n\n\n\t/* Mount a version of /sys that describes the network namespace */\n\tif (arg_debug)\n\t\tprintf(\"Remounting /sys directory\\n\");\n\tif (umount2(\"/sys\", MNT_DETACH) < 0)\n\t\tfprintf(stderr, \"Warning: failed to unmount /sys\\n\");\n\telse {\n\t\tif (mount(\"sysfs\", \"/sys\", \"sysfs\", MS_RDONLY|MS_NOSUID|MS_NOEXEC|MS_NODEV|MS_REC, NULL) < 0)\n\t\t\tfprintf(stderr, \"Warning: failed to mount /sys\\n\");\n\t\telse\n\t\t\tfs_logger(\"remount /sys\");\n\t}\n\t\t\n\tdisable_file(BLACKLIST_FILE, \"/sys/firmware\");\n\tdisable_file(BLACKLIST_FILE, \"/sys/hypervisor\");\n\t{ // allow user access to /sys/fs if \"--noblacklist=/sys/fs\" is present on the command line\n\t\tEUID_USER();\t\n\t\tprofile_add(\"blacklist /sys/fs\");\n\t\tEUID_ROOT();\n\t}\n\tdisable_file(BLACKLIST_FILE, \"/sys/module\");\n\tdisable_file(BLACKLIST_FILE, \"/sys/power\");\n\tdisable_file(BLACKLIST_FILE, \"/sys/kernel/debug\");\n\tdisable_file(BLACKLIST_FILE, \"/sys/kernel/vmcoreinfo\");\n\tdisable_file(BLACKLIST_FILE, \"/sys/kernel/uevent_helper\");\n\n\t// various /proc/sys files\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/security\");\t\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/efi/vars\");\t\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/fs/binfmt_misc\");\t\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/kernel/core_pattern\");\t\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/kernel/modprobe\");\t\n\tdisable_file(BLACKLIST_FILE, \"/proc/sysrq-trigger\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/kernel/hotplug\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/vm/panic_on_oom\");\n\n\t// various /proc files\n\tdisable_file(BLACKLIST_FILE, \"/proc/irq\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/bus\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/config.gz\");\t\n\tdisable_file(BLACKLIST_FILE, \"/proc/sched_debug\");\t\n\tdisable_file(BLACKLIST_FILE, \"/proc/timer_list\");\t\n\tdisable_file(BLACKLIST_FILE, \"/proc/timer_stats\");\t\n\tdisable_file(BLACKLIST_FILE, \"/proc/kcore\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/kallsyms\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/mem\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/kmem\");\n\t\n\t// remove kernel symbol information\n\tif (!arg_allow_debuggers) {\n\t\tdisable_file(BLACKLIST_FILE, \"/usr/src/linux\");\n\t\tdisable_file(BLACKLIST_FILE, \"/lib/modules\");\n\t\tdisable_file(BLACKLIST_FILE, \"/usr/lib/debug\");\n\t\tdisable_file(BLACKLIST_FILE, \"/boot\");\n\t}\n\t\t\n\t// disable /selinux\n\tdisable_file(BLACKLIST_FILE, \"/selinux\");\n\t\n\t// disable /dev/port\n\tdisable_file(BLACKLIST_FILE, \"/dev/port\");\n\t\n\tif (getuid() != 0) {\n\t\t// disable /dev/kmsg and /proc/kmsg\n\t\tdisable_file(BLACKLIST_FILE, \"/dev/kmsg\");\n\t\tdisable_file(BLACKLIST_FILE, \"/proc/kmsg\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "checkcfg",
          "args": [
            "CFG_REMOUNT_PROC_SYS"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "checkcfg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/checkcfg.c",
          "lines": "32-286",
          "snippet": "int checkcfg(int val) {\n\tassert(val < CFG_MAX);\n\tint line = 0;\n\n\tif (!initialized) {\n\t\t// initialize defaults\n\t\tint i;\n\t\tfor (i = 0; i < CFG_MAX; i++)\n\t\t\tcfg_val[i] = 1; // most of them are enabled by default\n\t\tcfg_val[CFG_RESTRICTED_NETWORK] = 0; // disabled by default\n\t\tcfg_val[CFG_FORCE_NONEWPRIVS] = 0; // disabled by default\n\t\tcfg_val[CFG_PRIVATE_BIN_NO_LOCAL] = 0; // disabled by default\n\t\t\n\t\t// open configuration file\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"%s/firejail.config\", SYSCONFDIR) == -1)\n\t\t\terrExit(\"asprintf\");\n\n\t\tFILE *fp = fopen(fname, \"r\");\n\t\tif (!fp) {\n#ifdef HAVE_GLOBALCFG\t\t\t\n\t\t\tfprintf(stderr, \"Error: Firejail configuration file %s not found\\n\", fname);\n\t\t\texit(1);\n#else\n\t\t\tinitialized = 1;\n\t\t\treturn\tcfg_val[val];\n#endif\t\n\t\t}\n\t\t\n\t\t// if the file exists, it should be owned by root\n\t\tstruct stat s;\n\t\tif (stat(fname, &s) == -1)\n\t\t\terrExit(\"stat\");\n\t\tif (s.st_uid != 0) {\n\t\t\tfprintf(stderr, \"Error: configuration file should be owned by root\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\t// read configuration file\n\t\tchar buf[MAX_READ];\n\t\twhile (fgets(buf,MAX_READ, fp)) {\n\t\t\tline++;\n\t\t\tif (*buf == '#' || *buf == '\\n') \n\t\t\t\tcontinue;\n\n\t\t\t// parse line\t\t\t\t\n\t\t\tchar *ptr = line_remove_spaces(buf);\n\t\t\tif (!ptr)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\t// file transfer\t\n\t\t\tif (strncmp(ptr, \"file-transfer \", 14) == 0) {\n\t\t\t\tif (strcmp(ptr + 14, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_FILE_TRANSFER] = 1;\n\t\t\t\telse if (strcmp(ptr + 14, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_FILE_TRANSFER] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// x11\n\t\t\telse if (strncmp(ptr, \"x11 \", 4) == 0) {\n\t\t\t\tif (strcmp(ptr + 4, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_X11] = 1;\n\t\t\t\telse if (strcmp(ptr + 4, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_X11] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// bind\n\t\t\telse if (strncmp(ptr, \"bind \", 5) == 0) {\n\t\t\t\tif (strcmp(ptr + 5, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_BIND] = 1;\n\t\t\t\telse if (strcmp(ptr + 5, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_BIND] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// user namespace\n\t\t\telse if (strncmp(ptr, \"userns \", 7) == 0) {\n\t\t\t\tif (strcmp(ptr + 7, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_USERNS] = 1;\n\t\t\t\telse if (strcmp(ptr + 7, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_USERNS] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// chroot\n\t\t\telse if (strncmp(ptr, \"chroot \", 7) == 0) {\n\t\t\t\tif (strcmp(ptr + 7, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_CHROOT] = 1;\n\t\t\t\telse if (strcmp(ptr + 7, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_CHROOT] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// nonewprivs\n\t\t\telse if (strncmp(ptr, \"force-nonewprivs \", 17) == 0) {\n\t\t\t\tif (strcmp(ptr + 17, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_SECCOMP] = 1;\n\t\t\t\telse if (strcmp(ptr + 17, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_SECCOMP] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// seccomp\n\t\t\telse if (strncmp(ptr, \"seccomp \", 8) == 0) {\n\t\t\t\tif (strcmp(ptr + 8, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_SECCOMP] = 1;\n\t\t\t\telse if (strcmp(ptr + 8, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_SECCOMP] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// whitelist\n\t\t\telse if (strncmp(ptr, \"whitelist \", 10) == 0) {\n\t\t\t\tif (strcmp(ptr + 10, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_WHITELIST] = 1;\n\t\t\t\telse if (strcmp(ptr + 10, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_WHITELIST] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// network\n\t\t\telse if (strncmp(ptr, \"network \", 8) == 0) {\n\t\t\t\tif (strcmp(ptr + 8, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_NETWORK] = 1;\n\t\t\t\telse if (strcmp(ptr + 8, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_NETWORK] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// network\n\t\t\telse if (strncmp(ptr, \"restricted-network \", 19) == 0) {\n\t\t\t\tif (strcmp(ptr + 19, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_RESTRICTED_NETWORK] = 1;\n\t\t\t\telse if (strcmp(ptr + 19, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_RESTRICTED_NETWORK] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// netfilter\n\t\t\telse if (strncmp(ptr, \"netfilter-default \", 18) == 0) {\n\t\t\t\tchar *fname = ptr + 18;\n\t\t\t\twhile (*fname == ' ' || *fname == '\\t')\n\t\t\t\t\tptr++;\n\t\t\t\tchar *end = strchr(fname, ' ');\n\t\t\t\tif (end)\n\t\t\t\t\t*end = '\\0';\n\t\t\t\t\n\t\t\t\t// is the file present?\n\t\t\t\tstruct stat s;\n\t\t\t\tif (stat(fname, &s) == -1) {\n\t\t\t\t\tfprintf(stderr, \"Error: netfilter-default file %s not available\\n\", fname);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tnetfilter_default = strdup(fname);\n\t\t\t\tif (!netfilter_default)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t\tif (arg_debug)\n\t\t\t\t\tprintf(\"netfilter default file %s\\n\", fname);\n\t\t\t}\n\t\t\t\n\t\t\t// Xephyr screen size\n\t\t\telse if (strncmp(ptr, \"xephyr-screen \", 14) == 0) {\n\t\t\t\t// expecting two numbers and an x between them\n\t\t\t\tint n1;\n\t\t\t\tint n2;\n\t\t\t\tint rv = sscanf(ptr + 14, \"%dx%d\", &n1, &n2);\n\t\t\t\tif (rv != 2)\n\t\t\t\t\tgoto errout;\n\t\t\t\tif (asprintf(&xephyr_screen, \"%dx%d\", n1, n2) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t}\n\t\n\t\t\t// xephyr window title\n\t\t\telse if (strncmp(ptr, \"xephyr-window-title \", 20) == 0) {\n\t\t\t\tif (strcmp(ptr + 20, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_XEPHYR_WINDOW_TITLE] = 1;\n\t\t\t\telse if (strcmp(ptr + 20, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_XEPHYR_WINDOW_TITLE] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t\t\n\t\t\t// Xephyr command extra parameters\n\t\t\telse if (strncmp(ptr, \"xephyr-extra-params \", 19) == 0) {\n\t\t\t\txephyr_extra_params = strdup(ptr + 19);\n\t\t\t\tif (!xephyr_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\t\t\t\n\t\t\t// quiet by default\n\t\t\telse if (strncmp(ptr, \"quiet-by-default \", 17) == 0) {\n\t\t\t\tif (strcmp(ptr + 17, \"yes\") == 0)\n\t\t\t\t\targ_quiet = 1;\n\t\t\t}\n\t\t\t// remount /proc and /sys\n\t\t\telse if (strncmp(ptr, \"remount-proc-sys \", 17) == 0) {\n\t\t\t\tif (strcmp(ptr + 17, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_REMOUNT_PROC_SYS] = 1;\n\t\t\t\telse if (strcmp(ptr + 17, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_REMOUNT_PROC_SYS] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\telse if (strncmp(ptr, \"overlayfs \", 10) == 0) {\n\t\t\t\tif (strcmp(ptr + 10, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_OVERLAYFS] = 1;\n\t\t\t\telse if (strcmp(ptr + 10, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_OVERLAYFS] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\telse if (strncmp(ptr, \"private-home \", 13) == 0) {\n\t\t\t\tif (strcmp(ptr + 13, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_PRIVATE_HOME] = 1;\n\t\t\t\telse if (strcmp(ptr + 13, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_PRIVATE_HOME] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\telse if (strncmp(ptr, \"chroot-desktop \", 15) == 0) {\n\t\t\t\tif (strcmp(ptr + 15, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_CHROOT_DESKTOP] = 1;\n\t\t\t\telse if (strcmp(ptr + 15, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_CHROOT_DESKTOP] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\telse if (strncmp(ptr, \"private-bin-no-local \", 21) == 0) {\n\t\t\t\tif (strcmp(ptr + 21, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_PRIVATE_BIN_NO_LOCAL] = 1;\n\t\t\t\telse if (strcmp(ptr + 21, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_PRIVATE_BIN_NO_LOCAL] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\telse\n\t\t\t\tgoto errout;\n\n\t\t\tfree(ptr);\n\t\t}\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t\tinitialized = 1;\n\t}\n\t\n\treturn cfg_val[val];\n\t\nerrout:\n\tfprintf(stderr, \"Error: invalid line %d in firejail configuration file\\n\", line );\n\texit(1);\n}",
          "includes": [
            "#include <linux/loop.h>",
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAX_READ 8192\t\t\t\t  // line buffer for profile files"
          ],
          "globals_used": [
            "static int initialized = 0;",
            "static int cfg_val[CFG_MAX];",
            "char *xephyr_screen = \"800x600\";",
            "char *xephyr_extra_params = \"\";",
            "char *netfilter_default = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/loop.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\n#define MAX_READ 8192\t\t\t\t  // line buffer for profile files\n\nstatic int initialized = 0;\nstatic int cfg_val[CFG_MAX];\nchar *xephyr_screen = \"800x600\";\nchar *xephyr_extra_params = \"\";\nchar *netfilter_default = NULL;\n\nint checkcfg(int val) {\n\tassert(val < CFG_MAX);\n\tint line = 0;\n\n\tif (!initialized) {\n\t\t// initialize defaults\n\t\tint i;\n\t\tfor (i = 0; i < CFG_MAX; i++)\n\t\t\tcfg_val[i] = 1; // most of them are enabled by default\n\t\tcfg_val[CFG_RESTRICTED_NETWORK] = 0; // disabled by default\n\t\tcfg_val[CFG_FORCE_NONEWPRIVS] = 0; // disabled by default\n\t\tcfg_val[CFG_PRIVATE_BIN_NO_LOCAL] = 0; // disabled by default\n\t\t\n\t\t// open configuration file\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"%s/firejail.config\", SYSCONFDIR) == -1)\n\t\t\terrExit(\"asprintf\");\n\n\t\tFILE *fp = fopen(fname, \"r\");\n\t\tif (!fp) {\n#ifdef HAVE_GLOBALCFG\t\t\t\n\t\t\tfprintf(stderr, \"Error: Firejail configuration file %s not found\\n\", fname);\n\t\t\texit(1);\n#else\n\t\t\tinitialized = 1;\n\t\t\treturn\tcfg_val[val];\n#endif\t\n\t\t}\n\t\t\n\t\t// if the file exists, it should be owned by root\n\t\tstruct stat s;\n\t\tif (stat(fname, &s) == -1)\n\t\t\terrExit(\"stat\");\n\t\tif (s.st_uid != 0) {\n\t\t\tfprintf(stderr, \"Error: configuration file should be owned by root\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\t// read configuration file\n\t\tchar buf[MAX_READ];\n\t\twhile (fgets(buf,MAX_READ, fp)) {\n\t\t\tline++;\n\t\t\tif (*buf == '#' || *buf == '\\n') \n\t\t\t\tcontinue;\n\n\t\t\t// parse line\t\t\t\t\n\t\t\tchar *ptr = line_remove_spaces(buf);\n\t\t\tif (!ptr)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\t// file transfer\t\n\t\t\tif (strncmp(ptr, \"file-transfer \", 14) == 0) {\n\t\t\t\tif (strcmp(ptr + 14, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_FILE_TRANSFER] = 1;\n\t\t\t\telse if (strcmp(ptr + 14, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_FILE_TRANSFER] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// x11\n\t\t\telse if (strncmp(ptr, \"x11 \", 4) == 0) {\n\t\t\t\tif (strcmp(ptr + 4, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_X11] = 1;\n\t\t\t\telse if (strcmp(ptr + 4, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_X11] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// bind\n\t\t\telse if (strncmp(ptr, \"bind \", 5) == 0) {\n\t\t\t\tif (strcmp(ptr + 5, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_BIND] = 1;\n\t\t\t\telse if (strcmp(ptr + 5, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_BIND] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// user namespace\n\t\t\telse if (strncmp(ptr, \"userns \", 7) == 0) {\n\t\t\t\tif (strcmp(ptr + 7, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_USERNS] = 1;\n\t\t\t\telse if (strcmp(ptr + 7, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_USERNS] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// chroot\n\t\t\telse if (strncmp(ptr, \"chroot \", 7) == 0) {\n\t\t\t\tif (strcmp(ptr + 7, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_CHROOT] = 1;\n\t\t\t\telse if (strcmp(ptr + 7, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_CHROOT] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// nonewprivs\n\t\t\telse if (strncmp(ptr, \"force-nonewprivs \", 17) == 0) {\n\t\t\t\tif (strcmp(ptr + 17, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_SECCOMP] = 1;\n\t\t\t\telse if (strcmp(ptr + 17, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_SECCOMP] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// seccomp\n\t\t\telse if (strncmp(ptr, \"seccomp \", 8) == 0) {\n\t\t\t\tif (strcmp(ptr + 8, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_SECCOMP] = 1;\n\t\t\t\telse if (strcmp(ptr + 8, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_SECCOMP] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// whitelist\n\t\t\telse if (strncmp(ptr, \"whitelist \", 10) == 0) {\n\t\t\t\tif (strcmp(ptr + 10, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_WHITELIST] = 1;\n\t\t\t\telse if (strcmp(ptr + 10, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_WHITELIST] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// network\n\t\t\telse if (strncmp(ptr, \"network \", 8) == 0) {\n\t\t\t\tif (strcmp(ptr + 8, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_NETWORK] = 1;\n\t\t\t\telse if (strcmp(ptr + 8, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_NETWORK] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// network\n\t\t\telse if (strncmp(ptr, \"restricted-network \", 19) == 0) {\n\t\t\t\tif (strcmp(ptr + 19, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_RESTRICTED_NETWORK] = 1;\n\t\t\t\telse if (strcmp(ptr + 19, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_RESTRICTED_NETWORK] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// netfilter\n\t\t\telse if (strncmp(ptr, \"netfilter-default \", 18) == 0) {\n\t\t\t\tchar *fname = ptr + 18;\n\t\t\t\twhile (*fname == ' ' || *fname == '\\t')\n\t\t\t\t\tptr++;\n\t\t\t\tchar *end = strchr(fname, ' ');\n\t\t\t\tif (end)\n\t\t\t\t\t*end = '\\0';\n\t\t\t\t\n\t\t\t\t// is the file present?\n\t\t\t\tstruct stat s;\n\t\t\t\tif (stat(fname, &s) == -1) {\n\t\t\t\t\tfprintf(stderr, \"Error: netfilter-default file %s not available\\n\", fname);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tnetfilter_default = strdup(fname);\n\t\t\t\tif (!netfilter_default)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t\tif (arg_debug)\n\t\t\t\t\tprintf(\"netfilter default file %s\\n\", fname);\n\t\t\t}\n\t\t\t\n\t\t\t// Xephyr screen size\n\t\t\telse if (strncmp(ptr, \"xephyr-screen \", 14) == 0) {\n\t\t\t\t// expecting two numbers and an x between them\n\t\t\t\tint n1;\n\t\t\t\tint n2;\n\t\t\t\tint rv = sscanf(ptr + 14, \"%dx%d\", &n1, &n2);\n\t\t\t\tif (rv != 2)\n\t\t\t\t\tgoto errout;\n\t\t\t\tif (asprintf(&xephyr_screen, \"%dx%d\", n1, n2) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t}\n\t\n\t\t\t// xephyr window title\n\t\t\telse if (strncmp(ptr, \"xephyr-window-title \", 20) == 0) {\n\t\t\t\tif (strcmp(ptr + 20, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_XEPHYR_WINDOW_TITLE] = 1;\n\t\t\t\telse if (strcmp(ptr + 20, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_XEPHYR_WINDOW_TITLE] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t\t\n\t\t\t// Xephyr command extra parameters\n\t\t\telse if (strncmp(ptr, \"xephyr-extra-params \", 19) == 0) {\n\t\t\t\txephyr_extra_params = strdup(ptr + 19);\n\t\t\t\tif (!xephyr_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\t\t\t\n\t\t\t// quiet by default\n\t\t\telse if (strncmp(ptr, \"quiet-by-default \", 17) == 0) {\n\t\t\t\tif (strcmp(ptr + 17, \"yes\") == 0)\n\t\t\t\t\targ_quiet = 1;\n\t\t\t}\n\t\t\t// remount /proc and /sys\n\t\t\telse if (strncmp(ptr, \"remount-proc-sys \", 17) == 0) {\n\t\t\t\tif (strcmp(ptr + 17, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_REMOUNT_PROC_SYS] = 1;\n\t\t\t\telse if (strcmp(ptr + 17, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_REMOUNT_PROC_SYS] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\telse if (strncmp(ptr, \"overlayfs \", 10) == 0) {\n\t\t\t\tif (strcmp(ptr + 10, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_OVERLAYFS] = 1;\n\t\t\t\telse if (strcmp(ptr + 10, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_OVERLAYFS] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\telse if (strncmp(ptr, \"private-home \", 13) == 0) {\n\t\t\t\tif (strcmp(ptr + 13, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_PRIVATE_HOME] = 1;\n\t\t\t\telse if (strcmp(ptr + 13, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_PRIVATE_HOME] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\telse if (strncmp(ptr, \"chroot-desktop \", 15) == 0) {\n\t\t\t\tif (strcmp(ptr + 15, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_CHROOT_DESKTOP] = 1;\n\t\t\t\telse if (strcmp(ptr + 15, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_CHROOT_DESKTOP] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\telse if (strncmp(ptr, \"private-bin-no-local \", 21) == 0) {\n\t\t\t\tif (strcmp(ptr + 21, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_PRIVATE_BIN_NO_LOCAL] = 1;\n\t\t\t\telse if (strcmp(ptr + 21, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_PRIVATE_BIN_NO_LOCAL] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\telse\n\t\t\t\tgoto errout;\n\n\t\t\tfree(ptr);\n\t\t}\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t\tinitialized = 1;\n\t}\n\t\n\treturn cfg_val[val];\n\t\nerrout:\n\tfprintf(stderr, \"Error: invalid line %d in firejail configuration file\\n\", line );\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EUID_ROOT",
          "args": [],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "profile_add",
          "args": [
            "\"whitelist /tmp/.X11-unix\""
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "profile_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/profile.c",
          "lines": "919-938",
          "snippet": "void profile_add(char *str) {\n\tEUID_ASSERT();\n\t\n\tProfileEntry *prf = malloc(sizeof(ProfileEntry));\n\tif (!prf)\n\t\terrExit(\"malloc\");\n\tmemset(prf, 0, sizeof(ProfileEntry));\n\tprf->next = NULL;\n\tprf->data = str;\t\n\n\t// add prf to the list\n\tif (cfg.profile == NULL) {\n\t\tcfg.profile = prf;\n\t\treturn;\n\t}\n\tProfileEntry *ptr = cfg.profile;\n\twhile (ptr->next != NULL)\n\t\tptr = ptr->next;\n\tptr->next = prf;\n}",
          "includes": [
            "#include <sys/stat.h>",
            "#include <dirent.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/stat.h>\n#include <dirent.h>\n#include \"firejail.h\"\n\nvoid profile_add(char *str) {\n\tEUID_ASSERT();\n\t\n\tProfileEntry *prf = malloc(sizeof(ProfileEntry));\n\tif (!prf)\n\t\terrExit(\"malloc\");\n\tmemset(prf, 0, sizeof(ProfileEntry));\n\tprf->next = NULL;\n\tprf->data = str;\t\n\n\t// add prf to the list\n\tif (cfg.profile == NULL) {\n\t\tcfg.profile = prf;\n\t\treturn;\n\t}\n\tProfileEntry *ptr = cfg.profile;\n\twhile (ptr->next != NULL)\n\t\tptr = ptr->next;\n\tptr->next = prf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EUID_USER",
          "args": [],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: private-tmp feature is disabled in overlay\\n\""
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: private-tmp feature is disabled in chroot\\n\""
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_private_bin_list",
          "args": [],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "fs_private_bin_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_bin.c",
          "lines": "210-294",
          "snippet": "void fs_private_bin_list(void) {\n\tchar *private_list = cfg.bin_private_keep;\n\tassert(private_list);\n\t\n\t// create /run/firejail/mnt/bin directory\n\tfs_build_mnt_dir();\n\tif (mkdir(RUN_BIN_DIR, 0755) == -1)\n\t\terrExit(\"mkdir\");\n\tif (chmod(RUN_BIN_DIR, 0755) == -1)\n\t\terrExit(\"chmod\");\n\tASSERT_PERMS(RUN_BIN_DIR, 0, 0, 0755);\n\t\n\t// copy the list of files in the new etc directory\n\t// using a new child process without root privileges\n\tfs_logger_print();\t// save the current log\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Copying files in the new home:\\n\");\n\n\t\t// elevate privileges - files in the new /bin directory belong to root\n\t\tif (setreuid(0, 0) < 0)\n\t\t\terrExit(\"setreuid\");\n\t\tif (setregid(0, 0) < 0)\n\t\t\terrExit(\"setregid\");\n\t\t\n\t\t// copy the list of files in the new home directory\n\t\tchar *dlist = strdup(private_list);\n\t\tif (!dlist)\n\t\t\terrExit(\"strdup\");\n\t\n\t\n\t\tchar *ptr = strtok(dlist, \",\");\n\t\tduplicate(ptr);\n\t\n\t\twhile ((ptr = strtok(NULL, \",\")) != NULL)\n\t\t\tduplicate(ptr);\n\t\tfree(dlist);\t\n\t\tfs_logger_print();\n\t\t_exit(0);\n\t}\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n\n\t// mount-bind\n\tint i = 0;\n\twhile (paths[i]) {\n\t\tstruct stat s;\n\t\tif (stat(paths[i], &s) == 0) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Mount-bind %s on top of %s\\n\", RUN_BIN_DIR, paths[i]);\n\t\t\tif (mount(RUN_BIN_DIR, paths[i], NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\t\t\tfs_logger2(\"tmpfs\", paths[i]);\n\t\t\tfs_logger2(\"mount\", paths[i]);\n\t\t}\n\t\ti++;\n\t}\n\t\n\t// log cloned files\n\tchar *dlist = strdup(private_list);\n\tif (!dlist)\n\t\terrExit(\"strdup\");\n\t\n\t\n\tchar *ptr = strtok(dlist, \",\");\n\twhile (ptr) {\n\t\ti = 0;\n\t\twhile (paths[i]) {\n\t\t\tstruct stat s;\n\t\t\tif (stat(paths[i], &s) == 0) {\n\t\t\t\tchar *fname;\n\t\t\t\tif (asprintf(&fname, \"%s/%s\", paths[i], ptr) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\tfs_logger2(\"clone\", fname);\n\t\t\t\tfree(fname);\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tptr = strtok(NULL, \",\");\n\t}\n\tfree(dlist);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *paths[] = {\n\t\"/usr/local/bin\",\n\t\"/usr/bin\",\n\t\"/bin\",\n\t\"/usr/games\",\n\t\"/usr/local/games\",\n\t\"/usr/local/sbin\",\n\t\"/usr/sbin\",\n\t\"/sbin\",\n\tNULL\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic char *paths[] = {\n\t\"/usr/local/bin\",\n\t\"/usr/bin\",\n\t\"/bin\",\n\t\"/usr/games\",\n\t\"/usr/local/games\",\n\t\"/usr/local/sbin\",\n\t\"/usr/sbin\",\n\t\"/sbin\",\n\tNULL\n};\n\nvoid fs_private_bin_list(void) {\n\tchar *private_list = cfg.bin_private_keep;\n\tassert(private_list);\n\t\n\t// create /run/firejail/mnt/bin directory\n\tfs_build_mnt_dir();\n\tif (mkdir(RUN_BIN_DIR, 0755) == -1)\n\t\terrExit(\"mkdir\");\n\tif (chmod(RUN_BIN_DIR, 0755) == -1)\n\t\terrExit(\"chmod\");\n\tASSERT_PERMS(RUN_BIN_DIR, 0, 0, 0755);\n\t\n\t// copy the list of files in the new etc directory\n\t// using a new child process without root privileges\n\tfs_logger_print();\t// save the current log\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Copying files in the new home:\\n\");\n\n\t\t// elevate privileges - files in the new /bin directory belong to root\n\t\tif (setreuid(0, 0) < 0)\n\t\t\terrExit(\"setreuid\");\n\t\tif (setregid(0, 0) < 0)\n\t\t\terrExit(\"setregid\");\n\t\t\n\t\t// copy the list of files in the new home directory\n\t\tchar *dlist = strdup(private_list);\n\t\tif (!dlist)\n\t\t\terrExit(\"strdup\");\n\t\n\t\n\t\tchar *ptr = strtok(dlist, \",\");\n\t\tduplicate(ptr);\n\t\n\t\twhile ((ptr = strtok(NULL, \",\")) != NULL)\n\t\t\tduplicate(ptr);\n\t\tfree(dlist);\t\n\t\tfs_logger_print();\n\t\t_exit(0);\n\t}\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n\n\t// mount-bind\n\tint i = 0;\n\twhile (paths[i]) {\n\t\tstruct stat s;\n\t\tif (stat(paths[i], &s) == 0) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Mount-bind %s on top of %s\\n\", RUN_BIN_DIR, paths[i]);\n\t\t\tif (mount(RUN_BIN_DIR, paths[i], NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\t\t\tfs_logger2(\"tmpfs\", paths[i]);\n\t\t\tfs_logger2(\"mount\", paths[i]);\n\t\t}\n\t\ti++;\n\t}\n\t\n\t// log cloned files\n\tchar *dlist = strdup(private_list);\n\tif (!dlist)\n\t\terrExit(\"strdup\");\n\t\n\t\n\tchar *ptr = strtok(dlist, \",\");\n\twhile (ptr) {\n\t\ti = 0;\n\t\twhile (paths[i]) {\n\t\t\tstruct stat s;\n\t\t\tif (stat(paths[i], &s) == 0) {\n\t\t\t\tchar *fname;\n\t\t\t\tif (asprintf(&fname, \"%s/%s\", paths[i], ptr) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\tfs_logger2(\"clone\", fname);\n\t\t\t\tfree(fname);\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tptr = strtok(NULL, \",\");\n\t}\n\tfree(dlist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EUID_ROOT",
          "args": [],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_check_bin_list",
          "args": [],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "fs_check_bin_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_bin.c",
          "lines": "97-156",
          "snippet": "void fs_check_bin_list(void) {\n\tEUID_ASSERT();\n\tif (strstr(cfg.bin_private_keep, \"..\")) {\n\t\tfprintf(stderr, \"Error: invalid private bin list\\n\");\n\t\texit(1);\n\t}\n\t\n\tchar *dlist = strdup(cfg.bin_private_keep);\n\tif (!dlist)\n\t\terrExit(\"strdup\");\n\n\t// create a new list removing files not found\n\tchar *newlist = malloc(strlen(dlist) + 1 + 1); // +',' + '\\0'\n\tif (!newlist)\n\t\terrExit(\"malloc\");\n\t*newlist = '\\0';\n\tchar *newlistptr = newlist;\n\n\t// check the first file\n\tchar *ptr = strtok(dlist, \",\");\n\tint notfound = 0;\n\tif (check_dir_or_file(ptr)) {\n\t\t// file found, copy the name in the new list\n\t\tstrcpy(newlistptr, ptr);\n\t\tstrcat(newlistptr, \",\");\n\t\tnewlistptr += strlen(newlistptr);\n\t}\n\telse\n\t\tnotfound = 1;\n\n\t// check the rest of the list\n\twhile ((ptr = strtok(NULL, \",\")) != NULL) {\n\t\tif (check_dir_or_file(ptr)) {\n\t\t\t// file found, copy the name in the new list\n\t\t\tstrcpy(newlistptr, ptr);\n\t\t\tstrcat(newlistptr, \",\");\n\t\t\tnewlistptr += strlen(newlistptr);\n\t\t}\n\t\telse\n\t\t\tnotfound = 1;\n\t}\n\t\n\tif (*newlist == '\\0') {\n//\t\tfprintf(stderr, \"Warning: no --private-bin list executable found, option disabled\\n\");\n//\t\tcfg.bin_private_keep = NULL;\n//\t\targ_private_bin = 0;\n\t\tfree(newlist);\n\t}\n\telse {\n\t\tptr = strrchr(newlist, ',');\n\t\tassert(ptr);\n\t\t*ptr = '\\0';\n\t\tif (notfound && !arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: not all executables from --private-bin list were found. The current list is %s\\n\", newlist);\n\t\t\n\t\tcfg.bin_private_keep = newlist;\n\t}\n\t\n\tfree(dlist);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_check_bin_list(void) {\n\tEUID_ASSERT();\n\tif (strstr(cfg.bin_private_keep, \"..\")) {\n\t\tfprintf(stderr, \"Error: invalid private bin list\\n\");\n\t\texit(1);\n\t}\n\t\n\tchar *dlist = strdup(cfg.bin_private_keep);\n\tif (!dlist)\n\t\terrExit(\"strdup\");\n\n\t// create a new list removing files not found\n\tchar *newlist = malloc(strlen(dlist) + 1 + 1); // +',' + '\\0'\n\tif (!newlist)\n\t\terrExit(\"malloc\");\n\t*newlist = '\\0';\n\tchar *newlistptr = newlist;\n\n\t// check the first file\n\tchar *ptr = strtok(dlist, \",\");\n\tint notfound = 0;\n\tif (check_dir_or_file(ptr)) {\n\t\t// file found, copy the name in the new list\n\t\tstrcpy(newlistptr, ptr);\n\t\tstrcat(newlistptr, \",\");\n\t\tnewlistptr += strlen(newlistptr);\n\t}\n\telse\n\t\tnotfound = 1;\n\n\t// check the rest of the list\n\twhile ((ptr = strtok(NULL, \",\")) != NULL) {\n\t\tif (check_dir_or_file(ptr)) {\n\t\t\t// file found, copy the name in the new list\n\t\t\tstrcpy(newlistptr, ptr);\n\t\t\tstrcat(newlistptr, \",\");\n\t\t\tnewlistptr += strlen(newlistptr);\n\t\t}\n\t\telse\n\t\t\tnotfound = 1;\n\t}\n\t\n\tif (*newlist == '\\0') {\n//\t\tfprintf(stderr, \"Warning: no --private-bin list executable found, option disabled\\n\");\n//\t\tcfg.bin_private_keep = NULL;\n//\t\targ_private_bin = 0;\n\t\tfree(newlist);\n\t}\n\telse {\n\t\tptr = strrchr(newlist, ',');\n\t\tassert(ptr);\n\t\t*ptr = '\\0';\n\t\tif (notfound && !arg_quiet)\n\t\t\tfprintf(stderr, \"Warning: not all executables from --private-bin list were found. The current list is %s\\n\", newlist);\n\t\t\n\t\tcfg.bin_private_keep = newlist;\n\t}\n\t\n\tfree(dlist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&tmp",
            "\"%s,xauth\"",
            "cfg.bin_private_keep"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_USER",
          "args": [],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: private-bin feature is disabled in overlay\\n\""
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: private-bin feature is disabled in chroot\\n\""
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_trace_preload",
          "args": [],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "fs_trace_preload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_trace.c",
          "lines": "29-44",
          "snippet": "void fs_trace_preload(void) {\n\tstruct stat s;\n\n\t// create an empty /etc/ld.so.preload\n\tif (stat(\"/etc/ld.so.preload\", &s)) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Creating an empty /etc/ld.so.preload file\\n\");\n\t\t/* coverity[toctou] */\n\t\tFILE *fp = fopen(\"/etc/ld.so.preload\", \"w\");\n\t\tif (!fp)\n\t\t\terrExit(\"fopen\");\n\t\tSET_PERMS_STREAM(fp, 0, 0, S_IRUSR | S_IWRITE | S_IRGRP | S_IROTH);\n\t\tfclose(fp);\n\t\tfs_logger(\"touch /etc/ld.so.preload\");\n\t}\n}",
          "includes": [
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pwd.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_trace_preload(void) {\n\tstruct stat s;\n\n\t// create an empty /etc/ld.so.preload\n\tif (stat(\"/etc/ld.so.preload\", &s)) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Creating an empty /etc/ld.so.preload file\\n\");\n\t\t/* coverity[toctou] */\n\t\tFILE *fp = fopen(\"/etc/ld.so.preload\", \"w\");\n\t\tif (!fp)\n\t\t\terrExit(\"fopen\");\n\t\tSET_PERMS_STREAM(fp, 0, 0, S_IRUSR | S_IWRITE | S_IRGRP | S_IROTH);\n\t\tfclose(fp);\n\t\tfs_logger(\"touch /etc/ld.so.preload\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_private_etc_list",
          "args": [],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "fs_private_etc_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_etc.c",
          "lines": "124-186",
          "snippet": "void fs_private_etc_list(void) {\n\tchar *private_list = cfg.etc_private_keep;\n\tassert(private_list);\n\t\n\tstruct stat s;\n\tif (stat(\"/etc\", &s) == -1) {\n\t\tfprintf(stderr, \"Error: cannot find user /etc directory\\n\");\n\t\texit(1);\n\t}\n\n\t// create /run/firejail/mnt/etc directory\n\tfs_build_mnt_dir();\n\tif (mkdir(RUN_ETC_DIR, 0755) == -1)\n\t\terrExit(\"mkdir\");\n\tif (chmod(RUN_ETC_DIR, 0755) == -1)\n\t\terrExit(\"chmod\");\n\tASSERT_PERMS(RUN_ETC_DIR, 0, 0, 0755);\n\tfs_logger(\"tmpfs /etc\");\n\t\n\tfs_logger_print();\t// save the current log\n\n\n\t// copy the list of files in the new etc directory\n\t// using a new child process with root privileges\n\tif (*private_list != '\\0') {\n\t\tpid_t child = fork();\n\t\tif (child < 0)\n\t\t\terrExit(\"fork\");\n\t\tif (child == 0) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Copying files in the new etc directory:\\n\");\n\t\n\t\t\t// elevate privileges - files in the new /etc directory belong to root\n\t\t\tif (setreuid(0, 0) < 0)\n\t\t\t\terrExit(\"setreuid\");\n\t\t\tif (setregid(0, 0) < 0)\n\t\t\t\terrExit(\"setregid\");\n\t\t\t\n\t\t\t// copy the list of files in the new home directory\n\t\t\tchar *dlist = strdup(private_list);\n\t\t\tif (!dlist)\n\t\t\t\terrExit(\"strdup\");\n\t\t\n\t\n\t\t\tchar *ptr = strtok(dlist, \",\");\n\t\t\tduplicate(ptr);\n\t\t\n\t\t\twhile ((ptr = strtok(NULL, \",\")) != NULL)\n\t\t\t\tduplicate(ptr);\n\t\t\tfree(dlist);\t\n\t\t\tfs_logger_print();\n\t\t\t_exit(0);\n\t\t}\n\t\t// wait for the child to finish\n\t\twaitpid(child, NULL, 0);\n\t}\n\t\n\tif (arg_debug)\n\t\tprintf(\"Mount-bind %s on top of /etc\\n\", RUN_ETC_DIR);\n\tif (mount(RUN_ETC_DIR, \"/etc\", NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\tfs_logger(\"mount /etc\");\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_private_etc_list(void) {\n\tchar *private_list = cfg.etc_private_keep;\n\tassert(private_list);\n\t\n\tstruct stat s;\n\tif (stat(\"/etc\", &s) == -1) {\n\t\tfprintf(stderr, \"Error: cannot find user /etc directory\\n\");\n\t\texit(1);\n\t}\n\n\t// create /run/firejail/mnt/etc directory\n\tfs_build_mnt_dir();\n\tif (mkdir(RUN_ETC_DIR, 0755) == -1)\n\t\terrExit(\"mkdir\");\n\tif (chmod(RUN_ETC_DIR, 0755) == -1)\n\t\terrExit(\"chmod\");\n\tASSERT_PERMS(RUN_ETC_DIR, 0, 0, 0755);\n\tfs_logger(\"tmpfs /etc\");\n\t\n\tfs_logger_print();\t// save the current log\n\n\n\t// copy the list of files in the new etc directory\n\t// using a new child process with root privileges\n\tif (*private_list != '\\0') {\n\t\tpid_t child = fork();\n\t\tif (child < 0)\n\t\t\terrExit(\"fork\");\n\t\tif (child == 0) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Copying files in the new etc directory:\\n\");\n\t\n\t\t\t// elevate privileges - files in the new /etc directory belong to root\n\t\t\tif (setreuid(0, 0) < 0)\n\t\t\t\terrExit(\"setreuid\");\n\t\t\tif (setregid(0, 0) < 0)\n\t\t\t\terrExit(\"setregid\");\n\t\t\t\n\t\t\t// copy the list of files in the new home directory\n\t\t\tchar *dlist = strdup(private_list);\n\t\t\tif (!dlist)\n\t\t\t\terrExit(\"strdup\");\n\t\t\n\t\n\t\t\tchar *ptr = strtok(dlist, \",\");\n\t\t\tduplicate(ptr);\n\t\t\n\t\t\twhile ((ptr = strtok(NULL, \",\")) != NULL)\n\t\t\t\tduplicate(ptr);\n\t\t\tfree(dlist);\t\n\t\t\tfs_logger_print();\n\t\t\t_exit(0);\n\t\t}\n\t\t// wait for the child to finish\n\t\twaitpid(child, NULL, 0);\n\t}\n\t\n\tif (arg_debug)\n\t\tprintf(\"Mount-bind %s on top of /etc\\n\", RUN_ETC_DIR);\n\tif (mount(RUN_ETC_DIR, \"/etc\", NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\tfs_logger(\"mount /etc\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: private-etc feature is disabled in overlay\\n\""
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: private-etc feature is disabled in chroot\\n\""
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_private_dev",
          "args": [],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "fs_private_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_dev.c",
          "lines": "126-244",
          "snippet": "void fs_private_dev(void){\n\t// install a new /dev directory\n\tif (arg_debug)\n\t\tprintf(\"Mounting tmpfs on /dev\\n\");\n\n\t// create DRI_DIR\n\tfs_build_mnt_dir();\n\t\n\t// keep a copy of dev directory\n\tif (mkdir(RUN_DEV_DIR, 0755) == -1)\n\t\terrExit(\"mkdir\");\n\tif (chmod(RUN_DEV_DIR, 0755) == -1)\n\t\terrExit(\"chmod\");\n\tASSERT_PERMS(RUN_DEV_DIR, 0, 0, 0755);\n\tif (mount(\"/dev\", RUN_DEV_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /dev/dri\");\n\n\t// create DEVLOG_FILE\n\tint have_devlog = 0;\n\tstruct stat s;\n\tif (stat(\"/dev/log\", &s) == 0) {\n\t\thave_devlog = 1;\n\t\tFILE *fp = fopen(RUN_DEVLOG_FILE, \"w\");\n\t\tif (!fp)\n\t\t\thave_devlog = 0;\n\t\telse {\n\t\t\tfprintf(fp, \"\\n\");\n\t\t\tfclose(fp);\n\t\t\tif (mount(\"/dev/log\", RUN_DEVLOG_FILE, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mounting /dev/log\");\n\t\t}\n\t}\n\n\t// mount tmpfs on top of /dev\n\tif (mount(\"tmpfs\", \"/dev\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\terrExit(\"mounting /dev\");\n\tfs_logger(\"tmpfs /dev\");\n\t\n\tdeventry_mount();\n\n\t// bring back /dev/log\n\tif (have_devlog) {\n\t\tFILE *fp = fopen(\"/dev/log\", \"w\");\n\t\tif (fp) {\n\t\t\tfprintf(fp, \"\\n\");\n\t\t\tfclose(fp);\n\t\t\tif (mount(RUN_DEVLOG_FILE, \"/dev/log\", NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mounting /dev/log\");\n\t\t\tfs_logger(\"clone /dev/log\");\n\t\t}\n\t}\t\t\n\tif (mount(RUN_RO_DIR, RUN_DEV_DIR, \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\terrExit(\"disable /dev/snd\");\n\n\t\n\t// create /dev/shm\n\tif (arg_debug)\n\t\tprintf(\"Create /dev/shm directory\\n\");\n\tif (mkdir(\"/dev/shm\", 01777) == -1)\n\t\terrExit(\"mkdir\");\n\t// mkdir sets only the file permission bits\n\tif (chmod(\"/dev/shm\", 01777) < 0)\n\t\terrExit(\"chmod\");\n\tASSERT_PERMS(\"/dev/shm\", 0, 0, 01777);\n\tfs_logger(\"mkdir /dev/shm\");\n\n\t// create devices\n\tcreate_char_dev(\"/dev/zero\", 0666, 1, 5); // mknod -m 666 /dev/zero c 1 5\n\tfs_logger(\"mknod /dev/zero\");\n\tcreate_char_dev(\"/dev/null\", 0666, 1, 3); // mknod -m 666 /dev/null c 1 3\n\tfs_logger(\"mknod /dev/null\");\n\tcreate_char_dev(\"/dev/full\", 0666, 1, 7); // mknod -m 666 /dev/full c 1 7\n\tfs_logger(\"mknod /dev/full\");\n\tcreate_char_dev(\"/dev/random\", 0666, 1, 8); // Mknod -m 666 /dev/random c 1 8\n\tfs_logger(\"mknod /dev/random\");\n\tcreate_char_dev(\"/dev/urandom\", 0666, 1, 9); // mknod -m 666 /dev/urandom c 1 9\n\tfs_logger(\"mknod /dev/urandom\");\n\tcreate_char_dev(\"/dev/tty\", 0666,  5, 0); // mknod -m 666 /dev/tty c 5 0\n\tfs_logger(\"mknod /dev/tty\");\n#if 0\n\tcreate_dev(\"/dev/tty0\", \"mknod -m 666 /dev/tty0 c 4 0\");\n\tcreate_dev(\"/dev/console\", \"mknod -m 622 /dev/console c 5 1\");\n#endif\n\n\t// pseudo-terminal\n\tif (mkdir(\"/dev/pts\", 0755) == -1)\n\t\terrExit(\"mkdir\");\n\tif (chmod(\"/dev/pts\", 0755) == -1)\n\t\terrExit(\"chmod\");\n\tASSERT_PERMS(\"/dev/pts\", 0, 0, 0755);\n\tfs_logger(\"mkdir /dev/pts\");\n\tcreate_char_dev(\"/dev/pts/ptmx\", 0666, 5, 2); //\"mknod -m 666 /dev/pts/ptmx c 5 2\");\n\tfs_logger(\"mknod /dev/pts/ptmx\");\n\tcreate_link(\"/dev/pts/ptmx\", \"/dev/ptmx\");\n\n// code before github issue #351\n\t// mount -vt devpts -o newinstance -o ptmxmode=0666 devpts //dev/pts\n//\tif (mount(\"devpts\", \"/dev/pts\", \"devpts\", MS_MGC_VAL,  \"newinstance,ptmxmode=0666\") < 0)\n//\t\terrExit(\"mounting /dev/pts\");\n\n\n\t// mount /dev/pts\n\tgid_t ttygid = get_group_id(\"tty\");\n\tchar *data;\n\tif (asprintf(&data, \"newinstance,gid=%d,mode=620,ptmxmode=0666\", (int) ttygid) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(\"devpts\", \"/dev/pts\", \"devpts\", MS_MGC_VAL,  data) < 0)\n\t\terrExit(\"mounting /dev/pts\");\n\tfree(data);\n\tfs_logger(\"clone /dev/pts\");\n\n#if 0\n\t// stdin, stdout, stderr\n\tcreate_link(\"/proc/self/fd\", \"/dev/fd\");\n\tcreate_link(\"/proc/self/fd/0\", \"/dev/stdin\");\n\tcreate_link(\"/proc/self/fd/1\", \"/dev/stdout\");\n\tcreate_link(\"/proc/self/fd/2\", \"/dev/stderr\");\n#endif\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <pwd.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <pwd.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_private_dev(void){\n\t// install a new /dev directory\n\tif (arg_debug)\n\t\tprintf(\"Mounting tmpfs on /dev\\n\");\n\n\t// create DRI_DIR\n\tfs_build_mnt_dir();\n\t\n\t// keep a copy of dev directory\n\tif (mkdir(RUN_DEV_DIR, 0755) == -1)\n\t\terrExit(\"mkdir\");\n\tif (chmod(RUN_DEV_DIR, 0755) == -1)\n\t\terrExit(\"chmod\");\n\tASSERT_PERMS(RUN_DEV_DIR, 0, 0, 0755);\n\tif (mount(\"/dev\", RUN_DEV_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /dev/dri\");\n\n\t// create DEVLOG_FILE\n\tint have_devlog = 0;\n\tstruct stat s;\n\tif (stat(\"/dev/log\", &s) == 0) {\n\t\thave_devlog = 1;\n\t\tFILE *fp = fopen(RUN_DEVLOG_FILE, \"w\");\n\t\tif (!fp)\n\t\t\thave_devlog = 0;\n\t\telse {\n\t\t\tfprintf(fp, \"\\n\");\n\t\t\tfclose(fp);\n\t\t\tif (mount(\"/dev/log\", RUN_DEVLOG_FILE, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mounting /dev/log\");\n\t\t}\n\t}\n\n\t// mount tmpfs on top of /dev\n\tif (mount(\"tmpfs\", \"/dev\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\terrExit(\"mounting /dev\");\n\tfs_logger(\"tmpfs /dev\");\n\t\n\tdeventry_mount();\n\n\t// bring back /dev/log\n\tif (have_devlog) {\n\t\tFILE *fp = fopen(\"/dev/log\", \"w\");\n\t\tif (fp) {\n\t\t\tfprintf(fp, \"\\n\");\n\t\t\tfclose(fp);\n\t\t\tif (mount(RUN_DEVLOG_FILE, \"/dev/log\", NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mounting /dev/log\");\n\t\t\tfs_logger(\"clone /dev/log\");\n\t\t}\n\t}\t\t\n\tif (mount(RUN_RO_DIR, RUN_DEV_DIR, \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\terrExit(\"disable /dev/snd\");\n\n\t\n\t// create /dev/shm\n\tif (arg_debug)\n\t\tprintf(\"Create /dev/shm directory\\n\");\n\tif (mkdir(\"/dev/shm\", 01777) == -1)\n\t\terrExit(\"mkdir\");\n\t// mkdir sets only the file permission bits\n\tif (chmod(\"/dev/shm\", 01777) < 0)\n\t\terrExit(\"chmod\");\n\tASSERT_PERMS(\"/dev/shm\", 0, 0, 01777);\n\tfs_logger(\"mkdir /dev/shm\");\n\n\t// create devices\n\tcreate_char_dev(\"/dev/zero\", 0666, 1, 5); // mknod -m 666 /dev/zero c 1 5\n\tfs_logger(\"mknod /dev/zero\");\n\tcreate_char_dev(\"/dev/null\", 0666, 1, 3); // mknod -m 666 /dev/null c 1 3\n\tfs_logger(\"mknod /dev/null\");\n\tcreate_char_dev(\"/dev/full\", 0666, 1, 7); // mknod -m 666 /dev/full c 1 7\n\tfs_logger(\"mknod /dev/full\");\n\tcreate_char_dev(\"/dev/random\", 0666, 1, 8); // Mknod -m 666 /dev/random c 1 8\n\tfs_logger(\"mknod /dev/random\");\n\tcreate_char_dev(\"/dev/urandom\", 0666, 1, 9); // mknod -m 666 /dev/urandom c 1 9\n\tfs_logger(\"mknod /dev/urandom\");\n\tcreate_char_dev(\"/dev/tty\", 0666,  5, 0); // mknod -m 666 /dev/tty c 5 0\n\tfs_logger(\"mknod /dev/tty\");\n#if 0\n\tcreate_dev(\"/dev/tty0\", \"mknod -m 666 /dev/tty0 c 4 0\");\n\tcreate_dev(\"/dev/console\", \"mknod -m 622 /dev/console c 5 1\");\n#endif\n\n\t// pseudo-terminal\n\tif (mkdir(\"/dev/pts\", 0755) == -1)\n\t\terrExit(\"mkdir\");\n\tif (chmod(\"/dev/pts\", 0755) == -1)\n\t\terrExit(\"chmod\");\n\tASSERT_PERMS(\"/dev/pts\", 0, 0, 0755);\n\tfs_logger(\"mkdir /dev/pts\");\n\tcreate_char_dev(\"/dev/pts/ptmx\", 0666, 5, 2); //\"mknod -m 666 /dev/pts/ptmx c 5 2\");\n\tfs_logger(\"mknod /dev/pts/ptmx\");\n\tcreate_link(\"/dev/pts/ptmx\", \"/dev/ptmx\");\n\n// code before github issue #351\n\t// mount -vt devpts -o newinstance -o ptmxmode=0666 devpts //dev/pts\n//\tif (mount(\"devpts\", \"/dev/pts\", \"devpts\", MS_MGC_VAL,  \"newinstance,ptmxmode=0666\") < 0)\n//\t\terrExit(\"mounting /dev/pts\");\n\n\n\t// mount /dev/pts\n\tgid_t ttygid = get_group_id(\"tty\");\n\tchar *data;\n\tif (asprintf(&data, \"newinstance,gid=%d,mode=620,ptmxmode=0666\", (int) ttygid) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(\"devpts\", \"/dev/pts\", \"devpts\", MS_MGC_VAL,  data) < 0)\n\t\terrExit(\"mounting /dev/pts\");\n\tfree(data);\n\tfs_logger(\"clone /dev/pts\");\n\n#if 0\n\t// stdin, stdout, stderr\n\tcreate_link(\"/proc/self/fd\", \"/dev/fd\");\n\tcreate_link(\"/proc/self/fd/0\", \"/dev/stdin\");\n\tcreate_link(\"/proc/self/fd/1\", \"/dev/stdout\");\n\tcreate_link(\"/proc/self/fd/2\", \"/dev/stderr\");\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: private-dev feature is disabled in overlay\\n\""
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: private-dev feature is disabled in chroot\\n\""
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_private_home_list",
          "args": [],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "fs_private_home_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_home.c",
          "lines": "579-677",
          "snippet": "void fs_private_home_list(void) {\n\tchar *homedir = cfg.homedir;\n\tchar *private_list = cfg.home_private_keep;\n\tassert(homedir);\n\tassert(private_list);\n\n\tint xflag = store_xauthority();\n\tint aflag = store_asoundrc();\n\n\tuid_t u = firejail_uid;\n\tgid_t g = firejail_gid;\n\tstruct stat s;\n\tif (stat(homedir, &s) == -1) {\n\t\tfprintf(stderr, \"Error: cannot find user home directory\\n\");\n\t\texit(1);\n\t}\n\n\t// create /run/firejail/mnt/home directory\n\tfs_build_mnt_dir();\n\tint rv = mkdir(RUN_HOME_DIR, 0755);\n\tif (rv == -1)\n\t\terrExit(\"mkdir\");\n\tif (chown(RUN_HOME_DIR, u, g) < 0)\n\t\terrExit(\"chown\");\n\tif (chmod(RUN_HOME_DIR, 0755) < 0)\n\t\terrExit(\"chmod\");\n\tASSERT_PERMS(RUN_HOME_DIR, u, g, 0755);\n\n\tfs_logger_print();\t// save the current log\n\n\t// copy the list of files in the new home directory\n\t// using a new child process without root privileges\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Copying files in the new home:\\n\");\n\n\t\t// drop privileges\n\t\tif (setgroups(0, NULL) < 0)\n\t\t\terrExit(\"setgroups\");\n\t\tif (setgid(getgid()) < 0)\n\t\t\terrExit(\"setgid/getgid\");\n\t\tif (setuid(getuid()) < 0)\n\t\t\terrExit(\"setuid/getuid\");\n\n\t\t// copy the list of files in the new home directory\n\t\tchar *dlist = strdup(cfg.home_private_keep);\n\t\tif (!dlist)\n\t\t\terrExit(\"strdup\");\n\t\t\n\t\tchar *ptr = strtok(dlist, \",\");\n\t\tduplicate(ptr);\n\t\twhile ((ptr = strtok(NULL, \",\")) != NULL)\n\t\t\tduplicate(ptr);\n\n\t\tif (!arg_quiet) {\n\t\t\tif (size_limit_reached)\n\t\t\t\tfprintf(stderr, \"Warning: private-home copy limit of %u MB reached, not all the files were copied\\n\", \n\t\t\t\t\tPRIVATE_COPY_LIMIT / (1024 *1024));\n\t\t\telse\n\t\t\t\tprintf(\"Private home: %u files, total size %u bytes\\n\", file_cnt, size_cnt);\n\t\t}\n\n\t\tfs_logger_print();\t// save the current log\n\t\tfree(dlist);\n\t\t_exit(0);\n\t}\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n\n\tif (arg_debug)\n\t\tprintf(\"Mount-bind %s on top of %s\\n\", RUN_HOME_DIR, homedir);\n\n\tif (mount(RUN_HOME_DIR, homedir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\n\tif (u != 0) {\n\t\t// mask /root\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting a new /root directory\\n\");\n\t\tif (mount(\"tmpfs\", \"/root\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=700,gid=0\") < 0)\n\t\t\terrExit(\"mounting home directory\");\n\t}\n\telse {\n\t\t// mask /home\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting a new /home directory\\n\");\n\t\tif (mount(\"tmpfs\", \"/home\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting home directory\");\n\t}\n\n\tskel(homedir, u, g);\n\tif (xflag)\n\t\tcopy_xauthority();\n\tif (aflag)\n\t\tcopy_asoundrc();\n}",
          "includes": [
            "#include <ftw.h>",
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define PRIVATE_COPY_LIMIT (500 * 1024 *1024)"
          ],
          "globals_used": [
            "static int size_limit_reached = 0;",
            "static unsigned file_cnt = 0;",
            "static unsigned size_cnt = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ftw.h>\n#include <grp.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\n#define PRIVATE_COPY_LIMIT (500 * 1024 *1024)\n\nstatic int size_limit_reached = 0;\nstatic unsigned file_cnt = 0;\nstatic unsigned size_cnt = 0;\n\nvoid fs_private_home_list(void) {\n\tchar *homedir = cfg.homedir;\n\tchar *private_list = cfg.home_private_keep;\n\tassert(homedir);\n\tassert(private_list);\n\n\tint xflag = store_xauthority();\n\tint aflag = store_asoundrc();\n\n\tuid_t u = firejail_uid;\n\tgid_t g = firejail_gid;\n\tstruct stat s;\n\tif (stat(homedir, &s) == -1) {\n\t\tfprintf(stderr, \"Error: cannot find user home directory\\n\");\n\t\texit(1);\n\t}\n\n\t// create /run/firejail/mnt/home directory\n\tfs_build_mnt_dir();\n\tint rv = mkdir(RUN_HOME_DIR, 0755);\n\tif (rv == -1)\n\t\terrExit(\"mkdir\");\n\tif (chown(RUN_HOME_DIR, u, g) < 0)\n\t\terrExit(\"chown\");\n\tif (chmod(RUN_HOME_DIR, 0755) < 0)\n\t\terrExit(\"chmod\");\n\tASSERT_PERMS(RUN_HOME_DIR, u, g, 0755);\n\n\tfs_logger_print();\t// save the current log\n\n\t// copy the list of files in the new home directory\n\t// using a new child process without root privileges\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Copying files in the new home:\\n\");\n\n\t\t// drop privileges\n\t\tif (setgroups(0, NULL) < 0)\n\t\t\terrExit(\"setgroups\");\n\t\tif (setgid(getgid()) < 0)\n\t\t\terrExit(\"setgid/getgid\");\n\t\tif (setuid(getuid()) < 0)\n\t\t\terrExit(\"setuid/getuid\");\n\n\t\t// copy the list of files in the new home directory\n\t\tchar *dlist = strdup(cfg.home_private_keep);\n\t\tif (!dlist)\n\t\t\terrExit(\"strdup\");\n\t\t\n\t\tchar *ptr = strtok(dlist, \",\");\n\t\tduplicate(ptr);\n\t\twhile ((ptr = strtok(NULL, \",\")) != NULL)\n\t\t\tduplicate(ptr);\n\n\t\tif (!arg_quiet) {\n\t\t\tif (size_limit_reached)\n\t\t\t\tfprintf(stderr, \"Warning: private-home copy limit of %u MB reached, not all the files were copied\\n\", \n\t\t\t\t\tPRIVATE_COPY_LIMIT / (1024 *1024));\n\t\t\telse\n\t\t\t\tprintf(\"Private home: %u files, total size %u bytes\\n\", file_cnt, size_cnt);\n\t\t}\n\n\t\tfs_logger_print();\t// save the current log\n\t\tfree(dlist);\n\t\t_exit(0);\n\t}\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n\n\tif (arg_debug)\n\t\tprintf(\"Mount-bind %s on top of %s\\n\", RUN_HOME_DIR, homedir);\n\n\tif (mount(RUN_HOME_DIR, homedir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\n\tif (u != 0) {\n\t\t// mask /root\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting a new /root directory\\n\");\n\t\tif (mount(\"tmpfs\", \"/root\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=700,gid=0\") < 0)\n\t\t\terrExit(\"mounting home directory\");\n\t}\n\telse {\n\t\t// mask /home\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting a new /home directory\\n\");\n\t\tif (mount(\"tmpfs\", \"/home\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting home directory\");\n\t}\n\n\tskel(homedir, u, g);\n\tif (xflag)\n\t\tcopy_xauthority();\n\tif (aflag)\n\t\tcopy_asoundrc();\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: private-home= feature is disabled in overlay\\n\""
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: private-home= feature is disabled in chroot\\n\""
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_private_homedir",
          "args": [],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "fs_private_homedir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_home.c",
          "lines": "211-265",
          "snippet": "void fs_private_homedir(void) {\n\tchar *homedir = cfg.homedir;\n\tchar *private_homedir = cfg.home_private;\n\tassert(homedir);\n\tassert(private_homedir);\n\t\n\tint xflag = store_xauthority();\n\tint aflag = store_asoundrc();\n\t\n\tuid_t u = getuid();\n\tgid_t g = getgid();\n\tstruct stat s;\n\tif (stat(homedir, &s) == -1) {\n\t\tfprintf(stderr, \"Error: cannot find user home directory\\n\");\n\t\texit(1);\n\t}\n\t\n\n\t// mount bind private_homedir on top of homedir\n\tif (arg_debug)\n\t\tprintf(\"Mount-bind %s on top of %s\\n\", private_homedir, homedir);\n\tif (mount(private_homedir, homedir, NULL, MS_NOSUID | MS_NODEV | MS_BIND | MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\tfs_logger3(\"mount-bind\", private_homedir, cfg.homedir);\n\tfs_logger2(\"whitelist\", cfg.homedir);\n// preserve mode and ownership\n//\tif (chown(homedir, s.st_uid, s.st_gid) == -1)\n//\t\terrExit(\"mount-bind chown\");\n//\tif (chmod(homedir, s.st_mode) == -1)\n//\t\terrExit(\"mount-bind chmod\");\n\n\tif (u != 0) {\n\t\t// mask /root\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting a new /root directory\\n\");\n\t\tif (mount(\"tmpfs\", \"/root\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_STRICTATIME | MS_REC,  \"mode=700,gid=0\") < 0)\n\t\t\terrExit(\"mounting home directory\");\n\t\tfs_logger(\"tmpfs /root\");\n\t}\n\telse {\n\t\t// mask /home\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting a new /home directory\\n\");\n\t\tif (mount(\"tmpfs\", \"/home\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting home directory\");\n\t\tfs_logger(\"tmpfs /home\");\n\t}\n\t\n\n\tskel(homedir, u, g);\n\tif (xflag)\n\t\tcopy_xauthority();\n\tif (aflag)\n\t\tcopy_asoundrc();\n}",
          "includes": [
            "#include <ftw.h>",
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ftw.h>\n#include <grp.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_private_homedir(void) {\n\tchar *homedir = cfg.homedir;\n\tchar *private_homedir = cfg.home_private;\n\tassert(homedir);\n\tassert(private_homedir);\n\t\n\tint xflag = store_xauthority();\n\tint aflag = store_asoundrc();\n\t\n\tuid_t u = getuid();\n\tgid_t g = getgid();\n\tstruct stat s;\n\tif (stat(homedir, &s) == -1) {\n\t\tfprintf(stderr, \"Error: cannot find user home directory\\n\");\n\t\texit(1);\n\t}\n\t\n\n\t// mount bind private_homedir on top of homedir\n\tif (arg_debug)\n\t\tprintf(\"Mount-bind %s on top of %s\\n\", private_homedir, homedir);\n\tif (mount(private_homedir, homedir, NULL, MS_NOSUID | MS_NODEV | MS_BIND | MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\tfs_logger3(\"mount-bind\", private_homedir, cfg.homedir);\n\tfs_logger2(\"whitelist\", cfg.homedir);\n// preserve mode and ownership\n//\tif (chown(homedir, s.st_uid, s.st_gid) == -1)\n//\t\terrExit(\"mount-bind chown\");\n//\tif (chmod(homedir, s.st_mode) == -1)\n//\t\terrExit(\"mount-bind chmod\");\n\n\tif (u != 0) {\n\t\t// mask /root\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting a new /root directory\\n\");\n\t\tif (mount(\"tmpfs\", \"/root\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_STRICTATIME | MS_REC,  \"mode=700,gid=0\") < 0)\n\t\t\terrExit(\"mounting home directory\");\n\t\tfs_logger(\"tmpfs /root\");\n\t}\n\telse {\n\t\t// mask /home\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting a new /home directory\\n\");\n\t\tif (mount(\"tmpfs\", \"/home\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting home directory\");\n\t\tfs_logger(\"tmpfs /home\");\n\t}\n\t\n\n\tskel(homedir, u, g);\n\tif (xflag)\n\t\tcopy_xauthority();\n\tif (aflag)\n\t\tcopy_asoundrc();\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: private=directory feature is disabled in overlay\\n\""
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: private=directory feature is disabled in chroot\\n\""
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_hostname",
          "args": [
            "cfg.hostname"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "fs_hostname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_hostname.c",
          "lines": "28-96",
          "snippet": "void fs_hostname(const char *hostname) {\n\tstruct stat s;\n\tfs_build_mnt_dir();\n\t\n\t// create a new /etc/hostname\n\tif (stat(\"/etc/hostname\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Creating a new /etc/hostname file\\n\");\n\n\t\tFILE *fp = fopen(RUN_HOSTNAME_FILE, \"w\");\n\t\tif (!fp) {\n\t\t\tfprintf(stderr, \"Error: cannot create %s\\n\", RUN_HOSTNAME_FILE);\n\t\t\texit(1);\n\t\t}\n\t\tfprintf(fp, \"%s\\n\", hostname);\n\t\t// mode and owner\n\t\tSET_PERMS_STREAM(fp, 0, 0, S_IRUSR | S_IWRITE | S_IRGRP | S_IROTH);\n\t\tfclose(fp);\n\n\t\t// bind-mount the file on top of /etc/hostname\n\t\tif (mount(RUN_HOSTNAME_FILE, \"/etc/hostname\", NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mount bind /etc/hostname\");\n\t\tfs_logger(\"create /etc/hostname\");\n\t}\n\t\n\t// create a new /etc/hosts\n\tif (stat(\"/etc/hosts\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Creating a new /etc/hosts file\\n\");\n\t\t// copy /etc/host into our new file, and modify it on the fly\n\t\t/* coverity[toctou] */\n\t\tFILE *fp1 = fopen(\"/etc/hosts\", \"r\");\n\t\tif (!fp1) {\n\t\t\tfprintf(stderr, \"Error: cannot open /etc/hosts\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tFILE *fp2 = fopen(RUN_HOSTS_FILE, \"w\");\n\t\tif (!fp2) {\n\t\t\tfprintf(stderr, \"Error: cannot create %s\\n\", RUN_HOSTS_FILE);\n\t\t\texit(1);\n\t\t}\n\t\t\n\t\tchar buf[4096];\n\t\tint done = 0;\n\t\twhile (fgets(buf, sizeof(buf), fp1)) {\n\t\t\t// remove '\\n'\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\t\t\n\t\t\t// copy line\n\t\t\tif (strstr(buf, \"127.0.0.1\") && done == 0) {\n\t\t\t\tdone = 1;\n\t\t\t\tfprintf(fp2, \"%s %s\\n\", buf, hostname);\n\t\t\t}\n\t\t\telse\n\t\t\t\tfprintf(fp2, \"%s\\n\", buf);\n\t\t}\n\t\tfclose(fp1);\n\t\t// mode and owner\n\t\tSET_PERMS_STREAM(fp2, 0, 0, S_IRUSR | S_IWRITE | S_IRGRP | S_IROTH);\n\t\tfclose(fp2);\n\t\t\n\t\t// bind-mount the file on top of /etc/hostname\n\t\tif (mount(RUN_HOSTS_FILE, \"/etc/hosts\", NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mount bind /etc/hosts\");\n\t\tfs_logger(\"create /etc/hosts\");\n\t}\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_hostname(const char *hostname) {\n\tstruct stat s;\n\tfs_build_mnt_dir();\n\t\n\t// create a new /etc/hostname\n\tif (stat(\"/etc/hostname\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Creating a new /etc/hostname file\\n\");\n\n\t\tFILE *fp = fopen(RUN_HOSTNAME_FILE, \"w\");\n\t\tif (!fp) {\n\t\t\tfprintf(stderr, \"Error: cannot create %s\\n\", RUN_HOSTNAME_FILE);\n\t\t\texit(1);\n\t\t}\n\t\tfprintf(fp, \"%s\\n\", hostname);\n\t\t// mode and owner\n\t\tSET_PERMS_STREAM(fp, 0, 0, S_IRUSR | S_IWRITE | S_IRGRP | S_IROTH);\n\t\tfclose(fp);\n\n\t\t// bind-mount the file on top of /etc/hostname\n\t\tif (mount(RUN_HOSTNAME_FILE, \"/etc/hostname\", NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mount bind /etc/hostname\");\n\t\tfs_logger(\"create /etc/hostname\");\n\t}\n\t\n\t// create a new /etc/hosts\n\tif (stat(\"/etc/hosts\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Creating a new /etc/hosts file\\n\");\n\t\t// copy /etc/host into our new file, and modify it on the fly\n\t\t/* coverity[toctou] */\n\t\tFILE *fp1 = fopen(\"/etc/hosts\", \"r\");\n\t\tif (!fp1) {\n\t\t\tfprintf(stderr, \"Error: cannot open /etc/hosts\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tFILE *fp2 = fopen(RUN_HOSTS_FILE, \"w\");\n\t\tif (!fp2) {\n\t\t\tfprintf(stderr, \"Error: cannot create %s\\n\", RUN_HOSTS_FILE);\n\t\t\texit(1);\n\t\t}\n\t\t\n\t\tchar buf[4096];\n\t\tint done = 0;\n\t\twhile (fgets(buf, sizeof(buf), fp1)) {\n\t\t\t// remove '\\n'\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\t\t\n\t\t\t// copy line\n\t\t\tif (strstr(buf, \"127.0.0.1\") && done == 0) {\n\t\t\t\tdone = 1;\n\t\t\t\tfprintf(fp2, \"%s %s\\n\", buf, hostname);\n\t\t\t}\n\t\t\telse\n\t\t\t\tfprintf(fp2, \"%s\\n\", buf);\n\t\t}\n\t\tfclose(fp1);\n\t\t// mode and owner\n\t\tSET_PERMS_STREAM(fp2, 0, 0, S_IRUSR | S_IWRITE | S_IRGRP | S_IROTH);\n\t\tfclose(fp2);\n\t\t\n\t\t// bind-mount the file on top of /etc/hostname\n\t\tif (mount(RUN_HOSTS_FILE, \"/etc/hosts\", NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mount bind /etc/hosts\");\n\t\tfs_logger(\"create /etc/hosts\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_basic_fs",
          "args": [],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "fs_basic_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
          "lines": "744-788",
          "snippet": "void fs_basic_fs(void) {\n\tuid_t uid = getuid();\n\t\n\tif (arg_debug)\n\t\tprintf(\"Mounting read-only /bin, /sbin, /lib, /lib32, /lib64, /usr\");\n\tif (!arg_writable_etc) {\n\t\tfs_rdonly(\"/etc\");\n\t\tif (uid)\n\t\t\tfs_noexec(\"/etc\");\n\t\tif (arg_debug) printf(\", /etc\");\n\t}\n\tif (!arg_writable_var) {\n\t\tfs_rdonly(\"/var\");\n\t\tif (uid)\n\t\t\tfs_noexec(\"/var\");\n\t\tif (arg_debug) printf(\", /var\");\n\t}\n\tif (arg_debug) printf(\"\\n\");\n\tfs_rdonly(\"/bin\");\n\tfs_rdonly(\"/sbin\");\n\tfs_rdonly(\"/lib\");\n\tfs_rdonly(\"/lib64\");\n\tfs_rdonly(\"/lib32\");\n\tfs_rdonly(\"/libx32\");\n\tfs_rdonly(\"/usr\");\n\n\t// update /var directory in order to support multiple sandboxes running on the same root directory\n\tif (!arg_private_dev)\n\t\tfs_dev_shm();\n\tfs_var_lock();\n\tfs_var_tmp();\n\tfs_var_log();\n\tfs_var_lib();\n\tfs_var_cache();\n\tfs_var_utmp();\n\n\t// don't leak user information\n\trestrict_users();\n\t\n\t// when starting as root, firejail config is not disabled;\n\t// this mode could be used to install and test new software by chaining\n\t// firejail sandboxes (firejail --force)\n\tif (uid)\n\t\tdisable_config();\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_basic_fs(void) {\n\tuid_t uid = getuid();\n\t\n\tif (arg_debug)\n\t\tprintf(\"Mounting read-only /bin, /sbin, /lib, /lib32, /lib64, /usr\");\n\tif (!arg_writable_etc) {\n\t\tfs_rdonly(\"/etc\");\n\t\tif (uid)\n\t\t\tfs_noexec(\"/etc\");\n\t\tif (arg_debug) printf(\", /etc\");\n\t}\n\tif (!arg_writable_var) {\n\t\tfs_rdonly(\"/var\");\n\t\tif (uid)\n\t\t\tfs_noexec(\"/var\");\n\t\tif (arg_debug) printf(\", /var\");\n\t}\n\tif (arg_debug) printf(\"\\n\");\n\tfs_rdonly(\"/bin\");\n\tfs_rdonly(\"/sbin\");\n\tfs_rdonly(\"/lib\");\n\tfs_rdonly(\"/lib64\");\n\tfs_rdonly(\"/lib32\");\n\tfs_rdonly(\"/libx32\");\n\tfs_rdonly(\"/usr\");\n\n\t// update /var directory in order to support multiple sandboxes running on the same root directory\n\tif (!arg_private_dev)\n\t\tfs_dev_shm();\n\tfs_var_lock();\n\tfs_var_tmp();\n\tfs_var_log();\n\tfs_var_lib();\n\tfs_var_cache();\n\tfs_var_utmp();\n\n\t// don't leak user information\n\trestrict_users();\n\t\n\t// when starting as root, firejail config is not disabled;\n\t// this mode could be used to install and test new software by chaining\n\t// firejail sandboxes (firejail --force)\n\tif (uid)\n\t\tdisable_config();\n}"
        }
      },
      {
        "call_info": {
          "callee": "enforce_filters",
          "args": [],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "enforce_filters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/sandbox.c",
          "lines": "395-418",
          "snippet": "static void enforce_filters(void) {\n\t// force default seccomp inside the chroot, no keep or drop list\n\t// the list build on top of the default drop list is kept intact\n\targ_seccomp = 1;\n\tif (cfg.seccomp_list_drop) {\n\t\tfree(cfg.seccomp_list_drop);\n\t\tcfg.seccomp_list_drop = NULL;\n\t}\n\tif (cfg.seccomp_list_keep) {\n\t\tfree(cfg.seccomp_list_keep);\n\t\tcfg.seccomp_list_keep = NULL;\n\t}\n\t\n\t// disable all capabilities\n\tif (arg_caps_default_filter || arg_caps_list)\n\t\tfprintf(stderr, \"Warning: all capabilities disabled for a regular user in chroot\\n\");\n\targ_caps_drop_all = 1;\n\t\n\t// drop all supplementary groups; /etc/group file inside chroot\n\t// is controlled by a regular usr\n\targ_nogroups = 1;\n\tif (!arg_quiet)\n\t\tprintf(\"Dropping all Linux capabilities and enforcing default seccomp filter\\n\");\n}",
          "includes": [
            "#include <sys/apparmor.h>",
            "#include <sys/prctl.h>",
            "#include <sched.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/prctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/apparmor.h>\n#include <sys/prctl.h>\n#include <sched.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/prctl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void enforce_filters(void) {\n\t// force default seccomp inside the chroot, no keep or drop list\n\t// the list build on top of the default drop list is kept intact\n\targ_seccomp = 1;\n\tif (cfg.seccomp_list_drop) {\n\t\tfree(cfg.seccomp_list_drop);\n\t\tcfg.seccomp_list_drop = NULL;\n\t}\n\tif (cfg.seccomp_list_keep) {\n\t\tfree(cfg.seccomp_list_keep);\n\t\tcfg.seccomp_list_keep = NULL;\n\t}\n\t\n\t// disable all capabilities\n\tif (arg_caps_default_filter || arg_caps_list)\n\t\tfprintf(stderr, \"Warning: all capabilities disabled for a regular user in chroot\\n\");\n\targ_caps_drop_all = 1;\n\t\n\t// drop all supplementary groups; /etc/group file inside chroot\n\t// is controlled by a regular usr\n\targ_nogroups = 1;\n\tif (!arg_quiet)\n\t\tprintf(\"Dropping all Linux capabilities and enforcing default seccomp filter\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_overlayfs",
          "args": [],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "fs_overlayfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
          "lines": "862-1100",
          "snippet": "void fs_overlayfs(void) {\n\t// check kernel version\n\tstruct utsname u;\n\tint rv = uname(&u);\n\tif (rv != 0)\n\t\terrExit(\"uname\");\n\tint major;\n\tint minor;\n\tif (2 != sscanf(u.release, \"%d.%d\", &major, &minor)) {\n\t\tfprintf(stderr, \"Error: cannot extract Linux kernel version: %s\\n\", u.version);\n\t\texit(1);\n\t}\n\t\n\tif (arg_debug)\n\t\tprintf(\"Linux kernel version %d.%d\\n\", major, minor);\n\tint oldkernel = 0;\n\tif (major < 3) {\n\t\tfprintf(stderr, \"Error: minimum kernel version required 3.x\\n\");\n\t\texit(1);\n\t}\n\tif (major == 3 && minor < 18)\n\t\toldkernel = 1;\n\t\n\t// build overlay directories\n\tfs_build_mnt_dir();\n\n\tchar *oroot;\n\tif(asprintf(&oroot, \"%s/oroot\", RUN_MNT_DIR) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mkdir(oroot, 0755))\n\t\terrExit(\"mkdir\");\n\tif (chmod(oroot, 0755) == -1)\n\t\terrExit(\"chmod\");\n\tASSERT_PERMS(oroot, 0, 0, 0755);\n\n\tstruct stat s;\n\tchar *basedir = RUN_MNT_DIR;\n\tif (arg_overlay_keep) {\n\t\t// set base for working and diff directories\n\t\tbasedir = cfg.overlay_dir;\n\n\t\t// does the overlay exist?\n\t\tif (stat(basedir, &s) == 0) {\n\t\t\tif (arg_overlay_reuse == 0) {\n\t\t\t\tfprintf(stderr, \"Error: overlay directory exists, but reuse is not allowed\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (mkdir(basedir, 0755) != 0) {\n\t\t\t\tfprintf(stderr, \"Error: cannot create overlay directory\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t}\n\n\tchar *odiff;\n\tif(asprintf(&odiff, \"%s/odiff\", basedir) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// no need to check arg_overlay_reuse\n\tif (stat(odiff, &s) != 0) {\n\t\tif (mkdir(odiff, 0755))\n\t\t\terrExit(\"mkdir\");\n\t}\n\n\tif (chown(odiff, 0, 0) < 0)\n\t\terrExit(\"chown\");\n\tif (chmod(odiff, 0755) < 0)\n\t\terrExit(\"chmod\");\n\t\n\tchar *owork;\n\tif(asprintf(&owork, \"%s/owork\", basedir) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// no need to check arg_overlay_reuse\n\tif (stat(owork, &s) != 0) {\n\t\tif (mkdir(owork, 0755))\n\t\t\terrExit(\"mkdir\");\n\t}\n\n\tif (chown(owork, 0, 0) < 0)\n\t\terrExit(\"chown\");\n\tif (chmod(owork, 0755) < 0)\n\t\terrExit(\"chmod\");\n\t\n\t// mount overlayfs\n\tif (arg_debug)\n\t\tprintf(\"Mounting OverlayFS\\n\");\n\tchar *option;\n\tif (oldkernel) { // old Ubuntu/OpenSUSE kernels\n\t\tif (arg_overlay_keep) {\n\t\t\tfprintf(stderr, \"Error: option --overlay= not available for kernels older than 3.18\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (asprintf(&option, \"lowerdir=/,upperdir=%s\", odiff) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (mount(\"overlayfs\", oroot, \"overlayfs\", MS_MGC_VAL, option) < 0)\n\t\t\terrExit(\"mounting overlayfs\");\n\t}\n\telse { // kernel 3.18 or newer\n\t\tif (asprintf(&option, \"lowerdir=/,upperdir=%s,workdir=%s\", odiff, owork) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (mount(\"overlay\", oroot, \"overlay\", MS_MGC_VAL, option) < 0)\n\t\t\terrExit(\"mounting overlayfs\");\n\t\t\t\n\t\t//***************************\n\t\t// issue #263 start code\n\t\t// My setup has a separate mount point for /home. When the overlay is mounted,\n\t\t// the overlay does not contain the original /home contents. \n\t\t// I added code to create a second overlay for /home if the overlay home dir is empty and this seems to work\n\t\t// @dshmgh, Jan 2016\n\t\t{\n\t\t\tchar *overlayhome;\n\t\t\tstruct stat s;\n\t\t\tchar *hroot;\n\t\t\tchar *hdiff;\n\t\t\tchar *hwork;\n\t\t\n\t\t\t// dons add debug\n\t\t\tif (arg_debug) printf (\"DEBUG: chroot dirs are oroot %s  odiff %s  owork %s\\n\",oroot,odiff,owork);\n\t\t\n\t\t\t// BEFORE NEXT, WE NEED TO TEST IF /home has any contents or do we need to mount it?\n\t\t\t// must create var for oroot/cfg.homedir\n\t\t\tif (asprintf(&overlayhome,\"%s%s\",oroot,cfg.homedir) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tif (arg_debug) printf (\"DEBUG: overlayhome var holds ##%s##\\n\",overlayhome);\n\t\t\n\t\t\t// if no homedir in overlay -- create another overlay for /home\n\t\t\tif (stat(overlayhome, &s) == -1) {\n\t\t\n\t\t\t\tif(asprintf(&hroot, \"%s/oroot/home\", RUN_MNT_DIR) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\n\t\t\t\tif(asprintf(&hdiff, \"%s/hdiff\", basedir) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\n\t\t\t\t// no need to check arg_overlay_reuse\n\t\t\t\tif (stat(hdiff, &s) != 0) {\n\t\t\t\t\tif (mkdir(hdiff, S_IRWXU | S_IRWXG | S_IRWXO))\n\t\t\t\t\t\terrExit(\"mkdir\");\n\t\t\t\t}\n\n\t\t\t\tif (chown(hdiff, 0, 0) < 0)\n\t\t\t\t\terrExit(\"chown\");\n\t\t\t\tif (chmod(hdiff, S_IRWXU  | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH) < 0)\n\t\t\t\t\terrExit(\"chmod\");\n\t\t\n\t\t\t\tif(asprintf(&hwork, \"%s/hwork\", basedir) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\n\t\t\t\t// no need to check arg_overlay_reuse\n\t\t\t\tif (stat(hwork, &s) != 0) {\n\t\t\t\t\tif (mkdir(hwork, S_IRWXU | S_IRWXG | S_IRWXO))\n\t\t\t\t\t\terrExit(\"mkdir\");\n\t\t\t\t}\n\n\t\t\t\tif (chown(hwork, 0, 0) < 0)\n\t\t\t\t\terrExit(\"chown\");\n\t\t\t\tif (chmod(hwork, S_IRWXU  | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH) < 0)\n\t\t\t\t\terrExit(\"chmod\");\n\t\t\n\t\t\t\t// no homedir in overlay so now mount another overlay for /home\n\t\t\t\tif (asprintf(&option, \"lowerdir=/home,upperdir=%s,workdir=%s\", hdiff, hwork) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\tif (mount(\"overlay\", hroot, \"overlay\", MS_MGC_VAL, option) < 0)\n\t\t\t\t\terrExit(\"mounting overlayfs for mounted home directory\");\n\t\t\n\t\t\t\tprintf(\"OverlayFS for /home configured in %s directory\\n\", basedir);\n\t\t\t} // stat(overlayhome)\n\t\t\tfree(overlayhome);\n\t\t}\n\t\t// issue #263 end code\n\t\t//***************************\n\t}\n\tprintf(\"OverlayFS configured in %s directory\\n\", basedir);\n\t\n\t// mount-bind dev directory\n\tif (arg_debug)\n\t\tprintf(\"Mounting /dev\\n\");\n\tchar *dev;\n\tif (asprintf(&dev, \"%s/dev\", oroot) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(\"/dev\", dev, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /dev\");\n\tfs_logger(\"whitelist /dev\");\n\n\t// mount-bind run directory\n\tif (arg_debug)\n\t\tprintf(\"Mounting /run\\n\");\n\tchar *run;\n\tif (asprintf(&run, \"%s/run\", oroot) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(\"/run\", run, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /run\");\n\tfs_logger(\"whitelist /run\");\n\n\t// mount-bind /tmp/.X11-unix directory\n\tif (stat(\"/tmp/.X11-unix\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting /tmp/.X11-unix\\n\");\n\t\tchar *x11;\n\t\tif (asprintf(&x11, \"%s/tmp/.X11-unix\", oroot) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (mount(\"/tmp/.X11-unix\", x11, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\tfprintf(stderr, \"Warning: cannot mount /tmp/.X11-unix in overlay\\n\");\n\t\telse\n\t\t\tfs_logger(\"whitelist /tmp/.X11-unix\");\n\t\tfree(x11);\n\t}\n\n\t// chroot in the new filesystem\n\tif (chroot(oroot) == -1)\n\t\terrExit(\"chroot\");\n\n\t// update /var directory in order to support multiple sandboxes running on the same root directory\n\tif (!arg_private_dev)\n\t\tfs_dev_shm();\n\tfs_var_lock();\n\tfs_var_tmp();\n\tfs_var_log();\n\tfs_var_lib();\n\tfs_var_cache();\n\tfs_var_utmp();\n\n\t// don't leak user information\n\trestrict_users();\n\n\t// when starting as root, firejail config is not disabled;\n\t// this mode could be used to install and test new software by chaining\n\t// firejail sandboxes (firejail --force)\n\tif (getuid() != 0)\n\t\tdisable_config();\n\n\t// cleanup and exit\n\tfree(option);\n\tfree(oroot);\n\tfree(odiff);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fs_rdwr(const char *dir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void fs_rdwr(const char *dir);\n\nvoid fs_overlayfs(void) {\n\t// check kernel version\n\tstruct utsname u;\n\tint rv = uname(&u);\n\tif (rv != 0)\n\t\terrExit(\"uname\");\n\tint major;\n\tint minor;\n\tif (2 != sscanf(u.release, \"%d.%d\", &major, &minor)) {\n\t\tfprintf(stderr, \"Error: cannot extract Linux kernel version: %s\\n\", u.version);\n\t\texit(1);\n\t}\n\t\n\tif (arg_debug)\n\t\tprintf(\"Linux kernel version %d.%d\\n\", major, minor);\n\tint oldkernel = 0;\n\tif (major < 3) {\n\t\tfprintf(stderr, \"Error: minimum kernel version required 3.x\\n\");\n\t\texit(1);\n\t}\n\tif (major == 3 && minor < 18)\n\t\toldkernel = 1;\n\t\n\t// build overlay directories\n\tfs_build_mnt_dir();\n\n\tchar *oroot;\n\tif(asprintf(&oroot, \"%s/oroot\", RUN_MNT_DIR) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mkdir(oroot, 0755))\n\t\terrExit(\"mkdir\");\n\tif (chmod(oroot, 0755) == -1)\n\t\terrExit(\"chmod\");\n\tASSERT_PERMS(oroot, 0, 0, 0755);\n\n\tstruct stat s;\n\tchar *basedir = RUN_MNT_DIR;\n\tif (arg_overlay_keep) {\n\t\t// set base for working and diff directories\n\t\tbasedir = cfg.overlay_dir;\n\n\t\t// does the overlay exist?\n\t\tif (stat(basedir, &s) == 0) {\n\t\t\tif (arg_overlay_reuse == 0) {\n\t\t\t\tfprintf(stderr, \"Error: overlay directory exists, but reuse is not allowed\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (mkdir(basedir, 0755) != 0) {\n\t\t\t\tfprintf(stderr, \"Error: cannot create overlay directory\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t}\n\n\tchar *odiff;\n\tif(asprintf(&odiff, \"%s/odiff\", basedir) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// no need to check arg_overlay_reuse\n\tif (stat(odiff, &s) != 0) {\n\t\tif (mkdir(odiff, 0755))\n\t\t\terrExit(\"mkdir\");\n\t}\n\n\tif (chown(odiff, 0, 0) < 0)\n\t\terrExit(\"chown\");\n\tif (chmod(odiff, 0755) < 0)\n\t\terrExit(\"chmod\");\n\t\n\tchar *owork;\n\tif(asprintf(&owork, \"%s/owork\", basedir) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// no need to check arg_overlay_reuse\n\tif (stat(owork, &s) != 0) {\n\t\tif (mkdir(owork, 0755))\n\t\t\terrExit(\"mkdir\");\n\t}\n\n\tif (chown(owork, 0, 0) < 0)\n\t\terrExit(\"chown\");\n\tif (chmod(owork, 0755) < 0)\n\t\terrExit(\"chmod\");\n\t\n\t// mount overlayfs\n\tif (arg_debug)\n\t\tprintf(\"Mounting OverlayFS\\n\");\n\tchar *option;\n\tif (oldkernel) { // old Ubuntu/OpenSUSE kernels\n\t\tif (arg_overlay_keep) {\n\t\t\tfprintf(stderr, \"Error: option --overlay= not available for kernels older than 3.18\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (asprintf(&option, \"lowerdir=/,upperdir=%s\", odiff) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (mount(\"overlayfs\", oroot, \"overlayfs\", MS_MGC_VAL, option) < 0)\n\t\t\terrExit(\"mounting overlayfs\");\n\t}\n\telse { // kernel 3.18 or newer\n\t\tif (asprintf(&option, \"lowerdir=/,upperdir=%s,workdir=%s\", odiff, owork) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (mount(\"overlay\", oroot, \"overlay\", MS_MGC_VAL, option) < 0)\n\t\t\terrExit(\"mounting overlayfs\");\n\t\t\t\n\t\t//***************************\n\t\t// issue #263 start code\n\t\t// My setup has a separate mount point for /home. When the overlay is mounted,\n\t\t// the overlay does not contain the original /home contents. \n\t\t// I added code to create a second overlay for /home if the overlay home dir is empty and this seems to work\n\t\t// @dshmgh, Jan 2016\n\t\t{\n\t\t\tchar *overlayhome;\n\t\t\tstruct stat s;\n\t\t\tchar *hroot;\n\t\t\tchar *hdiff;\n\t\t\tchar *hwork;\n\t\t\n\t\t\t// dons add debug\n\t\t\tif (arg_debug) printf (\"DEBUG: chroot dirs are oroot %s  odiff %s  owork %s\\n\",oroot,odiff,owork);\n\t\t\n\t\t\t// BEFORE NEXT, WE NEED TO TEST IF /home has any contents or do we need to mount it?\n\t\t\t// must create var for oroot/cfg.homedir\n\t\t\tif (asprintf(&overlayhome,\"%s%s\",oroot,cfg.homedir) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tif (arg_debug) printf (\"DEBUG: overlayhome var holds ##%s##\\n\",overlayhome);\n\t\t\n\t\t\t// if no homedir in overlay -- create another overlay for /home\n\t\t\tif (stat(overlayhome, &s) == -1) {\n\t\t\n\t\t\t\tif(asprintf(&hroot, \"%s/oroot/home\", RUN_MNT_DIR) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\n\t\t\t\tif(asprintf(&hdiff, \"%s/hdiff\", basedir) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\n\t\t\t\t// no need to check arg_overlay_reuse\n\t\t\t\tif (stat(hdiff, &s) != 0) {\n\t\t\t\t\tif (mkdir(hdiff, S_IRWXU | S_IRWXG | S_IRWXO))\n\t\t\t\t\t\terrExit(\"mkdir\");\n\t\t\t\t}\n\n\t\t\t\tif (chown(hdiff, 0, 0) < 0)\n\t\t\t\t\terrExit(\"chown\");\n\t\t\t\tif (chmod(hdiff, S_IRWXU  | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH) < 0)\n\t\t\t\t\terrExit(\"chmod\");\n\t\t\n\t\t\t\tif(asprintf(&hwork, \"%s/hwork\", basedir) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\n\t\t\t\t// no need to check arg_overlay_reuse\n\t\t\t\tif (stat(hwork, &s) != 0) {\n\t\t\t\t\tif (mkdir(hwork, S_IRWXU | S_IRWXG | S_IRWXO))\n\t\t\t\t\t\terrExit(\"mkdir\");\n\t\t\t\t}\n\n\t\t\t\tif (chown(hwork, 0, 0) < 0)\n\t\t\t\t\terrExit(\"chown\");\n\t\t\t\tif (chmod(hwork, S_IRWXU  | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH) < 0)\n\t\t\t\t\terrExit(\"chmod\");\n\t\t\n\t\t\t\t// no homedir in overlay so now mount another overlay for /home\n\t\t\t\tif (asprintf(&option, \"lowerdir=/home,upperdir=%s,workdir=%s\", hdiff, hwork) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\tif (mount(\"overlay\", hroot, \"overlay\", MS_MGC_VAL, option) < 0)\n\t\t\t\t\terrExit(\"mounting overlayfs for mounted home directory\");\n\t\t\n\t\t\t\tprintf(\"OverlayFS for /home configured in %s directory\\n\", basedir);\n\t\t\t} // stat(overlayhome)\n\t\t\tfree(overlayhome);\n\t\t}\n\t\t// issue #263 end code\n\t\t//***************************\n\t}\n\tprintf(\"OverlayFS configured in %s directory\\n\", basedir);\n\t\n\t// mount-bind dev directory\n\tif (arg_debug)\n\t\tprintf(\"Mounting /dev\\n\");\n\tchar *dev;\n\tif (asprintf(&dev, \"%s/dev\", oroot) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(\"/dev\", dev, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /dev\");\n\tfs_logger(\"whitelist /dev\");\n\n\t// mount-bind run directory\n\tif (arg_debug)\n\t\tprintf(\"Mounting /run\\n\");\n\tchar *run;\n\tif (asprintf(&run, \"%s/run\", oroot) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(\"/run\", run, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /run\");\n\tfs_logger(\"whitelist /run\");\n\n\t// mount-bind /tmp/.X11-unix directory\n\tif (stat(\"/tmp/.X11-unix\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting /tmp/.X11-unix\\n\");\n\t\tchar *x11;\n\t\tif (asprintf(&x11, \"%s/tmp/.X11-unix\", oroot) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (mount(\"/tmp/.X11-unix\", x11, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\tfprintf(stderr, \"Warning: cannot mount /tmp/.X11-unix in overlay\\n\");\n\t\telse\n\t\t\tfs_logger(\"whitelist /tmp/.X11-unix\");\n\t\tfree(x11);\n\t}\n\n\t// chroot in the new filesystem\n\tif (chroot(oroot) == -1)\n\t\terrExit(\"chroot\");\n\n\t// update /var directory in order to support multiple sandboxes running on the same root directory\n\tif (!arg_private_dev)\n\t\tfs_dev_shm();\n\tfs_var_lock();\n\tfs_var_tmp();\n\tfs_var_log();\n\tfs_var_lib();\n\tfs_var_cache();\n\tfs_var_utmp();\n\n\t// don't leak user information\n\trestrict_users();\n\n\t// when starting as root, firejail config is not disabled;\n\t// this mode could be used to install and test new software by chaining\n\t// firejail sandboxes (firejail --force)\n\tif (getuid() != 0)\n\t\tdisable_config();\n\n\t// cleanup and exit\n\tfree(option);\n\tfree(oroot);\n\tfree(odiff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_chroot",
          "args": [
            "cfg.chrootdir"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "fs_chroot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
          "lines": "1184-1268",
          "snippet": "void fs_chroot(const char *rootdir) {\n\tassert(rootdir);\n\t\n\tif (checkcfg(CFG_CHROOT_DESKTOP)) {\n\t\t// mount-bind a /dev in rootdir\n\t\tchar *newdev;\n\t\tif (asprintf(&newdev, \"%s/dev\", rootdir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting /dev on %s\\n\", newdev);\n\t\tif (mount(\"/dev\", newdev, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mounting /dev\");\n\t\tfree(newdev);\n\t\t\n\t\t// x11\n\t\tif (getenv(\"FIREJAIL_X11\")) {\n\t\t\tmask_x11_abstract_socket = 1;\n\t\t\tchar *newx11;\n\t\t\tif (asprintf(&newx11, \"%s/tmp/.X11-unix\", rootdir) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Mounting /tmp/.X11-unix on %s\\n\", newx11);\n\t\t\tif (mount(\"/tmp/.X11-unix\", newx11, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mounting /tmp/.X11-unix\");\n\t\t\tfree(newx11);\n\t\t}\n\t\t\n\t\t// some older distros don't have a /run directory\n\t\t// create one by default\n\t\t// no exit on error, let the user deal with any problems\n\t\tchar *rundir;\n\t\tif (asprintf(&rundir, \"%s/run\", rootdir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (!is_dir(rundir)) {\n\t\t\tint rv = mkdir(rundir, 0755);\n\t\t\t(void) rv;\n\t\t\trv = chown(rundir, 0, 0);\n\t\t\t(void) rv;\n\t\t}\n\t\t\n\t\t// copy /etc/resolv.conf in chroot directory\n\t\t// if resolv.conf in chroot is a symbolic link, this will fail\n\t\t// no exit on error, let the user deal with the problem\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"%s/etc/resolv.conf\", rootdir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Updating /etc/resolv.conf in %s\\n\", fname);\n\t\tif (is_link(fname)) {\n\t\t\tfprintf(stderr, \"Error: invalid %s file\\n\", fname);\n\t\t\texit(1);\n\t\t}\n\t\tif (copy_file(\"/etc/resolv.conf\", fname, 0, 0, 0644) == -1)\n\t\t\tfprintf(stderr, \"Warning: /etc/resolv.conf not initialized\\n\");\n\t}\n\t\n\t// chroot into the new directory\n\tif (arg_debug)\n\t\tprintf(\"Chrooting into %s\\n\", rootdir);\n\tif (chroot(rootdir) < 0)\n\t\terrExit(\"chroot\");\n\t// mount a new tmpfs in /run/firejail/mnt - the old one was lost in chroot\n\tfs_build_remount_mnt_dir();\n\t\t\n\tif (checkcfg(CFG_CHROOT_DESKTOP)) {\n\t\t// update /var directory in order to support multiple sandboxes running on the same root directory\n\t\tif (!arg_private_dev)\n\t\t\tfs_dev_shm();\n\t\tfs_var_lock();\n\t\tfs_var_tmp();\n\t\tfs_var_log();\n\t\tfs_var_lib();\n\t\tfs_var_cache();\n\t\tfs_var_utmp();\n\t\n\t\t// don't leak user information\n\t\trestrict_users();\n\t\n\t\t// when starting as root, firejail config is not disabled;\n\t\t// this mode could be used to install and test new software by chaining\n\t\t// firejail sandboxes (firejail --force)\n\t\tif (getuid() != 0)\n\t\t\tdisable_config();\n\t}\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_chroot(const char *rootdir) {\n\tassert(rootdir);\n\t\n\tif (checkcfg(CFG_CHROOT_DESKTOP)) {\n\t\t// mount-bind a /dev in rootdir\n\t\tchar *newdev;\n\t\tif (asprintf(&newdev, \"%s/dev\", rootdir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting /dev on %s\\n\", newdev);\n\t\tif (mount(\"/dev\", newdev, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mounting /dev\");\n\t\tfree(newdev);\n\t\t\n\t\t// x11\n\t\tif (getenv(\"FIREJAIL_X11\")) {\n\t\t\tmask_x11_abstract_socket = 1;\n\t\t\tchar *newx11;\n\t\t\tif (asprintf(&newx11, \"%s/tmp/.X11-unix\", rootdir) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Mounting /tmp/.X11-unix on %s\\n\", newx11);\n\t\t\tif (mount(\"/tmp/.X11-unix\", newx11, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mounting /tmp/.X11-unix\");\n\t\t\tfree(newx11);\n\t\t}\n\t\t\n\t\t// some older distros don't have a /run directory\n\t\t// create one by default\n\t\t// no exit on error, let the user deal with any problems\n\t\tchar *rundir;\n\t\tif (asprintf(&rundir, \"%s/run\", rootdir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (!is_dir(rundir)) {\n\t\t\tint rv = mkdir(rundir, 0755);\n\t\t\t(void) rv;\n\t\t\trv = chown(rundir, 0, 0);\n\t\t\t(void) rv;\n\t\t}\n\t\t\n\t\t// copy /etc/resolv.conf in chroot directory\n\t\t// if resolv.conf in chroot is a symbolic link, this will fail\n\t\t// no exit on error, let the user deal with the problem\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"%s/etc/resolv.conf\", rootdir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Updating /etc/resolv.conf in %s\\n\", fname);\n\t\tif (is_link(fname)) {\n\t\t\tfprintf(stderr, \"Error: invalid %s file\\n\", fname);\n\t\t\texit(1);\n\t\t}\n\t\tif (copy_file(\"/etc/resolv.conf\", fname, 0, 0, 0644) == -1)\n\t\t\tfprintf(stderr, \"Warning: /etc/resolv.conf not initialized\\n\");\n\t}\n\t\n\t// chroot into the new directory\n\tif (arg_debug)\n\t\tprintf(\"Chrooting into %s\\n\", rootdir);\n\tif (chroot(rootdir) < 0)\n\t\terrExit(\"chroot\");\n\t// mount a new tmpfs in /run/firejail/mnt - the old one was lost in chroot\n\tfs_build_remount_mnt_dir();\n\t\t\n\tif (checkcfg(CFG_CHROOT_DESKTOP)) {\n\t\t// update /var directory in order to support multiple sandboxes running on the same root directory\n\t\tif (!arg_private_dev)\n\t\t\tfs_dev_shm();\n\t\tfs_var_lock();\n\t\tfs_var_tmp();\n\t\tfs_var_log();\n\t\tfs_var_lib();\n\t\tfs_var_cache();\n\t\tfs_var_utmp();\n\t\n\t\t// don't leak user information\n\t\trestrict_users();\n\t\n\t\t// when starting as root, firejail config is not disabled;\n\t\t// this mode could be used to install and test new software by chaining\n\t\t// firejail sandboxes (firejail --force)\n\t\tif (getuid() != 0)\n\t\t\tdisable_config();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_build_cp_command",
          "args": [],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "fs_build_cp_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
          "lines": "148-174",
          "snippet": "void fs_build_cp_command(void) {\n\tstruct stat s;\n\tfs_build_mnt_dir();\n\tif (stat(RUN_CP_COMMAND, &s)) {\n\t\tchar* fname = realpath(\"/bin/cp\", NULL);\n\t\tif (fname == NULL) {\n\t\t\tfprintf(stderr, \"Error: /bin/cp not found\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (stat(fname, &s)) {\n\t\t\tfprintf(stderr, \"Error: /bin/cp not found\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (is_link(fname)) {\n\t\t\tfprintf(stderr, \"Error: invalid /bin/cp file\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tint rv = copy_file(fname, RUN_CP_COMMAND, 0, 0, 0755);\n\t\tif (rv) {\n\t\t\tfprintf(stderr, \"Error: cannot access /bin/cp\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tASSERT_PERMS(RUN_CP_COMMAND, 0, 0, 0755);\n\t\t\t\n\t\tfree(fname);\n\t}\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_build_cp_command(void) {\n\tstruct stat s;\n\tfs_build_mnt_dir();\n\tif (stat(RUN_CP_COMMAND, &s)) {\n\t\tchar* fname = realpath(\"/bin/cp\", NULL);\n\t\tif (fname == NULL) {\n\t\t\tfprintf(stderr, \"Error: /bin/cp not found\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (stat(fname, &s)) {\n\t\t\tfprintf(stderr, \"Error: /bin/cp not found\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (is_link(fname)) {\n\t\t\tfprintf(stderr, \"Error: invalid /bin/cp file\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tint rv = copy_file(fname, RUN_CP_COMMAND, 0, 0, 0755);\n\t\tif (rv) {\n\t\t\tfprintf(stderr, \"Error: cannot access /bin/cp\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tASSERT_PERMS(RUN_CP_COMMAND, 0, 0, 0755);\n\t\t\t\n\t\tfree(fname);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_ibus_load",
          "args": [],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "env_ibus_load",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/env.c",
          "lines": "54-114",
          "snippet": "void env_ibus_load(void) {\n\t// check ~/.config/ibus/bus directory\n\tchar *dirname;\n\tif (asprintf(&dirname, \"%s/.config/ibus/bus\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct stat s;\n\tif (stat(dirname, &s) == -1)\n\t\treturn;\n\n\t// find the file\n\t/* coverity[toctou] */\n\tDIR *dir = opendir(dirname);\n\tif (!dir) {\n\t\tfree(dirname);\n\t\treturn;\n\t}\n\n\tstruct dirent *entry;\n\twhile ((entry = readdir(dir)) != NULL) {\n\t\t// check the file name ends in \"unix-0\"\n\t\tchar *ptr = strstr(entry->d_name, \"unix-0\");\n\t\tif (!ptr)\n\t\t\tcontinue;\n\t\tif (strlen(ptr) != 6)\n\t\t\tcontinue;\n\t\t\n\t\t// open the file\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"%s/%s\", dirname, entry->d_name) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tFILE *fp = fopen(fname, \"r\");\n\t\tfree(fname);\n\t\tif (!fp)\n\t\t\tcontinue;\n\t\t\t\n\t\t// read the file\n\t\tconst int maxline = 4096;\n\t\tchar buf[maxline];\n\t\twhile (fgets(buf, maxline, fp)) {\n\t\t\tif (strncmp(buf, \"IBUS_\", 5) != 0)\n\t\t\t\tcontinue;\n\t\t\tchar *ptr = strchr(buf, '=');\n\t\t\tif (!ptr)\n\t\t\t\tcontinue;\n\t\t\tptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"%s\\n\", buf);\n\t\t\tEUID_USER();\n\t\t\tenv_store(buf, SETENV);\n\t\t\tEUID_ROOT();\n\t\t}\n\n\t\tfclose(fp);\n\t}\n\n\tfree(dirname);\n\tclosedir(dir);\n}",
          "includes": [
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid env_ibus_load(void) {\n\t// check ~/.config/ibus/bus directory\n\tchar *dirname;\n\tif (asprintf(&dirname, \"%s/.config/ibus/bus\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct stat s;\n\tif (stat(dirname, &s) == -1)\n\t\treturn;\n\n\t// find the file\n\t/* coverity[toctou] */\n\tDIR *dir = opendir(dirname);\n\tif (!dir) {\n\t\tfree(dirname);\n\t\treturn;\n\t}\n\n\tstruct dirent *entry;\n\twhile ((entry = readdir(dir)) != NULL) {\n\t\t// check the file name ends in \"unix-0\"\n\t\tchar *ptr = strstr(entry->d_name, \"unix-0\");\n\t\tif (!ptr)\n\t\t\tcontinue;\n\t\tif (strlen(ptr) != 6)\n\t\t\tcontinue;\n\t\t\n\t\t// open the file\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"%s/%s\", dirname, entry->d_name) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tFILE *fp = fopen(fname, \"r\");\n\t\tfree(fname);\n\t\tif (!fp)\n\t\t\tcontinue;\n\t\t\t\n\t\t// read the file\n\t\tconst int maxline = 4096;\n\t\tchar buf[maxline];\n\t\twhile (fgets(buf, maxline, fp)) {\n\t\t\tif (strncmp(buf, \"IBUS_\", 5) != 0)\n\t\t\t\tcontinue;\n\t\t\tchar *ptr = strchr(buf, '=');\n\t\t\tif (!ptr)\n\t\t\t\tcontinue;\n\t\t\tptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"%s\\n\", buf);\n\t\t\tEUID_USER();\n\t\t\tenv_store(buf, SETENV);\n\t\t\tEUID_ROOT();\n\t\t}\n\n\t\tfclose(fp);\n\t}\n\n\tfree(dirname);\n\tclosedir(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "netfilter6",
          "args": [
            "arg_netfilter6_file"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "netfilter6",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/netfilter.c",
          "lines": "183-289",
          "snippet": "void netfilter6(const char *fname) {\n\tif (fname == NULL)\n\t\treturn;\n\t\t\n\tchar *filter;\n\n\t// buffer the filter\n\tstruct stat s;\n\tif (stat(fname, &s) == -1) {\n\t\tfprintf(stderr, \"Error: cannot find network filter file %s\\n\", fname);\n\t\texit(1);\n\t}\n\n\tfilter = malloc(s.st_size + 1);\t  // + '\\0'\n\tif (!filter)\n\t\terrExit(\"malloc\");\n\tmemset(filter, 0, s.st_size + 1);\n\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: cannot open network filter file %s\\n\", fname);\n\t\texit(1);\n\t}\n\n\tsize_t sz = fread(filter, 1, s.st_size, fp);\n\tif ((off_t)sz != s.st_size) {\n\t\tfprintf(stderr, \"Error: cannot read network filter file %s\\n\", fname);\n\t\texit(1);\n\t}\n\tfclose(fp);\n\n\t// temporarily mount a tempfs on top of /tmp directory\n\tif (mount(\"tmpfs\", \"/tmp\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\terrExit(\"mounting /tmp\");\n\n\t// create the filter file\n\tfp = fopen(\"/tmp/netfilter6\", \"w\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: cannot open /tmp/netfilter6 file\\n\");\n\t\texit(1);\n\t}\n\tfprintf(fp, \"%s\\n\", filter);\n\tfclose(fp);\n\n\t// find iptables command\n\tchar *ip6tables = NULL;\n\tchar *ip6tables_restore = NULL;\n\tif (stat(\"/sbin/ip6tables\", &s) == 0) {\n\t\tip6tables = \"/sbin/ip6tables\";\n\t\tip6tables_restore = \"/sbin/ip6tables-restore\";\n\t}\n\telse if (stat(\"/usr/sbin/ip6tables\", &s) == 0) {\n\t\tip6tables = \"/usr/sbin/ip6tables\";\n\t\tip6tables_restore = \"/usr/sbin/ip6tables-restore\";\n\t}\n\tif (ip6tables == NULL || ip6tables_restore == NULL) {\n\t\tfprintf(stderr, \"Error: ip6tables command not found\\n\");\n\t\tgoto doexit;\n\t}\n\n\t// push filter\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Installing network filter:\\n%s\\n\", filter);\n\n\t\tint fd;\n\t\tif((fd = open(\"/tmp/netfilter6\", O_RDONLY)) == -1) {\n\t\t\tfprintf(stderr,\"Error: cannot open /tmp/netfilter6\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tdup2(fd,STDIN_FILENO);\n\n\t\t// wipe out environment variables\n\t\tenviron = NULL;\n\t\tclearenv();\n\t\texecl(ip6tables_restore, ip6tables_restore, NULL);\n\t\tperror(\"execl\");\n\t\t_exit(1);\n\t}\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n\n\t// debug\n\tif (arg_debug) {\n\t\tchild = fork();\n\t\tif (child < 0)\n\t\t\terrExit(\"fork\");\n\t\tif (child == 0) {\n\t\t\tenviron = NULL;\n\t\t\tclearenv();\n\t\t\texecl(ip6tables, ip6tables, \"-vL\", NULL);\n\t\t\tperror(\"execl\");\n\t\t\t_exit(1);\n\t\t}\n\t\t// wait for the child to finish\n\t\twaitpid(child, NULL, 0);\n\t}\n\ndoexit:\n\t// unmount /tmp\n\tumount(\"/tmp\");\n\tfree(filter);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid netfilter6(const char *fname) {\n\tif (fname == NULL)\n\t\treturn;\n\t\t\n\tchar *filter;\n\n\t// buffer the filter\n\tstruct stat s;\n\tif (stat(fname, &s) == -1) {\n\t\tfprintf(stderr, \"Error: cannot find network filter file %s\\n\", fname);\n\t\texit(1);\n\t}\n\n\tfilter = malloc(s.st_size + 1);\t  // + '\\0'\n\tif (!filter)\n\t\terrExit(\"malloc\");\n\tmemset(filter, 0, s.st_size + 1);\n\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: cannot open network filter file %s\\n\", fname);\n\t\texit(1);\n\t}\n\n\tsize_t sz = fread(filter, 1, s.st_size, fp);\n\tif ((off_t)sz != s.st_size) {\n\t\tfprintf(stderr, \"Error: cannot read network filter file %s\\n\", fname);\n\t\texit(1);\n\t}\n\tfclose(fp);\n\n\t// temporarily mount a tempfs on top of /tmp directory\n\tif (mount(\"tmpfs\", \"/tmp\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\terrExit(\"mounting /tmp\");\n\n\t// create the filter file\n\tfp = fopen(\"/tmp/netfilter6\", \"w\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: cannot open /tmp/netfilter6 file\\n\");\n\t\texit(1);\n\t}\n\tfprintf(fp, \"%s\\n\", filter);\n\tfclose(fp);\n\n\t// find iptables command\n\tchar *ip6tables = NULL;\n\tchar *ip6tables_restore = NULL;\n\tif (stat(\"/sbin/ip6tables\", &s) == 0) {\n\t\tip6tables = \"/sbin/ip6tables\";\n\t\tip6tables_restore = \"/sbin/ip6tables-restore\";\n\t}\n\telse if (stat(\"/usr/sbin/ip6tables\", &s) == 0) {\n\t\tip6tables = \"/usr/sbin/ip6tables\";\n\t\tip6tables_restore = \"/usr/sbin/ip6tables-restore\";\n\t}\n\tif (ip6tables == NULL || ip6tables_restore == NULL) {\n\t\tfprintf(stderr, \"Error: ip6tables command not found\\n\");\n\t\tgoto doexit;\n\t}\n\n\t// push filter\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Installing network filter:\\n%s\\n\", filter);\n\n\t\tint fd;\n\t\tif((fd = open(\"/tmp/netfilter6\", O_RDONLY)) == -1) {\n\t\t\tfprintf(stderr,\"Error: cannot open /tmp/netfilter6\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tdup2(fd,STDIN_FILENO);\n\n\t\t// wipe out environment variables\n\t\tenviron = NULL;\n\t\tclearenv();\n\t\texecl(ip6tables_restore, ip6tables_restore, NULL);\n\t\tperror(\"execl\");\n\t\t_exit(1);\n\t}\n\t// wait for the child to finish\n\twaitpid(child, NULL, 0);\n\n\t// debug\n\tif (arg_debug) {\n\t\tchild = fork();\n\t\tif (child < 0)\n\t\t\terrExit(\"fork\");\n\t\tif (child == 0) {\n\t\t\tenviron = NULL;\n\t\t\tclearenv();\n\t\t\texecl(ip6tables, ip6tables, \"-vL\", NULL);\n\t\t\tperror(\"execl\");\n\t\t\t_exit(1);\n\t\t}\n\t\t// wait for the child to finish\n\t\twaitpid(child, NULL, 0);\n\t}\n\ndoexit:\n\t// unmount /tmp\n\tumount(\"/tmp\");\n\tfree(filter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_logger",
          "args": [
            "\"install mount namespace\""
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger_print_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_logger.c",
          "lines": "136-189",
          "snippet": "void fs_logger_print_log(pid_t pid) {\n\tEUID_ASSERT();\n\n\t// if the pid is that of a firejail  process, use the pid of the first child process\n\tEUID_ROOT();\n\tchar *comm = pid_proc_comm(pid);\n\tEUID_USER();\n\tif (comm) {\n\t\tif (strcmp(comm, \"firejail\") == 0) {\n\t\t\tpid_t child;\n\t\t\tif (find_child(pid, &child) == 0) {\n\t\t\t\tpid = child;\n\t\t\t}\n\t\t}\n\t\tfree(comm);\n\t}\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission denied\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// print RUN_FSLOGGER_FILE\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_FSLOGGER_FILE) == -1)\n\t\terrExit(\"asprintf\");\n\n\tEUID_ROOT();\n\tstruct stat s;\n\tif (stat(fname, &s) == -1) {\n\t\tfprintf(stderr, \"Error: Cannot access filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: Cannot open filesystem log\\n\");\n\t\texit(1);\n\t}\n\t\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp))\n\t\tprintf(\"%s\", buf);\n\tfclose(fp);\n\tfree(fname);\n\n\texit(0);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAXBUF 4098"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\n#define MAXBUF 4098\n\nvoid fs_logger_print_log(pid_t pid) {\n\tEUID_ASSERT();\n\n\t// if the pid is that of a firejail  process, use the pid of the first child process\n\tEUID_ROOT();\n\tchar *comm = pid_proc_comm(pid);\n\tEUID_USER();\n\tif (comm) {\n\t\tif (strcmp(comm, \"firejail\") == 0) {\n\t\t\tpid_t child;\n\t\t\tif (find_child(pid, &child) == 0) {\n\t\t\t\tpid = child;\n\t\t\t}\n\t\t}\n\t\tfree(comm);\n\t}\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission denied\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// print RUN_FSLOGGER_FILE\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_FSLOGGER_FILE) == -1)\n\t\terrExit(\"asprintf\");\n\n\tEUID_ROOT();\n\tstruct stat s;\n\tif (stat(fname, &s) == -1) {\n\t\tfprintf(stderr, \"Error: Cannot access filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: Cannot open filesystem log\\n\");\n\t\texit(1);\n\t}\n\t\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp))\n\t\tprintf(\"%s\", buf);\n\tfclose(fp);\n\tfree(fname);\n\n\texit(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_logger2int",
          "args": [
            "\"sandbox pid:\"",
            "(int) sandbox_pid"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger2int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_logger.c",
          "lines": "73-80",
          "snippet": "void fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "chk_chroot",
          "args": [],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "chk_chroot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/sandbox.c",
          "lines": "171-186",
          "snippet": "static void chk_chroot(void) {\n\t// if we are starting firejail inside some other container technology, we don't care about this\n\tchar *mycont = getenv(\"container\");\n\tif (mycont)\n\t\treturn;\n\t\n\t// check if this is a regular chroot\n\tstruct stat s;\n\tif (stat(\"/\", &s) == 0) {\n\t\tif (s.st_ino != 2)\n\t\t\treturn;\n\t}\n\t\n\tfprintf(stderr, \"Error: cannot mount filesystem as slave\\n\");\n\texit(1);\n}",
          "includes": [
            "#include <sys/apparmor.h>",
            "#include <sys/prctl.h>",
            "#include <sched.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/prctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/apparmor.h>\n#include <sys/prctl.h>\n#include <sched.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/prctl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void chk_chroot(void) {\n\t// if we are starting firejail inside some other container technology, we don't care about this\n\tchar *mycont = getenv(\"container\");\n\tif (mycont)\n\t\treturn;\n\t\n\t// check if this is a regular chroot\n\tstruct stat s;\n\tif (stat(\"/\", &s) == 0) {\n\t\tif (s.st_ino != 2)\n\t\t\treturn;\n\t}\n\t\n\tfprintf(stderr, \"Error: cannot mount filesystem as slave\\n\");\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "NULL",
            "\"/\"",
            "NULL",
            "MS_SLAVE | MS_REC",
            "NULL"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"sethostname\""
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sethostname",
          "args": [
            "cfg.hostname",
            "strlen(cfg.hostname)"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cfg.hostname"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"PID namespace installed\\n\""
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "child_to_parent_fds[0]"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "parent_to_child_fds[1]"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Initializing child process\\n\""
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/apparmor.h>\n#include <sys/prctl.h>\n#include <sched.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/prctl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\n#define CLONE_NEWUSER\t0x10000000\n\nint sandbox(void* sandbox_arg) {\n\t// Get rid of unused parameter warning\n\t(void)sandbox_arg;\n\n\tpid_t child_pid = getpid();\n\tif (arg_debug)\n\t\tprintf(\"Initializing child process\\n\");\t\n\n \t// close each end of the unused pipes\n \tclose(parent_to_child_fds[1]);\n \tclose(child_to_parent_fds[0]);\n \n \t// wait for parent to do base setup\n \twait_for_other(parent_to_child_fds[0]);\n\n\tif (arg_debug && child_pid == 1)\n\t\tprintf(\"PID namespace installed\\n\");\n\n\n\t//****************************\n\t// set hostname\n\t//****************************\n\tif (cfg.hostname) {\n\t\tif (sethostname(cfg.hostname, strlen(cfg.hostname)) < 0)\n\t\t\terrExit(\"sethostname\");\n\t}\n\n\t//****************************\n\t// mount namespace\n\t//****************************\n\t// mount events are not forwarded between the host the sandbox\n\tif (mount(NULL, \"/\", NULL, MS_SLAVE | MS_REC, NULL) < 0) {\n\t\tchk_chroot();\n\t}\n\t\n\t\n\t//****************************\n\t// log sandbox data\n\t//****************************\n\tif (cfg.name)\n\t\tfs_logger2(\"sandbox name:\", cfg.name);\n\tfs_logger2int(\"sandbox pid:\", (int) sandbox_pid);\n\tif (cfg.chrootdir)\n\t\tfs_logger(\"sandbox filesystem: chroot\");\n\telse if (arg_overlay)\t\n\t\tfs_logger(\"sandbox filesystem: overlay\");\n\telse\n\t\tfs_logger(\"sandbox filesystem: local\");\n\tfs_logger(\"install mount namespace\");\n\t\n\t//****************************\n\t// netfilter etc.\n\t//****************************\n\tif (arg_netfilter && any_bridge_configured()) { // assuming by default the client filter\n\t\tnetfilter(arg_netfilter_file);\n\t}\n\tif (arg_netfilter6 && any_bridge_configured()) { // assuming by default the client filter\n\t\tnetfilter6(arg_netfilter6_file);\n\t}\n\n\t// load IBUS env variables\n\tif (arg_nonetwork || any_bridge_configured() || any_interface_configured()) {\n\t\t// do nothing - there are problems with ibus version 1.5.11\n\t}\n\telse\n\t\tenv_ibus_load();\n\t\n\t// grab a copy of cp command\n\tfs_build_cp_command();\n\t\n\t// trace pre-install\n\tif (arg_trace || arg_tracelog || mask_x11_abstract_socket)\n\t\tfs_trace_preload();\n\n\t//****************************\n\t// configure filesystem\n\t//****************************\n#ifdef HAVE_SECCOMP\n\tint enforce_seccomp = 0;\n#endif\n#ifdef HAVE_CHROOT\t\t\n\tif (cfg.chrootdir) {\n\t\tfs_chroot(cfg.chrootdir);\n\t\t\n\t\t// force caps and seccomp if not started as root\n\t\tif (getuid() != 0) {\n\t\t\tenforce_filters();\n#ifdef HAVE_SECCOMP\n\t\t\tenforce_seccomp = 1;\n#endif\n\t\t}\n\t\telse\n\t\t\targ_seccomp = 1;\n\t\t\t\t\t\t\n\t\t//****************************\n\t\t// trace pre-install, this time inside chroot\n\t\t//****************************\n\t\tif (arg_trace || arg_tracelog || mask_x11_abstract_socket)\n\t\t\tfs_trace_preload();\n\t}\n\telse \n#endif\t\t\n#ifdef HAVE_OVERLAYFS\n\tif (arg_overlay)\t{\n\t\tfs_overlayfs();\n\t\t// force caps and seccomp if not started as root\n\t\tif (getuid() != 0) {\n\t\t\tenforce_filters();\n#ifdef HAVE_SECCOMP\n\t\t\tenforce_seccomp = 1;\n#endif\n\t\t}\n\t\telse\n\t\t\targ_seccomp = 1;\n\t}\n\telse\n#endif\n\t\tfs_basic_fs();\n\t\n\t//****************************\n\t// set hostname in /etc/hostname\n\t//****************************\n\tif (cfg.hostname) {\n\t\tfs_hostname(cfg.hostname);\n\t}\n\t\n\t//****************************\n\t// private mode\n\t//****************************\n\tif (arg_private) {\n\t\tif (cfg.home_private) {\t// --private=\n\t\t\tif (cfg.chrootdir)\n\t\t\t\tfprintf(stderr, \"Warning: private=directory feature is disabled in chroot\\n\");\n\t\t\telse if (arg_overlay)\n\t\t\t\tfprintf(stderr, \"Warning: private=directory feature is disabled in overlay\\n\");\n\t\t\telse\n\t\t\t\tfs_private_homedir();\n\t\t}\n\t\telse if (cfg.home_private_keep) { // --private-home=\n\t\t\tif (cfg.chrootdir)\n\t\t\t\tfprintf(stderr, \"Warning: private-home= feature is disabled in chroot\\n\");\n\t\t\telse if (arg_overlay)\n\t\t\t\tfprintf(stderr, \"Warning: private-home= feature is disabled in overlay\\n\");\n\t\t\telse\n\t\t\t\tfs_private_home_list();\n\t\t}\n\t\telse // --private\n\t\t\tfs_private();\n\t}\n\n\tif (arg_private_dev) {\n\t\tif (cfg.chrootdir)\n\t\t\tfprintf(stderr, \"Warning: private-dev feature is disabled in chroot\\n\");\n\t\telse if (arg_overlay)\n\t\t\tfprintf(stderr, \"Warning: private-dev feature is disabled in overlay\\n\");\n\t\telse\n\t\t\tfs_private_dev();\n\t}\n\t\t\n\tif (arg_private_etc) {\n\t\tif (cfg.chrootdir)\n\t\t\tfprintf(stderr, \"Warning: private-etc feature is disabled in chroot\\n\");\n\t\telse if (arg_overlay)\n\t\t\tfprintf(stderr, \"Warning: private-etc feature is disabled in overlay\\n\");\n\t\telse {\n\t\t\tfs_private_etc_list();\n\t\t\t// create /etc/ld.so.preload file again\n\t\t\tif (arg_trace || arg_tracelog || mask_x11_abstract_socket)\n\t\t\t\tfs_trace_preload();\n\t\t}\n\t}\n\t\n\tif (arg_private_bin) {\n\t\tif (cfg.chrootdir)\n\t\t\tfprintf(stderr, \"Warning: private-bin feature is disabled in chroot\\n\");\n\t\telse if (arg_overlay)\n\t\t\tfprintf(stderr, \"Warning: private-bin feature is disabled in overlay\\n\");\n\t\telse {\n\t\t\t// for --x11=xorg we need to add xauth command\n\t\t\tif (arg_x11_xorg) {\n\t\t\t\tEUID_USER();\n\t\t\t\tchar *tmp;\n\t\t\t\tif (asprintf(&tmp, \"%s,xauth\", cfg.bin_private_keep) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\tcfg.bin_private_keep = tmp;\n\t\t\t\tfs_check_bin_list();\n\t\t\t\tEUID_ROOT();\n\t\t\t}\n\t\t\tfs_private_bin_list();\n\t\t}\n\t}\n\t\n\tif (arg_private_tmp) {\n\t\tif (cfg.chrootdir)\n\t\t\tfprintf(stderr, \"Warning: private-tmp feature is disabled in chroot\\n\");\n\t\telse if (arg_overlay)\n\t\t\tfprintf(stderr, \"Warning: private-tmp feature is disabled in overlay\\n\");\n\t\telse {\n\t\t\t// private-tmp is implemented as a whitelist\n\t\t\tEUID_USER();\n\t\t\tprofile_add(\"whitelist /tmp/.X11-unix\");\n\t\t\tEUID_ROOT();\n//\t\t\tfs_private_tmp();\n\t\t}\n\t}\n\t\n\t//****************************\n\t// update /proc, /sys, /dev, /boot directorymy\n\t//****************************\n\tif (checkcfg(CFG_REMOUNT_PROC_SYS))\n\t\tfs_proc_sys_dev_boot();\n\t\n\t//****************************\n\t// apply the profile file\n\t//****************************\n\t// apply all whitelist commands ... \n\tif (cfg.chrootdir)\n\t\tfprintf(stderr, \"Warning: whitelist feature is disabled in chroot\\n\");\n\telse if (arg_overlay)\n\t\tfprintf(stderr, \"Warning: whitelist feature is disabled in overlay\\n\");\n\telse\n\t\tfs_whitelist();\n\t\n\t// ... followed by blacklist commands\n\tfs_blacklist();\n\t\n\t//****************************\n\t// install trace\n\t//****************************\n\tif (arg_trace || arg_tracelog || mask_x11_abstract_socket)\n\t\tfs_trace();\n\t\t\n\t//****************************\n\t// nosound/no3d and fix for pulseaudio 7.0\n\t//****************************\n\tif (arg_nosound) {\n\t\t// disable pulseaudio\n\t\tpulseaudio_disable();\n\n\t\t// disable /dev/snd\n\t\tfs_dev_disable_sound();\n\t}\n\telse\n\t\tpulseaudio_init();\n\t\n\tif (arg_no3d)\n\t\tfs_dev_disable_3d();\n\t\n\t//****************************\n\t// networking\n\t//****************************\n\tint gw_cfg_failed = 0; // default gw configuration flag\n\tif (arg_nonetwork) {\n\t\tnet_if_up(\"lo\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Network namespace enabled, only loopback interface available\\n\");\n\t}\n\telse if (any_bridge_configured() || any_interface_configured()) {\n\t\t// configure lo and eth0...eth3\n\t\tnet_if_up(\"lo\");\n\t\t\n\t\tif (mac_not_zero(cfg.bridge0.macsandbox))\n\t\t\tnet_config_mac(cfg.bridge0.devsandbox, cfg.bridge0.macsandbox);\n\t\tsandbox_if_up(&cfg.bridge0);\n\t\t\n\t\tif (mac_not_zero(cfg.bridge1.macsandbox))\n\t\t\tnet_config_mac(cfg.bridge1.devsandbox, cfg.bridge1.macsandbox);\n\t\tsandbox_if_up(&cfg.bridge1);\n\t\t\n\t\tif (mac_not_zero(cfg.bridge2.macsandbox))\n\t\t\tnet_config_mac(cfg.bridge2.devsandbox, cfg.bridge2.macsandbox);\n\t\tsandbox_if_up(&cfg.bridge2);\n\t\t\n\t\tif (mac_not_zero(cfg.bridge3.macsandbox))\n\t\t\tnet_config_mac(cfg.bridge3.devsandbox, cfg.bridge3.macsandbox);\n\t\tsandbox_if_up(&cfg.bridge3);\n\t\t\n\t\t// enable interfaces\n\t\tif (cfg.interface0.configured && cfg.interface0.ip) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(cfg.interface0.ip), cfg.interface0.dev);\n\t\t\tnet_if_ip(cfg.interface0.dev, cfg.interface0.ip, cfg.interface0.mask, cfg.interface0.mtu);\n\t\t\tnet_if_up(cfg.interface0.dev);\n\t\t}\t\t\t\n\t\tif (cfg.interface1.configured && cfg.interface1.ip) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(cfg.interface1.ip), cfg.interface1.dev);\n\t\t\tnet_if_ip(cfg.interface1.dev, cfg.interface1.ip, cfg.interface1.mask, cfg.interface1.mtu);\n\t\t\tnet_if_up(cfg.interface1.dev);\n\t\t}\t\t\t\n\t\tif (cfg.interface2.configured && cfg.interface2.ip) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(cfg.interface2.ip), cfg.interface2.dev);\n\t\t\tnet_if_ip(cfg.interface2.dev, cfg.interface2.ip, cfg.interface2.mask, cfg.interface2.mtu);\n\t\t\tnet_if_up(cfg.interface2.dev);\n\t\t}\t\t\t\n\t\tif (cfg.interface3.configured && cfg.interface3.ip) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(cfg.interface3.ip), cfg.interface3.dev);\n\t\t\tnet_if_ip(cfg.interface3.dev, cfg.interface3.ip, cfg.interface3.mask, cfg.interface3.mtu);\n\t\t\tnet_if_up(cfg.interface3.dev);\n\t\t}\t\t\t\n\t\t\t\n\t\t// add a default route\n\t\tif (cfg.defaultgw) {\n\t\t\t// set the default route\n\t\t\tif (net_add_route(0, 0, cfg.defaultgw)) {\n\t\t\t\tfprintf(stderr, \"Warning: cannot configure default route\\n\");\n\t\t\t\tgw_cfg_failed = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (arg_debug)\n\t\t\tprintf(\"Network namespace enabled\\n\");\n\t}\n\t\n\t// if any dns server is configured, it is time to set it now\n\tfs_resolvconf();\n\tfs_logger_print();\n\tfs_logger_change_owner();\n\n\t// print network configuration\n\tif (!arg_quiet) {\n\t\tif (any_bridge_configured() || any_interface_configured() || cfg.defaultgw || cfg.dns1) {\n\t\t\tprintf(\"\\n\");\n\t\t\tif (any_bridge_configured() || any_interface_configured())\n\t\t\t\tnet_ifprint();\n\t\t\tif (cfg.defaultgw != 0) {\n\t\t\t\tif (gw_cfg_failed)\n\t\t\t\t\tprintf(\"Default gateway configuration failed\\n\");\n\t\t\t\telse\n\t\t\t\t\tprintf(\"Default gateway %d.%d.%d.%d\\n\", PRINT_IP(cfg.defaultgw));\n\t\t\t}\n\t\t\tif (cfg.dns1 != 0)\n\t\t\t\tprintf(\"DNS server %d.%d.%d.%d\\n\", PRINT_IP(cfg.dns1));\n\t\t\tif (cfg.dns2 != 0)\n\t\t\t\tprintf(\"DNS server %d.%d.%d.%d\\n\", PRINT_IP(cfg.dns2));\n\t\t\tif (cfg.dns3 != 0)\n\t\t\t\tprintf(\"DNS server %d.%d.%d.%d\\n\", PRINT_IP(cfg.dns3));\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\t\n\tfs_delete_cp_command();\n\n\t//****************************\n\t// set application environment\n\t//****************************\n\tprctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0); // kill the child in case the parent died\n\tint cwd = 0;\n\tif (cfg.cwd) {\n\t\tif (chdir(cfg.cwd) == 0)\n\t\t\tcwd = 1;\n\t}\n\t\n\tif (!cwd) {\n\t\tif (chdir(\"/\") < 0)\n\t\t\terrExit(\"chdir\");\n\t\tif (cfg.homedir) {\n\t\t\tstruct stat s;\n\t\t\tif (stat(cfg.homedir, &s) == 0) {\n\t\t\t\t/* coverity[toctou] */\n\t\t\t\tif (chdir(cfg.homedir) < 0)\n\t\t\t\t\terrExit(\"chdir\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// set nice\n\tif (arg_nice) {\n\t\terrno = 0;\n\t\tint rv = nice(cfg.nice);\n\t\t(void) rv;\n\t\tif (errno) {\n\t\t\tfprintf(stderr, \"Warning: cannot set nice value\\n\");\n\t\t\terrno = 0;\n\t\t}\n\t}\n\t\n\t// clean /tmp/.X11-unix sockets\n\tfs_x11();\n\tif (arg_x11_xorg)\n\t\tx11_xorg();\n\t\n\t//****************************\n\t// set security filters\n\t//****************************\n\t// set capabilities\n//\tif (!arg_noroot)\n\t\tset_caps();\n\n\t// set rlimits\n\tset_rlimits();\n\n\t// set seccomp\n#ifdef HAVE_SECCOMP\n\t// install protocol filter\n\tif (cfg.protocol) {\n\t\tprotocol_filter();\t// install filter\t\n\t\tprotocol_filter_save();\t// save filter in PROTOCOL_CFG\n\t}\n\n\t// if a keep list is available, disregard the drop list\n\tif (arg_seccomp == 1) {\n\t\tif (cfg.seccomp_list_keep)\n\t\t\tseccomp_filter_keep();\n\t\telse if (cfg.seccomp_list_errno)\n\t\t\tseccomp_filter_errno(); \n\t\telse\n\t\t\tseccomp_filter_drop(enforce_seccomp);\n\t}\n#endif\n\n\t// set cpu affinity\n\tif (cfg.cpus) {\n\t\tsave_cpu(); // save cpu affinity mask to CPU_CFG file\n\t\tset_cpu_affinity();\n\t}\n\t\n\t// save cgroup in CGROUP_CFG file\n\tif (cfg.cgroup)\n\t\tsave_cgroup();\n\n\t//****************************************\n\t// drop privileges or create a new user namespace\n\t//****************************************\n\tsave_nogroups();\n\tif (arg_noroot) {\n\t\tint rv = unshare(CLONE_NEWUSER);\n\t\tif (rv == -1) {\n\t\t\tfprintf(stderr, \"Warning: cannot create a new user namespace, going forward without it...\\n\");\n\t\t\tdrop_privs(arg_nogroups);\n\t\t\targ_noroot = 0;\n\t\t}\n\t}\n\telse\n\t\tdrop_privs(arg_nogroups);\n\t\n\t// notify parent that new user namespace has been created so a proper\n \t// UID/GID map can be setup\n \tnotify_other(child_to_parent_fds[1]);\n \tclose(child_to_parent_fds[1]);\n \n \t// wait for parent to finish setting up a proper UID/GID map\n \twait_for_other(parent_to_child_fds[0]);\n \tclose(parent_to_child_fds[0]);\n\n\t// somehow, the new user namespace resets capabilities;\n\t// we need to do them again\n\tif (arg_noroot) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"noroot user namespace installed\\n\");\n\t\tset_caps();\n\t}\n\t\n\t//****************************************\n\t// Set NO_NEW_PRIVS if desired\n\t//****************************************\n\tif (arg_nonewprivs) {\n\t\tint no_new_privs = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\n\t\tif(no_new_privs != 0)\n\t\t\tfprintf(stderr, \"Warning: NO_NEW_PRIVS disabled, it requires a Linux kernel version 3.5 or newer.\\n\");\n\t\telse if (arg_debug)\n\t\t\tprintf(\"NO_NEW_PRIVS set\\n\");\n\t}\n\n\t//****************************************\n\t// fork the application and monitor it\n\t//****************************************\n\tpid_t app_pid = fork();\n\tif (app_pid == -1)\n\t\terrExit(\"fork\");\n\n\tif (app_pid == 0) {\n#ifdef HAVE_APPARMOR\n\t\tif (arg_apparmor) {\n\t\t\terrno = 0;\n\t\t\tif (aa_change_onexec(\"firejail-default\")) {\n\t\t\t\tfprintf(stderr, \"Error: cannot confine the application using AppArmor.\\n\");\n\t\t\t\tfprintf(stderr, \"Maybe firejail-default AppArmor profile is not loaded into the kernel.\\n\");\n\t\t\t\tfprintf(stderr, \"As root, run \\\"aa-enforce firejail-default\\\" to load it.\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\telse if (arg_debug)\n\t\t\t\tprintf(\"AppArmor enabled\\n\");\n\t\t}\n#endif\t\t\n\t\tprctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0); // kill the child in case the parent died\n\t\tstart_application();\t// start app\n\t}\n\n\tint status = monitor_application(app_pid);\t// monitor application\n\tflush_stdin();\n\n\n\n\tif (WIFEXITED(status)) {\n\t\t// if we had a proper exit, return that exit status\n\t\treturn WEXITSTATUS(status);\n\t} else {\n\t\t// something else went wrong!\n\t\treturn -1;\n\t}\n}"
  },
  {
    "function_name": "enforce_filters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/sandbox.c",
    "lines": "395-418",
    "snippet": "static void enforce_filters(void) {\n\t// force default seccomp inside the chroot, no keep or drop list\n\t// the list build on top of the default drop list is kept intact\n\targ_seccomp = 1;\n\tif (cfg.seccomp_list_drop) {\n\t\tfree(cfg.seccomp_list_drop);\n\t\tcfg.seccomp_list_drop = NULL;\n\t}\n\tif (cfg.seccomp_list_keep) {\n\t\tfree(cfg.seccomp_list_keep);\n\t\tcfg.seccomp_list_keep = NULL;\n\t}\n\t\n\t// disable all capabilities\n\tif (arg_caps_default_filter || arg_caps_list)\n\t\tfprintf(stderr, \"Warning: all capabilities disabled for a regular user in chroot\\n\");\n\targ_caps_drop_all = 1;\n\t\n\t// drop all supplementary groups; /etc/group file inside chroot\n\t// is controlled by a regular usr\n\targ_nogroups = 1;\n\tif (!arg_quiet)\n\t\tprintf(\"Dropping all Linux capabilities and enforcing default seccomp filter\\n\");\n}",
    "includes": [
      "#include <sys/apparmor.h>",
      "#include <sys/prctl.h>",
      "#include <sched.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/prctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Dropping all Linux capabilities and enforcing default seccomp filter\\n\""
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: all capabilities disabled for a regular user in chroot\\n\""
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cfg.seccomp_list_keep"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cfg.seccomp_list_drop"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/apparmor.h>\n#include <sys/prctl.h>\n#include <sched.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/prctl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void enforce_filters(void) {\n\t// force default seccomp inside the chroot, no keep or drop list\n\t// the list build on top of the default drop list is kept intact\n\targ_seccomp = 1;\n\tif (cfg.seccomp_list_drop) {\n\t\tfree(cfg.seccomp_list_drop);\n\t\tcfg.seccomp_list_drop = NULL;\n\t}\n\tif (cfg.seccomp_list_keep) {\n\t\tfree(cfg.seccomp_list_keep);\n\t\tcfg.seccomp_list_keep = NULL;\n\t}\n\t\n\t// disable all capabilities\n\tif (arg_caps_default_filter || arg_caps_list)\n\t\tfprintf(stderr, \"Warning: all capabilities disabled for a regular user in chroot\\n\");\n\targ_caps_drop_all = 1;\n\t\n\t// drop all supplementary groups; /etc/group file inside chroot\n\t// is controlled by a regular usr\n\targ_nogroups = 1;\n\tif (!arg_quiet)\n\t\tprintf(\"Dropping all Linux capabilities and enforcing default seccomp filter\\n\");\n}"
  },
  {
    "function_name": "start_application",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/sandbox.c",
    "lines": "296-393",
    "snippet": "void start_application(void) {\n//if (setsid() == -1)\n//errExit(\"setsid\");\n\n\t// set environment\n\tenv_defaults();\n\tenv_apply();\n\tif (arg_debug) {\n\t\tprintf(\"starting application\\n\");\n\t\tprintf(\"LD_PRELOAD=%s\\n\", getenv(\"LD_PRELOAD\"));\n\t}\n\n\t//****************************************\n\t// audit\n\t//****************************************\n\tif (arg_audit) {\n\t\tassert(arg_audit_prog);\n\t\tstruct stat s;\n\t\tif (stat(arg_audit_prog, &s) != 0) {\n\t\t\tfprintf(stderr, \"Error: cannot find the audit program\\n\");\n\t\t\texit(1);\n\t\t}\n\t\texecl(arg_audit_prog, arg_audit_prog, NULL);\n\t}\n\t//****************************************\n\t// start the program without using a shell\n\t//****************************************\n\telse if (arg_shell_none) {\n\t\tif (arg_debug) {\n\t\t\tint i;\n\t\t\tfor (i = cfg.original_program_index; i < cfg.original_argc; i++) {\n\t\t\t\tif (cfg.original_argv[i] == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tprintf(\"execvp argument %d: %s\\n\", i - cfg.original_program_index, cfg.original_argv[i]);\n\t\t\t}\n\t\t}\n\n\t\tif (cfg.original_program_index == 0) {\n\t\t\tfprintf(stderr, \"Error: --shell=none configured, but no program specified\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tif (!arg_command && !arg_quiet)\n\t\t\tprintf(\"Child process initialized\\n\");\n\n\t\texecvp(cfg.original_argv[cfg.original_program_index], &cfg.original_argv[cfg.original_program_index]);\n\t\texit(1);\n\t}\n\t//****************************************\n\t// start the program using a shell\n\t//****************************************\n\telse {\n\t\tassert(cfg.shell);\n\t\tassert(cfg.command_line);\n\n\t\tchar *arg[5];\n\t\tint index = 0;\n\t\targ[index++] = cfg.shell;\n\t\tif (login_shell) {\n\t\t\targ[index++] = \"-l\";\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Starting %s login shell\\n\", cfg.shell);\n\t\t} else {\n\t\t\targ[index++] = \"-c\";\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Running %s command through %s\\n\", cfg.command_line, cfg.shell);\n\t\t\tif (arg_doubledash)\n\t\t\t\targ[index++] = \"--\";\n\t\t\targ[index++] = cfg.command_line;\n\t\t}\n\t\targ[index] = NULL;\n\t\tassert(index < 5);\n\n\t\tif (arg_debug) {\n\t\t\tchar *msg;\n\t\t\tif (asprintf(&msg, \"sandbox %d, execvp into %s\", sandbox_pid, cfg.command_line) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tlogmsg(msg);\n\t\t\tfree(msg);\n\t\t}\n\n\t\tif (arg_debug) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < 5; i++) {\n\t\t\t\tif (arg[i] == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tprintf(\"execvp argument %d: %s\\n\", i, arg[i]);\n\t\t\t}\n\t\t}\n\n\t\tif (!arg_command && !arg_quiet)\n\t\t\tprintf(\"Child process initialized\\n\");\n\t\texecvp(arg[0], arg);\n\t}\n\n\tperror(\"execvp\");\n\texit(1); // it should never get here!!!\n}",
    "includes": [
      "#include <sys/apparmor.h>",
      "#include <sys/prctl.h>",
      "#include <sched.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/prctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "myexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/main.c",
          "lines": "137-149",
          "snippet": "static void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}",
          "includes": [
            "#include <sys/times.h>",
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int arg_command = 0;",
            "int arg_quiet = 0;",
            "pid_t sandbox_pid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/times.h>\n#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nint arg_command = 0;\nint arg_quiet = 0;\npid_t sandbox_pid;\n\nstatic void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}"
        }
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"execvp\""
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execvp",
          "args": [
            "arg[0]",
            "arg"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Child process initialized\\n\""
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"execvp argument %d: %s\\n\"",
            "i",
            "arg[i]"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "msg"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logmsg",
          "args": [
            "msg"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "logmsg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/util.c",
          "lines": "131-138",
          "snippet": "void logmsg(const char *msg) {\n\tif (!arg_debug)\n\t\treturn;\n\n\topenlog(\"firejail\", LOG_NDELAY | LOG_PID, LOG_USER);\n\tsyslog(LOG_INFO, \"%s\\n\", msg);\n\tcloselog();\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid logmsg(const char *msg) {\n\tif (!arg_debug)\n\t\treturn;\n\n\topenlog(\"firejail\", LOG_NDELAY | LOG_PID, LOG_USER);\n\tsyslog(LOG_INFO, \"%s\\n\", msg);\n\tcloselog();\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&msg",
            "\"sandbox %d, execvp into %s\"",
            "sandbox_pid",
            "cfg.command_line"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "index < 5"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Running %s command through %s\\n\"",
            "cfg.command_line",
            "cfg.shell"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Starting %s login shell\\n\"",
            "cfg.shell"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "cfg.command_line"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "cfg.shell"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execvp",
          "args": [
            "cfg.original_argv[cfg.original_program_index]",
            "&cfg.original_argv[cfg.original_program_index]"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Child process initialized\\n\""
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: --shell=none configured, but no program specified\\n\""
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"execvp argument %d: %s\\n\"",
            "i - cfg.original_program_index",
            "cfg.original_argv[i]"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execl",
          "args": [
            "arg_audit_prog",
            "arg_audit_prog",
            "NULL"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot find the audit program\\n\""
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "arg_audit_prog",
            "&s"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "arg_audit_prog"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"LD_PRELOAD=%s\\n\"",
            "getenv(\"LD_PRELOAD\")"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"LD_PRELOAD\""
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"starting application\\n\""
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "env_apply",
          "args": [],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "env_apply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/env.c",
          "lines": "188-201",
          "snippet": "void env_apply(void) {\n\tEnv *env = envlist;\n\t\n\twhile (env) {\n\t\tif (env->op == SETENV) {\n\t\t\tif (setenv(env->name, env->value, 1) < 0)\n\t\t\t\terrExit(\"setenv\");\n\t\t}\n\t\telse if (env->op == RMENV) {\n\t\t\tunsetenv(env->name);\n\t\t}\n\t\tenv = env->next;\n\t}\n}",
          "includes": [
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Env *envlist = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nstatic Env *envlist = NULL;\n\nvoid env_apply(void) {\n\tEnv *env = envlist;\n\t\n\twhile (env) {\n\t\tif (env->op == SETENV) {\n\t\t\tif (setenv(env->name, env->value, 1) < 0)\n\t\t\t\terrExit(\"setenv\");\n\t\t}\n\t\telse if (env->op == RMENV) {\n\t\t\tunsetenv(env->name);\n\t\t}\n\t\tenv = env->next;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_defaults",
          "args": [],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "env_defaults",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/env.c",
          "lines": "118-143",
          "snippet": "void env_defaults(void) {\n\t// fix qt 4.8\n\tif (setenv(\"QT_X11_NO_MITSHM\", \"1\", 1) < 0)\n\t\terrExit(\"setenv\");\n//\tif (setenv(\"MOZ_NO_REMOTE, \"1\", 1) < 0)\n//\t\terrExit(\"setenv\");\n\tif (setenv(\"container\", \"firejail\", 1) < 0) // LXC sets container=lxc,\n\t\terrExit(\"setenv\");\n\tif (!cfg.shell)\n\t\tcfg.shell = guess_shell();\n\tif (cfg.shell && setenv(\"SHELL\", cfg.shell, 1) < 0)\n\t\terrExit(\"setenv\");\n\n\t// set prompt color to green\n\tchar *prompt = getenv(\"FIREJAIL_PROMPT\");\n\tif (prompt && strcmp(prompt, \"yes\") == 0) {\n\t\t//export PS1='\\[\\e[1;32m\\][\\u@\\h \\W]\\$\\[\\e[0m\\] '\n\t\tif (setenv(\"PROMPT_COMMAND\", \"export PS1=\\\"\\\\[\\\\e[1;32m\\\\][\\\\u@\\\\h \\\\W]\\\\$\\\\[\\\\e[0m\\\\] \\\"\", 1) < 0)\n\t\t\terrExit(\"setenv\");\n\t}\n\n\t// set the window title\n\tif (!arg_quiet)\n\t\tprintf(\"\\033]0;firejail %s\\007\", cfg.window_title);\n\tfflush(0);\n}",
          "includes": [
            "#include <dirent.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dirent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid env_defaults(void) {\n\t// fix qt 4.8\n\tif (setenv(\"QT_X11_NO_MITSHM\", \"1\", 1) < 0)\n\t\terrExit(\"setenv\");\n//\tif (setenv(\"MOZ_NO_REMOTE, \"1\", 1) < 0)\n//\t\terrExit(\"setenv\");\n\tif (setenv(\"container\", \"firejail\", 1) < 0) // LXC sets container=lxc,\n\t\terrExit(\"setenv\");\n\tif (!cfg.shell)\n\t\tcfg.shell = guess_shell();\n\tif (cfg.shell && setenv(\"SHELL\", cfg.shell, 1) < 0)\n\t\terrExit(\"setenv\");\n\n\t// set prompt color to green\n\tchar *prompt = getenv(\"FIREJAIL_PROMPT\");\n\tif (prompt && strcmp(prompt, \"yes\") == 0) {\n\t\t//export PS1='\\[\\e[1;32m\\][\\u@\\h \\W]\\$\\[\\e[0m\\] '\n\t\tif (setenv(\"PROMPT_COMMAND\", \"export PS1=\\\"\\\\[\\\\e[1;32m\\\\][\\\\u@\\\\h \\\\W]\\\\$\\\\[\\\\e[0m\\\\] \\\"\", 1) < 0)\n\t\t\terrExit(\"setenv\");\n\t}\n\n\t// set the window title\n\tif (!arg_quiet)\n\t\tprintf(\"\\033]0;firejail %s\\007\", cfg.window_title);\n\tfflush(0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/apparmor.h>\n#include <sys/prctl.h>\n#include <sched.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/prctl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid start_application(void) {\n//if (setsid() == -1)\n//errExit(\"setsid\");\n\n\t// set environment\n\tenv_defaults();\n\tenv_apply();\n\tif (arg_debug) {\n\t\tprintf(\"starting application\\n\");\n\t\tprintf(\"LD_PRELOAD=%s\\n\", getenv(\"LD_PRELOAD\"));\n\t}\n\n\t//****************************************\n\t// audit\n\t//****************************************\n\tif (arg_audit) {\n\t\tassert(arg_audit_prog);\n\t\tstruct stat s;\n\t\tif (stat(arg_audit_prog, &s) != 0) {\n\t\t\tfprintf(stderr, \"Error: cannot find the audit program\\n\");\n\t\t\texit(1);\n\t\t}\n\t\texecl(arg_audit_prog, arg_audit_prog, NULL);\n\t}\n\t//****************************************\n\t// start the program without using a shell\n\t//****************************************\n\telse if (arg_shell_none) {\n\t\tif (arg_debug) {\n\t\t\tint i;\n\t\t\tfor (i = cfg.original_program_index; i < cfg.original_argc; i++) {\n\t\t\t\tif (cfg.original_argv[i] == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tprintf(\"execvp argument %d: %s\\n\", i - cfg.original_program_index, cfg.original_argv[i]);\n\t\t\t}\n\t\t}\n\n\t\tif (cfg.original_program_index == 0) {\n\t\t\tfprintf(stderr, \"Error: --shell=none configured, but no program specified\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tif (!arg_command && !arg_quiet)\n\t\t\tprintf(\"Child process initialized\\n\");\n\n\t\texecvp(cfg.original_argv[cfg.original_program_index], &cfg.original_argv[cfg.original_program_index]);\n\t\texit(1);\n\t}\n\t//****************************************\n\t// start the program using a shell\n\t//****************************************\n\telse {\n\t\tassert(cfg.shell);\n\t\tassert(cfg.command_line);\n\n\t\tchar *arg[5];\n\t\tint index = 0;\n\t\targ[index++] = cfg.shell;\n\t\tif (login_shell) {\n\t\t\targ[index++] = \"-l\";\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Starting %s login shell\\n\", cfg.shell);\n\t\t} else {\n\t\t\targ[index++] = \"-c\";\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Running %s command through %s\\n\", cfg.command_line, cfg.shell);\n\t\t\tif (arg_doubledash)\n\t\t\t\targ[index++] = \"--\";\n\t\t\targ[index++] = cfg.command_line;\n\t\t}\n\t\targ[index] = NULL;\n\t\tassert(index < 5);\n\n\t\tif (arg_debug) {\n\t\t\tchar *msg;\n\t\t\tif (asprintf(&msg, \"sandbox %d, execvp into %s\", sandbox_pid, cfg.command_line) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tlogmsg(msg);\n\t\t\tfree(msg);\n\t\t}\n\n\t\tif (arg_debug) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < 5; i++) {\n\t\t\t\tif (arg[i] == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tprintf(\"execvp argument %d: %s\\n\", i, arg[i]);\n\t\t\t}\n\t\t}\n\n\t\tif (!arg_command && !arg_quiet)\n\t\t\tprintf(\"Child process initialized\\n\");\n\t\texecvp(arg[0], arg);\n\t}\n\n\tperror(\"execvp\");\n\texit(1); // it should never get here!!!\n}"
  },
  {
    "function_name": "start_audit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/sandbox.c",
    "lines": "287-294",
    "snippet": "void start_audit(void) {\n\tchar *audit_prog;\n\tif (asprintf(&audit_prog, \"%s/firejail/faudit\", LIBDIR) == -1)\n\t\terrExit(\"asprintf\");\n\texecl(audit_prog, audit_prog, NULL);\n\tperror(\"execl\");\n\texit(1);\n}",
    "includes": [
      "#include <sys/apparmor.h>",
      "#include <sys/prctl.h>",
      "#include <sched.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/prctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "myexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/main.c",
          "lines": "137-149",
          "snippet": "static void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}",
          "includes": [
            "#include <sys/times.h>",
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int arg_command = 0;",
            "int arg_quiet = 0;",
            "pid_t sandbox_pid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/times.h>\n#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nint arg_command = 0;\nint arg_quiet = 0;\npid_t sandbox_pid;\n\nstatic void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}"
        }
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"execl\""
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execl",
          "args": [
            "audit_prog",
            "audit_prog",
            "NULL"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&audit_prog",
            "\"%s/firejail/faudit\"",
            "LIBDIR"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/apparmor.h>\n#include <sys/prctl.h>\n#include <sched.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/prctl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid start_audit(void) {\n\tchar *audit_prog;\n\tif (asprintf(&audit_prog, \"%s/firejail/faudit\", LIBDIR) == -1)\n\t\terrExit(\"asprintf\");\n\texecl(audit_prog, audit_prog, NULL);\n\tperror(\"execl\");\n\texit(1);\n}"
  },
  {
    "function_name": "monitor_application",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/sandbox.c",
    "lines": "188-285",
    "snippet": "static int monitor_application(pid_t app_pid) {\n\tmonitored_pid = app_pid;\n\tsignal (SIGTERM, sandbox_handler);\n\tEUID_USER();\n\n\tint status = 0;\n\twhile (monitored_pid) {\n\t\tusleep(20000);\n\t\tchar *msg;\n\t\tif (asprintf(&msg, \"monitoring pid %d\\n\", monitored_pid) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tlogmsg(msg);\n\t\tif (arg_debug)\n\t\t\tprintf(\"%s\\n\", msg);\n\t\tfree(msg);\n\n\t\tpid_t rv;\n\t\tdo {\n\t\t\trv = waitpid(-1, &status, 0);\n\t\t\tif (rv == -1)\n\t\t\t\tbreak;\n\t\t}\n\t\twhile(rv != monitored_pid);\n\t\tif (arg_debug)\n\t\t\tprintf(\"Sandbox monitor: waitpid %u retval %d status %d\\n\", monitored_pid, rv, status);\n\n\t\t// if /proc is not remounted, we cannot check /proc directory,\n\t\t// for now we just get out of here\n\t\t// todo: find another way of checking child processes!\n\t\tif (!checkcfg(CFG_REMOUNT_PROC_SYS))\n\t\t\tbreak;\n\n\t\tDIR *dir;\n\t\tif (!(dir = opendir(\"/proc\"))) {\n\t\t\t// sleep 2 seconds and try again\n\t\t\tsleep(2);\n\t\t\tif (!(dir = opendir(\"/proc\"))) {\n\t\t\t\tfprintf(stderr, \"Error: cannot open /proc directory\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\n\t\tstruct dirent *entry;\n\t\tmonitored_pid = 0;\n\t\twhile ((entry = readdir(dir)) != NULL) {\n\t\t\tunsigned pid;\n\t\t\tif (sscanf(entry->d_name, \"%u\", &pid) != 1)\n\t\t\t\tcontinue;\n\t\t\tif (pid == 1)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\t// todo: make this generic\n\t\t\t// Dillo browser leaves a dpid process running, we need to shut it down\n\t\t\tif (strcmp(cfg.command_name, \"dillo\") == 0) {\n\t\t\t\tchar *pidname = pid_proc_comm(pid);\n\t\t\t\tif (pidname && strcmp(pidname, \"dpid\") == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tfree(pidname);\n\t\t\t}\n\n\t\t\tmonitored_pid = pid;\n\t\t\tbreak;\n\t\t}\n\t\tclosedir(dir);\n\n\t\tif (monitored_pid != 0 && arg_debug)\n\t\t\tprintf(\"Sandbox monitor: monitoring %u\\n\", monitored_pid);\n\t}\n\n\t// return the latest exit status.\n\treturn status;\n\n#if 0\n// todo: find a way to shut down interfaces before closing the namespace\n// the problem is we don't have enough privileges to shutdown interfaces in this moment\n\t// shut down bridge/macvlan interfaces\n\tif (any_bridge_configured()) {\n\t\t\n\t\tif (cfg.bridge0.configured) {\n\t\t\tprintf(\"Shutting down %s\\n\", cfg.bridge0.devsandbox);\n\t\t\tnet_if_down( cfg.bridge0.devsandbox);\n\t\t}\n\t\tif (cfg.bridge1.configured) {\n\t\t\tprintf(\"Shutting down %s\\n\", cfg.bridge1.devsandbox);\n\t\t\tnet_if_down( cfg.bridge1.devsandbox);\n\t\t}\n\t\tif (cfg.bridge2.configured) {\n\t\t\tprintf(\"Shutting down %s\\n\", cfg.bridge2.devsandbox);\n\t\t\tnet_if_down( cfg.bridge2.devsandbox);\n\t\t}\n\t\tif (cfg.bridge3.configured) {\n\t\t\tprintf(\"Shutting down %s\\n\", cfg.bridge3.devsandbox);\n\t\t\tnet_if_down( cfg.bridge3.devsandbox);\n\t\t}\n\t\tusleep(20000);\t// 20 ms sleep\n\t}\t\n#endif\t\n}",
    "includes": [
      "#include <sys/apparmor.h>",
      "#include <sys/prctl.h>",
      "#include <sched.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/prctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int monitored_pid = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "20000"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_if_down",
          "args": [
            "cfg.bridge3.devsandbox"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "net_if_down",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/network.c",
          "lines": "248-281",
          "snippet": "void net_if_down(const char *ifname) {\n\tif (strlen(ifname) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error: invalid network device name %s\\n\", ifname);\n\t\texit(1);\n\t}\n\t\n\tint sock = socket(AF_INET,SOCK_DGRAM,0);\n\tif (sock < 0)\n\t\terrExit(\"socket\");\n\n\t// get the existing interface flags\n\tstruct ifreq ifr;\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ);\n\tifr.ifr_addr.sa_family = AF_INET;\n\n\t// read the existing flags\n\tif (ioctl(sock, SIOCGIFFLAGS, &ifr ) < 0) {\n\t\tclose(sock);\n\t\tprintf(\"Error: cannot shut down interface %s\\n\", ifname);\n\t\terrExit(\"ioctl\");\n\t}\n\n\tifr.ifr_flags &= ~IFF_UP;\n\n\t// set the new flags\n\tif (ioctl( sock, SIOCSIFFLAGS, &ifr ) < 0) {\n\t\tclose(sock);\n\t\tprintf(\"Error: cannot shut down interface %s\\n\", ifname);\n\t\terrExit(\"ioctl\");\n\t}\n\n\tclose(sock);\n}",
          "includes": [
            "#include <linux/if_bridge.h>",
            "#include <net/route.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <ifaddrs.h>",
            "#include <netdb.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <arpa/inet.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"firejail.h\"\n\nvoid net_if_down(const char *ifname) {\n\tif (strlen(ifname) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error: invalid network device name %s\\n\", ifname);\n\t\texit(1);\n\t}\n\t\n\tint sock = socket(AF_INET,SOCK_DGRAM,0);\n\tif (sock < 0)\n\t\terrExit(\"socket\");\n\n\t// get the existing interface flags\n\tstruct ifreq ifr;\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ);\n\tifr.ifr_addr.sa_family = AF_INET;\n\n\t// read the existing flags\n\tif (ioctl(sock, SIOCGIFFLAGS, &ifr ) < 0) {\n\t\tclose(sock);\n\t\tprintf(\"Error: cannot shut down interface %s\\n\", ifname);\n\t\terrExit(\"ioctl\");\n\t}\n\n\tifr.ifr_flags &= ~IFF_UP;\n\n\t// set the new flags\n\tif (ioctl( sock, SIOCSIFFLAGS, &ifr ) < 0) {\n\t\tclose(sock);\n\t\tprintf(\"Error: cannot shut down interface %s\\n\", ifname);\n\t\terrExit(\"ioctl\");\n\t}\n\n\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Shutting down %s\\n\"",
            "cfg.bridge3.devsandbox"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Shutting down %s\\n\"",
            "cfg.bridge2.devsandbox"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Shutting down %s\\n\"",
            "cfg.bridge1.devsandbox"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Shutting down %s\\n\"",
            "cfg.bridge0.devsandbox"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "any_bridge_configured",
          "args": [],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "any_bridge_configured",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/firejail.h",
          "lines": "257-262",
          "snippet": "static inline int any_bridge_configured(void) {\n\tif (cfg.bridge0.configured || cfg.bridge1.configured || cfg.bridge2.configured || cfg.bridge3.configured)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include \"../include/euid_common.h\"",
            "#include \"../include/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../include/euid_common.h\"\n#include \"../include/common.h\"\n\nstatic inline int any_bridge_configured(void) {\n\tif (cfg.bridge0.configured || cfg.bridge1.configured || cfg.bridge2.configured || cfg.bridge3.configured)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Sandbox monitor: monitoring %u\\n\"",
            "monitored_pid"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "dir"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "pidname"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "pidname",
            "\"dpid\""
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pid_proc_comm",
          "args": [
            "pid"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cfg.command_name",
            "\"dillo\""
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "entry->d_name",
            "\"%u\"",
            "&pid"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readdir",
          "args": [
            "dir"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "myexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/main.c",
          "lines": "137-149",
          "snippet": "static void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}",
          "includes": [
            "#include <sys/times.h>",
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int arg_command = 0;",
            "int arg_quiet = 0;",
            "pid_t sandbox_pid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/times.h>\n#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nint arg_command = 0;\nint arg_quiet = 0;\npid_t sandbox_pid;\n\nstatic void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot open /proc directory\\n\""
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opendir",
          "args": [
            "\"/proc\""
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sleep",
          "args": [
            "2"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opendir",
          "args": [
            "\"/proc\""
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "checkcfg",
          "args": [
            "CFG_REMOUNT_PROC_SYS"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "checkcfg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/checkcfg.c",
          "lines": "32-286",
          "snippet": "int checkcfg(int val) {\n\tassert(val < CFG_MAX);\n\tint line = 0;\n\n\tif (!initialized) {\n\t\t// initialize defaults\n\t\tint i;\n\t\tfor (i = 0; i < CFG_MAX; i++)\n\t\t\tcfg_val[i] = 1; // most of them are enabled by default\n\t\tcfg_val[CFG_RESTRICTED_NETWORK] = 0; // disabled by default\n\t\tcfg_val[CFG_FORCE_NONEWPRIVS] = 0; // disabled by default\n\t\tcfg_val[CFG_PRIVATE_BIN_NO_LOCAL] = 0; // disabled by default\n\t\t\n\t\t// open configuration file\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"%s/firejail.config\", SYSCONFDIR) == -1)\n\t\t\terrExit(\"asprintf\");\n\n\t\tFILE *fp = fopen(fname, \"r\");\n\t\tif (!fp) {\n#ifdef HAVE_GLOBALCFG\t\t\t\n\t\t\tfprintf(stderr, \"Error: Firejail configuration file %s not found\\n\", fname);\n\t\t\texit(1);\n#else\n\t\t\tinitialized = 1;\n\t\t\treturn\tcfg_val[val];\n#endif\t\n\t\t}\n\t\t\n\t\t// if the file exists, it should be owned by root\n\t\tstruct stat s;\n\t\tif (stat(fname, &s) == -1)\n\t\t\terrExit(\"stat\");\n\t\tif (s.st_uid != 0) {\n\t\t\tfprintf(stderr, \"Error: configuration file should be owned by root\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\t// read configuration file\n\t\tchar buf[MAX_READ];\n\t\twhile (fgets(buf,MAX_READ, fp)) {\n\t\t\tline++;\n\t\t\tif (*buf == '#' || *buf == '\\n') \n\t\t\t\tcontinue;\n\n\t\t\t// parse line\t\t\t\t\n\t\t\tchar *ptr = line_remove_spaces(buf);\n\t\t\tif (!ptr)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\t// file transfer\t\n\t\t\tif (strncmp(ptr, \"file-transfer \", 14) == 0) {\n\t\t\t\tif (strcmp(ptr + 14, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_FILE_TRANSFER] = 1;\n\t\t\t\telse if (strcmp(ptr + 14, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_FILE_TRANSFER] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// x11\n\t\t\telse if (strncmp(ptr, \"x11 \", 4) == 0) {\n\t\t\t\tif (strcmp(ptr + 4, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_X11] = 1;\n\t\t\t\telse if (strcmp(ptr + 4, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_X11] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// bind\n\t\t\telse if (strncmp(ptr, \"bind \", 5) == 0) {\n\t\t\t\tif (strcmp(ptr + 5, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_BIND] = 1;\n\t\t\t\telse if (strcmp(ptr + 5, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_BIND] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// user namespace\n\t\t\telse if (strncmp(ptr, \"userns \", 7) == 0) {\n\t\t\t\tif (strcmp(ptr + 7, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_USERNS] = 1;\n\t\t\t\telse if (strcmp(ptr + 7, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_USERNS] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// chroot\n\t\t\telse if (strncmp(ptr, \"chroot \", 7) == 0) {\n\t\t\t\tif (strcmp(ptr + 7, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_CHROOT] = 1;\n\t\t\t\telse if (strcmp(ptr + 7, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_CHROOT] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// nonewprivs\n\t\t\telse if (strncmp(ptr, \"force-nonewprivs \", 17) == 0) {\n\t\t\t\tif (strcmp(ptr + 17, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_SECCOMP] = 1;\n\t\t\t\telse if (strcmp(ptr + 17, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_SECCOMP] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// seccomp\n\t\t\telse if (strncmp(ptr, \"seccomp \", 8) == 0) {\n\t\t\t\tif (strcmp(ptr + 8, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_SECCOMP] = 1;\n\t\t\t\telse if (strcmp(ptr + 8, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_SECCOMP] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// whitelist\n\t\t\telse if (strncmp(ptr, \"whitelist \", 10) == 0) {\n\t\t\t\tif (strcmp(ptr + 10, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_WHITELIST] = 1;\n\t\t\t\telse if (strcmp(ptr + 10, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_WHITELIST] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// network\n\t\t\telse if (strncmp(ptr, \"network \", 8) == 0) {\n\t\t\t\tif (strcmp(ptr + 8, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_NETWORK] = 1;\n\t\t\t\telse if (strcmp(ptr + 8, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_NETWORK] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// network\n\t\t\telse if (strncmp(ptr, \"restricted-network \", 19) == 0) {\n\t\t\t\tif (strcmp(ptr + 19, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_RESTRICTED_NETWORK] = 1;\n\t\t\t\telse if (strcmp(ptr + 19, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_RESTRICTED_NETWORK] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// netfilter\n\t\t\telse if (strncmp(ptr, \"netfilter-default \", 18) == 0) {\n\t\t\t\tchar *fname = ptr + 18;\n\t\t\t\twhile (*fname == ' ' || *fname == '\\t')\n\t\t\t\t\tptr++;\n\t\t\t\tchar *end = strchr(fname, ' ');\n\t\t\t\tif (end)\n\t\t\t\t\t*end = '\\0';\n\t\t\t\t\n\t\t\t\t// is the file present?\n\t\t\t\tstruct stat s;\n\t\t\t\tif (stat(fname, &s) == -1) {\n\t\t\t\t\tfprintf(stderr, \"Error: netfilter-default file %s not available\\n\", fname);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tnetfilter_default = strdup(fname);\n\t\t\t\tif (!netfilter_default)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t\tif (arg_debug)\n\t\t\t\t\tprintf(\"netfilter default file %s\\n\", fname);\n\t\t\t}\n\t\t\t\n\t\t\t// Xephyr screen size\n\t\t\telse if (strncmp(ptr, \"xephyr-screen \", 14) == 0) {\n\t\t\t\t// expecting two numbers and an x between them\n\t\t\t\tint n1;\n\t\t\t\tint n2;\n\t\t\t\tint rv = sscanf(ptr + 14, \"%dx%d\", &n1, &n2);\n\t\t\t\tif (rv != 2)\n\t\t\t\t\tgoto errout;\n\t\t\t\tif (asprintf(&xephyr_screen, \"%dx%d\", n1, n2) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t}\n\t\n\t\t\t// xephyr window title\n\t\t\telse if (strncmp(ptr, \"xephyr-window-title \", 20) == 0) {\n\t\t\t\tif (strcmp(ptr + 20, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_XEPHYR_WINDOW_TITLE] = 1;\n\t\t\t\telse if (strcmp(ptr + 20, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_XEPHYR_WINDOW_TITLE] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t\t\n\t\t\t// Xephyr command extra parameters\n\t\t\telse if (strncmp(ptr, \"xephyr-extra-params \", 19) == 0) {\n\t\t\t\txephyr_extra_params = strdup(ptr + 19);\n\t\t\t\tif (!xephyr_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\t\t\t\n\t\t\t// quiet by default\n\t\t\telse if (strncmp(ptr, \"quiet-by-default \", 17) == 0) {\n\t\t\t\tif (strcmp(ptr + 17, \"yes\") == 0)\n\t\t\t\t\targ_quiet = 1;\n\t\t\t}\n\t\t\t// remount /proc and /sys\n\t\t\telse if (strncmp(ptr, \"remount-proc-sys \", 17) == 0) {\n\t\t\t\tif (strcmp(ptr + 17, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_REMOUNT_PROC_SYS] = 1;\n\t\t\t\telse if (strcmp(ptr + 17, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_REMOUNT_PROC_SYS] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\telse if (strncmp(ptr, \"overlayfs \", 10) == 0) {\n\t\t\t\tif (strcmp(ptr + 10, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_OVERLAYFS] = 1;\n\t\t\t\telse if (strcmp(ptr + 10, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_OVERLAYFS] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\telse if (strncmp(ptr, \"private-home \", 13) == 0) {\n\t\t\t\tif (strcmp(ptr + 13, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_PRIVATE_HOME] = 1;\n\t\t\t\telse if (strcmp(ptr + 13, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_PRIVATE_HOME] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\telse if (strncmp(ptr, \"chroot-desktop \", 15) == 0) {\n\t\t\t\tif (strcmp(ptr + 15, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_CHROOT_DESKTOP] = 1;\n\t\t\t\telse if (strcmp(ptr + 15, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_CHROOT_DESKTOP] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\telse if (strncmp(ptr, \"private-bin-no-local \", 21) == 0) {\n\t\t\t\tif (strcmp(ptr + 21, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_PRIVATE_BIN_NO_LOCAL] = 1;\n\t\t\t\telse if (strcmp(ptr + 21, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_PRIVATE_BIN_NO_LOCAL] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\telse\n\t\t\t\tgoto errout;\n\n\t\t\tfree(ptr);\n\t\t}\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t\tinitialized = 1;\n\t}\n\t\n\treturn cfg_val[val];\n\t\nerrout:\n\tfprintf(stderr, \"Error: invalid line %d in firejail configuration file\\n\", line );\n\texit(1);\n}",
          "includes": [
            "#include <linux/loop.h>",
            "#include <sys/stat.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAX_READ 8192\t\t\t\t  // line buffer for profile files"
          ],
          "globals_used": [
            "static int initialized = 0;",
            "static int cfg_val[CFG_MAX];",
            "char *xephyr_screen = \"800x600\";",
            "char *xephyr_extra_params = \"\";",
            "char *netfilter_default = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/loop.h>\n#include <sys/stat.h>\n#include \"firejail.h\"\n\n#define MAX_READ 8192\t\t\t\t  // line buffer for profile files\n\nstatic int initialized = 0;\nstatic int cfg_val[CFG_MAX];\nchar *xephyr_screen = \"800x600\";\nchar *xephyr_extra_params = \"\";\nchar *netfilter_default = NULL;\n\nint checkcfg(int val) {\n\tassert(val < CFG_MAX);\n\tint line = 0;\n\n\tif (!initialized) {\n\t\t// initialize defaults\n\t\tint i;\n\t\tfor (i = 0; i < CFG_MAX; i++)\n\t\t\tcfg_val[i] = 1; // most of them are enabled by default\n\t\tcfg_val[CFG_RESTRICTED_NETWORK] = 0; // disabled by default\n\t\tcfg_val[CFG_FORCE_NONEWPRIVS] = 0; // disabled by default\n\t\tcfg_val[CFG_PRIVATE_BIN_NO_LOCAL] = 0; // disabled by default\n\t\t\n\t\t// open configuration file\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"%s/firejail.config\", SYSCONFDIR) == -1)\n\t\t\terrExit(\"asprintf\");\n\n\t\tFILE *fp = fopen(fname, \"r\");\n\t\tif (!fp) {\n#ifdef HAVE_GLOBALCFG\t\t\t\n\t\t\tfprintf(stderr, \"Error: Firejail configuration file %s not found\\n\", fname);\n\t\t\texit(1);\n#else\n\t\t\tinitialized = 1;\n\t\t\treturn\tcfg_val[val];\n#endif\t\n\t\t}\n\t\t\n\t\t// if the file exists, it should be owned by root\n\t\tstruct stat s;\n\t\tif (stat(fname, &s) == -1)\n\t\t\terrExit(\"stat\");\n\t\tif (s.st_uid != 0) {\n\t\t\tfprintf(stderr, \"Error: configuration file should be owned by root\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\t// read configuration file\n\t\tchar buf[MAX_READ];\n\t\twhile (fgets(buf,MAX_READ, fp)) {\n\t\t\tline++;\n\t\t\tif (*buf == '#' || *buf == '\\n') \n\t\t\t\tcontinue;\n\n\t\t\t// parse line\t\t\t\t\n\t\t\tchar *ptr = line_remove_spaces(buf);\n\t\t\tif (!ptr)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\t// file transfer\t\n\t\t\tif (strncmp(ptr, \"file-transfer \", 14) == 0) {\n\t\t\t\tif (strcmp(ptr + 14, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_FILE_TRANSFER] = 1;\n\t\t\t\telse if (strcmp(ptr + 14, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_FILE_TRANSFER] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// x11\n\t\t\telse if (strncmp(ptr, \"x11 \", 4) == 0) {\n\t\t\t\tif (strcmp(ptr + 4, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_X11] = 1;\n\t\t\t\telse if (strcmp(ptr + 4, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_X11] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// bind\n\t\t\telse if (strncmp(ptr, \"bind \", 5) == 0) {\n\t\t\t\tif (strcmp(ptr + 5, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_BIND] = 1;\n\t\t\t\telse if (strcmp(ptr + 5, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_BIND] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// user namespace\n\t\t\telse if (strncmp(ptr, \"userns \", 7) == 0) {\n\t\t\t\tif (strcmp(ptr + 7, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_USERNS] = 1;\n\t\t\t\telse if (strcmp(ptr + 7, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_USERNS] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// chroot\n\t\t\telse if (strncmp(ptr, \"chroot \", 7) == 0) {\n\t\t\t\tif (strcmp(ptr + 7, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_CHROOT] = 1;\n\t\t\t\telse if (strcmp(ptr + 7, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_CHROOT] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// nonewprivs\n\t\t\telse if (strncmp(ptr, \"force-nonewprivs \", 17) == 0) {\n\t\t\t\tif (strcmp(ptr + 17, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_SECCOMP] = 1;\n\t\t\t\telse if (strcmp(ptr + 17, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_SECCOMP] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// seccomp\n\t\t\telse if (strncmp(ptr, \"seccomp \", 8) == 0) {\n\t\t\t\tif (strcmp(ptr + 8, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_SECCOMP] = 1;\n\t\t\t\telse if (strcmp(ptr + 8, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_SECCOMP] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// whitelist\n\t\t\telse if (strncmp(ptr, \"whitelist \", 10) == 0) {\n\t\t\t\tif (strcmp(ptr + 10, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_WHITELIST] = 1;\n\t\t\t\telse if (strcmp(ptr + 10, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_WHITELIST] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// network\n\t\t\telse if (strncmp(ptr, \"network \", 8) == 0) {\n\t\t\t\tif (strcmp(ptr + 8, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_NETWORK] = 1;\n\t\t\t\telse if (strcmp(ptr + 8, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_NETWORK] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// network\n\t\t\telse if (strncmp(ptr, \"restricted-network \", 19) == 0) {\n\t\t\t\tif (strcmp(ptr + 19, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_RESTRICTED_NETWORK] = 1;\n\t\t\t\telse if (strcmp(ptr + 19, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_RESTRICTED_NETWORK] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// netfilter\n\t\t\telse if (strncmp(ptr, \"netfilter-default \", 18) == 0) {\n\t\t\t\tchar *fname = ptr + 18;\n\t\t\t\twhile (*fname == ' ' || *fname == '\\t')\n\t\t\t\t\tptr++;\n\t\t\t\tchar *end = strchr(fname, ' ');\n\t\t\t\tif (end)\n\t\t\t\t\t*end = '\\0';\n\t\t\t\t\n\t\t\t\t// is the file present?\n\t\t\t\tstruct stat s;\n\t\t\t\tif (stat(fname, &s) == -1) {\n\t\t\t\t\tfprintf(stderr, \"Error: netfilter-default file %s not available\\n\", fname);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tnetfilter_default = strdup(fname);\n\t\t\t\tif (!netfilter_default)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t\tif (arg_debug)\n\t\t\t\t\tprintf(\"netfilter default file %s\\n\", fname);\n\t\t\t}\n\t\t\t\n\t\t\t// Xephyr screen size\n\t\t\telse if (strncmp(ptr, \"xephyr-screen \", 14) == 0) {\n\t\t\t\t// expecting two numbers and an x between them\n\t\t\t\tint n1;\n\t\t\t\tint n2;\n\t\t\t\tint rv = sscanf(ptr + 14, \"%dx%d\", &n1, &n2);\n\t\t\t\tif (rv != 2)\n\t\t\t\t\tgoto errout;\n\t\t\t\tif (asprintf(&xephyr_screen, \"%dx%d\", n1, n2) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t}\n\t\n\t\t\t// xephyr window title\n\t\t\telse if (strncmp(ptr, \"xephyr-window-title \", 20) == 0) {\n\t\t\t\tif (strcmp(ptr + 20, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_XEPHYR_WINDOW_TITLE] = 1;\n\t\t\t\telse if (strcmp(ptr + 20, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_XEPHYR_WINDOW_TITLE] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t\t\n\t\t\t// Xephyr command extra parameters\n\t\t\telse if (strncmp(ptr, \"xephyr-extra-params \", 19) == 0) {\n\t\t\t\txephyr_extra_params = strdup(ptr + 19);\n\t\t\t\tif (!xephyr_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\t\t\t\n\t\t\t// quiet by default\n\t\t\telse if (strncmp(ptr, \"quiet-by-default \", 17) == 0) {\n\t\t\t\tif (strcmp(ptr + 17, \"yes\") == 0)\n\t\t\t\t\targ_quiet = 1;\n\t\t\t}\n\t\t\t// remount /proc and /sys\n\t\t\telse if (strncmp(ptr, \"remount-proc-sys \", 17) == 0) {\n\t\t\t\tif (strcmp(ptr + 17, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_REMOUNT_PROC_SYS] = 1;\n\t\t\t\telse if (strcmp(ptr + 17, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_REMOUNT_PROC_SYS] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\telse if (strncmp(ptr, \"overlayfs \", 10) == 0) {\n\t\t\t\tif (strcmp(ptr + 10, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_OVERLAYFS] = 1;\n\t\t\t\telse if (strcmp(ptr + 10, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_OVERLAYFS] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\telse if (strncmp(ptr, \"private-home \", 13) == 0) {\n\t\t\t\tif (strcmp(ptr + 13, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_PRIVATE_HOME] = 1;\n\t\t\t\telse if (strcmp(ptr + 13, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_PRIVATE_HOME] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\telse if (strncmp(ptr, \"chroot-desktop \", 15) == 0) {\n\t\t\t\tif (strcmp(ptr + 15, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_CHROOT_DESKTOP] = 1;\n\t\t\t\telse if (strcmp(ptr + 15, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_CHROOT_DESKTOP] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\telse if (strncmp(ptr, \"private-bin-no-local \", 21) == 0) {\n\t\t\t\tif (strcmp(ptr + 21, \"yes\") == 0)\n\t\t\t\t\tcfg_val[CFG_PRIVATE_BIN_NO_LOCAL] = 1;\n\t\t\t\telse if (strcmp(ptr + 21, \"no\") == 0)\n\t\t\t\t\tcfg_val[CFG_PRIVATE_BIN_NO_LOCAL] = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\telse\n\t\t\t\tgoto errout;\n\n\t\t\tfree(ptr);\n\t\t}\n\n\t\tfclose(fp);\n\t\tfree(fname);\n\t\tinitialized = 1;\n\t}\n\t\n\treturn cfg_val[val];\n\t\nerrout:\n\tfprintf(stderr, \"Error: invalid line %d in firejail configuration file\\n\", line );\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Sandbox monitor: waitpid %u retval %d status %d\\n\"",
            "monitored_pid",
            "rv",
            "status"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "-1",
            "&status",
            "0"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "msg"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s\\n\"",
            "msg"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logmsg",
          "args": [
            "msg"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "logmsg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/util.c",
          "lines": "131-138",
          "snippet": "void logmsg(const char *msg) {\n\tif (!arg_debug)\n\t\treturn;\n\n\topenlog(\"firejail\", LOG_NDELAY | LOG_PID, LOG_USER);\n\tsyslog(LOG_INFO, \"%s\\n\", msg);\n\tcloselog();\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid logmsg(const char *msg) {\n\tif (!arg_debug)\n\t\treturn;\n\n\topenlog(\"firejail\", LOG_NDELAY | LOG_PID, LOG_USER);\n\tsyslog(LOG_INFO, \"%s\\n\", msg);\n\tcloselog();\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&msg",
            "\"monitoring pid %d\\n\"",
            "monitored_pid"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "20000"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_USER",
          "args": [],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGTERM",
            "sandbox_handler"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/apparmor.h>\n#include <sys/prctl.h>\n#include <sched.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/prctl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic int monitored_pid = 0;\n\nstatic int monitor_application(pid_t app_pid) {\n\tmonitored_pid = app_pid;\n\tsignal (SIGTERM, sandbox_handler);\n\tEUID_USER();\n\n\tint status = 0;\n\twhile (monitored_pid) {\n\t\tusleep(20000);\n\t\tchar *msg;\n\t\tif (asprintf(&msg, \"monitoring pid %d\\n\", monitored_pid) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tlogmsg(msg);\n\t\tif (arg_debug)\n\t\t\tprintf(\"%s\\n\", msg);\n\t\tfree(msg);\n\n\t\tpid_t rv;\n\t\tdo {\n\t\t\trv = waitpid(-1, &status, 0);\n\t\t\tif (rv == -1)\n\t\t\t\tbreak;\n\t\t}\n\t\twhile(rv != monitored_pid);\n\t\tif (arg_debug)\n\t\t\tprintf(\"Sandbox monitor: waitpid %u retval %d status %d\\n\", monitored_pid, rv, status);\n\n\t\t// if /proc is not remounted, we cannot check /proc directory,\n\t\t// for now we just get out of here\n\t\t// todo: find another way of checking child processes!\n\t\tif (!checkcfg(CFG_REMOUNT_PROC_SYS))\n\t\t\tbreak;\n\n\t\tDIR *dir;\n\t\tif (!(dir = opendir(\"/proc\"))) {\n\t\t\t// sleep 2 seconds and try again\n\t\t\tsleep(2);\n\t\t\tif (!(dir = opendir(\"/proc\"))) {\n\t\t\t\tfprintf(stderr, \"Error: cannot open /proc directory\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\n\t\tstruct dirent *entry;\n\t\tmonitored_pid = 0;\n\t\twhile ((entry = readdir(dir)) != NULL) {\n\t\t\tunsigned pid;\n\t\t\tif (sscanf(entry->d_name, \"%u\", &pid) != 1)\n\t\t\t\tcontinue;\n\t\t\tif (pid == 1)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\t// todo: make this generic\n\t\t\t// Dillo browser leaves a dpid process running, we need to shut it down\n\t\t\tif (strcmp(cfg.command_name, \"dillo\") == 0) {\n\t\t\t\tchar *pidname = pid_proc_comm(pid);\n\t\t\t\tif (pidname && strcmp(pidname, \"dpid\") == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tfree(pidname);\n\t\t\t}\n\n\t\t\tmonitored_pid = pid;\n\t\t\tbreak;\n\t\t}\n\t\tclosedir(dir);\n\n\t\tif (monitored_pid != 0 && arg_debug)\n\t\t\tprintf(\"Sandbox monitor: monitoring %u\\n\", monitored_pid);\n\t}\n\n\t// return the latest exit status.\n\treturn status;\n\n#if 0\n// todo: find a way to shut down interfaces before closing the namespace\n// the problem is we don't have enough privileges to shutdown interfaces in this moment\n\t// shut down bridge/macvlan interfaces\n\tif (any_bridge_configured()) {\n\t\t\n\t\tif (cfg.bridge0.configured) {\n\t\t\tprintf(\"Shutting down %s\\n\", cfg.bridge0.devsandbox);\n\t\t\tnet_if_down( cfg.bridge0.devsandbox);\n\t\t}\n\t\tif (cfg.bridge1.configured) {\n\t\t\tprintf(\"Shutting down %s\\n\", cfg.bridge1.devsandbox);\n\t\t\tnet_if_down( cfg.bridge1.devsandbox);\n\t\t}\n\t\tif (cfg.bridge2.configured) {\n\t\t\tprintf(\"Shutting down %s\\n\", cfg.bridge2.devsandbox);\n\t\t\tnet_if_down( cfg.bridge2.devsandbox);\n\t\t}\n\t\tif (cfg.bridge3.configured) {\n\t\t\tprintf(\"Shutting down %s\\n\", cfg.bridge3.devsandbox);\n\t\t\tnet_if_down( cfg.bridge3.devsandbox);\n\t\t}\n\t\tusleep(20000);\t// 20 ms sleep\n\t}\t\n#endif\t\n}"
  },
  {
    "function_name": "chk_chroot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/sandbox.c",
    "lines": "171-186",
    "snippet": "static void chk_chroot(void) {\n\t// if we are starting firejail inside some other container technology, we don't care about this\n\tchar *mycont = getenv(\"container\");\n\tif (mycont)\n\t\treturn;\n\t\n\t// check if this is a regular chroot\n\tstruct stat s;\n\tif (stat(\"/\", &s) == 0) {\n\t\tif (s.st_ino != 2)\n\t\t\treturn;\n\t}\n\t\n\tfprintf(stderr, \"Error: cannot mount filesystem as slave\\n\");\n\texit(1);\n}",
    "includes": [
      "#include <sys/apparmor.h>",
      "#include <sys/prctl.h>",
      "#include <sched.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/prctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "myexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/main.c",
          "lines": "137-149",
          "snippet": "static void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}",
          "includes": [
            "#include <sys/times.h>",
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int arg_command = 0;",
            "int arg_quiet = 0;",
            "pid_t sandbox_pid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/times.h>\n#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nint arg_command = 0;\nint arg_quiet = 0;\npid_t sandbox_pid;\n\nstatic void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot mount filesystem as slave\\n\""
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "\"/\"",
            "&s"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"container\""
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/apparmor.h>\n#include <sys/prctl.h>\n#include <sched.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/prctl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void chk_chroot(void) {\n\t// if we are starting firejail inside some other container technology, we don't care about this\n\tchar *mycont = getenv(\"container\");\n\tif (mycont)\n\t\treturn;\n\t\n\t// check if this is a regular chroot\n\tstruct stat s;\n\tif (stat(\"/\", &s) == 0) {\n\t\tif (s.st_ino != 2)\n\t\t\treturn;\n\t}\n\t\n\tfprintf(stderr, \"Error: cannot mount filesystem as slave\\n\");\n\texit(1);\n}"
  },
  {
    "function_name": "sandbox_if_up",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/sandbox.c",
    "lines": "121-169",
    "snippet": "static void sandbox_if_up(Bridge *br) {\n\tassert(br);\n\tif (!br->configured)\n\t\treturn;\n\t\t\n\tchar *dev = br->devsandbox;\n\tnet_if_up(dev);\n\n\tif (br->arg_ip_none == 1);\t// do nothing\n\telse if (br->arg_ip_none == 0 && br->macvlan == 0) {\n\t\tif (br->ipsandbox == br->ip) {\n\t\t\tfprintf(stderr, \"Error: %d.%d.%d.%d is interface %s address.\\n\", PRINT_IP(br->ipsandbox), br->dev);\n\t\t\texit(1);\n\t\t}\n\t\t\n\t\t// just assign the address\n\t\tassert(br->ipsandbox);\n\t\tif (arg_debug)\n\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(br->ipsandbox), dev);\n\t\tnet_if_ip(dev, br->ipsandbox, br->mask, br->mtu);\n\t\tnet_if_up(dev);\n\t}\n\telse if (br->arg_ip_none == 0 && br->macvlan == 1) {\n\t\t// reassign the macvlan address\n\t\tif (br->ipsandbox == 0)\n\t\t\t// ip address assigned by arp-scan for a macvlan device\n\t\t\tbr->ipsandbox = arp_assign(dev, br); //br->ip, br->mask);\n\t\telse {\n\t\t\tif (br->ipsandbox == br->ip) {\n\t\t\t\tfprintf(stderr, \"Error: %d.%d.%d.%d is interface %s address.\\n\", PRINT_IP(br->ipsandbox), br->dev);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t\n\t\t\tuint32_t rv = arp_check(dev, br->ipsandbox, br->ip);\n\t\t\tif (rv) {\n\t\t\t\tfprintf(stderr, \"Error: the address %d.%d.%d.%d is already in use.\\n\", PRINT_IP(br->ipsandbox));\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\t\t\n\t\tif (arg_debug)\n\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(br->ipsandbox), dev);\n\t\tnet_if_ip(dev, br->ipsandbox, br->mask, br->mtu);\n\t\tnet_if_up(dev);\n\t}\n\t\n\tif (br->ip6sandbox)\n\t\t net_if_ip6(dev, br->ip6sandbox);\n}",
    "includes": [
      "#include <sys/apparmor.h>",
      "#include <sys/prctl.h>",
      "#include <sched.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/prctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "net_if_ip6",
          "args": [
            "dev",
            "br->ip6sandbox"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "net_if_ip6",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/network.c",
          "lines": "290-349",
          "snippet": "void net_if_ip6(const char *ifname, const char *addr6) {\n\tif (strchr(addr6, ':') == NULL) {\n\t\tfprintf(stderr, \"Error: invalid IPv6 address %s\\n\", addr6);\n\t\texit(1);\n\t}\n\t\n\t// extract prefix\n\tunsigned long prefix;\n\tchar *ptr;\n\tif ((ptr = strchr(addr6, '/'))) {\n\t\tprefix = atol(ptr + 1);\n\t\tif (prefix > 128) {\n\t\t\tfprintf(stderr, \"Error: invalid prefix for IPv6 address %s\\n\", addr6);\n\t\t\texit(1);\n\t\t}\n\t\t*ptr = '\\0';\t// mark the end of the address\n\t}\n\telse\n\t\tprefix = 128;\n\n\t// extract address\n\tstruct sockaddr_in6 sin6;\n\tmemset(&sin6, 0, sizeof(sin6));\n\tsin6.sin6_family = AF_INET6;\n\tint rv = inet_pton(AF_INET6, addr6, sin6.sin6_addr.s6_addr);\n\tif (rv <= 0) {\n\t\tfprintf(stderr, \"Error: invalid IPv6 address %s\\n\", addr6);\n\t\texit(1);\n\t}\n\n\t// open socket\n\tint sock = socket(PF_INET6, SOCK_DGRAM, IPPROTO_IP);\n\tif (sock < 0) {\n\t\tfprintf(stderr, \"Error: IPv6 is not supported on this system\\n\");\n\t\texit(1);\n\t}\n\n\t// find interface index\n\tstruct ifreq ifr;\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ);\n\tifr.ifr_addr.sa_family = AF_INET;\n\tif (ioctl(sock, SIOGIFINDEX, &ifr) < 0) {\n\t\tperror(\"ioctl SIOGIFINDEX\");\n\t\texit(1);\n\t}\n\n\t// configure address\n\tstruct ifreq6 ifr6;\n\tmemset(&ifr6, 0, sizeof(ifr6));\n\tifr6.ifr6_prefixlen = prefix;\n\tifr6.ifr6_ifindex = ifr.ifr_ifindex;\n\tmemcpy((char *) &ifr6.ifr6_addr, (char *) &sin6.sin6_addr, sizeof(struct in6_addr));\n\tif (ioctl(sock, SIOCSIFADDR, &ifr6) < 0) {\n\t\tperror(\"ioctl SIOCSIFADDR\");\n\t\texit(1);\n\t}\n\t\n\tclose(sock);\n}",
          "includes": [
            "#include <linux/if_bridge.h>",
            "#include <net/route.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <ifaddrs.h>",
            "#include <netdb.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <arpa/inet.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"firejail.h\"\n\nvoid net_if_ip6(const char *ifname, const char *addr6) {\n\tif (strchr(addr6, ':') == NULL) {\n\t\tfprintf(stderr, \"Error: invalid IPv6 address %s\\n\", addr6);\n\t\texit(1);\n\t}\n\t\n\t// extract prefix\n\tunsigned long prefix;\n\tchar *ptr;\n\tif ((ptr = strchr(addr6, '/'))) {\n\t\tprefix = atol(ptr + 1);\n\t\tif (prefix > 128) {\n\t\t\tfprintf(stderr, \"Error: invalid prefix for IPv6 address %s\\n\", addr6);\n\t\t\texit(1);\n\t\t}\n\t\t*ptr = '\\0';\t// mark the end of the address\n\t}\n\telse\n\t\tprefix = 128;\n\n\t// extract address\n\tstruct sockaddr_in6 sin6;\n\tmemset(&sin6, 0, sizeof(sin6));\n\tsin6.sin6_family = AF_INET6;\n\tint rv = inet_pton(AF_INET6, addr6, sin6.sin6_addr.s6_addr);\n\tif (rv <= 0) {\n\t\tfprintf(stderr, \"Error: invalid IPv6 address %s\\n\", addr6);\n\t\texit(1);\n\t}\n\n\t// open socket\n\tint sock = socket(PF_INET6, SOCK_DGRAM, IPPROTO_IP);\n\tif (sock < 0) {\n\t\tfprintf(stderr, \"Error: IPv6 is not supported on this system\\n\");\n\t\texit(1);\n\t}\n\n\t// find interface index\n\tstruct ifreq ifr;\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ);\n\tifr.ifr_addr.sa_family = AF_INET;\n\tif (ioctl(sock, SIOGIFINDEX, &ifr) < 0) {\n\t\tperror(\"ioctl SIOGIFINDEX\");\n\t\texit(1);\n\t}\n\n\t// configure address\n\tstruct ifreq6 ifr6;\n\tmemset(&ifr6, 0, sizeof(ifr6));\n\tifr6.ifr6_prefixlen = prefix;\n\tifr6.ifr6_ifindex = ifr.ifr_ifindex;\n\tmemcpy((char *) &ifr6.ifr6_addr, (char *) &sin6.sin6_addr, sizeof(struct in6_addr));\n\tif (ioctl(sock, SIOCSIFADDR, &ifr6) < 0) {\n\t\tperror(\"ioctl SIOCSIFADDR\");\n\t\texit(1);\n\t}\n\t\n\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_if_up",
          "args": [
            "dev"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "net_if_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/network.c",
          "lines": "188-245",
          "snippet": "void net_if_up(const char *ifname) {\n\tif (strlen(ifname) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error: invalid network device name %s\\n\", ifname);\n\t\texit(1);\n\t}\n\t\n\tint sock = socket(AF_INET,SOCK_DGRAM,0);\n\tif (sock < 0)\n\t\terrExit(\"socket\");\n\n\t// get the existing interface flags\n\tstruct ifreq ifr;\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ);\n\tifr.ifr_addr.sa_family = AF_INET;\n\n\t// read the existing flags\n\tif (ioctl(sock, SIOCGIFFLAGS, &ifr ) < 0) {\n\t\tclose(sock);\n\t\tprintf(\"Error: cannot bring up interface %s\\n\", ifname);\n\t\terrExit(\"ioctl\");\n\t}\n\n\tifr.ifr_flags |= IFF_UP;\n\n\t// set the new flags\n\tif (ioctl( sock, SIOCSIFFLAGS, &ifr ) < 0) {\n\t\tclose(sock);\n\t\tprintf(\"Error: cannot bring up interface %s\\n\", ifname);\n\t\terrExit(\"ioctl\");\n\t}\n\n\t// checking\n\t// read the existing flags\n\tif (ioctl(sock, SIOCGIFFLAGS, &ifr ) < 0) {\n\t\tclose(sock);\n\t\tprintf(\"Error: cannot bring up interface %s\\n\", ifname);\n\t\terrExit(\"ioctl\");\n\t}\n\n\t// wait not more than 500ms for the interface to come up\n\tint cnt = 0;\n\twhile (cnt < 50) {\n\t\tusleep(10000);\t\t\t  // sleep 10ms\n\n\t\t// read the existing flags\n\t\tif (ioctl(sock, SIOCGIFFLAGS, &ifr ) < 0) {\n\t\t\tclose(sock);\n\t\t\tprintf(\"Error: cannot bring up interface %s\\n\", ifname);\n\t\t\terrExit(\"ioctl\");\n\t\t}\n\t\tif (ifr.ifr_flags & IFF_RUNNING)\n\t\t\tbreak;\n\t\tcnt++;\n\t}\n\n\tclose(sock);\n}",
          "includes": [
            "#include <linux/if_bridge.h>",
            "#include <net/route.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <ifaddrs.h>",
            "#include <netdb.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <arpa/inet.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"firejail.h\"\n\nvoid net_if_up(const char *ifname) {\n\tif (strlen(ifname) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error: invalid network device name %s\\n\", ifname);\n\t\texit(1);\n\t}\n\t\n\tint sock = socket(AF_INET,SOCK_DGRAM,0);\n\tif (sock < 0)\n\t\terrExit(\"socket\");\n\n\t// get the existing interface flags\n\tstruct ifreq ifr;\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ);\n\tifr.ifr_addr.sa_family = AF_INET;\n\n\t// read the existing flags\n\tif (ioctl(sock, SIOCGIFFLAGS, &ifr ) < 0) {\n\t\tclose(sock);\n\t\tprintf(\"Error: cannot bring up interface %s\\n\", ifname);\n\t\terrExit(\"ioctl\");\n\t}\n\n\tifr.ifr_flags |= IFF_UP;\n\n\t// set the new flags\n\tif (ioctl( sock, SIOCSIFFLAGS, &ifr ) < 0) {\n\t\tclose(sock);\n\t\tprintf(\"Error: cannot bring up interface %s\\n\", ifname);\n\t\terrExit(\"ioctl\");\n\t}\n\n\t// checking\n\t// read the existing flags\n\tif (ioctl(sock, SIOCGIFFLAGS, &ifr ) < 0) {\n\t\tclose(sock);\n\t\tprintf(\"Error: cannot bring up interface %s\\n\", ifname);\n\t\terrExit(\"ioctl\");\n\t}\n\n\t// wait not more than 500ms for the interface to come up\n\tint cnt = 0;\n\twhile (cnt < 50) {\n\t\tusleep(10000);\t\t\t  // sleep 10ms\n\n\t\t// read the existing flags\n\t\tif (ioctl(sock, SIOCGIFFLAGS, &ifr ) < 0) {\n\t\t\tclose(sock);\n\t\t\tprintf(\"Error: cannot bring up interface %s\\n\", ifname);\n\t\t\terrExit(\"ioctl\");\n\t\t}\n\t\tif (ifr.ifr_flags & IFF_RUNNING)\n\t\t\tbreak;\n\t\tcnt++;\n\t}\n\n\tclose(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_if_ip",
          "args": [
            "dev",
            "br->ipsandbox",
            "br->mask",
            "br->mtu"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "net_if_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/network.c",
          "lines": "352-394",
          "snippet": "void net_if_ip(const char *ifname, uint32_t ip, uint32_t mask, int mtu) {\n\tif (strlen(ifname) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error: invalid network device name %s\\n\", ifname);\n\t\texit(1);\n\t}\n\tif (arg_debug)\n\t\tprintf(\"configure interface %s\\n\", ifname);\n\n\tint sock = socket(AF_INET,SOCK_DGRAM,0);\n\tif (sock < 0)\n\t\terrExit(\"socket\");\n\n\tstruct ifreq ifr;\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ);\n\tifr.ifr_addr.sa_family = AF_INET;\n\n\t((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr.s_addr = htonl(ip);\n\tif (ioctl( sock, SIOCSIFADDR, &ifr ) < 0) {\n\t\tclose(sock);\n\t\terrExit(\"ioctl\");\n\t}\n\n\tif (ip != 0) {\n\t\t((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr.s_addr =  htonl(mask);\n\t\tif (ioctl( sock, SIOCSIFNETMASK, &ifr ) < 0) {\n\t\t\tclose(sock);\n\t\t\terrExit(\"ioctl\");\n\t\t}\n\t}\n\t\n\t// configure mtu\n\tif (mtu > 0) {\n\t\tifr.ifr_mtu = mtu;\n\t\tif (ioctl( sock, SIOCSIFMTU, &ifr ) < 0) {\n\t\t\tclose(sock);\n\t\t\terrExit(\"ioctl\");\n\t\t}\n\t}\n\n\tclose(sock);\n\tusleep(10000);\t\t\t\t  // sleep 10ms\n}",
          "includes": [
            "#include <linux/if_bridge.h>",
            "#include <net/route.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <ifaddrs.h>",
            "#include <netdb.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <arpa/inet.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_bridge.h>\n#include <net/route.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include \"firejail.h\"\n\nvoid net_if_ip(const char *ifname, uint32_t ip, uint32_t mask, int mtu) {\n\tif (strlen(ifname) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error: invalid network device name %s\\n\", ifname);\n\t\texit(1);\n\t}\n\tif (arg_debug)\n\t\tprintf(\"configure interface %s\\n\", ifname);\n\n\tint sock = socket(AF_INET,SOCK_DGRAM,0);\n\tif (sock < 0)\n\t\terrExit(\"socket\");\n\n\tstruct ifreq ifr;\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, ifname, IFNAMSIZ);\n\tifr.ifr_addr.sa_family = AF_INET;\n\n\t((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr.s_addr = htonl(ip);\n\tif (ioctl( sock, SIOCSIFADDR, &ifr ) < 0) {\n\t\tclose(sock);\n\t\terrExit(\"ioctl\");\n\t}\n\n\tif (ip != 0) {\n\t\t((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr.s_addr =  htonl(mask);\n\t\tif (ioctl( sock, SIOCSIFNETMASK, &ifr ) < 0) {\n\t\t\tclose(sock);\n\t\t\terrExit(\"ioctl\");\n\t\t}\n\t}\n\t\n\t// configure mtu\n\tif (mtu > 0) {\n\t\tifr.ifr_mtu = mtu;\n\t\tif (ioctl( sock, SIOCSIFMTU, &ifr ) < 0) {\n\t\t\tclose(sock);\n\t\t\terrExit(\"ioctl\");\n\t\t}\n\t}\n\n\tclose(sock);\n\tusleep(10000);\t\t\t\t  // sleep 10ms\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Configuring %d.%d.%d.%d address on interface %s\\n\"",
            "PRINT_IP(br->ipsandbox)",
            "dev"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_IP",
          "args": [
            "br->ipsandbox"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "myexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/main.c",
          "lines": "137-149",
          "snippet": "static void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}",
          "includes": [
            "#include <sys/times.h>",
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int arg_command = 0;",
            "int arg_quiet = 0;",
            "pid_t sandbox_pid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/times.h>\n#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nint arg_command = 0;\nint arg_quiet = 0;\npid_t sandbox_pid;\n\nstatic void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: the address %d.%d.%d.%d is already in use.\\n\"",
            "PRINT_IP(br->ipsandbox)"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_IP",
          "args": [
            "br->ipsandbox"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arp_check",
          "args": [
            "dev",
            "br->ipsandbox",
            "br->ip"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "arp_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/arp.c",
          "lines": "44-159",
          "snippet": "int arp_check(const char *dev, uint32_t destaddr, uint32_t srcaddr) {\n\tif (strlen(dev) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error: invalid network device name %s\\n\", dev);\n\t\texit(1);\n\t}\n\t\n\tif (arg_debug)\n\t\tprintf(\"Trying %d.%d.%d.%d ...\\n\", PRINT_IP(destaddr));\n\n\t// find interface address\n\tint sock;\n\tif ((sock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0)\n\t\terrExit(\"socket\");\n\n\tsrcaddr = htonl(srcaddr);\n\tdestaddr = htonl(destaddr);\n\n\t// Find interface MAC address\n\tstruct ifreq ifr;\n\tmemset(&ifr, 0, sizeof (ifr));\n\tstrncpy(ifr.ifr_name, dev, IFNAMSIZ);\n\tif (ioctl(sock, SIOCGIFHWADDR, &ifr) < 0)\n\t\terrExit(\"ioctl\");\n\tclose(sock);\n\t\n\t// configure layer2 socket address information\n\tstruct sockaddr_ll addr;\n\tmemset(&addr, 0, sizeof(addr));\n\tif ((addr.sll_ifindex = if_nametoindex(dev)) == 0)\n\t\terrExit(\"if_nametoindex\");\n\taddr.sll_family = AF_PACKET;\n\tmemcpy (addr.sll_addr, ifr.ifr_hwaddr.sa_data, 6);\n\taddr.sll_halen = htons(6);\n\n\t// build the arp packet header\n\tArpHdr hdr;\n\tmemset(&hdr, 0, sizeof(hdr));\n\thdr.htype = htons(1);\n\thdr.ptype = htons(ETH_P_IP);\n\thdr.hlen = 6;\n\thdr.plen = 4;\n\thdr.opcode = htons(1); //ARPOP_REQUEST\n\tmemcpy(hdr.sender_mac, ifr.ifr_hwaddr.sa_data, 6);\n\tmemcpy(hdr.sender_ip, (uint8_t *)&srcaddr, 4);\n\tmemcpy(hdr.target_ip, (uint8_t *)&destaddr, 4);\n\n\t// build ethernet frame\n\tuint8_t frame[ETH_FRAME_LEN]; // includes eht header, vlan, and crc\n\tmemset(frame, 0, sizeof(frame));\n\tframe[0] = frame[1] = frame[2] = frame[3] = frame[4] = frame[5] = 0xff;\n\tmemcpy(frame + 6, ifr.ifr_hwaddr.sa_data, 6);\n\tframe[12] = ETH_P_ARP / 256;\n\tframe[13] = ETH_P_ARP % 256;\n\tmemcpy (frame + 14, &hdr, sizeof(hdr));\n\n\t// open layer2 socket\n\tif ((sock = socket(PF_PACKET, SOCK_RAW, htons (ETH_P_ALL))) < 0)\n\t\terrExit(\"socket\");\n\n\tint len;\n\tif ((len = sendto (sock, frame, 14 + sizeof(ArpHdr), 0, (struct sockaddr *) &addr, sizeof (addr))) <= 0)\n\t\terrExit(\"send\");\n\tfflush(0);\n\t\t\n\t// wait not more than one second for an answer\n\tfd_set fds;\n\tFD_ZERO(&fds);\n\tFD_SET(sock, &fds);\n\tint maxfd = sock;\n\tstruct timeval ts;\n\tts.tv_sec = 1; // 1 second wait time\n\tts.tv_usec = 0;\n\twhile (1) {\n\t\tint nready = select(maxfd + 1,  &fds, (fd_set *) 0, (fd_set *) 0, &ts);\n\t\tif (nready < 0)\n\t\t\terrExit(\"select\");\n\t\telse if (nready == 0) { // timeout\n\t\t\tclose(sock);\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\t// read the incoming packet\n\t\t\tint len = recvfrom(sock, frame, ETH_FRAME_LEN, 0, NULL, NULL);\n\t\t\tif (len < 0) {\n\t\t\t\tperror(\"recvfrom\");\n\t\t\t\tclose(sock);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\n\t\t\t// parse the incoming packet\n\t\t\tif ((unsigned int) len < 14 + sizeof(ArpHdr))\n\t\t\t\tcontinue;\n\t\t\tif (frame[12] != (ETH_P_ARP / 256) || frame[13] != (ETH_P_ARP % 256))\n\t\t\t\tcontinue;\n\t\t\tmemcpy(&hdr, frame + 14, sizeof(ArpHdr));\n\t\t\tif (hdr.opcode == htons(1))\n\t\t\t\tcontinue;\n\t\t\tif (hdr.opcode == htons(2)) {\n\t\t\t\t// check my mac and my address\n\t\t\t\tif (memcmp(ifr.ifr_hwaddr.sa_data, hdr.target_mac, 6) != 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tuint32_t ip;\n\t\t\t\tmemcpy(&ip, hdr.target_ip, 4);\n\t\t\t\tif (ip != srcaddr) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\t\t\t\t\t\n\t\t\t\tclose(sock);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\t// it will never get here!\n\tclose(sock);\n\treturn -1;\n}",
          "includes": [
            "#include <linux/if_packet.h>",
            "#include <linux/tcp.h>",
            "#include <linux/udp.h>",
            "#include <linux/ip.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/if_ether.h>\t\t\t  //TCP/IP Protocol Suite for Linux",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_packet.h>\n#include <linux/tcp.h>\n#include <linux/udp.h>\n#include <linux/ip.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/if_ether.h>\t\t\t  //TCP/IP Protocol Suite for Linux\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include \"firejail.h\"\n\nint arp_check(const char *dev, uint32_t destaddr, uint32_t srcaddr) {\n\tif (strlen(dev) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error: invalid network device name %s\\n\", dev);\n\t\texit(1);\n\t}\n\t\n\tif (arg_debug)\n\t\tprintf(\"Trying %d.%d.%d.%d ...\\n\", PRINT_IP(destaddr));\n\n\t// find interface address\n\tint sock;\n\tif ((sock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0)\n\t\terrExit(\"socket\");\n\n\tsrcaddr = htonl(srcaddr);\n\tdestaddr = htonl(destaddr);\n\n\t// Find interface MAC address\n\tstruct ifreq ifr;\n\tmemset(&ifr, 0, sizeof (ifr));\n\tstrncpy(ifr.ifr_name, dev, IFNAMSIZ);\n\tif (ioctl(sock, SIOCGIFHWADDR, &ifr) < 0)\n\t\terrExit(\"ioctl\");\n\tclose(sock);\n\t\n\t// configure layer2 socket address information\n\tstruct sockaddr_ll addr;\n\tmemset(&addr, 0, sizeof(addr));\n\tif ((addr.sll_ifindex = if_nametoindex(dev)) == 0)\n\t\terrExit(\"if_nametoindex\");\n\taddr.sll_family = AF_PACKET;\n\tmemcpy (addr.sll_addr, ifr.ifr_hwaddr.sa_data, 6);\n\taddr.sll_halen = htons(6);\n\n\t// build the arp packet header\n\tArpHdr hdr;\n\tmemset(&hdr, 0, sizeof(hdr));\n\thdr.htype = htons(1);\n\thdr.ptype = htons(ETH_P_IP);\n\thdr.hlen = 6;\n\thdr.plen = 4;\n\thdr.opcode = htons(1); //ARPOP_REQUEST\n\tmemcpy(hdr.sender_mac, ifr.ifr_hwaddr.sa_data, 6);\n\tmemcpy(hdr.sender_ip, (uint8_t *)&srcaddr, 4);\n\tmemcpy(hdr.target_ip, (uint8_t *)&destaddr, 4);\n\n\t// build ethernet frame\n\tuint8_t frame[ETH_FRAME_LEN]; // includes eht header, vlan, and crc\n\tmemset(frame, 0, sizeof(frame));\n\tframe[0] = frame[1] = frame[2] = frame[3] = frame[4] = frame[5] = 0xff;\n\tmemcpy(frame + 6, ifr.ifr_hwaddr.sa_data, 6);\n\tframe[12] = ETH_P_ARP / 256;\n\tframe[13] = ETH_P_ARP % 256;\n\tmemcpy (frame + 14, &hdr, sizeof(hdr));\n\n\t// open layer2 socket\n\tif ((sock = socket(PF_PACKET, SOCK_RAW, htons (ETH_P_ALL))) < 0)\n\t\terrExit(\"socket\");\n\n\tint len;\n\tif ((len = sendto (sock, frame, 14 + sizeof(ArpHdr), 0, (struct sockaddr *) &addr, sizeof (addr))) <= 0)\n\t\terrExit(\"send\");\n\tfflush(0);\n\t\t\n\t// wait not more than one second for an answer\n\tfd_set fds;\n\tFD_ZERO(&fds);\n\tFD_SET(sock, &fds);\n\tint maxfd = sock;\n\tstruct timeval ts;\n\tts.tv_sec = 1; // 1 second wait time\n\tts.tv_usec = 0;\n\twhile (1) {\n\t\tint nready = select(maxfd + 1,  &fds, (fd_set *) 0, (fd_set *) 0, &ts);\n\t\tif (nready < 0)\n\t\t\terrExit(\"select\");\n\t\telse if (nready == 0) { // timeout\n\t\t\tclose(sock);\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\t// read the incoming packet\n\t\t\tint len = recvfrom(sock, frame, ETH_FRAME_LEN, 0, NULL, NULL);\n\t\t\tif (len < 0) {\n\t\t\t\tperror(\"recvfrom\");\n\t\t\t\tclose(sock);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\n\t\t\t// parse the incoming packet\n\t\t\tif ((unsigned int) len < 14 + sizeof(ArpHdr))\n\t\t\t\tcontinue;\n\t\t\tif (frame[12] != (ETH_P_ARP / 256) || frame[13] != (ETH_P_ARP % 256))\n\t\t\t\tcontinue;\n\t\t\tmemcpy(&hdr, frame + 14, sizeof(ArpHdr));\n\t\t\tif (hdr.opcode == htons(1))\n\t\t\t\tcontinue;\n\t\t\tif (hdr.opcode == htons(2)) {\n\t\t\t\t// check my mac and my address\n\t\t\t\tif (memcmp(ifr.ifr_hwaddr.sa_data, hdr.target_mac, 6) != 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tuint32_t ip;\n\t\t\t\tmemcpy(&ip, hdr.target_ip, 4);\n\t\t\t\tif (ip != srcaddr) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\t\t\t\t\t\n\t\t\t\tclose(sock);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\t// it will never get here!\n\tclose(sock);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: %d.%d.%d.%d is interface %s address.\\n\"",
            "PRINT_IP(br->ipsandbox)",
            "br->dev"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_IP",
          "args": [
            "br->ipsandbox"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arp_assign",
          "args": [
            "dev",
            "br"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "arp_assign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/arp.c",
          "lines": "266-287",
          "snippet": "uint32_t arp_assign(const char *dev, Bridge *br) {\n\tassert(br);\n\tuint32_t ip = 0;\n\n\t// try two random IP addresses\n\tip = arp_random(dev, br);\n\tif (!ip)\n\t\tip = arp_random(dev, br);\n\t\t\n\t// try all possible IP addresses one by one\n\tif (!ip)\n\t\tip = arp_sequential(dev, br);\n\t\n\t// print result\n\tif (!ip) {\n\t\tfprintf(stderr, \"Error: cannot assign an IP address; it looks like all of them are in use.\\n\");\n\t\tlogerr(\"Cannot assign an IP address; it looks like all of them are in use.\");\n\t\texit(1);\n\t}\n\t\n\treturn ip;\n}",
          "includes": [
            "#include <linux/if_packet.h>",
            "#include <linux/tcp.h>",
            "#include <linux/udp.h>",
            "#include <linux/ip.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <linux/if_ether.h>\t\t\t  //TCP/IP Protocol Suite for Linux",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/if_packet.h>\n#include <linux/tcp.h>\n#include <linux/udp.h>\n#include <linux/ip.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <linux/if_ether.h>\t\t\t  //TCP/IP Protocol Suite for Linux\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include \"firejail.h\"\n\nuint32_t arp_assign(const char *dev, Bridge *br) {\n\tassert(br);\n\tuint32_t ip = 0;\n\n\t// try two random IP addresses\n\tip = arp_random(dev, br);\n\tif (!ip)\n\t\tip = arp_random(dev, br);\n\t\t\n\t// try all possible IP addresses one by one\n\tif (!ip)\n\t\tip = arp_sequential(dev, br);\n\t\n\t// print result\n\tif (!ip) {\n\t\tfprintf(stderr, \"Error: cannot assign an IP address; it looks like all of them are in use.\\n\");\n\t\tlogerr(\"Cannot assign an IP address; it looks like all of them are in use.\");\n\t\texit(1);\n\t}\n\t\n\treturn ip;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Configuring %d.%d.%d.%d address on interface %s\\n\"",
            "PRINT_IP(br->ipsandbox)",
            "dev"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_IP",
          "args": [
            "br->ipsandbox"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "br->ipsandbox"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: %d.%d.%d.%d is interface %s address.\\n\"",
            "PRINT_IP(br->ipsandbox)",
            "br->dev"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_IP",
          "args": [
            "br->ipsandbox"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "br"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/apparmor.h>\n#include <sys/prctl.h>\n#include <sched.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/prctl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void sandbox_if_up(Bridge *br) {\n\tassert(br);\n\tif (!br->configured)\n\t\treturn;\n\t\t\n\tchar *dev = br->devsandbox;\n\tnet_if_up(dev);\n\n\tif (br->arg_ip_none == 1);\t// do nothing\n\telse if (br->arg_ip_none == 0 && br->macvlan == 0) {\n\t\tif (br->ipsandbox == br->ip) {\n\t\t\tfprintf(stderr, \"Error: %d.%d.%d.%d is interface %s address.\\n\", PRINT_IP(br->ipsandbox), br->dev);\n\t\t\texit(1);\n\t\t}\n\t\t\n\t\t// just assign the address\n\t\tassert(br->ipsandbox);\n\t\tif (arg_debug)\n\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(br->ipsandbox), dev);\n\t\tnet_if_ip(dev, br->ipsandbox, br->mask, br->mtu);\n\t\tnet_if_up(dev);\n\t}\n\telse if (br->arg_ip_none == 0 && br->macvlan == 1) {\n\t\t// reassign the macvlan address\n\t\tif (br->ipsandbox == 0)\n\t\t\t// ip address assigned by arp-scan for a macvlan device\n\t\t\tbr->ipsandbox = arp_assign(dev, br); //br->ip, br->mask);\n\t\telse {\n\t\t\tif (br->ipsandbox == br->ip) {\n\t\t\t\tfprintf(stderr, \"Error: %d.%d.%d.%d is interface %s address.\\n\", PRINT_IP(br->ipsandbox), br->dev);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t\n\t\t\tuint32_t rv = arp_check(dev, br->ipsandbox, br->ip);\n\t\t\tif (rv) {\n\t\t\t\tfprintf(stderr, \"Error: the address %d.%d.%d.%d is already in use.\\n\", PRINT_IP(br->ipsandbox));\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\t\t\n\t\tif (arg_debug)\n\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(br->ipsandbox), dev);\n\t\tnet_if_ip(dev, br->ipsandbox, br->mask, br->mtu);\n\t\tnet_if_up(dev);\n\t}\n\t\n\tif (br->ip6sandbox)\n\t\t net_if_ip6(dev, br->ip6sandbox);\n}"
  },
  {
    "function_name": "save_nogroups",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/sandbox.c",
    "lines": "104-119",
    "snippet": "void save_nogroups(void) {\n\tif (arg_nogroups == 0)\n\t\treturn;\n\n\tFILE *fp = fopen(RUN_GROUPS_CFG, \"w\");\n\tif (fp) {\n\t\tfprintf(fp, \"\\n\");\n\t\tSET_PERMS_STREAM(fp, 0, 0, 0644); // assume mode 0644\n\t\tfclose(fp);\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: cannot save nogroups state\\n\");\n\t\texit(1);\n\t}\n\t\n}",
    "includes": [
      "#include <sys/apparmor.h>",
      "#include <sys/prctl.h>",
      "#include <sched.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/prctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "myexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/main.c",
          "lines": "137-149",
          "snippet": "static void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}",
          "includes": [
            "#include <sys/times.h>",
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int arg_command = 0;",
            "int arg_quiet = 0;",
            "pid_t sandbox_pid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/times.h>\n#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nint arg_command = 0;\nint arg_quiet = 0;\npid_t sandbox_pid;\n\nstatic void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot save nogroups state\\n\""
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_PERMS_STREAM",
          "args": [
            "fp",
            "0",
            "0",
            "0644"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fp",
            "\"\\n\""
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "RUN_GROUPS_CFG",
            "\"w\""
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/apparmor.h>\n#include <sys/prctl.h>\n#include <sched.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/prctl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid save_nogroups(void) {\n\tif (arg_nogroups == 0)\n\t\treturn;\n\n\tFILE *fp = fopen(RUN_GROUPS_CFG, \"w\");\n\tif (fp) {\n\t\tfprintf(fp, \"\\n\");\n\t\tSET_PERMS_STREAM(fp, 0, 0, 0644); // assume mode 0644\n\t\tfclose(fp);\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: cannot save nogroups state\\n\");\n\t\texit(1);\n\t}\n\t\n}"
  },
  {
    "function_name": "set_caps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/sandbox.c",
    "lines": "93-102",
    "snippet": "static void set_caps(void) {\n\tif (arg_caps_drop_all)\n\t\tcaps_drop_all();\n\telse if (arg_caps_drop)\n\t\tcaps_drop_list(arg_caps_list);\n\telse if (arg_caps_keep)\n\t\tcaps_keep_list(arg_caps_list);\n\telse if (arg_caps_default_filter)\n\t\tcaps_default_filter();\n}",
    "includes": [
      "#include <sys/apparmor.h>",
      "#include <sys/prctl.h>",
      "#include <sched.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/prctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "caps_default_filter",
          "args": [],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "caps_default_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/caps.c",
          "lines": "268-313",
          "snippet": "int caps_default_filter(void) {\n\t// drop capabilities\n\tif (prctl(PR_CAPBSET_DROP, CAP_SYS_MODULE, 0, 0, 0) && arg_debug)\n\t\tfprintf(stderr, \"Warning: cannot drop CAP_SYS_MODULE\");\n\telse if (arg_debug)\n\t\tprintf(\"Drop CAP_SYS_MODULE\\n\");\n\n\tif (prctl(PR_CAPBSET_DROP, CAP_SYS_RAWIO, 0, 0, 0) && arg_debug)\n\t\tfprintf(stderr, \"Warning: cannot drop CAP_SYS_RAWIO\");\n\telse if (arg_debug)\n\t\tprintf(\"Drop CAP_SYS_RAWIO\\n\");\n\n\tif (prctl(PR_CAPBSET_DROP, CAP_SYS_BOOT, 0, 0, 0) && arg_debug)\n\t\tfprintf(stderr, \"Warning: cannot drop CAP_SYS_BOOT\");\n\telse if (arg_debug)\n\t\tprintf(\"Drop CAP_SYS_BOOT\\n\");\n\n\tif (prctl(PR_CAPBSET_DROP, CAP_SYS_NICE, 0, 0, 0) && arg_debug)\n\t\tfprintf(stderr, \"Warning: cannot drop CAP_SYS_NICE\");\n\telse if (arg_debug)\n\t\tprintf(\"Drop CAP_SYS_NICE\\n\");\n\n\tif (prctl(PR_CAPBSET_DROP, CAP_SYS_TTY_CONFIG, 0, 0, 0) && arg_debug)\n\t\tfprintf(stderr, \"Warning: cannot drop CAP_SYS_TTY_CONFIG\");\n\telse if (arg_debug)\n\t\tprintf(\"Drop CAP_SYS_TTY_CONFIG\\n\");\n\n#ifdef CAP_SYSLOG\n\tif (prctl(PR_CAPBSET_DROP, CAP_SYSLOG, 0, 0, 0) && arg_debug)\n\t\tfprintf(stderr, \"Warning: cannot drop CAP_SYSLOG\");\n\telse if (arg_debug)\n\t\tprintf(\"Drop CAP_SYSLOG\\n\");\n#endif\n\n\tif (prctl(PR_CAPBSET_DROP, CAP_MKNOD, 0, 0, 0) && arg_debug)\n\t\tfprintf(stderr, \"Warning: cannot drop CAP_MKNOD\");\n\telse if (arg_debug)\n\t\tprintf(\"Drop CAP_MKNOD\\n\");\n\n\tif (prctl(PR_CAPBSET_DROP, CAP_SYS_ADMIN, 0, 0, 0) && arg_debug)\n\t\tfprintf(stderr, \"Warning: cannot drop CAP_SYS_ADMIN\");\n\telse if (arg_debug)\n\t\tprintf(\"Drop CAP_SYS_ADMIN\\n\");\n\n\treturn 0;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>",
            "#include <stddef.h>",
            "#include <linux/filter.h>",
            "#include <errno.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n#include <stddef.h>\n#include <linux/filter.h>\n#include <errno.h>\n#include \"firejail.h\"\n\nint caps_default_filter(void) {\n\t// drop capabilities\n\tif (prctl(PR_CAPBSET_DROP, CAP_SYS_MODULE, 0, 0, 0) && arg_debug)\n\t\tfprintf(stderr, \"Warning: cannot drop CAP_SYS_MODULE\");\n\telse if (arg_debug)\n\t\tprintf(\"Drop CAP_SYS_MODULE\\n\");\n\n\tif (prctl(PR_CAPBSET_DROP, CAP_SYS_RAWIO, 0, 0, 0) && arg_debug)\n\t\tfprintf(stderr, \"Warning: cannot drop CAP_SYS_RAWIO\");\n\telse if (arg_debug)\n\t\tprintf(\"Drop CAP_SYS_RAWIO\\n\");\n\n\tif (prctl(PR_CAPBSET_DROP, CAP_SYS_BOOT, 0, 0, 0) && arg_debug)\n\t\tfprintf(stderr, \"Warning: cannot drop CAP_SYS_BOOT\");\n\telse if (arg_debug)\n\t\tprintf(\"Drop CAP_SYS_BOOT\\n\");\n\n\tif (prctl(PR_CAPBSET_DROP, CAP_SYS_NICE, 0, 0, 0) && arg_debug)\n\t\tfprintf(stderr, \"Warning: cannot drop CAP_SYS_NICE\");\n\telse if (arg_debug)\n\t\tprintf(\"Drop CAP_SYS_NICE\\n\");\n\n\tif (prctl(PR_CAPBSET_DROP, CAP_SYS_TTY_CONFIG, 0, 0, 0) && arg_debug)\n\t\tfprintf(stderr, \"Warning: cannot drop CAP_SYS_TTY_CONFIG\");\n\telse if (arg_debug)\n\t\tprintf(\"Drop CAP_SYS_TTY_CONFIG\\n\");\n\n#ifdef CAP_SYSLOG\n\tif (prctl(PR_CAPBSET_DROP, CAP_SYSLOG, 0, 0, 0) && arg_debug)\n\t\tfprintf(stderr, \"Warning: cannot drop CAP_SYSLOG\");\n\telse if (arg_debug)\n\t\tprintf(\"Drop CAP_SYSLOG\\n\");\n#endif\n\n\tif (prctl(PR_CAPBSET_DROP, CAP_MKNOD, 0, 0, 0) && arg_debug)\n\t\tfprintf(stderr, \"Warning: cannot drop CAP_MKNOD\");\n\telse if (arg_debug)\n\t\tprintf(\"Drop CAP_MKNOD\\n\");\n\n\tif (prctl(PR_CAPBSET_DROP, CAP_SYS_ADMIN, 0, 0, 0) && arg_debug)\n\t\tfprintf(stderr, \"Warning: cannot drop CAP_SYS_ADMIN\");\n\telse if (arg_debug)\n\t\tprintf(\"Drop CAP_SYS_ADMIN\\n\");\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "caps_keep_list",
          "args": [
            "arg_caps_list"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "caps_keep_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/caps.c",
          "lines": "362-366",
          "snippet": "void caps_keep_list(const char *clist) {\n\tfilter = 0;\n\tcaps_check_list(clist, caps_set_bit);\n\tcaps_set(filter);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>",
            "#include <stddef.h>",
            "#include <linux/filter.h>",
            "#include <errno.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static uint64_t filter;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n#include <stddef.h>\n#include <linux/filter.h>\n#include <errno.h>\n#include \"firejail.h\"\n\nstatic uint64_t filter;\n\nvoid caps_keep_list(const char *clist) {\n\tfilter = 0;\n\tcaps_check_list(clist, caps_set_bit);\n\tcaps_set(filter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "caps_drop_list",
          "args": [
            "arg_caps_list"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "caps_drop_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/caps.c",
          "lines": "355-360",
          "snippet": "void caps_drop_list(const char *clist) {\n\tfilter = 0;\n\tfilter--;\n\tcaps_check_list(clist, caps_reset_bit);\n\tcaps_set(filter);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>",
            "#include <stddef.h>",
            "#include <linux/filter.h>",
            "#include <errno.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static uint64_t filter;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n#include <stddef.h>\n#include <linux/filter.h>\n#include <errno.h>\n#include \"firejail.h\"\n\nstatic uint64_t filter;\n\nvoid caps_drop_list(const char *clist) {\n\tfilter = 0;\n\tfilter--;\n\tcaps_check_list(clist, caps_reset_bit);\n\tcaps_set(filter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "caps_drop_all",
          "args": [],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "caps_drop_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/caps.c",
          "lines": "315-325",
          "snippet": "void caps_drop_all(void) {\n\tif (arg_debug)\n\t\tprintf(\"Dropping all capabilities\\n\");\n\n\tunsigned long cap;\n\tfor (cap=0; cap <= 63; cap++) {\n\t\tint code = prctl(PR_CAPBSET_DROP, cap, 0, 0, 0);\n\t\tif (code == -1 && errno != EINVAL)\n\t\t\terrExit(\"PR_CAPBSET_DROP\");\n\t}\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/prctl.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>",
            "#include <stddef.h>",
            "#include <linux/filter.h>",
            "#include <errno.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/prctl.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n#include <stddef.h>\n#include <linux/filter.h>\n#include <errno.h>\n#include \"firejail.h\"\n\nvoid caps_drop_all(void) {\n\tif (arg_debug)\n\t\tprintf(\"Dropping all capabilities\\n\");\n\n\tunsigned long cap;\n\tfor (cap=0; cap <= 63; cap++) {\n\t\tint code = prctl(PR_CAPBSET_DROP, cap, 0, 0, 0);\n\t\tif (code == -1 && errno != EINVAL)\n\t\t\terrExit(\"PR_CAPBSET_DROP\");\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/apparmor.h>\n#include <sys/prctl.h>\n#include <sched.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/prctl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void set_caps(void) {\n\tif (arg_caps_drop_all)\n\t\tcaps_drop_all();\n\telse if (arg_caps_drop)\n\t\tcaps_drop_list(arg_caps_list);\n\telse if (arg_caps_keep)\n\t\tcaps_keep_list(arg_caps_list);\n\telse if (arg_caps_default_filter)\n\t\tcaps_default_filter();\n}"
  },
  {
    "function_name": "sandbox_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/sandbox.c",
    "lines": "49-90",
    "snippet": "static void sandbox_handler(int sig){\n\tif (!arg_quiet) {\n\t\tprintf(\"\\nChild received signal %d, shutting down the sandbox...\\n\", sig);\n\t\tfflush(0);\n\t}\n\n\t// broadcast sigterm to all processes in the group\n\tkill(-1, SIGTERM);\n\tsleep(1);\n\n\tif (monitored_pid) {\n\t\tint monsec = 9;\n\t\tchar *monfile;\n\t\tif (asprintf(&monfile, \"/proc/%d/cmdline\", monitored_pid) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\twhile (monsec) {\n\t\t\tFILE *fp = fopen(monfile, \"r\");\n\t\t\tif (!fp)\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tchar c;\n\t\t\tsize_t count = fread(&c, 1, 1, fp);\n\t\t\tfclose(fp);\n\t\t\tif (count == 0)\n\t\t\t\tbreak;\n\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Waiting on PID %d to finish\\n\", monitored_pid);\n\t\t\tsleep(1);\n\t\t\tmonsec--;\n\t\t}\n\t\tfree(monfile);\n\t\t\n\t}\n\n\n\t// broadcast a SIGKILL\n\tkill(-1, SIGKILL);\n\tflush_stdin();\n\n\texit(sig);\n}",
    "includes": [
      "#include <sys/apparmor.h>",
      "#include <sys/prctl.h>",
      "#include <sched.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <sys/types.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/prctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/wait.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int monitored_pid = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "sig"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "myexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/main.c",
          "lines": "137-149",
          "snippet": "static void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}",
          "includes": [
            "#include <sys/times.h>",
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int arg_command = 0;",
            "int arg_quiet = 0;",
            "pid_t sandbox_pid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/times.h>\n#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nint arg_command = 0;\nint arg_quiet = 0;\npid_t sandbox_pid;\n\nstatic void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_stdin",
          "args": [],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "flush_stdin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/util.c",
          "lines": "721-731",
          "snippet": "void flush_stdin(void) {\n\tif (isatty(STDIN_FILENO)) {\n\t\tint cnt = 0;\n\t\tioctl(STDIN_FILENO, FIONREAD, &cnt);\n\t\tif (cnt) {\n\t\t\tif (!arg_quiet)\n\t\t\t\tprintf(\"Warning: removing %d bytes from stdin\\n\", cnt);\n\t\t\tioctl(STDIN_FILENO, TCFLSH, TCIFLUSH);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nvoid flush_stdin(void) {\n\tif (isatty(STDIN_FILENO)) {\n\t\tint cnt = 0;\n\t\tioctl(STDIN_FILENO, FIONREAD, &cnt);\n\t\tif (cnt) {\n\t\t\tif (!arg_quiet)\n\t\t\t\tprintf(\"Warning: removing %d bytes from stdin\\n\", cnt);\n\t\t\tioctl(STDIN_FILENO, TCFLSH, TCIFLUSH);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "-1",
            "SIGKILL"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "monfile"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sleep",
          "args": [
            "1"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Waiting on PID %d to finish\\n\"",
            "monitored_pid"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fread",
          "args": [
            "&c",
            "1",
            "1",
            "fp"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "monfile",
            "\"r\""
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&monfile",
            "\"/proc/%d/cmdline\"",
            "monitored_pid"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sleep",
          "args": [
            "1"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "-1",
            "SIGTERM"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "0"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\nChild received signal %d, shutting down the sandbox...\\n\"",
            "sig"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/apparmor.h>\n#include <sys/prctl.h>\n#include <sched.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/prctl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic int monitored_pid = 0;\n\nstatic void sandbox_handler(int sig){\n\tif (!arg_quiet) {\n\t\tprintf(\"\\nChild received signal %d, shutting down the sandbox...\\n\", sig);\n\t\tfflush(0);\n\t}\n\n\t// broadcast sigterm to all processes in the group\n\tkill(-1, SIGTERM);\n\tsleep(1);\n\n\tif (monitored_pid) {\n\t\tint monsec = 9;\n\t\tchar *monfile;\n\t\tif (asprintf(&monfile, \"/proc/%d/cmdline\", monitored_pid) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\twhile (monsec) {\n\t\t\tFILE *fp = fopen(monfile, \"r\");\n\t\t\tif (!fp)\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tchar c;\n\t\t\tsize_t count = fread(&c, 1, 1, fp);\n\t\t\tfclose(fp);\n\t\t\tif (count == 0)\n\t\t\t\tbreak;\n\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Waiting on PID %d to finish\\n\", monitored_pid);\n\t\t\tsleep(1);\n\t\t\tmonsec--;\n\t\t}\n\t\tfree(monfile);\n\t\t\n\t}\n\n\n\t// broadcast a SIGKILL\n\tkill(-1, SIGKILL);\n\tflush_stdin();\n\n\texit(sig);\n}"
  }
]