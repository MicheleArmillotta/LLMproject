[
  {
    "function_name": "restrict_users",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/restrict_users.c",
    "lines": "337-357",
    "snippet": "void restrict_users(void) {\n\tif (arg_allusers)\n\t\treturn;\n\t\t\n\t// only in user mode\n\tif (getuid()) {\n\t\tif (strncmp(cfg.homedir, \"/home/\", 6) == 0) {\n\t\t\t// user has the home directory under /home\n\t\t\tsanitize_home();\n\t\t}\n\t\telse {\n\t\t\t// user has the home directory outside /home\n\t\t\t// mount tmpfs on top of /home in order to hide it\n\t\t\tif (mount(\"tmpfs\", \"/home\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\t\terrExit(\"mount tmpfs\");\n\t\t\tfs_logger(\"tmpfs /home\");\n\t\t}\n\t\tsanitize_passwd();\n\t\tsanitize_group();\n\t}\n}",
    "includes": [
      "#include \"../../uids.h\"",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sanitize_group",
          "args": [],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "sanitize_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/restrict_users.c",
          "lines": "251-335",
          "snippet": "static void sanitize_group(void) {\n\tstruct stat s;\n\tif (stat(\"/etc/group\", &s) == -1)\n\t\treturn;\n\tif (arg_debug)\n\t\tprintf(\"Sanitizing /etc/group, GID_MIN %d\\n\", GID_MIN);\n\tif (is_link(\"/etc/group\")) {\n\t\tfprintf(stderr, \"Error: invalid /etc/group\\n\");\n\t\texit(1);\n\t}\n\n\tFILE *fpin = NULL;\n\tFILE *fpout = NULL;\n\tfs_build_mnt_dir();\n\n\t// open files\n\t/* coverity[toctou] */\n\tfpin = fopen(\"/etc/group\", \"r\");\n\tif (!fpin)\n\t\tgoto errout;\n\tfpout = fopen(RUN_GROUP_FILE, \"w\");\n\tif (!fpout)\n\t\tgoto errout;\n\t\n\t// read the file line by line\n\tchar buf[MAXBUF];\n\tgid_t mygid = getgid();\n\twhile (fgets(buf, MAXBUF, fpin)) {\n\t\t// comments and empty lines\n\t\tif (*buf == '\\0' || *buf == '#')\n\t\t\tcontinue;\n\t\t\n\t\t// sample line:\n\t\t// \tpulse:x:115:netblue,bingo\n\t\t// drop lines with uid > 1000 and not the current user group\n\t\tchar *ptr = buf;\n\t\t\n\t\t// advance to uid\n\t\twhile (*ptr != ':' && *ptr != '\\0')\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errout;\n\t\tptr++;\n\t\twhile (*ptr != ':' && *ptr != '\\0')\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errout;\n\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errout;\n\n\t\t// process uid\n\t\tint gid;\n\t\tint rv = sscanf(ptr, \"%d:\", &gid);\n\t\tif (rv == 0 || gid < 0)\n\t\t\tgoto errout;\n\t\tif (gid < GID_MIN) {\n\t\t\tif (copy_line(fpout, buf, ptr))\n\t\t\t\tgoto errout;\n\t\t\tcontinue;\n\t\t}\n\t\tif ((gid_t) gid != mygid) {\n\t\t\tcontinue; // skip line\n\t\t}\n\t\tif (copy_line(fpout, buf, ptr))\n\t\t\tgoto errout;\n\t}\n\tfclose(fpin);\n\tSET_PERMS_STREAM(fpout, 0, 0, 0644);\n\tfclose(fpout);\n\n\t// mount-bind tne new group file\n\tif (mount(RUN_GROUP_FILE, \"/etc/group\", \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\terrExit(\"mount\");\n\tfs_logger(\"create /etc/group\");\n\t\n\treturn;\t\n\t\nerrout:\n\tfprintf(stderr, \"Warning: failed to clean up /etc/group\\n\");\n\tif (fpin)\n\t\tfclose(fpin);\n\tif (fpout)\n\t\tfclose(fpout);\n}",
          "includes": [
            "#include \"../../uids.h\"",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAXBUF 1024"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../uids.h\"\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\n#define MAXBUF 1024\n\nstatic void sanitize_group(void) {\n\tstruct stat s;\n\tif (stat(\"/etc/group\", &s) == -1)\n\t\treturn;\n\tif (arg_debug)\n\t\tprintf(\"Sanitizing /etc/group, GID_MIN %d\\n\", GID_MIN);\n\tif (is_link(\"/etc/group\")) {\n\t\tfprintf(stderr, \"Error: invalid /etc/group\\n\");\n\t\texit(1);\n\t}\n\n\tFILE *fpin = NULL;\n\tFILE *fpout = NULL;\n\tfs_build_mnt_dir();\n\n\t// open files\n\t/* coverity[toctou] */\n\tfpin = fopen(\"/etc/group\", \"r\");\n\tif (!fpin)\n\t\tgoto errout;\n\tfpout = fopen(RUN_GROUP_FILE, \"w\");\n\tif (!fpout)\n\t\tgoto errout;\n\t\n\t// read the file line by line\n\tchar buf[MAXBUF];\n\tgid_t mygid = getgid();\n\twhile (fgets(buf, MAXBUF, fpin)) {\n\t\t// comments and empty lines\n\t\tif (*buf == '\\0' || *buf == '#')\n\t\t\tcontinue;\n\t\t\n\t\t// sample line:\n\t\t// \tpulse:x:115:netblue,bingo\n\t\t// drop lines with uid > 1000 and not the current user group\n\t\tchar *ptr = buf;\n\t\t\n\t\t// advance to uid\n\t\twhile (*ptr != ':' && *ptr != '\\0')\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errout;\n\t\tptr++;\n\t\twhile (*ptr != ':' && *ptr != '\\0')\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errout;\n\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errout;\n\n\t\t// process uid\n\t\tint gid;\n\t\tint rv = sscanf(ptr, \"%d:\", &gid);\n\t\tif (rv == 0 || gid < 0)\n\t\t\tgoto errout;\n\t\tif (gid < GID_MIN) {\n\t\t\tif (copy_line(fpout, buf, ptr))\n\t\t\t\tgoto errout;\n\t\t\tcontinue;\n\t\t}\n\t\tif ((gid_t) gid != mygid) {\n\t\t\tcontinue; // skip line\n\t\t}\n\t\tif (copy_line(fpout, buf, ptr))\n\t\t\tgoto errout;\n\t}\n\tfclose(fpin);\n\tSET_PERMS_STREAM(fpout, 0, 0, 0644);\n\tfclose(fpout);\n\n\t// mount-bind tne new group file\n\tif (mount(RUN_GROUP_FILE, \"/etc/group\", \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\terrExit(\"mount\");\n\tfs_logger(\"create /etc/group\");\n\t\n\treturn;\t\n\t\nerrout:\n\tfprintf(stderr, \"Warning: failed to clean up /etc/group\\n\");\n\tif (fpin)\n\t\tfclose(fpin);\n\tif (fpout)\n\t\tfclose(fpout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sanitize_passwd",
          "args": [],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "sanitize_passwd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/restrict_users.c",
          "lines": "117-206",
          "snippet": "static void sanitize_passwd(void) {\n\tstruct stat s;\n\tif (stat(\"/etc/passwd\", &s) == -1)\n\t\treturn;\n\tif (arg_debug)\n\t\tprintf(\"Sanitizing /etc/passwd, UID_MIN %d\\n\", UID_MIN);\n\tif (is_link(\"/etc/passwd\")) {\n\t\tfprintf(stderr, \"Error: invalid /etc/passwd\\n\");\n\t\texit(1);\n\t}\n\n\tFILE *fpin = NULL;\n\tFILE *fpout = NULL;\n\tfs_build_mnt_dir();\n\n\t// open files\n\t/* coverity[toctou] */\n\tfpin = fopen(\"/etc/passwd\", \"r\");\n\tif (!fpin)\n\t\tgoto errout;\n\tfpout = fopen(RUN_PASSWD_FILE, \"w\");\n\tif (!fpout)\n\t\tgoto errout;\n\t\n\t// read the file line by line\n\tchar buf[MAXBUF];\n\tuid_t myuid = getuid();\n\twhile (fgets(buf, MAXBUF, fpin)) {\n\t\t// comments and empty lines\n\t\tif (*buf == '\\0' || *buf == '#')\n\t\t\tcontinue;\n\t\t\n\t\t// sample line:\n\t\t// \twww-data:x:33:33:www-data:/var/www:/bin/sh\n\t\t// drop lines with uid > 1000 and not the current user\n\t\tchar *ptr = buf;\n\t\t\n\t\t// advance to uid\n\t\twhile (*ptr != ':' && *ptr != '\\0')\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errout;\n\t\tchar *ptr1 = ptr;\n\t\tptr++;\n\t\twhile (*ptr != ':' && *ptr != '\\0')\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errout;\n\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errout;\n\n\t\t// process uid\n\t\tint uid;\n\t\tint rv = sscanf(ptr, \"%d:\", &uid);\n\t\tif (rv == 0 || uid < 0)\n\t\t\tgoto errout;\n\t\tif (uid < UID_MIN) {\n\t\t\tfprintf(fpout, \"%s\", buf);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((uid_t) uid != myuid) {\n\t\t\t// store user name - necessary to process /etc/group\n\t\t\t*ptr1 = '\\0';\n\t\t\tchar *user = strdup(buf);\n\t\t\tif (!user)\n\t\t\t\terrExit(\"malloc\");\n\t\t\tulist_add(user);\n\t\t\tcontinue; // skip line\n\t\t}\n\t\tfprintf(fpout, \"%s\", buf);\n\t}\n\tfclose(fpin);\n\tSET_PERMS_STREAM(fpout, 0, 0, 0644);\n\tfclose(fpout);\n\n\t// mount-bind tne new password file\n\tif (mount(RUN_PASSWD_FILE, \"/etc/passwd\", \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\terrExit(\"mount\");\n\tfs_logger(\"create /etc/passwd\");\n\t\n\treturn;\t\n\t\nerrout:\n\tfprintf(stderr, \"Warning: failed to clean up /etc/passwd\\n\");\n\tif (fpin)\n\t\tfclose(fpin);\n\tif (fpout)\n\t\tfclose(fpout);\n}",
          "includes": [
            "#include \"../../uids.h\"",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAXBUF 1024"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../uids.h\"\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\n#define MAXBUF 1024\n\nstatic void sanitize_passwd(void) {\n\tstruct stat s;\n\tif (stat(\"/etc/passwd\", &s) == -1)\n\t\treturn;\n\tif (arg_debug)\n\t\tprintf(\"Sanitizing /etc/passwd, UID_MIN %d\\n\", UID_MIN);\n\tif (is_link(\"/etc/passwd\")) {\n\t\tfprintf(stderr, \"Error: invalid /etc/passwd\\n\");\n\t\texit(1);\n\t}\n\n\tFILE *fpin = NULL;\n\tFILE *fpout = NULL;\n\tfs_build_mnt_dir();\n\n\t// open files\n\t/* coverity[toctou] */\n\tfpin = fopen(\"/etc/passwd\", \"r\");\n\tif (!fpin)\n\t\tgoto errout;\n\tfpout = fopen(RUN_PASSWD_FILE, \"w\");\n\tif (!fpout)\n\t\tgoto errout;\n\t\n\t// read the file line by line\n\tchar buf[MAXBUF];\n\tuid_t myuid = getuid();\n\twhile (fgets(buf, MAXBUF, fpin)) {\n\t\t// comments and empty lines\n\t\tif (*buf == '\\0' || *buf == '#')\n\t\t\tcontinue;\n\t\t\n\t\t// sample line:\n\t\t// \twww-data:x:33:33:www-data:/var/www:/bin/sh\n\t\t// drop lines with uid > 1000 and not the current user\n\t\tchar *ptr = buf;\n\t\t\n\t\t// advance to uid\n\t\twhile (*ptr != ':' && *ptr != '\\0')\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errout;\n\t\tchar *ptr1 = ptr;\n\t\tptr++;\n\t\twhile (*ptr != ':' && *ptr != '\\0')\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errout;\n\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errout;\n\n\t\t// process uid\n\t\tint uid;\n\t\tint rv = sscanf(ptr, \"%d:\", &uid);\n\t\tif (rv == 0 || uid < 0)\n\t\t\tgoto errout;\n\t\tif (uid < UID_MIN) {\n\t\t\tfprintf(fpout, \"%s\", buf);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((uid_t) uid != myuid) {\n\t\t\t// store user name - necessary to process /etc/group\n\t\t\t*ptr1 = '\\0';\n\t\t\tchar *user = strdup(buf);\n\t\t\tif (!user)\n\t\t\t\terrExit(\"malloc\");\n\t\t\tulist_add(user);\n\t\t\tcontinue; // skip line\n\t\t}\n\t\tfprintf(fpout, \"%s\", buf);\n\t}\n\tfclose(fpin);\n\tSET_PERMS_STREAM(fpout, 0, 0, 0644);\n\tfclose(fpout);\n\n\t// mount-bind tne new password file\n\tif (mount(RUN_PASSWD_FILE, \"/etc/passwd\", \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\terrExit(\"mount\");\n\tfs_logger(\"create /etc/passwd\");\n\t\n\treturn;\t\n\t\nerrout:\n\tfprintf(stderr, \"Warning: failed to clean up /etc/passwd\\n\");\n\tif (fpin)\n\t\tfclose(fpin);\n\tif (fpout)\n\t\tfclose(fpout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_logger",
          "args": [
            "\"tmpfs /home\""
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger_print_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_logger.c",
          "lines": "136-189",
          "snippet": "void fs_logger_print_log(pid_t pid) {\n\tEUID_ASSERT();\n\n\t// if the pid is that of a firejail  process, use the pid of the first child process\n\tEUID_ROOT();\n\tchar *comm = pid_proc_comm(pid);\n\tEUID_USER();\n\tif (comm) {\n\t\tif (strcmp(comm, \"firejail\") == 0) {\n\t\t\tpid_t child;\n\t\t\tif (find_child(pid, &child) == 0) {\n\t\t\t\tpid = child;\n\t\t\t}\n\t\t}\n\t\tfree(comm);\n\t}\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission denied\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// print RUN_FSLOGGER_FILE\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_FSLOGGER_FILE) == -1)\n\t\terrExit(\"asprintf\");\n\n\tEUID_ROOT();\n\tstruct stat s;\n\tif (stat(fname, &s) == -1) {\n\t\tfprintf(stderr, \"Error: Cannot access filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: Cannot open filesystem log\\n\");\n\t\texit(1);\n\t}\n\t\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp))\n\t\tprintf(\"%s\", buf);\n\tfclose(fp);\n\tfree(fname);\n\n\texit(0);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAXBUF 4098"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\n#define MAXBUF 4098\n\nvoid fs_logger_print_log(pid_t pid) {\n\tEUID_ASSERT();\n\n\t// if the pid is that of a firejail  process, use the pid of the first child process\n\tEUID_ROOT();\n\tchar *comm = pid_proc_comm(pid);\n\tEUID_USER();\n\tif (comm) {\n\t\tif (strcmp(comm, \"firejail\") == 0) {\n\t\t\tpid_t child;\n\t\t\tif (find_child(pid, &child) == 0) {\n\t\t\t\tpid = child;\n\t\t\t}\n\t\t}\n\t\tfree(comm);\n\t}\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission denied\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// print RUN_FSLOGGER_FILE\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_FSLOGGER_FILE) == -1)\n\t\terrExit(\"asprintf\");\n\n\tEUID_ROOT();\n\tstruct stat s;\n\tif (stat(fname, &s) == -1) {\n\t\tfprintf(stderr, \"Error: Cannot access filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: Cannot open filesystem log\\n\");\n\t\texit(1);\n\t}\n\t\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp))\n\t\tprintf(\"%s\", buf);\n\tfclose(fp);\n\tfree(fname);\n\n\texit(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount tmpfs\""
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"tmpfs\"",
            "\"/home\"",
            "\"tmpfs\"",
            "MS_NOSUID | MS_NODEV | MS_STRICTATIME | MS_REC",
            "\"mode=755,gid=0\""
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sanitize_home",
          "args": [],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "sanitize_home",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/restrict_users.c",
          "lines": "63-115",
          "snippet": "static void sanitize_home(void) {\n\tassert(getuid() != 0);\t// this code works only for regular users\n\t\n\tif (arg_debug)\n\t\tprintf(\"Cleaning /home directory\\n\");\n\t\n\tstruct stat s;\n\tif (stat(cfg.homedir, &s) == -1) {\n\t\t// cannot find home directory, just return\n\t\tfprintf(stderr, \"Warning: cannot find home directory\\n\");\n\t\treturn;\n\t}\n\t\n\tfs_build_mnt_dir();\n\tif (mkdir(RUN_WHITELIST_HOME_DIR, 0755) == -1)\n\t\terrExit(\"mkdir\");\n\n\t// keep a copy of the user home directory\n\tif (mount(cfg.homedir, RUN_WHITELIST_HOME_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\n\t// mount tmpfs in the new home\n\tif (mount(\"tmpfs\", \"/home\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\terrExit(\"mount tmpfs\");\n\tfs_logger(\"tmpfs /home\");\n\n\t// create user home directory\n\tif (mkdir(cfg.homedir, 0755) == -1) {\n\t\tif (mkpath_as_root(cfg.homedir))\n\t\t\terrExit(\"mkpath\");\n\t\tif (mkdir(cfg.homedir, 0755) == -1)\n\t\t\terrExit(\"mkdir\");\n\t}\n\tfs_logger2(\"mkdir\", cfg.homedir);\n\t\n\t// set mode and ownership\n\tif (chown(cfg.homedir, s.st_uid, s.st_gid) == -1)\n\t\terrExit(\"chown\");\n\tif (chmod(cfg.homedir, s.st_mode) == -1)\n\t\terrExit(\"chmod\");\n\n\t// mount user home directory\n\tif (mount(RUN_WHITELIST_HOME_DIR, cfg.homedir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\n\t// mask home dir under /run\n\tif (mount(\"tmpfs\", RUN_WHITELIST_HOME_DIR, \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\terrExit(\"mount tmpfs\");\n\tfs_logger2(\"tmpfs\", RUN_WHITELIST_HOME_DIR);\n\tif (!arg_private)\n\t\tfs_logger2(\"whitelist\", cfg.homedir);\n\t\n}",
          "includes": [
            "#include \"../../uids.h\"",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../uids.h\"\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void sanitize_home(void) {\n\tassert(getuid() != 0);\t// this code works only for regular users\n\t\n\tif (arg_debug)\n\t\tprintf(\"Cleaning /home directory\\n\");\n\t\n\tstruct stat s;\n\tif (stat(cfg.homedir, &s) == -1) {\n\t\t// cannot find home directory, just return\n\t\tfprintf(stderr, \"Warning: cannot find home directory\\n\");\n\t\treturn;\n\t}\n\t\n\tfs_build_mnt_dir();\n\tif (mkdir(RUN_WHITELIST_HOME_DIR, 0755) == -1)\n\t\terrExit(\"mkdir\");\n\n\t// keep a copy of the user home directory\n\tif (mount(cfg.homedir, RUN_WHITELIST_HOME_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\n\t// mount tmpfs in the new home\n\tif (mount(\"tmpfs\", \"/home\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\terrExit(\"mount tmpfs\");\n\tfs_logger(\"tmpfs /home\");\n\n\t// create user home directory\n\tif (mkdir(cfg.homedir, 0755) == -1) {\n\t\tif (mkpath_as_root(cfg.homedir))\n\t\t\terrExit(\"mkpath\");\n\t\tif (mkdir(cfg.homedir, 0755) == -1)\n\t\t\terrExit(\"mkdir\");\n\t}\n\tfs_logger2(\"mkdir\", cfg.homedir);\n\t\n\t// set mode and ownership\n\tif (chown(cfg.homedir, s.st_uid, s.st_gid) == -1)\n\t\terrExit(\"chown\");\n\tif (chmod(cfg.homedir, s.st_mode) == -1)\n\t\terrExit(\"chmod\");\n\n\t// mount user home directory\n\tif (mount(RUN_WHITELIST_HOME_DIR, cfg.homedir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\n\t// mask home dir under /run\n\tif (mount(\"tmpfs\", RUN_WHITELIST_HOME_DIR, \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\terrExit(\"mount tmpfs\");\n\tfs_logger2(\"tmpfs\", RUN_WHITELIST_HOME_DIR);\n\tif (!arg_private)\n\t\tfs_logger2(\"whitelist\", cfg.homedir);\n\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "cfg.homedir",
            "\"/home/\"",
            "6"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../uids.h\"\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid restrict_users(void) {\n\tif (arg_allusers)\n\t\treturn;\n\t\t\n\t// only in user mode\n\tif (getuid()) {\n\t\tif (strncmp(cfg.homedir, \"/home/\", 6) == 0) {\n\t\t\t// user has the home directory under /home\n\t\t\tsanitize_home();\n\t\t}\n\t\telse {\n\t\t\t// user has the home directory outside /home\n\t\t\t// mount tmpfs on top of /home in order to hide it\n\t\t\tif (mount(\"tmpfs\", \"/home\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\t\terrExit(\"mount tmpfs\");\n\t\t\tfs_logger(\"tmpfs /home\");\n\t\t}\n\t\tsanitize_passwd();\n\t\tsanitize_group();\n\t}\n}"
  },
  {
    "function_name": "sanitize_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/restrict_users.c",
    "lines": "251-335",
    "snippet": "static void sanitize_group(void) {\n\tstruct stat s;\n\tif (stat(\"/etc/group\", &s) == -1)\n\t\treturn;\n\tif (arg_debug)\n\t\tprintf(\"Sanitizing /etc/group, GID_MIN %d\\n\", GID_MIN);\n\tif (is_link(\"/etc/group\")) {\n\t\tfprintf(stderr, \"Error: invalid /etc/group\\n\");\n\t\texit(1);\n\t}\n\n\tFILE *fpin = NULL;\n\tFILE *fpout = NULL;\n\tfs_build_mnt_dir();\n\n\t// open files\n\t/* coverity[toctou] */\n\tfpin = fopen(\"/etc/group\", \"r\");\n\tif (!fpin)\n\t\tgoto errout;\n\tfpout = fopen(RUN_GROUP_FILE, \"w\");\n\tif (!fpout)\n\t\tgoto errout;\n\t\n\t// read the file line by line\n\tchar buf[MAXBUF];\n\tgid_t mygid = getgid();\n\twhile (fgets(buf, MAXBUF, fpin)) {\n\t\t// comments and empty lines\n\t\tif (*buf == '\\0' || *buf == '#')\n\t\t\tcontinue;\n\t\t\n\t\t// sample line:\n\t\t// \tpulse:x:115:netblue,bingo\n\t\t// drop lines with uid > 1000 and not the current user group\n\t\tchar *ptr = buf;\n\t\t\n\t\t// advance to uid\n\t\twhile (*ptr != ':' && *ptr != '\\0')\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errout;\n\t\tptr++;\n\t\twhile (*ptr != ':' && *ptr != '\\0')\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errout;\n\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errout;\n\n\t\t// process uid\n\t\tint gid;\n\t\tint rv = sscanf(ptr, \"%d:\", &gid);\n\t\tif (rv == 0 || gid < 0)\n\t\t\tgoto errout;\n\t\tif (gid < GID_MIN) {\n\t\t\tif (copy_line(fpout, buf, ptr))\n\t\t\t\tgoto errout;\n\t\t\tcontinue;\n\t\t}\n\t\tif ((gid_t) gid != mygid) {\n\t\t\tcontinue; // skip line\n\t\t}\n\t\tif (copy_line(fpout, buf, ptr))\n\t\t\tgoto errout;\n\t}\n\tfclose(fpin);\n\tSET_PERMS_STREAM(fpout, 0, 0, 0644);\n\tfclose(fpout);\n\n\t// mount-bind tne new group file\n\tif (mount(RUN_GROUP_FILE, \"/etc/group\", \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\terrExit(\"mount\");\n\tfs_logger(\"create /etc/group\");\n\t\n\treturn;\t\n\t\nerrout:\n\tfprintf(stderr, \"Warning: failed to clean up /etc/group\\n\");\n\tif (fpin)\n\t\tfclose(fpin);\n\tif (fpout)\n\t\tfclose(fpout);\n}",
    "includes": [
      "#include \"../../uids.h\"",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [
      "#define MAXBUF 1024"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fpout"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fpin"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: failed to clean up /etc/group\\n\""
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_logger",
          "args": [
            "\"create /etc/group\""
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger_print_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_logger.c",
          "lines": "136-189",
          "snippet": "void fs_logger_print_log(pid_t pid) {\n\tEUID_ASSERT();\n\n\t// if the pid is that of a firejail  process, use the pid of the first child process\n\tEUID_ROOT();\n\tchar *comm = pid_proc_comm(pid);\n\tEUID_USER();\n\tif (comm) {\n\t\tif (strcmp(comm, \"firejail\") == 0) {\n\t\t\tpid_t child;\n\t\t\tif (find_child(pid, &child) == 0) {\n\t\t\t\tpid = child;\n\t\t\t}\n\t\t}\n\t\tfree(comm);\n\t}\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission denied\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// print RUN_FSLOGGER_FILE\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_FSLOGGER_FILE) == -1)\n\t\terrExit(\"asprintf\");\n\n\tEUID_ROOT();\n\tstruct stat s;\n\tif (stat(fname, &s) == -1) {\n\t\tfprintf(stderr, \"Error: Cannot access filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: Cannot open filesystem log\\n\");\n\t\texit(1);\n\t}\n\t\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp))\n\t\tprintf(\"%s\", buf);\n\tfclose(fp);\n\tfree(fname);\n\n\texit(0);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAXBUF 4098"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\n#define MAXBUF 4098\n\nvoid fs_logger_print_log(pid_t pid) {\n\tEUID_ASSERT();\n\n\t// if the pid is that of a firejail  process, use the pid of the first child process\n\tEUID_ROOT();\n\tchar *comm = pid_proc_comm(pid);\n\tEUID_USER();\n\tif (comm) {\n\t\tif (strcmp(comm, \"firejail\") == 0) {\n\t\t\tpid_t child;\n\t\t\tif (find_child(pid, &child) == 0) {\n\t\t\t\tpid = child;\n\t\t\t}\n\t\t}\n\t\tfree(comm);\n\t}\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission denied\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// print RUN_FSLOGGER_FILE\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_FSLOGGER_FILE) == -1)\n\t\terrExit(\"asprintf\");\n\n\tEUID_ROOT();\n\tstruct stat s;\n\tif (stat(fname, &s) == -1) {\n\t\tfprintf(stderr, \"Error: Cannot access filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: Cannot open filesystem log\\n\");\n\t\texit(1);\n\t}\n\t\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp))\n\t\tprintf(\"%s\", buf);\n\tfclose(fp);\n\tfree(fname);\n\n\texit(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount\""
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "RUN_GROUP_FILE",
            "\"/etc/group\"",
            "\"none\"",
            "MS_BIND",
            "\"mode=400,gid=0\""
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fpout"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_PERMS_STREAM",
          "args": [
            "fpout",
            "0",
            "0",
            "0644"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fpin"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_line",
          "args": [
            "fpout",
            "buf",
            "ptr"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "copy_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/restrict_users.c",
          "lines": "209-249",
          "snippet": "static int copy_line(FILE *fpout, char *buf, char *ptr) {\n\t// fpout: GROUP_FILE\n\t// buf: pulse:x:115:netblue,bingo\n\t// ptr: 115:neblue,bingo\n\t\n\twhile (*ptr != ':' && *ptr != '\\0')\n\t\tptr++;\n\tif (*ptr == '\\0')\n\t\treturn 1;\n\n\tptr++;\n\tif (*ptr == '\\n' || *ptr == '\\0') {\n\t\tfprintf(fpout, \"%s\", buf);\n\t\treturn 0;\n\t}\n\t\n\t// print what we have so far\n\tchar tmp = *ptr;\n\t*ptr = '\\0';\n\tfprintf(fpout, \"%s\", buf);\n\t*ptr = tmp;\n\n\t// tokenize\n\tchar *token = strtok(ptr, \",\\n\");\n\tint first = 1;\n\twhile (token) {\n\t\tchar *newtoken = strtok(NULL, \",\\n\");\n\t\tif (ulist_find(token)) {\n\t\t\t//skip\n\t\t\ttoken = newtoken;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!first)\n\t\t\tfprintf(fpout, \",\");\n\t\tfirst = 0;\n\t\tfprintf(fpout, \"%s\", token);\n\t\ttoken = newtoken;\n\t}\n\tfprintf(fpout, \"\\n\");\n\treturn 0;\n}",
          "includes": [
            "#include \"../../uids.h\"",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../uids.h\"\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic int copy_line(FILE *fpout, char *buf, char *ptr) {\n\t// fpout: GROUP_FILE\n\t// buf: pulse:x:115:netblue,bingo\n\t// ptr: 115:neblue,bingo\n\t\n\twhile (*ptr != ':' && *ptr != '\\0')\n\t\tptr++;\n\tif (*ptr == '\\0')\n\t\treturn 1;\n\n\tptr++;\n\tif (*ptr == '\\n' || *ptr == '\\0') {\n\t\tfprintf(fpout, \"%s\", buf);\n\t\treturn 0;\n\t}\n\t\n\t// print what we have so far\n\tchar tmp = *ptr;\n\t*ptr = '\\0';\n\tfprintf(fpout, \"%s\", buf);\n\t*ptr = tmp;\n\n\t// tokenize\n\tchar *token = strtok(ptr, \",\\n\");\n\tint first = 1;\n\twhile (token) {\n\t\tchar *newtoken = strtok(NULL, \",\\n\");\n\t\tif (ulist_find(token)) {\n\t\t\t//skip\n\t\t\ttoken = newtoken;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!first)\n\t\t\tfprintf(fpout, \",\");\n\t\tfirst = 0;\n\t\tfprintf(fpout, \"%s\", token);\n\t\ttoken = newtoken;\n\t}\n\tfprintf(fpout, \"\\n\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "ptr",
            "\"%d:\"",
            "&gid"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buf",
            "MAXBUF",
            "fpin"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getgid",
          "args": [],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "RUN_GROUP_FILE",
            "\"w\""
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "\"/etc/group\"",
            "\"r\""
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_build_mnt_dir",
          "args": [],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "fs_build_mnt_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
          "lines": "126-145",
          "snippet": "void fs_build_mnt_dir(void) {\n\tstruct stat s;\n\tfs_build_firejail_dir();\n\t\n\t// create /run/firejail/mnt directory\n\tif (stat(RUN_MNT_DIR, &s)) {\n\t\tcreate_dir_as_root(RUN_MNT_DIR, 0755);\n\t}\n\n\t// ... and mount tmpfs on top of it\n\tif (!tmpfs_mounted) {\n\t\t// mount tmpfs on top of /run/firejail/mnt\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on %s directory\\n\", RUN_MNT_DIR);\n\t\tif (mount(\"tmpfs\", RUN_MNT_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /run/firejail/mnt\");\n\t\ttmpfs_mounted = 1;\n\t\tfs_logger2(\"tmpfs\", RUN_MNT_DIR);\n\t}\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int tmpfs_mounted = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic int tmpfs_mounted = 0;\n\nvoid fs_build_mnt_dir(void) {\n\tstruct stat s;\n\tfs_build_firejail_dir();\n\t\n\t// create /run/firejail/mnt directory\n\tif (stat(RUN_MNT_DIR, &s)) {\n\t\tcreate_dir_as_root(RUN_MNT_DIR, 0755);\n\t}\n\n\t// ... and mount tmpfs on top of it\n\tif (!tmpfs_mounted) {\n\t\t// mount tmpfs on top of /run/firejail/mnt\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on %s directory\\n\", RUN_MNT_DIR);\n\t\tif (mount(\"tmpfs\", RUN_MNT_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /run/firejail/mnt\");\n\t\ttmpfs_mounted = 1;\n\t\tfs_logger2(\"tmpfs\", RUN_MNT_DIR);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "myexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/main.c",
          "lines": "137-149",
          "snippet": "static void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}",
          "includes": [
            "#include <sys/times.h>",
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int arg_command = 0;",
            "int arg_quiet = 0;",
            "pid_t sandbox_pid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/times.h>\n#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nint arg_command = 0;\nint arg_quiet = 0;\npid_t sandbox_pid;\n\nstatic void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid /etc/group\\n\""
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_link",
          "args": [
            "\"/etc/group\""
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "is_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/util.c",
          "lines": "295-307",
          "snippet": "int is_link(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\tstruct stat s;\n\tif (lstat(fname, &s) == 0) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nint is_link(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\tstruct stat s;\n\tif (lstat(fname, &s) == 0) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Sanitizing /etc/group, GID_MIN %d\\n\"",
            "GID_MIN"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "\"/etc/group\"",
            "&s"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../uids.h\"\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\n#define MAXBUF 1024\n\nstatic void sanitize_group(void) {\n\tstruct stat s;\n\tif (stat(\"/etc/group\", &s) == -1)\n\t\treturn;\n\tif (arg_debug)\n\t\tprintf(\"Sanitizing /etc/group, GID_MIN %d\\n\", GID_MIN);\n\tif (is_link(\"/etc/group\")) {\n\t\tfprintf(stderr, \"Error: invalid /etc/group\\n\");\n\t\texit(1);\n\t}\n\n\tFILE *fpin = NULL;\n\tFILE *fpout = NULL;\n\tfs_build_mnt_dir();\n\n\t// open files\n\t/* coverity[toctou] */\n\tfpin = fopen(\"/etc/group\", \"r\");\n\tif (!fpin)\n\t\tgoto errout;\n\tfpout = fopen(RUN_GROUP_FILE, \"w\");\n\tif (!fpout)\n\t\tgoto errout;\n\t\n\t// read the file line by line\n\tchar buf[MAXBUF];\n\tgid_t mygid = getgid();\n\twhile (fgets(buf, MAXBUF, fpin)) {\n\t\t// comments and empty lines\n\t\tif (*buf == '\\0' || *buf == '#')\n\t\t\tcontinue;\n\t\t\n\t\t// sample line:\n\t\t// \tpulse:x:115:netblue,bingo\n\t\t// drop lines with uid > 1000 and not the current user group\n\t\tchar *ptr = buf;\n\t\t\n\t\t// advance to uid\n\t\twhile (*ptr != ':' && *ptr != '\\0')\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errout;\n\t\tptr++;\n\t\twhile (*ptr != ':' && *ptr != '\\0')\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errout;\n\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errout;\n\n\t\t// process uid\n\t\tint gid;\n\t\tint rv = sscanf(ptr, \"%d:\", &gid);\n\t\tif (rv == 0 || gid < 0)\n\t\t\tgoto errout;\n\t\tif (gid < GID_MIN) {\n\t\t\tif (copy_line(fpout, buf, ptr))\n\t\t\t\tgoto errout;\n\t\t\tcontinue;\n\t\t}\n\t\tif ((gid_t) gid != mygid) {\n\t\t\tcontinue; // skip line\n\t\t}\n\t\tif (copy_line(fpout, buf, ptr))\n\t\t\tgoto errout;\n\t}\n\tfclose(fpin);\n\tSET_PERMS_STREAM(fpout, 0, 0, 0644);\n\tfclose(fpout);\n\n\t// mount-bind tne new group file\n\tif (mount(RUN_GROUP_FILE, \"/etc/group\", \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\terrExit(\"mount\");\n\tfs_logger(\"create /etc/group\");\n\t\n\treturn;\t\n\t\nerrout:\n\tfprintf(stderr, \"Warning: failed to clean up /etc/group\\n\");\n\tif (fpin)\n\t\tfclose(fpin);\n\tif (fpout)\n\t\tfclose(fpout);\n}"
  },
  {
    "function_name": "copy_line",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/restrict_users.c",
    "lines": "209-249",
    "snippet": "static int copy_line(FILE *fpout, char *buf, char *ptr) {\n\t// fpout: GROUP_FILE\n\t// buf: pulse:x:115:netblue,bingo\n\t// ptr: 115:neblue,bingo\n\t\n\twhile (*ptr != ':' && *ptr != '\\0')\n\t\tptr++;\n\tif (*ptr == '\\0')\n\t\treturn 1;\n\n\tptr++;\n\tif (*ptr == '\\n' || *ptr == '\\0') {\n\t\tfprintf(fpout, \"%s\", buf);\n\t\treturn 0;\n\t}\n\t\n\t// print what we have so far\n\tchar tmp = *ptr;\n\t*ptr = '\\0';\n\tfprintf(fpout, \"%s\", buf);\n\t*ptr = tmp;\n\n\t// tokenize\n\tchar *token = strtok(ptr, \",\\n\");\n\tint first = 1;\n\twhile (token) {\n\t\tchar *newtoken = strtok(NULL, \",\\n\");\n\t\tif (ulist_find(token)) {\n\t\t\t//skip\n\t\t\ttoken = newtoken;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!first)\n\t\t\tfprintf(fpout, \",\");\n\t\tfirst = 0;\n\t\tfprintf(fpout, \"%s\", token);\n\t\ttoken = newtoken;\n\t}\n\tfprintf(fpout, \"\\n\");\n\treturn 0;\n}",
    "includes": [
      "#include \"../../uids.h\"",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fpout",
            "\"\\n\""
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fpout",
            "\"%s\"",
            "token"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fpout",
            "\",\""
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ulist_find",
          "args": [
            "token"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/restrict_users.c",
          "lines": "50-61",
          "snippet": "static USER_LIST *ulist_find(const char *user) {\n\tassert(user);\n\n\tUSER_LIST *ptr = ulist;\n\twhile (ptr) {\n\t\tif (strcmp(ptr->user, user) == 0)\n\t\t\treturn ptr;\n\t\tptr = ptr->next;\n\t}\n\t\n\treturn NULL;\n}",
          "includes": [
            "#include \"../../uids.h\"",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "USER_LIST *ulist = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../uids.h\"\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nUSER_LIST *ulist = NULL;\n\nstatic USER_LIST *ulist_find(const char *user) {\n\tassert(user);\n\n\tUSER_LIST *ptr = ulist;\n\twhile (ptr) {\n\t\tif (strcmp(ptr->user, user) == 0)\n\t\t\treturn ptr;\n\t\tptr = ptr->next;\n\t}\n\t\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\",\\n\""
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "ptr",
            "\",\\n\""
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fpout",
            "\"%s\"",
            "buf"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fpout",
            "\"%s\"",
            "buf"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../uids.h\"\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic int copy_line(FILE *fpout, char *buf, char *ptr) {\n\t// fpout: GROUP_FILE\n\t// buf: pulse:x:115:netblue,bingo\n\t// ptr: 115:neblue,bingo\n\t\n\twhile (*ptr != ':' && *ptr != '\\0')\n\t\tptr++;\n\tif (*ptr == '\\0')\n\t\treturn 1;\n\n\tptr++;\n\tif (*ptr == '\\n' || *ptr == '\\0') {\n\t\tfprintf(fpout, \"%s\", buf);\n\t\treturn 0;\n\t}\n\t\n\t// print what we have so far\n\tchar tmp = *ptr;\n\t*ptr = '\\0';\n\tfprintf(fpout, \"%s\", buf);\n\t*ptr = tmp;\n\n\t// tokenize\n\tchar *token = strtok(ptr, \",\\n\");\n\tint first = 1;\n\twhile (token) {\n\t\tchar *newtoken = strtok(NULL, \",\\n\");\n\t\tif (ulist_find(token)) {\n\t\t\t//skip\n\t\t\ttoken = newtoken;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!first)\n\t\t\tfprintf(fpout, \",\");\n\t\tfirst = 0;\n\t\tfprintf(fpout, \"%s\", token);\n\t\ttoken = newtoken;\n\t}\n\tfprintf(fpout, \"\\n\");\n\treturn 0;\n}"
  },
  {
    "function_name": "sanitize_passwd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/restrict_users.c",
    "lines": "117-206",
    "snippet": "static void sanitize_passwd(void) {\n\tstruct stat s;\n\tif (stat(\"/etc/passwd\", &s) == -1)\n\t\treturn;\n\tif (arg_debug)\n\t\tprintf(\"Sanitizing /etc/passwd, UID_MIN %d\\n\", UID_MIN);\n\tif (is_link(\"/etc/passwd\")) {\n\t\tfprintf(stderr, \"Error: invalid /etc/passwd\\n\");\n\t\texit(1);\n\t}\n\n\tFILE *fpin = NULL;\n\tFILE *fpout = NULL;\n\tfs_build_mnt_dir();\n\n\t// open files\n\t/* coverity[toctou] */\n\tfpin = fopen(\"/etc/passwd\", \"r\");\n\tif (!fpin)\n\t\tgoto errout;\n\tfpout = fopen(RUN_PASSWD_FILE, \"w\");\n\tif (!fpout)\n\t\tgoto errout;\n\t\n\t// read the file line by line\n\tchar buf[MAXBUF];\n\tuid_t myuid = getuid();\n\twhile (fgets(buf, MAXBUF, fpin)) {\n\t\t// comments and empty lines\n\t\tif (*buf == '\\0' || *buf == '#')\n\t\t\tcontinue;\n\t\t\n\t\t// sample line:\n\t\t// \twww-data:x:33:33:www-data:/var/www:/bin/sh\n\t\t// drop lines with uid > 1000 and not the current user\n\t\tchar *ptr = buf;\n\t\t\n\t\t// advance to uid\n\t\twhile (*ptr != ':' && *ptr != '\\0')\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errout;\n\t\tchar *ptr1 = ptr;\n\t\tptr++;\n\t\twhile (*ptr != ':' && *ptr != '\\0')\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errout;\n\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errout;\n\n\t\t// process uid\n\t\tint uid;\n\t\tint rv = sscanf(ptr, \"%d:\", &uid);\n\t\tif (rv == 0 || uid < 0)\n\t\t\tgoto errout;\n\t\tif (uid < UID_MIN) {\n\t\t\tfprintf(fpout, \"%s\", buf);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((uid_t) uid != myuid) {\n\t\t\t// store user name - necessary to process /etc/group\n\t\t\t*ptr1 = '\\0';\n\t\t\tchar *user = strdup(buf);\n\t\t\tif (!user)\n\t\t\t\terrExit(\"malloc\");\n\t\t\tulist_add(user);\n\t\t\tcontinue; // skip line\n\t\t}\n\t\tfprintf(fpout, \"%s\", buf);\n\t}\n\tfclose(fpin);\n\tSET_PERMS_STREAM(fpout, 0, 0, 0644);\n\tfclose(fpout);\n\n\t// mount-bind tne new password file\n\tif (mount(RUN_PASSWD_FILE, \"/etc/passwd\", \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\terrExit(\"mount\");\n\tfs_logger(\"create /etc/passwd\");\n\t\n\treturn;\t\n\t\nerrout:\n\tfprintf(stderr, \"Warning: failed to clean up /etc/passwd\\n\");\n\tif (fpin)\n\t\tfclose(fpin);\n\tif (fpout)\n\t\tfclose(fpout);\n}",
    "includes": [
      "#include \"../../uids.h\"",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [
      "#define MAXBUF 1024"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fpout"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fpin"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: failed to clean up /etc/passwd\\n\""
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_logger",
          "args": [
            "\"create /etc/passwd\""
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger_print_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_logger.c",
          "lines": "136-189",
          "snippet": "void fs_logger_print_log(pid_t pid) {\n\tEUID_ASSERT();\n\n\t// if the pid is that of a firejail  process, use the pid of the first child process\n\tEUID_ROOT();\n\tchar *comm = pid_proc_comm(pid);\n\tEUID_USER();\n\tif (comm) {\n\t\tif (strcmp(comm, \"firejail\") == 0) {\n\t\t\tpid_t child;\n\t\t\tif (find_child(pid, &child) == 0) {\n\t\t\t\tpid = child;\n\t\t\t}\n\t\t}\n\t\tfree(comm);\n\t}\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission denied\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// print RUN_FSLOGGER_FILE\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_FSLOGGER_FILE) == -1)\n\t\terrExit(\"asprintf\");\n\n\tEUID_ROOT();\n\tstruct stat s;\n\tif (stat(fname, &s) == -1) {\n\t\tfprintf(stderr, \"Error: Cannot access filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: Cannot open filesystem log\\n\");\n\t\texit(1);\n\t}\n\t\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp))\n\t\tprintf(\"%s\", buf);\n\tfclose(fp);\n\tfree(fname);\n\n\texit(0);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAXBUF 4098"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\n#define MAXBUF 4098\n\nvoid fs_logger_print_log(pid_t pid) {\n\tEUID_ASSERT();\n\n\t// if the pid is that of a firejail  process, use the pid of the first child process\n\tEUID_ROOT();\n\tchar *comm = pid_proc_comm(pid);\n\tEUID_USER();\n\tif (comm) {\n\t\tif (strcmp(comm, \"firejail\") == 0) {\n\t\t\tpid_t child;\n\t\t\tif (find_child(pid, &child) == 0) {\n\t\t\t\tpid = child;\n\t\t\t}\n\t\t}\n\t\tfree(comm);\n\t}\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission denied\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// print RUN_FSLOGGER_FILE\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_FSLOGGER_FILE) == -1)\n\t\terrExit(\"asprintf\");\n\n\tEUID_ROOT();\n\tstruct stat s;\n\tif (stat(fname, &s) == -1) {\n\t\tfprintf(stderr, \"Error: Cannot access filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: Cannot open filesystem log\\n\");\n\t\texit(1);\n\t}\n\t\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp))\n\t\tprintf(\"%s\", buf);\n\tfclose(fp);\n\tfree(fname);\n\n\texit(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount\""
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "RUN_PASSWD_FILE",
            "\"/etc/passwd\"",
            "\"none\"",
            "MS_BIND",
            "\"mode=400,gid=0\""
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fpout"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_PERMS_STREAM",
          "args": [
            "fpout",
            "0",
            "0",
            "0644"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fpin"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fpout",
            "\"%s\"",
            "buf"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ulist_add",
          "args": [
            "user"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/restrict_users.c",
          "lines": "40-48",
          "snippet": "static void ulist_add(const char *user) {\n\tassert(user);\n\n\tUSER_LIST *nlist = malloc(sizeof(USER_LIST));\n\tmemset(nlist, 0, sizeof(USER_LIST));\n\tnlist->user = user;\n\tnlist->next = ulist;\n\tulist = nlist;\n}",
          "includes": [
            "#include \"../../uids.h\"",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "USER_LIST *ulist = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../uids.h\"\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nUSER_LIST *ulist = NULL;\n\nstatic void ulist_add(const char *user) {\n\tassert(user);\n\n\tUSER_LIST *nlist = malloc(sizeof(USER_LIST));\n\tmemset(nlist, 0, sizeof(USER_LIST));\n\tnlist->user = user;\n\tnlist->next = ulist;\n\tulist = nlist;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"malloc\""
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "buf"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "fpout",
            "\"%s\"",
            "buf"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "ptr",
            "\"%d:\"",
            "&uid"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buf",
            "MAXBUF",
            "fpin"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "RUN_PASSWD_FILE",
            "\"w\""
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "\"/etc/passwd\"",
            "\"r\""
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_build_mnt_dir",
          "args": [],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "fs_build_mnt_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
          "lines": "126-145",
          "snippet": "void fs_build_mnt_dir(void) {\n\tstruct stat s;\n\tfs_build_firejail_dir();\n\t\n\t// create /run/firejail/mnt directory\n\tif (stat(RUN_MNT_DIR, &s)) {\n\t\tcreate_dir_as_root(RUN_MNT_DIR, 0755);\n\t}\n\n\t// ... and mount tmpfs on top of it\n\tif (!tmpfs_mounted) {\n\t\t// mount tmpfs on top of /run/firejail/mnt\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on %s directory\\n\", RUN_MNT_DIR);\n\t\tif (mount(\"tmpfs\", RUN_MNT_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /run/firejail/mnt\");\n\t\ttmpfs_mounted = 1;\n\t\tfs_logger2(\"tmpfs\", RUN_MNT_DIR);\n\t}\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int tmpfs_mounted = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic int tmpfs_mounted = 0;\n\nvoid fs_build_mnt_dir(void) {\n\tstruct stat s;\n\tfs_build_firejail_dir();\n\t\n\t// create /run/firejail/mnt directory\n\tif (stat(RUN_MNT_DIR, &s)) {\n\t\tcreate_dir_as_root(RUN_MNT_DIR, 0755);\n\t}\n\n\t// ... and mount tmpfs on top of it\n\tif (!tmpfs_mounted) {\n\t\t// mount tmpfs on top of /run/firejail/mnt\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on %s directory\\n\", RUN_MNT_DIR);\n\t\tif (mount(\"tmpfs\", RUN_MNT_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /run/firejail/mnt\");\n\t\ttmpfs_mounted = 1;\n\t\tfs_logger2(\"tmpfs\", RUN_MNT_DIR);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "myexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/main.c",
          "lines": "137-149",
          "snippet": "static void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}",
          "includes": [
            "#include <sys/times.h>",
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int arg_command = 0;",
            "int arg_quiet = 0;",
            "pid_t sandbox_pid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/times.h>\n#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nint arg_command = 0;\nint arg_quiet = 0;\npid_t sandbox_pid;\n\nstatic void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: invalid /etc/passwd\\n\""
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_link",
          "args": [
            "\"/etc/passwd\""
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "is_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/util.c",
          "lines": "295-307",
          "snippet": "int is_link(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\tstruct stat s;\n\tif (lstat(fname, &s) == 0) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nint is_link(const char *fname) {\n\tassert(fname);\n\tif (*fname == '\\0')\n\t\treturn 0;\n\n\tstruct stat s;\n\tif (lstat(fname, &s) == 0) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Sanitizing /etc/passwd, UID_MIN %d\\n\"",
            "UID_MIN"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "\"/etc/passwd\"",
            "&s"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../uids.h\"\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\n#define MAXBUF 1024\n\nstatic void sanitize_passwd(void) {\n\tstruct stat s;\n\tif (stat(\"/etc/passwd\", &s) == -1)\n\t\treturn;\n\tif (arg_debug)\n\t\tprintf(\"Sanitizing /etc/passwd, UID_MIN %d\\n\", UID_MIN);\n\tif (is_link(\"/etc/passwd\")) {\n\t\tfprintf(stderr, \"Error: invalid /etc/passwd\\n\");\n\t\texit(1);\n\t}\n\n\tFILE *fpin = NULL;\n\tFILE *fpout = NULL;\n\tfs_build_mnt_dir();\n\n\t// open files\n\t/* coverity[toctou] */\n\tfpin = fopen(\"/etc/passwd\", \"r\");\n\tif (!fpin)\n\t\tgoto errout;\n\tfpout = fopen(RUN_PASSWD_FILE, \"w\");\n\tif (!fpout)\n\t\tgoto errout;\n\t\n\t// read the file line by line\n\tchar buf[MAXBUF];\n\tuid_t myuid = getuid();\n\twhile (fgets(buf, MAXBUF, fpin)) {\n\t\t// comments and empty lines\n\t\tif (*buf == '\\0' || *buf == '#')\n\t\t\tcontinue;\n\t\t\n\t\t// sample line:\n\t\t// \twww-data:x:33:33:www-data:/var/www:/bin/sh\n\t\t// drop lines with uid > 1000 and not the current user\n\t\tchar *ptr = buf;\n\t\t\n\t\t// advance to uid\n\t\twhile (*ptr != ':' && *ptr != '\\0')\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errout;\n\t\tchar *ptr1 = ptr;\n\t\tptr++;\n\t\twhile (*ptr != ':' && *ptr != '\\0')\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errout;\n\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\tgoto errout;\n\n\t\t// process uid\n\t\tint uid;\n\t\tint rv = sscanf(ptr, \"%d:\", &uid);\n\t\tif (rv == 0 || uid < 0)\n\t\t\tgoto errout;\n\t\tif (uid < UID_MIN) {\n\t\t\tfprintf(fpout, \"%s\", buf);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((uid_t) uid != myuid) {\n\t\t\t// store user name - necessary to process /etc/group\n\t\t\t*ptr1 = '\\0';\n\t\t\tchar *user = strdup(buf);\n\t\t\tif (!user)\n\t\t\t\terrExit(\"malloc\");\n\t\t\tulist_add(user);\n\t\t\tcontinue; // skip line\n\t\t}\n\t\tfprintf(fpout, \"%s\", buf);\n\t}\n\tfclose(fpin);\n\tSET_PERMS_STREAM(fpout, 0, 0, 0644);\n\tfclose(fpout);\n\n\t// mount-bind tne new password file\n\tif (mount(RUN_PASSWD_FILE, \"/etc/passwd\", \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\terrExit(\"mount\");\n\tfs_logger(\"create /etc/passwd\");\n\t\n\treturn;\t\n\t\nerrout:\n\tfprintf(stderr, \"Warning: failed to clean up /etc/passwd\\n\");\n\tif (fpin)\n\t\tfclose(fpin);\n\tif (fpout)\n\t\tfclose(fpout);\n}"
  },
  {
    "function_name": "sanitize_home",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/restrict_users.c",
    "lines": "63-115",
    "snippet": "static void sanitize_home(void) {\n\tassert(getuid() != 0);\t// this code works only for regular users\n\t\n\tif (arg_debug)\n\t\tprintf(\"Cleaning /home directory\\n\");\n\t\n\tstruct stat s;\n\tif (stat(cfg.homedir, &s) == -1) {\n\t\t// cannot find home directory, just return\n\t\tfprintf(stderr, \"Warning: cannot find home directory\\n\");\n\t\treturn;\n\t}\n\t\n\tfs_build_mnt_dir();\n\tif (mkdir(RUN_WHITELIST_HOME_DIR, 0755) == -1)\n\t\terrExit(\"mkdir\");\n\n\t// keep a copy of the user home directory\n\tif (mount(cfg.homedir, RUN_WHITELIST_HOME_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\n\t// mount tmpfs in the new home\n\tif (mount(\"tmpfs\", \"/home\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\terrExit(\"mount tmpfs\");\n\tfs_logger(\"tmpfs /home\");\n\n\t// create user home directory\n\tif (mkdir(cfg.homedir, 0755) == -1) {\n\t\tif (mkpath_as_root(cfg.homedir))\n\t\t\terrExit(\"mkpath\");\n\t\tif (mkdir(cfg.homedir, 0755) == -1)\n\t\t\terrExit(\"mkdir\");\n\t}\n\tfs_logger2(\"mkdir\", cfg.homedir);\n\t\n\t// set mode and ownership\n\tif (chown(cfg.homedir, s.st_uid, s.st_gid) == -1)\n\t\terrExit(\"chown\");\n\tif (chmod(cfg.homedir, s.st_mode) == -1)\n\t\terrExit(\"chmod\");\n\n\t// mount user home directory\n\tif (mount(RUN_WHITELIST_HOME_DIR, cfg.homedir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\n\t// mask home dir under /run\n\tif (mount(\"tmpfs\", RUN_WHITELIST_HOME_DIR, \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\terrExit(\"mount tmpfs\");\n\tfs_logger2(\"tmpfs\", RUN_WHITELIST_HOME_DIR);\n\tif (!arg_private)\n\t\tfs_logger2(\"whitelist\", cfg.homedir);\n\t\n}",
    "includes": [
      "#include \"../../uids.h\"",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_logger2",
          "args": [
            "\"whitelist\"",
            "cfg.homedir"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger2int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_logger.c",
          "lines": "73-80",
          "snippet": "void fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nvoid fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount tmpfs\""
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"tmpfs\"",
            "RUN_WHITELIST_HOME_DIR",
            "\"tmpfs\"",
            "MS_NOSUID | MS_NODEV | MS_STRICTATIME | MS_REC",
            "\"mode=755,gid=0\""
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount bind\""
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "RUN_WHITELIST_HOME_DIR",
            "cfg.homedir",
            "NULL",
            "MS_BIND|MS_REC",
            "NULL"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"chmod\""
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chmod",
          "args": [
            "cfg.homedir",
            "s.st_mode"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"chown\""
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chown",
          "args": [
            "cfg.homedir",
            "s.st_uid",
            "s.st_gid"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mkdir\""
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "cfg.homedir",
            "0755"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mkpath\""
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkpath_as_root",
          "args": [
            "cfg.homedir"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "mkpath_as_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/util.c",
          "lines": "84-118",
          "snippet": "int mkpath_as_root(const char* path) {\n\tassert(path && *path);\n\n\t// work on a copy of the path\n\tchar *file_path = strdup(path);\n\tif (!file_path)\n\t\terrExit(\"strdup\");\n\n\tchar* p;\n\tint done = 0;\n\tfor (p=strchr(file_path+1, '/'); p; p=strchr(p+1, '/')) {\n\t\t*p='\\0';\n\t\tif (mkdir(file_path, 0755)==-1) {\n\t\t\tif (errno != EEXIST) {\n\t\t\t\t*p='/';\n\t\t\t\tfree(file_path);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (chmod(file_path, 0755) == -1)\n\t\t\t\terrExit(\"chmod\");\n\t\t\tif (chown(file_path, 0, 0) == -1)\n\t\t\t\terrExit(\"chown\");\n\t\t\tdone = 1;\n\t\t}\n\n\t\t*p='/';\n\t}\n\tif (done)\n\t\tfs_logger2(\"mkpath\", path);\n\n\tfree(file_path);\n\treturn 0;\n}",
          "includes": [
            "#include <sys/wait.h>",
            "#include <termios.h>",
            "#include <sys/ioctl.h>",
            "#include <grp.h>",
            "#include <dirent.h>",
            "#include <errno.h>",
            "#include <syslog.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <ftw.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <grp.h>\n#include <dirent.h>\n#include <errno.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <ftw.h>\n#include \"firejail.h\"\n\nint mkpath_as_root(const char* path) {\n\tassert(path && *path);\n\n\t// work on a copy of the path\n\tchar *file_path = strdup(path);\n\tif (!file_path)\n\t\terrExit(\"strdup\");\n\n\tchar* p;\n\tint done = 0;\n\tfor (p=strchr(file_path+1, '/'); p; p=strchr(p+1, '/')) {\n\t\t*p='\\0';\n\t\tif (mkdir(file_path, 0755)==-1) {\n\t\t\tif (errno != EEXIST) {\n\t\t\t\t*p='/';\n\t\t\t\tfree(file_path);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (chmod(file_path, 0755) == -1)\n\t\t\t\terrExit(\"chmod\");\n\t\t\tif (chown(file_path, 0, 0) == -1)\n\t\t\t\terrExit(\"chown\");\n\t\t\tdone = 1;\n\t\t}\n\n\t\t*p='/';\n\t}\n\tif (done)\n\t\tfs_logger2(\"mkpath\", path);\n\n\tfree(file_path);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "cfg.homedir",
            "0755"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_logger",
          "args": [
            "\"tmpfs /home\""
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "fs_logger_print_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs_logger.c",
          "lines": "136-189",
          "snippet": "void fs_logger_print_log(pid_t pid) {\n\tEUID_ASSERT();\n\n\t// if the pid is that of a firejail  process, use the pid of the first child process\n\tEUID_ROOT();\n\tchar *comm = pid_proc_comm(pid);\n\tEUID_USER();\n\tif (comm) {\n\t\tif (strcmp(comm, \"firejail\") == 0) {\n\t\t\tpid_t child;\n\t\t\tif (find_child(pid, &child) == 0) {\n\t\t\t\tpid = child;\n\t\t\t}\n\t\t}\n\t\tfree(comm);\n\t}\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission denied\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// print RUN_FSLOGGER_FILE\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_FSLOGGER_FILE) == -1)\n\t\terrExit(\"asprintf\");\n\n\tEUID_ROOT();\n\tstruct stat s;\n\tif (stat(fname, &s) == -1) {\n\t\tfprintf(stderr, \"Error: Cannot access filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: Cannot open filesystem log\\n\");\n\t\texit(1);\n\t}\n\t\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp))\n\t\tprintf(\"%s\", buf);\n\tfclose(fp);\n\tfree(fname);\n\n\texit(0);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [
            "#define MAXBUF 4098"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\n#define MAXBUF 4098\n\nvoid fs_logger_print_log(pid_t pid) {\n\tEUID_ASSERT();\n\n\t// if the pid is that of a firejail  process, use the pid of the first child process\n\tEUID_ROOT();\n\tchar *comm = pid_proc_comm(pid);\n\tEUID_USER();\n\tif (comm) {\n\t\tif (strcmp(comm, \"firejail\") == 0) {\n\t\t\tpid_t child;\n\t\t\tif (find_child(pid, &child) == 0) {\n\t\t\t\tpid = child;\n\t\t\t}\n\t\t}\n\t\tfree(comm);\n\t}\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission denied\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// print RUN_FSLOGGER_FILE\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_FSLOGGER_FILE) == -1)\n\t\terrExit(\"asprintf\");\n\n\tEUID_ROOT();\n\tstruct stat s;\n\tif (stat(fname, &s) == -1) {\n\t\tfprintf(stderr, \"Error: Cannot access filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: Cannot open filesystem log\\n\");\n\t\texit(1);\n\t}\n\t\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp))\n\t\tprintf(\"%s\", buf);\n\tfclose(fp);\n\tfree(fname);\n\n\texit(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount tmpfs\""
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"tmpfs\"",
            "\"/home\"",
            "\"tmpfs\"",
            "MS_NOSUID | MS_NODEV | MS_STRICTATIME | MS_REC",
            "\"mode=755,gid=0\""
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mount bind\""
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "cfg.homedir",
            "RUN_WHITELIST_HOME_DIR",
            "NULL",
            "MS_BIND|MS_REC",
            "NULL"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mkdir\""
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "RUN_WHITELIST_HOME_DIR",
            "0755"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_build_mnt_dir",
          "args": [],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "fs_build_mnt_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
          "lines": "126-145",
          "snippet": "void fs_build_mnt_dir(void) {\n\tstruct stat s;\n\tfs_build_firejail_dir();\n\t\n\t// create /run/firejail/mnt directory\n\tif (stat(RUN_MNT_DIR, &s)) {\n\t\tcreate_dir_as_root(RUN_MNT_DIR, 0755);\n\t}\n\n\t// ... and mount tmpfs on top of it\n\tif (!tmpfs_mounted) {\n\t\t// mount tmpfs on top of /run/firejail/mnt\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on %s directory\\n\", RUN_MNT_DIR);\n\t\tif (mount(\"tmpfs\", RUN_MNT_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /run/firejail/mnt\");\n\t\ttmpfs_mounted = 1;\n\t\tfs_logger2(\"tmpfs\", RUN_MNT_DIR);\n\t}\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int tmpfs_mounted = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic int tmpfs_mounted = 0;\n\nvoid fs_build_mnt_dir(void) {\n\tstruct stat s;\n\tfs_build_firejail_dir();\n\t\n\t// create /run/firejail/mnt directory\n\tif (stat(RUN_MNT_DIR, &s)) {\n\t\tcreate_dir_as_root(RUN_MNT_DIR, 0755);\n\t}\n\n\t// ... and mount tmpfs on top of it\n\tif (!tmpfs_mounted) {\n\t\t// mount tmpfs on top of /run/firejail/mnt\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on %s directory\\n\", RUN_MNT_DIR);\n\t\tif (mount(\"tmpfs\", RUN_MNT_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /run/firejail/mnt\");\n\t\ttmpfs_mounted = 1;\n\t\tfs_logger2(\"tmpfs\", RUN_MNT_DIR);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning: cannot find home directory\\n\""
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "cfg.homedir",
            "&s"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Cleaning /home directory\\n\""
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "getuid() != 0"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../uids.h\"\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nstatic void sanitize_home(void) {\n\tassert(getuid() != 0);\t// this code works only for regular users\n\t\n\tif (arg_debug)\n\t\tprintf(\"Cleaning /home directory\\n\");\n\t\n\tstruct stat s;\n\tif (stat(cfg.homedir, &s) == -1) {\n\t\t// cannot find home directory, just return\n\t\tfprintf(stderr, \"Warning: cannot find home directory\\n\");\n\t\treturn;\n\t}\n\t\n\tfs_build_mnt_dir();\n\tif (mkdir(RUN_WHITELIST_HOME_DIR, 0755) == -1)\n\t\terrExit(\"mkdir\");\n\n\t// keep a copy of the user home directory\n\tif (mount(cfg.homedir, RUN_WHITELIST_HOME_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\n\t// mount tmpfs in the new home\n\tif (mount(\"tmpfs\", \"/home\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\terrExit(\"mount tmpfs\");\n\tfs_logger(\"tmpfs /home\");\n\n\t// create user home directory\n\tif (mkdir(cfg.homedir, 0755) == -1) {\n\t\tif (mkpath_as_root(cfg.homedir))\n\t\t\terrExit(\"mkpath\");\n\t\tif (mkdir(cfg.homedir, 0755) == -1)\n\t\t\terrExit(\"mkdir\");\n\t}\n\tfs_logger2(\"mkdir\", cfg.homedir);\n\t\n\t// set mode and ownership\n\tif (chown(cfg.homedir, s.st_uid, s.st_gid) == -1)\n\t\terrExit(\"chown\");\n\tif (chmod(cfg.homedir, s.st_mode) == -1)\n\t\terrExit(\"chmod\");\n\n\t// mount user home directory\n\tif (mount(RUN_WHITELIST_HOME_DIR, cfg.homedir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\n\t// mask home dir under /run\n\tif (mount(\"tmpfs\", RUN_WHITELIST_HOME_DIR, \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME | MS_REC,  \"mode=755,gid=0\") < 0)\n\t\terrExit(\"mount tmpfs\");\n\tfs_logger2(\"tmpfs\", RUN_WHITELIST_HOME_DIR);\n\tif (!arg_private)\n\t\tfs_logger2(\"whitelist\", cfg.homedir);\n\t\n}"
  },
  {
    "function_name": "ulist_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/restrict_users.c",
    "lines": "50-61",
    "snippet": "static USER_LIST *ulist_find(const char *user) {\n\tassert(user);\n\n\tUSER_LIST *ptr = ulist;\n\twhile (ptr) {\n\t\tif (strcmp(ptr->user, user) == 0)\n\t\t\treturn ptr;\n\t\tptr = ptr->next;\n\t}\n\t\n\treturn NULL;\n}",
    "includes": [
      "#include \"../../uids.h\"",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "USER_LIST *ulist = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr->user",
            "user"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "user"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../uids.h\"\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nUSER_LIST *ulist = NULL;\n\nstatic USER_LIST *ulist_find(const char *user) {\n\tassert(user);\n\n\tUSER_LIST *ptr = ulist;\n\twhile (ptr) {\n\t\tif (strcmp(ptr->user, user) == 0)\n\t\t\treturn ptr;\n\t\tptr = ptr->next;\n\t}\n\t\n\treturn NULL;\n}"
  },
  {
    "function_name": "ulist_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/restrict_users.c",
    "lines": "40-48",
    "snippet": "static void ulist_add(const char *user) {\n\tassert(user);\n\n\tUSER_LIST *nlist = malloc(sizeof(USER_LIST));\n\tmemset(nlist, 0, sizeof(USER_LIST));\n\tnlist->user = user;\n\tnlist->next = ulist;\n\tulist = nlist;\n}",
    "includes": [
      "#include \"../../uids.h\"",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include <glob.h>",
      "#include <fnmatch.h>",
      "#include <linux/limits.h>",
      "#include <sys/stat.h>",
      "#include <sys/mount.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "USER_LIST *ulist = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "nlist",
            "0",
            "sizeof(USER_LIST)"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(USER_LIST)"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "user"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../../uids.h\"\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nUSER_LIST *ulist = NULL;\n\nstatic void ulist_add(const char *user) {\n\tassert(user);\n\n\tUSER_LIST *nlist = malloc(sizeof(USER_LIST));\n\tmemset(nlist, 0, sizeof(USER_LIST));\n\tnlist->user = user;\n\tnlist->next = ulist;\n\tulist = nlist;\n}"
  }
]