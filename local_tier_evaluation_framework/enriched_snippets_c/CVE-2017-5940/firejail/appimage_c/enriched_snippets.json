[
  {
    "function_name": "appimage_clear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/appimage.c",
    "lines": "126-163",
    "snippet": "void appimage_clear(void) {\n\tint rv;\n\n\tEUID_ROOT();\n\tif (mntdir) {\n\t\tint i;\n\t\tint rv = 0;\n\t\tfor (i = 0; i < 5; i++) {\n\t\t\trv = umount2(mntdir, MNT_FORCE);\n\t\t\tif (rv == 0)\n\t\t\t\tbreak;\n\t\t\tif (rv == -1 && errno == EBUSY) {\n\t\t\t\tif (!arg_quiet)\n\t\t\t\t\tprintf(\"Warning: EBUSY error trying to unmount %s\\n\", mntdir);\t\t\t\n\t\t\t\tsleep(2);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t// rv = -1\n\t\t\tif (!arg_quiet) {\n\t\t\t\tprintf(\"Warning: error trying to unmount %s\\n\", mntdir);\n\t\t\t\tperror(\"umount\");\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (rv == 0) {\n\t\t\trmdir(mntdir);\n\t\t\tfree(mntdir);\n\t\t}\n\t}\n\n\tif (devloop) {\n\t\tint lfd = open(devloop, O_RDONLY);\n\t\trv = ioctl(lfd, LOOP_CLR_FD, 0);\n\t\t(void) rv;\n\t\tclose(lfd);\n\t}\n}",
    "includes": [
      "#include <errno.h>",
      "#include <linux/loop.h>",
      "#include <fcntl.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char *devloop = NULL;",
      "static char *mntdir = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "lfd"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "lfd",
            "LOOP_CLR_FD",
            "0"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "devloop",
            "O_RDONLY"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "mntdir"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rmdir",
          "args": [
            "mntdir"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"umount\""
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Warning: error trying to unmount %s\\n\"",
            "mntdir"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sleep",
          "args": [
            "2"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Warning: EBUSY error trying to unmount %s\\n\"",
            "mntdir"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umount2",
          "args": [
            "mntdir",
            "MNT_FORCE"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ROOT",
          "args": [],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <linux/loop.h>\n#include <fcntl.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nstatic char *devloop = NULL;\nstatic char *mntdir = NULL;\n\nvoid appimage_clear(void) {\n\tint rv;\n\n\tEUID_ROOT();\n\tif (mntdir) {\n\t\tint i;\n\t\tint rv = 0;\n\t\tfor (i = 0; i < 5; i++) {\n\t\t\trv = umount2(mntdir, MNT_FORCE);\n\t\t\tif (rv == 0)\n\t\t\t\tbreak;\n\t\t\tif (rv == -1 && errno == EBUSY) {\n\t\t\t\tif (!arg_quiet)\n\t\t\t\t\tprintf(\"Warning: EBUSY error trying to unmount %s\\n\", mntdir);\t\t\t\n\t\t\t\tsleep(2);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t// rv = -1\n\t\t\tif (!arg_quiet) {\n\t\t\t\tprintf(\"Warning: error trying to unmount %s\\n\", mntdir);\n\t\t\t\tperror(\"umount\");\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (rv == 0) {\n\t\t\trmdir(mntdir);\n\t\t\tfree(mntdir);\n\t\t}\n\t}\n\n\tif (devloop) {\n\t\tint lfd = open(devloop, O_RDONLY);\n\t\trv = ioctl(lfd, LOOP_CLR_FD, 0);\n\t\t(void) rv;\n\t\tclose(lfd);\n\t}\n}"
  },
  {
    "function_name": "appimage_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/appimage.c",
    "lines": "38-124",
    "snippet": "void appimage_set(const char *appimage_path) {\n\tassert(appimage_path);\n\tassert(devloop == NULL);\t// don't call this twice!\n\tEUID_ASSERT();\n\n#ifdef LOOP_CTL_GET_FREE\t// test for older kernels; this definition is found in /usr/include/linux/loop.h\n\t// check appimage_path\n\tif (access(appimage_path, R_OK) == -1) {\n\t\tfprintf(stderr, \"Error: cannot access AppImage file\\n\");\n\t\texit(1);\n\t}\n\n\t// open as user to prevent race condition\n\tint ffd = open(appimage_path, O_RDONLY|O_CLOEXEC);\n\tif (ffd == -1) {\n\t\tfprintf(stderr, \"Error: /dev/loop-control interface is not supported by your kernel\\n\");\n\t\texit(1);\n\t}\n\n\t// populate /run/firejail directory\n\tEUID_ROOT();\n\tfs_build_firejail_dir();\n\tEUID_USER();\n\n\t// find or allocate a free loop device to use\n\tEUID_ROOT();\n\tint cfd = open(\"/dev/loop-control\", O_RDWR);\n\tint devnr = ioctl(cfd, LOOP_CTL_GET_FREE);\n\tif (devnr == -1) {\n\t\tfprintf(stderr, \"Error: cannot allocate a new loopback device\\n\");\n\t\texit(1);\n\t}\n\tclose(cfd);\n\tif (asprintf(&devloop, \"/dev/loop%d\", devnr) == -1)\n\t\terrExit(\"asprintf\");\n\t\t\n\tint lfd = open(devloop, O_RDONLY);\n\tif (ioctl(lfd, LOOP_SET_FD, ffd) == -1) {\n\t\tfprintf(stderr, \"Error: cannot configure the loopback device\\n\");\n\t\texit(1);\n\t}\n\tclose(lfd);\n\tclose(ffd);\n\tEUID_USER();\n\n\t// creates appimage mount point perms 0700\n\tif (asprintf(&mntdir, \"%s/appimage-%u\",  RUN_FIREJAIL_APPIMAGE_DIR, getpid()) == -1)\n\t\terrExit(\"asprintf\");\n\tEUID_ROOT();\n\tif (mkdir(mntdir, 0700) == -1) {\n\t\tfprintf(stderr, \"Error: cannot create appimage mount point\\n\");\n\t\texit(1);\n\t}\n\tif (chmod(mntdir, 0700) == -1)\n\t\terrExit(\"chmod\");\n\tif (chown(mntdir, getuid(), getgid()) == -1)\n\t\terrExit(\"chown\");\n\tEUID_USER();\n\tASSERT_PERMS(mntdir, getuid(), getgid(), 0700);\n\t\n\t// mount\n\tchar *mode;\n\tif (asprintf(&mode, \"mode=700,uid=%d,gid=%d\", getuid(), getgid()) == -1)\n\t\terrExit(\"asprintf\");\n\tEUID_ROOT();\n\tif (mount(devloop, mntdir, \"iso9660\",MS_MGC_VAL|MS_RDONLY,  mode) < 0)\n\t\terrExit(\"mounting appimage\");\n\tif (arg_debug)\n\t\tprintf(\"appimage mounted on %s\\n\", mntdir);\n\tEUID_USER();\n\n\t// set environment\n\tif (appimage_path && setenv(\"APPIMAGE\", appimage_path, 1) < 0)\n\t\terrExit(\"setenv\");\n\tif (mntdir && setenv(\"APPDIR\", mntdir, 1) < 0)\n\t\terrExit(\"setenv\");\n\n\t// build new command line\n\tif (asprintf(&cfg.command_line, \"%s/AppRun\", mntdir) == -1)\n\t\terrExit(\"asprintf\");\n\t\n\tfree(mode);\n#else\n\tfprintf(stderr, \"Error: /dev/loop-control interface is not supported by your kernel\\n\");\n\texit(1);\n#endif\n}",
    "includes": [
      "#include <errno.h>",
      "#include <linux/loop.h>",
      "#include <fcntl.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char *devloop = NULL;",
      "static char *mntdir = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "myexit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/main.c",
          "lines": "137-149",
          "snippet": "static void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}",
          "includes": [
            "#include <sys/times.h>",
            "#include <sys/utsname.h>",
            "#include <net/if.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/prctl.h>",
            "#include <sys/file.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <pwd.h>",
            "#include <dirent.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/wait.h>",
            "#include <sys/mount.h>",
            "#include <sched.h>",
            "#include <sys/utsname.h>",
            "#include \"../include/pid.h\"",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int arg_command = 0;",
            "int arg_quiet = 0;",
            "pid_t sandbox_pid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/times.h>\n#include <sys/utsname.h>\n#include <net/if.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/prctl.h>\n#include <sys/file.h>\n#include <limits.h>\n#include <errno.h>\n#include <pwd.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <sys/utsname.h>\n#include \"../include/pid.h\"\n#include \"firejail.h\"\n\nint arg_command = 0;\nint arg_quiet = 0;\npid_t sandbox_pid;\n\nstatic void myexit(int rv) {\n\tlogmsg(\"exiting...\");\n\tif (!arg_command && !arg_quiet)\n\t\tprintf(\"\\nParent is shutting down, bye...\\n\");\n\n\n\t// delete sandbox files in shared memory\n\tEUID_ROOT();\n\tclear_run_files(sandbox_pid);\n\tappimage_clear();\n\tflush_stdin();\n\texit(rv); \n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: /dev/loop-control interface is not supported by your kernel\\n\""
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "mode"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&cfg.command_line",
            "\"%s/AppRun\"",
            "mntdir"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"setenv\""
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"APPDIR\"",
            "mntdir",
            "1"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"setenv\""
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"APPIMAGE\"",
            "appimage_path",
            "1"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_USER",
          "args": [],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"appimage mounted on %s\\n\"",
            "mntdir"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"mounting appimage\""
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "devloop",
            "mntdir",
            "\"iso9660\"",
            "MS_MGC_VAL|MS_RDONLY",
            "mode"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ROOT",
          "args": [],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&mode",
            "\"mode=700,uid=%d,gid=%d\"",
            "getuid()",
            "getgid()"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getgid",
          "args": [],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_PERMS",
          "args": [
            "mntdir",
            "getuid()",
            "getgid()",
            "0700"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getgid",
          "args": [],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_USER",
          "args": [],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"chown\""
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chown",
          "args": [
            "mntdir",
            "getuid()",
            "getgid()"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getgid",
          "args": [],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"chmod\""
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chmod",
          "args": [
            "mntdir",
            "0700"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot create appimage mount point\\n\""
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdir",
          "args": [
            "mntdir",
            "0700"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ROOT",
          "args": [],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&mntdir",
            "\"%s/appimage-%u\"",
            "RUN_FIREJAIL_APPIMAGE_DIR",
            "getpid()"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_USER",
          "args": [],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "ffd"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "lfd"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot configure the loopback device\\n\""
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "lfd",
            "LOOP_SET_FD",
            "ffd"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "devloop",
            "O_RDONLY"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errExit",
          "args": [
            "\"asprintf\""
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&devloop",
            "\"/dev/loop%d\"",
            "devnr"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "cfd"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot allocate a new loopback device\\n\""
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "cfd",
            "LOOP_CTL_GET_FREE"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "\"/dev/loop-control\"",
            "O_RDWR"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ROOT",
          "args": [],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_USER",
          "args": [],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_build_firejail_dir",
          "args": [],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "fs_build_firejail_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/fs.c",
          "lines": "73-114",
          "snippet": "void fs_build_firejail_dir(void) {\n\tstruct stat s;\n\n\t// CentOS 6 doesn't have /run directory\n\tif (stat(RUN_FIREJAIL_BASEDIR, &s)) {\n\t\tcreate_dir_as_root(RUN_FIREJAIL_BASEDIR, 0755);\n\t}\n\n\t// check /run/firejail directory belongs to root end exit if doesn't!\n\tif (stat(RUN_FIREJAIL_DIR, &s) == 0) {\n\t\tif (s.st_uid != 0 || s.st_gid != 0) {\n\t\t\tfprintf(stderr, \"Error: non-root %s directory, exiting...\\n\", RUN_FIREJAIL_DIR);\n\t\t\texit(1);\n\t\t}\n\t}\n\telse {\n\t\tcreate_dir_as_root(RUN_FIREJAIL_DIR, 0755);\n\t}\n\t\n\tif (stat(RUN_FIREJAIL_NETWORK_DIR, &s)) {\n\t\tcreate_dir_as_root(RUN_FIREJAIL_NETWORK_DIR, 0755);\n\t}\n\t\n\tif (stat(RUN_FIREJAIL_BANDWIDTH_DIR, &s)) {\n\t\tcreate_dir_as_root(RUN_FIREJAIL_BANDWIDTH_DIR, 0755);\n\t}\n\t\t\n\tif (stat(RUN_FIREJAIL_NAME_DIR, &s)) {\n\t\tcreate_dir_as_root(RUN_FIREJAIL_NAME_DIR, 0755);\n\t}\n\t\n\tif (stat(RUN_FIREJAIL_X11_DIR, &s)) {\n\t\tcreate_dir_as_root(RUN_FIREJAIL_X11_DIR, 0755);\n\t}\n\t\n\tif (stat(RUN_FIREJAIL_APPIMAGE_DIR, &s)) {\n\t\tcreate_dir_as_root(RUN_FIREJAIL_APPIMAGE_DIR, 0755);\n\t}\n\t\n\tcreate_empty_dir();\n\tcreate_empty_file();\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <glob.h>",
            "#include <fnmatch.h>",
            "#include <linux/limits.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include \"firejail.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <glob.h>\n#include <fnmatch.h>\n#include <linux/limits.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\nvoid fs_build_firejail_dir(void) {\n\tstruct stat s;\n\n\t// CentOS 6 doesn't have /run directory\n\tif (stat(RUN_FIREJAIL_BASEDIR, &s)) {\n\t\tcreate_dir_as_root(RUN_FIREJAIL_BASEDIR, 0755);\n\t}\n\n\t// check /run/firejail directory belongs to root end exit if doesn't!\n\tif (stat(RUN_FIREJAIL_DIR, &s) == 0) {\n\t\tif (s.st_uid != 0 || s.st_gid != 0) {\n\t\t\tfprintf(stderr, \"Error: non-root %s directory, exiting...\\n\", RUN_FIREJAIL_DIR);\n\t\t\texit(1);\n\t\t}\n\t}\n\telse {\n\t\tcreate_dir_as_root(RUN_FIREJAIL_DIR, 0755);\n\t}\n\t\n\tif (stat(RUN_FIREJAIL_NETWORK_DIR, &s)) {\n\t\tcreate_dir_as_root(RUN_FIREJAIL_NETWORK_DIR, 0755);\n\t}\n\t\n\tif (stat(RUN_FIREJAIL_BANDWIDTH_DIR, &s)) {\n\t\tcreate_dir_as_root(RUN_FIREJAIL_BANDWIDTH_DIR, 0755);\n\t}\n\t\t\n\tif (stat(RUN_FIREJAIL_NAME_DIR, &s)) {\n\t\tcreate_dir_as_root(RUN_FIREJAIL_NAME_DIR, 0755);\n\t}\n\t\n\tif (stat(RUN_FIREJAIL_X11_DIR, &s)) {\n\t\tcreate_dir_as_root(RUN_FIREJAIL_X11_DIR, 0755);\n\t}\n\t\n\tif (stat(RUN_FIREJAIL_APPIMAGE_DIR, &s)) {\n\t\tcreate_dir_as_root(RUN_FIREJAIL_APPIMAGE_DIR, 0755);\n\t}\n\t\n\tcreate_empty_dir();\n\tcreate_empty_file();\n}"
        }
      },
      {
        "call_info": {
          "callee": "EUID_ROOT",
          "args": [],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: /dev/loop-control interface is not supported by your kernel\\n\""
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "appimage_path",
            "O_RDONLY|O_CLOEXEC"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: cannot access AppImage file\\n\""
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "appimage_path",
            "R_OK"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EUID_ASSERT",
          "args": [],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "devloop == NULL"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "appimage_path"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <linux/loop.h>\n#include <fcntl.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nstatic char *devloop = NULL;\nstatic char *mntdir = NULL;\n\nvoid appimage_set(const char *appimage_path) {\n\tassert(appimage_path);\n\tassert(devloop == NULL);\t// don't call this twice!\n\tEUID_ASSERT();\n\n#ifdef LOOP_CTL_GET_FREE\t// test for older kernels; this definition is found in /usr/include/linux/loop.h\n\t// check appimage_path\n\tif (access(appimage_path, R_OK) == -1) {\n\t\tfprintf(stderr, \"Error: cannot access AppImage file\\n\");\n\t\texit(1);\n\t}\n\n\t// open as user to prevent race condition\n\tint ffd = open(appimage_path, O_RDONLY|O_CLOEXEC);\n\tif (ffd == -1) {\n\t\tfprintf(stderr, \"Error: /dev/loop-control interface is not supported by your kernel\\n\");\n\t\texit(1);\n\t}\n\n\t// populate /run/firejail directory\n\tEUID_ROOT();\n\tfs_build_firejail_dir();\n\tEUID_USER();\n\n\t// find or allocate a free loop device to use\n\tEUID_ROOT();\n\tint cfd = open(\"/dev/loop-control\", O_RDWR);\n\tint devnr = ioctl(cfd, LOOP_CTL_GET_FREE);\n\tif (devnr == -1) {\n\t\tfprintf(stderr, \"Error: cannot allocate a new loopback device\\n\");\n\t\texit(1);\n\t}\n\tclose(cfd);\n\tif (asprintf(&devloop, \"/dev/loop%d\", devnr) == -1)\n\t\terrExit(\"asprintf\");\n\t\t\n\tint lfd = open(devloop, O_RDONLY);\n\tif (ioctl(lfd, LOOP_SET_FD, ffd) == -1) {\n\t\tfprintf(stderr, \"Error: cannot configure the loopback device\\n\");\n\t\texit(1);\n\t}\n\tclose(lfd);\n\tclose(ffd);\n\tEUID_USER();\n\n\t// creates appimage mount point perms 0700\n\tif (asprintf(&mntdir, \"%s/appimage-%u\",  RUN_FIREJAIL_APPIMAGE_DIR, getpid()) == -1)\n\t\terrExit(\"asprintf\");\n\tEUID_ROOT();\n\tif (mkdir(mntdir, 0700) == -1) {\n\t\tfprintf(stderr, \"Error: cannot create appimage mount point\\n\");\n\t\texit(1);\n\t}\n\tif (chmod(mntdir, 0700) == -1)\n\t\terrExit(\"chmod\");\n\tif (chown(mntdir, getuid(), getgid()) == -1)\n\t\terrExit(\"chown\");\n\tEUID_USER();\n\tASSERT_PERMS(mntdir, getuid(), getgid(), 0700);\n\t\n\t// mount\n\tchar *mode;\n\tif (asprintf(&mode, \"mode=700,uid=%d,gid=%d\", getuid(), getgid()) == -1)\n\t\terrExit(\"asprintf\");\n\tEUID_ROOT();\n\tif (mount(devloop, mntdir, \"iso9660\",MS_MGC_VAL|MS_RDONLY,  mode) < 0)\n\t\terrExit(\"mounting appimage\");\n\tif (arg_debug)\n\t\tprintf(\"appimage mounted on %s\\n\", mntdir);\n\tEUID_USER();\n\n\t// set environment\n\tif (appimage_path && setenv(\"APPIMAGE\", appimage_path, 1) < 0)\n\t\terrExit(\"setenv\");\n\tif (mntdir && setenv(\"APPDIR\", mntdir, 1) < 0)\n\t\terrExit(\"setenv\");\n\n\t// build new command line\n\tif (asprintf(&cfg.command_line, \"%s/AppRun\", mntdir) == -1)\n\t\terrExit(\"asprintf\");\n\t\n\tfree(mode);\n#else\n\tfprintf(stderr, \"Error: /dev/loop-control interface is not supported by your kernel\\n\");\n\texit(1);\n#endif\n}"
  },
  {
    "function_name": "appimage_getdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-5940/repo/src/firejail/appimage.c",
    "lines": "34-36",
    "snippet": "const char *appimage_getdir(void) {\n\treturn mntdir;\n}",
    "includes": [
      "#include <errno.h>",
      "#include <linux/loop.h>",
      "#include <fcntl.h>",
      "#include <sys/mount.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include \"firejail.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char *mntdir = NULL;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <errno.h>\n#include <linux/loop.h>\n#include <fcntl.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include \"firejail.h\"\n\nstatic char *mntdir = NULL;\n\nconst char *appimage_getdir(void) {\n\treturn mntdir;\n}"
  }
]