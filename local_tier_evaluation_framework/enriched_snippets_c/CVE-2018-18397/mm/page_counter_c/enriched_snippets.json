[
  {
    "function_name": "page_counter_memparse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
    "lines": "248-266",
    "snippet": "int page_counter_memparse(const char *buf, const char *max,\n\t\t\t  unsigned long *nr_pages)\n{\n\tchar *end;\n\tu64 bytes;\n\n\tif (!strcmp(buf, max)) {\n\t\t*nr_pages = PAGE_COUNTER_MAX;\n\t\treturn 0;\n\t}\n\n\tbytes = memparse(buf, &end);\n\tif (*end != '\\0')\n\t\treturn -EINVAL;\n\n\t*nr_pages = min(bytes / PAGE_SIZE, (u64)PAGE_COUNTER_MAX);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <linux/atomic.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min",
          "args": [
            "bytes / PAGE_SIZE",
            "(u64)PAGE_COUNTER_MAX"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "page_counter_set_min",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
          "lines": "212-220",
          "snippet": "void page_counter_set_min(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tcounter->min = nr_pages;\n\n\tfor (c = counter; c; c = c->parent)\n\t\tpropagate_protected_usage(c, atomic_long_read(&c->usage));\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/atomic.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nvoid page_counter_set_min(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tcounter->min = nr_pages;\n\n\tfor (c = counter; c; c = c->parent)\n\t\tpropagate_protected_usage(c, atomic_long_read(&c->usage));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memparse",
          "args": [
            "buf",
            "&end"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "buf",
            "max"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nint page_counter_memparse(const char *buf, const char *max,\n\t\t\t  unsigned long *nr_pages)\n{\n\tchar *end;\n\tu64 bytes;\n\n\tif (!strcmp(buf, max)) {\n\t\t*nr_pages = PAGE_COUNTER_MAX;\n\t\treturn 0;\n\t}\n\n\tbytes = memparse(buf, &end);\n\tif (*end != '\\0')\n\t\treturn -EINVAL;\n\n\t*nr_pages = min(bytes / PAGE_SIZE, (u64)PAGE_COUNTER_MAX);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "page_counter_set_low",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
    "lines": "229-237",
    "snippet": "void page_counter_set_low(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tcounter->low = nr_pages;\n\n\tfor (c = counter; c; c = c->parent)\n\t\tpropagate_protected_usage(c, atomic_long_read(&c->usage));\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <linux/atomic.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "propagate_protected_usage",
          "args": [
            "c",
            "atomic_long_read(&c->usage)"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "propagate_protected_usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
          "lines": "16-48",
          "snippet": "static void propagate_protected_usage(struct page_counter *c,\n\t\t\t\t      unsigned long usage)\n{\n\tunsigned long protected, old_protected;\n\tlong delta;\n\n\tif (!c->parent)\n\t\treturn;\n\n\tif (c->min || atomic_long_read(&c->min_usage)) {\n\t\tif (usage <= c->min)\n\t\t\tprotected = usage;\n\t\telse\n\t\t\tprotected = 0;\n\n\t\told_protected = atomic_long_xchg(&c->min_usage, protected);\n\t\tdelta = protected - old_protected;\n\t\tif (delta)\n\t\t\tatomic_long_add(delta, &c->parent->children_min_usage);\n\t}\n\n\tif (c->low || atomic_long_read(&c->low_usage)) {\n\t\tif (usage <= c->low)\n\t\t\tprotected = usage;\n\t\telse\n\t\t\tprotected = 0;\n\n\t\told_protected = atomic_long_xchg(&c->low_usage, protected);\n\t\tdelta = protected - old_protected;\n\t\tif (delta)\n\t\t\tatomic_long_add(delta, &c->parent->children_low_usage);\n\t}\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/atomic.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nstatic void propagate_protected_usage(struct page_counter *c,\n\t\t\t\t      unsigned long usage)\n{\n\tunsigned long protected, old_protected;\n\tlong delta;\n\n\tif (!c->parent)\n\t\treturn;\n\n\tif (c->min || atomic_long_read(&c->min_usage)) {\n\t\tif (usage <= c->min)\n\t\t\tprotected = usage;\n\t\telse\n\t\t\tprotected = 0;\n\n\t\told_protected = atomic_long_xchg(&c->min_usage, protected);\n\t\tdelta = protected - old_protected;\n\t\tif (delta)\n\t\t\tatomic_long_add(delta, &c->parent->children_min_usage);\n\t}\n\n\tif (c->low || atomic_long_read(&c->low_usage)) {\n\t\tif (usage <= c->low)\n\t\t\tprotected = usage;\n\t\telse\n\t\t\tprotected = 0;\n\n\t\told_protected = atomic_long_xchg(&c->low_usage, protected);\n\t\tdelta = protected - old_protected;\n\t\tif (delta)\n\t\t\tatomic_long_add(delta, &c->parent->children_low_usage);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&c->usage"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nvoid page_counter_set_low(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tcounter->low = nr_pages;\n\n\tfor (c = counter; c; c = c->parent)\n\t\tpropagate_protected_usage(c, atomic_long_read(&c->usage));\n}"
  },
  {
    "function_name": "page_counter_set_min",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
    "lines": "212-220",
    "snippet": "void page_counter_set_min(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tcounter->min = nr_pages;\n\n\tfor (c = counter; c; c = c->parent)\n\t\tpropagate_protected_usage(c, atomic_long_read(&c->usage));\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <linux/atomic.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "propagate_protected_usage",
          "args": [
            "c",
            "atomic_long_read(&c->usage)"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "propagate_protected_usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
          "lines": "16-48",
          "snippet": "static void propagate_protected_usage(struct page_counter *c,\n\t\t\t\t      unsigned long usage)\n{\n\tunsigned long protected, old_protected;\n\tlong delta;\n\n\tif (!c->parent)\n\t\treturn;\n\n\tif (c->min || atomic_long_read(&c->min_usage)) {\n\t\tif (usage <= c->min)\n\t\t\tprotected = usage;\n\t\telse\n\t\t\tprotected = 0;\n\n\t\told_protected = atomic_long_xchg(&c->min_usage, protected);\n\t\tdelta = protected - old_protected;\n\t\tif (delta)\n\t\t\tatomic_long_add(delta, &c->parent->children_min_usage);\n\t}\n\n\tif (c->low || atomic_long_read(&c->low_usage)) {\n\t\tif (usage <= c->low)\n\t\t\tprotected = usage;\n\t\telse\n\t\t\tprotected = 0;\n\n\t\told_protected = atomic_long_xchg(&c->low_usage, protected);\n\t\tdelta = protected - old_protected;\n\t\tif (delta)\n\t\t\tatomic_long_add(delta, &c->parent->children_low_usage);\n\t}\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/atomic.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nstatic void propagate_protected_usage(struct page_counter *c,\n\t\t\t\t      unsigned long usage)\n{\n\tunsigned long protected, old_protected;\n\tlong delta;\n\n\tif (!c->parent)\n\t\treturn;\n\n\tif (c->min || atomic_long_read(&c->min_usage)) {\n\t\tif (usage <= c->min)\n\t\t\tprotected = usage;\n\t\telse\n\t\t\tprotected = 0;\n\n\t\told_protected = atomic_long_xchg(&c->min_usage, protected);\n\t\tdelta = protected - old_protected;\n\t\tif (delta)\n\t\t\tatomic_long_add(delta, &c->parent->children_min_usage);\n\t}\n\n\tif (c->low || atomic_long_read(&c->low_usage)) {\n\t\tif (usage <= c->low)\n\t\t\tprotected = usage;\n\t\telse\n\t\t\tprotected = 0;\n\n\t\told_protected = atomic_long_xchg(&c->low_usage, protected);\n\t\tdelta = protected - old_protected;\n\t\tif (delta)\n\t\t\tatomic_long_add(delta, &c->parent->children_low_usage);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&c->usage"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nvoid page_counter_set_min(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tcounter->min = nr_pages;\n\n\tfor (c = counter; c; c = c->parent)\n\t\tpropagate_protected_usage(c, atomic_long_read(&c->usage));\n}"
  },
  {
    "function_name": "page_counter_set_max",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
    "lines": "173-203",
    "snippet": "int page_counter_set_max(struct page_counter *counter, unsigned long nr_pages)\n{\n\tfor (;;) {\n\t\tunsigned long old;\n\t\tlong usage;\n\n\t\t/*\n\t\t * Update the limit while making sure that it's not\n\t\t * below the concurrently-changing counter value.\n\t\t *\n\t\t * The xchg implies two full memory barriers before\n\t\t * and after, so the read-swap-read is ordered and\n\t\t * ensures coherency with page_counter_try_charge():\n\t\t * that function modifies the count before checking\n\t\t * the limit, so if it sees the old limit, we see the\n\t\t * modified counter and retry.\n\t\t */\n\t\tusage = atomic_long_read(&counter->usage);\n\n\t\tif (usage > nr_pages)\n\t\t\treturn -EBUSY;\n\n\t\told = xchg(&counter->max, nr_pages);\n\n\t\tif (atomic_long_read(&counter->usage) <= usage)\n\t\t\treturn 0;\n\n\t\tcounter->max = old;\n\t\tcond_resched();\n\t}\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <linux/atomic.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&counter->usage"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "&counter->max",
            "nr_pages"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "page_cpupid_xchg_last",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmzone.c",
          "lines": "100-114",
          "snippet": "int page_cpupid_xchg_last(struct page *page, int cpupid)\n{\n\tunsigned long old_flags, flags;\n\tint last_cpupid;\n\n\tdo {\n\t\told_flags = flags = page->flags;\n\t\tlast_cpupid = page_cpupid_last(page);\n\n\t\tflags &= ~(LAST_CPUPID_MASK << LAST_CPUPID_PGSHIFT);\n\t\tflags |= (cpupid & LAST_CPUPID_MASK) << LAST_CPUPID_PGSHIFT;\n\t} while (unlikely(cmpxchg(&page->flags, old_flags, flags) != old_flags));\n\n\treturn last_cpupid;\n}",
          "includes": [
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nint page_cpupid_xchg_last(struct page *page, int cpupid)\n{\n\tunsigned long old_flags, flags;\n\tint last_cpupid;\n\n\tdo {\n\t\told_flags = flags = page->flags;\n\t\tlast_cpupid = page_cpupid_last(page);\n\n\t\tflags &= ~(LAST_CPUPID_MASK << LAST_CPUPID_PGSHIFT);\n\t\tflags |= (cpupid & LAST_CPUPID_MASK) << LAST_CPUPID_PGSHIFT;\n\t} while (unlikely(cmpxchg(&page->flags, old_flags, flags) != old_flags));\n\n\treturn last_cpupid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&counter->usage"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nint page_counter_set_max(struct page_counter *counter, unsigned long nr_pages)\n{\n\tfor (;;) {\n\t\tunsigned long old;\n\t\tlong usage;\n\n\t\t/*\n\t\t * Update the limit while making sure that it's not\n\t\t * below the concurrently-changing counter value.\n\t\t *\n\t\t * The xchg implies two full memory barriers before\n\t\t * and after, so the read-swap-read is ordered and\n\t\t * ensures coherency with page_counter_try_charge():\n\t\t * that function modifies the count before checking\n\t\t * the limit, so if it sees the old limit, we see the\n\t\t * modified counter and retry.\n\t\t */\n\t\tusage = atomic_long_read(&counter->usage);\n\n\t\tif (usage > nr_pages)\n\t\t\treturn -EBUSY;\n\n\t\told = xchg(&counter->max, nr_pages);\n\n\t\tif (atomic_long_read(&counter->usage) <= usage)\n\t\t\treturn 0;\n\n\t\tcounter->max = old;\n\t\tcond_resched();\n\t}\n}"
  },
  {
    "function_name": "page_counter_uncharge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
    "lines": "155-161",
    "snippet": "void page_counter_uncharge(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tfor (c = counter; c; c = c->parent)\n\t\tpage_counter_cancel(c, nr_pages);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <linux/atomic.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_counter_cancel",
          "args": [
            "c",
            "nr_pages"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "page_counter_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
          "lines": "55-63",
          "snippet": "void page_counter_cancel(struct page_counter *counter, unsigned long nr_pages)\n{\n\tlong new;\n\n\tnew = atomic_long_sub_return(nr_pages, &counter->usage);\n\tpropagate_protected_usage(counter, new);\n\t/* More uncharges than charges? */\n\tWARN_ON_ONCE(new < 0);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/atomic.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nvoid page_counter_cancel(struct page_counter *counter, unsigned long nr_pages)\n{\n\tlong new;\n\n\tnew = atomic_long_sub_return(nr_pages, &counter->usage);\n\tpropagate_protected_usage(counter, new);\n\t/* More uncharges than charges? */\n\tWARN_ON_ONCE(new < 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nvoid page_counter_uncharge(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tfor (c = counter; c; c = c->parent)\n\t\tpage_counter_cancel(c, nr_pages);\n}"
  },
  {
    "function_name": "page_counter_try_charge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
    "lines": "99-148",
    "snippet": "bool page_counter_try_charge(struct page_counter *counter,\n\t\t\t     unsigned long nr_pages,\n\t\t\t     struct page_counter **fail)\n{\n\tstruct page_counter *c;\n\n\tfor (c = counter; c; c = c->parent) {\n\t\tlong new;\n\t\t/*\n\t\t * Charge speculatively to avoid an expensive CAS.  If\n\t\t * a bigger charge fails, it might falsely lock out a\n\t\t * racing smaller charge and send it into reclaim\n\t\t * early, but the error is limited to the difference\n\t\t * between the two sizes, which is less than 2M/4M in\n\t\t * case of a THP locking out a regular page charge.\n\t\t *\n\t\t * The atomic_long_add_return() implies a full memory\n\t\t * barrier between incrementing the count and reading\n\t\t * the limit.  When racing with page_counter_limit(),\n\t\t * we either see the new limit or the setter sees the\n\t\t * counter has changed and retries.\n\t\t */\n\t\tnew = atomic_long_add_return(nr_pages, &c->usage);\n\t\tif (new > c->max) {\n\t\t\tatomic_long_sub(nr_pages, &c->usage);\n\t\t\tpropagate_protected_usage(counter, new);\n\t\t\t/*\n\t\t\t * This is racy, but we can live with some\n\t\t\t * inaccuracy in the failcnt.\n\t\t\t */\n\t\t\tc->failcnt++;\n\t\t\t*fail = c;\n\t\t\tgoto failed;\n\t\t}\n\t\tpropagate_protected_usage(counter, new);\n\t\t/*\n\t\t * Just like with failcnt, we can live with some\n\t\t * inaccuracy in the watermark.\n\t\t */\n\t\tif (new > c->watermark)\n\t\t\tc->watermark = new;\n\t}\n\treturn true;\n\nfailed:\n\tfor (c = counter; c != *fail; c = c->parent)\n\t\tpage_counter_cancel(c, nr_pages);\n\n\treturn false;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <linux/atomic.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_counter_cancel",
          "args": [
            "c",
            "nr_pages"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "page_counter_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
          "lines": "55-63",
          "snippet": "void page_counter_cancel(struct page_counter *counter, unsigned long nr_pages)\n{\n\tlong new;\n\n\tnew = atomic_long_sub_return(nr_pages, &counter->usage);\n\tpropagate_protected_usage(counter, new);\n\t/* More uncharges than charges? */\n\tWARN_ON_ONCE(new < 0);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/atomic.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nvoid page_counter_cancel(struct page_counter *counter, unsigned long nr_pages)\n{\n\tlong new;\n\n\tnew = atomic_long_sub_return(nr_pages, &counter->usage);\n\tpropagate_protected_usage(counter, new);\n\t/* More uncharges than charges? */\n\tWARN_ON_ONCE(new < 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "propagate_protected_usage",
          "args": [
            "counter",
            "new"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "propagate_protected_usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
          "lines": "16-48",
          "snippet": "static void propagate_protected_usage(struct page_counter *c,\n\t\t\t\t      unsigned long usage)\n{\n\tunsigned long protected, old_protected;\n\tlong delta;\n\n\tif (!c->parent)\n\t\treturn;\n\n\tif (c->min || atomic_long_read(&c->min_usage)) {\n\t\tif (usage <= c->min)\n\t\t\tprotected = usage;\n\t\telse\n\t\t\tprotected = 0;\n\n\t\told_protected = atomic_long_xchg(&c->min_usage, protected);\n\t\tdelta = protected - old_protected;\n\t\tif (delta)\n\t\t\tatomic_long_add(delta, &c->parent->children_min_usage);\n\t}\n\n\tif (c->low || atomic_long_read(&c->low_usage)) {\n\t\tif (usage <= c->low)\n\t\t\tprotected = usage;\n\t\telse\n\t\t\tprotected = 0;\n\n\t\told_protected = atomic_long_xchg(&c->low_usage, protected);\n\t\tdelta = protected - old_protected;\n\t\tif (delta)\n\t\t\tatomic_long_add(delta, &c->parent->children_low_usage);\n\t}\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/atomic.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nstatic void propagate_protected_usage(struct page_counter *c,\n\t\t\t\t      unsigned long usage)\n{\n\tunsigned long protected, old_protected;\n\tlong delta;\n\n\tif (!c->parent)\n\t\treturn;\n\n\tif (c->min || atomic_long_read(&c->min_usage)) {\n\t\tif (usage <= c->min)\n\t\t\tprotected = usage;\n\t\telse\n\t\t\tprotected = 0;\n\n\t\told_protected = atomic_long_xchg(&c->min_usage, protected);\n\t\tdelta = protected - old_protected;\n\t\tif (delta)\n\t\t\tatomic_long_add(delta, &c->parent->children_min_usage);\n\t}\n\n\tif (c->low || atomic_long_read(&c->low_usage)) {\n\t\tif (usage <= c->low)\n\t\t\tprotected = usage;\n\t\telse\n\t\t\tprotected = 0;\n\n\t\told_protected = atomic_long_xchg(&c->low_usage, protected);\n\t\tdelta = protected - old_protected;\n\t\tif (delta)\n\t\t\tatomic_long_add(delta, &c->parent->children_low_usage);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_long_sub",
          "args": [
            "nr_pages",
            "&c->usage"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_add_return",
          "args": [
            "nr_pages",
            "&c->usage"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nbool page_counter_try_charge(struct page_counter *counter,\n\t\t\t     unsigned long nr_pages,\n\t\t\t     struct page_counter **fail)\n{\n\tstruct page_counter *c;\n\n\tfor (c = counter; c; c = c->parent) {\n\t\tlong new;\n\t\t/*\n\t\t * Charge speculatively to avoid an expensive CAS.  If\n\t\t * a bigger charge fails, it might falsely lock out a\n\t\t * racing smaller charge and send it into reclaim\n\t\t * early, but the error is limited to the difference\n\t\t * between the two sizes, which is less than 2M/4M in\n\t\t * case of a THP locking out a regular page charge.\n\t\t *\n\t\t * The atomic_long_add_return() implies a full memory\n\t\t * barrier between incrementing the count and reading\n\t\t * the limit.  When racing with page_counter_limit(),\n\t\t * we either see the new limit or the setter sees the\n\t\t * counter has changed and retries.\n\t\t */\n\t\tnew = atomic_long_add_return(nr_pages, &c->usage);\n\t\tif (new > c->max) {\n\t\t\tatomic_long_sub(nr_pages, &c->usage);\n\t\t\tpropagate_protected_usage(counter, new);\n\t\t\t/*\n\t\t\t * This is racy, but we can live with some\n\t\t\t * inaccuracy in the failcnt.\n\t\t\t */\n\t\t\tc->failcnt++;\n\t\t\t*fail = c;\n\t\t\tgoto failed;\n\t\t}\n\t\tpropagate_protected_usage(counter, new);\n\t\t/*\n\t\t * Just like with failcnt, we can live with some\n\t\t * inaccuracy in the watermark.\n\t\t */\n\t\tif (new > c->watermark)\n\t\t\tc->watermark = new;\n\t}\n\treturn true;\n\nfailed:\n\tfor (c = counter; c != *fail; c = c->parent)\n\t\tpage_counter_cancel(c, nr_pages);\n\n\treturn false;\n}"
  },
  {
    "function_name": "page_counter_charge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
    "lines": "72-88",
    "snippet": "void page_counter_charge(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tfor (c = counter; c; c = c->parent) {\n\t\tlong new;\n\n\t\tnew = atomic_long_add_return(nr_pages, &c->usage);\n\t\tpropagate_protected_usage(counter, new);\n\t\t/*\n\t\t * This is indeed racy, but we can live with some\n\t\t * inaccuracy in the watermark.\n\t\t */\n\t\tif (new > c->watermark)\n\t\t\tc->watermark = new;\n\t}\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <linux/atomic.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "propagate_protected_usage",
          "args": [
            "counter",
            "new"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "propagate_protected_usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
          "lines": "16-48",
          "snippet": "static void propagate_protected_usage(struct page_counter *c,\n\t\t\t\t      unsigned long usage)\n{\n\tunsigned long protected, old_protected;\n\tlong delta;\n\n\tif (!c->parent)\n\t\treturn;\n\n\tif (c->min || atomic_long_read(&c->min_usage)) {\n\t\tif (usage <= c->min)\n\t\t\tprotected = usage;\n\t\telse\n\t\t\tprotected = 0;\n\n\t\told_protected = atomic_long_xchg(&c->min_usage, protected);\n\t\tdelta = protected - old_protected;\n\t\tif (delta)\n\t\t\tatomic_long_add(delta, &c->parent->children_min_usage);\n\t}\n\n\tif (c->low || atomic_long_read(&c->low_usage)) {\n\t\tif (usage <= c->low)\n\t\t\tprotected = usage;\n\t\telse\n\t\t\tprotected = 0;\n\n\t\told_protected = atomic_long_xchg(&c->low_usage, protected);\n\t\tdelta = protected - old_protected;\n\t\tif (delta)\n\t\t\tatomic_long_add(delta, &c->parent->children_low_usage);\n\t}\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/atomic.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nstatic void propagate_protected_usage(struct page_counter *c,\n\t\t\t\t      unsigned long usage)\n{\n\tunsigned long protected, old_protected;\n\tlong delta;\n\n\tif (!c->parent)\n\t\treturn;\n\n\tif (c->min || atomic_long_read(&c->min_usage)) {\n\t\tif (usage <= c->min)\n\t\t\tprotected = usage;\n\t\telse\n\t\t\tprotected = 0;\n\n\t\told_protected = atomic_long_xchg(&c->min_usage, protected);\n\t\tdelta = protected - old_protected;\n\t\tif (delta)\n\t\t\tatomic_long_add(delta, &c->parent->children_min_usage);\n\t}\n\n\tif (c->low || atomic_long_read(&c->low_usage)) {\n\t\tif (usage <= c->low)\n\t\t\tprotected = usage;\n\t\telse\n\t\t\tprotected = 0;\n\n\t\told_protected = atomic_long_xchg(&c->low_usage, protected);\n\t\tdelta = protected - old_protected;\n\t\tif (delta)\n\t\t\tatomic_long_add(delta, &c->parent->children_low_usage);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_long_add_return",
          "args": [
            "nr_pages",
            "&c->usage"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nvoid page_counter_charge(struct page_counter *counter, unsigned long nr_pages)\n{\n\tstruct page_counter *c;\n\n\tfor (c = counter; c; c = c->parent) {\n\t\tlong new;\n\n\t\tnew = atomic_long_add_return(nr_pages, &c->usage);\n\t\tpropagate_protected_usage(counter, new);\n\t\t/*\n\t\t * This is indeed racy, but we can live with some\n\t\t * inaccuracy in the watermark.\n\t\t */\n\t\tif (new > c->watermark)\n\t\t\tc->watermark = new;\n\t}\n}"
  },
  {
    "function_name": "page_counter_cancel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
    "lines": "55-63",
    "snippet": "void page_counter_cancel(struct page_counter *counter, unsigned long nr_pages)\n{\n\tlong new;\n\n\tnew = atomic_long_sub_return(nr_pages, &counter->usage);\n\tpropagate_protected_usage(counter, new);\n\t/* More uncharges than charges? */\n\tWARN_ON_ONCE(new < 0);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <linux/atomic.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "new < 0"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "propagate_protected_usage",
          "args": [
            "counter",
            "new"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "propagate_protected_usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
          "lines": "16-48",
          "snippet": "static void propagate_protected_usage(struct page_counter *c,\n\t\t\t\t      unsigned long usage)\n{\n\tunsigned long protected, old_protected;\n\tlong delta;\n\n\tif (!c->parent)\n\t\treturn;\n\n\tif (c->min || atomic_long_read(&c->min_usage)) {\n\t\tif (usage <= c->min)\n\t\t\tprotected = usage;\n\t\telse\n\t\t\tprotected = 0;\n\n\t\told_protected = atomic_long_xchg(&c->min_usage, protected);\n\t\tdelta = protected - old_protected;\n\t\tif (delta)\n\t\t\tatomic_long_add(delta, &c->parent->children_min_usage);\n\t}\n\n\tif (c->low || atomic_long_read(&c->low_usage)) {\n\t\tif (usage <= c->low)\n\t\t\tprotected = usage;\n\t\telse\n\t\t\tprotected = 0;\n\n\t\told_protected = atomic_long_xchg(&c->low_usage, protected);\n\t\tdelta = protected - old_protected;\n\t\tif (delta)\n\t\t\tatomic_long_add(delta, &c->parent->children_low_usage);\n\t}\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/atomic.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nstatic void propagate_protected_usage(struct page_counter *c,\n\t\t\t\t      unsigned long usage)\n{\n\tunsigned long protected, old_protected;\n\tlong delta;\n\n\tif (!c->parent)\n\t\treturn;\n\n\tif (c->min || atomic_long_read(&c->min_usage)) {\n\t\tif (usage <= c->min)\n\t\t\tprotected = usage;\n\t\telse\n\t\t\tprotected = 0;\n\n\t\told_protected = atomic_long_xchg(&c->min_usage, protected);\n\t\tdelta = protected - old_protected;\n\t\tif (delta)\n\t\t\tatomic_long_add(delta, &c->parent->children_min_usage);\n\t}\n\n\tif (c->low || atomic_long_read(&c->low_usage)) {\n\t\tif (usage <= c->low)\n\t\t\tprotected = usage;\n\t\telse\n\t\t\tprotected = 0;\n\n\t\told_protected = atomic_long_xchg(&c->low_usage, protected);\n\t\tdelta = protected - old_protected;\n\t\tif (delta)\n\t\t\tatomic_long_add(delta, &c->parent->children_low_usage);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_long_sub_return",
          "args": [
            "nr_pages",
            "&counter->usage"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nvoid page_counter_cancel(struct page_counter *counter, unsigned long nr_pages)\n{\n\tlong new;\n\n\tnew = atomic_long_sub_return(nr_pages, &counter->usage);\n\tpropagate_protected_usage(counter, new);\n\t/* More uncharges than charges? */\n\tWARN_ON_ONCE(new < 0);\n}"
  },
  {
    "function_name": "propagate_protected_usage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_counter.c",
    "lines": "16-48",
    "snippet": "static void propagate_protected_usage(struct page_counter *c,\n\t\t\t\t      unsigned long usage)\n{\n\tunsigned long protected, old_protected;\n\tlong delta;\n\n\tif (!c->parent)\n\t\treturn;\n\n\tif (c->min || atomic_long_read(&c->min_usage)) {\n\t\tif (usage <= c->min)\n\t\t\tprotected = usage;\n\t\telse\n\t\t\tprotected = 0;\n\n\t\told_protected = atomic_long_xchg(&c->min_usage, protected);\n\t\tdelta = protected - old_protected;\n\t\tif (delta)\n\t\t\tatomic_long_add(delta, &c->parent->children_min_usage);\n\t}\n\n\tif (c->low || atomic_long_read(&c->low_usage)) {\n\t\tif (usage <= c->low)\n\t\t\tprotected = usage;\n\t\telse\n\t\t\tprotected = 0;\n\n\t\told_protected = atomic_long_xchg(&c->low_usage, protected);\n\t\tdelta = protected - old_protected;\n\t\tif (delta)\n\t\t\tatomic_long_add(delta, &c->parent->children_low_usage);\n\t}\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <linux/bug.h>",
      "#include <linux/sched.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <linux/atomic.h>",
      "#include <linux/page_counter.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_long_add",
          "args": [
            "delta",
            "&c->parent->children_low_usage"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_xchg",
          "args": [
            "&c->low_usage",
            "protected"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&c->low_usage"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_add",
          "args": [
            "delta",
            "&c->parent->children_min_usage"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_xchg",
          "args": [
            "&c->min_usage",
            "protected"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&c->min_usage"
          ],
          "line": 25
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n#include <linux/page_counter.h>\n\nstatic void propagate_protected_usage(struct page_counter *c,\n\t\t\t\t      unsigned long usage)\n{\n\tunsigned long protected, old_protected;\n\tlong delta;\n\n\tif (!c->parent)\n\t\treturn;\n\n\tif (c->min || atomic_long_read(&c->min_usage)) {\n\t\tif (usage <= c->min)\n\t\t\tprotected = usage;\n\t\telse\n\t\t\tprotected = 0;\n\n\t\told_protected = atomic_long_xchg(&c->min_usage, protected);\n\t\tdelta = protected - old_protected;\n\t\tif (delta)\n\t\t\tatomic_long_add(delta, &c->parent->children_min_usage);\n\t}\n\n\tif (c->low || atomic_long_read(&c->low_usage)) {\n\t\tif (usage <= c->low)\n\t\t\tprotected = usage;\n\t\telse\n\t\t\tprotected = 0;\n\n\t\told_protected = atomic_long_xchg(&c->low_usage, protected);\n\t\tdelta = protected - old_protected;\n\t\tif (delta)\n\t\t\tatomic_long_add(delta, &c->parent->children_low_usage);\n\t}\n}"
  }
]