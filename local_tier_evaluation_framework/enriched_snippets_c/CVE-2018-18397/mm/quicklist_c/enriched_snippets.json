[
  {
    "function_name": "quicklist_total_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/quicklist.c",
    "lines": "90-102",
    "snippet": "unsigned long quicklist_total_size(void)\n{\n\tunsigned long count = 0;\n\tint cpu;\n\tstruct quicklist *ql, *q;\n\n\tfor_each_online_cpu(cpu) {\n\t\tql = per_cpu(quicklist, cpu);\n\t\tfor (q = ql; q < ql + CONFIG_NR_QUICK; q++)\n\t\t\tcount += q->nr_pages;\n\t}\n\treturn count;\n}",
    "includes": [
      "#include <linux/quicklist.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "quicklist",
            "cpu"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/quicklist.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel.h>\n\nunsigned long quicklist_total_size(void)\n{\n\tunsigned long count = 0;\n\tint cpu;\n\tstruct quicklist *ql, *q;\n\n\tfor_each_online_cpu(cpu) {\n\t\tql = per_cpu(quicklist, cpu);\n\t\tfor (q = ql; q < ql + CONFIG_NR_QUICK; q++)\n\t\t\tcount += q->nr_pages;\n\t}\n\treturn count;\n}"
  },
  {
    "function_name": "quicklist_trim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/quicklist.c",
    "lines": "64-88",
    "snippet": "void quicklist_trim(int nr, void (*dtor)(void *),\n\tunsigned long min_pages, unsigned long max_free)\n{\n\tlong pages_to_free;\n\tstruct quicklist *q;\n\n\tq = &get_cpu_var(quicklist)[nr];\n\tif (q->nr_pages > min_pages) {\n\t\tpages_to_free = min_pages_to_free(q, min_pages, max_free);\n\n\t\twhile (pages_to_free > 0) {\n\t\t\t/*\n\t\t\t * We pass a gfp_t of 0 to quicklist_alloc here\n\t\t\t * because we will never call into the page allocator.\n\t\t\t */\n\t\t\tvoid *p = quicklist_alloc(nr, 0, NULL);\n\n\t\t\tif (dtor)\n\t\t\t\tdtor(p);\n\t\t\tfree_page((unsigned long)p);\n\t\t\tpages_to_free--;\n\t\t}\n\t}\n\tput_cpu_var(quicklist);\n}",
    "includes": [
      "#include <linux/quicklist.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_cpu_var",
          "args": [
            "quicklist"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long)p"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "soft_offline_free_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory-failure.c",
          "lines": "1857-1871",
          "snippet": "static int soft_offline_free_page(struct page *page)\n{\n\tint rc = 0;\n\tstruct page *head = compound_head(page);\n\n\tif (PageHuge(head))\n\t\trc = dissolve_free_huge_page(page);\n\tif (!rc) {\n\t\tif (set_hwpoison_free_buddy_page(page))\n\t\t\tnum_poisoned_pages_inc();\n\t\telse\n\t\t\trc = -EBUSY;\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"ras/ras_event.h\"",
            "#include \"internal.h\"",
            "#include <linux/page-isolation.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kfifo.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swapops.h>",
            "#include <linux/slab.h>",
            "#include <linux/suspend.h>",
            "#include <linux/migrate.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel-page-flags.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define head\t\t(1UL << PG_head)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ras/ras_event.h\"\n#include \"internal.h\"\n#include <linux/page-isolation.h>\n#include <linux/ratelimit.h>\n#include <linux/kfifo.h>\n#include <linux/memremap.h>\n#include <linux/mm_inline.h>\n#include <linux/memory_hotplug.h>\n#include <linux/hugetlb.h>\n#include <linux/swapops.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/migrate.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel-page-flags.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define head\t\t(1UL << PG_head)\n\nstatic int soft_offline_free_page(struct page *page)\n{\n\tint rc = 0;\n\tstruct page *head = compound_head(page);\n\n\tif (PageHuge(head))\n\t\trc = dissolve_free_huge_page(page);\n\tif (!rc) {\n\t\tif (set_hwpoison_free_buddy_page(page))\n\t\t\tnum_poisoned_pages_inc();\n\t\telse\n\t\t\trc = -EBUSY;\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dtor",
          "args": [
            "p"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "quicklist_alloc",
          "args": [
            "nr",
            "0",
            "NULL"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_pages_to_free",
          "args": [
            "q",
            "min_pages",
            "max_free"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "min_pages_to_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/quicklist.c",
          "lines": "51-59",
          "snippet": "static long min_pages_to_free(struct quicklist *q,\n\tunsigned long min_pages, long max_free)\n{\n\tlong pages_to_free;\n\n\tpages_to_free = q->nr_pages - max_pages(min_pages);\n\n\treturn min(pages_to_free, max_free);\n}",
          "includes": [
            "#include <linux/quicklist.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quicklist.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel.h>\n\nstatic long min_pages_to_free(struct quicklist *q,\n\tunsigned long min_pages, long max_free)\n{\n\tlong pages_to_free;\n\n\tpages_to_free = q->nr_pages - max_pages(min_pages);\n\n\treturn min(pages_to_free, max_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_cpu_var",
          "args": [
            "quicklist"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/quicklist.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel.h>\n\nvoid quicklist_trim(int nr, void (*dtor)(void *),\n\tunsigned long min_pages, unsigned long max_free)\n{\n\tlong pages_to_free;\n\tstruct quicklist *q;\n\n\tq = &get_cpu_var(quicklist)[nr];\n\tif (q->nr_pages > min_pages) {\n\t\tpages_to_free = min_pages_to_free(q, min_pages, max_free);\n\n\t\twhile (pages_to_free > 0) {\n\t\t\t/*\n\t\t\t * We pass a gfp_t of 0 to quicklist_alloc here\n\t\t\t * because we will never call into the page allocator.\n\t\t\t */\n\t\t\tvoid *p = quicklist_alloc(nr, 0, NULL);\n\n\t\t\tif (dtor)\n\t\t\t\tdtor(p);\n\t\t\tfree_page((unsigned long)p);\n\t\t\tpages_to_free--;\n\t\t}\n\t}\n\tput_cpu_var(quicklist);\n}"
  },
  {
    "function_name": "min_pages_to_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/quicklist.c",
    "lines": "51-59",
    "snippet": "static long min_pages_to_free(struct quicklist *q,\n\tunsigned long min_pages, long max_free)\n{\n\tlong pages_to_free;\n\n\tpages_to_free = q->nr_pages - max_pages(min_pages);\n\n\treturn min(pages_to_free, max_free);\n}",
    "includes": [
      "#include <linux/quicklist.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min",
          "args": [
            "pages_to_free",
            "max_free"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max_pages",
          "args": [
            "min_pages"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/quicklist.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel.h>\n\nstatic long min_pages_to_free(struct quicklist *q,\n\tunsigned long min_pages, long max_free)\n{\n\tlong pages_to_free;\n\n\tpages_to_free = q->nr_pages - max_pages(min_pages);\n\n\treturn min(pages_to_free, max_free);\n}"
  }
]