[
  {
    "function_name": "kmem_cache_init_late",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
    "lines": "660-663",
    "snippet": "void __init kmem_cache_init_late(void)\n{\n\tslab_state = FULL;\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/atomic.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/list.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/cache.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid __init kmem_cache_init_late(void)\n{\n\tslab_state = FULL;\n}"
  },
  {
    "function_name": "kmem_cache_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
    "lines": "654-658",
    "snippet": "void __init kmem_cache_init(void)\n{\n\tkmem_cache = &kmem_cache_boot;\n\tslab_state = UP;\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/atomic.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/list.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/cache.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache kmem_cache_boot = {\n\t.name = \"kmem_cache\",\n\t.size = sizeof(struct kmem_cache),\n\t.flags = SLAB_PANIC,\n\t.align = ARCH_KMALLOC_MINALIGN,\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct kmem_cache kmem_cache_boot = {\n\t.name = \"kmem_cache\",\n\t.size = sizeof(struct kmem_cache),\n\t.flags = SLAB_PANIC,\n\t.align = ARCH_KMALLOC_MINALIGN,\n};\n\nvoid __init kmem_cache_init(void)\n{\n\tkmem_cache = &kmem_cache_boot;\n\tslab_state = UP;\n}"
  },
  {
    "function_name": "__kmem_cache_shrink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
    "lines": "642-645",
    "snippet": "int __kmem_cache_shrink(struct kmem_cache *d)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/atomic.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/list.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/cache.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint __kmem_cache_shrink(struct kmem_cache *d)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "__kmem_cache_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
    "lines": "638-640",
    "snippet": "void __kmem_cache_release(struct kmem_cache *c)\n{\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/atomic.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/list.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/cache.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid __kmem_cache_release(struct kmem_cache *c)\n{\n}"
  },
  {
    "function_name": "__kmem_cache_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
    "lines": "632-636",
    "snippet": "int __kmem_cache_shutdown(struct kmem_cache *c)\n{\n\t/* No way to check for remaining objects */\n\treturn 0;\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/atomic.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/list.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/cache.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint __kmem_cache_shutdown(struct kmem_cache *c)\n{\n\t/* No way to check for remaining objects */\n\treturn 0;\n}"
  },
  {
    "function_name": "kmem_cache_alloc_bulk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
    "lines": "625-629",
    "snippet": "int kmem_cache_alloc_bulk(struct kmem_cache *s, gfp_t flags, size_t size,\n\t\t\t\t\t\t\t\tvoid **p)\n{\n\treturn __kmem_cache_alloc_bulk(s, flags, size, p);\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/atomic.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/list.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/cache.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__kmem_cache_alloc_bulk",
          "args": [
            "s",
            "flags",
            "size",
            "p"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "__kmem_cache_alloc_bulk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "115-128",
          "snippet": "int __kmem_cache_alloc_bulk(struct kmem_cache *s, gfp_t flags, size_t nr,\n\t\t\t\t\t\t\t\tvoid **p)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tvoid *x = p[i] = kmem_cache_alloc(s, flags);\n\t\tif (!x) {\n\t\t\t__kmem_cache_free_bulk(s, i, p);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn i;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *kmem_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nint __kmem_cache_alloc_bulk(struct kmem_cache *s, gfp_t flags, size_t nr,\n\t\t\t\t\t\t\t\tvoid **p)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tvoid *x = p[i] = kmem_cache_alloc(s, flags);\n\t\tif (!x) {\n\t\t\t__kmem_cache_free_bulk(s, i, p);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn i;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint kmem_cache_alloc_bulk(struct kmem_cache *s, gfp_t flags, size_t size,\n\t\t\t\t\t\t\t\tvoid **p)\n{\n\treturn __kmem_cache_alloc_bulk(s, flags, size, p);\n}"
  },
  {
    "function_name": "kmem_cache_free_bulk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
    "lines": "619-622",
    "snippet": "void kmem_cache_free_bulk(struct kmem_cache *s, size_t size, void **p)\n{\n\t__kmem_cache_free_bulk(s, size, p);\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/atomic.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/list.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/cache.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__kmem_cache_free_bulk",
          "args": [
            "s",
            "size",
            "p"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "__kmem_cache_free_bulk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab_common.c",
          "lines": "103-113",
          "snippet": "void __kmem_cache_free_bulk(struct kmem_cache *s, size_t nr, void **p)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tif (s)\n\t\t\tkmem_cache_free(s, p[i]);\n\t\telse\n\t\t\tkfree(p[i]);\n\t}\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/memcontrol.h>",
            "#include <asm/page.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cache.h>",
            "#include <linux/memory.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/poison.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *kmem_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <trace/events/kmem.h>\n#include <linux/memcontrol.h>\n#include <asm/page.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/cache.h>\n#include <linux/memory.h>\n#include <linux/interrupt.h>\n#include <linux/poison.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\nstruct kmem_cache *kmem_cache;\n\nvoid __kmem_cache_free_bulk(struct kmem_cache *s, size_t nr, void **p)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tif (s)\n\t\t\tkmem_cache_free(s, p[i]);\n\t\telse\n\t\t\tkfree(p[i]);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid kmem_cache_free_bulk(struct kmem_cache *s, size_t size, void **p)\n{\n\t__kmem_cache_free_bulk(s, size, p);\n}"
  },
  {
    "function_name": "kmem_cache_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
    "lines": "603-616",
    "snippet": "void kmem_cache_free(struct kmem_cache *c, void *b)\n{\n\tkmemleak_free_recursive(b, c->flags);\n\tif (unlikely(c->flags & SLAB_TYPESAFE_BY_RCU)) {\n\t\tstruct slob_rcu *slob_rcu;\n\t\tslob_rcu = b + (c->size - sizeof(struct slob_rcu));\n\t\tslob_rcu->size = c->size;\n\t\tcall_rcu(&slob_rcu->head, kmem_rcu_free);\n\t} else {\n\t\t__kmem_cache_free(b, c->size);\n\t}\n\n\ttrace_kmem_cache_free(_RET_IP_, b);\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/atomic.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/list.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/cache.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_kmem_cache_free",
          "args": [
            "_RET_IP_",
            "b"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kmem_cache_free",
          "args": [
            "b",
            "c->size"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "__kmem_cache_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
          "lines": "587-593",
          "snippet": "static void __kmem_cache_free(void *b, int size)\n{\n\tif (size < PAGE_SIZE)\n\t\tslob_free(b, size);\n\telse\n\t\tslob_free_pages(b, get_order(size));\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <linux/atomic.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/list.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/cache.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void __kmem_cache_free(void *b, int size)\n{\n\tif (size < PAGE_SIZE)\n\t\tslob_free(b, size);\n\telse\n\t\tslob_free_pages(b, get_order(size));\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&slob_rcu->head",
            "kmem_rcu_free"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "c->flags & SLAB_TYPESAFE_BY_RCU"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmemleak_free_recursive",
          "args": [
            "b",
            "c->flags"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid kmem_cache_free(struct kmem_cache *c, void *b)\n{\n\tkmemleak_free_recursive(b, c->flags);\n\tif (unlikely(c->flags & SLAB_TYPESAFE_BY_RCU)) {\n\t\tstruct slob_rcu *slob_rcu;\n\t\tslob_rcu = b + (c->size - sizeof(struct slob_rcu));\n\t\tslob_rcu->size = c->size;\n\t\tcall_rcu(&slob_rcu->head, kmem_rcu_free);\n\t} else {\n\t\t__kmem_cache_free(b, c->size);\n\t}\n\n\ttrace_kmem_cache_free(_RET_IP_, b);\n}"
  },
  {
    "function_name": "kmem_rcu_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
    "lines": "595-601",
    "snippet": "static void kmem_rcu_free(struct rcu_head *head)\n{\n\tstruct slob_rcu *slob_rcu = (struct slob_rcu *)head;\n\tvoid *b = (void *)slob_rcu - (slob_rcu->size - sizeof(struct slob_rcu));\n\n\t__kmem_cache_free(b, slob_rcu->size);\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/atomic.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/list.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/cache.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__kmem_cache_free",
          "args": [
            "b",
            "slob_rcu->size"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "__kmem_cache_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
          "lines": "587-593",
          "snippet": "static void __kmem_cache_free(void *b, int size)\n{\n\tif (size < PAGE_SIZE)\n\t\tslob_free(b, size);\n\telse\n\t\tslob_free_pages(b, get_order(size));\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <linux/atomic.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/list.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/cache.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void __kmem_cache_free(void *b, int size)\n{\n\tif (size < PAGE_SIZE)\n\t\tslob_free(b, size);\n\telse\n\t\tslob_free_pages(b, get_order(size));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void kmem_rcu_free(struct rcu_head *head)\n{\n\tstruct slob_rcu *slob_rcu = (struct slob_rcu *)head;\n\tvoid *b = (void *)slob_rcu - (slob_rcu->size - sizeof(struct slob_rcu));\n\n\t__kmem_cache_free(b, slob_rcu->size);\n}"
  },
  {
    "function_name": "__kmem_cache_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
    "lines": "587-593",
    "snippet": "static void __kmem_cache_free(void *b, int size)\n{\n\tif (size < PAGE_SIZE)\n\t\tslob_free(b, size);\n\telse\n\t\tslob_free_pages(b, get_order(size));\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/atomic.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/list.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/cache.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "slob_free_pages",
          "args": [
            "b",
            "get_order(size)"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "slob_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
          "lines": "208-213",
          "snippet": "static void slob_free_pages(void *b, int order)\n{\n\tif (current->reclaim_state)\n\t\tcurrent->reclaim_state->reclaimed_slab += 1 << order;\n\tfree_pages((unsigned long)b, order);\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <linux/atomic.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/list.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/cache.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void slob_free_pages(void *b, int order)\n{\n\tif (current->reclaim_state)\n\t\tcurrent->reclaim_state->reclaimed_slab += 1 << order;\n\tfree_pages((unsigned long)b, order);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "size"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slob_free",
          "args": [
            "b",
            "size"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "slob_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
          "lines": "341-421",
          "snippet": "static void slob_free(void *block, int size)\n{\n\tstruct page *sp;\n\tslob_t *prev, *next, *b = (slob_t *)block;\n\tslobidx_t units;\n\tunsigned long flags;\n\tstruct list_head *slob_list;\n\n\tif (unlikely(ZERO_OR_NULL_PTR(block)))\n\t\treturn;\n\tBUG_ON(!size);\n\n\tsp = virt_to_page(block);\n\tunits = SLOB_UNITS(size);\n\n\tspin_lock_irqsave(&slob_lock, flags);\n\n\tif (sp->units + units == SLOB_UNITS(PAGE_SIZE)) {\n\t\t/* Go directly to page allocator. Do not pass slob allocator */\n\t\tif (slob_page_free(sp))\n\t\t\tclear_slob_page_free(sp);\n\t\tspin_unlock_irqrestore(&slob_lock, flags);\n\t\t__ClearPageSlab(sp);\n\t\tpage_mapcount_reset(sp);\n\t\tslob_free_pages(b, 0);\n\t\treturn;\n\t}\n\n\tif (!slob_page_free(sp)) {\n\t\t/* This slob page is about to become partially free. Easy! */\n\t\tsp->units = units;\n\t\tsp->freelist = b;\n\t\tset_slob(b, units,\n\t\t\t(void *)((unsigned long)(b +\n\t\t\t\t\tSLOB_UNITS(PAGE_SIZE)) & PAGE_MASK));\n\t\tif (size < SLOB_BREAK1)\n\t\t\tslob_list = &free_slob_small;\n\t\telse if (size < SLOB_BREAK2)\n\t\t\tslob_list = &free_slob_medium;\n\t\telse\n\t\t\tslob_list = &free_slob_large;\n\t\tset_slob_page_free(sp, slob_list);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Otherwise the page is already partially free, so find reinsertion\n\t * point.\n\t */\n\tsp->units += units;\n\n\tif (b < (slob_t *)sp->freelist) {\n\t\tif (b + units == sp->freelist) {\n\t\t\tunits += slob_units(sp->freelist);\n\t\t\tsp->freelist = slob_next(sp->freelist);\n\t\t}\n\t\tset_slob(b, units, sp->freelist);\n\t\tsp->freelist = b;\n\t} else {\n\t\tprev = sp->freelist;\n\t\tnext = slob_next(prev);\n\t\twhile (b > next) {\n\t\t\tprev = next;\n\t\t\tnext = slob_next(prev);\n\t\t}\n\n\t\tif (!slob_last(prev) && b + units == next) {\n\t\t\tunits += slob_units(next);\n\t\t\tset_slob(b, units, slob_next(next));\n\t\t} else\n\t\t\tset_slob(b, units, next);\n\n\t\tif (prev + slob_units(prev) == b) {\n\t\t\tunits = slob_units(b) + slob_units(prev);\n\t\t\tset_slob(prev, units, slob_next(b));\n\t\t} else\n\t\t\tset_slob(prev, slob_units(prev), b);\n\t}\nout:\n\tspin_unlock_irqrestore(&slob_lock, flags);\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <linux/atomic.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/list.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/cache.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define SLOB_BREAK2 1024",
            "#define SLOB_BREAK1 256"
          ],
          "globals_used": [
            "static LIST_HEAD(free_slob_small);",
            "static LIST_HEAD(free_slob_medium);",
            "static LIST_HEAD(free_slob_large);",
            "static DEFINE_SPINLOCK(slob_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\n#define SLOB_BREAK2 1024\n#define SLOB_BREAK1 256\n\nstatic LIST_HEAD(free_slob_small);\nstatic LIST_HEAD(free_slob_medium);\nstatic LIST_HEAD(free_slob_large);\nstatic DEFINE_SPINLOCK(slob_lock);\n\nstatic void slob_free(void *block, int size)\n{\n\tstruct page *sp;\n\tslob_t *prev, *next, *b = (slob_t *)block;\n\tslobidx_t units;\n\tunsigned long flags;\n\tstruct list_head *slob_list;\n\n\tif (unlikely(ZERO_OR_NULL_PTR(block)))\n\t\treturn;\n\tBUG_ON(!size);\n\n\tsp = virt_to_page(block);\n\tunits = SLOB_UNITS(size);\n\n\tspin_lock_irqsave(&slob_lock, flags);\n\n\tif (sp->units + units == SLOB_UNITS(PAGE_SIZE)) {\n\t\t/* Go directly to page allocator. Do not pass slob allocator */\n\t\tif (slob_page_free(sp))\n\t\t\tclear_slob_page_free(sp);\n\t\tspin_unlock_irqrestore(&slob_lock, flags);\n\t\t__ClearPageSlab(sp);\n\t\tpage_mapcount_reset(sp);\n\t\tslob_free_pages(b, 0);\n\t\treturn;\n\t}\n\n\tif (!slob_page_free(sp)) {\n\t\t/* This slob page is about to become partially free. Easy! */\n\t\tsp->units = units;\n\t\tsp->freelist = b;\n\t\tset_slob(b, units,\n\t\t\t(void *)((unsigned long)(b +\n\t\t\t\t\tSLOB_UNITS(PAGE_SIZE)) & PAGE_MASK));\n\t\tif (size < SLOB_BREAK1)\n\t\t\tslob_list = &free_slob_small;\n\t\telse if (size < SLOB_BREAK2)\n\t\t\tslob_list = &free_slob_medium;\n\t\telse\n\t\t\tslob_list = &free_slob_large;\n\t\tset_slob_page_free(sp, slob_list);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Otherwise the page is already partially free, so find reinsertion\n\t * point.\n\t */\n\tsp->units += units;\n\n\tif (b < (slob_t *)sp->freelist) {\n\t\tif (b + units == sp->freelist) {\n\t\t\tunits += slob_units(sp->freelist);\n\t\t\tsp->freelist = slob_next(sp->freelist);\n\t\t}\n\t\tset_slob(b, units, sp->freelist);\n\t\tsp->freelist = b;\n\t} else {\n\t\tprev = sp->freelist;\n\t\tnext = slob_next(prev);\n\t\twhile (b > next) {\n\t\t\tprev = next;\n\t\t\tnext = slob_next(prev);\n\t\t}\n\n\t\tif (!slob_last(prev) && b + units == next) {\n\t\t\tunits += slob_units(next);\n\t\t\tset_slob(b, units, slob_next(next));\n\t\t} else\n\t\t\tset_slob(b, units, next);\n\n\t\tif (prev + slob_units(prev) == b) {\n\t\t\tunits = slob_units(b) + slob_units(prev);\n\t\t\tset_slob(prev, units, slob_next(b));\n\t\t} else\n\t\t\tset_slob(prev, slob_units(prev), b);\n\t}\nout:\n\tspin_unlock_irqrestore(&slob_lock, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void __kmem_cache_free(void *b, int size)\n{\n\tif (size < PAGE_SIZE)\n\t\tslob_free(b, size);\n\telse\n\t\tslob_free_pages(b, get_order(size));\n}"
  },
  {
    "function_name": "kmem_cache_alloc_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
    "lines": "580-583",
    "snippet": "void *kmem_cache_alloc_node(struct kmem_cache *cachep, gfp_t gfp, int node)\n{\n\treturn slob_alloc_node(cachep, gfp, node);\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/atomic.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/list.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/cache.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "slob_alloc_node",
          "args": [
            "cachep",
            "gfp",
            "node"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "slob_alloc_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
          "lines": "537-565",
          "snippet": "static void *slob_alloc_node(struct kmem_cache *c, gfp_t flags, int node)\n{\n\tvoid *b;\n\n\tflags &= gfp_allowed_mask;\n\n\tfs_reclaim_acquire(flags);\n\tfs_reclaim_release(flags);\n\n\tif (c->size < PAGE_SIZE) {\n\t\tb = slob_alloc(c->size, flags, c->align, node);\n\t\ttrace_kmem_cache_alloc_node(_RET_IP_, b, c->object_size,\n\t\t\t\t\t    SLOB_UNITS(c->size) * SLOB_UNIT,\n\t\t\t\t\t    flags, node);\n\t} else {\n\t\tb = slob_new_pages(flags, get_order(c->size), node);\n\t\ttrace_kmem_cache_alloc_node(_RET_IP_, b, c->object_size,\n\t\t\t\t\t    PAGE_SIZE << get_order(c->size),\n\t\t\t\t\t    flags, node);\n\t}\n\n\tif (b && c->ctor) {\n\t\tWARN_ON_ONCE(flags & __GFP_ZERO);\n\t\tc->ctor(b);\n\t}\n\n\tkmemleak_alloc_recursive(b, c->size, 1, c->flags, flags);\n\treturn b;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <linux/atomic.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/list.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/cache.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define SLOB_UNIT sizeof(slob_t)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\n#define SLOB_UNIT sizeof(slob_t)\n\nstatic void *slob_alloc_node(struct kmem_cache *c, gfp_t flags, int node)\n{\n\tvoid *b;\n\n\tflags &= gfp_allowed_mask;\n\n\tfs_reclaim_acquire(flags);\n\tfs_reclaim_release(flags);\n\n\tif (c->size < PAGE_SIZE) {\n\t\tb = slob_alloc(c->size, flags, c->align, node);\n\t\ttrace_kmem_cache_alloc_node(_RET_IP_, b, c->object_size,\n\t\t\t\t\t    SLOB_UNITS(c->size) * SLOB_UNIT,\n\t\t\t\t\t    flags, node);\n\t} else {\n\t\tb = slob_new_pages(flags, get_order(c->size), node);\n\t\ttrace_kmem_cache_alloc_node(_RET_IP_, b, c->object_size,\n\t\t\t\t\t    PAGE_SIZE << get_order(c->size),\n\t\t\t\t\t    flags, node);\n\t}\n\n\tif (b && c->ctor) {\n\t\tWARN_ON_ONCE(flags & __GFP_ZERO);\n\t\tc->ctor(b);\n\t}\n\n\tkmemleak_alloc_recursive(b, c->size, 1, c->flags, flags);\n\treturn b;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid *kmem_cache_alloc_node(struct kmem_cache *cachep, gfp_t gfp, int node)\n{\n\treturn slob_alloc_node(cachep, gfp, node);\n}"
  },
  {
    "function_name": "__kmalloc_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
    "lines": "574-577",
    "snippet": "void *__kmalloc_node(size_t size, gfp_t gfp, int node)\n{\n\treturn __do_kmalloc_node(size, gfp, node, _RET_IP_);\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/atomic.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/list.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/cache.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__do_kmalloc_node",
          "args": [
            "size",
            "gfp",
            "node",
            "_RET_IP_"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "__do_kmalloc_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
          "lines": "427-465",
          "snippet": "static __always_inline void *\n__do_kmalloc_node(size_t size, gfp_t gfp, int node, unsigned long caller)\n{\n\tunsigned int *m;\n\tint align = max_t(size_t, ARCH_KMALLOC_MINALIGN, ARCH_SLAB_MINALIGN);\n\tvoid *ret;\n\n\tgfp &= gfp_allowed_mask;\n\n\tfs_reclaim_acquire(gfp);\n\tfs_reclaim_release(gfp);\n\n\tif (size < PAGE_SIZE - align) {\n\t\tif (!size)\n\t\t\treturn ZERO_SIZE_PTR;\n\n\t\tm = slob_alloc(size + align, gfp, align, node);\n\n\t\tif (!m)\n\t\t\treturn NULL;\n\t\t*m = size;\n\t\tret = (void *)m + align;\n\n\t\ttrace_kmalloc_node(caller, ret,\n\t\t\t\t   size, size + align, gfp, node);\n\t} else {\n\t\tunsigned int order = get_order(size);\n\n\t\tif (likely(order))\n\t\t\tgfp |= __GFP_COMP;\n\t\tret = slob_new_pages(gfp, order, node);\n\n\t\ttrace_kmalloc_node(caller, ret,\n\t\t\t\t   size, PAGE_SIZE << order, gfp, node);\n\t}\n\n\tkmemleak_alloc(ret, size, 1, gfp);\n\treturn ret;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <linux/atomic.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/list.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/cache.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic __always_inline void *\n__do_kmalloc_node(size_t size, gfp_t gfp, int node, unsigned long caller)\n{\n\tunsigned int *m;\n\tint align = max_t(size_t, ARCH_KMALLOC_MINALIGN, ARCH_SLAB_MINALIGN);\n\tvoid *ret;\n\n\tgfp &= gfp_allowed_mask;\n\n\tfs_reclaim_acquire(gfp);\n\tfs_reclaim_release(gfp);\n\n\tif (size < PAGE_SIZE - align) {\n\t\tif (!size)\n\t\t\treturn ZERO_SIZE_PTR;\n\n\t\tm = slob_alloc(size + align, gfp, align, node);\n\n\t\tif (!m)\n\t\t\treturn NULL;\n\t\t*m = size;\n\t\tret = (void *)m + align;\n\n\t\ttrace_kmalloc_node(caller, ret,\n\t\t\t\t   size, size + align, gfp, node);\n\t} else {\n\t\tunsigned int order = get_order(size);\n\n\t\tif (likely(order))\n\t\t\tgfp |= __GFP_COMP;\n\t\tret = slob_new_pages(gfp, order, node);\n\n\t\ttrace_kmalloc_node(caller, ret,\n\t\t\t\t   size, PAGE_SIZE << order, gfp, node);\n\t}\n\n\tkmemleak_alloc(ret, size, 1, gfp);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid *__kmalloc_node(size_t size, gfp_t gfp, int node)\n{\n\treturn __do_kmalloc_node(size, gfp, node, _RET_IP_);\n}"
  },
  {
    "function_name": "kmem_cache_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
    "lines": "567-570",
    "snippet": "void *kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags)\n{\n\treturn slob_alloc_node(cachep, flags, NUMA_NO_NODE);\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/atomic.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/list.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/cache.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "slob_alloc_node",
          "args": [
            "cachep",
            "flags",
            "NUMA_NO_NODE"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "slob_alloc_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
          "lines": "537-565",
          "snippet": "static void *slob_alloc_node(struct kmem_cache *c, gfp_t flags, int node)\n{\n\tvoid *b;\n\n\tflags &= gfp_allowed_mask;\n\n\tfs_reclaim_acquire(flags);\n\tfs_reclaim_release(flags);\n\n\tif (c->size < PAGE_SIZE) {\n\t\tb = slob_alloc(c->size, flags, c->align, node);\n\t\ttrace_kmem_cache_alloc_node(_RET_IP_, b, c->object_size,\n\t\t\t\t\t    SLOB_UNITS(c->size) * SLOB_UNIT,\n\t\t\t\t\t    flags, node);\n\t} else {\n\t\tb = slob_new_pages(flags, get_order(c->size), node);\n\t\ttrace_kmem_cache_alloc_node(_RET_IP_, b, c->object_size,\n\t\t\t\t\t    PAGE_SIZE << get_order(c->size),\n\t\t\t\t\t    flags, node);\n\t}\n\n\tif (b && c->ctor) {\n\t\tWARN_ON_ONCE(flags & __GFP_ZERO);\n\t\tc->ctor(b);\n\t}\n\n\tkmemleak_alloc_recursive(b, c->size, 1, c->flags, flags);\n\treturn b;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <linux/atomic.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/list.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/cache.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define SLOB_UNIT sizeof(slob_t)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\n#define SLOB_UNIT sizeof(slob_t)\n\nstatic void *slob_alloc_node(struct kmem_cache *c, gfp_t flags, int node)\n{\n\tvoid *b;\n\n\tflags &= gfp_allowed_mask;\n\n\tfs_reclaim_acquire(flags);\n\tfs_reclaim_release(flags);\n\n\tif (c->size < PAGE_SIZE) {\n\t\tb = slob_alloc(c->size, flags, c->align, node);\n\t\ttrace_kmem_cache_alloc_node(_RET_IP_, b, c->object_size,\n\t\t\t\t\t    SLOB_UNITS(c->size) * SLOB_UNIT,\n\t\t\t\t\t    flags, node);\n\t} else {\n\t\tb = slob_new_pages(flags, get_order(c->size), node);\n\t\ttrace_kmem_cache_alloc_node(_RET_IP_, b, c->object_size,\n\t\t\t\t\t    PAGE_SIZE << get_order(c->size),\n\t\t\t\t\t    flags, node);\n\t}\n\n\tif (b && c->ctor) {\n\t\tWARN_ON_ONCE(flags & __GFP_ZERO);\n\t\tc->ctor(b);\n\t}\n\n\tkmemleak_alloc_recursive(b, c->size, 1, c->flags, flags);\n\treturn b;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid *kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags)\n{\n\treturn slob_alloc_node(cachep, flags, NUMA_NO_NODE);\n}"
  },
  {
    "function_name": "slob_alloc_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
    "lines": "537-565",
    "snippet": "static void *slob_alloc_node(struct kmem_cache *c, gfp_t flags, int node)\n{\n\tvoid *b;\n\n\tflags &= gfp_allowed_mask;\n\n\tfs_reclaim_acquire(flags);\n\tfs_reclaim_release(flags);\n\n\tif (c->size < PAGE_SIZE) {\n\t\tb = slob_alloc(c->size, flags, c->align, node);\n\t\ttrace_kmem_cache_alloc_node(_RET_IP_, b, c->object_size,\n\t\t\t\t\t    SLOB_UNITS(c->size) * SLOB_UNIT,\n\t\t\t\t\t    flags, node);\n\t} else {\n\t\tb = slob_new_pages(flags, get_order(c->size), node);\n\t\ttrace_kmem_cache_alloc_node(_RET_IP_, b, c->object_size,\n\t\t\t\t\t    PAGE_SIZE << get_order(c->size),\n\t\t\t\t\t    flags, node);\n\t}\n\n\tif (b && c->ctor) {\n\t\tWARN_ON_ONCE(flags & __GFP_ZERO);\n\t\tc->ctor(b);\n\t}\n\n\tkmemleak_alloc_recursive(b, c->size, 1, c->flags, flags);\n\treturn b;\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/atomic.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/list.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/cache.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define SLOB_UNIT sizeof(slob_t)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmemleak_alloc_recursive",
          "args": [
            "b",
            "c->size",
            "1",
            "c->flags",
            "flags"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->ctor",
          "args": [
            "b"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "flags & __GFP_ZERO"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kmem_cache_alloc_node",
          "args": [
            "_RET_IP_",
            "b",
            "c->object_size",
            "PAGE_SIZE << get_order(c->size)",
            "flags",
            "node"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "c->size"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slob_new_pages",
          "args": [
            "flags",
            "get_order(c->size)",
            "node"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "slob_new_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
          "lines": "191-206",
          "snippet": "static void *slob_new_pages(gfp_t gfp, int order, int node)\n{\n\tvoid *page;\n\n#ifdef CONFIG_NUMA\n\tif (node != NUMA_NO_NODE)\n\t\tpage = __alloc_pages_node(node, gfp, order);\n\telse\n#endif\n\t\tpage = alloc_pages(gfp, order);\n\n\tif (!page)\n\t\treturn NULL;\n\n\treturn page_address(page);\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <linux/atomic.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/list.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/cache.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void *slob_new_pages(gfp_t gfp, int order, int node)\n{\n\tvoid *page;\n\n#ifdef CONFIG_NUMA\n\tif (node != NUMA_NO_NODE)\n\t\tpage = __alloc_pages_node(node, gfp, order);\n\telse\n#endif\n\t\tpage = alloc_pages(gfp, order);\n\n\tif (!page)\n\t\treturn NULL;\n\n\treturn page_address(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "c->size"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kmem_cache_alloc_node",
          "args": [
            "_RET_IP_",
            "b",
            "c->object_size",
            "SLOB_UNITS(c->size) * SLOB_UNIT",
            "flags",
            "node"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SLOB_UNITS",
          "args": [
            "c->size"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slob_alloc",
          "args": [
            "c->size",
            "flags",
            "c->align",
            "node"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "slob_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
          "lines": "269-336",
          "snippet": "static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)\n{\n\tstruct page *sp;\n\tstruct list_head *prev;\n\tstruct list_head *slob_list;\n\tslob_t *b = NULL;\n\tunsigned long flags;\n\n\tif (size < SLOB_BREAK1)\n\t\tslob_list = &free_slob_small;\n\telse if (size < SLOB_BREAK2)\n\t\tslob_list = &free_slob_medium;\n\telse\n\t\tslob_list = &free_slob_large;\n\n\tspin_lock_irqsave(&slob_lock, flags);\n\t/* Iterate through each partially free page, try to find room */\n\tlist_for_each_entry(sp, slob_list, lru) {\n#ifdef CONFIG_NUMA\n\t\t/*\n\t\t * If there's a node specification, search for a partial\n\t\t * page with a matching node id in the freelist.\n\t\t */\n\t\tif (node != NUMA_NO_NODE && page_to_nid(sp) != node)\n\t\t\tcontinue;\n#endif\n\t\t/* Enough room on this page? */\n\t\tif (sp->units < SLOB_UNITS(size))\n\t\t\tcontinue;\n\n\t\t/* Attempt to alloc */\n\t\tprev = sp->lru.prev;\n\t\tb = slob_page_alloc(sp, size, align);\n\t\tif (!b)\n\t\t\tcontinue;\n\n\t\t/* Improve fragment distribution and reduce our average\n\t\t * search time by starting our next search here. (see\n\t\t * Knuth vol 1, sec 2.5, pg 449) */\n\t\tif (prev != slob_list->prev &&\n\t\t\t\tslob_list->next != prev->next)\n\t\t\tlist_move_tail(slob_list, prev->next);\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&slob_lock, flags);\n\n\t/* Not enough space: must allocate a new page */\n\tif (!b) {\n\t\tb = slob_new_pages(gfp & ~__GFP_ZERO, 0, node);\n\t\tif (!b)\n\t\t\treturn NULL;\n\t\tsp = virt_to_page(b);\n\t\t__SetPageSlab(sp);\n\n\t\tspin_lock_irqsave(&slob_lock, flags);\n\t\tsp->units = SLOB_UNITS(PAGE_SIZE);\n\t\tsp->freelist = b;\n\t\tINIT_LIST_HEAD(&sp->lru);\n\t\tset_slob(b, SLOB_UNITS(PAGE_SIZE), b + SLOB_UNITS(PAGE_SIZE));\n\t\tset_slob_page_free(sp, slob_list);\n\t\tb = slob_page_alloc(sp, size, align);\n\t\tBUG_ON(!b);\n\t\tspin_unlock_irqrestore(&slob_lock, flags);\n\t}\n\tif (unlikely(gfp & __GFP_ZERO))\n\t\tmemset(b, 0, size);\n\treturn b;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <linux/atomic.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/list.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/cache.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define SLOB_BREAK2 1024",
            "#define SLOB_BREAK1 256"
          ],
          "globals_used": [
            "static LIST_HEAD(free_slob_small);",
            "static LIST_HEAD(free_slob_medium);",
            "static LIST_HEAD(free_slob_large);",
            "static DEFINE_SPINLOCK(slob_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\n#define SLOB_BREAK2 1024\n#define SLOB_BREAK1 256\n\nstatic LIST_HEAD(free_slob_small);\nstatic LIST_HEAD(free_slob_medium);\nstatic LIST_HEAD(free_slob_large);\nstatic DEFINE_SPINLOCK(slob_lock);\n\nstatic void *slob_alloc(size_t size, gfp_t gfp, int align, int node)\n{\n\tstruct page *sp;\n\tstruct list_head *prev;\n\tstruct list_head *slob_list;\n\tslob_t *b = NULL;\n\tunsigned long flags;\n\n\tif (size < SLOB_BREAK1)\n\t\tslob_list = &free_slob_small;\n\telse if (size < SLOB_BREAK2)\n\t\tslob_list = &free_slob_medium;\n\telse\n\t\tslob_list = &free_slob_large;\n\n\tspin_lock_irqsave(&slob_lock, flags);\n\t/* Iterate through each partially free page, try to find room */\n\tlist_for_each_entry(sp, slob_list, lru) {\n#ifdef CONFIG_NUMA\n\t\t/*\n\t\t * If there's a node specification, search for a partial\n\t\t * page with a matching node id in the freelist.\n\t\t */\n\t\tif (node != NUMA_NO_NODE && page_to_nid(sp) != node)\n\t\t\tcontinue;\n#endif\n\t\t/* Enough room on this page? */\n\t\tif (sp->units < SLOB_UNITS(size))\n\t\t\tcontinue;\n\n\t\t/* Attempt to alloc */\n\t\tprev = sp->lru.prev;\n\t\tb = slob_page_alloc(sp, size, align);\n\t\tif (!b)\n\t\t\tcontinue;\n\n\t\t/* Improve fragment distribution and reduce our average\n\t\t * search time by starting our next search here. (see\n\t\t * Knuth vol 1, sec 2.5, pg 449) */\n\t\tif (prev != slob_list->prev &&\n\t\t\t\tslob_list->next != prev->next)\n\t\t\tlist_move_tail(slob_list, prev->next);\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&slob_lock, flags);\n\n\t/* Not enough space: must allocate a new page */\n\tif (!b) {\n\t\tb = slob_new_pages(gfp & ~__GFP_ZERO, 0, node);\n\t\tif (!b)\n\t\t\treturn NULL;\n\t\tsp = virt_to_page(b);\n\t\t__SetPageSlab(sp);\n\n\t\tspin_lock_irqsave(&slob_lock, flags);\n\t\tsp->units = SLOB_UNITS(PAGE_SIZE);\n\t\tsp->freelist = b;\n\t\tINIT_LIST_HEAD(&sp->lru);\n\t\tset_slob(b, SLOB_UNITS(PAGE_SIZE), b + SLOB_UNITS(PAGE_SIZE));\n\t\tset_slob_page_free(sp, slob_list);\n\t\tb = slob_page_alloc(sp, size, align);\n\t\tBUG_ON(!b);\n\t\tspin_unlock_irqrestore(&slob_lock, flags);\n\t}\n\tif (unlikely(gfp & __GFP_ZERO))\n\t\tmemset(b, 0, size);\n\treturn b;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_reclaim_release",
          "args": [
            "flags"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "fs_reclaim_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3745-3749",
          "snippet": "void fs_reclaim_release(gfp_t gfp_mask)\n{\n\tif (__need_fs_reclaim(gfp_mask))\n\t\t__fs_reclaim_release();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid fs_reclaim_release(gfp_t gfp_mask)\n{\n\tif (__need_fs_reclaim(gfp_mask))\n\t\t__fs_reclaim_release();\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_reclaim_acquire",
          "args": [
            "flags"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "fs_reclaim_acquire",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3738-3742",
          "snippet": "void fs_reclaim_acquire(gfp_t gfp_mask)\n{\n\tif (__need_fs_reclaim(gfp_mask))\n\t\t__fs_reclaim_acquire();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid fs_reclaim_acquire(gfp_t gfp_mask)\n{\n\tif (__need_fs_reclaim(gfp_mask))\n\t\t__fs_reclaim_acquire();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\n#define SLOB_UNIT sizeof(slob_t)\n\nstatic void *slob_alloc_node(struct kmem_cache *c, gfp_t flags, int node)\n{\n\tvoid *b;\n\n\tflags &= gfp_allowed_mask;\n\n\tfs_reclaim_acquire(flags);\n\tfs_reclaim_release(flags);\n\n\tif (c->size < PAGE_SIZE) {\n\t\tb = slob_alloc(c->size, flags, c->align, node);\n\t\ttrace_kmem_cache_alloc_node(_RET_IP_, b, c->object_size,\n\t\t\t\t\t    SLOB_UNITS(c->size) * SLOB_UNIT,\n\t\t\t\t\t    flags, node);\n\t} else {\n\t\tb = slob_new_pages(flags, get_order(c->size), node);\n\t\ttrace_kmem_cache_alloc_node(_RET_IP_, b, c->object_size,\n\t\t\t\t\t    PAGE_SIZE << get_order(c->size),\n\t\t\t\t\t    flags, node);\n\t}\n\n\tif (b && c->ctor) {\n\t\tWARN_ON_ONCE(flags & __GFP_ZERO);\n\t\tc->ctor(b);\n\t}\n\n\tkmemleak_alloc_recursive(b, c->size, 1, c->flags, flags);\n\treturn b;\n}"
  },
  {
    "function_name": "__kmem_cache_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
    "lines": "527-535",
    "snippet": "int __kmem_cache_create(struct kmem_cache *c, slab_flags_t flags)\n{\n\tif (flags & SLAB_TYPESAFE_BY_RCU) {\n\t\t/* leave room for rcu footer at the end of object */\n\t\tc->size += sizeof(struct slob_rcu);\n\t}\n\tc->flags = flags;\n\treturn 0;\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/atomic.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/list.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/cache.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint __kmem_cache_create(struct kmem_cache *c, slab_flags_t flags)\n{\n\tif (flags & SLAB_TYPESAFE_BY_RCU) {\n\t\t/* leave room for rcu footer at the end of object */\n\t\tc->size += sizeof(struct slob_rcu);\n\t}\n\tc->flags = flags;\n\treturn 0;\n}"
  },
  {
    "function_name": "ksize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
    "lines": "507-524",
    "snippet": "size_t ksize(const void *block)\n{\n\tstruct page *sp;\n\tint align;\n\tunsigned int *m;\n\n\tBUG_ON(!block);\n\tif (unlikely(block == ZERO_SIZE_PTR))\n\t\treturn 0;\n\n\tsp = virt_to_page(block);\n\tif (unlikely(!PageSlab(sp)))\n\t\treturn PAGE_SIZE << compound_order(sp);\n\n\talign = max_t(size_t, ARCH_KMALLOC_MINALIGN, ARCH_SLAB_MINALIGN);\n\tm = (unsigned int *)(block - align);\n\treturn SLOB_UNITS(*m) * SLOB_UNIT;\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/atomic.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/list.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/cache.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define SLOB_UNIT sizeof(slob_t)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SLOB_UNITS",
          "args": [
            "*m"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "size_t",
            "ARCH_KMALLOC_MINALIGN",
            "ARCH_SLAB_MINALIGN"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_order",
          "args": [
            "sp"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!PageSlab(sp)"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSlab",
          "args": [
            "sp"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "block"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "block == ZERO_SIZE_PTR"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!block"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\n#define SLOB_UNIT sizeof(slob_t)\n\nsize_t ksize(const void *block)\n{\n\tstruct page *sp;\n\tint align;\n\tunsigned int *m;\n\n\tBUG_ON(!block);\n\tif (unlikely(block == ZERO_SIZE_PTR))\n\t\treturn 0;\n\n\tsp = virt_to_page(block);\n\tif (unlikely(!PageSlab(sp)))\n\t\treturn PAGE_SIZE << compound_order(sp);\n\n\talign = max_t(size_t, ARCH_KMALLOC_MINALIGN, ARCH_SLAB_MINALIGN);\n\tm = (unsigned int *)(block - align);\n\treturn SLOB_UNITS(*m) * SLOB_UNIT;\n}"
  },
  {
    "function_name": "kfree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
    "lines": "486-503",
    "snippet": "void kfree(const void *block)\n{\n\tstruct page *sp;\n\n\ttrace_kfree(_RET_IP_, block);\n\n\tif (unlikely(ZERO_OR_NULL_PTR(block)))\n\t\treturn;\n\tkmemleak_free(block);\n\n\tsp = virt_to_page(block);\n\tif (PageSlab(sp)) {\n\t\tint align = max_t(size_t, ARCH_KMALLOC_MINALIGN, ARCH_SLAB_MINALIGN);\n\t\tunsigned int *m = (unsigned int *)(block - align);\n\t\tslob_free(m, *m + align);\n\t} else\n\t\t__free_pages(sp, compound_order(sp));\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/atomic.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/list.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/cache.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_pages",
          "args": [
            "sp",
            "compound_order(sp)"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "__free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4430-4438",
          "snippet": "void __free_pages(struct page *page, unsigned int order)\n{\n\tif (put_page_testzero(page)) {\n\t\tif (order == 0)\n\t\t\tfree_unref_page(page);\n\t\telse\n\t\t\t__free_pages_ok(page, order);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid __free_pages(struct page *page, unsigned int order)\n{\n\tif (put_page_testzero(page)) {\n\t\tif (order == 0)\n\t\t\tfree_unref_page(page);\n\t\telse\n\t\t\t__free_pages_ok(page, order);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "compound_order",
          "args": [
            "sp"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slob_free",
          "args": [
            "m",
            "*m + align"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "slob_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
          "lines": "341-421",
          "snippet": "static void slob_free(void *block, int size)\n{\n\tstruct page *sp;\n\tslob_t *prev, *next, *b = (slob_t *)block;\n\tslobidx_t units;\n\tunsigned long flags;\n\tstruct list_head *slob_list;\n\n\tif (unlikely(ZERO_OR_NULL_PTR(block)))\n\t\treturn;\n\tBUG_ON(!size);\n\n\tsp = virt_to_page(block);\n\tunits = SLOB_UNITS(size);\n\n\tspin_lock_irqsave(&slob_lock, flags);\n\n\tif (sp->units + units == SLOB_UNITS(PAGE_SIZE)) {\n\t\t/* Go directly to page allocator. Do not pass slob allocator */\n\t\tif (slob_page_free(sp))\n\t\t\tclear_slob_page_free(sp);\n\t\tspin_unlock_irqrestore(&slob_lock, flags);\n\t\t__ClearPageSlab(sp);\n\t\tpage_mapcount_reset(sp);\n\t\tslob_free_pages(b, 0);\n\t\treturn;\n\t}\n\n\tif (!slob_page_free(sp)) {\n\t\t/* This slob page is about to become partially free. Easy! */\n\t\tsp->units = units;\n\t\tsp->freelist = b;\n\t\tset_slob(b, units,\n\t\t\t(void *)((unsigned long)(b +\n\t\t\t\t\tSLOB_UNITS(PAGE_SIZE)) & PAGE_MASK));\n\t\tif (size < SLOB_BREAK1)\n\t\t\tslob_list = &free_slob_small;\n\t\telse if (size < SLOB_BREAK2)\n\t\t\tslob_list = &free_slob_medium;\n\t\telse\n\t\t\tslob_list = &free_slob_large;\n\t\tset_slob_page_free(sp, slob_list);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Otherwise the page is already partially free, so find reinsertion\n\t * point.\n\t */\n\tsp->units += units;\n\n\tif (b < (slob_t *)sp->freelist) {\n\t\tif (b + units == sp->freelist) {\n\t\t\tunits += slob_units(sp->freelist);\n\t\t\tsp->freelist = slob_next(sp->freelist);\n\t\t}\n\t\tset_slob(b, units, sp->freelist);\n\t\tsp->freelist = b;\n\t} else {\n\t\tprev = sp->freelist;\n\t\tnext = slob_next(prev);\n\t\twhile (b > next) {\n\t\t\tprev = next;\n\t\t\tnext = slob_next(prev);\n\t\t}\n\n\t\tif (!slob_last(prev) && b + units == next) {\n\t\t\tunits += slob_units(next);\n\t\t\tset_slob(b, units, slob_next(next));\n\t\t} else\n\t\t\tset_slob(b, units, next);\n\n\t\tif (prev + slob_units(prev) == b) {\n\t\t\tunits = slob_units(b) + slob_units(prev);\n\t\t\tset_slob(prev, units, slob_next(b));\n\t\t} else\n\t\t\tset_slob(prev, slob_units(prev), b);\n\t}\nout:\n\tspin_unlock_irqrestore(&slob_lock, flags);\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <linux/atomic.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/list.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/cache.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define SLOB_BREAK2 1024",
            "#define SLOB_BREAK1 256"
          ],
          "globals_used": [
            "static LIST_HEAD(free_slob_small);",
            "static LIST_HEAD(free_slob_medium);",
            "static LIST_HEAD(free_slob_large);",
            "static DEFINE_SPINLOCK(slob_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\n#define SLOB_BREAK2 1024\n#define SLOB_BREAK1 256\n\nstatic LIST_HEAD(free_slob_small);\nstatic LIST_HEAD(free_slob_medium);\nstatic LIST_HEAD(free_slob_large);\nstatic DEFINE_SPINLOCK(slob_lock);\n\nstatic void slob_free(void *block, int size)\n{\n\tstruct page *sp;\n\tslob_t *prev, *next, *b = (slob_t *)block;\n\tslobidx_t units;\n\tunsigned long flags;\n\tstruct list_head *slob_list;\n\n\tif (unlikely(ZERO_OR_NULL_PTR(block)))\n\t\treturn;\n\tBUG_ON(!size);\n\n\tsp = virt_to_page(block);\n\tunits = SLOB_UNITS(size);\n\n\tspin_lock_irqsave(&slob_lock, flags);\n\n\tif (sp->units + units == SLOB_UNITS(PAGE_SIZE)) {\n\t\t/* Go directly to page allocator. Do not pass slob allocator */\n\t\tif (slob_page_free(sp))\n\t\t\tclear_slob_page_free(sp);\n\t\tspin_unlock_irqrestore(&slob_lock, flags);\n\t\t__ClearPageSlab(sp);\n\t\tpage_mapcount_reset(sp);\n\t\tslob_free_pages(b, 0);\n\t\treturn;\n\t}\n\n\tif (!slob_page_free(sp)) {\n\t\t/* This slob page is about to become partially free. Easy! */\n\t\tsp->units = units;\n\t\tsp->freelist = b;\n\t\tset_slob(b, units,\n\t\t\t(void *)((unsigned long)(b +\n\t\t\t\t\tSLOB_UNITS(PAGE_SIZE)) & PAGE_MASK));\n\t\tif (size < SLOB_BREAK1)\n\t\t\tslob_list = &free_slob_small;\n\t\telse if (size < SLOB_BREAK2)\n\t\t\tslob_list = &free_slob_medium;\n\t\telse\n\t\t\tslob_list = &free_slob_large;\n\t\tset_slob_page_free(sp, slob_list);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Otherwise the page is already partially free, so find reinsertion\n\t * point.\n\t */\n\tsp->units += units;\n\n\tif (b < (slob_t *)sp->freelist) {\n\t\tif (b + units == sp->freelist) {\n\t\t\tunits += slob_units(sp->freelist);\n\t\t\tsp->freelist = slob_next(sp->freelist);\n\t\t}\n\t\tset_slob(b, units, sp->freelist);\n\t\tsp->freelist = b;\n\t} else {\n\t\tprev = sp->freelist;\n\t\tnext = slob_next(prev);\n\t\twhile (b > next) {\n\t\t\tprev = next;\n\t\t\tnext = slob_next(prev);\n\t\t}\n\n\t\tif (!slob_last(prev) && b + units == next) {\n\t\t\tunits += slob_units(next);\n\t\t\tset_slob(b, units, slob_next(next));\n\t\t} else\n\t\t\tset_slob(b, units, next);\n\n\t\tif (prev + slob_units(prev) == b) {\n\t\t\tunits = slob_units(b) + slob_units(prev);\n\t\t\tset_slob(prev, units, slob_next(b));\n\t\t} else\n\t\t\tset_slob(prev, slob_units(prev), b);\n\t}\nout:\n\tspin_unlock_irqrestore(&slob_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "size_t",
            "ARCH_KMALLOC_MINALIGN",
            "ARCH_SLAB_MINALIGN"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSlab",
          "args": [
            "sp"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "block"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmemleak_free",
          "args": [
            "block"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "kmemleak_free_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1082-1094",
          "snippet": "void __ref kmemleak_free_percpu(const void __percpu *ptr)\n{\n\tunsigned int cpu;\n\n\tpr_debug(\"%s(0x%p)\\n\", __func__, ptr);\n\n\tif (kmemleak_free_enabled && ptr && !IS_ERR(ptr))\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tdelete_object_full((unsigned long)per_cpu_ptr(ptr,\n\t\t\t\t\t\t\t\t      cpu));\n\telse if (kmemleak_early_log)\n\t\tlog_early(KMEMLEAK_FREE_PERCPU, ptr, 0, 0);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kmemleak_free_enabled;",
            "static int kmemleak_early_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int kmemleak_free_enabled;\nstatic int kmemleak_early_log = 1;\n\nvoid __ref kmemleak_free_percpu(const void __percpu *ptr)\n{\n\tunsigned int cpu;\n\n\tpr_debug(\"%s(0x%p)\\n\", __func__, ptr);\n\n\tif (kmemleak_free_enabled && ptr && !IS_ERR(ptr))\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tdelete_object_full((unsigned long)per_cpu_ptr(ptr,\n\t\t\t\t\t\t\t\t      cpu));\n\telse if (kmemleak_early_log)\n\t\tlog_early(KMEMLEAK_FREE_PERCPU, ptr, 0, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ZERO_OR_NULL_PTR(block)"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ZERO_OR_NULL_PTR",
          "args": [
            "block"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kfree",
          "args": [
            "_RET_IP_",
            "block"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid kfree(const void *block)\n{\n\tstruct page *sp;\n\n\ttrace_kfree(_RET_IP_, block);\n\n\tif (unlikely(ZERO_OR_NULL_PTR(block)))\n\t\treturn;\n\tkmemleak_free(block);\n\n\tsp = virt_to_page(block);\n\tif (PageSlab(sp)) {\n\t\tint align = max_t(size_t, ARCH_KMALLOC_MINALIGN, ARCH_SLAB_MINALIGN);\n\t\tunsigned int *m = (unsigned int *)(block - align);\n\t\tslob_free(m, *m + align);\n\t} else\n\t\t__free_pages(sp, compound_order(sp));\n}"
  },
  {
    "function_name": "__kmalloc_node_track_caller",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
    "lines": "479-483",
    "snippet": "void *__kmalloc_node_track_caller(size_t size, gfp_t gfp,\n\t\t\t\t\tint node, unsigned long caller)\n{\n\treturn __do_kmalloc_node(size, gfp, node, caller);\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/atomic.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/list.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/cache.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__do_kmalloc_node",
          "args": [
            "size",
            "gfp",
            "node",
            "caller"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "__do_kmalloc_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
          "lines": "427-465",
          "snippet": "static __always_inline void *\n__do_kmalloc_node(size_t size, gfp_t gfp, int node, unsigned long caller)\n{\n\tunsigned int *m;\n\tint align = max_t(size_t, ARCH_KMALLOC_MINALIGN, ARCH_SLAB_MINALIGN);\n\tvoid *ret;\n\n\tgfp &= gfp_allowed_mask;\n\n\tfs_reclaim_acquire(gfp);\n\tfs_reclaim_release(gfp);\n\n\tif (size < PAGE_SIZE - align) {\n\t\tif (!size)\n\t\t\treturn ZERO_SIZE_PTR;\n\n\t\tm = slob_alloc(size + align, gfp, align, node);\n\n\t\tif (!m)\n\t\t\treturn NULL;\n\t\t*m = size;\n\t\tret = (void *)m + align;\n\n\t\ttrace_kmalloc_node(caller, ret,\n\t\t\t\t   size, size + align, gfp, node);\n\t} else {\n\t\tunsigned int order = get_order(size);\n\n\t\tif (likely(order))\n\t\t\tgfp |= __GFP_COMP;\n\t\tret = slob_new_pages(gfp, order, node);\n\n\t\ttrace_kmalloc_node(caller, ret,\n\t\t\t\t   size, PAGE_SIZE << order, gfp, node);\n\t}\n\n\tkmemleak_alloc(ret, size, 1, gfp);\n\treturn ret;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <linux/atomic.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/list.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/cache.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic __always_inline void *\n__do_kmalloc_node(size_t size, gfp_t gfp, int node, unsigned long caller)\n{\n\tunsigned int *m;\n\tint align = max_t(size_t, ARCH_KMALLOC_MINALIGN, ARCH_SLAB_MINALIGN);\n\tvoid *ret;\n\n\tgfp &= gfp_allowed_mask;\n\n\tfs_reclaim_acquire(gfp);\n\tfs_reclaim_release(gfp);\n\n\tif (size < PAGE_SIZE - align) {\n\t\tif (!size)\n\t\t\treturn ZERO_SIZE_PTR;\n\n\t\tm = slob_alloc(size + align, gfp, align, node);\n\n\t\tif (!m)\n\t\t\treturn NULL;\n\t\t*m = size;\n\t\tret = (void *)m + align;\n\n\t\ttrace_kmalloc_node(caller, ret,\n\t\t\t\t   size, size + align, gfp, node);\n\t} else {\n\t\tunsigned int order = get_order(size);\n\n\t\tif (likely(order))\n\t\t\tgfp |= __GFP_COMP;\n\t\tret = slob_new_pages(gfp, order, node);\n\n\t\ttrace_kmalloc_node(caller, ret,\n\t\t\t\t   size, PAGE_SIZE << order, gfp, node);\n\t}\n\n\tkmemleak_alloc(ret, size, 1, gfp);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid *__kmalloc_node_track_caller(size_t size, gfp_t gfp,\n\t\t\t\t\tint node, unsigned long caller)\n{\n\treturn __do_kmalloc_node(size, gfp, node, caller);\n}"
  },
  {
    "function_name": "__kmalloc_track_caller",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
    "lines": "473-476",
    "snippet": "void *__kmalloc_track_caller(size_t size, gfp_t gfp, unsigned long caller)\n{\n\treturn __do_kmalloc_node(size, gfp, NUMA_NO_NODE, caller);\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/atomic.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/list.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/cache.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__do_kmalloc_node",
          "args": [
            "size",
            "gfp",
            "NUMA_NO_NODE",
            "caller"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "__do_kmalloc_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
          "lines": "427-465",
          "snippet": "static __always_inline void *\n__do_kmalloc_node(size_t size, gfp_t gfp, int node, unsigned long caller)\n{\n\tunsigned int *m;\n\tint align = max_t(size_t, ARCH_KMALLOC_MINALIGN, ARCH_SLAB_MINALIGN);\n\tvoid *ret;\n\n\tgfp &= gfp_allowed_mask;\n\n\tfs_reclaim_acquire(gfp);\n\tfs_reclaim_release(gfp);\n\n\tif (size < PAGE_SIZE - align) {\n\t\tif (!size)\n\t\t\treturn ZERO_SIZE_PTR;\n\n\t\tm = slob_alloc(size + align, gfp, align, node);\n\n\t\tif (!m)\n\t\t\treturn NULL;\n\t\t*m = size;\n\t\tret = (void *)m + align;\n\n\t\ttrace_kmalloc_node(caller, ret,\n\t\t\t\t   size, size + align, gfp, node);\n\t} else {\n\t\tunsigned int order = get_order(size);\n\n\t\tif (likely(order))\n\t\t\tgfp |= __GFP_COMP;\n\t\tret = slob_new_pages(gfp, order, node);\n\n\t\ttrace_kmalloc_node(caller, ret,\n\t\t\t\t   size, PAGE_SIZE << order, gfp, node);\n\t}\n\n\tkmemleak_alloc(ret, size, 1, gfp);\n\treturn ret;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <linux/atomic.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/list.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/cache.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic __always_inline void *\n__do_kmalloc_node(size_t size, gfp_t gfp, int node, unsigned long caller)\n{\n\tunsigned int *m;\n\tint align = max_t(size_t, ARCH_KMALLOC_MINALIGN, ARCH_SLAB_MINALIGN);\n\tvoid *ret;\n\n\tgfp &= gfp_allowed_mask;\n\n\tfs_reclaim_acquire(gfp);\n\tfs_reclaim_release(gfp);\n\n\tif (size < PAGE_SIZE - align) {\n\t\tif (!size)\n\t\t\treturn ZERO_SIZE_PTR;\n\n\t\tm = slob_alloc(size + align, gfp, align, node);\n\n\t\tif (!m)\n\t\t\treturn NULL;\n\t\t*m = size;\n\t\tret = (void *)m + align;\n\n\t\ttrace_kmalloc_node(caller, ret,\n\t\t\t\t   size, size + align, gfp, node);\n\t} else {\n\t\tunsigned int order = get_order(size);\n\n\t\tif (likely(order))\n\t\t\tgfp |= __GFP_COMP;\n\t\tret = slob_new_pages(gfp, order, node);\n\n\t\ttrace_kmalloc_node(caller, ret,\n\t\t\t\t   size, PAGE_SIZE << order, gfp, node);\n\t}\n\n\tkmemleak_alloc(ret, size, 1, gfp);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid *__kmalloc_track_caller(size_t size, gfp_t gfp, unsigned long caller)\n{\n\treturn __do_kmalloc_node(size, gfp, NUMA_NO_NODE, caller);\n}"
  },
  {
    "function_name": "__kmalloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
    "lines": "467-470",
    "snippet": "void *__kmalloc(size_t size, gfp_t gfp)\n{\n\treturn __do_kmalloc_node(size, gfp, NUMA_NO_NODE, _RET_IP_);\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/atomic.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/list.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/cache.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__do_kmalloc_node",
          "args": [
            "size",
            "gfp",
            "NUMA_NO_NODE",
            "_RET_IP_"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "__do_kmalloc_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
          "lines": "427-465",
          "snippet": "static __always_inline void *\n__do_kmalloc_node(size_t size, gfp_t gfp, int node, unsigned long caller)\n{\n\tunsigned int *m;\n\tint align = max_t(size_t, ARCH_KMALLOC_MINALIGN, ARCH_SLAB_MINALIGN);\n\tvoid *ret;\n\n\tgfp &= gfp_allowed_mask;\n\n\tfs_reclaim_acquire(gfp);\n\tfs_reclaim_release(gfp);\n\n\tif (size < PAGE_SIZE - align) {\n\t\tif (!size)\n\t\t\treturn ZERO_SIZE_PTR;\n\n\t\tm = slob_alloc(size + align, gfp, align, node);\n\n\t\tif (!m)\n\t\t\treturn NULL;\n\t\t*m = size;\n\t\tret = (void *)m + align;\n\n\t\ttrace_kmalloc_node(caller, ret,\n\t\t\t\t   size, size + align, gfp, node);\n\t} else {\n\t\tunsigned int order = get_order(size);\n\n\t\tif (likely(order))\n\t\t\tgfp |= __GFP_COMP;\n\t\tret = slob_new_pages(gfp, order, node);\n\n\t\ttrace_kmalloc_node(caller, ret,\n\t\t\t\t   size, PAGE_SIZE << order, gfp, node);\n\t}\n\n\tkmemleak_alloc(ret, size, 1, gfp);\n\treturn ret;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <linux/atomic.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/list.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/cache.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic __always_inline void *\n__do_kmalloc_node(size_t size, gfp_t gfp, int node, unsigned long caller)\n{\n\tunsigned int *m;\n\tint align = max_t(size_t, ARCH_KMALLOC_MINALIGN, ARCH_SLAB_MINALIGN);\n\tvoid *ret;\n\n\tgfp &= gfp_allowed_mask;\n\n\tfs_reclaim_acquire(gfp);\n\tfs_reclaim_release(gfp);\n\n\tif (size < PAGE_SIZE - align) {\n\t\tif (!size)\n\t\t\treturn ZERO_SIZE_PTR;\n\n\t\tm = slob_alloc(size + align, gfp, align, node);\n\n\t\tif (!m)\n\t\t\treturn NULL;\n\t\t*m = size;\n\t\tret = (void *)m + align;\n\n\t\ttrace_kmalloc_node(caller, ret,\n\t\t\t\t   size, size + align, gfp, node);\n\t} else {\n\t\tunsigned int order = get_order(size);\n\n\t\tif (likely(order))\n\t\t\tgfp |= __GFP_COMP;\n\t\tret = slob_new_pages(gfp, order, node);\n\n\t\ttrace_kmalloc_node(caller, ret,\n\t\t\t\t   size, PAGE_SIZE << order, gfp, node);\n\t}\n\n\tkmemleak_alloc(ret, size, 1, gfp);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid *__kmalloc(size_t size, gfp_t gfp)\n{\n\treturn __do_kmalloc_node(size, gfp, NUMA_NO_NODE, _RET_IP_);\n}"
  },
  {
    "function_name": "__do_kmalloc_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
    "lines": "427-465",
    "snippet": "static __always_inline void *\n__do_kmalloc_node(size_t size, gfp_t gfp, int node, unsigned long caller)\n{\n\tunsigned int *m;\n\tint align = max_t(size_t, ARCH_KMALLOC_MINALIGN, ARCH_SLAB_MINALIGN);\n\tvoid *ret;\n\n\tgfp &= gfp_allowed_mask;\n\n\tfs_reclaim_acquire(gfp);\n\tfs_reclaim_release(gfp);\n\n\tif (size < PAGE_SIZE - align) {\n\t\tif (!size)\n\t\t\treturn ZERO_SIZE_PTR;\n\n\t\tm = slob_alloc(size + align, gfp, align, node);\n\n\t\tif (!m)\n\t\t\treturn NULL;\n\t\t*m = size;\n\t\tret = (void *)m + align;\n\n\t\ttrace_kmalloc_node(caller, ret,\n\t\t\t\t   size, size + align, gfp, node);\n\t} else {\n\t\tunsigned int order = get_order(size);\n\n\t\tif (likely(order))\n\t\t\tgfp |= __GFP_COMP;\n\t\tret = slob_new_pages(gfp, order, node);\n\n\t\ttrace_kmalloc_node(caller, ret,\n\t\t\t\t   size, PAGE_SIZE << order, gfp, node);\n\t}\n\n\tkmemleak_alloc(ret, size, 1, gfp);\n\treturn ret;\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/atomic.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/list.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/cache.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmemleak_alloc",
          "args": [
            "ret",
            "size",
            "1",
            "gfp"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "kmemleak_alloc_phys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1220-1225",
          "snippet": "void __ref kmemleak_alloc_phys(phys_addr_t phys, size_t size, int min_count,\n\t\t\t       gfp_t gfp)\n{\n\tif (!IS_ENABLED(CONFIG_HIGHMEM) || PHYS_PFN(phys) < max_low_pfn)\n\t\tkmemleak_alloc(__va(phys), size, min_count, gfp);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nvoid __ref kmemleak_alloc_phys(phys_addr_t phys, size_t size, int min_count,\n\t\t\t       gfp_t gfp)\n{\n\tif (!IS_ENABLED(CONFIG_HIGHMEM) || PHYS_PFN(phys) < max_low_pfn)\n\t\tkmemleak_alloc(__va(phys), size, min_count, gfp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kmalloc_node",
          "args": [
            "caller",
            "ret",
            "size",
            "PAGE_SIZE << order",
            "gfp",
            "node"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slob_new_pages",
          "args": [
            "gfp",
            "order",
            "node"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "slob_new_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
          "lines": "191-206",
          "snippet": "static void *slob_new_pages(gfp_t gfp, int order, int node)\n{\n\tvoid *page;\n\n#ifdef CONFIG_NUMA\n\tif (node != NUMA_NO_NODE)\n\t\tpage = __alloc_pages_node(node, gfp, order);\n\telse\n#endif\n\t\tpage = alloc_pages(gfp, order);\n\n\tif (!page)\n\t\treturn NULL;\n\n\treturn page_address(page);\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <linux/atomic.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/list.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/cache.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void *slob_new_pages(gfp_t gfp, int order, int node)\n{\n\tvoid *page;\n\n#ifdef CONFIG_NUMA\n\tif (node != NUMA_NO_NODE)\n\t\tpage = __alloc_pages_node(node, gfp, order);\n\telse\n#endif\n\t\tpage = alloc_pages(gfp, order);\n\n\tif (!page)\n\t\treturn NULL;\n\n\treturn page_address(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "order"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "size"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kmalloc_node",
          "args": [
            "caller",
            "ret",
            "size",
            "size + align",
            "gfp",
            "node"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slob_alloc",
          "args": [
            "size + align",
            "gfp",
            "align",
            "node"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "slob_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
          "lines": "269-336",
          "snippet": "static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)\n{\n\tstruct page *sp;\n\tstruct list_head *prev;\n\tstruct list_head *slob_list;\n\tslob_t *b = NULL;\n\tunsigned long flags;\n\n\tif (size < SLOB_BREAK1)\n\t\tslob_list = &free_slob_small;\n\telse if (size < SLOB_BREAK2)\n\t\tslob_list = &free_slob_medium;\n\telse\n\t\tslob_list = &free_slob_large;\n\n\tspin_lock_irqsave(&slob_lock, flags);\n\t/* Iterate through each partially free page, try to find room */\n\tlist_for_each_entry(sp, slob_list, lru) {\n#ifdef CONFIG_NUMA\n\t\t/*\n\t\t * If there's a node specification, search for a partial\n\t\t * page with a matching node id in the freelist.\n\t\t */\n\t\tif (node != NUMA_NO_NODE && page_to_nid(sp) != node)\n\t\t\tcontinue;\n#endif\n\t\t/* Enough room on this page? */\n\t\tif (sp->units < SLOB_UNITS(size))\n\t\t\tcontinue;\n\n\t\t/* Attempt to alloc */\n\t\tprev = sp->lru.prev;\n\t\tb = slob_page_alloc(sp, size, align);\n\t\tif (!b)\n\t\t\tcontinue;\n\n\t\t/* Improve fragment distribution and reduce our average\n\t\t * search time by starting our next search here. (see\n\t\t * Knuth vol 1, sec 2.5, pg 449) */\n\t\tif (prev != slob_list->prev &&\n\t\t\t\tslob_list->next != prev->next)\n\t\t\tlist_move_tail(slob_list, prev->next);\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&slob_lock, flags);\n\n\t/* Not enough space: must allocate a new page */\n\tif (!b) {\n\t\tb = slob_new_pages(gfp & ~__GFP_ZERO, 0, node);\n\t\tif (!b)\n\t\t\treturn NULL;\n\t\tsp = virt_to_page(b);\n\t\t__SetPageSlab(sp);\n\n\t\tspin_lock_irqsave(&slob_lock, flags);\n\t\tsp->units = SLOB_UNITS(PAGE_SIZE);\n\t\tsp->freelist = b;\n\t\tINIT_LIST_HEAD(&sp->lru);\n\t\tset_slob(b, SLOB_UNITS(PAGE_SIZE), b + SLOB_UNITS(PAGE_SIZE));\n\t\tset_slob_page_free(sp, slob_list);\n\t\tb = slob_page_alloc(sp, size, align);\n\t\tBUG_ON(!b);\n\t\tspin_unlock_irqrestore(&slob_lock, flags);\n\t}\n\tif (unlikely(gfp & __GFP_ZERO))\n\t\tmemset(b, 0, size);\n\treturn b;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <linux/atomic.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/list.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/cache.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define SLOB_BREAK2 1024",
            "#define SLOB_BREAK1 256"
          ],
          "globals_used": [
            "static LIST_HEAD(free_slob_small);",
            "static LIST_HEAD(free_slob_medium);",
            "static LIST_HEAD(free_slob_large);",
            "static DEFINE_SPINLOCK(slob_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\n#define SLOB_BREAK2 1024\n#define SLOB_BREAK1 256\n\nstatic LIST_HEAD(free_slob_small);\nstatic LIST_HEAD(free_slob_medium);\nstatic LIST_HEAD(free_slob_large);\nstatic DEFINE_SPINLOCK(slob_lock);\n\nstatic void *slob_alloc(size_t size, gfp_t gfp, int align, int node)\n{\n\tstruct page *sp;\n\tstruct list_head *prev;\n\tstruct list_head *slob_list;\n\tslob_t *b = NULL;\n\tunsigned long flags;\n\n\tif (size < SLOB_BREAK1)\n\t\tslob_list = &free_slob_small;\n\telse if (size < SLOB_BREAK2)\n\t\tslob_list = &free_slob_medium;\n\telse\n\t\tslob_list = &free_slob_large;\n\n\tspin_lock_irqsave(&slob_lock, flags);\n\t/* Iterate through each partially free page, try to find room */\n\tlist_for_each_entry(sp, slob_list, lru) {\n#ifdef CONFIG_NUMA\n\t\t/*\n\t\t * If there's a node specification, search for a partial\n\t\t * page with a matching node id in the freelist.\n\t\t */\n\t\tif (node != NUMA_NO_NODE && page_to_nid(sp) != node)\n\t\t\tcontinue;\n#endif\n\t\t/* Enough room on this page? */\n\t\tif (sp->units < SLOB_UNITS(size))\n\t\t\tcontinue;\n\n\t\t/* Attempt to alloc */\n\t\tprev = sp->lru.prev;\n\t\tb = slob_page_alloc(sp, size, align);\n\t\tif (!b)\n\t\t\tcontinue;\n\n\t\t/* Improve fragment distribution and reduce our average\n\t\t * search time by starting our next search here. (see\n\t\t * Knuth vol 1, sec 2.5, pg 449) */\n\t\tif (prev != slob_list->prev &&\n\t\t\t\tslob_list->next != prev->next)\n\t\t\tlist_move_tail(slob_list, prev->next);\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&slob_lock, flags);\n\n\t/* Not enough space: must allocate a new page */\n\tif (!b) {\n\t\tb = slob_new_pages(gfp & ~__GFP_ZERO, 0, node);\n\t\tif (!b)\n\t\t\treturn NULL;\n\t\tsp = virt_to_page(b);\n\t\t__SetPageSlab(sp);\n\n\t\tspin_lock_irqsave(&slob_lock, flags);\n\t\tsp->units = SLOB_UNITS(PAGE_SIZE);\n\t\tsp->freelist = b;\n\t\tINIT_LIST_HEAD(&sp->lru);\n\t\tset_slob(b, SLOB_UNITS(PAGE_SIZE), b + SLOB_UNITS(PAGE_SIZE));\n\t\tset_slob_page_free(sp, slob_list);\n\t\tb = slob_page_alloc(sp, size, align);\n\t\tBUG_ON(!b);\n\t\tspin_unlock_irqrestore(&slob_lock, flags);\n\t}\n\tif (unlikely(gfp & __GFP_ZERO))\n\t\tmemset(b, 0, size);\n\treturn b;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_reclaim_release",
          "args": [
            "gfp"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "fs_reclaim_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3745-3749",
          "snippet": "void fs_reclaim_release(gfp_t gfp_mask)\n{\n\tif (__need_fs_reclaim(gfp_mask))\n\t\t__fs_reclaim_release();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid fs_reclaim_release(gfp_t gfp_mask)\n{\n\tif (__need_fs_reclaim(gfp_mask))\n\t\t__fs_reclaim_release();\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_reclaim_acquire",
          "args": [
            "gfp"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "fs_reclaim_acquire",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3738-3742",
          "snippet": "void fs_reclaim_acquire(gfp_t gfp_mask)\n{\n\tif (__need_fs_reclaim(gfp_mask))\n\t\t__fs_reclaim_acquire();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid fs_reclaim_acquire(gfp_t gfp_mask)\n{\n\tif (__need_fs_reclaim(gfp_mask))\n\t\t__fs_reclaim_acquire();\n}"
        }
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "size_t",
            "ARCH_KMALLOC_MINALIGN",
            "ARCH_SLAB_MINALIGN"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic __always_inline void *\n__do_kmalloc_node(size_t size, gfp_t gfp, int node, unsigned long caller)\n{\n\tunsigned int *m;\n\tint align = max_t(size_t, ARCH_KMALLOC_MINALIGN, ARCH_SLAB_MINALIGN);\n\tvoid *ret;\n\n\tgfp &= gfp_allowed_mask;\n\n\tfs_reclaim_acquire(gfp);\n\tfs_reclaim_release(gfp);\n\n\tif (size < PAGE_SIZE - align) {\n\t\tif (!size)\n\t\t\treturn ZERO_SIZE_PTR;\n\n\t\tm = slob_alloc(size + align, gfp, align, node);\n\n\t\tif (!m)\n\t\t\treturn NULL;\n\t\t*m = size;\n\t\tret = (void *)m + align;\n\n\t\ttrace_kmalloc_node(caller, ret,\n\t\t\t\t   size, size + align, gfp, node);\n\t} else {\n\t\tunsigned int order = get_order(size);\n\n\t\tif (likely(order))\n\t\t\tgfp |= __GFP_COMP;\n\t\tret = slob_new_pages(gfp, order, node);\n\n\t\ttrace_kmalloc_node(caller, ret,\n\t\t\t\t   size, PAGE_SIZE << order, gfp, node);\n\t}\n\n\tkmemleak_alloc(ret, size, 1, gfp);\n\treturn ret;\n}"
  },
  {
    "function_name": "slob_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
    "lines": "341-421",
    "snippet": "static void slob_free(void *block, int size)\n{\n\tstruct page *sp;\n\tslob_t *prev, *next, *b = (slob_t *)block;\n\tslobidx_t units;\n\tunsigned long flags;\n\tstruct list_head *slob_list;\n\n\tif (unlikely(ZERO_OR_NULL_PTR(block)))\n\t\treturn;\n\tBUG_ON(!size);\n\n\tsp = virt_to_page(block);\n\tunits = SLOB_UNITS(size);\n\n\tspin_lock_irqsave(&slob_lock, flags);\n\n\tif (sp->units + units == SLOB_UNITS(PAGE_SIZE)) {\n\t\t/* Go directly to page allocator. Do not pass slob allocator */\n\t\tif (slob_page_free(sp))\n\t\t\tclear_slob_page_free(sp);\n\t\tspin_unlock_irqrestore(&slob_lock, flags);\n\t\t__ClearPageSlab(sp);\n\t\tpage_mapcount_reset(sp);\n\t\tslob_free_pages(b, 0);\n\t\treturn;\n\t}\n\n\tif (!slob_page_free(sp)) {\n\t\t/* This slob page is about to become partially free. Easy! */\n\t\tsp->units = units;\n\t\tsp->freelist = b;\n\t\tset_slob(b, units,\n\t\t\t(void *)((unsigned long)(b +\n\t\t\t\t\tSLOB_UNITS(PAGE_SIZE)) & PAGE_MASK));\n\t\tif (size < SLOB_BREAK1)\n\t\t\tslob_list = &free_slob_small;\n\t\telse if (size < SLOB_BREAK2)\n\t\t\tslob_list = &free_slob_medium;\n\t\telse\n\t\t\tslob_list = &free_slob_large;\n\t\tset_slob_page_free(sp, slob_list);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Otherwise the page is already partially free, so find reinsertion\n\t * point.\n\t */\n\tsp->units += units;\n\n\tif (b < (slob_t *)sp->freelist) {\n\t\tif (b + units == sp->freelist) {\n\t\t\tunits += slob_units(sp->freelist);\n\t\t\tsp->freelist = slob_next(sp->freelist);\n\t\t}\n\t\tset_slob(b, units, sp->freelist);\n\t\tsp->freelist = b;\n\t} else {\n\t\tprev = sp->freelist;\n\t\tnext = slob_next(prev);\n\t\twhile (b > next) {\n\t\t\tprev = next;\n\t\t\tnext = slob_next(prev);\n\t\t}\n\n\t\tif (!slob_last(prev) && b + units == next) {\n\t\t\tunits += slob_units(next);\n\t\t\tset_slob(b, units, slob_next(next));\n\t\t} else\n\t\t\tset_slob(b, units, next);\n\n\t\tif (prev + slob_units(prev) == b) {\n\t\t\tunits = slob_units(b) + slob_units(prev);\n\t\t\tset_slob(prev, units, slob_next(b));\n\t\t} else\n\t\t\tset_slob(prev, slob_units(prev), b);\n\t}\nout:\n\tspin_unlock_irqrestore(&slob_lock, flags);\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/atomic.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/list.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/cache.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define SLOB_BREAK2 1024",
      "#define SLOB_BREAK1 256"
    ],
    "globals_used": [
      "static LIST_HEAD(free_slob_small);",
      "static LIST_HEAD(free_slob_medium);",
      "static LIST_HEAD(free_slob_large);",
      "static DEFINE_SPINLOCK(slob_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&slob_lock",
            "flags"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_slob",
          "args": [
            "prev",
            "slob_units(prev)",
            "b"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "set_slob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
          "lines": "146-156",
          "snippet": "static void set_slob(slob_t *s, slobidx_t size, slob_t *next)\n{\n\tslob_t *base = (slob_t *)((unsigned long)s & PAGE_MASK);\n\tslobidx_t offset = next - base;\n\n\tif (size > 1) {\n\t\ts[0].units = size;\n\t\ts[1].units = offset;\n\t} else\n\t\ts[0].units = -offset;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <linux/atomic.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/list.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/cache.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void set_slob(slob_t *s, slobidx_t size, slob_t *next)\n{\n\tslob_t *base = (slob_t *)((unsigned long)s & PAGE_MASK);\n\tslobidx_t offset = next - base;\n\n\tif (size > 1) {\n\t\ts[0].units = size;\n\t\ts[1].units = offset;\n\t} else\n\t\ts[0].units = -offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "slob_units",
          "args": [
            "prev"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "slob_units",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
          "lines": "161-166",
          "snippet": "static slobidx_t slob_units(slob_t *s)\n{\n\tif (s->units > 0)\n\t\treturn s->units;\n\treturn 1;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <linux/atomic.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/list.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/cache.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic slobidx_t slob_units(slob_t *s)\n{\n\tif (s->units > 0)\n\t\treturn s->units;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "slob_next",
          "args": [
            "b"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "slob_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
          "lines": "171-181",
          "snippet": "static slob_t *slob_next(slob_t *s)\n{\n\tslob_t *base = (slob_t *)((unsigned long)s & PAGE_MASK);\n\tslobidx_t next;\n\n\tif (s[0].units < 0)\n\t\tnext = -s[0].units;\n\telse\n\t\tnext = s[1].units;\n\treturn base+next;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <linux/atomic.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/list.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/cache.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic slob_t *slob_next(slob_t *s)\n{\n\tslob_t *base = (slob_t *)((unsigned long)s & PAGE_MASK);\n\tslobidx_t next;\n\n\tif (s[0].units < 0)\n\t\tnext = -s[0].units;\n\telse\n\t\tnext = s[1].units;\n\treturn base+next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "slob_last",
          "args": [
            "prev"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "slob_last",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
          "lines": "186-189",
          "snippet": "static int slob_last(slob_t *s)\n{\n\treturn !((unsigned long)slob_next(s) & ~PAGE_MASK);\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <linux/atomic.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/list.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/cache.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int slob_last(slob_t *s)\n{\n\treturn !((unsigned long)slob_next(s) & ~PAGE_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_slob_page_free",
          "args": [
            "sp",
            "slob_list"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "set_slob_page_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
          "lines": "113-117",
          "snippet": "static void set_slob_page_free(struct page *sp, struct list_head *list)\n{\n\tlist_add(&sp->lru, list);\n\t__SetPageSlobFree(sp);\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <linux/atomic.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/list.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/cache.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void set_slob_page_free(struct page *sp, struct list_head *list)\n{\n\tlist_add(&sp->lru, list);\n\t__SetPageSlobFree(sp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SLOB_UNITS",
          "args": [
            "PAGE_SIZE"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slob_page_free",
          "args": [
            "sp"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "clear_slob_page_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
          "lines": "119-123",
          "snippet": "static inline void clear_slob_page_free(struct page *sp)\n{\n\tlist_del(&sp->lru);\n\t__ClearPageSlobFree(sp);\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <linux/atomic.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/list.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/cache.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline void clear_slob_page_free(struct page *sp)\n{\n\tlist_del(&sp->lru);\n\t__ClearPageSlobFree(sp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "slob_free_pages",
          "args": [
            "b",
            "0"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "slob_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
          "lines": "208-213",
          "snippet": "static void slob_free_pages(void *b, int order)\n{\n\tif (current->reclaim_state)\n\t\tcurrent->reclaim_state->reclaimed_slab += 1 << order;\n\tfree_pages((unsigned long)b, order);\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <linux/atomic.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/list.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/cache.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void slob_free_pages(void *b, int order)\n{\n\tif (current->reclaim_state)\n\t\tcurrent->reclaim_state->reclaimed_slab += 1 << order;\n\tfree_pages((unsigned long)b, order);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_mapcount_reset",
          "args": [
            "sp"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ClearPageSlab",
          "args": [
            "sp"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&slob_lock",
            "flags"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SLOB_UNITS",
          "args": [
            "PAGE_SIZE"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&slob_lock",
            "flags"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SLOB_UNITS",
          "args": [
            "size"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "block"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!size"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ZERO_OR_NULL_PTR(block)"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ZERO_OR_NULL_PTR",
          "args": [
            "block"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\n#define SLOB_BREAK2 1024\n#define SLOB_BREAK1 256\n\nstatic LIST_HEAD(free_slob_small);\nstatic LIST_HEAD(free_slob_medium);\nstatic LIST_HEAD(free_slob_large);\nstatic DEFINE_SPINLOCK(slob_lock);\n\nstatic void slob_free(void *block, int size)\n{\n\tstruct page *sp;\n\tslob_t *prev, *next, *b = (slob_t *)block;\n\tslobidx_t units;\n\tunsigned long flags;\n\tstruct list_head *slob_list;\n\n\tif (unlikely(ZERO_OR_NULL_PTR(block)))\n\t\treturn;\n\tBUG_ON(!size);\n\n\tsp = virt_to_page(block);\n\tunits = SLOB_UNITS(size);\n\n\tspin_lock_irqsave(&slob_lock, flags);\n\n\tif (sp->units + units == SLOB_UNITS(PAGE_SIZE)) {\n\t\t/* Go directly to page allocator. Do not pass slob allocator */\n\t\tif (slob_page_free(sp))\n\t\t\tclear_slob_page_free(sp);\n\t\tspin_unlock_irqrestore(&slob_lock, flags);\n\t\t__ClearPageSlab(sp);\n\t\tpage_mapcount_reset(sp);\n\t\tslob_free_pages(b, 0);\n\t\treturn;\n\t}\n\n\tif (!slob_page_free(sp)) {\n\t\t/* This slob page is about to become partially free. Easy! */\n\t\tsp->units = units;\n\t\tsp->freelist = b;\n\t\tset_slob(b, units,\n\t\t\t(void *)((unsigned long)(b +\n\t\t\t\t\tSLOB_UNITS(PAGE_SIZE)) & PAGE_MASK));\n\t\tif (size < SLOB_BREAK1)\n\t\t\tslob_list = &free_slob_small;\n\t\telse if (size < SLOB_BREAK2)\n\t\t\tslob_list = &free_slob_medium;\n\t\telse\n\t\t\tslob_list = &free_slob_large;\n\t\tset_slob_page_free(sp, slob_list);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Otherwise the page is already partially free, so find reinsertion\n\t * point.\n\t */\n\tsp->units += units;\n\n\tif (b < (slob_t *)sp->freelist) {\n\t\tif (b + units == sp->freelist) {\n\t\t\tunits += slob_units(sp->freelist);\n\t\t\tsp->freelist = slob_next(sp->freelist);\n\t\t}\n\t\tset_slob(b, units, sp->freelist);\n\t\tsp->freelist = b;\n\t} else {\n\t\tprev = sp->freelist;\n\t\tnext = slob_next(prev);\n\t\twhile (b > next) {\n\t\t\tprev = next;\n\t\t\tnext = slob_next(prev);\n\t\t}\n\n\t\tif (!slob_last(prev) && b + units == next) {\n\t\t\tunits += slob_units(next);\n\t\t\tset_slob(b, units, slob_next(next));\n\t\t} else\n\t\t\tset_slob(b, units, next);\n\n\t\tif (prev + slob_units(prev) == b) {\n\t\t\tunits = slob_units(b) + slob_units(prev);\n\t\t\tset_slob(prev, units, slob_next(b));\n\t\t} else\n\t\t\tset_slob(prev, slob_units(prev), b);\n\t}\nout:\n\tspin_unlock_irqrestore(&slob_lock, flags);\n}"
  },
  {
    "function_name": "slob_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
    "lines": "269-336",
    "snippet": "static void *slob_alloc(size_t size, gfp_t gfp, int align, int node)\n{\n\tstruct page *sp;\n\tstruct list_head *prev;\n\tstruct list_head *slob_list;\n\tslob_t *b = NULL;\n\tunsigned long flags;\n\n\tif (size < SLOB_BREAK1)\n\t\tslob_list = &free_slob_small;\n\telse if (size < SLOB_BREAK2)\n\t\tslob_list = &free_slob_medium;\n\telse\n\t\tslob_list = &free_slob_large;\n\n\tspin_lock_irqsave(&slob_lock, flags);\n\t/* Iterate through each partially free page, try to find room */\n\tlist_for_each_entry(sp, slob_list, lru) {\n#ifdef CONFIG_NUMA\n\t\t/*\n\t\t * If there's a node specification, search for a partial\n\t\t * page with a matching node id in the freelist.\n\t\t */\n\t\tif (node != NUMA_NO_NODE && page_to_nid(sp) != node)\n\t\t\tcontinue;\n#endif\n\t\t/* Enough room on this page? */\n\t\tif (sp->units < SLOB_UNITS(size))\n\t\t\tcontinue;\n\n\t\t/* Attempt to alloc */\n\t\tprev = sp->lru.prev;\n\t\tb = slob_page_alloc(sp, size, align);\n\t\tif (!b)\n\t\t\tcontinue;\n\n\t\t/* Improve fragment distribution and reduce our average\n\t\t * search time by starting our next search here. (see\n\t\t * Knuth vol 1, sec 2.5, pg 449) */\n\t\tif (prev != slob_list->prev &&\n\t\t\t\tslob_list->next != prev->next)\n\t\t\tlist_move_tail(slob_list, prev->next);\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&slob_lock, flags);\n\n\t/* Not enough space: must allocate a new page */\n\tif (!b) {\n\t\tb = slob_new_pages(gfp & ~__GFP_ZERO, 0, node);\n\t\tif (!b)\n\t\t\treturn NULL;\n\t\tsp = virt_to_page(b);\n\t\t__SetPageSlab(sp);\n\n\t\tspin_lock_irqsave(&slob_lock, flags);\n\t\tsp->units = SLOB_UNITS(PAGE_SIZE);\n\t\tsp->freelist = b;\n\t\tINIT_LIST_HEAD(&sp->lru);\n\t\tset_slob(b, SLOB_UNITS(PAGE_SIZE), b + SLOB_UNITS(PAGE_SIZE));\n\t\tset_slob_page_free(sp, slob_list);\n\t\tb = slob_page_alloc(sp, size, align);\n\t\tBUG_ON(!b);\n\t\tspin_unlock_irqrestore(&slob_lock, flags);\n\t}\n\tif (unlikely(gfp & __GFP_ZERO))\n\t\tmemset(b, 0, size);\n\treturn b;\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/atomic.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/list.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/cache.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define SLOB_BREAK2 1024",
      "#define SLOB_BREAK1 256"
    ],
    "globals_used": [
      "static LIST_HEAD(free_slob_small);",
      "static LIST_HEAD(free_slob_medium);",
      "static LIST_HEAD(free_slob_large);",
      "static DEFINE_SPINLOCK(slob_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "b",
            "0",
            "size"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "283-288",
          "snippet": "void *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "gfp & __GFP_ZERO"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&slob_lock",
            "flags"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!b"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slob_page_alloc",
          "args": [
            "sp",
            "size",
            "align"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "slob_page_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
          "lines": "218-264",
          "snippet": "static void *slob_page_alloc(struct page *sp, size_t size, int align)\n{\n\tslob_t *prev, *cur, *aligned = NULL;\n\tint delta = 0, units = SLOB_UNITS(size);\n\n\tfor (prev = NULL, cur = sp->freelist; ; prev = cur, cur = slob_next(cur)) {\n\t\tslobidx_t avail = slob_units(cur);\n\n\t\tif (align) {\n\t\t\taligned = (slob_t *)ALIGN((unsigned long)cur, align);\n\t\t\tdelta = aligned - cur;\n\t\t}\n\t\tif (avail >= units + delta) { /* room enough? */\n\t\t\tslob_t *next;\n\n\t\t\tif (delta) { /* need to fragment head to align? */\n\t\t\t\tnext = slob_next(cur);\n\t\t\t\tset_slob(aligned, avail - delta, next);\n\t\t\t\tset_slob(cur, delta, aligned);\n\t\t\t\tprev = cur;\n\t\t\t\tcur = aligned;\n\t\t\t\tavail = slob_units(cur);\n\t\t\t}\n\n\t\t\tnext = slob_next(cur);\n\t\t\tif (avail == units) { /* exact fit? unlink. */\n\t\t\t\tif (prev)\n\t\t\t\t\tset_slob(prev, slob_units(prev), next);\n\t\t\t\telse\n\t\t\t\t\tsp->freelist = next;\n\t\t\t} else { /* fragment */\n\t\t\t\tif (prev)\n\t\t\t\t\tset_slob(prev, slob_units(prev), cur + units);\n\t\t\t\telse\n\t\t\t\t\tsp->freelist = cur + units;\n\t\t\t\tset_slob(cur + units, avail - units, next);\n\t\t\t}\n\n\t\t\tsp->units -= units;\n\t\t\tif (!sp->units)\n\t\t\t\tclear_slob_page_free(sp);\n\t\t\treturn cur;\n\t\t}\n\t\tif (slob_last(cur))\n\t\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <linux/atomic.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/list.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/cache.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void *slob_page_alloc(struct page *sp, size_t size, int align)\n{\n\tslob_t *prev, *cur, *aligned = NULL;\n\tint delta = 0, units = SLOB_UNITS(size);\n\n\tfor (prev = NULL, cur = sp->freelist; ; prev = cur, cur = slob_next(cur)) {\n\t\tslobidx_t avail = slob_units(cur);\n\n\t\tif (align) {\n\t\t\taligned = (slob_t *)ALIGN((unsigned long)cur, align);\n\t\t\tdelta = aligned - cur;\n\t\t}\n\t\tif (avail >= units + delta) { /* room enough? */\n\t\t\tslob_t *next;\n\n\t\t\tif (delta) { /* need to fragment head to align? */\n\t\t\t\tnext = slob_next(cur);\n\t\t\t\tset_slob(aligned, avail - delta, next);\n\t\t\t\tset_slob(cur, delta, aligned);\n\t\t\t\tprev = cur;\n\t\t\t\tcur = aligned;\n\t\t\t\tavail = slob_units(cur);\n\t\t\t}\n\n\t\t\tnext = slob_next(cur);\n\t\t\tif (avail == units) { /* exact fit? unlink. */\n\t\t\t\tif (prev)\n\t\t\t\t\tset_slob(prev, slob_units(prev), next);\n\t\t\t\telse\n\t\t\t\t\tsp->freelist = next;\n\t\t\t} else { /* fragment */\n\t\t\t\tif (prev)\n\t\t\t\t\tset_slob(prev, slob_units(prev), cur + units);\n\t\t\t\telse\n\t\t\t\t\tsp->freelist = cur + units;\n\t\t\t\tset_slob(cur + units, avail - units, next);\n\t\t\t}\n\n\t\t\tsp->units -= units;\n\t\t\tif (!sp->units)\n\t\t\t\tclear_slob_page_free(sp);\n\t\t\treturn cur;\n\t\t}\n\t\tif (slob_last(cur))\n\t\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_slob_page_free",
          "args": [
            "sp",
            "slob_list"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "set_slob_page_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
          "lines": "113-117",
          "snippet": "static void set_slob_page_free(struct page *sp, struct list_head *list)\n{\n\tlist_add(&sp->lru, list);\n\t__SetPageSlobFree(sp);\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <linux/atomic.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/list.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/cache.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void set_slob_page_free(struct page *sp, struct list_head *list)\n{\n\tlist_add(&sp->lru, list);\n\t__SetPageSlobFree(sp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_slob",
          "args": [
            "b",
            "SLOB_UNITS(PAGE_SIZE)",
            "b + SLOB_UNITS(PAGE_SIZE)"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "set_slob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
          "lines": "146-156",
          "snippet": "static void set_slob(slob_t *s, slobidx_t size, slob_t *next)\n{\n\tslob_t *base = (slob_t *)((unsigned long)s & PAGE_MASK);\n\tslobidx_t offset = next - base;\n\n\tif (size > 1) {\n\t\ts[0].units = size;\n\t\ts[1].units = offset;\n\t} else\n\t\ts[0].units = -offset;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <linux/atomic.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/list.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/cache.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void set_slob(slob_t *s, slobidx_t size, slob_t *next)\n{\n\tslob_t *base = (slob_t *)((unsigned long)s & PAGE_MASK);\n\tslobidx_t offset = next - base;\n\n\tif (size > 1) {\n\t\ts[0].units = size;\n\t\ts[1].units = offset;\n\t} else\n\t\ts[0].units = -offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SLOB_UNITS",
          "args": [
            "PAGE_SIZE"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SLOB_UNITS",
          "args": [
            "PAGE_SIZE"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&sp->lru"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SLOB_UNITS",
          "args": [
            "PAGE_SIZE"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&slob_lock",
            "flags"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__SetPageSlab",
          "args": [
            "sp"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "b"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slob_new_pages",
          "args": [
            "gfp & ~__GFP_ZERO",
            "0",
            "node"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "slob_new_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
          "lines": "191-206",
          "snippet": "static void *slob_new_pages(gfp_t gfp, int order, int node)\n{\n\tvoid *page;\n\n#ifdef CONFIG_NUMA\n\tif (node != NUMA_NO_NODE)\n\t\tpage = __alloc_pages_node(node, gfp, order);\n\telse\n#endif\n\t\tpage = alloc_pages(gfp, order);\n\n\tif (!page)\n\t\treturn NULL;\n\n\treturn page_address(page);\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <linux/atomic.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/list.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/cache.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void *slob_new_pages(gfp_t gfp, int order, int node)\n{\n\tvoid *page;\n\n#ifdef CONFIG_NUMA\n\tif (node != NUMA_NO_NODE)\n\t\tpage = __alloc_pages_node(node, gfp, order);\n\telse\n#endif\n\t\tpage = alloc_pages(gfp, order);\n\n\tif (!page)\n\t\treturn NULL;\n\n\treturn page_address(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&slob_lock",
            "flags"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "slob_list",
            "prev->next"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SLOB_UNITS",
          "args": [
            "size"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_nid",
          "args": [
            "sp"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "45-48",
          "snippet": "int page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "sp",
            "slob_list",
            "lru"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&slob_lock",
            "flags"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\n#define SLOB_BREAK2 1024\n#define SLOB_BREAK1 256\n\nstatic LIST_HEAD(free_slob_small);\nstatic LIST_HEAD(free_slob_medium);\nstatic LIST_HEAD(free_slob_large);\nstatic DEFINE_SPINLOCK(slob_lock);\n\nstatic void *slob_alloc(size_t size, gfp_t gfp, int align, int node)\n{\n\tstruct page *sp;\n\tstruct list_head *prev;\n\tstruct list_head *slob_list;\n\tslob_t *b = NULL;\n\tunsigned long flags;\n\n\tif (size < SLOB_BREAK1)\n\t\tslob_list = &free_slob_small;\n\telse if (size < SLOB_BREAK2)\n\t\tslob_list = &free_slob_medium;\n\telse\n\t\tslob_list = &free_slob_large;\n\n\tspin_lock_irqsave(&slob_lock, flags);\n\t/* Iterate through each partially free page, try to find room */\n\tlist_for_each_entry(sp, slob_list, lru) {\n#ifdef CONFIG_NUMA\n\t\t/*\n\t\t * If there's a node specification, search for a partial\n\t\t * page with a matching node id in the freelist.\n\t\t */\n\t\tif (node != NUMA_NO_NODE && page_to_nid(sp) != node)\n\t\t\tcontinue;\n#endif\n\t\t/* Enough room on this page? */\n\t\tif (sp->units < SLOB_UNITS(size))\n\t\t\tcontinue;\n\n\t\t/* Attempt to alloc */\n\t\tprev = sp->lru.prev;\n\t\tb = slob_page_alloc(sp, size, align);\n\t\tif (!b)\n\t\t\tcontinue;\n\n\t\t/* Improve fragment distribution and reduce our average\n\t\t * search time by starting our next search here. (see\n\t\t * Knuth vol 1, sec 2.5, pg 449) */\n\t\tif (prev != slob_list->prev &&\n\t\t\t\tslob_list->next != prev->next)\n\t\t\tlist_move_tail(slob_list, prev->next);\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&slob_lock, flags);\n\n\t/* Not enough space: must allocate a new page */\n\tif (!b) {\n\t\tb = slob_new_pages(gfp & ~__GFP_ZERO, 0, node);\n\t\tif (!b)\n\t\t\treturn NULL;\n\t\tsp = virt_to_page(b);\n\t\t__SetPageSlab(sp);\n\n\t\tspin_lock_irqsave(&slob_lock, flags);\n\t\tsp->units = SLOB_UNITS(PAGE_SIZE);\n\t\tsp->freelist = b;\n\t\tINIT_LIST_HEAD(&sp->lru);\n\t\tset_slob(b, SLOB_UNITS(PAGE_SIZE), b + SLOB_UNITS(PAGE_SIZE));\n\t\tset_slob_page_free(sp, slob_list);\n\t\tb = slob_page_alloc(sp, size, align);\n\t\tBUG_ON(!b);\n\t\tspin_unlock_irqrestore(&slob_lock, flags);\n\t}\n\tif (unlikely(gfp & __GFP_ZERO))\n\t\tmemset(b, 0, size);\n\treturn b;\n}"
  },
  {
    "function_name": "slob_page_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
    "lines": "218-264",
    "snippet": "static void *slob_page_alloc(struct page *sp, size_t size, int align)\n{\n\tslob_t *prev, *cur, *aligned = NULL;\n\tint delta = 0, units = SLOB_UNITS(size);\n\n\tfor (prev = NULL, cur = sp->freelist; ; prev = cur, cur = slob_next(cur)) {\n\t\tslobidx_t avail = slob_units(cur);\n\n\t\tif (align) {\n\t\t\taligned = (slob_t *)ALIGN((unsigned long)cur, align);\n\t\t\tdelta = aligned - cur;\n\t\t}\n\t\tif (avail >= units + delta) { /* room enough? */\n\t\t\tslob_t *next;\n\n\t\t\tif (delta) { /* need to fragment head to align? */\n\t\t\t\tnext = slob_next(cur);\n\t\t\t\tset_slob(aligned, avail - delta, next);\n\t\t\t\tset_slob(cur, delta, aligned);\n\t\t\t\tprev = cur;\n\t\t\t\tcur = aligned;\n\t\t\t\tavail = slob_units(cur);\n\t\t\t}\n\n\t\t\tnext = slob_next(cur);\n\t\t\tif (avail == units) { /* exact fit? unlink. */\n\t\t\t\tif (prev)\n\t\t\t\t\tset_slob(prev, slob_units(prev), next);\n\t\t\t\telse\n\t\t\t\t\tsp->freelist = next;\n\t\t\t} else { /* fragment */\n\t\t\t\tif (prev)\n\t\t\t\t\tset_slob(prev, slob_units(prev), cur + units);\n\t\t\t\telse\n\t\t\t\t\tsp->freelist = cur + units;\n\t\t\t\tset_slob(cur + units, avail - units, next);\n\t\t\t}\n\n\t\t\tsp->units -= units;\n\t\t\tif (!sp->units)\n\t\t\t\tclear_slob_page_free(sp);\n\t\t\treturn cur;\n\t\t}\n\t\tif (slob_last(cur))\n\t\t\treturn NULL;\n\t}\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/atomic.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/list.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/cache.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "slob_last",
          "args": [
            "cur"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "slob_last",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
          "lines": "186-189",
          "snippet": "static int slob_last(slob_t *s)\n{\n\treturn !((unsigned long)slob_next(s) & ~PAGE_MASK);\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <linux/atomic.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/list.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/cache.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int slob_last(slob_t *s)\n{\n\treturn !((unsigned long)slob_next(s) & ~PAGE_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_slob_page_free",
          "args": [
            "sp"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "clear_slob_page_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
          "lines": "119-123",
          "snippet": "static inline void clear_slob_page_free(struct page *sp)\n{\n\tlist_del(&sp->lru);\n\t__ClearPageSlobFree(sp);\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <linux/atomic.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/list.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/cache.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline void clear_slob_page_free(struct page *sp)\n{\n\tlist_del(&sp->lru);\n\t__ClearPageSlobFree(sp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_slob",
          "args": [
            "cur + units",
            "avail - units",
            "next"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "set_slob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
          "lines": "146-156",
          "snippet": "static void set_slob(slob_t *s, slobidx_t size, slob_t *next)\n{\n\tslob_t *base = (slob_t *)((unsigned long)s & PAGE_MASK);\n\tslobidx_t offset = next - base;\n\n\tif (size > 1) {\n\t\ts[0].units = size;\n\t\ts[1].units = offset;\n\t} else\n\t\ts[0].units = -offset;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <linux/atomic.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/list.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/cache.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void set_slob(slob_t *s, slobidx_t size, slob_t *next)\n{\n\tslob_t *base = (slob_t *)((unsigned long)s & PAGE_MASK);\n\tslobidx_t offset = next - base;\n\n\tif (size > 1) {\n\t\ts[0].units = size;\n\t\ts[1].units = offset;\n\t} else\n\t\ts[0].units = -offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "slob_units",
          "args": [
            "prev"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "slob_units",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
          "lines": "161-166",
          "snippet": "static slobidx_t slob_units(slob_t *s)\n{\n\tif (s->units > 0)\n\t\treturn s->units;\n\treturn 1;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <linux/atomic.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/list.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/cache.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic slobidx_t slob_units(slob_t *s)\n{\n\tif (s->units > 0)\n\t\treturn s->units;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "slob_next",
          "args": [
            "cur"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "slob_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
          "lines": "171-181",
          "snippet": "static slob_t *slob_next(slob_t *s)\n{\n\tslob_t *base = (slob_t *)((unsigned long)s & PAGE_MASK);\n\tslobidx_t next;\n\n\tif (s[0].units < 0)\n\t\tnext = -s[0].units;\n\telse\n\t\tnext = s[1].units;\n\treturn base+next;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <linux/atomic.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/list.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/cache.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic slob_t *slob_next(slob_t *s)\n{\n\tslob_t *base = (slob_t *)((unsigned long)s & PAGE_MASK);\n\tslobidx_t next;\n\n\tif (s[0].units < 0)\n\t\tnext = -s[0].units;\n\telse\n\t\tnext = s[1].units;\n\treturn base+next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "(unsigned long)cur",
            "align"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SLOB_UNITS",
          "args": [
            "size"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void *slob_page_alloc(struct page *sp, size_t size, int align)\n{\n\tslob_t *prev, *cur, *aligned = NULL;\n\tint delta = 0, units = SLOB_UNITS(size);\n\n\tfor (prev = NULL, cur = sp->freelist; ; prev = cur, cur = slob_next(cur)) {\n\t\tslobidx_t avail = slob_units(cur);\n\n\t\tif (align) {\n\t\t\taligned = (slob_t *)ALIGN((unsigned long)cur, align);\n\t\t\tdelta = aligned - cur;\n\t\t}\n\t\tif (avail >= units + delta) { /* room enough? */\n\t\t\tslob_t *next;\n\n\t\t\tif (delta) { /* need to fragment head to align? */\n\t\t\t\tnext = slob_next(cur);\n\t\t\t\tset_slob(aligned, avail - delta, next);\n\t\t\t\tset_slob(cur, delta, aligned);\n\t\t\t\tprev = cur;\n\t\t\t\tcur = aligned;\n\t\t\t\tavail = slob_units(cur);\n\t\t\t}\n\n\t\t\tnext = slob_next(cur);\n\t\t\tif (avail == units) { /* exact fit? unlink. */\n\t\t\t\tif (prev)\n\t\t\t\t\tset_slob(prev, slob_units(prev), next);\n\t\t\t\telse\n\t\t\t\t\tsp->freelist = next;\n\t\t\t} else { /* fragment */\n\t\t\t\tif (prev)\n\t\t\t\t\tset_slob(prev, slob_units(prev), cur + units);\n\t\t\t\telse\n\t\t\t\t\tsp->freelist = cur + units;\n\t\t\t\tset_slob(cur + units, avail - units, next);\n\t\t\t}\n\n\t\t\tsp->units -= units;\n\t\t\tif (!sp->units)\n\t\t\t\tclear_slob_page_free(sp);\n\t\t\treturn cur;\n\t\t}\n\t\tif (slob_last(cur))\n\t\t\treturn NULL;\n\t}\n}"
  },
  {
    "function_name": "slob_free_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
    "lines": "208-213",
    "snippet": "static void slob_free_pages(void *b, int order)\n{\n\tif (current->reclaim_state)\n\t\tcurrent->reclaim_state->reclaimed_slab += 1 << order;\n\tfree_pages((unsigned long)b, order);\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/atomic.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/list.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/cache.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_pages",
          "args": [
            "(unsigned long)b",
            "order"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "slob_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
          "lines": "208-213",
          "snippet": "static void slob_free_pages(void *b, int order)\n{\n\tif (current->reclaim_state)\n\t\tcurrent->reclaim_state->reclaimed_slab += 1 << order;\n\tfree_pages((unsigned long)b, order);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void slob_free_pages(void *b, int order)\n{\n\tif (current->reclaim_state)\n\t\tcurrent->reclaim_state->reclaimed_slab += 1 << order;\n\tfree_pages((unsigned long)b, order);\n}"
  },
  {
    "function_name": "slob_new_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
    "lines": "191-206",
    "snippet": "static void *slob_new_pages(gfp_t gfp, int order, int node)\n{\n\tvoid *page;\n\n#ifdef CONFIG_NUMA\n\tif (node != NUMA_NO_NODE)\n\t\tpage = __alloc_pages_node(node, gfp, order);\n\telse\n#endif\n\t\tpage = alloc_pages(gfp, order);\n\n\tif (!page)\n\t\treturn NULL;\n\n\treturn page_address(page);\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/atomic.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/list.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/cache.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "page_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
          "lines": "409-434",
          "snippet": "void *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/tlbflush.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nvoid *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_pages",
          "args": [
            "gfp",
            "order"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_pages_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4594-4601",
          "snippet": "void *alloc_pages_exact(size_t size, gfp_t gfp_mask)\n{\n\tunsigned int order = get_order(size);\n\tunsigned long addr;\n\n\taddr = __get_free_pages(gfp_mask, order);\n\treturn make_alloc_exact(addr, order, size);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\n\nvoid *alloc_pages_exact(size_t size, gfp_t gfp_mask)\n{\n\tunsigned int order = get_order(size);\n\tunsigned long addr;\n\n\taddr = __get_free_pages(gfp_mask, order);\n\treturn make_alloc_exact(addr, order, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__alloc_pages_node",
          "args": [
            "node",
            "gfp",
            "order"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void *slob_new_pages(gfp_t gfp, int order, int node)\n{\n\tvoid *page;\n\n#ifdef CONFIG_NUMA\n\tif (node != NUMA_NO_NODE)\n\t\tpage = __alloc_pages_node(node, gfp, order);\n\telse\n#endif\n\t\tpage = alloc_pages(gfp, order);\n\n\tif (!page)\n\t\treturn NULL;\n\n\treturn page_address(page);\n}"
  },
  {
    "function_name": "slob_last",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
    "lines": "186-189",
    "snippet": "static int slob_last(slob_t *s)\n{\n\treturn !((unsigned long)slob_next(s) & ~PAGE_MASK);\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/atomic.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/list.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/cache.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "slob_next",
          "args": [
            "s"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "slob_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
          "lines": "171-181",
          "snippet": "static slob_t *slob_next(slob_t *s)\n{\n\tslob_t *base = (slob_t *)((unsigned long)s & PAGE_MASK);\n\tslobidx_t next;\n\n\tif (s[0].units < 0)\n\t\tnext = -s[0].units;\n\telse\n\t\tnext = s[1].units;\n\treturn base+next;\n}",
          "includes": [
            "#include \"slab.h\"",
            "#include <linux/atomic.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/list.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/cache.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic slob_t *slob_next(slob_t *s)\n{\n\tslob_t *base = (slob_t *)((unsigned long)s & PAGE_MASK);\n\tslobidx_t next;\n\n\tif (s[0].units < 0)\n\t\tnext = -s[0].units;\n\telse\n\t\tnext = s[1].units;\n\treturn base+next;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int slob_last(slob_t *s)\n{\n\treturn !((unsigned long)slob_next(s) & ~PAGE_MASK);\n}"
  },
  {
    "function_name": "slob_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
    "lines": "171-181",
    "snippet": "static slob_t *slob_next(slob_t *s)\n{\n\tslob_t *base = (slob_t *)((unsigned long)s & PAGE_MASK);\n\tslobidx_t next;\n\n\tif (s[0].units < 0)\n\t\tnext = -s[0].units;\n\telse\n\t\tnext = s[1].units;\n\treturn base+next;\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/atomic.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/list.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/cache.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic slob_t *slob_next(slob_t *s)\n{\n\tslob_t *base = (slob_t *)((unsigned long)s & PAGE_MASK);\n\tslobidx_t next;\n\n\tif (s[0].units < 0)\n\t\tnext = -s[0].units;\n\telse\n\t\tnext = s[1].units;\n\treturn base+next;\n}"
  },
  {
    "function_name": "slob_units",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
    "lines": "161-166",
    "snippet": "static slobidx_t slob_units(slob_t *s)\n{\n\tif (s->units > 0)\n\t\treturn s->units;\n\treturn 1;\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/atomic.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/list.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/cache.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic slobidx_t slob_units(slob_t *s)\n{\n\tif (s->units > 0)\n\t\treturn s->units;\n\treturn 1;\n}"
  },
  {
    "function_name": "set_slob",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
    "lines": "146-156",
    "snippet": "static void set_slob(slob_t *s, slobidx_t size, slob_t *next)\n{\n\tslob_t *base = (slob_t *)((unsigned long)s & PAGE_MASK);\n\tslobidx_t offset = next - base;\n\n\tif (size > 1) {\n\t\ts[0].units = size;\n\t\ts[1].units = offset;\n\t} else\n\t\ts[0].units = -offset;\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/atomic.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/list.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/cache.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void set_slob(slob_t *s, slobidx_t size, slob_t *next)\n{\n\tslob_t *base = (slob_t *)((unsigned long)s & PAGE_MASK);\n\tslobidx_t offset = next - base;\n\n\tif (size > 1) {\n\t\ts[0].units = size;\n\t\ts[1].units = offset;\n\t} else\n\t\ts[0].units = -offset;\n}"
  },
  {
    "function_name": "clear_slob_page_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
    "lines": "119-123",
    "snippet": "static inline void clear_slob_page_free(struct page *sp)\n{\n\tlist_del(&sp->lru);\n\t__ClearPageSlobFree(sp);\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/atomic.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/list.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/cache.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ClearPageSlobFree",
          "args": [
            "sp"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&sp->lru"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline void clear_slob_page_free(struct page *sp)\n{\n\tlist_del(&sp->lru);\n\t__ClearPageSlobFree(sp);\n}"
  },
  {
    "function_name": "set_slob_page_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
    "lines": "113-117",
    "snippet": "static void set_slob_page_free(struct page *sp, struct list_head *list)\n{\n\tlist_add(&sp->lru, list);\n\t__SetPageSlobFree(sp);\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/atomic.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/list.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/cache.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__SetPageSlobFree",
          "args": [
            "sp"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&sp->lru",
            "list"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void set_slob_page_free(struct page *sp, struct list_head *list)\n{\n\tlist_add(&sp->lru, list);\n\t__SetPageSlobFree(sp);\n}"
  },
  {
    "function_name": "slob_page_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slob.c",
    "lines": "108-111",
    "snippet": "static inline int slob_page_free(struct page *sp)\n{\n\treturn PageSlobFree(sp);\n}",
    "includes": [
      "#include \"slab.h\"",
      "#include <linux/atomic.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/list.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/cache.h>",
      "#include <linux/swap.h> /* struct reclaim_state */",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PageSlobFree",
          "args": [
            "sp"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"slab.h\"\n#include <linux/atomic.h>\n#include <trace/events/kmem.h>\n#include <linux/kmemleak.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/cache.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline int slob_page_free(struct page *sp)\n{\n\treturn PageSlobFree(sp);\n}"
  }
]