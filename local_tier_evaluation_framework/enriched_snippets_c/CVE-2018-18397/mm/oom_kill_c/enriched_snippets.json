[
  {
    "function_name": "pagefault_out_of_memory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
    "lines": "1130-1147",
    "snippet": "void pagefault_out_of_memory(void)\n{\n\tstruct oom_control oc = {\n\t\t.zonelist = NULL,\n\t\t.nodemask = NULL,\n\t\t.memcg = NULL,\n\t\t.gfp_mask = 0,\n\t\t.order = 0,\n\t};\n\n\tif (mem_cgroup_oom_synchronize(true))\n\t\treturn;\n\n\tif (!mutex_trylock(&oom_lock))\n\t\treturn;\n\tout_of_memory(&oc);\n\tmutex_unlock(&oom_lock);\n}",
    "includes": [
      "#include <trace/events/oom.h>",
      "#include \"slab.h\"",
      "#include \"internal.h\"",
      "#include <asm/tlb.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/timex.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/oom.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&oom_lock"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "out_of_memory",
          "args": [
            "&oc"
          ],
          "line": 1145
        },
        "resolved": true,
        "details": {
          "function_name": "out_of_memory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
          "lines": "1053-1123",
          "snippet": "bool out_of_memory(struct oom_control *oc)\n{\n\tunsigned long freed = 0;\n\tenum oom_constraint constraint = CONSTRAINT_NONE;\n\n\tif (oom_killer_disabled)\n\t\treturn false;\n\n\tif (!is_memcg_oom(oc)) {\n\t\tblocking_notifier_call_chain(&oom_notify_list, 0, &freed);\n\t\tif (freed > 0)\n\t\t\t/* Got some memory back in the last second. */\n\t\t\treturn true;\n\t}\n\n\t/*\n\t * If current has a pending SIGKILL or is exiting, then automatically\n\t * select it.  The goal is to allow it to allocate so that it may\n\t * quickly exit and free its memory.\n\t */\n\tif (task_will_free_mem(current)) {\n\t\tmark_oom_victim(current);\n\t\twake_oom_reaper(current);\n\t\treturn true;\n\t}\n\n\t/*\n\t * The OOM killer does not compensate for IO-less reclaim.\n\t * pagefault_out_of_memory lost its gfp context so we have to\n\t * make sure exclude 0 mask - all other users should have at least\n\t * ___GFP_DIRECT_RECLAIM to get here.\n\t */\n\tif (oc->gfp_mask && !(oc->gfp_mask & __GFP_FS))\n\t\treturn true;\n\n\t/*\n\t * Check if there were limitations on the allocation (only relevant for\n\t * NUMA and memcg) that may require different handling.\n\t */\n\tconstraint = constrained_alloc(oc);\n\tif (constraint != CONSTRAINT_MEMORY_POLICY)\n\t\toc->nodemask = NULL;\n\tcheck_panic_on_oom(oc, constraint);\n\n\tif (!is_memcg_oom(oc) && sysctl_oom_kill_allocating_task &&\n\t    current->mm && !oom_unkillable_task(current, NULL, oc->nodemask) &&\n\t    current->signal->oom_score_adj != OOM_SCORE_ADJ_MIN) {\n\t\tget_task_struct(current);\n\t\toc->chosen = current;\n\t\toom_kill_process(oc, \"Out of memory (oom_kill_allocating_task)\");\n\t\treturn true;\n\t}\n\n\tselect_bad_process(oc);\n\t/* Found nothing?!?! */\n\tif (!oc->chosen) {\n\t\tdump_header(oc, NULL);\n\t\tpr_warn(\"Out of memory and no killable processes...\\n\");\n\t\t/*\n\t\t * If we got here due to an actual allocation at the\n\t\t * system level, we cannot survive this and will enter\n\t\t * an endless loop in the allocator. Bail out now.\n\t\t */\n\t\tif (!is_sysrq_oom(oc) && !is_memcg_oom(oc))\n\t\t\tpanic(\"System is deadlocked on memory\\n\");\n\t}\n\tif (oc->chosen && oc->chosen != (void *)-1UL)\n\t\toom_kill_process(oc, !is_memcg_oom(oc) ? \"Out of memory\" :\n\t\t\t\t \"Memory cgroup out of memory\");\n\treturn !!oc->chosen;\n}",
          "includes": [
            "#include <trace/events/oom.h>",
            "#include \"slab.h\"",
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/timex.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/oom.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int sysctl_oom_kill_allocating_task;",
            "static bool oom_killer_disabled",
            "static BLOCKING_NOTIFIER_HEAD(oom_notify_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nint sysctl_oom_kill_allocating_task;\nstatic bool oom_killer_disabled;\nstatic BLOCKING_NOTIFIER_HEAD(oom_notify_list);\n\nbool out_of_memory(struct oom_control *oc)\n{\n\tunsigned long freed = 0;\n\tenum oom_constraint constraint = CONSTRAINT_NONE;\n\n\tif (oom_killer_disabled)\n\t\treturn false;\n\n\tif (!is_memcg_oom(oc)) {\n\t\tblocking_notifier_call_chain(&oom_notify_list, 0, &freed);\n\t\tif (freed > 0)\n\t\t\t/* Got some memory back in the last second. */\n\t\t\treturn true;\n\t}\n\n\t/*\n\t * If current has a pending SIGKILL or is exiting, then automatically\n\t * select it.  The goal is to allow it to allocate so that it may\n\t * quickly exit and free its memory.\n\t */\n\tif (task_will_free_mem(current)) {\n\t\tmark_oom_victim(current);\n\t\twake_oom_reaper(current);\n\t\treturn true;\n\t}\n\n\t/*\n\t * The OOM killer does not compensate for IO-less reclaim.\n\t * pagefault_out_of_memory lost its gfp context so we have to\n\t * make sure exclude 0 mask - all other users should have at least\n\t * ___GFP_DIRECT_RECLAIM to get here.\n\t */\n\tif (oc->gfp_mask && !(oc->gfp_mask & __GFP_FS))\n\t\treturn true;\n\n\t/*\n\t * Check if there were limitations on the allocation (only relevant for\n\t * NUMA and memcg) that may require different handling.\n\t */\n\tconstraint = constrained_alloc(oc);\n\tif (constraint != CONSTRAINT_MEMORY_POLICY)\n\t\toc->nodemask = NULL;\n\tcheck_panic_on_oom(oc, constraint);\n\n\tif (!is_memcg_oom(oc) && sysctl_oom_kill_allocating_task &&\n\t    current->mm && !oom_unkillable_task(current, NULL, oc->nodemask) &&\n\t    current->signal->oom_score_adj != OOM_SCORE_ADJ_MIN) {\n\t\tget_task_struct(current);\n\t\toc->chosen = current;\n\t\toom_kill_process(oc, \"Out of memory (oom_kill_allocating_task)\");\n\t\treturn true;\n\t}\n\n\tselect_bad_process(oc);\n\t/* Found nothing?!?! */\n\tif (!oc->chosen) {\n\t\tdump_header(oc, NULL);\n\t\tpr_warn(\"Out of memory and no killable processes...\\n\");\n\t\t/*\n\t\t * If we got here due to an actual allocation at the\n\t\t * system level, we cannot survive this and will enter\n\t\t * an endless loop in the allocator. Bail out now.\n\t\t */\n\t\tif (!is_sysrq_oom(oc) && !is_memcg_oom(oc))\n\t\t\tpanic(\"System is deadlocked on memory\\n\");\n\t}\n\tif (oc->chosen && oc->chosen != (void *)-1UL)\n\t\toom_kill_process(oc, !is_memcg_oom(oc) ? \"Out of memory\" :\n\t\t\t\t \"Memory cgroup out of memory\");\n\treturn !!oc->chosen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_trylock",
          "args": [
            "&oom_lock"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_oom_synchronize",
          "args": [
            "true"
          ],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_oom_synchronize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1726-1777",
          "snippet": "bool mem_cgroup_oom_synchronize(bool handle)\n{\n\tstruct mem_cgroup *memcg = current->memcg_in_oom;\n\tstruct oom_wait_info owait;\n\tbool locked;\n\n\t/* OOM is global, do not handle */\n\tif (!memcg)\n\t\treturn false;\n\n\tif (!handle)\n\t\tgoto cleanup;\n\n\towait.memcg = memcg;\n\towait.wait.flags = 0;\n\towait.wait.func = memcg_oom_wake_function;\n\towait.wait.private = current;\n\tINIT_LIST_HEAD(&owait.wait.entry);\n\n\tprepare_to_wait(&memcg_oom_waitq, &owait.wait, TASK_KILLABLE);\n\tmem_cgroup_mark_under_oom(memcg);\n\n\tlocked = mem_cgroup_oom_trylock(memcg);\n\n\tif (locked)\n\t\tmem_cgroup_oom_notify(memcg);\n\n\tif (locked && !memcg->oom_kill_disable) {\n\t\tmem_cgroup_unmark_under_oom(memcg);\n\t\tfinish_wait(&memcg_oom_waitq, &owait.wait);\n\t\tmem_cgroup_out_of_memory(memcg, current->memcg_oom_gfp_mask,\n\t\t\t\t\t current->memcg_oom_order);\n\t} else {\n\t\tschedule();\n\t\tmem_cgroup_unmark_under_oom(memcg);\n\t\tfinish_wait(&memcg_oom_waitq, &owait.wait);\n\t}\n\n\tif (locked) {\n\t\tmem_cgroup_oom_unlock(memcg);\n\t\t/*\n\t\t * There is no guarantee that an OOM-lock contender\n\t\t * sees the wakeups triggered by the OOM kill\n\t\t * uncharges.  Wake any sleepers explicitely.\n\t\t */\n\t\tmemcg_oom_recover(memcg);\n\t}\ncleanup:\n\tcurrent->memcg_in_oom = NULL;\n\tcss_put(&memcg->css);\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct",
            "static DECLARE_WAIT_QUEUE_HEAD(memcg_oom_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstatic DECLARE_WAIT_QUEUE_HEAD(memcg_oom_waitq);\n\nbool mem_cgroup_oom_synchronize(bool handle)\n{\n\tstruct mem_cgroup *memcg = current->memcg_in_oom;\n\tstruct oom_wait_info owait;\n\tbool locked;\n\n\t/* OOM is global, do not handle */\n\tif (!memcg)\n\t\treturn false;\n\n\tif (!handle)\n\t\tgoto cleanup;\n\n\towait.memcg = memcg;\n\towait.wait.flags = 0;\n\towait.wait.func = memcg_oom_wake_function;\n\towait.wait.private = current;\n\tINIT_LIST_HEAD(&owait.wait.entry);\n\n\tprepare_to_wait(&memcg_oom_waitq, &owait.wait, TASK_KILLABLE);\n\tmem_cgroup_mark_under_oom(memcg);\n\n\tlocked = mem_cgroup_oom_trylock(memcg);\n\n\tif (locked)\n\t\tmem_cgroup_oom_notify(memcg);\n\n\tif (locked && !memcg->oom_kill_disable) {\n\t\tmem_cgroup_unmark_under_oom(memcg);\n\t\tfinish_wait(&memcg_oom_waitq, &owait.wait);\n\t\tmem_cgroup_out_of_memory(memcg, current->memcg_oom_gfp_mask,\n\t\t\t\t\t current->memcg_oom_order);\n\t} else {\n\t\tschedule();\n\t\tmem_cgroup_unmark_under_oom(memcg);\n\t\tfinish_wait(&memcg_oom_waitq, &owait.wait);\n\t}\n\n\tif (locked) {\n\t\tmem_cgroup_oom_unlock(memcg);\n\t\t/*\n\t\t * There is no guarantee that an OOM-lock contender\n\t\t * sees the wakeups triggered by the OOM kill\n\t\t * uncharges.  Wake any sleepers explicitely.\n\t\t */\n\t\tmemcg_oom_recover(memcg);\n\t}\ncleanup:\n\tcurrent->memcg_in_oom = NULL;\n\tcss_put(&memcg->css);\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nvoid pagefault_out_of_memory(void)\n{\n\tstruct oom_control oc = {\n\t\t.zonelist = NULL,\n\t\t.nodemask = NULL,\n\t\t.memcg = NULL,\n\t\t.gfp_mask = 0,\n\t\t.order = 0,\n\t};\n\n\tif (mem_cgroup_oom_synchronize(true))\n\t\treturn;\n\n\tif (!mutex_trylock(&oom_lock))\n\t\treturn;\n\tout_of_memory(&oc);\n\tmutex_unlock(&oom_lock);\n}"
  },
  {
    "function_name": "out_of_memory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
    "lines": "1053-1123",
    "snippet": "bool out_of_memory(struct oom_control *oc)\n{\n\tunsigned long freed = 0;\n\tenum oom_constraint constraint = CONSTRAINT_NONE;\n\n\tif (oom_killer_disabled)\n\t\treturn false;\n\n\tif (!is_memcg_oom(oc)) {\n\t\tblocking_notifier_call_chain(&oom_notify_list, 0, &freed);\n\t\tif (freed > 0)\n\t\t\t/* Got some memory back in the last second. */\n\t\t\treturn true;\n\t}\n\n\t/*\n\t * If current has a pending SIGKILL or is exiting, then automatically\n\t * select it.  The goal is to allow it to allocate so that it may\n\t * quickly exit and free its memory.\n\t */\n\tif (task_will_free_mem(current)) {\n\t\tmark_oom_victim(current);\n\t\twake_oom_reaper(current);\n\t\treturn true;\n\t}\n\n\t/*\n\t * The OOM killer does not compensate for IO-less reclaim.\n\t * pagefault_out_of_memory lost its gfp context so we have to\n\t * make sure exclude 0 mask - all other users should have at least\n\t * ___GFP_DIRECT_RECLAIM to get here.\n\t */\n\tif (oc->gfp_mask && !(oc->gfp_mask & __GFP_FS))\n\t\treturn true;\n\n\t/*\n\t * Check if there were limitations on the allocation (only relevant for\n\t * NUMA and memcg) that may require different handling.\n\t */\n\tconstraint = constrained_alloc(oc);\n\tif (constraint != CONSTRAINT_MEMORY_POLICY)\n\t\toc->nodemask = NULL;\n\tcheck_panic_on_oom(oc, constraint);\n\n\tif (!is_memcg_oom(oc) && sysctl_oom_kill_allocating_task &&\n\t    current->mm && !oom_unkillable_task(current, NULL, oc->nodemask) &&\n\t    current->signal->oom_score_adj != OOM_SCORE_ADJ_MIN) {\n\t\tget_task_struct(current);\n\t\toc->chosen = current;\n\t\toom_kill_process(oc, \"Out of memory (oom_kill_allocating_task)\");\n\t\treturn true;\n\t}\n\n\tselect_bad_process(oc);\n\t/* Found nothing?!?! */\n\tif (!oc->chosen) {\n\t\tdump_header(oc, NULL);\n\t\tpr_warn(\"Out of memory and no killable processes...\\n\");\n\t\t/*\n\t\t * If we got here due to an actual allocation at the\n\t\t * system level, we cannot survive this and will enter\n\t\t * an endless loop in the allocator. Bail out now.\n\t\t */\n\t\tif (!is_sysrq_oom(oc) && !is_memcg_oom(oc))\n\t\t\tpanic(\"System is deadlocked on memory\\n\");\n\t}\n\tif (oc->chosen && oc->chosen != (void *)-1UL)\n\t\toom_kill_process(oc, !is_memcg_oom(oc) ? \"Out of memory\" :\n\t\t\t\t \"Memory cgroup out of memory\");\n\treturn !!oc->chosen;\n}",
    "includes": [
      "#include <trace/events/oom.h>",
      "#include \"slab.h\"",
      "#include \"internal.h\"",
      "#include <asm/tlb.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/timex.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/oom.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int sysctl_oom_kill_allocating_task;",
      "static bool oom_killer_disabled",
      "static BLOCKING_NOTIFIER_HEAD(oom_notify_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "oom_kill_process",
          "args": [
            "oc",
            "!is_memcg_oom(oc) ? \"Out of memory\" :\n\t\t\t\t \"Memory cgroup out of memory\""
          ],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "oom_kill_process",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
          "lines": "925-1003",
          "snippet": "static void oom_kill_process(struct oom_control *oc, const char *message)\n{\n\tstruct task_struct *p = oc->chosen;\n\tunsigned int points = oc->chosen_points;\n\tstruct task_struct *victim = p;\n\tstruct task_struct *child;\n\tstruct task_struct *t;\n\tstruct mem_cgroup *oom_group;\n\tunsigned int victim_points = 0;\n\tstatic DEFINE_RATELIMIT_STATE(oom_rs, DEFAULT_RATELIMIT_INTERVAL,\n\t\t\t\t\t      DEFAULT_RATELIMIT_BURST);\n\n\t/*\n\t * If the task is already exiting, don't alarm the sysadmin or kill\n\t * its children or threads, just give it access to memory reserves\n\t * so it can die quickly\n\t */\n\ttask_lock(p);\n\tif (task_will_free_mem(p)) {\n\t\tmark_oom_victim(p);\n\t\twake_oom_reaper(p);\n\t\ttask_unlock(p);\n\t\tput_task_struct(p);\n\t\treturn;\n\t}\n\ttask_unlock(p);\n\n\tif (__ratelimit(&oom_rs))\n\t\tdump_header(oc, p);\n\n\tpr_err(\"%s: Kill process %d (%s) score %u or sacrifice child\\n\",\n\t\tmessage, task_pid_nr(p), p->comm, points);\n\n\t/*\n\t * If any of p's children has a different mm and is eligible for kill,\n\t * the one with the highest oom_badness() score is sacrificed for its\n\t * parent.  This attempts to lose the minimal amount of work done while\n\t * still freeing memory.\n\t */\n\tread_lock(&tasklist_lock);\n\tfor_each_thread(p, t) {\n\t\tlist_for_each_entry(child, &t->children, sibling) {\n\t\t\tunsigned int child_points;\n\n\t\t\tif (process_shares_mm(child, p->mm))\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * oom_badness() returns 0 if the thread is unkillable\n\t\t\t */\n\t\t\tchild_points = oom_badness(child,\n\t\t\t\toc->memcg, oc->nodemask, oc->totalpages);\n\t\t\tif (child_points > victim_points) {\n\t\t\t\tput_task_struct(victim);\n\t\t\t\tvictim = child;\n\t\t\t\tvictim_points = child_points;\n\t\t\t\tget_task_struct(victim);\n\t\t\t}\n\t\t}\n\t}\n\tread_unlock(&tasklist_lock);\n\n\t/*\n\t * Do we need to kill the entire memory cgroup?\n\t * Or even one of the ancestor memory cgroups?\n\t * Check this out before killing the victim task.\n\t */\n\toom_group = mem_cgroup_get_oom_group(victim, oc->memcg);\n\n\t__oom_kill_process(victim);\n\n\t/*\n\t * If necessary, kill all tasks in the selected memory cgroup.\n\t */\n\tif (oom_group) {\n\t\tmem_cgroup_print_oom_group(oom_group);\n\t\tmem_cgroup_scan_tasks(oom_group, oom_kill_memcg_member, NULL);\n\t\tmem_cgroup_put(oom_group);\n\t}\n}",
          "includes": [
            "#include <trace/events/oom.h>",
            "#include \"slab.h\"",
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/timex.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/oom.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstatic void oom_kill_process(struct oom_control *oc, const char *message)\n{\n\tstruct task_struct *p = oc->chosen;\n\tunsigned int points = oc->chosen_points;\n\tstruct task_struct *victim = p;\n\tstruct task_struct *child;\n\tstruct task_struct *t;\n\tstruct mem_cgroup *oom_group;\n\tunsigned int victim_points = 0;\n\tstatic DEFINE_RATELIMIT_STATE(oom_rs, DEFAULT_RATELIMIT_INTERVAL,\n\t\t\t\t\t      DEFAULT_RATELIMIT_BURST);\n\n\t/*\n\t * If the task is already exiting, don't alarm the sysadmin or kill\n\t * its children or threads, just give it access to memory reserves\n\t * so it can die quickly\n\t */\n\ttask_lock(p);\n\tif (task_will_free_mem(p)) {\n\t\tmark_oom_victim(p);\n\t\twake_oom_reaper(p);\n\t\ttask_unlock(p);\n\t\tput_task_struct(p);\n\t\treturn;\n\t}\n\ttask_unlock(p);\n\n\tif (__ratelimit(&oom_rs))\n\t\tdump_header(oc, p);\n\n\tpr_err(\"%s: Kill process %d (%s) score %u or sacrifice child\\n\",\n\t\tmessage, task_pid_nr(p), p->comm, points);\n\n\t/*\n\t * If any of p's children has a different mm and is eligible for kill,\n\t * the one with the highest oom_badness() score is sacrificed for its\n\t * parent.  This attempts to lose the minimal amount of work done while\n\t * still freeing memory.\n\t */\n\tread_lock(&tasklist_lock);\n\tfor_each_thread(p, t) {\n\t\tlist_for_each_entry(child, &t->children, sibling) {\n\t\t\tunsigned int child_points;\n\n\t\t\tif (process_shares_mm(child, p->mm))\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * oom_badness() returns 0 if the thread is unkillable\n\t\t\t */\n\t\t\tchild_points = oom_badness(child,\n\t\t\t\toc->memcg, oc->nodemask, oc->totalpages);\n\t\t\tif (child_points > victim_points) {\n\t\t\t\tput_task_struct(victim);\n\t\t\t\tvictim = child;\n\t\t\t\tvictim_points = child_points;\n\t\t\t\tget_task_struct(victim);\n\t\t\t}\n\t\t}\n\t}\n\tread_unlock(&tasklist_lock);\n\n\t/*\n\t * Do we need to kill the entire memory cgroup?\n\t * Or even one of the ancestor memory cgroups?\n\t * Check this out before killing the victim task.\n\t */\n\toom_group = mem_cgroup_get_oom_group(victim, oc->memcg);\n\n\t__oom_kill_process(victim);\n\n\t/*\n\t * If necessary, kill all tasks in the selected memory cgroup.\n\t */\n\tif (oom_group) {\n\t\tmem_cgroup_print_oom_group(oom_group);\n\t\tmem_cgroup_scan_tasks(oom_group, oom_kill_memcg_member, NULL);\n\t\tmem_cgroup_put(oom_group);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_memcg_oom",
          "args": [
            "oc"
          ],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "is_memcg_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
          "lines": "148-151",
          "snippet": "static inline bool is_memcg_oom(struct oom_control *oc)\n{\n\treturn oc->memcg != NULL;\n}",
          "includes": [
            "#include <trace/events/oom.h>",
            "#include \"slab.h\"",
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/timex.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/oom.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstatic inline bool is_memcg_oom(struct oom_control *oc)\n{\n\treturn oc->memcg != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"System is deadlocked on memory\\n\""
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_sysrq_oom",
          "args": [
            "oc"
          ],
          "line": 1116
        },
        "resolved": true,
        "details": {
          "function_name": "is_sysrq_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
          "lines": "143-146",
          "snippet": "static inline bool is_sysrq_oom(struct oom_control *oc)\n{\n\treturn oc->order == -1;\n}",
          "includes": [
            "#include <trace/events/oom.h>",
            "#include \"slab.h\"",
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/timex.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/oom.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstatic inline bool is_sysrq_oom(struct oom_control *oc)\n{\n\treturn oc->order == -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Out of memory and no killable processes...\\n\""
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_header",
          "args": [
            "oc",
            "NULL"
          ],
          "line": 1109
        },
        "resolved": true,
        "details": {
          "function_name": "dump_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
          "lines": "431-451",
          "snippet": "static void dump_header(struct oom_control *oc, struct task_struct *p)\n{\n\tpr_warn(\"%s invoked oom-killer: gfp_mask=%#x(%pGg), nodemask=%*pbl, order=%d, oom_score_adj=%hd\\n\",\n\t\tcurrent->comm, oc->gfp_mask, &oc->gfp_mask,\n\t\tnodemask_pr_args(oc->nodemask), oc->order,\n\t\t\tcurrent->signal->oom_score_adj);\n\tif (!IS_ENABLED(CONFIG_COMPACTION) && oc->order)\n\t\tpr_warn(\"COMPACTION is disabled!!!\\n\");\n\n\tcpuset_print_current_mems_allowed();\n\tdump_stack();\n\tif (is_memcg_oom(oc))\n\t\tmem_cgroup_print_oom_info(oc->memcg, p);\n\telse {\n\t\tshow_mem(SHOW_MEM_FILTER_NODES, oc->nodemask);\n\t\tif (is_dump_unreclaim_slabs())\n\t\t\tdump_unreclaimable_slab();\n\t}\n\tif (sysctl_oom_dump_tasks)\n\t\tdump_tasks(oc->memcg, oc->nodemask);\n}",
          "includes": [
            "#include <trace/events/oom.h>",
            "#include \"slab.h\"",
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/timex.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/oom.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int sysctl_oom_dump_tasks = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nint sysctl_oom_dump_tasks = 1;\n\nstatic void dump_header(struct oom_control *oc, struct task_struct *p)\n{\n\tpr_warn(\"%s invoked oom-killer: gfp_mask=%#x(%pGg), nodemask=%*pbl, order=%d, oom_score_adj=%hd\\n\",\n\t\tcurrent->comm, oc->gfp_mask, &oc->gfp_mask,\n\t\tnodemask_pr_args(oc->nodemask), oc->order,\n\t\t\tcurrent->signal->oom_score_adj);\n\tif (!IS_ENABLED(CONFIG_COMPACTION) && oc->order)\n\t\tpr_warn(\"COMPACTION is disabled!!!\\n\");\n\n\tcpuset_print_current_mems_allowed();\n\tdump_stack();\n\tif (is_memcg_oom(oc))\n\t\tmem_cgroup_print_oom_info(oc->memcg, p);\n\telse {\n\t\tshow_mem(SHOW_MEM_FILTER_NODES, oc->nodemask);\n\t\tif (is_dump_unreclaim_slabs())\n\t\t\tdump_unreclaimable_slab();\n\t}\n\tif (sysctl_oom_dump_tasks)\n\t\tdump_tasks(oc->memcg, oc->nodemask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "select_bad_process",
          "args": [
            "oc"
          ],
          "line": 1106
        },
        "resolved": true,
        "details": {
          "function_name": "select_bad_process",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
          "lines": "370-385",
          "snippet": "static void select_bad_process(struct oom_control *oc)\n{\n\tif (is_memcg_oom(oc))\n\t\tmem_cgroup_scan_tasks(oc->memcg, oom_evaluate_task, oc);\n\telse {\n\t\tstruct task_struct *p;\n\n\t\trcu_read_lock();\n\t\tfor_each_process(p)\n\t\t\tif (oom_evaluate_task(p, oc))\n\t\t\t\tbreak;\n\t\trcu_read_unlock();\n\t}\n\n\toc->chosen_points = oc->chosen_points * 1000 / oc->totalpages;\n}",
          "includes": [
            "#include <trace/events/oom.h>",
            "#include \"slab.h\"",
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/timex.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/oom.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstatic void select_bad_process(struct oom_control *oc)\n{\n\tif (is_memcg_oom(oc))\n\t\tmem_cgroup_scan_tasks(oc->memcg, oom_evaluate_task, oc);\n\telse {\n\t\tstruct task_struct *p;\n\n\t\trcu_read_lock();\n\t\tfor_each_process(p)\n\t\t\tif (oom_evaluate_task(p, oc))\n\t\t\t\tbreak;\n\t\trcu_read_unlock();\n\t}\n\n\toc->chosen_points = oc->chosen_points * 1000 / oc->totalpages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_task_struct",
          "args": [
            "current"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oom_unkillable_task",
          "args": [
            "current",
            "NULL",
            "oc->nodemask"
          ],
          "line": 1098
        },
        "resolved": true,
        "details": {
          "function_name": "oom_unkillable_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
          "lines": "154-171",
          "snippet": "static bool oom_unkillable_task(struct task_struct *p,\n\t\tstruct mem_cgroup *memcg, const nodemask_t *nodemask)\n{\n\tif (is_global_init(p))\n\t\treturn true;\n\tif (p->flags & PF_KTHREAD)\n\t\treturn true;\n\n\t/* When mem_cgroup_out_of_memory() and p is not member of the group */\n\tif (memcg && !task_in_mem_cgroup(p, memcg))\n\t\treturn true;\n\n\t/* p may not have freeable memory in nodemask */\n\tif (!has_intersects_mems_allowed(p, nodemask))\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/oom.h>",
            "#include \"slab.h\"",
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/timex.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/oom.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstatic bool oom_unkillable_task(struct task_struct *p,\n\t\tstruct mem_cgroup *memcg, const nodemask_t *nodemask)\n{\n\tif (is_global_init(p))\n\t\treturn true;\n\tif (p->flags & PF_KTHREAD)\n\t\treturn true;\n\n\t/* When mem_cgroup_out_of_memory() and p is not member of the group */\n\tif (memcg && !task_in_mem_cgroup(p, memcg))\n\t\treturn true;\n\n\t/* p may not have freeable memory in nodemask */\n\tif (!has_intersects_mems_allowed(p, nodemask))\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_panic_on_oom",
          "args": [
            "oc",
            "constraint"
          ],
          "line": 1095
        },
        "resolved": true,
        "details": {
          "function_name": "check_panic_on_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
          "lines": "1008-1028",
          "snippet": "static void check_panic_on_oom(struct oom_control *oc,\n\t\t\t       enum oom_constraint constraint)\n{\n\tif (likely(!sysctl_panic_on_oom))\n\t\treturn;\n\tif (sysctl_panic_on_oom != 2) {\n\t\t/*\n\t\t * panic_on_oom == 1 only affects CONSTRAINT_NONE, the kernel\n\t\t * does not panic for cpuset, mempolicy, or memcg allocation\n\t\t * failures.\n\t\t */\n\t\tif (constraint != CONSTRAINT_NONE)\n\t\t\treturn;\n\t}\n\t/* Do not panic for oom kills triggered by sysrq */\n\tif (is_sysrq_oom(oc))\n\t\treturn;\n\tdump_header(oc, NULL);\n\tpanic(\"Out of memory: %s panic_on_oom is enabled\\n\",\n\t\tsysctl_panic_on_oom == 2 ? \"compulsory\" : \"system-wide\");\n}",
          "includes": [
            "#include <trace/events/oom.h>",
            "#include \"slab.h\"",
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/timex.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/oom.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int sysctl_panic_on_oom;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nint sysctl_panic_on_oom;\n\nstatic void check_panic_on_oom(struct oom_control *oc,\n\t\t\t       enum oom_constraint constraint)\n{\n\tif (likely(!sysctl_panic_on_oom))\n\t\treturn;\n\tif (sysctl_panic_on_oom != 2) {\n\t\t/*\n\t\t * panic_on_oom == 1 only affects CONSTRAINT_NONE, the kernel\n\t\t * does not panic for cpuset, mempolicy, or memcg allocation\n\t\t * failures.\n\t\t */\n\t\tif (constraint != CONSTRAINT_NONE)\n\t\t\treturn;\n\t}\n\t/* Do not panic for oom kills triggered by sysrq */\n\tif (is_sysrq_oom(oc))\n\t\treturn;\n\tdump_header(oc, NULL);\n\tpanic(\"Out of memory: %s panic_on_oom is enabled\\n\",\n\t\tsysctl_panic_on_oom == 2 ? \"compulsory\" : \"system-wide\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "constrained_alloc",
          "args": [
            "oc"
          ],
          "line": 1092
        },
        "resolved": true,
        "details": {
          "function_name": "constrained_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
          "lines": "258-313",
          "snippet": "static enum oom_constraint constrained_alloc(struct oom_control *oc)\n{\n\tstruct zone *zone;\n\tstruct zoneref *z;\n\tenum zone_type high_zoneidx = gfp_zone(oc->gfp_mask);\n\tbool cpuset_limited = false;\n\tint nid;\n\n\tif (is_memcg_oom(oc)) {\n\t\toc->totalpages = mem_cgroup_get_max(oc->memcg) ?: 1;\n\t\treturn CONSTRAINT_MEMCG;\n\t}\n\n\t/* Default to all available memory */\n\toc->totalpages = totalram_pages + total_swap_pages;\n\n\tif (!IS_ENABLED(CONFIG_NUMA))\n\t\treturn CONSTRAINT_NONE;\n\n\tif (!oc->zonelist)\n\t\treturn CONSTRAINT_NONE;\n\t/*\n\t * Reach here only when __GFP_NOFAIL is used. So, we should avoid\n\t * to kill current.We have to random task kill in this case.\n\t * Hopefully, CONSTRAINT_THISNODE...but no way to handle it, now.\n\t */\n\tif (oc->gfp_mask & __GFP_THISNODE)\n\t\treturn CONSTRAINT_NONE;\n\n\t/*\n\t * This is not a __GFP_THISNODE allocation, so a truncated nodemask in\n\t * the page allocator means a mempolicy is in effect.  Cpuset policy\n\t * is enforced in get_page_from_freelist().\n\t */\n\tif (oc->nodemask &&\n\t    !nodes_subset(node_states[N_MEMORY], *oc->nodemask)) {\n\t\toc->totalpages = total_swap_pages;\n\t\tfor_each_node_mask(nid, *oc->nodemask)\n\t\t\toc->totalpages += node_spanned_pages(nid);\n\t\treturn CONSTRAINT_MEMORY_POLICY;\n\t}\n\n\t/* Check this allocation failure is caused by cpuset's wall function */\n\tfor_each_zone_zonelist_nodemask(zone, z, oc->zonelist,\n\t\t\thigh_zoneidx, oc->nodemask)\n\t\tif (!cpuset_zone_allowed(zone, oc->gfp_mask))\n\t\t\tcpuset_limited = true;\n\n\tif (cpuset_limited) {\n\t\toc->totalpages = total_swap_pages;\n\t\tfor_each_node_mask(nid, cpuset_current_mems_allowed)\n\t\t\toc->totalpages += node_spanned_pages(nid);\n\t\treturn CONSTRAINT_CPUSET;\n\t}\n\treturn CONSTRAINT_NONE;\n}",
          "includes": [
            "#include <trace/events/oom.h>",
            "#include \"slab.h\"",
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/timex.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/oom.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstatic enum oom_constraint constrained_alloc(struct oom_control *oc)\n{\n\tstruct zone *zone;\n\tstruct zoneref *z;\n\tenum zone_type high_zoneidx = gfp_zone(oc->gfp_mask);\n\tbool cpuset_limited = false;\n\tint nid;\n\n\tif (is_memcg_oom(oc)) {\n\t\toc->totalpages = mem_cgroup_get_max(oc->memcg) ?: 1;\n\t\treturn CONSTRAINT_MEMCG;\n\t}\n\n\t/* Default to all available memory */\n\toc->totalpages = totalram_pages + total_swap_pages;\n\n\tif (!IS_ENABLED(CONFIG_NUMA))\n\t\treturn CONSTRAINT_NONE;\n\n\tif (!oc->zonelist)\n\t\treturn CONSTRAINT_NONE;\n\t/*\n\t * Reach here only when __GFP_NOFAIL is used. So, we should avoid\n\t * to kill current.We have to random task kill in this case.\n\t * Hopefully, CONSTRAINT_THISNODE...but no way to handle it, now.\n\t */\n\tif (oc->gfp_mask & __GFP_THISNODE)\n\t\treturn CONSTRAINT_NONE;\n\n\t/*\n\t * This is not a __GFP_THISNODE allocation, so a truncated nodemask in\n\t * the page allocator means a mempolicy is in effect.  Cpuset policy\n\t * is enforced in get_page_from_freelist().\n\t */\n\tif (oc->nodemask &&\n\t    !nodes_subset(node_states[N_MEMORY], *oc->nodemask)) {\n\t\toc->totalpages = total_swap_pages;\n\t\tfor_each_node_mask(nid, *oc->nodemask)\n\t\t\toc->totalpages += node_spanned_pages(nid);\n\t\treturn CONSTRAINT_MEMORY_POLICY;\n\t}\n\n\t/* Check this allocation failure is caused by cpuset's wall function */\n\tfor_each_zone_zonelist_nodemask(zone, z, oc->zonelist,\n\t\t\thigh_zoneidx, oc->nodemask)\n\t\tif (!cpuset_zone_allowed(zone, oc->gfp_mask))\n\t\t\tcpuset_limited = true;\n\n\tif (cpuset_limited) {\n\t\toc->totalpages = total_swap_pages;\n\t\tfor_each_node_mask(nid, cpuset_current_mems_allowed)\n\t\t\toc->totalpages += node_spanned_pages(nid);\n\t\treturn CONSTRAINT_CPUSET;\n\t}\n\treturn CONSTRAINT_NONE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_oom_reaper",
          "args": [
            "current"
          ],
          "line": 1075
        },
        "resolved": true,
        "details": {
          "function_name": "wake_oom_reaper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
          "lines": "658-660",
          "snippet": "static inline void wake_oom_reaper(struct task_struct *tsk)\n{\n}",
          "includes": [
            "#include <trace/events/oom.h>",
            "#include \"slab.h\"",
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/timex.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/oom.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstatic inline void wake_oom_reaper(struct task_struct *tsk)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_oom_victim",
          "args": [
            "current"
          ],
          "line": 1074
        },
        "resolved": true,
        "details": {
          "function_name": "mark_oom_victim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
          "lines": "673-697",
          "snippet": "static void mark_oom_victim(struct task_struct *tsk)\n{\n\tstruct mm_struct *mm = tsk->mm;\n\n\tWARN_ON(oom_killer_disabled);\n\t/* OOM killer might race with memcg OOM */\n\tif (test_and_set_tsk_thread_flag(tsk, TIF_MEMDIE))\n\t\treturn;\n\n\t/* oom_mm is bound to the signal struct life time. */\n\tif (!cmpxchg(&tsk->signal->oom_mm, NULL, mm)) {\n\t\tmmgrab(tsk->signal->oom_mm);\n\t\tset_bit(MMF_OOM_VICTIM, &mm->flags);\n\t}\n\n\t/*\n\t * Make sure that the task is woken up from uninterruptible sleep\n\t * if it is frozen because OOM killer wouldn't be able to free\n\t * any memory and livelock. freezing_slow_path will tell the freezer\n\t * that TIF_MEMDIE tasks should be ignored.\n\t */\n\t__thaw_task(tsk);\n\tatomic_inc(&oom_victims);\n\ttrace_mark_victim(tsk->pid);\n}",
          "includes": [
            "#include <trace/events/oom.h>",
            "#include \"slab.h\"",
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/timex.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/oom.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t oom_victims = ATOMIC_INIT(0);",
            "static bool oom_killer_disabled"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstatic atomic_t oom_victims = ATOMIC_INIT(0);\nstatic bool oom_killer_disabled;\n\nstatic void mark_oom_victim(struct task_struct *tsk)\n{\n\tstruct mm_struct *mm = tsk->mm;\n\n\tWARN_ON(oom_killer_disabled);\n\t/* OOM killer might race with memcg OOM */\n\tif (test_and_set_tsk_thread_flag(tsk, TIF_MEMDIE))\n\t\treturn;\n\n\t/* oom_mm is bound to the signal struct life time. */\n\tif (!cmpxchg(&tsk->signal->oom_mm, NULL, mm)) {\n\t\tmmgrab(tsk->signal->oom_mm);\n\t\tset_bit(MMF_OOM_VICTIM, &mm->flags);\n\t}\n\n\t/*\n\t * Make sure that the task is woken up from uninterruptible sleep\n\t * if it is frozen because OOM killer wouldn't be able to free\n\t * any memory and livelock. freezing_slow_path will tell the freezer\n\t * that TIF_MEMDIE tasks should be ignored.\n\t */\n\t__thaw_task(tsk);\n\tatomic_inc(&oom_victims);\n\ttrace_mark_victim(tsk->pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_will_free_mem",
          "args": [
            "current"
          ],
          "line": 1073
        },
        "resolved": true,
        "details": {
          "function_name": "task_will_free_mem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
          "lines": "786-831",
          "snippet": "static bool task_will_free_mem(struct task_struct *task)\n{\n\tstruct mm_struct *mm = task->mm;\n\tstruct task_struct *p;\n\tbool ret = true;\n\n\t/*\n\t * Skip tasks without mm because it might have passed its exit_mm and\n\t * exit_oom_victim. oom_reaper could have rescued that but do not rely\n\t * on that for now. We can consider find_lock_task_mm in future.\n\t */\n\tif (!mm)\n\t\treturn false;\n\n\tif (!__task_will_free_mem(task))\n\t\treturn false;\n\n\t/*\n\t * This task has already been drained by the oom reaper so there are\n\t * only small chances it will free some more\n\t */\n\tif (test_bit(MMF_OOM_SKIP, &mm->flags))\n\t\treturn false;\n\n\tif (atomic_read(&mm->mm_users) <= 1)\n\t\treturn true;\n\n\t/*\n\t * Make sure that all tasks which share the mm with the given tasks\n\t * are dying as well to make sure that a) nobody pins its mm and\n\t * b) the task is also reapable by the oom reaper.\n\t */\n\trcu_read_lock();\n\tfor_each_process(p) {\n\t\tif (!process_shares_mm(p, mm))\n\t\t\tcontinue;\n\t\tif (same_thread_group(task, p))\n\t\t\tcontinue;\n\t\tret = __task_will_free_mem(p);\n\t\tif (!ret)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/oom.h>",
            "#include \"slab.h\"",
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/timex.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/oom.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstatic bool task_will_free_mem(struct task_struct *task)\n{\n\tstruct mm_struct *mm = task->mm;\n\tstruct task_struct *p;\n\tbool ret = true;\n\n\t/*\n\t * Skip tasks without mm because it might have passed its exit_mm and\n\t * exit_oom_victim. oom_reaper could have rescued that but do not rely\n\t * on that for now. We can consider find_lock_task_mm in future.\n\t */\n\tif (!mm)\n\t\treturn false;\n\n\tif (!__task_will_free_mem(task))\n\t\treturn false;\n\n\t/*\n\t * This task has already been drained by the oom reaper so there are\n\t * only small chances it will free some more\n\t */\n\tif (test_bit(MMF_OOM_SKIP, &mm->flags))\n\t\treturn false;\n\n\tif (atomic_read(&mm->mm_users) <= 1)\n\t\treturn true;\n\n\t/*\n\t * Make sure that all tasks which share the mm with the given tasks\n\t * are dying as well to make sure that a) nobody pins its mm and\n\t * b) the task is also reapable by the oom reaper.\n\t */\n\trcu_read_lock();\n\tfor_each_process(p) {\n\t\tif (!process_shares_mm(p, mm))\n\t\t\tcontinue;\n\t\tif (same_thread_group(task, p))\n\t\t\tcontinue;\n\t\tret = __task_will_free_mem(p);\n\t\tif (!ret)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "blocking_notifier_call_chain",
          "args": [
            "&oom_notify_list",
            "0",
            "&freed"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nint sysctl_oom_kill_allocating_task;\nstatic bool oom_killer_disabled;\nstatic BLOCKING_NOTIFIER_HEAD(oom_notify_list);\n\nbool out_of_memory(struct oom_control *oc)\n{\n\tunsigned long freed = 0;\n\tenum oom_constraint constraint = CONSTRAINT_NONE;\n\n\tif (oom_killer_disabled)\n\t\treturn false;\n\n\tif (!is_memcg_oom(oc)) {\n\t\tblocking_notifier_call_chain(&oom_notify_list, 0, &freed);\n\t\tif (freed > 0)\n\t\t\t/* Got some memory back in the last second. */\n\t\t\treturn true;\n\t}\n\n\t/*\n\t * If current has a pending SIGKILL or is exiting, then automatically\n\t * select it.  The goal is to allow it to allocate so that it may\n\t * quickly exit and free its memory.\n\t */\n\tif (task_will_free_mem(current)) {\n\t\tmark_oom_victim(current);\n\t\twake_oom_reaper(current);\n\t\treturn true;\n\t}\n\n\t/*\n\t * The OOM killer does not compensate for IO-less reclaim.\n\t * pagefault_out_of_memory lost its gfp context so we have to\n\t * make sure exclude 0 mask - all other users should have at least\n\t * ___GFP_DIRECT_RECLAIM to get here.\n\t */\n\tif (oc->gfp_mask && !(oc->gfp_mask & __GFP_FS))\n\t\treturn true;\n\n\t/*\n\t * Check if there were limitations on the allocation (only relevant for\n\t * NUMA and memcg) that may require different handling.\n\t */\n\tconstraint = constrained_alloc(oc);\n\tif (constraint != CONSTRAINT_MEMORY_POLICY)\n\t\toc->nodemask = NULL;\n\tcheck_panic_on_oom(oc, constraint);\n\n\tif (!is_memcg_oom(oc) && sysctl_oom_kill_allocating_task &&\n\t    current->mm && !oom_unkillable_task(current, NULL, oc->nodemask) &&\n\t    current->signal->oom_score_adj != OOM_SCORE_ADJ_MIN) {\n\t\tget_task_struct(current);\n\t\toc->chosen = current;\n\t\toom_kill_process(oc, \"Out of memory (oom_kill_allocating_task)\");\n\t\treturn true;\n\t}\n\n\tselect_bad_process(oc);\n\t/* Found nothing?!?! */\n\tif (!oc->chosen) {\n\t\tdump_header(oc, NULL);\n\t\tpr_warn(\"Out of memory and no killable processes...\\n\");\n\t\t/*\n\t\t * If we got here due to an actual allocation at the\n\t\t * system level, we cannot survive this and will enter\n\t\t * an endless loop in the allocator. Bail out now.\n\t\t */\n\t\tif (!is_sysrq_oom(oc) && !is_memcg_oom(oc))\n\t\t\tpanic(\"System is deadlocked on memory\\n\");\n\t}\n\tif (oc->chosen && oc->chosen != (void *)-1UL)\n\t\toom_kill_process(oc, !is_memcg_oom(oc) ? \"Out of memory\" :\n\t\t\t\t \"Memory cgroup out of memory\");\n\treturn !!oc->chosen;\n}"
  },
  {
    "function_name": "unregister_oom_notifier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
    "lines": "1038-1041",
    "snippet": "int unregister_oom_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&oom_notify_list, nb);\n}",
    "includes": [
      "#include <trace/events/oom.h>",
      "#include \"slab.h\"",
      "#include \"internal.h\"",
      "#include <asm/tlb.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/timex.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/oom.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static BLOCKING_NOTIFIER_HEAD(oom_notify_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "blocking_notifier_chain_unregister",
          "args": [
            "&oom_notify_list",
            "nb"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstatic BLOCKING_NOTIFIER_HEAD(oom_notify_list);\n\nint unregister_oom_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&oom_notify_list, nb);\n}"
  },
  {
    "function_name": "register_oom_notifier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
    "lines": "1032-1035",
    "snippet": "int register_oom_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_register(&oom_notify_list, nb);\n}",
    "includes": [
      "#include <trace/events/oom.h>",
      "#include \"slab.h\"",
      "#include \"internal.h\"",
      "#include <asm/tlb.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/timex.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/oom.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static BLOCKING_NOTIFIER_HEAD(oom_notify_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "blocking_notifier_chain_register",
          "args": [
            "&oom_notify_list",
            "nb"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstatic BLOCKING_NOTIFIER_HEAD(oom_notify_list);\n\nint register_oom_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_register(&oom_notify_list, nb);\n}"
  },
  {
    "function_name": "check_panic_on_oom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
    "lines": "1008-1028",
    "snippet": "static void check_panic_on_oom(struct oom_control *oc,\n\t\t\t       enum oom_constraint constraint)\n{\n\tif (likely(!sysctl_panic_on_oom))\n\t\treturn;\n\tif (sysctl_panic_on_oom != 2) {\n\t\t/*\n\t\t * panic_on_oom == 1 only affects CONSTRAINT_NONE, the kernel\n\t\t * does not panic for cpuset, mempolicy, or memcg allocation\n\t\t * failures.\n\t\t */\n\t\tif (constraint != CONSTRAINT_NONE)\n\t\t\treturn;\n\t}\n\t/* Do not panic for oom kills triggered by sysrq */\n\tif (is_sysrq_oom(oc))\n\t\treturn;\n\tdump_header(oc, NULL);\n\tpanic(\"Out of memory: %s panic_on_oom is enabled\\n\",\n\t\tsysctl_panic_on_oom == 2 ? \"compulsory\" : \"system-wide\");\n}",
    "includes": [
      "#include <trace/events/oom.h>",
      "#include \"slab.h\"",
      "#include \"internal.h\"",
      "#include <asm/tlb.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/timex.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/oom.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int sysctl_panic_on_oom;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"Out of memory: %s panic_on_oom is enabled\\n\"",
            "sysctl_panic_on_oom == 2 ? \"compulsory\" : \"system-wide\""
          ],
          "line": 1026
        },
        "resolved": true,
        "details": {
          "function_name": "check_panic_on_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
          "lines": "1008-1028",
          "snippet": "static void check_panic_on_oom(struct oom_control *oc,\n\t\t\t       enum oom_constraint constraint)\n{\n\tif (likely(!sysctl_panic_on_oom))\n\t\treturn;\n\tif (sysctl_panic_on_oom != 2) {\n\t\t/*\n\t\t * panic_on_oom == 1 only affects CONSTRAINT_NONE, the kernel\n\t\t * does not panic for cpuset, mempolicy, or memcg allocation\n\t\t * failures.\n\t\t */\n\t\tif (constraint != CONSTRAINT_NONE)\n\t\t\treturn;\n\t}\n\t/* Do not panic for oom kills triggered by sysrq */\n\tif (is_sysrq_oom(oc))\n\t\treturn;\n\tdump_header(oc, NULL);\n\tpanic(\"Out of memory: %s panic_on_oom is enabled\\n\",\n\t\tsysctl_panic_on_oom == 2 ? \"compulsory\" : \"system-wide\");\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "dump_header",
          "args": [
            "oc",
            "NULL"
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "dump_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
          "lines": "431-451",
          "snippet": "static void dump_header(struct oom_control *oc, struct task_struct *p)\n{\n\tpr_warn(\"%s invoked oom-killer: gfp_mask=%#x(%pGg), nodemask=%*pbl, order=%d, oom_score_adj=%hd\\n\",\n\t\tcurrent->comm, oc->gfp_mask, &oc->gfp_mask,\n\t\tnodemask_pr_args(oc->nodemask), oc->order,\n\t\t\tcurrent->signal->oom_score_adj);\n\tif (!IS_ENABLED(CONFIG_COMPACTION) && oc->order)\n\t\tpr_warn(\"COMPACTION is disabled!!!\\n\");\n\n\tcpuset_print_current_mems_allowed();\n\tdump_stack();\n\tif (is_memcg_oom(oc))\n\t\tmem_cgroup_print_oom_info(oc->memcg, p);\n\telse {\n\t\tshow_mem(SHOW_MEM_FILTER_NODES, oc->nodemask);\n\t\tif (is_dump_unreclaim_slabs())\n\t\t\tdump_unreclaimable_slab();\n\t}\n\tif (sysctl_oom_dump_tasks)\n\t\tdump_tasks(oc->memcg, oc->nodemask);\n}",
          "includes": [
            "#include <trace/events/oom.h>",
            "#include \"slab.h\"",
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/timex.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/oom.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int sysctl_oom_dump_tasks = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nint sysctl_oom_dump_tasks = 1;\n\nstatic void dump_header(struct oom_control *oc, struct task_struct *p)\n{\n\tpr_warn(\"%s invoked oom-killer: gfp_mask=%#x(%pGg), nodemask=%*pbl, order=%d, oom_score_adj=%hd\\n\",\n\t\tcurrent->comm, oc->gfp_mask, &oc->gfp_mask,\n\t\tnodemask_pr_args(oc->nodemask), oc->order,\n\t\t\tcurrent->signal->oom_score_adj);\n\tif (!IS_ENABLED(CONFIG_COMPACTION) && oc->order)\n\t\tpr_warn(\"COMPACTION is disabled!!!\\n\");\n\n\tcpuset_print_current_mems_allowed();\n\tdump_stack();\n\tif (is_memcg_oom(oc))\n\t\tmem_cgroup_print_oom_info(oc->memcg, p);\n\telse {\n\t\tshow_mem(SHOW_MEM_FILTER_NODES, oc->nodemask);\n\t\tif (is_dump_unreclaim_slabs())\n\t\t\tdump_unreclaimable_slab();\n\t}\n\tif (sysctl_oom_dump_tasks)\n\t\tdump_tasks(oc->memcg, oc->nodemask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_sysrq_oom",
          "args": [
            "oc"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "is_sysrq_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
          "lines": "143-146",
          "snippet": "static inline bool is_sysrq_oom(struct oom_control *oc)\n{\n\treturn oc->order == -1;\n}",
          "includes": [
            "#include <trace/events/oom.h>",
            "#include \"slab.h\"",
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/timex.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/oom.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstatic inline bool is_sysrq_oom(struct oom_control *oc)\n{\n\treturn oc->order == -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!sysctl_panic_on_oom"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nint sysctl_panic_on_oom;\n\nstatic void check_panic_on_oom(struct oom_control *oc,\n\t\t\t       enum oom_constraint constraint)\n{\n\tif (likely(!sysctl_panic_on_oom))\n\t\treturn;\n\tif (sysctl_panic_on_oom != 2) {\n\t\t/*\n\t\t * panic_on_oom == 1 only affects CONSTRAINT_NONE, the kernel\n\t\t * does not panic for cpuset, mempolicy, or memcg allocation\n\t\t * failures.\n\t\t */\n\t\tif (constraint != CONSTRAINT_NONE)\n\t\t\treturn;\n\t}\n\t/* Do not panic for oom kills triggered by sysrq */\n\tif (is_sysrq_oom(oc))\n\t\treturn;\n\tdump_header(oc, NULL);\n\tpanic(\"Out of memory: %s panic_on_oom is enabled\\n\",\n\t\tsysctl_panic_on_oom == 2 ? \"compulsory\" : \"system-wide\");\n}"
  },
  {
    "function_name": "oom_kill_process",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
    "lines": "925-1003",
    "snippet": "static void oom_kill_process(struct oom_control *oc, const char *message)\n{\n\tstruct task_struct *p = oc->chosen;\n\tunsigned int points = oc->chosen_points;\n\tstruct task_struct *victim = p;\n\tstruct task_struct *child;\n\tstruct task_struct *t;\n\tstruct mem_cgroup *oom_group;\n\tunsigned int victim_points = 0;\n\tstatic DEFINE_RATELIMIT_STATE(oom_rs, DEFAULT_RATELIMIT_INTERVAL,\n\t\t\t\t\t      DEFAULT_RATELIMIT_BURST);\n\n\t/*\n\t * If the task is already exiting, don't alarm the sysadmin or kill\n\t * its children or threads, just give it access to memory reserves\n\t * so it can die quickly\n\t */\n\ttask_lock(p);\n\tif (task_will_free_mem(p)) {\n\t\tmark_oom_victim(p);\n\t\twake_oom_reaper(p);\n\t\ttask_unlock(p);\n\t\tput_task_struct(p);\n\t\treturn;\n\t}\n\ttask_unlock(p);\n\n\tif (__ratelimit(&oom_rs))\n\t\tdump_header(oc, p);\n\n\tpr_err(\"%s: Kill process %d (%s) score %u or sacrifice child\\n\",\n\t\tmessage, task_pid_nr(p), p->comm, points);\n\n\t/*\n\t * If any of p's children has a different mm and is eligible for kill,\n\t * the one with the highest oom_badness() score is sacrificed for its\n\t * parent.  This attempts to lose the minimal amount of work done while\n\t * still freeing memory.\n\t */\n\tread_lock(&tasklist_lock);\n\tfor_each_thread(p, t) {\n\t\tlist_for_each_entry(child, &t->children, sibling) {\n\t\t\tunsigned int child_points;\n\n\t\t\tif (process_shares_mm(child, p->mm))\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * oom_badness() returns 0 if the thread is unkillable\n\t\t\t */\n\t\t\tchild_points = oom_badness(child,\n\t\t\t\toc->memcg, oc->nodemask, oc->totalpages);\n\t\t\tif (child_points > victim_points) {\n\t\t\t\tput_task_struct(victim);\n\t\t\t\tvictim = child;\n\t\t\t\tvictim_points = child_points;\n\t\t\t\tget_task_struct(victim);\n\t\t\t}\n\t\t}\n\t}\n\tread_unlock(&tasklist_lock);\n\n\t/*\n\t * Do we need to kill the entire memory cgroup?\n\t * Or even one of the ancestor memory cgroups?\n\t * Check this out before killing the victim task.\n\t */\n\toom_group = mem_cgroup_get_oom_group(victim, oc->memcg);\n\n\t__oom_kill_process(victim);\n\n\t/*\n\t * If necessary, kill all tasks in the selected memory cgroup.\n\t */\n\tif (oom_group) {\n\t\tmem_cgroup_print_oom_group(oom_group);\n\t\tmem_cgroup_scan_tasks(oom_group, oom_kill_memcg_member, NULL);\n\t\tmem_cgroup_put(oom_group);\n\t}\n}",
    "includes": [
      "#include <trace/events/oom.h>",
      "#include \"slab.h\"",
      "#include \"internal.h\"",
      "#include <asm/tlb.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/timex.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/oom.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mem_cgroup_put",
          "args": [
            "oom_group"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_scan_tasks",
          "args": [
            "oom_group",
            "oom_kill_memcg_member",
            "NULL"
          ],
          "line": 1000
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_scan_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1067-1089",
          "snippet": "int mem_cgroup_scan_tasks(struct mem_cgroup *memcg,\n\t\t\t  int (*fn)(struct task_struct *, void *), void *arg)\n{\n\tstruct mem_cgroup *iter;\n\tint ret = 0;\n\n\tBUG_ON(memcg == root_mem_cgroup);\n\n\tfor_each_mem_cgroup_tree(iter, memcg) {\n\t\tstruct css_task_iter it;\n\t\tstruct task_struct *task;\n\n\t\tcss_task_iter_start(&iter->css, 0, &it);\n\t\twhile (!ret && (task = css_task_iter_next(&it)))\n\t\t\tret = fn(task, arg);\n\t\tcss_task_iter_end(&it);\n\t\tif (ret) {\n\t\t\tmem_cgroup_iter_break(memcg, iter);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mem_cgroup *root_mem_cgroup",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nint mem_cgroup_scan_tasks(struct mem_cgroup *memcg,\n\t\t\t  int (*fn)(struct task_struct *, void *), void *arg)\n{\n\tstruct mem_cgroup *iter;\n\tint ret = 0;\n\n\tBUG_ON(memcg == root_mem_cgroup);\n\n\tfor_each_mem_cgroup_tree(iter, memcg) {\n\t\tstruct css_task_iter it;\n\t\tstruct task_struct *task;\n\n\t\tcss_task_iter_start(&iter->css, 0, &it);\n\t\twhile (!ret && (task = css_task_iter_next(&it)))\n\t\t\tret = fn(task, arg);\n\t\tcss_task_iter_end(&it);\n\t\tif (ret) {\n\t\t\tmem_cgroup_iter_break(memcg, iter);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_print_oom_group",
          "args": [
            "oom_group"
          ],
          "line": 999
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_print_oom_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1828-1833",
          "snippet": "void mem_cgroup_print_oom_group(struct mem_cgroup *memcg)\n{\n\tpr_info(\"Tasks in \");\n\tpr_cont_cgroup_path(memcg->css.cgroup);\n\tpr_cont(\" are going to be killed due to memory.oom.group set\\n\");\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nvoid mem_cgroup_print_oom_group(struct mem_cgroup *memcg)\n{\n\tpr_info(\"Tasks in \");\n\tpr_cont_cgroup_path(memcg->css.cgroup);\n\tpr_cont(\" are going to be killed due to memory.oom.group set\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "__oom_kill_process",
          "args": [
            "victim"
          ],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "__oom_kill_process",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
          "lines": "833-909",
          "snippet": "static void __oom_kill_process(struct task_struct *victim)\n{\n\tstruct task_struct *p;\n\tstruct mm_struct *mm;\n\tbool can_oom_reap = true;\n\n\tp = find_lock_task_mm(victim);\n\tif (!p) {\n\t\tput_task_struct(victim);\n\t\treturn;\n\t} else if (victim != p) {\n\t\tget_task_struct(p);\n\t\tput_task_struct(victim);\n\t\tvictim = p;\n\t}\n\n\t/* Get a reference to safely compare mm after task_unlock(victim) */\n\tmm = victim->mm;\n\tmmgrab(mm);\n\n\t/* Raise event before sending signal: task reaper must see this */\n\tcount_vm_event(OOM_KILL);\n\tmemcg_memory_event_mm(mm, MEMCG_OOM_KILL);\n\n\t/*\n\t * We should send SIGKILL before granting access to memory reserves\n\t * in order to prevent the OOM victim from depleting the memory\n\t * reserves from the user space under its control.\n\t */\n\tdo_send_sig_info(SIGKILL, SEND_SIG_PRIV, victim, PIDTYPE_TGID);\n\tmark_oom_victim(victim);\n\tpr_err(\"Killed process %d (%s) total-vm:%lukB, anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\\n\",\n\t\ttask_pid_nr(victim), victim->comm, K(victim->mm->total_vm),\n\t\tK(get_mm_counter(victim->mm, MM_ANONPAGES)),\n\t\tK(get_mm_counter(victim->mm, MM_FILEPAGES)),\n\t\tK(get_mm_counter(victim->mm, MM_SHMEMPAGES)));\n\ttask_unlock(victim);\n\n\t/*\n\t * Kill all user processes sharing victim->mm in other thread groups, if\n\t * any.  They don't get access to memory reserves, though, to avoid\n\t * depletion of all memory.  This prevents mm->mmap_sem livelock when an\n\t * oom killed thread cannot exit because it requires the semaphore and\n\t * its contended by another thread trying to allocate memory itself.\n\t * That thread will now get access to memory reserves since it has a\n\t * pending fatal signal.\n\t */\n\trcu_read_lock();\n\tfor_each_process(p) {\n\t\tif (!process_shares_mm(p, mm))\n\t\t\tcontinue;\n\t\tif (same_thread_group(p, victim))\n\t\t\tcontinue;\n\t\tif (is_global_init(p)) {\n\t\t\tcan_oom_reap = false;\n\t\t\tset_bit(MMF_OOM_SKIP, &mm->flags);\n\t\t\tpr_info(\"oom killer %d (%s) has mm pinned by %d (%s)\\n\",\n\t\t\t\t\ttask_pid_nr(victim), victim->comm,\n\t\t\t\t\ttask_pid_nr(p), p->comm);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * No use_mm() user needs to read from the userspace so we are\n\t\t * ok to reap it.\n\t\t */\n\t\tif (unlikely(p->flags & PF_KTHREAD))\n\t\t\tcontinue;\n\t\tdo_send_sig_info(SIGKILL, SEND_SIG_PRIV, p, PIDTYPE_TGID);\n\t}\n\trcu_read_unlock();\n\n\tif (can_oom_reap)\n\t\twake_oom_reaper(victim);\n\n\tmmdrop(mm);\n\tput_task_struct(victim);\n}",
          "includes": [
            "#include <trace/events/oom.h>",
            "#include \"slab.h\"",
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/timex.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/oom.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstatic void __oom_kill_process(struct task_struct *victim)\n{\n\tstruct task_struct *p;\n\tstruct mm_struct *mm;\n\tbool can_oom_reap = true;\n\n\tp = find_lock_task_mm(victim);\n\tif (!p) {\n\t\tput_task_struct(victim);\n\t\treturn;\n\t} else if (victim != p) {\n\t\tget_task_struct(p);\n\t\tput_task_struct(victim);\n\t\tvictim = p;\n\t}\n\n\t/* Get a reference to safely compare mm after task_unlock(victim) */\n\tmm = victim->mm;\n\tmmgrab(mm);\n\n\t/* Raise event before sending signal: task reaper must see this */\n\tcount_vm_event(OOM_KILL);\n\tmemcg_memory_event_mm(mm, MEMCG_OOM_KILL);\n\n\t/*\n\t * We should send SIGKILL before granting access to memory reserves\n\t * in order to prevent the OOM victim from depleting the memory\n\t * reserves from the user space under its control.\n\t */\n\tdo_send_sig_info(SIGKILL, SEND_SIG_PRIV, victim, PIDTYPE_TGID);\n\tmark_oom_victim(victim);\n\tpr_err(\"Killed process %d (%s) total-vm:%lukB, anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\\n\",\n\t\ttask_pid_nr(victim), victim->comm, K(victim->mm->total_vm),\n\t\tK(get_mm_counter(victim->mm, MM_ANONPAGES)),\n\t\tK(get_mm_counter(victim->mm, MM_FILEPAGES)),\n\t\tK(get_mm_counter(victim->mm, MM_SHMEMPAGES)));\n\ttask_unlock(victim);\n\n\t/*\n\t * Kill all user processes sharing victim->mm in other thread groups, if\n\t * any.  They don't get access to memory reserves, though, to avoid\n\t * depletion of all memory.  This prevents mm->mmap_sem livelock when an\n\t * oom killed thread cannot exit because it requires the semaphore and\n\t * its contended by another thread trying to allocate memory itself.\n\t * That thread will now get access to memory reserves since it has a\n\t * pending fatal signal.\n\t */\n\trcu_read_lock();\n\tfor_each_process(p) {\n\t\tif (!process_shares_mm(p, mm))\n\t\t\tcontinue;\n\t\tif (same_thread_group(p, victim))\n\t\t\tcontinue;\n\t\tif (is_global_init(p)) {\n\t\t\tcan_oom_reap = false;\n\t\t\tset_bit(MMF_OOM_SKIP, &mm->flags);\n\t\t\tpr_info(\"oom killer %d (%s) has mm pinned by %d (%s)\\n\",\n\t\t\t\t\ttask_pid_nr(victim), victim->comm,\n\t\t\t\t\ttask_pid_nr(p), p->comm);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * No use_mm() user needs to read from the userspace so we are\n\t\t * ok to reap it.\n\t\t */\n\t\tif (unlikely(p->flags & PF_KTHREAD))\n\t\t\tcontinue;\n\t\tdo_send_sig_info(SIGKILL, SEND_SIG_PRIV, p, PIDTYPE_TGID);\n\t}\n\trcu_read_unlock();\n\n\tif (can_oom_reap)\n\t\twake_oom_reaper(victim);\n\n\tmmdrop(mm);\n\tput_task_struct(victim);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_get_oom_group",
          "args": [
            "victim",
            "oc->memcg"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_get_oom_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1789-1826",
          "snippet": "struct mem_cgroup *mem_cgroup_get_oom_group(struct task_struct *victim,\n\t\t\t\t\t    struct mem_cgroup *oom_domain)\n{\n\tstruct mem_cgroup *oom_group = NULL;\n\tstruct mem_cgroup *memcg;\n\n\tif (!cgroup_subsys_on_dfl(memory_cgrp_subsys))\n\t\treturn NULL;\n\n\tif (!oom_domain)\n\t\toom_domain = root_mem_cgroup;\n\n\trcu_read_lock();\n\n\tmemcg = mem_cgroup_from_task(victim);\n\tif (memcg == root_mem_cgroup)\n\t\tgoto out;\n\n\t/*\n\t * Traverse the memory cgroup hierarchy from the victim task's\n\t * cgroup up to the OOMing cgroup (or root) to find the\n\t * highest-level memory cgroup with oom.group set.\n\t */\n\tfor (; memcg; memcg = parent_mem_cgroup(memcg)) {\n\t\tif (memcg->oom_group)\n\t\t\toom_group = memcg;\n\n\t\tif (memcg == oom_domain)\n\t\t\tbreak;\n\t}\n\n\tif (oom_group)\n\t\tcss_get(&oom_group->css);\nout:\n\trcu_read_unlock();\n\n\treturn oom_group;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_subsys memory_cgrp_subsys",
            "struct mem_cgroup *root_mem_cgroup",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct",
            "struct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct cgroup_subsys memory_cgrp_subsys;\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstruct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};\n\nstruct mem_cgroup *mem_cgroup_get_oom_group(struct task_struct *victim,\n\t\t\t\t\t    struct mem_cgroup *oom_domain)\n{\n\tstruct mem_cgroup *oom_group = NULL;\n\tstruct mem_cgroup *memcg;\n\n\tif (!cgroup_subsys_on_dfl(memory_cgrp_subsys))\n\t\treturn NULL;\n\n\tif (!oom_domain)\n\t\toom_domain = root_mem_cgroup;\n\n\trcu_read_lock();\n\n\tmemcg = mem_cgroup_from_task(victim);\n\tif (memcg == root_mem_cgroup)\n\t\tgoto out;\n\n\t/*\n\t * Traverse the memory cgroup hierarchy from the victim task's\n\t * cgroup up to the OOMing cgroup (or root) to find the\n\t * highest-level memory cgroup with oom.group set.\n\t */\n\tfor (; memcg; memcg = parent_mem_cgroup(memcg)) {\n\t\tif (memcg->oom_group)\n\t\t\toom_group = memcg;\n\n\t\tif (memcg == oom_domain)\n\t\t\tbreak;\n\t}\n\n\tif (oom_group)\n\t\tcss_get(&oom_group->css);\nout:\n\trcu_read_unlock();\n\n\treturn oom_group;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zsmalloc.c",
          "lines": "1859-1862",
          "snippet": "static void migrate_read_unlock(struct zspage *zspage)\n{\n\tread_unlock(&zspage->lock);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mount.h>",
            "#include <linux/zpool.h>",
            "#include <linux/zsmalloc.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/types.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/highmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/bitops.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/migrate.h>\n#include <linux/mount.h>\n#include <linux/zpool.h>\n#include <linux/zsmalloc.h>\n#include <linux/debugfs.h>\n#include <linux/types.h>\n#include <linux/shrinker.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/vmalloc.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/highmem.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void migrate_read_unlock(struct zspage *zspage)\n{\n\tread_unlock(&zspage->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_task_struct",
          "args": [
            "victim"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "victim"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oom_badness",
          "args": [
            "child",
            "oc->memcg",
            "oc->nodemask",
            "oc->totalpages"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "oom_badness",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
          "lines": "203-246",
          "snippet": "unsigned long oom_badness(struct task_struct *p, struct mem_cgroup *memcg,\n\t\t\t  const nodemask_t *nodemask, unsigned long totalpages)\n{\n\tlong points;\n\tlong adj;\n\n\tif (oom_unkillable_task(p, memcg, nodemask))\n\t\treturn 0;\n\n\tp = find_lock_task_mm(p);\n\tif (!p)\n\t\treturn 0;\n\n\t/*\n\t * Do not even consider tasks which are explicitly marked oom\n\t * unkillable or have been already oom reaped or the are in\n\t * the middle of vfork\n\t */\n\tadj = (long)p->signal->oom_score_adj;\n\tif (adj == OOM_SCORE_ADJ_MIN ||\n\t\t\ttest_bit(MMF_OOM_SKIP, &p->mm->flags) ||\n\t\t\tin_vfork(p)) {\n\t\ttask_unlock(p);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * The baseline for the badness score is the proportion of RAM that each\n\t * task's rss, pagetable and swap space use.\n\t */\n\tpoints = get_mm_rss(p->mm) + get_mm_counter(p->mm, MM_SWAPENTS) +\n\t\tmm_pgtables_bytes(p->mm) / PAGE_SIZE;\n\ttask_unlock(p);\n\n\t/* Normalize to oom_score_adj units */\n\tadj *= totalpages / 1000;\n\tpoints += adj;\n\n\t/*\n\t * Never return 0 for an eligible task regardless of the root bonus and\n\t * oom_score_adj (oom_score_adj can't be OOM_SCORE_ADJ_MIN here).\n\t */\n\treturn points > 0 ? points : 1;\n}",
          "includes": [
            "#include <trace/events/oom.h>",
            "#include \"slab.h\"",
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/timex.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/oom.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nunsigned long oom_badness(struct task_struct *p, struct mem_cgroup *memcg,\n\t\t\t  const nodemask_t *nodemask, unsigned long totalpages)\n{\n\tlong points;\n\tlong adj;\n\n\tif (oom_unkillable_task(p, memcg, nodemask))\n\t\treturn 0;\n\n\tp = find_lock_task_mm(p);\n\tif (!p)\n\t\treturn 0;\n\n\t/*\n\t * Do not even consider tasks which are explicitly marked oom\n\t * unkillable or have been already oom reaped or the are in\n\t * the middle of vfork\n\t */\n\tadj = (long)p->signal->oom_score_adj;\n\tif (adj == OOM_SCORE_ADJ_MIN ||\n\t\t\ttest_bit(MMF_OOM_SKIP, &p->mm->flags) ||\n\t\t\tin_vfork(p)) {\n\t\ttask_unlock(p);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * The baseline for the badness score is the proportion of RAM that each\n\t * task's rss, pagetable and swap space use.\n\t */\n\tpoints = get_mm_rss(p->mm) + get_mm_counter(p->mm, MM_SWAPENTS) +\n\t\tmm_pgtables_bytes(p->mm) / PAGE_SIZE;\n\ttask_unlock(p);\n\n\t/* Normalize to oom_score_adj units */\n\tadj *= totalpages / 1000;\n\tpoints += adj;\n\n\t/*\n\t * Never return 0 for an eligible task regardless of the root bonus and\n\t * oom_score_adj (oom_score_adj can't be OOM_SCORE_ADJ_MIN here).\n\t */\n\treturn points > 0 ? points : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_shares_mm",
          "args": [
            "child",
            "p->mm"
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "process_shares_mm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
          "lines": "469-479",
          "snippet": "bool process_shares_mm(struct task_struct *p, struct mm_struct *mm)\n{\n\tstruct task_struct *t;\n\n\tfor_each_thread(p, t) {\n\t\tstruct mm_struct *t_mm = READ_ONCE(t->mm);\n\t\tif (t_mm)\n\t\t\treturn t_mm == mm;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/oom.h>",
            "#include \"slab.h\"",
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/timex.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/oom.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nbool process_shares_mm(struct task_struct *p, struct mm_struct *mm)\n{\n\tstruct task_struct *t;\n\n\tfor_each_thread(p, t) {\n\t\tstruct mm_struct *t_mm = READ_ONCE(t->mm);\n\t\tif (t_mm)\n\t\t\treturn t_mm == mm;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "child",
            "&t->children",
            "sibling"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_thread",
          "args": [
            "p",
            "t"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_read_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zsmalloc.c",
          "lines": "1854-1857",
          "snippet": "static void migrate_read_lock(struct zspage *zspage)\n{\n\tread_lock(&zspage->lock);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mount.h>",
            "#include <linux/zpool.h>",
            "#include <linux/zsmalloc.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/types.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/highmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/bitops.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/migrate.h>\n#include <linux/mount.h>\n#include <linux/zpool.h>\n#include <linux/zsmalloc.h>\n#include <linux/debugfs.h>\n#include <linux/types.h>\n#include <linux/shrinker.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/vmalloc.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/highmem.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void migrate_read_lock(struct zspage *zspage)\n{\n\tread_lock(&zspage->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: Kill process %d (%s) score %u or sacrifice child\\n\"",
            "message",
            "task_pid_nr(p)",
            "p->comm",
            "points"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "p"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_header",
          "args": [
            "oc",
            "p"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "dump_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
          "lines": "431-451",
          "snippet": "static void dump_header(struct oom_control *oc, struct task_struct *p)\n{\n\tpr_warn(\"%s invoked oom-killer: gfp_mask=%#x(%pGg), nodemask=%*pbl, order=%d, oom_score_adj=%hd\\n\",\n\t\tcurrent->comm, oc->gfp_mask, &oc->gfp_mask,\n\t\tnodemask_pr_args(oc->nodemask), oc->order,\n\t\t\tcurrent->signal->oom_score_adj);\n\tif (!IS_ENABLED(CONFIG_COMPACTION) && oc->order)\n\t\tpr_warn(\"COMPACTION is disabled!!!\\n\");\n\n\tcpuset_print_current_mems_allowed();\n\tdump_stack();\n\tif (is_memcg_oom(oc))\n\t\tmem_cgroup_print_oom_info(oc->memcg, p);\n\telse {\n\t\tshow_mem(SHOW_MEM_FILTER_NODES, oc->nodemask);\n\t\tif (is_dump_unreclaim_slabs())\n\t\t\tdump_unreclaimable_slab();\n\t}\n\tif (sysctl_oom_dump_tasks)\n\t\tdump_tasks(oc->memcg, oc->nodemask);\n}",
          "includes": [
            "#include <trace/events/oom.h>",
            "#include \"slab.h\"",
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/timex.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/oom.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int sysctl_oom_dump_tasks = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nint sysctl_oom_dump_tasks = 1;\n\nstatic void dump_header(struct oom_control *oc, struct task_struct *p)\n{\n\tpr_warn(\"%s invoked oom-killer: gfp_mask=%#x(%pGg), nodemask=%*pbl, order=%d, oom_score_adj=%hd\\n\",\n\t\tcurrent->comm, oc->gfp_mask, &oc->gfp_mask,\n\t\tnodemask_pr_args(oc->nodemask), oc->order,\n\t\t\tcurrent->signal->oom_score_adj);\n\tif (!IS_ENABLED(CONFIG_COMPACTION) && oc->order)\n\t\tpr_warn(\"COMPACTION is disabled!!!\\n\");\n\n\tcpuset_print_current_mems_allowed();\n\tdump_stack();\n\tif (is_memcg_oom(oc))\n\t\tmem_cgroup_print_oom_info(oc->memcg, p);\n\telse {\n\t\tshow_mem(SHOW_MEM_FILTER_NODES, oc->nodemask);\n\t\tif (is_dump_unreclaim_slabs())\n\t\t\tdump_unreclaimable_slab();\n\t}\n\tif (sysctl_oom_dump_tasks)\n\t\tdump_tasks(oc->memcg, oc->nodemask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ratelimit",
          "args": [
            "&oom_rs"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "p"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "p"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "p"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_oom_reaper",
          "args": [
            "p"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "wake_oom_reaper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
          "lines": "658-660",
          "snippet": "static inline void wake_oom_reaper(struct task_struct *tsk)\n{\n}",
          "includes": [
            "#include <trace/events/oom.h>",
            "#include \"slab.h\"",
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/timex.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/oom.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstatic inline void wake_oom_reaper(struct task_struct *tsk)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_oom_victim",
          "args": [
            "p"
          ],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "mark_oom_victim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
          "lines": "673-697",
          "snippet": "static void mark_oom_victim(struct task_struct *tsk)\n{\n\tstruct mm_struct *mm = tsk->mm;\n\n\tWARN_ON(oom_killer_disabled);\n\t/* OOM killer might race with memcg OOM */\n\tif (test_and_set_tsk_thread_flag(tsk, TIF_MEMDIE))\n\t\treturn;\n\n\t/* oom_mm is bound to the signal struct life time. */\n\tif (!cmpxchg(&tsk->signal->oom_mm, NULL, mm)) {\n\t\tmmgrab(tsk->signal->oom_mm);\n\t\tset_bit(MMF_OOM_VICTIM, &mm->flags);\n\t}\n\n\t/*\n\t * Make sure that the task is woken up from uninterruptible sleep\n\t * if it is frozen because OOM killer wouldn't be able to free\n\t * any memory and livelock. freezing_slow_path will tell the freezer\n\t * that TIF_MEMDIE tasks should be ignored.\n\t */\n\t__thaw_task(tsk);\n\tatomic_inc(&oom_victims);\n\ttrace_mark_victim(tsk->pid);\n}",
          "includes": [
            "#include <trace/events/oom.h>",
            "#include \"slab.h\"",
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/timex.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/oom.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t oom_victims = ATOMIC_INIT(0);",
            "static bool oom_killer_disabled"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstatic atomic_t oom_victims = ATOMIC_INIT(0);\nstatic bool oom_killer_disabled;\n\nstatic void mark_oom_victim(struct task_struct *tsk)\n{\n\tstruct mm_struct *mm = tsk->mm;\n\n\tWARN_ON(oom_killer_disabled);\n\t/* OOM killer might race with memcg OOM */\n\tif (test_and_set_tsk_thread_flag(tsk, TIF_MEMDIE))\n\t\treturn;\n\n\t/* oom_mm is bound to the signal struct life time. */\n\tif (!cmpxchg(&tsk->signal->oom_mm, NULL, mm)) {\n\t\tmmgrab(tsk->signal->oom_mm);\n\t\tset_bit(MMF_OOM_VICTIM, &mm->flags);\n\t}\n\n\t/*\n\t * Make sure that the task is woken up from uninterruptible sleep\n\t * if it is frozen because OOM killer wouldn't be able to free\n\t * any memory and livelock. freezing_slow_path will tell the freezer\n\t * that TIF_MEMDIE tasks should be ignored.\n\t */\n\t__thaw_task(tsk);\n\tatomic_inc(&oom_victims);\n\ttrace_mark_victim(tsk->pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_will_free_mem",
          "args": [
            "p"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "task_will_free_mem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
          "lines": "786-831",
          "snippet": "static bool task_will_free_mem(struct task_struct *task)\n{\n\tstruct mm_struct *mm = task->mm;\n\tstruct task_struct *p;\n\tbool ret = true;\n\n\t/*\n\t * Skip tasks without mm because it might have passed its exit_mm and\n\t * exit_oom_victim. oom_reaper could have rescued that but do not rely\n\t * on that for now. We can consider find_lock_task_mm in future.\n\t */\n\tif (!mm)\n\t\treturn false;\n\n\tif (!__task_will_free_mem(task))\n\t\treturn false;\n\n\t/*\n\t * This task has already been drained by the oom reaper so there are\n\t * only small chances it will free some more\n\t */\n\tif (test_bit(MMF_OOM_SKIP, &mm->flags))\n\t\treturn false;\n\n\tif (atomic_read(&mm->mm_users) <= 1)\n\t\treturn true;\n\n\t/*\n\t * Make sure that all tasks which share the mm with the given tasks\n\t * are dying as well to make sure that a) nobody pins its mm and\n\t * b) the task is also reapable by the oom reaper.\n\t */\n\trcu_read_lock();\n\tfor_each_process(p) {\n\t\tif (!process_shares_mm(p, mm))\n\t\t\tcontinue;\n\t\tif (same_thread_group(task, p))\n\t\t\tcontinue;\n\t\tret = __task_will_free_mem(p);\n\t\tif (!ret)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/oom.h>",
            "#include \"slab.h\"",
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/timex.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/oom.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstatic bool task_will_free_mem(struct task_struct *task)\n{\n\tstruct mm_struct *mm = task->mm;\n\tstruct task_struct *p;\n\tbool ret = true;\n\n\t/*\n\t * Skip tasks without mm because it might have passed its exit_mm and\n\t * exit_oom_victim. oom_reaper could have rescued that but do not rely\n\t * on that for now. We can consider find_lock_task_mm in future.\n\t */\n\tif (!mm)\n\t\treturn false;\n\n\tif (!__task_will_free_mem(task))\n\t\treturn false;\n\n\t/*\n\t * This task has already been drained by the oom reaper so there are\n\t * only small chances it will free some more\n\t */\n\tif (test_bit(MMF_OOM_SKIP, &mm->flags))\n\t\treturn false;\n\n\tif (atomic_read(&mm->mm_users) <= 1)\n\t\treturn true;\n\n\t/*\n\t * Make sure that all tasks which share the mm with the given tasks\n\t * are dying as well to make sure that a) nobody pins its mm and\n\t * b) the task is also reapable by the oom reaper.\n\t */\n\trcu_read_lock();\n\tfor_each_process(p) {\n\t\tif (!process_shares_mm(p, mm))\n\t\t\tcontinue;\n\t\tif (same_thread_group(task, p))\n\t\t\tcontinue;\n\t\tret = __task_will_free_mem(p);\n\t\tif (!ret)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_lock",
          "args": [
            "p"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstatic void oom_kill_process(struct oom_control *oc, const char *message)\n{\n\tstruct task_struct *p = oc->chosen;\n\tunsigned int points = oc->chosen_points;\n\tstruct task_struct *victim = p;\n\tstruct task_struct *child;\n\tstruct task_struct *t;\n\tstruct mem_cgroup *oom_group;\n\tunsigned int victim_points = 0;\n\tstatic DEFINE_RATELIMIT_STATE(oom_rs, DEFAULT_RATELIMIT_INTERVAL,\n\t\t\t\t\t      DEFAULT_RATELIMIT_BURST);\n\n\t/*\n\t * If the task is already exiting, don't alarm the sysadmin or kill\n\t * its children or threads, just give it access to memory reserves\n\t * so it can die quickly\n\t */\n\ttask_lock(p);\n\tif (task_will_free_mem(p)) {\n\t\tmark_oom_victim(p);\n\t\twake_oom_reaper(p);\n\t\ttask_unlock(p);\n\t\tput_task_struct(p);\n\t\treturn;\n\t}\n\ttask_unlock(p);\n\n\tif (__ratelimit(&oom_rs))\n\t\tdump_header(oc, p);\n\n\tpr_err(\"%s: Kill process %d (%s) score %u or sacrifice child\\n\",\n\t\tmessage, task_pid_nr(p), p->comm, points);\n\n\t/*\n\t * If any of p's children has a different mm and is eligible for kill,\n\t * the one with the highest oom_badness() score is sacrificed for its\n\t * parent.  This attempts to lose the minimal amount of work done while\n\t * still freeing memory.\n\t */\n\tread_lock(&tasklist_lock);\n\tfor_each_thread(p, t) {\n\t\tlist_for_each_entry(child, &t->children, sibling) {\n\t\t\tunsigned int child_points;\n\n\t\t\tif (process_shares_mm(child, p->mm))\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * oom_badness() returns 0 if the thread is unkillable\n\t\t\t */\n\t\t\tchild_points = oom_badness(child,\n\t\t\t\toc->memcg, oc->nodemask, oc->totalpages);\n\t\t\tif (child_points > victim_points) {\n\t\t\t\tput_task_struct(victim);\n\t\t\t\tvictim = child;\n\t\t\t\tvictim_points = child_points;\n\t\t\t\tget_task_struct(victim);\n\t\t\t}\n\t\t}\n\t}\n\tread_unlock(&tasklist_lock);\n\n\t/*\n\t * Do we need to kill the entire memory cgroup?\n\t * Or even one of the ancestor memory cgroups?\n\t * Check this out before killing the victim task.\n\t */\n\toom_group = mem_cgroup_get_oom_group(victim, oc->memcg);\n\n\t__oom_kill_process(victim);\n\n\t/*\n\t * If necessary, kill all tasks in the selected memory cgroup.\n\t */\n\tif (oom_group) {\n\t\tmem_cgroup_print_oom_group(oom_group);\n\t\tmem_cgroup_scan_tasks(oom_group, oom_kill_memcg_member, NULL);\n\t\tmem_cgroup_put(oom_group);\n\t}\n}"
  },
  {
    "function_name": "oom_kill_memcg_member",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
    "lines": "916-923",
    "snippet": "static int oom_kill_memcg_member(struct task_struct *task, void *unused)\n{\n\tif (task->signal->oom_score_adj != OOM_SCORE_ADJ_MIN) {\n\t\tget_task_struct(task);\n\t\t__oom_kill_process(task);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/oom.h>",
      "#include \"slab.h\"",
      "#include \"internal.h\"",
      "#include <asm/tlb.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/timex.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/oom.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__oom_kill_process",
          "args": [
            "task"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "__oom_kill_process",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
          "lines": "833-909",
          "snippet": "static void __oom_kill_process(struct task_struct *victim)\n{\n\tstruct task_struct *p;\n\tstruct mm_struct *mm;\n\tbool can_oom_reap = true;\n\n\tp = find_lock_task_mm(victim);\n\tif (!p) {\n\t\tput_task_struct(victim);\n\t\treturn;\n\t} else if (victim != p) {\n\t\tget_task_struct(p);\n\t\tput_task_struct(victim);\n\t\tvictim = p;\n\t}\n\n\t/* Get a reference to safely compare mm after task_unlock(victim) */\n\tmm = victim->mm;\n\tmmgrab(mm);\n\n\t/* Raise event before sending signal: task reaper must see this */\n\tcount_vm_event(OOM_KILL);\n\tmemcg_memory_event_mm(mm, MEMCG_OOM_KILL);\n\n\t/*\n\t * We should send SIGKILL before granting access to memory reserves\n\t * in order to prevent the OOM victim from depleting the memory\n\t * reserves from the user space under its control.\n\t */\n\tdo_send_sig_info(SIGKILL, SEND_SIG_PRIV, victim, PIDTYPE_TGID);\n\tmark_oom_victim(victim);\n\tpr_err(\"Killed process %d (%s) total-vm:%lukB, anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\\n\",\n\t\ttask_pid_nr(victim), victim->comm, K(victim->mm->total_vm),\n\t\tK(get_mm_counter(victim->mm, MM_ANONPAGES)),\n\t\tK(get_mm_counter(victim->mm, MM_FILEPAGES)),\n\t\tK(get_mm_counter(victim->mm, MM_SHMEMPAGES)));\n\ttask_unlock(victim);\n\n\t/*\n\t * Kill all user processes sharing victim->mm in other thread groups, if\n\t * any.  They don't get access to memory reserves, though, to avoid\n\t * depletion of all memory.  This prevents mm->mmap_sem livelock when an\n\t * oom killed thread cannot exit because it requires the semaphore and\n\t * its contended by another thread trying to allocate memory itself.\n\t * That thread will now get access to memory reserves since it has a\n\t * pending fatal signal.\n\t */\n\trcu_read_lock();\n\tfor_each_process(p) {\n\t\tif (!process_shares_mm(p, mm))\n\t\t\tcontinue;\n\t\tif (same_thread_group(p, victim))\n\t\t\tcontinue;\n\t\tif (is_global_init(p)) {\n\t\t\tcan_oom_reap = false;\n\t\t\tset_bit(MMF_OOM_SKIP, &mm->flags);\n\t\t\tpr_info(\"oom killer %d (%s) has mm pinned by %d (%s)\\n\",\n\t\t\t\t\ttask_pid_nr(victim), victim->comm,\n\t\t\t\t\ttask_pid_nr(p), p->comm);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * No use_mm() user needs to read from the userspace so we are\n\t\t * ok to reap it.\n\t\t */\n\t\tif (unlikely(p->flags & PF_KTHREAD))\n\t\t\tcontinue;\n\t\tdo_send_sig_info(SIGKILL, SEND_SIG_PRIV, p, PIDTYPE_TGID);\n\t}\n\trcu_read_unlock();\n\n\tif (can_oom_reap)\n\t\twake_oom_reaper(victim);\n\n\tmmdrop(mm);\n\tput_task_struct(victim);\n}",
          "includes": [
            "#include <trace/events/oom.h>",
            "#include \"slab.h\"",
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/timex.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/oom.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstatic void __oom_kill_process(struct task_struct *victim)\n{\n\tstruct task_struct *p;\n\tstruct mm_struct *mm;\n\tbool can_oom_reap = true;\n\n\tp = find_lock_task_mm(victim);\n\tif (!p) {\n\t\tput_task_struct(victim);\n\t\treturn;\n\t} else if (victim != p) {\n\t\tget_task_struct(p);\n\t\tput_task_struct(victim);\n\t\tvictim = p;\n\t}\n\n\t/* Get a reference to safely compare mm after task_unlock(victim) */\n\tmm = victim->mm;\n\tmmgrab(mm);\n\n\t/* Raise event before sending signal: task reaper must see this */\n\tcount_vm_event(OOM_KILL);\n\tmemcg_memory_event_mm(mm, MEMCG_OOM_KILL);\n\n\t/*\n\t * We should send SIGKILL before granting access to memory reserves\n\t * in order to prevent the OOM victim from depleting the memory\n\t * reserves from the user space under its control.\n\t */\n\tdo_send_sig_info(SIGKILL, SEND_SIG_PRIV, victim, PIDTYPE_TGID);\n\tmark_oom_victim(victim);\n\tpr_err(\"Killed process %d (%s) total-vm:%lukB, anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\\n\",\n\t\ttask_pid_nr(victim), victim->comm, K(victim->mm->total_vm),\n\t\tK(get_mm_counter(victim->mm, MM_ANONPAGES)),\n\t\tK(get_mm_counter(victim->mm, MM_FILEPAGES)),\n\t\tK(get_mm_counter(victim->mm, MM_SHMEMPAGES)));\n\ttask_unlock(victim);\n\n\t/*\n\t * Kill all user processes sharing victim->mm in other thread groups, if\n\t * any.  They don't get access to memory reserves, though, to avoid\n\t * depletion of all memory.  This prevents mm->mmap_sem livelock when an\n\t * oom killed thread cannot exit because it requires the semaphore and\n\t * its contended by another thread trying to allocate memory itself.\n\t * That thread will now get access to memory reserves since it has a\n\t * pending fatal signal.\n\t */\n\trcu_read_lock();\n\tfor_each_process(p) {\n\t\tif (!process_shares_mm(p, mm))\n\t\t\tcontinue;\n\t\tif (same_thread_group(p, victim))\n\t\t\tcontinue;\n\t\tif (is_global_init(p)) {\n\t\t\tcan_oom_reap = false;\n\t\t\tset_bit(MMF_OOM_SKIP, &mm->flags);\n\t\t\tpr_info(\"oom killer %d (%s) has mm pinned by %d (%s)\\n\",\n\t\t\t\t\ttask_pid_nr(victim), victim->comm,\n\t\t\t\t\ttask_pid_nr(p), p->comm);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * No use_mm() user needs to read from the userspace so we are\n\t\t * ok to reap it.\n\t\t */\n\t\tif (unlikely(p->flags & PF_KTHREAD))\n\t\t\tcontinue;\n\t\tdo_send_sig_info(SIGKILL, SEND_SIG_PRIV, p, PIDTYPE_TGID);\n\t}\n\trcu_read_unlock();\n\n\tif (can_oom_reap)\n\t\twake_oom_reaper(victim);\n\n\tmmdrop(mm);\n\tput_task_struct(victim);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_task_struct",
          "args": [
            "task"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstatic int oom_kill_memcg_member(struct task_struct *task, void *unused)\n{\n\tif (task->signal->oom_score_adj != OOM_SCORE_ADJ_MIN) {\n\t\tget_task_struct(task);\n\t\t__oom_kill_process(task);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "__oom_kill_process",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
    "lines": "833-909",
    "snippet": "static void __oom_kill_process(struct task_struct *victim)\n{\n\tstruct task_struct *p;\n\tstruct mm_struct *mm;\n\tbool can_oom_reap = true;\n\n\tp = find_lock_task_mm(victim);\n\tif (!p) {\n\t\tput_task_struct(victim);\n\t\treturn;\n\t} else if (victim != p) {\n\t\tget_task_struct(p);\n\t\tput_task_struct(victim);\n\t\tvictim = p;\n\t}\n\n\t/* Get a reference to safely compare mm after task_unlock(victim) */\n\tmm = victim->mm;\n\tmmgrab(mm);\n\n\t/* Raise event before sending signal: task reaper must see this */\n\tcount_vm_event(OOM_KILL);\n\tmemcg_memory_event_mm(mm, MEMCG_OOM_KILL);\n\n\t/*\n\t * We should send SIGKILL before granting access to memory reserves\n\t * in order to prevent the OOM victim from depleting the memory\n\t * reserves from the user space under its control.\n\t */\n\tdo_send_sig_info(SIGKILL, SEND_SIG_PRIV, victim, PIDTYPE_TGID);\n\tmark_oom_victim(victim);\n\tpr_err(\"Killed process %d (%s) total-vm:%lukB, anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\\n\",\n\t\ttask_pid_nr(victim), victim->comm, K(victim->mm->total_vm),\n\t\tK(get_mm_counter(victim->mm, MM_ANONPAGES)),\n\t\tK(get_mm_counter(victim->mm, MM_FILEPAGES)),\n\t\tK(get_mm_counter(victim->mm, MM_SHMEMPAGES)));\n\ttask_unlock(victim);\n\n\t/*\n\t * Kill all user processes sharing victim->mm in other thread groups, if\n\t * any.  They don't get access to memory reserves, though, to avoid\n\t * depletion of all memory.  This prevents mm->mmap_sem livelock when an\n\t * oom killed thread cannot exit because it requires the semaphore and\n\t * its contended by another thread trying to allocate memory itself.\n\t * That thread will now get access to memory reserves since it has a\n\t * pending fatal signal.\n\t */\n\trcu_read_lock();\n\tfor_each_process(p) {\n\t\tif (!process_shares_mm(p, mm))\n\t\t\tcontinue;\n\t\tif (same_thread_group(p, victim))\n\t\t\tcontinue;\n\t\tif (is_global_init(p)) {\n\t\t\tcan_oom_reap = false;\n\t\t\tset_bit(MMF_OOM_SKIP, &mm->flags);\n\t\t\tpr_info(\"oom killer %d (%s) has mm pinned by %d (%s)\\n\",\n\t\t\t\t\ttask_pid_nr(victim), victim->comm,\n\t\t\t\t\ttask_pid_nr(p), p->comm);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * No use_mm() user needs to read from the userspace so we are\n\t\t * ok to reap it.\n\t\t */\n\t\tif (unlikely(p->flags & PF_KTHREAD))\n\t\t\tcontinue;\n\t\tdo_send_sig_info(SIGKILL, SEND_SIG_PRIV, p, PIDTYPE_TGID);\n\t}\n\trcu_read_unlock();\n\n\tif (can_oom_reap)\n\t\twake_oom_reaper(victim);\n\n\tmmdrop(mm);\n\tput_task_struct(victim);\n}",
    "includes": [
      "#include <trace/events/oom.h>",
      "#include \"slab.h\"",
      "#include \"internal.h\"",
      "#include <asm/tlb.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/timex.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/oom.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "victim"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmdrop",
          "args": [
            "mm"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_oom_reaper",
          "args": [
            "victim"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "wake_oom_reaper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
          "lines": "658-660",
          "snippet": "static inline void wake_oom_reaper(struct task_struct *tsk)\n{\n}",
          "includes": [
            "#include <trace/events/oom.h>",
            "#include \"slab.h\"",
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/timex.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/oom.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstatic inline void wake_oom_reaper(struct task_struct *tsk)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_send_sig_info",
          "args": [
            "SIGKILL",
            "SEND_SIG_PRIV",
            "p",
            "PIDTYPE_TGID"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p->flags & PF_KTHREAD"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"oom killer %d (%s) has mm pinned by %d (%s)\\n\"",
            "task_pid_nr(victim)",
            "victim->comm",
            "task_pid_nr(p)",
            "p->comm"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "p"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "victim"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "MMF_OOM_SKIP",
            "&mm->flags"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_global_init",
          "args": [
            "p"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "same_thread_group",
          "args": [
            "p",
            "victim"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_shares_mm",
          "args": [
            "p",
            "mm"
          ],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "process_shares_mm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
          "lines": "469-479",
          "snippet": "bool process_shares_mm(struct task_struct *p, struct mm_struct *mm)\n{\n\tstruct task_struct *t;\n\n\tfor_each_thread(p, t) {\n\t\tstruct mm_struct *t_mm = READ_ONCE(t->mm);\n\t\tif (t_mm)\n\t\t\treturn t_mm == mm;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/oom.h>",
            "#include \"slab.h\"",
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/timex.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/oom.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nbool process_shares_mm(struct task_struct *p, struct mm_struct *mm)\n{\n\tstruct task_struct *t;\n\n\tfor_each_thread(p, t) {\n\t\tstruct mm_struct *t_mm = READ_ONCE(t->mm);\n\t\tif (t_mm)\n\t\t\treturn t_mm == mm;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "victim"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Killed process %d (%s) total-vm:%lukB, anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\\n\"",
            "task_pid_nr(victim)",
            "victim->comm",
            "K(victim->mm->total_vm)",
            "K(get_mm_counter(victim->mm, MM_ANONPAGES))",
            "K(get_mm_counter(victim->mm, MM_FILEPAGES))",
            "K(get_mm_counter(victim->mm, MM_SHMEMPAGES))"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "get_mm_counter(victim->mm, MM_SHMEMPAGES)"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mm_counter",
          "args": [
            "victim->mm",
            "MM_SHMEMPAGES"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "get_mm_counter(victim->mm, MM_FILEPAGES)"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mm_counter",
          "args": [
            "victim->mm",
            "MM_FILEPAGES"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "get_mm_counter(victim->mm, MM_ANONPAGES)"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mm_counter",
          "args": [
            "victim->mm",
            "MM_ANONPAGES"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "victim->mm->total_vm"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "victim"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_oom_victim",
          "args": [
            "victim"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "mark_oom_victim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
          "lines": "673-697",
          "snippet": "static void mark_oom_victim(struct task_struct *tsk)\n{\n\tstruct mm_struct *mm = tsk->mm;\n\n\tWARN_ON(oom_killer_disabled);\n\t/* OOM killer might race with memcg OOM */\n\tif (test_and_set_tsk_thread_flag(tsk, TIF_MEMDIE))\n\t\treturn;\n\n\t/* oom_mm is bound to the signal struct life time. */\n\tif (!cmpxchg(&tsk->signal->oom_mm, NULL, mm)) {\n\t\tmmgrab(tsk->signal->oom_mm);\n\t\tset_bit(MMF_OOM_VICTIM, &mm->flags);\n\t}\n\n\t/*\n\t * Make sure that the task is woken up from uninterruptible sleep\n\t * if it is frozen because OOM killer wouldn't be able to free\n\t * any memory and livelock. freezing_slow_path will tell the freezer\n\t * that TIF_MEMDIE tasks should be ignored.\n\t */\n\t__thaw_task(tsk);\n\tatomic_inc(&oom_victims);\n\ttrace_mark_victim(tsk->pid);\n}",
          "includes": [
            "#include <trace/events/oom.h>",
            "#include \"slab.h\"",
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/timex.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/oom.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t oom_victims = ATOMIC_INIT(0);",
            "static bool oom_killer_disabled"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstatic atomic_t oom_victims = ATOMIC_INIT(0);\nstatic bool oom_killer_disabled;\n\nstatic void mark_oom_victim(struct task_struct *tsk)\n{\n\tstruct mm_struct *mm = tsk->mm;\n\n\tWARN_ON(oom_killer_disabled);\n\t/* OOM killer might race with memcg OOM */\n\tif (test_and_set_tsk_thread_flag(tsk, TIF_MEMDIE))\n\t\treturn;\n\n\t/* oom_mm is bound to the signal struct life time. */\n\tif (!cmpxchg(&tsk->signal->oom_mm, NULL, mm)) {\n\t\tmmgrab(tsk->signal->oom_mm);\n\t\tset_bit(MMF_OOM_VICTIM, &mm->flags);\n\t}\n\n\t/*\n\t * Make sure that the task is woken up from uninterruptible sleep\n\t * if it is frozen because OOM killer wouldn't be able to free\n\t * any memory and livelock. freezing_slow_path will tell the freezer\n\t * that TIF_MEMDIE tasks should be ignored.\n\t */\n\t__thaw_task(tsk);\n\tatomic_inc(&oom_victims);\n\ttrace_mark_victim(tsk->pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_send_sig_info",
          "args": [
            "SIGKILL",
            "SEND_SIG_PRIV",
            "victim",
            "PIDTYPE_TGID"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcg_memory_event_mm",
          "args": [
            "mm",
            "MEMCG_OOM_KILL"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_vm_event",
          "args": [
            "OOM_KILL"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmgrab",
          "args": [
            "mm"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "victim"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_struct",
          "args": [
            "p"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "victim"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_lock_task_mm",
          "args": [
            "victim"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "find_lock_task_mm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
          "lines": "120-137",
          "snippet": "struct task_struct *find_lock_task_mm(struct task_struct *p)\n{\n\tstruct task_struct *t;\n\n\trcu_read_lock();\n\n\tfor_each_thread(p, t) {\n\t\ttask_lock(t);\n\t\tif (likely(t->mm))\n\t\t\tgoto found;\n\t\ttask_unlock(t);\n\t}\n\tt = NULL;\nfound:\n\trcu_read_unlock();\n\n\treturn t;\n}",
          "includes": [
            "#include <trace/events/oom.h>",
            "#include \"slab.h\"",
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/timex.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/oom.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstruct task_struct *find_lock_task_mm(struct task_struct *p)\n{\n\tstruct task_struct *t;\n\n\trcu_read_lock();\n\n\tfor_each_thread(p, t) {\n\t\ttask_lock(t);\n\t\tif (likely(t->mm))\n\t\t\tgoto found;\n\t\ttask_unlock(t);\n\t}\n\tt = NULL;\nfound:\n\trcu_read_unlock();\n\n\treturn t;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstatic void __oom_kill_process(struct task_struct *victim)\n{\n\tstruct task_struct *p;\n\tstruct mm_struct *mm;\n\tbool can_oom_reap = true;\n\n\tp = find_lock_task_mm(victim);\n\tif (!p) {\n\t\tput_task_struct(victim);\n\t\treturn;\n\t} else if (victim != p) {\n\t\tget_task_struct(p);\n\t\tput_task_struct(victim);\n\t\tvictim = p;\n\t}\n\n\t/* Get a reference to safely compare mm after task_unlock(victim) */\n\tmm = victim->mm;\n\tmmgrab(mm);\n\n\t/* Raise event before sending signal: task reaper must see this */\n\tcount_vm_event(OOM_KILL);\n\tmemcg_memory_event_mm(mm, MEMCG_OOM_KILL);\n\n\t/*\n\t * We should send SIGKILL before granting access to memory reserves\n\t * in order to prevent the OOM victim from depleting the memory\n\t * reserves from the user space under its control.\n\t */\n\tdo_send_sig_info(SIGKILL, SEND_SIG_PRIV, victim, PIDTYPE_TGID);\n\tmark_oom_victim(victim);\n\tpr_err(\"Killed process %d (%s) total-vm:%lukB, anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\\n\",\n\t\ttask_pid_nr(victim), victim->comm, K(victim->mm->total_vm),\n\t\tK(get_mm_counter(victim->mm, MM_ANONPAGES)),\n\t\tK(get_mm_counter(victim->mm, MM_FILEPAGES)),\n\t\tK(get_mm_counter(victim->mm, MM_SHMEMPAGES)));\n\ttask_unlock(victim);\n\n\t/*\n\t * Kill all user processes sharing victim->mm in other thread groups, if\n\t * any.  They don't get access to memory reserves, though, to avoid\n\t * depletion of all memory.  This prevents mm->mmap_sem livelock when an\n\t * oom killed thread cannot exit because it requires the semaphore and\n\t * its contended by another thread trying to allocate memory itself.\n\t * That thread will now get access to memory reserves since it has a\n\t * pending fatal signal.\n\t */\n\trcu_read_lock();\n\tfor_each_process(p) {\n\t\tif (!process_shares_mm(p, mm))\n\t\t\tcontinue;\n\t\tif (same_thread_group(p, victim))\n\t\t\tcontinue;\n\t\tif (is_global_init(p)) {\n\t\t\tcan_oom_reap = false;\n\t\t\tset_bit(MMF_OOM_SKIP, &mm->flags);\n\t\t\tpr_info(\"oom killer %d (%s) has mm pinned by %d (%s)\\n\",\n\t\t\t\t\ttask_pid_nr(victim), victim->comm,\n\t\t\t\t\ttask_pid_nr(p), p->comm);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * No use_mm() user needs to read from the userspace so we are\n\t\t * ok to reap it.\n\t\t */\n\t\tif (unlikely(p->flags & PF_KTHREAD))\n\t\t\tcontinue;\n\t\tdo_send_sig_info(SIGKILL, SEND_SIG_PRIV, p, PIDTYPE_TGID);\n\t}\n\trcu_read_unlock();\n\n\tif (can_oom_reap)\n\t\twake_oom_reaper(victim);\n\n\tmmdrop(mm);\n\tput_task_struct(victim);\n}"
  },
  {
    "function_name": "task_will_free_mem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
    "lines": "786-831",
    "snippet": "static bool task_will_free_mem(struct task_struct *task)\n{\n\tstruct mm_struct *mm = task->mm;\n\tstruct task_struct *p;\n\tbool ret = true;\n\n\t/*\n\t * Skip tasks without mm because it might have passed its exit_mm and\n\t * exit_oom_victim. oom_reaper could have rescued that but do not rely\n\t * on that for now. We can consider find_lock_task_mm in future.\n\t */\n\tif (!mm)\n\t\treturn false;\n\n\tif (!__task_will_free_mem(task))\n\t\treturn false;\n\n\t/*\n\t * This task has already been drained by the oom reaper so there are\n\t * only small chances it will free some more\n\t */\n\tif (test_bit(MMF_OOM_SKIP, &mm->flags))\n\t\treturn false;\n\n\tif (atomic_read(&mm->mm_users) <= 1)\n\t\treturn true;\n\n\t/*\n\t * Make sure that all tasks which share the mm with the given tasks\n\t * are dying as well to make sure that a) nobody pins its mm and\n\t * b) the task is also reapable by the oom reaper.\n\t */\n\trcu_read_lock();\n\tfor_each_process(p) {\n\t\tif (!process_shares_mm(p, mm))\n\t\t\tcontinue;\n\t\tif (same_thread_group(task, p))\n\t\t\tcontinue;\n\t\tret = __task_will_free_mem(p);\n\t\tif (!ret)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/oom.h>",
      "#include \"slab.h\"",
      "#include \"internal.h\"",
      "#include <asm/tlb.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/timex.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/oom.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__task_will_free_mem",
          "args": [
            "p"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "__task_will_free_mem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
          "lines": "758-777",
          "snippet": "static inline bool __task_will_free_mem(struct task_struct *task)\n{\n\tstruct signal_struct *sig = task->signal;\n\n\t/*\n\t * A coredumping process may sleep for an extended period in exit_mm(),\n\t * so the oom killer cannot assume that the process will promptly exit\n\t * and release memory.\n\t */\n\tif (sig->flags & SIGNAL_GROUP_COREDUMP)\n\t\treturn false;\n\n\tif (sig->flags & SIGNAL_GROUP_EXIT)\n\t\treturn true;\n\n\tif (thread_group_empty(task) && (task->flags & PF_EXITING))\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/oom.h>",
            "#include \"slab.h\"",
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/timex.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/oom.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstatic inline bool __task_will_free_mem(struct task_struct *task)\n{\n\tstruct signal_struct *sig = task->signal;\n\n\t/*\n\t * A coredumping process may sleep for an extended period in exit_mm(),\n\t * so the oom killer cannot assume that the process will promptly exit\n\t * and release memory.\n\t */\n\tif (sig->flags & SIGNAL_GROUP_COREDUMP)\n\t\treturn false;\n\n\tif (sig->flags & SIGNAL_GROUP_EXIT)\n\t\treturn true;\n\n\tif (thread_group_empty(task) && (task->flags & PF_EXITING))\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "same_thread_group",
          "args": [
            "task",
            "p"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_shares_mm",
          "args": [
            "p",
            "mm"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "process_shares_mm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
          "lines": "469-479",
          "snippet": "bool process_shares_mm(struct task_struct *p, struct mm_struct *mm)\n{\n\tstruct task_struct *t;\n\n\tfor_each_thread(p, t) {\n\t\tstruct mm_struct *t_mm = READ_ONCE(t->mm);\n\t\tif (t_mm)\n\t\t\treturn t_mm == mm;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/oom.h>",
            "#include \"slab.h\"",
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/timex.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/oom.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nbool process_shares_mm(struct task_struct *p, struct mm_struct *mm)\n{\n\tstruct task_struct *t;\n\n\tfor_each_thread(p, t) {\n\t\tstruct mm_struct *t_mm = READ_ONCE(t->mm);\n\t\tif (t_mm)\n\t\t\treturn t_mm == mm;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&mm->mm_users"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "MMF_OOM_SKIP",
            "&mm->flags"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstatic bool task_will_free_mem(struct task_struct *task)\n{\n\tstruct mm_struct *mm = task->mm;\n\tstruct task_struct *p;\n\tbool ret = true;\n\n\t/*\n\t * Skip tasks without mm because it might have passed its exit_mm and\n\t * exit_oom_victim. oom_reaper could have rescued that but do not rely\n\t * on that for now. We can consider find_lock_task_mm in future.\n\t */\n\tif (!mm)\n\t\treturn false;\n\n\tif (!__task_will_free_mem(task))\n\t\treturn false;\n\n\t/*\n\t * This task has already been drained by the oom reaper so there are\n\t * only small chances it will free some more\n\t */\n\tif (test_bit(MMF_OOM_SKIP, &mm->flags))\n\t\treturn false;\n\n\tif (atomic_read(&mm->mm_users) <= 1)\n\t\treturn true;\n\n\t/*\n\t * Make sure that all tasks which share the mm with the given tasks\n\t * are dying as well to make sure that a) nobody pins its mm and\n\t * b) the task is also reapable by the oom reaper.\n\t */\n\trcu_read_lock();\n\tfor_each_process(p) {\n\t\tif (!process_shares_mm(p, mm))\n\t\t\tcontinue;\n\t\tif (same_thread_group(task, p))\n\t\t\tcontinue;\n\t\tret = __task_will_free_mem(p);\n\t\tif (!ret)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__task_will_free_mem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
    "lines": "758-777",
    "snippet": "static inline bool __task_will_free_mem(struct task_struct *task)\n{\n\tstruct signal_struct *sig = task->signal;\n\n\t/*\n\t * A coredumping process may sleep for an extended period in exit_mm(),\n\t * so the oom killer cannot assume that the process will promptly exit\n\t * and release memory.\n\t */\n\tif (sig->flags & SIGNAL_GROUP_COREDUMP)\n\t\treturn false;\n\n\tif (sig->flags & SIGNAL_GROUP_EXIT)\n\t\treturn true;\n\n\tif (thread_group_empty(task) && (task->flags & PF_EXITING))\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include <trace/events/oom.h>",
      "#include \"slab.h\"",
      "#include \"internal.h\"",
      "#include <asm/tlb.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/timex.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/oom.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "thread_group_empty",
          "args": [
            "task"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstatic inline bool __task_will_free_mem(struct task_struct *task)\n{\n\tstruct signal_struct *sig = task->signal;\n\n\t/*\n\t * A coredumping process may sleep for an extended period in exit_mm(),\n\t * so the oom killer cannot assume that the process will promptly exit\n\t * and release memory.\n\t */\n\tif (sig->flags & SIGNAL_GROUP_COREDUMP)\n\t\treturn false;\n\n\tif (sig->flags & SIGNAL_GROUP_EXIT)\n\t\treturn true;\n\n\tif (thread_group_empty(task) && (task->flags & PF_EXITING))\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "oom_killer_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
    "lines": "734-756",
    "snippet": "bool oom_killer_disable(signed long timeout)\n{\n\tsigned long ret;\n\n\t/*\n\t * Make sure to not race with an ongoing OOM killer. Check that the\n\t * current is not killed (possibly due to sharing the victim's memory).\n\t */\n\tif (mutex_lock_killable(&oom_lock))\n\t\treturn false;\n\toom_killer_disabled = true;\n\tmutex_unlock(&oom_lock);\n\n\tret = wait_event_interruptible_timeout(oom_victims_wait,\n\t\t\t!atomic_read(&oom_victims), timeout);\n\tif (ret <= 0) {\n\t\toom_killer_enable();\n\t\treturn false;\n\t}\n\tpr_info(\"OOM killer disabled.\\n\");\n\n\treturn true;\n}",
    "includes": [
      "#include <trace/events/oom.h>",
      "#include \"slab.h\"",
      "#include \"internal.h\"",
      "#include <asm/tlb.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/timex.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/oom.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t oom_victims = ATOMIC_INIT(0);",
      "static DECLARE_WAIT_QUEUE_HEAD(oom_victims_wait);",
      "static bool oom_killer_disabled"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"OOM killer disabled.\\n\""
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oom_killer_enable",
          "args": [],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "oom_killer_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
          "lines": "713-717",
          "snippet": "void oom_killer_enable(void)\n{\n\toom_killer_disabled = false;\n\tpr_info(\"OOM killer enabled.\\n\");\n}",
          "includes": [
            "#include <trace/events/oom.h>",
            "#include \"slab.h\"",
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/timex.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/oom.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool oom_killer_disabled"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstatic bool oom_killer_disabled;\n\nvoid oom_killer_enable(void)\n{\n\toom_killer_disabled = false;\n\tpr_info(\"OOM killer enabled.\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event_interruptible_timeout",
          "args": [
            "oom_victims_wait",
            "!atomic_read(&oom_victims)",
            "timeout"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&oom_victims"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&oom_lock"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_killable",
          "args": [
            "&oom_lock"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstatic atomic_t oom_victims = ATOMIC_INIT(0);\nstatic DECLARE_WAIT_QUEUE_HEAD(oom_victims_wait);\nstatic bool oom_killer_disabled;\n\nbool oom_killer_disable(signed long timeout)\n{\n\tsigned long ret;\n\n\t/*\n\t * Make sure to not race with an ongoing OOM killer. Check that the\n\t * current is not killed (possibly due to sharing the victim's memory).\n\t */\n\tif (mutex_lock_killable(&oom_lock))\n\t\treturn false;\n\toom_killer_disabled = true;\n\tmutex_unlock(&oom_lock);\n\n\tret = wait_event_interruptible_timeout(oom_victims_wait,\n\t\t\t!atomic_read(&oom_victims), timeout);\n\tif (ret <= 0) {\n\t\toom_killer_enable();\n\t\treturn false;\n\t}\n\tpr_info(\"OOM killer disabled.\\n\");\n\n\treturn true;\n}"
  },
  {
    "function_name": "oom_killer_enable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
    "lines": "713-717",
    "snippet": "void oom_killer_enable(void)\n{\n\toom_killer_disabled = false;\n\tpr_info(\"OOM killer enabled.\\n\");\n}",
    "includes": [
      "#include <trace/events/oom.h>",
      "#include \"slab.h\"",
      "#include \"internal.h\"",
      "#include <asm/tlb.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/timex.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/oom.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool oom_killer_disabled"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"OOM killer enabled.\\n\""
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstatic bool oom_killer_disabled;\n\nvoid oom_killer_enable(void)\n{\n\toom_killer_disabled = false;\n\tpr_info(\"OOM killer enabled.\\n\");\n}"
  },
  {
    "function_name": "exit_oom_victim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
    "lines": "702-708",
    "snippet": "void exit_oom_victim(void)\n{\n\tclear_thread_flag(TIF_MEMDIE);\n\n\tif (!atomic_dec_return(&oom_victims))\n\t\twake_up_all(&oom_victims_wait);\n}",
    "includes": [
      "#include <trace/events/oom.h>",
      "#include \"slab.h\"",
      "#include \"internal.h\"",
      "#include <asm/tlb.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/timex.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/oom.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t oom_victims = ATOMIC_INIT(0);",
      "static DECLARE_WAIT_QUEUE_HEAD(oom_victims_wait);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&oom_victims_wait"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_return",
          "args": [
            "&oom_victims"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_thread_flag",
          "args": [
            "TIF_MEMDIE"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstatic atomic_t oom_victims = ATOMIC_INIT(0);\nstatic DECLARE_WAIT_QUEUE_HEAD(oom_victims_wait);\n\nvoid exit_oom_victim(void)\n{\n\tclear_thread_flag(TIF_MEMDIE);\n\n\tif (!atomic_dec_return(&oom_victims))\n\t\twake_up_all(&oom_victims_wait);\n}"
  },
  {
    "function_name": "mark_oom_victim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
    "lines": "673-697",
    "snippet": "static void mark_oom_victim(struct task_struct *tsk)\n{\n\tstruct mm_struct *mm = tsk->mm;\n\n\tWARN_ON(oom_killer_disabled);\n\t/* OOM killer might race with memcg OOM */\n\tif (test_and_set_tsk_thread_flag(tsk, TIF_MEMDIE))\n\t\treturn;\n\n\t/* oom_mm is bound to the signal struct life time. */\n\tif (!cmpxchg(&tsk->signal->oom_mm, NULL, mm)) {\n\t\tmmgrab(tsk->signal->oom_mm);\n\t\tset_bit(MMF_OOM_VICTIM, &mm->flags);\n\t}\n\n\t/*\n\t * Make sure that the task is woken up from uninterruptible sleep\n\t * if it is frozen because OOM killer wouldn't be able to free\n\t * any memory and livelock. freezing_slow_path will tell the freezer\n\t * that TIF_MEMDIE tasks should be ignored.\n\t */\n\t__thaw_task(tsk);\n\tatomic_inc(&oom_victims);\n\ttrace_mark_victim(tsk->pid);\n}",
    "includes": [
      "#include <trace/events/oom.h>",
      "#include \"slab.h\"",
      "#include \"internal.h\"",
      "#include <asm/tlb.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/timex.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/oom.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t oom_victims = ATOMIC_INIT(0);",
      "static bool oom_killer_disabled"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_mark_victim",
          "args": [
            "tsk->pid"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&oom_victims"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__thaw_task",
          "args": [
            "tsk"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "MMF_OOM_VICTIM",
            "&mm->flags"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmgrab",
          "args": [
            "tsk->signal->oom_mm"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmpxchg",
          "args": [
            "&tsk->signal->oom_mm",
            "NULL",
            "mm"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "note_cmpxchg_failure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1992-2014",
          "snippet": "static inline void note_cmpxchg_failure(const char *n,\n\t\tconst struct kmem_cache *s, unsigned long tid)\n{\n#ifdef SLUB_DEBUG_CMPXCHG\n\tunsigned long actual_tid = __this_cpu_read(s->cpu_slab->tid);\n\n\tpr_info(\"%s %s: cmpxchg redo \", n, s->name);\n\n#ifdef CONFIG_PREEMPT\n\tif (tid_to_cpu(tid) != tid_to_cpu(actual_tid))\n\t\tpr_warn(\"due to cpu change %d -> %d\\n\",\n\t\t\ttid_to_cpu(tid), tid_to_cpu(actual_tid));\n\telse\n#endif\n\tif (tid_to_event(tid) != tid_to_event(actual_tid))\n\t\tpr_warn(\"due to cpu running other code. Event %ld->%ld\\n\",\n\t\t\ttid_to_event(tid), tid_to_event(actual_tid));\n\telse\n\t\tpr_warn(\"for unknown reason: actual=%lx was=%lx target=%lx\\n\",\n\t\t\tactual_tid, tid, next_tid(tid));\n#endif\n\tstat(s, CMPXCHG_DOUBLE_CPU_FAIL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void note_cmpxchg_failure(const char *n,\n\t\tconst struct kmem_cache *s, unsigned long tid)\n{\n#ifdef SLUB_DEBUG_CMPXCHG\n\tunsigned long actual_tid = __this_cpu_read(s->cpu_slab->tid);\n\n\tpr_info(\"%s %s: cmpxchg redo \", n, s->name);\n\n#ifdef CONFIG_PREEMPT\n\tif (tid_to_cpu(tid) != tid_to_cpu(actual_tid))\n\t\tpr_warn(\"due to cpu change %d -> %d\\n\",\n\t\t\ttid_to_cpu(tid), tid_to_cpu(actual_tid));\n\telse\n#endif\n\tif (tid_to_event(tid) != tid_to_event(actual_tid))\n\t\tpr_warn(\"due to cpu running other code. Event %ld->%ld\\n\",\n\t\t\ttid_to_event(tid), tid_to_event(actual_tid));\n\telse\n\t\tpr_warn(\"for unknown reason: actual=%lx was=%lx target=%lx\\n\",\n\t\t\tactual_tid, tid, next_tid(tid));\n#endif\n\tstat(s, CMPXCHG_DOUBLE_CPU_FAIL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_tsk_thread_flag",
          "args": [
            "tsk",
            "TIF_MEMDIE"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "oom_killer_disabled"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstatic atomic_t oom_victims = ATOMIC_INIT(0);\nstatic bool oom_killer_disabled;\n\nstatic void mark_oom_victim(struct task_struct *tsk)\n{\n\tstruct mm_struct *mm = tsk->mm;\n\n\tWARN_ON(oom_killer_disabled);\n\t/* OOM killer might race with memcg OOM */\n\tif (test_and_set_tsk_thread_flag(tsk, TIF_MEMDIE))\n\t\treturn;\n\n\t/* oom_mm is bound to the signal struct life time. */\n\tif (!cmpxchg(&tsk->signal->oom_mm, NULL, mm)) {\n\t\tmmgrab(tsk->signal->oom_mm);\n\t\tset_bit(MMF_OOM_VICTIM, &mm->flags);\n\t}\n\n\t/*\n\t * Make sure that the task is woken up from uninterruptible sleep\n\t * if it is frozen because OOM killer wouldn't be able to free\n\t * any memory and livelock. freezing_slow_path will tell the freezer\n\t * that TIF_MEMDIE tasks should be ignored.\n\t */\n\t__thaw_task(tsk);\n\tatomic_inc(&oom_victims);\n\ttrace_mark_victim(tsk->pid);\n}"
  },
  {
    "function_name": "wake_oom_reaper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
    "lines": "658-660",
    "snippet": "static inline void wake_oom_reaper(struct task_struct *tsk)\n{\n}",
    "includes": [
      "#include <trace/events/oom.h>",
      "#include \"slab.h\"",
      "#include \"internal.h\"",
      "#include <asm/tlb.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/timex.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/oom.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstatic inline void wake_oom_reaper(struct task_struct *tsk)\n{\n}"
  },
  {
    "function_name": "oom_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
    "lines": "651-655",
    "snippet": "static int __init oom_init(void)\n{\n\toom_reaper_th = kthread_run(oom_reaper, NULL, \"oom_reaper\");\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/oom.h>",
      "#include \"slab.h\"",
      "#include \"internal.h\"",
      "#include <asm/tlb.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/timex.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/oom.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "oom_reaper",
            "NULL",
            "\"oom_reaper\""
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstatic int __init oom_init(void)\n{\n\toom_reaper_th = kthread_run(oom_reaper, NULL, \"oom_reaper\");\n\treturn 0;\n}"
  },
  {
    "function_name": "wake_oom_reaper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
    "lines": "635-649",
    "snippet": "static void wake_oom_reaper(struct task_struct *tsk)\n{\n\t/* tsk is already queued? */\n\tif (tsk == oom_reaper_list || tsk->oom_reaper_list)\n\t\treturn;\n\n\tget_task_struct(tsk);\n\n\tspin_lock(&oom_reaper_lock);\n\ttsk->oom_reaper_list = oom_reaper_list;\n\toom_reaper_list = tsk;\n\tspin_unlock(&oom_reaper_lock);\n\ttrace_wake_reaper(tsk->pid);\n\twake_up(&oom_reaper_wait);\n}",
    "includes": [
      "#include <trace/events/oom.h>",
      "#include \"slab.h\"",
      "#include \"internal.h\"",
      "#include <asm/tlb.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/timex.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/oom.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&oom_reaper_wait"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_wake_reaper",
          "args": [
            "tsk->pid"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&oom_reaper_lock"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&oom_reaper_lock"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_struct",
          "args": [
            "tsk"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstatic void wake_oom_reaper(struct task_struct *tsk)\n{\n\t/* tsk is already queued? */\n\tif (tsk == oom_reaper_list || tsk->oom_reaper_list)\n\t\treturn;\n\n\tget_task_struct(tsk);\n\n\tspin_lock(&oom_reaper_lock);\n\ttsk->oom_reaper_list = oom_reaper_list;\n\toom_reaper_list = tsk;\n\tspin_unlock(&oom_reaper_lock);\n\ttrace_wake_reaper(tsk->pid);\n\twake_up(&oom_reaper_wait);\n}"
  },
  {
    "function_name": "oom_reaper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
    "lines": "615-633",
    "snippet": "static int oom_reaper(void *unused)\n{\n\twhile (true) {\n\t\tstruct task_struct *tsk = NULL;\n\n\t\twait_event_freezable(oom_reaper_wait, oom_reaper_list != NULL);\n\t\tspin_lock(&oom_reaper_lock);\n\t\tif (oom_reaper_list != NULL) {\n\t\t\ttsk = oom_reaper_list;\n\t\t\toom_reaper_list = tsk->oom_reaper_list;\n\t\t}\n\t\tspin_unlock(&oom_reaper_lock);\n\n\t\tif (tsk)\n\t\t\toom_reap_task(tsk);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/oom.h>",
      "#include \"slab.h\"",
      "#include \"internal.h\"",
      "#include <asm/tlb.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/timex.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/oom.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "oom_reap_task",
          "args": [
            "tsk"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "oom_reap_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
          "lines": "585-613",
          "snippet": "static void oom_reap_task(struct task_struct *tsk)\n{\n\tint attempts = 0;\n\tstruct mm_struct *mm = tsk->signal->oom_mm;\n\n\t/* Retry the down_read_trylock(mmap_sem) a few times */\n\twhile (attempts++ < MAX_OOM_REAP_RETRIES && !oom_reap_task_mm(tsk, mm))\n\t\tschedule_timeout_idle(HZ/10);\n\n\tif (attempts <= MAX_OOM_REAP_RETRIES ||\n\t    test_bit(MMF_OOM_SKIP, &mm->flags))\n\t\tgoto done;\n\n\tpr_info(\"oom_reaper: unable to reap pid:%d (%s)\\n\",\n\t\ttask_pid_nr(tsk), tsk->comm);\n\tdebug_show_all_locks();\n\ndone:\n\ttsk->oom_reaper_list = NULL;\n\n\t/*\n\t * Hide this mm from OOM killer because it has been either reaped or\n\t * somebody can't call up_write(mmap_sem).\n\t */\n\tset_bit(MMF_OOM_SKIP, &mm->flags);\n\n\t/* Drop a reference taken by wake_oom_reaper */\n\tput_task_struct(tsk);\n}",
          "includes": [
            "#include <trace/events/oom.h>",
            "#include \"slab.h\"",
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/timex.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/oom.h>"
          ],
          "macros_used": [
            "#define MAX_OOM_REAP_RETRIES 10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\n#define MAX_OOM_REAP_RETRIES 10\n\nstatic void oom_reap_task(struct task_struct *tsk)\n{\n\tint attempts = 0;\n\tstruct mm_struct *mm = tsk->signal->oom_mm;\n\n\t/* Retry the down_read_trylock(mmap_sem) a few times */\n\twhile (attempts++ < MAX_OOM_REAP_RETRIES && !oom_reap_task_mm(tsk, mm))\n\t\tschedule_timeout_idle(HZ/10);\n\n\tif (attempts <= MAX_OOM_REAP_RETRIES ||\n\t    test_bit(MMF_OOM_SKIP, &mm->flags))\n\t\tgoto done;\n\n\tpr_info(\"oom_reaper: unable to reap pid:%d (%s)\\n\",\n\t\ttask_pid_nr(tsk), tsk->comm);\n\tdebug_show_all_locks();\n\ndone:\n\ttsk->oom_reaper_list = NULL;\n\n\t/*\n\t * Hide this mm from OOM killer because it has been either reaped or\n\t * somebody can't call up_write(mmap_sem).\n\t */\n\tset_bit(MMF_OOM_SKIP, &mm->flags);\n\n\t/* Drop a reference taken by wake_oom_reaper */\n\tput_task_struct(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&oom_reaper_lock"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&oom_reaper_lock"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event_freezable",
          "args": [
            "oom_reaper_wait",
            "oom_reaper_list != NULL"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstatic int oom_reaper(void *unused)\n{\n\twhile (true) {\n\t\tstruct task_struct *tsk = NULL;\n\n\t\twait_event_freezable(oom_reaper_wait, oom_reaper_list != NULL);\n\t\tspin_lock(&oom_reaper_lock);\n\t\tif (oom_reaper_list != NULL) {\n\t\t\ttsk = oom_reaper_list;\n\t\t\toom_reaper_list = tsk->oom_reaper_list;\n\t\t}\n\t\tspin_unlock(&oom_reaper_lock);\n\n\t\tif (tsk)\n\t\t\toom_reap_task(tsk);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "oom_reap_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
    "lines": "585-613",
    "snippet": "static void oom_reap_task(struct task_struct *tsk)\n{\n\tint attempts = 0;\n\tstruct mm_struct *mm = tsk->signal->oom_mm;\n\n\t/* Retry the down_read_trylock(mmap_sem) a few times */\n\twhile (attempts++ < MAX_OOM_REAP_RETRIES && !oom_reap_task_mm(tsk, mm))\n\t\tschedule_timeout_idle(HZ/10);\n\n\tif (attempts <= MAX_OOM_REAP_RETRIES ||\n\t    test_bit(MMF_OOM_SKIP, &mm->flags))\n\t\tgoto done;\n\n\tpr_info(\"oom_reaper: unable to reap pid:%d (%s)\\n\",\n\t\ttask_pid_nr(tsk), tsk->comm);\n\tdebug_show_all_locks();\n\ndone:\n\ttsk->oom_reaper_list = NULL;\n\n\t/*\n\t * Hide this mm from OOM killer because it has been either reaped or\n\t * somebody can't call up_write(mmap_sem).\n\t */\n\tset_bit(MMF_OOM_SKIP, &mm->flags);\n\n\t/* Drop a reference taken by wake_oom_reaper */\n\tput_task_struct(tsk);\n}",
    "includes": [
      "#include <trace/events/oom.h>",
      "#include \"slab.h\"",
      "#include \"internal.h\"",
      "#include <asm/tlb.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/timex.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/oom.h>"
    ],
    "macros_used": [
      "#define MAX_OOM_REAP_RETRIES 10"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "tsk"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "MMF_OOM_SKIP",
            "&mm->flags"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_show_all_locks",
          "args": [],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"oom_reaper: unable to reap pid:%d (%s)\\n\"",
            "task_pid_nr(tsk)",
            "tsk->comm"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "tsk"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "MMF_OOM_SKIP",
            "&mm->flags"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout_idle",
          "args": [
            "HZ/10"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oom_reap_task_mm",
          "args": [
            "tsk",
            "mm"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "oom_reap_task_mm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
          "lines": "544-582",
          "snippet": "static bool oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)\n{\n\tbool ret = true;\n\n\tif (!down_read_trylock(&mm->mmap_sem)) {\n\t\ttrace_skip_task_reaping(tsk->pid);\n\t\treturn false;\n\t}\n\n\t/*\n\t * MMF_OOM_SKIP is set by exit_mmap when the OOM reaper can't\n\t * work on the mm anymore. The check for MMF_OOM_SKIP must run\n\t * under mmap_sem for reading because it serializes against the\n\t * down_write();up_write() cycle in exit_mmap().\n\t */\n\tif (test_bit(MMF_OOM_SKIP, &mm->flags)) {\n\t\ttrace_skip_task_reaping(tsk->pid);\n\t\tgoto out_unlock;\n\t}\n\n\ttrace_start_task_reaping(tsk->pid);\n\n\t/* failed to reap part of the address space. Try again later */\n\tret = __oom_reap_task_mm(mm);\n\tif (!ret)\n\t\tgoto out_finish;\n\n\tpr_info(\"oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\\n\",\n\t\t\ttask_pid_nr(tsk), tsk->comm,\n\t\t\tK(get_mm_counter(mm, MM_ANONPAGES)),\n\t\t\tK(get_mm_counter(mm, MM_FILEPAGES)),\n\t\t\tK(get_mm_counter(mm, MM_SHMEMPAGES)));\nout_finish:\n\ttrace_finish_task_reaping(tsk->pid);\nout_unlock:\n\tup_read(&mm->mmap_sem);\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/oom.h>",
            "#include \"slab.h\"",
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/timex.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/oom.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstatic bool oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)\n{\n\tbool ret = true;\n\n\tif (!down_read_trylock(&mm->mmap_sem)) {\n\t\ttrace_skip_task_reaping(tsk->pid);\n\t\treturn false;\n\t}\n\n\t/*\n\t * MMF_OOM_SKIP is set by exit_mmap when the OOM reaper can't\n\t * work on the mm anymore. The check for MMF_OOM_SKIP must run\n\t * under mmap_sem for reading because it serializes against the\n\t * down_write();up_write() cycle in exit_mmap().\n\t */\n\tif (test_bit(MMF_OOM_SKIP, &mm->flags)) {\n\t\ttrace_skip_task_reaping(tsk->pid);\n\t\tgoto out_unlock;\n\t}\n\n\ttrace_start_task_reaping(tsk->pid);\n\n\t/* failed to reap part of the address space. Try again later */\n\tret = __oom_reap_task_mm(mm);\n\tif (!ret)\n\t\tgoto out_finish;\n\n\tpr_info(\"oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\\n\",\n\t\t\ttask_pid_nr(tsk), tsk->comm,\n\t\t\tK(get_mm_counter(mm, MM_ANONPAGES)),\n\t\t\tK(get_mm_counter(mm, MM_FILEPAGES)),\n\t\t\tK(get_mm_counter(mm, MM_SHMEMPAGES)));\nout_finish:\n\ttrace_finish_task_reaping(tsk->pid);\nout_unlock:\n\tup_read(&mm->mmap_sem);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\n#define MAX_OOM_REAP_RETRIES 10\n\nstatic void oom_reap_task(struct task_struct *tsk)\n{\n\tint attempts = 0;\n\tstruct mm_struct *mm = tsk->signal->oom_mm;\n\n\t/* Retry the down_read_trylock(mmap_sem) a few times */\n\twhile (attempts++ < MAX_OOM_REAP_RETRIES && !oom_reap_task_mm(tsk, mm))\n\t\tschedule_timeout_idle(HZ/10);\n\n\tif (attempts <= MAX_OOM_REAP_RETRIES ||\n\t    test_bit(MMF_OOM_SKIP, &mm->flags))\n\t\tgoto done;\n\n\tpr_info(\"oom_reaper: unable to reap pid:%d (%s)\\n\",\n\t\ttask_pid_nr(tsk), tsk->comm);\n\tdebug_show_all_locks();\n\ndone:\n\ttsk->oom_reaper_list = NULL;\n\n\t/*\n\t * Hide this mm from OOM killer because it has been either reaped or\n\t * somebody can't call up_write(mmap_sem).\n\t */\n\tset_bit(MMF_OOM_SKIP, &mm->flags);\n\n\t/* Drop a reference taken by wake_oom_reaper */\n\tput_task_struct(tsk);\n}"
  },
  {
    "function_name": "oom_reap_task_mm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
    "lines": "544-582",
    "snippet": "static bool oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)\n{\n\tbool ret = true;\n\n\tif (!down_read_trylock(&mm->mmap_sem)) {\n\t\ttrace_skip_task_reaping(tsk->pid);\n\t\treturn false;\n\t}\n\n\t/*\n\t * MMF_OOM_SKIP is set by exit_mmap when the OOM reaper can't\n\t * work on the mm anymore. The check for MMF_OOM_SKIP must run\n\t * under mmap_sem for reading because it serializes against the\n\t * down_write();up_write() cycle in exit_mmap().\n\t */\n\tif (test_bit(MMF_OOM_SKIP, &mm->flags)) {\n\t\ttrace_skip_task_reaping(tsk->pid);\n\t\tgoto out_unlock;\n\t}\n\n\ttrace_start_task_reaping(tsk->pid);\n\n\t/* failed to reap part of the address space. Try again later */\n\tret = __oom_reap_task_mm(mm);\n\tif (!ret)\n\t\tgoto out_finish;\n\n\tpr_info(\"oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\\n\",\n\t\t\ttask_pid_nr(tsk), tsk->comm,\n\t\t\tK(get_mm_counter(mm, MM_ANONPAGES)),\n\t\t\tK(get_mm_counter(mm, MM_FILEPAGES)),\n\t\t\tK(get_mm_counter(mm, MM_SHMEMPAGES)));\nout_finish:\n\ttrace_finish_task_reaping(tsk->pid);\nout_unlock:\n\tup_read(&mm->mmap_sem);\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/oom.h>",
      "#include \"slab.h\"",
      "#include \"internal.h\"",
      "#include <asm/tlb.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/timex.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/oom.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_finish_task_reaping",
          "args": [
            "tsk->pid"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\\n\"",
            "task_pid_nr(tsk)",
            "tsk->comm",
            "K(get_mm_counter(mm, MM_ANONPAGES))",
            "K(get_mm_counter(mm, MM_FILEPAGES))",
            "K(get_mm_counter(mm, MM_SHMEMPAGES))"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "get_mm_counter(mm, MM_SHMEMPAGES)"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mm_counter",
          "args": [
            "mm",
            "MM_SHMEMPAGES"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "get_mm_counter(mm, MM_FILEPAGES)"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mm_counter",
          "args": [
            "mm",
            "MM_FILEPAGES"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "get_mm_counter(mm, MM_ANONPAGES)"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mm_counter",
          "args": [
            "mm",
            "MM_ANONPAGES"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "tsk"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__oom_reap_task_mm",
          "args": [
            "mm"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "__oom_reap_task_mm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
          "lines": "491-536",
          "snippet": "bool __oom_reap_task_mm(struct mm_struct *mm)\n{\n\tstruct vm_area_struct *vma;\n\tbool ret = true;\n\n\t/*\n\t * Tell all users of get_user/copy_from_user etc... that the content\n\t * is no longer stable. No barriers really needed because unmapping\n\t * should imply barriers already and the reader would hit a page fault\n\t * if it stumbled over a reaped memory.\n\t */\n\tset_bit(MMF_UNSTABLE, &mm->flags);\n\n\tfor (vma = mm->mmap ; vma; vma = vma->vm_next) {\n\t\tif (!can_madv_dontneed_vma(vma))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Only anonymous pages have a good chance to be dropped\n\t\t * without additional steps which we cannot afford as we\n\t\t * are OOM already.\n\t\t *\n\t\t * We do not even care about fs backed pages because all\n\t\t * which are reclaimable have already been reclaimed and\n\t\t * we do not want to block exit_mmap by keeping mm ref\n\t\t * count elevated without a good reason.\n\t\t */\n\t\tif (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED)) {\n\t\t\tconst unsigned long start = vma->vm_start;\n\t\t\tconst unsigned long end = vma->vm_end;\n\t\t\tstruct mmu_gather tlb;\n\n\t\t\ttlb_gather_mmu(&tlb, mm, start, end);\n\t\t\tif (mmu_notifier_invalidate_range_start_nonblock(mm, start, end)) {\n\t\t\t\ttlb_finish_mmu(&tlb, start, end);\n\t\t\t\tret = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tunmap_page_range(&tlb, vma, start, end, NULL);\n\t\t\tmmu_notifier_invalidate_range_end(mm, start, end);\n\t\t\ttlb_finish_mmu(&tlb, start, end);\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/oom.h>",
            "#include \"slab.h\"",
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/timex.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/oom.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nbool __oom_reap_task_mm(struct mm_struct *mm)\n{\n\tstruct vm_area_struct *vma;\n\tbool ret = true;\n\n\t/*\n\t * Tell all users of get_user/copy_from_user etc... that the content\n\t * is no longer stable. No barriers really needed because unmapping\n\t * should imply barriers already and the reader would hit a page fault\n\t * if it stumbled over a reaped memory.\n\t */\n\tset_bit(MMF_UNSTABLE, &mm->flags);\n\n\tfor (vma = mm->mmap ; vma; vma = vma->vm_next) {\n\t\tif (!can_madv_dontneed_vma(vma))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Only anonymous pages have a good chance to be dropped\n\t\t * without additional steps which we cannot afford as we\n\t\t * are OOM already.\n\t\t *\n\t\t * We do not even care about fs backed pages because all\n\t\t * which are reclaimable have already been reclaimed and\n\t\t * we do not want to block exit_mmap by keeping mm ref\n\t\t * count elevated without a good reason.\n\t\t */\n\t\tif (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED)) {\n\t\t\tconst unsigned long start = vma->vm_start;\n\t\t\tconst unsigned long end = vma->vm_end;\n\t\t\tstruct mmu_gather tlb;\n\n\t\t\ttlb_gather_mmu(&tlb, mm, start, end);\n\t\t\tif (mmu_notifier_invalidate_range_start_nonblock(mm, start, end)) {\n\t\t\t\ttlb_finish_mmu(&tlb, start, end);\n\t\t\t\tret = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tunmap_page_range(&tlb, vma, start, end, NULL);\n\t\t\tmmu_notifier_invalidate_range_end(mm, start, end);\n\t\t\ttlb_finish_mmu(&tlb, start, end);\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_start_task_reaping",
          "args": [
            "tsk->pid"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_skip_task_reaping",
          "args": [
            "tsk->pid"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "MMF_OOM_SKIP",
            "&mm->flags"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_skip_task_reaping",
          "args": [
            "tsk->pid"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read_trylock",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstatic bool oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)\n{\n\tbool ret = true;\n\n\tif (!down_read_trylock(&mm->mmap_sem)) {\n\t\ttrace_skip_task_reaping(tsk->pid);\n\t\treturn false;\n\t}\n\n\t/*\n\t * MMF_OOM_SKIP is set by exit_mmap when the OOM reaper can't\n\t * work on the mm anymore. The check for MMF_OOM_SKIP must run\n\t * under mmap_sem for reading because it serializes against the\n\t * down_write();up_write() cycle in exit_mmap().\n\t */\n\tif (test_bit(MMF_OOM_SKIP, &mm->flags)) {\n\t\ttrace_skip_task_reaping(tsk->pid);\n\t\tgoto out_unlock;\n\t}\n\n\ttrace_start_task_reaping(tsk->pid);\n\n\t/* failed to reap part of the address space. Try again later */\n\tret = __oom_reap_task_mm(mm);\n\tif (!ret)\n\t\tgoto out_finish;\n\n\tpr_info(\"oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\\n\",\n\t\t\ttask_pid_nr(tsk), tsk->comm,\n\t\t\tK(get_mm_counter(mm, MM_ANONPAGES)),\n\t\t\tK(get_mm_counter(mm, MM_FILEPAGES)),\n\t\t\tK(get_mm_counter(mm, MM_SHMEMPAGES)));\nout_finish:\n\ttrace_finish_task_reaping(tsk->pid);\nout_unlock:\n\tup_read(&mm->mmap_sem);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__oom_reap_task_mm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
    "lines": "491-536",
    "snippet": "bool __oom_reap_task_mm(struct mm_struct *mm)\n{\n\tstruct vm_area_struct *vma;\n\tbool ret = true;\n\n\t/*\n\t * Tell all users of get_user/copy_from_user etc... that the content\n\t * is no longer stable. No barriers really needed because unmapping\n\t * should imply barriers already and the reader would hit a page fault\n\t * if it stumbled over a reaped memory.\n\t */\n\tset_bit(MMF_UNSTABLE, &mm->flags);\n\n\tfor (vma = mm->mmap ; vma; vma = vma->vm_next) {\n\t\tif (!can_madv_dontneed_vma(vma))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Only anonymous pages have a good chance to be dropped\n\t\t * without additional steps which we cannot afford as we\n\t\t * are OOM already.\n\t\t *\n\t\t * We do not even care about fs backed pages because all\n\t\t * which are reclaimable have already been reclaimed and\n\t\t * we do not want to block exit_mmap by keeping mm ref\n\t\t * count elevated without a good reason.\n\t\t */\n\t\tif (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED)) {\n\t\t\tconst unsigned long start = vma->vm_start;\n\t\t\tconst unsigned long end = vma->vm_end;\n\t\t\tstruct mmu_gather tlb;\n\n\t\t\ttlb_gather_mmu(&tlb, mm, start, end);\n\t\t\tif (mmu_notifier_invalidate_range_start_nonblock(mm, start, end)) {\n\t\t\t\ttlb_finish_mmu(&tlb, start, end);\n\t\t\t\tret = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tunmap_page_range(&tlb, vma, start, end, NULL);\n\t\t\tmmu_notifier_invalidate_range_end(mm, start, end);\n\t\t\ttlb_finish_mmu(&tlb, start, end);\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/oom.h>",
      "#include \"slab.h\"",
      "#include \"internal.h\"",
      "#include <asm/tlb.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/timex.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/oom.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tlb_finish_mmu",
          "args": [
            "&tlb",
            "start",
            "end"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "tlb_finish_mmu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_gather.c",
          "lines": "247-261",
          "snippet": "void tlb_finish_mmu(struct mmu_gather *tlb,\n\t\tunsigned long start, unsigned long end)\n{\n\t/*\n\t * If there are parallel threads are doing PTE changes on same range\n\t * under non-exclusive lock(e.g., mmap_sem read-side) but defer TLB\n\t * flush by batching, a thread has stable TLB entry can fail to flush\n\t * the TLB by observing pte_none|!pte_dirty, for example so flush TLB\n\t * forcefully if we detect parallel PTE batching threads.\n\t */\n\tbool force = mm_tlb_flush_nested(tlb->mm);\n\n\tarch_tlb_finish_mmu(tlb, start, end, force);\n\tdec_tlb_flush_pending(tlb->mm);\n}",
          "includes": [
            "#include <asm/tlb.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/smp.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/kernel.h>",
            "#include <linux/highmem.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlb.h>\n#include <asm/pgalloc.h>\n#include <linux/swap.h>\n#include <linux/smp.h>\n#include <linux/rcupdate.h>\n#include <linux/pagemap.h>\n#include <linux/mm_types.h>\n#include <linux/mmdebug.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/gfp.h>\n\nvoid tlb_finish_mmu(struct mmu_gather *tlb,\n\t\tunsigned long start, unsigned long end)\n{\n\t/*\n\t * If there are parallel threads are doing PTE changes on same range\n\t * under non-exclusive lock(e.g., mmap_sem read-side) but defer TLB\n\t * flush by batching, a thread has stable TLB entry can fail to flush\n\t * the TLB by observing pte_none|!pte_dirty, for example so flush TLB\n\t * forcefully if we detect parallel PTE batching threads.\n\t */\n\tbool force = mm_tlb_flush_nested(tlb->mm);\n\n\tarch_tlb_finish_mmu(tlb, start, end, force);\n\tdec_tlb_flush_pending(tlb->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_end",
          "args": [
            "mm",
            "start",
            "end"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmap_page_range",
          "args": [
            "&tlb",
            "vma",
            "start",
            "end",
            "NULL"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_page_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory.c",
          "lines": "1249-1267",
          "snippet": "void unmap_page_range(struct mmu_gather *tlb,\n\t\t\t     struct vm_area_struct *vma,\n\t\t\t     unsigned long addr, unsigned long end,\n\t\t\t     struct zap_details *details)\n{\n\tpgd_t *pgd;\n\tunsigned long next;\n\n\tBUG_ON(addr >= end);\n\ttlb_start_vma(tlb, vma);\n\tpgd = pgd_offset(vma->vm_mm, addr);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\tif (pgd_none_or_clear_bad(pgd))\n\t\t\tcontinue;\n\t\tnext = zap_p4d_range(tlb, vma, pgd, addr, next, details);\n\t} while (pgd++, addr = next, addr != end);\n\ttlb_end_vma(tlb, vma);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/io.h>",
            "#include <linux/oom.h>",
            "#include <linux/dax.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/string.h>",
            "#include <linux/migrate.h>",
            "#include <linux/gfp.h>",
            "#include <linux/elf.h>",
            "#include <linux/swapops.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/init.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/export.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/mmu_context.h>\n#include <asm/io.h>\n#include <linux/oom.h>\n#include <linux/dax.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/debugfs.h>\n#include <linux/dma-debug.h>\n#include <linux/string.h>\n#include <linux/migrate.h>\n#include <linux/gfp.h>\n#include <linux/elf.h>\n#include <linux/swapops.h>\n#include <linux/mmu_notifier.h>\n#include <linux/memcontrol.h>\n#include <linux/writeback.h>\n#include <linux/pfn_t.h>\n#include <linux/init.h>\n#include <linux/delayacct.h>\n#include <linux/export.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/memremap.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/kernel_stat.h>\n\nvoid unmap_page_range(struct mmu_gather *tlb,\n\t\t\t     struct vm_area_struct *vma,\n\t\t\t     unsigned long addr, unsigned long end,\n\t\t\t     struct zap_details *details)\n{\n\tpgd_t *pgd;\n\tunsigned long next;\n\n\tBUG_ON(addr >= end);\n\ttlb_start_vma(tlb, vma);\n\tpgd = pgd_offset(vma->vm_mm, addr);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\tif (pgd_none_or_clear_bad(pgd))\n\t\t\tcontinue;\n\t\tnext = zap_p4d_range(tlb, vma, pgd, addr, next, details);\n\t} while (pgd++, addr = next, addr != end);\n\ttlb_end_vma(tlb, vma);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_notifier_invalidate_range_start_nonblock",
          "args": [
            "mm",
            "start",
            "end"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tlb_gather_mmu",
          "args": [
            "&tlb",
            "mm",
            "start",
            "end"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "tlb_gather_mmu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmu_gather.c",
          "lines": "240-245",
          "snippet": "void tlb_gather_mmu(struct mmu_gather *tlb, struct mm_struct *mm,\n\t\t\tunsigned long start, unsigned long end)\n{\n\tarch_tlb_gather_mmu(tlb, mm, start, end);\n\tinc_tlb_flush_pending(tlb->mm);\n}",
          "includes": [
            "#include <asm/tlb.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/smp.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/kernel.h>",
            "#include <linux/highmem.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlb.h>\n#include <asm/pgalloc.h>\n#include <linux/swap.h>\n#include <linux/smp.h>\n#include <linux/rcupdate.h>\n#include <linux/pagemap.h>\n#include <linux/mm_types.h>\n#include <linux/mmdebug.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/gfp.h>\n\nvoid tlb_gather_mmu(struct mmu_gather *tlb, struct mm_struct *mm,\n\t\t\tunsigned long start, unsigned long end)\n{\n\tarch_tlb_gather_mmu(tlb, mm, start, end);\n\tinc_tlb_flush_pending(tlb->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vma_is_anonymous",
          "args": [
            "vma"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "can_madv_dontneed_vma",
          "args": [
            "vma"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "can_madv_dontneed_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "46-49",
          "snippet": "static inline bool can_madv_dontneed_vma(struct vm_area_struct *vma)\n{\n\treturn !(vma->vm_flags & (VM_LOCKED|VM_HUGETLB|VM_PFNMAP));\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline bool can_madv_dontneed_vma(struct vm_area_struct *vma)\n{\n\treturn !(vma->vm_flags & (VM_LOCKED|VM_HUGETLB|VM_PFNMAP));\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "MMF_UNSTABLE",
            "&mm->flags"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nbool __oom_reap_task_mm(struct mm_struct *mm)\n{\n\tstruct vm_area_struct *vma;\n\tbool ret = true;\n\n\t/*\n\t * Tell all users of get_user/copy_from_user etc... that the content\n\t * is no longer stable. No barriers really needed because unmapping\n\t * should imply barriers already and the reader would hit a page fault\n\t * if it stumbled over a reaped memory.\n\t */\n\tset_bit(MMF_UNSTABLE, &mm->flags);\n\n\tfor (vma = mm->mmap ; vma; vma = vma->vm_next) {\n\t\tif (!can_madv_dontneed_vma(vma))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Only anonymous pages have a good chance to be dropped\n\t\t * without additional steps which we cannot afford as we\n\t\t * are OOM already.\n\t\t *\n\t\t * We do not even care about fs backed pages because all\n\t\t * which are reclaimable have already been reclaimed and\n\t\t * we do not want to block exit_mmap by keeping mm ref\n\t\t * count elevated without a good reason.\n\t\t */\n\t\tif (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED)) {\n\t\t\tconst unsigned long start = vma->vm_start;\n\t\t\tconst unsigned long end = vma->vm_end;\n\t\t\tstruct mmu_gather tlb;\n\n\t\t\ttlb_gather_mmu(&tlb, mm, start, end);\n\t\t\tif (mmu_notifier_invalidate_range_start_nonblock(mm, start, end)) {\n\t\t\t\ttlb_finish_mmu(&tlb, start, end);\n\t\t\t\tret = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tunmap_page_range(&tlb, vma, start, end, NULL);\n\t\t\tmmu_notifier_invalidate_range_end(mm, start, end);\n\t\t\ttlb_finish_mmu(&tlb, start, end);\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "process_shares_mm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
    "lines": "469-479",
    "snippet": "bool process_shares_mm(struct task_struct *p, struct mm_struct *mm)\n{\n\tstruct task_struct *t;\n\n\tfor_each_thread(p, t) {\n\t\tstruct mm_struct *t_mm = READ_ONCE(t->mm);\n\t\tif (t_mm)\n\t\t\treturn t_mm == mm;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include <trace/events/oom.h>",
      "#include \"slab.h\"",
      "#include \"internal.h\"",
      "#include <asm/tlb.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/timex.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/oom.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "t->mm"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_thread",
          "args": [
            "p",
            "t"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nbool process_shares_mm(struct task_struct *p, struct mm_struct *mm)\n{\n\tstruct task_struct *t;\n\n\tfor_each_thread(p, t) {\n\t\tstruct mm_struct *t_mm = READ_ONCE(t->mm);\n\t\tif (t_mm)\n\t\t\treturn t_mm == mm;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "dump_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
    "lines": "431-451",
    "snippet": "static void dump_header(struct oom_control *oc, struct task_struct *p)\n{\n\tpr_warn(\"%s invoked oom-killer: gfp_mask=%#x(%pGg), nodemask=%*pbl, order=%d, oom_score_adj=%hd\\n\",\n\t\tcurrent->comm, oc->gfp_mask, &oc->gfp_mask,\n\t\tnodemask_pr_args(oc->nodemask), oc->order,\n\t\t\tcurrent->signal->oom_score_adj);\n\tif (!IS_ENABLED(CONFIG_COMPACTION) && oc->order)\n\t\tpr_warn(\"COMPACTION is disabled!!!\\n\");\n\n\tcpuset_print_current_mems_allowed();\n\tdump_stack();\n\tif (is_memcg_oom(oc))\n\t\tmem_cgroup_print_oom_info(oc->memcg, p);\n\telse {\n\t\tshow_mem(SHOW_MEM_FILTER_NODES, oc->nodemask);\n\t\tif (is_dump_unreclaim_slabs())\n\t\t\tdump_unreclaimable_slab();\n\t}\n\tif (sysctl_oom_dump_tasks)\n\t\tdump_tasks(oc->memcg, oc->nodemask);\n}",
    "includes": [
      "#include <trace/events/oom.h>",
      "#include \"slab.h\"",
      "#include \"internal.h\"",
      "#include <asm/tlb.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/timex.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/oom.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int sysctl_oom_dump_tasks = 1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_tasks",
          "args": [
            "oc->memcg",
            "oc->nodemask"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "dump_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
          "lines": "398-429",
          "snippet": "static void dump_tasks(struct mem_cgroup *memcg, const nodemask_t *nodemask)\n{\n\tstruct task_struct *p;\n\tstruct task_struct *task;\n\n\tpr_info(\"Tasks state (memory values in pages):\\n\");\n\tpr_info(\"[  pid  ]   uid  tgid total_vm      rss pgtables_bytes swapents oom_score_adj name\\n\");\n\trcu_read_lock();\n\tfor_each_process(p) {\n\t\tif (oom_unkillable_task(p, memcg, nodemask))\n\t\t\tcontinue;\n\n\t\ttask = find_lock_task_mm(p);\n\t\tif (!task) {\n\t\t\t/*\n\t\t\t * This is a kthread or all of p's threads have already\n\t\t\t * detached their mm's.  There's no need to report\n\t\t\t * them; they can't be oom killed anyway.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\tpr_info(\"[%7d] %5d %5d %8lu %8lu %8ld %8lu         %5hd %s\\n\",\n\t\t\ttask->pid, from_kuid(&init_user_ns, task_uid(task)),\n\t\t\ttask->tgid, task->mm->total_vm, get_mm_rss(task->mm),\n\t\t\tmm_pgtables_bytes(task->mm),\n\t\t\tget_mm_counter(task->mm, MM_SWAPENTS),\n\t\t\ttask->signal->oom_score_adj, task->comm);\n\t\ttask_unlock(task);\n\t}\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <trace/events/oom.h>",
            "#include \"slab.h\"",
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/timex.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/oom.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstatic void dump_tasks(struct mem_cgroup *memcg, const nodemask_t *nodemask)\n{\n\tstruct task_struct *p;\n\tstruct task_struct *task;\n\n\tpr_info(\"Tasks state (memory values in pages):\\n\");\n\tpr_info(\"[  pid  ]   uid  tgid total_vm      rss pgtables_bytes swapents oom_score_adj name\\n\");\n\trcu_read_lock();\n\tfor_each_process(p) {\n\t\tif (oom_unkillable_task(p, memcg, nodemask))\n\t\t\tcontinue;\n\n\t\ttask = find_lock_task_mm(p);\n\t\tif (!task) {\n\t\t\t/*\n\t\t\t * This is a kthread or all of p's threads have already\n\t\t\t * detached their mm's.  There's no need to report\n\t\t\t * them; they can't be oom killed anyway.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\tpr_info(\"[%7d] %5d %5d %8lu %8lu %8ld %8lu         %5hd %s\\n\",\n\t\t\ttask->pid, from_kuid(&init_user_ns, task_uid(task)),\n\t\t\ttask->tgid, task->mm->total_vm, get_mm_rss(task->mm),\n\t\t\tmm_pgtables_bytes(task->mm),\n\t\t\tget_mm_counter(task->mm, MM_SWAPENTS),\n\t\t\ttask->signal->oom_score_adj, task->comm);\n\t\ttask_unlock(task);\n\t}\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_unreclaimable_slab",
          "args": [],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "dump_unreclaimable_slab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slab.h",
          "lines": "511-513",
          "snippet": "static inline void dump_unreclaimable_slab(void)\n{\n}",
          "includes": [
            "#include <linux/sched/mm.h>",
            "#include <linux/random.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/slub_def.h>",
            "#include <linux/slab_def.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/mm.h>\n#include <linux/random.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/fault-inject.h>\n#include <linux/memcontrol.h>\n#include <linux/slub_def.h>\n#include <linux/slab_def.h>\n\nstatic inline void dump_unreclaimable_slab(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_dump_unreclaim_slabs",
          "args": [],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "is_dump_unreclaim_slabs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
          "lines": "177-190",
          "snippet": "static bool is_dump_unreclaim_slabs(void)\n{\n\tunsigned long nr_lru;\n\n\tnr_lru = global_node_page_state(NR_ACTIVE_ANON) +\n\t\t global_node_page_state(NR_INACTIVE_ANON) +\n\t\t global_node_page_state(NR_ACTIVE_FILE) +\n\t\t global_node_page_state(NR_INACTIVE_FILE) +\n\t\t global_node_page_state(NR_ISOLATED_ANON) +\n\t\t global_node_page_state(NR_ISOLATED_FILE) +\n\t\t global_node_page_state(NR_UNEVICTABLE);\n\n\treturn (global_node_page_state(NR_SLAB_UNRECLAIMABLE) > nr_lru);\n}",
          "includes": [
            "#include <trace/events/oom.h>",
            "#include \"slab.h\"",
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/timex.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/oom.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstatic bool is_dump_unreclaim_slabs(void)\n{\n\tunsigned long nr_lru;\n\n\tnr_lru = global_node_page_state(NR_ACTIVE_ANON) +\n\t\t global_node_page_state(NR_INACTIVE_ANON) +\n\t\t global_node_page_state(NR_ACTIVE_FILE) +\n\t\t global_node_page_state(NR_INACTIVE_FILE) +\n\t\t global_node_page_state(NR_ISOLATED_ANON) +\n\t\t global_node_page_state(NR_ISOLATED_FILE) +\n\t\t global_node_page_state(NR_UNEVICTABLE);\n\n\treturn (global_node_page_state(NR_SLAB_UNRECLAIMABLE) > nr_lru);\n}"
        }
      },
      {
        "call_info": {
          "callee": "show_mem",
          "args": [
            "SHOW_MEM_FILTER_NODES",
            "oc->nodemask"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "warn_alloc_show_mem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3380-3401",
          "snippet": "static void warn_alloc_show_mem(gfp_t gfp_mask, nodemask_t *nodemask)\n{\n\tunsigned int filter = SHOW_MEM_FILTER_NODES;\n\tstatic DEFINE_RATELIMIT_STATE(show_mem_rs, HZ, 1);\n\n\tif (!__ratelimit(&show_mem_rs))\n\t\treturn;\n\n\t/*\n\t * This documents exceptions given to allocations in certain\n\t * contexts that are allowed to allocate outside current's set\n\t * of allowed nodes.\n\t */\n\tif (!(gfp_mask & __GFP_NOMEMALLOC))\n\t\tif (tsk_is_oom_victim(current) ||\n\t\t    (current->flags & (PF_MEMALLOC | PF_EXITING)))\n\t\t\tfilter &= ~SHOW_MEM_FILTER_NODES;\n\tif (in_interrupt() || !(gfp_mask & __GFP_DIRECT_RECLAIM))\n\t\tfilter &= ~SHOW_MEM_FILTER_NODES;\n\n\tshow_mem(filter, nodemask);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void warn_alloc_show_mem(gfp_t gfp_mask, nodemask_t *nodemask)\n{\n\tunsigned int filter = SHOW_MEM_FILTER_NODES;\n\tstatic DEFINE_RATELIMIT_STATE(show_mem_rs, HZ, 1);\n\n\tif (!__ratelimit(&show_mem_rs))\n\t\treturn;\n\n\t/*\n\t * This documents exceptions given to allocations in certain\n\t * contexts that are allowed to allocate outside current's set\n\t * of allowed nodes.\n\t */\n\tif (!(gfp_mask & __GFP_NOMEMALLOC))\n\t\tif (tsk_is_oom_victim(current) ||\n\t\t    (current->flags & (PF_MEMALLOC | PF_EXITING)))\n\t\t\tfilter &= ~SHOW_MEM_FILTER_NODES;\n\tif (in_interrupt() || !(gfp_mask & __GFP_DIRECT_RECLAIM))\n\t\tfilter &= ~SHOW_MEM_FILTER_NODES;\n\n\tshow_mem(filter, nodemask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_print_oom_info",
          "args": [
            "oc->memcg",
            "p"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_print_oom_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1303-1351",
          "snippet": "void mem_cgroup_print_oom_info(struct mem_cgroup *memcg, struct task_struct *p)\n{\n\tstruct mem_cgroup *iter;\n\tunsigned int i;\n\n\trcu_read_lock();\n\n\tif (p) {\n\t\tpr_info(\"Task in \");\n\t\tpr_cont_cgroup_path(task_cgroup(p, memory_cgrp_id));\n\t\tpr_cont(\" killed as a result of limit of \");\n\t} else {\n\t\tpr_info(\"Memory limit reached of cgroup \");\n\t}\n\n\tpr_cont_cgroup_path(memcg->css.cgroup);\n\tpr_cont(\"\\n\");\n\n\trcu_read_unlock();\n\n\tpr_info(\"memory: usage %llukB, limit %llukB, failcnt %lu\\n\",\n\t\tK((u64)page_counter_read(&memcg->memory)),\n\t\tK((u64)memcg->memory.max), memcg->memory.failcnt);\n\tpr_info(\"memory+swap: usage %llukB, limit %llukB, failcnt %lu\\n\",\n\t\tK((u64)page_counter_read(&memcg->memsw)),\n\t\tK((u64)memcg->memsw.max), memcg->memsw.failcnt);\n\tpr_info(\"kmem: usage %llukB, limit %llukB, failcnt %lu\\n\",\n\t\tK((u64)page_counter_read(&memcg->kmem)),\n\t\tK((u64)memcg->kmem.max), memcg->kmem.failcnt);\n\n\tfor_each_mem_cgroup_tree(iter, memcg) {\n\t\tpr_info(\"Memory cgroup stats for \");\n\t\tpr_cont_cgroup_path(iter->css.cgroup);\n\t\tpr_cont(\":\");\n\n\t\tfor (i = 0; i < ARRAY_SIZE(memcg1_stats); i++) {\n\t\t\tif (memcg1_stats[i] == MEMCG_SWAP && !do_swap_account)\n\t\t\t\tcontinue;\n\t\t\tpr_cont(\" %s:%luKB\", memcg1_stat_names[i],\n\t\t\t\tK(memcg_page_state(iter, memcg1_stats[i])));\n\t\t}\n\n\t\tfor (i = 0; i < NR_LRU_LISTS; i++)\n\t\t\tpr_cont(\" %s:%luKB\", mem_cgroup_lru_names[i],\n\t\t\t\tK(mem_cgroup_nr_lru_pages(iter, BIT(i))));\n\n\t\tpr_cont(\"\\n\");\n\t}\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [
            "#define do_swap_account\t\t0"
          ],
          "globals_used": [
            "static const char *const mem_cgroup_lru_names[] = {\n\t\"inactive_anon\",\n\t\"active_anon\",\n\t\"inactive_file\",\n\t\"active_file\",\n\t\"unevictable\",\n};",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct",
            "static const unsigned int memcg1_stats[] = {\n\tMEMCG_CACHE,\n\tMEMCG_RSS,\n\tMEMCG_RSS_HUGE,\n\tNR_SHMEM,\n\tNR_FILE_MAPPED,\n\tNR_FILE_DIRTY,\n\tNR_WRITEBACK,\n\tMEMCG_SWAP,\n};",
            "static const char *const memcg1_stat_names[] = {\n\t\"cache\",\n\t\"rss\",\n\t\"rss_huge\",\n\t\"shmem\",\n\t\"mapped_file\",\n\t\"dirty\",\n\t\"writeback\",\n\t\"swap\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\n#define do_swap_account\t\t0\n\nstatic const char *const mem_cgroup_lru_names[] = {\n\t\"inactive_anon\",\n\t\"active_anon\",\n\t\"inactive_file\",\n\t\"active_file\",\n\t\"unevictable\",\n};\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstatic const unsigned int memcg1_stats[] = {\n\tMEMCG_CACHE,\n\tMEMCG_RSS,\n\tMEMCG_RSS_HUGE,\n\tNR_SHMEM,\n\tNR_FILE_MAPPED,\n\tNR_FILE_DIRTY,\n\tNR_WRITEBACK,\n\tMEMCG_SWAP,\n};\nstatic const char *const memcg1_stat_names[] = {\n\t\"cache\",\n\t\"rss\",\n\t\"rss_huge\",\n\t\"shmem\",\n\t\"mapped_file\",\n\t\"dirty\",\n\t\"writeback\",\n\t\"swap\",\n};\n\nvoid mem_cgroup_print_oom_info(struct mem_cgroup *memcg, struct task_struct *p)\n{\n\tstruct mem_cgroup *iter;\n\tunsigned int i;\n\n\trcu_read_lock();\n\n\tif (p) {\n\t\tpr_info(\"Task in \");\n\t\tpr_cont_cgroup_path(task_cgroup(p, memory_cgrp_id));\n\t\tpr_cont(\" killed as a result of limit of \");\n\t} else {\n\t\tpr_info(\"Memory limit reached of cgroup \");\n\t}\n\n\tpr_cont_cgroup_path(memcg->css.cgroup);\n\tpr_cont(\"\\n\");\n\n\trcu_read_unlock();\n\n\tpr_info(\"memory: usage %llukB, limit %llukB, failcnt %lu\\n\",\n\t\tK((u64)page_counter_read(&memcg->memory)),\n\t\tK((u64)memcg->memory.max), memcg->memory.failcnt);\n\tpr_info(\"memory+swap: usage %llukB, limit %llukB, failcnt %lu\\n\",\n\t\tK((u64)page_counter_read(&memcg->memsw)),\n\t\tK((u64)memcg->memsw.max), memcg->memsw.failcnt);\n\tpr_info(\"kmem: usage %llukB, limit %llukB, failcnt %lu\\n\",\n\t\tK((u64)page_counter_read(&memcg->kmem)),\n\t\tK((u64)memcg->kmem.max), memcg->kmem.failcnt);\n\n\tfor_each_mem_cgroup_tree(iter, memcg) {\n\t\tpr_info(\"Memory cgroup stats for \");\n\t\tpr_cont_cgroup_path(iter->css.cgroup);\n\t\tpr_cont(\":\");\n\n\t\tfor (i = 0; i < ARRAY_SIZE(memcg1_stats); i++) {\n\t\t\tif (memcg1_stats[i] == MEMCG_SWAP && !do_swap_account)\n\t\t\t\tcontinue;\n\t\t\tpr_cont(\" %s:%luKB\", memcg1_stat_names[i],\n\t\t\t\tK(memcg_page_state(iter, memcg1_stats[i])));\n\t\t}\n\n\t\tfor (i = 0; i < NR_LRU_LISTS; i++)\n\t\t\tpr_cont(\" %s:%luKB\", mem_cgroup_lru_names[i],\n\t\t\t\tK(mem_cgroup_nr_lru_pages(iter, BIT(i))));\n\n\t\tpr_cont(\"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_memcg_oom",
          "args": [
            "oc"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "is_memcg_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
          "lines": "148-151",
          "snippet": "static inline bool is_memcg_oom(struct oom_control *oc)\n{\n\treturn oc->memcg != NULL;\n}",
          "includes": [
            "#include <trace/events/oom.h>",
            "#include \"slab.h\"",
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/timex.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/oom.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstatic inline bool is_memcg_oom(struct oom_control *oc)\n{\n\treturn oc->memcg != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuset_print_current_mems_allowed",
          "args": [],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"COMPACTION is disabled!!!\\n\""
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_COMPACTION"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s invoked oom-killer: gfp_mask=%#x(%pGg), nodemask=%*pbl, order=%d, oom_score_adj=%hd\\n\"",
            "current->comm",
            "oc->gfp_mask",
            "&oc->gfp_mask",
            "nodemask_pr_args(oc->nodemask)",
            "oc->order",
            "current->signal->oom_score_adj"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodemask_pr_args",
          "args": [
            "oc->nodemask"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nint sysctl_oom_dump_tasks = 1;\n\nstatic void dump_header(struct oom_control *oc, struct task_struct *p)\n{\n\tpr_warn(\"%s invoked oom-killer: gfp_mask=%#x(%pGg), nodemask=%*pbl, order=%d, oom_score_adj=%hd\\n\",\n\t\tcurrent->comm, oc->gfp_mask, &oc->gfp_mask,\n\t\tnodemask_pr_args(oc->nodemask), oc->order,\n\t\t\tcurrent->signal->oom_score_adj);\n\tif (!IS_ENABLED(CONFIG_COMPACTION) && oc->order)\n\t\tpr_warn(\"COMPACTION is disabled!!!\\n\");\n\n\tcpuset_print_current_mems_allowed();\n\tdump_stack();\n\tif (is_memcg_oom(oc))\n\t\tmem_cgroup_print_oom_info(oc->memcg, p);\n\telse {\n\t\tshow_mem(SHOW_MEM_FILTER_NODES, oc->nodemask);\n\t\tif (is_dump_unreclaim_slabs())\n\t\t\tdump_unreclaimable_slab();\n\t}\n\tif (sysctl_oom_dump_tasks)\n\t\tdump_tasks(oc->memcg, oc->nodemask);\n}"
  },
  {
    "function_name": "dump_tasks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
    "lines": "398-429",
    "snippet": "static void dump_tasks(struct mem_cgroup *memcg, const nodemask_t *nodemask)\n{\n\tstruct task_struct *p;\n\tstruct task_struct *task;\n\n\tpr_info(\"Tasks state (memory values in pages):\\n\");\n\tpr_info(\"[  pid  ]   uid  tgid total_vm      rss pgtables_bytes swapents oom_score_adj name\\n\");\n\trcu_read_lock();\n\tfor_each_process(p) {\n\t\tif (oom_unkillable_task(p, memcg, nodemask))\n\t\t\tcontinue;\n\n\t\ttask = find_lock_task_mm(p);\n\t\tif (!task) {\n\t\t\t/*\n\t\t\t * This is a kthread or all of p's threads have already\n\t\t\t * detached their mm's.  There's no need to report\n\t\t\t * them; they can't be oom killed anyway.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\tpr_info(\"[%7d] %5d %5d %8lu %8lu %8ld %8lu         %5hd %s\\n\",\n\t\t\ttask->pid, from_kuid(&init_user_ns, task_uid(task)),\n\t\t\ttask->tgid, task->mm->total_vm, get_mm_rss(task->mm),\n\t\t\tmm_pgtables_bytes(task->mm),\n\t\t\tget_mm_counter(task->mm, MM_SWAPENTS),\n\t\t\ttask->signal->oom_score_adj, task->comm);\n\t\ttask_unlock(task);\n\t}\n\trcu_read_unlock();\n}",
    "includes": [
      "#include <trace/events/oom.h>",
      "#include \"slab.h\"",
      "#include \"internal.h\"",
      "#include <asm/tlb.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/timex.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/oom.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "task"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"[%7d] %5d %5d %8lu %8lu %8ld %8lu         %5hd %s\\n\"",
            "task->pid",
            "from_kuid(&init_user_ns, task_uid(task))",
            "task->tgid",
            "task->mm->total_vm",
            "get_mm_rss(task->mm)",
            "mm_pgtables_bytes(task->mm)",
            "get_mm_counter(task->mm, MM_SWAPENTS)",
            "task->signal->oom_score_adj",
            "task->comm"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mm_counter",
          "args": [
            "task->mm",
            "MM_SWAPENTS"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_pgtables_bytes",
          "args": [
            "task->mm"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mm_rss",
          "args": [
            "task->mm"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "task_uid(task)"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_uid",
          "args": [
            "task"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_lock_task_mm",
          "args": [
            "p"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "find_lock_task_mm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
          "lines": "120-137",
          "snippet": "struct task_struct *find_lock_task_mm(struct task_struct *p)\n{\n\tstruct task_struct *t;\n\n\trcu_read_lock();\n\n\tfor_each_thread(p, t) {\n\t\ttask_lock(t);\n\t\tif (likely(t->mm))\n\t\t\tgoto found;\n\t\ttask_unlock(t);\n\t}\n\tt = NULL;\nfound:\n\trcu_read_unlock();\n\n\treturn t;\n}",
          "includes": [
            "#include <trace/events/oom.h>",
            "#include \"slab.h\"",
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/timex.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/oom.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstruct task_struct *find_lock_task_mm(struct task_struct *p)\n{\n\tstruct task_struct *t;\n\n\trcu_read_lock();\n\n\tfor_each_thread(p, t) {\n\t\ttask_lock(t);\n\t\tif (likely(t->mm))\n\t\t\tgoto found;\n\t\ttask_unlock(t);\n\t}\n\tt = NULL;\nfound:\n\trcu_read_unlock();\n\n\treturn t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "oom_unkillable_task",
          "args": [
            "p",
            "memcg",
            "nodemask"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "oom_unkillable_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
          "lines": "154-171",
          "snippet": "static bool oom_unkillable_task(struct task_struct *p,\n\t\tstruct mem_cgroup *memcg, const nodemask_t *nodemask)\n{\n\tif (is_global_init(p))\n\t\treturn true;\n\tif (p->flags & PF_KTHREAD)\n\t\treturn true;\n\n\t/* When mem_cgroup_out_of_memory() and p is not member of the group */\n\tif (memcg && !task_in_mem_cgroup(p, memcg))\n\t\treturn true;\n\n\t/* p may not have freeable memory in nodemask */\n\tif (!has_intersects_mems_allowed(p, nodemask))\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/oom.h>",
            "#include \"slab.h\"",
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/timex.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/oom.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstatic bool oom_unkillable_task(struct task_struct *p,\n\t\tstruct mem_cgroup *memcg, const nodemask_t *nodemask)\n{\n\tif (is_global_init(p))\n\t\treturn true;\n\tif (p->flags & PF_KTHREAD)\n\t\treturn true;\n\n\t/* When mem_cgroup_out_of_memory() and p is not member of the group */\n\tif (memcg && !task_in_mem_cgroup(p, memcg))\n\t\treturn true;\n\n\t/* p may not have freeable memory in nodemask */\n\tif (!has_intersects_mems_allowed(p, nodemask))\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"[  pid  ]   uid  tgid total_vm      rss pgtables_bytes swapents oom_score_adj name\\n\""
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Tasks state (memory values in pages):\\n\""
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstatic void dump_tasks(struct mem_cgroup *memcg, const nodemask_t *nodemask)\n{\n\tstruct task_struct *p;\n\tstruct task_struct *task;\n\n\tpr_info(\"Tasks state (memory values in pages):\\n\");\n\tpr_info(\"[  pid  ]   uid  tgid total_vm      rss pgtables_bytes swapents oom_score_adj name\\n\");\n\trcu_read_lock();\n\tfor_each_process(p) {\n\t\tif (oom_unkillable_task(p, memcg, nodemask))\n\t\t\tcontinue;\n\n\t\ttask = find_lock_task_mm(p);\n\t\tif (!task) {\n\t\t\t/*\n\t\t\t * This is a kthread or all of p's threads have already\n\t\t\t * detached their mm's.  There's no need to report\n\t\t\t * them; they can't be oom killed anyway.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\tpr_info(\"[%7d] %5d %5d %8lu %8lu %8ld %8lu         %5hd %s\\n\",\n\t\t\ttask->pid, from_kuid(&init_user_ns, task_uid(task)),\n\t\t\ttask->tgid, task->mm->total_vm, get_mm_rss(task->mm),\n\t\t\tmm_pgtables_bytes(task->mm),\n\t\t\tget_mm_counter(task->mm, MM_SWAPENTS),\n\t\t\ttask->signal->oom_score_adj, task->comm);\n\t\ttask_unlock(task);\n\t}\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "select_bad_process",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
    "lines": "370-385",
    "snippet": "static void select_bad_process(struct oom_control *oc)\n{\n\tif (is_memcg_oom(oc))\n\t\tmem_cgroup_scan_tasks(oc->memcg, oom_evaluate_task, oc);\n\telse {\n\t\tstruct task_struct *p;\n\n\t\trcu_read_lock();\n\t\tfor_each_process(p)\n\t\t\tif (oom_evaluate_task(p, oc))\n\t\t\t\tbreak;\n\t\trcu_read_unlock();\n\t}\n\n\toc->chosen_points = oc->chosen_points * 1000 / oc->totalpages;\n}",
    "includes": [
      "#include <trace/events/oom.h>",
      "#include \"slab.h\"",
      "#include \"internal.h\"",
      "#include <asm/tlb.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/timex.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/oom.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_scan_tasks",
          "args": [
            "oc->memcg",
            "oom_evaluate_task",
            "oc"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_scan_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1067-1089",
          "snippet": "int mem_cgroup_scan_tasks(struct mem_cgroup *memcg,\n\t\t\t  int (*fn)(struct task_struct *, void *), void *arg)\n{\n\tstruct mem_cgroup *iter;\n\tint ret = 0;\n\n\tBUG_ON(memcg == root_mem_cgroup);\n\n\tfor_each_mem_cgroup_tree(iter, memcg) {\n\t\tstruct css_task_iter it;\n\t\tstruct task_struct *task;\n\n\t\tcss_task_iter_start(&iter->css, 0, &it);\n\t\twhile (!ret && (task = css_task_iter_next(&it)))\n\t\t\tret = fn(task, arg);\n\t\tcss_task_iter_end(&it);\n\t\tif (ret) {\n\t\t\tmem_cgroup_iter_break(memcg, iter);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mem_cgroup *root_mem_cgroup",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nint mem_cgroup_scan_tasks(struct mem_cgroup *memcg,\n\t\t\t  int (*fn)(struct task_struct *, void *), void *arg)\n{\n\tstruct mem_cgroup *iter;\n\tint ret = 0;\n\n\tBUG_ON(memcg == root_mem_cgroup);\n\n\tfor_each_mem_cgroup_tree(iter, memcg) {\n\t\tstruct css_task_iter it;\n\t\tstruct task_struct *task;\n\n\t\tcss_task_iter_start(&iter->css, 0, &it);\n\t\twhile (!ret && (task = css_task_iter_next(&it)))\n\t\t\tret = fn(task, arg);\n\t\tcss_task_iter_end(&it);\n\t\tif (ret) {\n\t\t\tmem_cgroup_iter_break(memcg, iter);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_memcg_oom",
          "args": [
            "oc"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "is_memcg_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
          "lines": "148-151",
          "snippet": "static inline bool is_memcg_oom(struct oom_control *oc)\n{\n\treturn oc->memcg != NULL;\n}",
          "includes": [
            "#include <trace/events/oom.h>",
            "#include \"slab.h\"",
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/timex.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/oom.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstatic inline bool is_memcg_oom(struct oom_control *oc)\n{\n\treturn oc->memcg != NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstatic void select_bad_process(struct oom_control *oc)\n{\n\tif (is_memcg_oom(oc))\n\t\tmem_cgroup_scan_tasks(oc->memcg, oom_evaluate_task, oc);\n\telse {\n\t\tstruct task_struct *p;\n\n\t\trcu_read_lock();\n\t\tfor_each_process(p)\n\t\t\tif (oom_evaluate_task(p, oc))\n\t\t\t\tbreak;\n\t\trcu_read_unlock();\n\t}\n\n\toc->chosen_points = oc->chosen_points * 1000 / oc->totalpages;\n}"
  },
  {
    "function_name": "oom_evaluate_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
    "lines": "315-364",
    "snippet": "static int oom_evaluate_task(struct task_struct *task, void *arg)\n{\n\tstruct oom_control *oc = arg;\n\tunsigned long points;\n\n\tif (oom_unkillable_task(task, NULL, oc->nodemask))\n\t\tgoto next;\n\n\t/*\n\t * This task already has access to memory reserves and is being killed.\n\t * Don't allow any other task to have access to the reserves unless\n\t * the task has MMF_OOM_SKIP because chances that it would release\n\t * any memory is quite low.\n\t */\n\tif (!is_sysrq_oom(oc) && tsk_is_oom_victim(task)) {\n\t\tif (test_bit(MMF_OOM_SKIP, &task->signal->oom_mm->flags))\n\t\t\tgoto next;\n\t\tgoto abort;\n\t}\n\n\t/*\n\t * If task is allocating a lot of memory and has been marked to be\n\t * killed first if it triggers an oom, then select it.\n\t */\n\tif (oom_task_origin(task)) {\n\t\tpoints = ULONG_MAX;\n\t\tgoto select;\n\t}\n\n\tpoints = oom_badness(task, NULL, oc->nodemask, oc->totalpages);\n\tif (!points || points < oc->chosen_points)\n\t\tgoto next;\n\n\t/* Prefer thread group leaders for display purposes */\n\tif (points == oc->chosen_points && thread_group_leader(oc->chosen))\n\t\tgoto next;\nselect:\n\tif (oc->chosen)\n\t\tput_task_struct(oc->chosen);\n\tget_task_struct(task);\n\toc->chosen = task;\n\toc->chosen_points = points;\nnext:\n\treturn 0;\nabort:\n\tif (oc->chosen)\n\t\tput_task_struct(oc->chosen);\n\toc->chosen = (void *)-1UL;\n\treturn 1;\n}",
    "includes": [
      "#include <trace/events/oom.h>",
      "#include \"slab.h\"",
      "#include \"internal.h\"",
      "#include <asm/tlb.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/timex.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/oom.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "oc->chosen"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_struct",
          "args": [
            "task"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "oc->chosen"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread_group_leader",
          "args": [
            "oc->chosen"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oom_badness",
          "args": [
            "task",
            "NULL",
            "oc->nodemask",
            "oc->totalpages"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "oom_badness",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
          "lines": "203-246",
          "snippet": "unsigned long oom_badness(struct task_struct *p, struct mem_cgroup *memcg,\n\t\t\t  const nodemask_t *nodemask, unsigned long totalpages)\n{\n\tlong points;\n\tlong adj;\n\n\tif (oom_unkillable_task(p, memcg, nodemask))\n\t\treturn 0;\n\n\tp = find_lock_task_mm(p);\n\tif (!p)\n\t\treturn 0;\n\n\t/*\n\t * Do not even consider tasks which are explicitly marked oom\n\t * unkillable or have been already oom reaped or the are in\n\t * the middle of vfork\n\t */\n\tadj = (long)p->signal->oom_score_adj;\n\tif (adj == OOM_SCORE_ADJ_MIN ||\n\t\t\ttest_bit(MMF_OOM_SKIP, &p->mm->flags) ||\n\t\t\tin_vfork(p)) {\n\t\ttask_unlock(p);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * The baseline for the badness score is the proportion of RAM that each\n\t * task's rss, pagetable and swap space use.\n\t */\n\tpoints = get_mm_rss(p->mm) + get_mm_counter(p->mm, MM_SWAPENTS) +\n\t\tmm_pgtables_bytes(p->mm) / PAGE_SIZE;\n\ttask_unlock(p);\n\n\t/* Normalize to oom_score_adj units */\n\tadj *= totalpages / 1000;\n\tpoints += adj;\n\n\t/*\n\t * Never return 0 for an eligible task regardless of the root bonus and\n\t * oom_score_adj (oom_score_adj can't be OOM_SCORE_ADJ_MIN here).\n\t */\n\treturn points > 0 ? points : 1;\n}",
          "includes": [
            "#include <trace/events/oom.h>",
            "#include \"slab.h\"",
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/timex.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/oom.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nunsigned long oom_badness(struct task_struct *p, struct mem_cgroup *memcg,\n\t\t\t  const nodemask_t *nodemask, unsigned long totalpages)\n{\n\tlong points;\n\tlong adj;\n\n\tif (oom_unkillable_task(p, memcg, nodemask))\n\t\treturn 0;\n\n\tp = find_lock_task_mm(p);\n\tif (!p)\n\t\treturn 0;\n\n\t/*\n\t * Do not even consider tasks which are explicitly marked oom\n\t * unkillable or have been already oom reaped or the are in\n\t * the middle of vfork\n\t */\n\tadj = (long)p->signal->oom_score_adj;\n\tif (adj == OOM_SCORE_ADJ_MIN ||\n\t\t\ttest_bit(MMF_OOM_SKIP, &p->mm->flags) ||\n\t\t\tin_vfork(p)) {\n\t\ttask_unlock(p);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * The baseline for the badness score is the proportion of RAM that each\n\t * task's rss, pagetable and swap space use.\n\t */\n\tpoints = get_mm_rss(p->mm) + get_mm_counter(p->mm, MM_SWAPENTS) +\n\t\tmm_pgtables_bytes(p->mm) / PAGE_SIZE;\n\ttask_unlock(p);\n\n\t/* Normalize to oom_score_adj units */\n\tadj *= totalpages / 1000;\n\tpoints += adj;\n\n\t/*\n\t * Never return 0 for an eligible task regardless of the root bonus and\n\t * oom_score_adj (oom_score_adj can't be OOM_SCORE_ADJ_MIN here).\n\t */\n\treturn points > 0 ? points : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "oom_task_origin",
          "args": [
            "task"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "MMF_OOM_SKIP",
            "&task->signal->oom_mm->flags"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tsk_is_oom_victim",
          "args": [
            "task"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_sysrq_oom",
          "args": [
            "oc"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "is_sysrq_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
          "lines": "143-146",
          "snippet": "static inline bool is_sysrq_oom(struct oom_control *oc)\n{\n\treturn oc->order == -1;\n}",
          "includes": [
            "#include <trace/events/oom.h>",
            "#include \"slab.h\"",
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/timex.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/oom.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstatic inline bool is_sysrq_oom(struct oom_control *oc)\n{\n\treturn oc->order == -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "oom_unkillable_task",
          "args": [
            "task",
            "NULL",
            "oc->nodemask"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "oom_unkillable_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
          "lines": "154-171",
          "snippet": "static bool oom_unkillable_task(struct task_struct *p,\n\t\tstruct mem_cgroup *memcg, const nodemask_t *nodemask)\n{\n\tif (is_global_init(p))\n\t\treturn true;\n\tif (p->flags & PF_KTHREAD)\n\t\treturn true;\n\n\t/* When mem_cgroup_out_of_memory() and p is not member of the group */\n\tif (memcg && !task_in_mem_cgroup(p, memcg))\n\t\treturn true;\n\n\t/* p may not have freeable memory in nodemask */\n\tif (!has_intersects_mems_allowed(p, nodemask))\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/oom.h>",
            "#include \"slab.h\"",
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/timex.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/oom.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstatic bool oom_unkillable_task(struct task_struct *p,\n\t\tstruct mem_cgroup *memcg, const nodemask_t *nodemask)\n{\n\tif (is_global_init(p))\n\t\treturn true;\n\tif (p->flags & PF_KTHREAD)\n\t\treturn true;\n\n\t/* When mem_cgroup_out_of_memory() and p is not member of the group */\n\tif (memcg && !task_in_mem_cgroup(p, memcg))\n\t\treturn true;\n\n\t/* p may not have freeable memory in nodemask */\n\tif (!has_intersects_mems_allowed(p, nodemask))\n\t\treturn true;\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstatic int oom_evaluate_task(struct task_struct *task, void *arg)\n{\n\tstruct oom_control *oc = arg;\n\tunsigned long points;\n\n\tif (oom_unkillable_task(task, NULL, oc->nodemask))\n\t\tgoto next;\n\n\t/*\n\t * This task already has access to memory reserves and is being killed.\n\t * Don't allow any other task to have access to the reserves unless\n\t * the task has MMF_OOM_SKIP because chances that it would release\n\t * any memory is quite low.\n\t */\n\tif (!is_sysrq_oom(oc) && tsk_is_oom_victim(task)) {\n\t\tif (test_bit(MMF_OOM_SKIP, &task->signal->oom_mm->flags))\n\t\t\tgoto next;\n\t\tgoto abort;\n\t}\n\n\t/*\n\t * If task is allocating a lot of memory and has been marked to be\n\t * killed first if it triggers an oom, then select it.\n\t */\n\tif (oom_task_origin(task)) {\n\t\tpoints = ULONG_MAX;\n\t\tgoto select;\n\t}\n\n\tpoints = oom_badness(task, NULL, oc->nodemask, oc->totalpages);\n\tif (!points || points < oc->chosen_points)\n\t\tgoto next;\n\n\t/* Prefer thread group leaders for display purposes */\n\tif (points == oc->chosen_points && thread_group_leader(oc->chosen))\n\t\tgoto next;\nselect:\n\tif (oc->chosen)\n\t\tput_task_struct(oc->chosen);\n\tget_task_struct(task);\n\toc->chosen = task;\n\toc->chosen_points = points;\nnext:\n\treturn 0;\nabort:\n\tif (oc->chosen)\n\t\tput_task_struct(oc->chosen);\n\toc->chosen = (void *)-1UL;\n\treturn 1;\n}"
  },
  {
    "function_name": "constrained_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
    "lines": "258-313",
    "snippet": "static enum oom_constraint constrained_alloc(struct oom_control *oc)\n{\n\tstruct zone *zone;\n\tstruct zoneref *z;\n\tenum zone_type high_zoneidx = gfp_zone(oc->gfp_mask);\n\tbool cpuset_limited = false;\n\tint nid;\n\n\tif (is_memcg_oom(oc)) {\n\t\toc->totalpages = mem_cgroup_get_max(oc->memcg) ?: 1;\n\t\treturn CONSTRAINT_MEMCG;\n\t}\n\n\t/* Default to all available memory */\n\toc->totalpages = totalram_pages + total_swap_pages;\n\n\tif (!IS_ENABLED(CONFIG_NUMA))\n\t\treturn CONSTRAINT_NONE;\n\n\tif (!oc->zonelist)\n\t\treturn CONSTRAINT_NONE;\n\t/*\n\t * Reach here only when __GFP_NOFAIL is used. So, we should avoid\n\t * to kill current.We have to random task kill in this case.\n\t * Hopefully, CONSTRAINT_THISNODE...but no way to handle it, now.\n\t */\n\tif (oc->gfp_mask & __GFP_THISNODE)\n\t\treturn CONSTRAINT_NONE;\n\n\t/*\n\t * This is not a __GFP_THISNODE allocation, so a truncated nodemask in\n\t * the page allocator means a mempolicy is in effect.  Cpuset policy\n\t * is enforced in get_page_from_freelist().\n\t */\n\tif (oc->nodemask &&\n\t    !nodes_subset(node_states[N_MEMORY], *oc->nodemask)) {\n\t\toc->totalpages = total_swap_pages;\n\t\tfor_each_node_mask(nid, *oc->nodemask)\n\t\t\toc->totalpages += node_spanned_pages(nid);\n\t\treturn CONSTRAINT_MEMORY_POLICY;\n\t}\n\n\t/* Check this allocation failure is caused by cpuset's wall function */\n\tfor_each_zone_zonelist_nodemask(zone, z, oc->zonelist,\n\t\t\thigh_zoneidx, oc->nodemask)\n\t\tif (!cpuset_zone_allowed(zone, oc->gfp_mask))\n\t\t\tcpuset_limited = true;\n\n\tif (cpuset_limited) {\n\t\toc->totalpages = total_swap_pages;\n\t\tfor_each_node_mask(nid, cpuset_current_mems_allowed)\n\t\t\toc->totalpages += node_spanned_pages(nid);\n\t\treturn CONSTRAINT_CPUSET;\n\t}\n\treturn CONSTRAINT_NONE;\n}",
    "includes": [
      "#include <trace/events/oom.h>",
      "#include \"slab.h\"",
      "#include \"internal.h\"",
      "#include <asm/tlb.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/timex.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/oom.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "node_spanned_pages",
          "args": [
            "nid"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_node_mask",
          "args": [
            "nid",
            "cpuset_current_mems_allowed"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuset_zone_allowed",
          "args": [
            "zone",
            "oc->gfp_mask"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_zone_zonelist_nodemask",
          "args": [
            "zone",
            "z",
            "oc->zonelist",
            "high_zoneidx",
            "oc->nodemask"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_spanned_pages",
          "args": [
            "nid"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_node_mask",
          "args": [
            "nid",
            "*oc->nodemask"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes_subset",
          "args": [
            "node_states[N_MEMORY]",
            "*oc->nodemask"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_NUMA"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_get_max",
          "args": [
            "oc->memcg"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_get_max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1356-1371",
          "snippet": "unsigned long mem_cgroup_get_max(struct mem_cgroup *memcg)\n{\n\tunsigned long max;\n\n\tmax = memcg->memory.max;\n\tif (mem_cgroup_swappiness(memcg)) {\n\t\tunsigned long memsw_max;\n\t\tunsigned long swap_max;\n\n\t\tmemsw_max = memcg->memsw.max;\n\t\tswap_max = memcg->swap.max;\n\t\tswap_max = min(swap_max, (unsigned long)total_swap_pages);\n\t\tmax = min(max + swap_max, memsw_max);\n\t}\n\treturn max;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nunsigned long mem_cgroup_get_max(struct mem_cgroup *memcg)\n{\n\tunsigned long max;\n\n\tmax = memcg->memory.max;\n\tif (mem_cgroup_swappiness(memcg)) {\n\t\tunsigned long memsw_max;\n\t\tunsigned long swap_max;\n\n\t\tmemsw_max = memcg->memsw.max;\n\t\tswap_max = memcg->swap.max;\n\t\tswap_max = min(swap_max, (unsigned long)total_swap_pages);\n\t\tmax = min(max + swap_max, memsw_max);\n\t}\n\treturn max;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_memcg_oom",
          "args": [
            "oc"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "is_memcg_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
          "lines": "148-151",
          "snippet": "static inline bool is_memcg_oom(struct oom_control *oc)\n{\n\treturn oc->memcg != NULL;\n}",
          "includes": [
            "#include <trace/events/oom.h>",
            "#include \"slab.h\"",
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/timex.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/oom.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstatic inline bool is_memcg_oom(struct oom_control *oc)\n{\n\treturn oc->memcg != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfp_zone",
          "args": [
            "oc->gfp_mask"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstatic enum oom_constraint constrained_alloc(struct oom_control *oc)\n{\n\tstruct zone *zone;\n\tstruct zoneref *z;\n\tenum zone_type high_zoneidx = gfp_zone(oc->gfp_mask);\n\tbool cpuset_limited = false;\n\tint nid;\n\n\tif (is_memcg_oom(oc)) {\n\t\toc->totalpages = mem_cgroup_get_max(oc->memcg) ?: 1;\n\t\treturn CONSTRAINT_MEMCG;\n\t}\n\n\t/* Default to all available memory */\n\toc->totalpages = totalram_pages + total_swap_pages;\n\n\tif (!IS_ENABLED(CONFIG_NUMA))\n\t\treturn CONSTRAINT_NONE;\n\n\tif (!oc->zonelist)\n\t\treturn CONSTRAINT_NONE;\n\t/*\n\t * Reach here only when __GFP_NOFAIL is used. So, we should avoid\n\t * to kill current.We have to random task kill in this case.\n\t * Hopefully, CONSTRAINT_THISNODE...but no way to handle it, now.\n\t */\n\tif (oc->gfp_mask & __GFP_THISNODE)\n\t\treturn CONSTRAINT_NONE;\n\n\t/*\n\t * This is not a __GFP_THISNODE allocation, so a truncated nodemask in\n\t * the page allocator means a mempolicy is in effect.  Cpuset policy\n\t * is enforced in get_page_from_freelist().\n\t */\n\tif (oc->nodemask &&\n\t    !nodes_subset(node_states[N_MEMORY], *oc->nodemask)) {\n\t\toc->totalpages = total_swap_pages;\n\t\tfor_each_node_mask(nid, *oc->nodemask)\n\t\t\toc->totalpages += node_spanned_pages(nid);\n\t\treturn CONSTRAINT_MEMORY_POLICY;\n\t}\n\n\t/* Check this allocation failure is caused by cpuset's wall function */\n\tfor_each_zone_zonelist_nodemask(zone, z, oc->zonelist,\n\t\t\thigh_zoneidx, oc->nodemask)\n\t\tif (!cpuset_zone_allowed(zone, oc->gfp_mask))\n\t\t\tcpuset_limited = true;\n\n\tif (cpuset_limited) {\n\t\toc->totalpages = total_swap_pages;\n\t\tfor_each_node_mask(nid, cpuset_current_mems_allowed)\n\t\t\toc->totalpages += node_spanned_pages(nid);\n\t\treturn CONSTRAINT_CPUSET;\n\t}\n\treturn CONSTRAINT_NONE;\n}"
  },
  {
    "function_name": "oom_badness",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
    "lines": "203-246",
    "snippet": "unsigned long oom_badness(struct task_struct *p, struct mem_cgroup *memcg,\n\t\t\t  const nodemask_t *nodemask, unsigned long totalpages)\n{\n\tlong points;\n\tlong adj;\n\n\tif (oom_unkillable_task(p, memcg, nodemask))\n\t\treturn 0;\n\n\tp = find_lock_task_mm(p);\n\tif (!p)\n\t\treturn 0;\n\n\t/*\n\t * Do not even consider tasks which are explicitly marked oom\n\t * unkillable or have been already oom reaped or the are in\n\t * the middle of vfork\n\t */\n\tadj = (long)p->signal->oom_score_adj;\n\tif (adj == OOM_SCORE_ADJ_MIN ||\n\t\t\ttest_bit(MMF_OOM_SKIP, &p->mm->flags) ||\n\t\t\tin_vfork(p)) {\n\t\ttask_unlock(p);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * The baseline for the badness score is the proportion of RAM that each\n\t * task's rss, pagetable and swap space use.\n\t */\n\tpoints = get_mm_rss(p->mm) + get_mm_counter(p->mm, MM_SWAPENTS) +\n\t\tmm_pgtables_bytes(p->mm) / PAGE_SIZE;\n\ttask_unlock(p);\n\n\t/* Normalize to oom_score_adj units */\n\tadj *= totalpages / 1000;\n\tpoints += adj;\n\n\t/*\n\t * Never return 0 for an eligible task regardless of the root bonus and\n\t * oom_score_adj (oom_score_adj can't be OOM_SCORE_ADJ_MIN here).\n\t */\n\treturn points > 0 ? points : 1;\n}",
    "includes": [
      "#include <trace/events/oom.h>",
      "#include \"slab.h\"",
      "#include \"internal.h\"",
      "#include <asm/tlb.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/timex.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/oom.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "p"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_pgtables_bytes",
          "args": [
            "p->mm"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mm_counter",
          "args": [
            "p->mm",
            "MM_SWAPENTS"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mm_rss",
          "args": [
            "p->mm"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "p"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_vfork",
          "args": [
            "p"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "MMF_OOM_SKIP",
            "&p->mm->flags"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_lock_task_mm",
          "args": [
            "p"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "find_lock_task_mm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
          "lines": "120-137",
          "snippet": "struct task_struct *find_lock_task_mm(struct task_struct *p)\n{\n\tstruct task_struct *t;\n\n\trcu_read_lock();\n\n\tfor_each_thread(p, t) {\n\t\ttask_lock(t);\n\t\tif (likely(t->mm))\n\t\t\tgoto found;\n\t\ttask_unlock(t);\n\t}\n\tt = NULL;\nfound:\n\trcu_read_unlock();\n\n\treturn t;\n}",
          "includes": [
            "#include <trace/events/oom.h>",
            "#include \"slab.h\"",
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/timex.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/oom.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstruct task_struct *find_lock_task_mm(struct task_struct *p)\n{\n\tstruct task_struct *t;\n\n\trcu_read_lock();\n\n\tfor_each_thread(p, t) {\n\t\ttask_lock(t);\n\t\tif (likely(t->mm))\n\t\t\tgoto found;\n\t\ttask_unlock(t);\n\t}\n\tt = NULL;\nfound:\n\trcu_read_unlock();\n\n\treturn t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "oom_unkillable_task",
          "args": [
            "p",
            "memcg",
            "nodemask"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "oom_unkillable_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
          "lines": "154-171",
          "snippet": "static bool oom_unkillable_task(struct task_struct *p,\n\t\tstruct mem_cgroup *memcg, const nodemask_t *nodemask)\n{\n\tif (is_global_init(p))\n\t\treturn true;\n\tif (p->flags & PF_KTHREAD)\n\t\treturn true;\n\n\t/* When mem_cgroup_out_of_memory() and p is not member of the group */\n\tif (memcg && !task_in_mem_cgroup(p, memcg))\n\t\treturn true;\n\n\t/* p may not have freeable memory in nodemask */\n\tif (!has_intersects_mems_allowed(p, nodemask))\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/oom.h>",
            "#include \"slab.h\"",
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/timex.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/oom.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstatic bool oom_unkillable_task(struct task_struct *p,\n\t\tstruct mem_cgroup *memcg, const nodemask_t *nodemask)\n{\n\tif (is_global_init(p))\n\t\treturn true;\n\tif (p->flags & PF_KTHREAD)\n\t\treturn true;\n\n\t/* When mem_cgroup_out_of_memory() and p is not member of the group */\n\tif (memcg && !task_in_mem_cgroup(p, memcg))\n\t\treturn true;\n\n\t/* p may not have freeable memory in nodemask */\n\tif (!has_intersects_mems_allowed(p, nodemask))\n\t\treturn true;\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nunsigned long oom_badness(struct task_struct *p, struct mem_cgroup *memcg,\n\t\t\t  const nodemask_t *nodemask, unsigned long totalpages)\n{\n\tlong points;\n\tlong adj;\n\n\tif (oom_unkillable_task(p, memcg, nodemask))\n\t\treturn 0;\n\n\tp = find_lock_task_mm(p);\n\tif (!p)\n\t\treturn 0;\n\n\t/*\n\t * Do not even consider tasks which are explicitly marked oom\n\t * unkillable or have been already oom reaped or the are in\n\t * the middle of vfork\n\t */\n\tadj = (long)p->signal->oom_score_adj;\n\tif (adj == OOM_SCORE_ADJ_MIN ||\n\t\t\ttest_bit(MMF_OOM_SKIP, &p->mm->flags) ||\n\t\t\tin_vfork(p)) {\n\t\ttask_unlock(p);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * The baseline for the badness score is the proportion of RAM that each\n\t * task's rss, pagetable and swap space use.\n\t */\n\tpoints = get_mm_rss(p->mm) + get_mm_counter(p->mm, MM_SWAPENTS) +\n\t\tmm_pgtables_bytes(p->mm) / PAGE_SIZE;\n\ttask_unlock(p);\n\n\t/* Normalize to oom_score_adj units */\n\tadj *= totalpages / 1000;\n\tpoints += adj;\n\n\t/*\n\t * Never return 0 for an eligible task regardless of the root bonus and\n\t * oom_score_adj (oom_score_adj can't be OOM_SCORE_ADJ_MIN here).\n\t */\n\treturn points > 0 ? points : 1;\n}"
  },
  {
    "function_name": "is_dump_unreclaim_slabs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
    "lines": "177-190",
    "snippet": "static bool is_dump_unreclaim_slabs(void)\n{\n\tunsigned long nr_lru;\n\n\tnr_lru = global_node_page_state(NR_ACTIVE_ANON) +\n\t\t global_node_page_state(NR_INACTIVE_ANON) +\n\t\t global_node_page_state(NR_ACTIVE_FILE) +\n\t\t global_node_page_state(NR_INACTIVE_FILE) +\n\t\t global_node_page_state(NR_ISOLATED_ANON) +\n\t\t global_node_page_state(NR_ISOLATED_FILE) +\n\t\t global_node_page_state(NR_UNEVICTABLE);\n\n\treturn (global_node_page_state(NR_SLAB_UNRECLAIMABLE) > nr_lru);\n}",
    "includes": [
      "#include <trace/events/oom.h>",
      "#include \"slab.h\"",
      "#include \"internal.h\"",
      "#include <asm/tlb.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/timex.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/oom.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "global_node_page_state",
          "args": [
            "NR_SLAB_UNRECLAIMABLE"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_node_page_state",
          "args": [
            "NR_UNEVICTABLE"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_node_page_state",
          "args": [
            "NR_ISOLATED_FILE"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_node_page_state",
          "args": [
            "NR_ISOLATED_ANON"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_node_page_state",
          "args": [
            "NR_INACTIVE_FILE"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_node_page_state",
          "args": [
            "NR_ACTIVE_FILE"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_node_page_state",
          "args": [
            "NR_INACTIVE_ANON"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_node_page_state",
          "args": [
            "NR_ACTIVE_ANON"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstatic bool is_dump_unreclaim_slabs(void)\n{\n\tunsigned long nr_lru;\n\n\tnr_lru = global_node_page_state(NR_ACTIVE_ANON) +\n\t\t global_node_page_state(NR_INACTIVE_ANON) +\n\t\t global_node_page_state(NR_ACTIVE_FILE) +\n\t\t global_node_page_state(NR_INACTIVE_FILE) +\n\t\t global_node_page_state(NR_ISOLATED_ANON) +\n\t\t global_node_page_state(NR_ISOLATED_FILE) +\n\t\t global_node_page_state(NR_UNEVICTABLE);\n\n\treturn (global_node_page_state(NR_SLAB_UNRECLAIMABLE) > nr_lru);\n}"
  },
  {
    "function_name": "oom_unkillable_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
    "lines": "154-171",
    "snippet": "static bool oom_unkillable_task(struct task_struct *p,\n\t\tstruct mem_cgroup *memcg, const nodemask_t *nodemask)\n{\n\tif (is_global_init(p))\n\t\treturn true;\n\tif (p->flags & PF_KTHREAD)\n\t\treturn true;\n\n\t/* When mem_cgroup_out_of_memory() and p is not member of the group */\n\tif (memcg && !task_in_mem_cgroup(p, memcg))\n\t\treturn true;\n\n\t/* p may not have freeable memory in nodemask */\n\tif (!has_intersects_mems_allowed(p, nodemask))\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include <trace/events/oom.h>",
      "#include \"slab.h\"",
      "#include \"internal.h\"",
      "#include <asm/tlb.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/timex.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/oom.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "has_intersects_mems_allowed",
          "args": [
            "p",
            "nodemask"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "has_intersects_mems_allowed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
          "lines": "107-111",
          "snippet": "static bool has_intersects_mems_allowed(struct task_struct *tsk,\n\t\t\t\t\tconst nodemask_t *mask)\n{\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/oom.h>",
            "#include \"slab.h\"",
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/timex.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/oom.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstatic bool has_intersects_mems_allowed(struct task_struct *tsk,\n\t\t\t\t\tconst nodemask_t *mask)\n{\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_in_mem_cgroup",
          "args": [
            "p",
            "memcg"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "task_in_mem_cgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1171-1195",
          "snippet": "bool task_in_mem_cgroup(struct task_struct *task, struct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup *task_memcg;\n\tstruct task_struct *p;\n\tbool ret;\n\n\tp = find_lock_task_mm(task);\n\tif (p) {\n\t\ttask_memcg = get_mem_cgroup_from_mm(p->mm);\n\t\ttask_unlock(p);\n\t} else {\n\t\t/*\n\t\t * All threads may have already detached their mm's, but the oom\n\t\t * killer still needs to detect if they have already been oom\n\t\t * killed to prevent needlessly killing additional tasks.\n\t\t */\n\t\trcu_read_lock();\n\t\ttask_memcg = mem_cgroup_from_task(task);\n\t\tcss_get(&task_memcg->css);\n\t\trcu_read_unlock();\n\t}\n\tret = mem_cgroup_is_descendant(task_memcg, memcg);\n\tcss_put(&task_memcg->css);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nbool task_in_mem_cgroup(struct task_struct *task, struct mem_cgroup *memcg)\n{\n\tstruct mem_cgroup *task_memcg;\n\tstruct task_struct *p;\n\tbool ret;\n\n\tp = find_lock_task_mm(task);\n\tif (p) {\n\t\ttask_memcg = get_mem_cgroup_from_mm(p->mm);\n\t\ttask_unlock(p);\n\t} else {\n\t\t/*\n\t\t * All threads may have already detached their mm's, but the oom\n\t\t * killer still needs to detect if they have already been oom\n\t\t * killed to prevent needlessly killing additional tasks.\n\t\t */\n\t\trcu_read_lock();\n\t\ttask_memcg = mem_cgroup_from_task(task);\n\t\tcss_get(&task_memcg->css);\n\t\trcu_read_unlock();\n\t}\n\tret = mem_cgroup_is_descendant(task_memcg, memcg);\n\tcss_put(&task_memcg->css);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_global_init",
          "args": [
            "p"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstatic bool oom_unkillable_task(struct task_struct *p,\n\t\tstruct mem_cgroup *memcg, const nodemask_t *nodemask)\n{\n\tif (is_global_init(p))\n\t\treturn true;\n\tif (p->flags & PF_KTHREAD)\n\t\treturn true;\n\n\t/* When mem_cgroup_out_of_memory() and p is not member of the group */\n\tif (memcg && !task_in_mem_cgroup(p, memcg))\n\t\treturn true;\n\n\t/* p may not have freeable memory in nodemask */\n\tif (!has_intersects_mems_allowed(p, nodemask))\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "is_memcg_oom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
    "lines": "148-151",
    "snippet": "static inline bool is_memcg_oom(struct oom_control *oc)\n{\n\treturn oc->memcg != NULL;\n}",
    "includes": [
      "#include <trace/events/oom.h>",
      "#include \"slab.h\"",
      "#include \"internal.h\"",
      "#include <asm/tlb.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/timex.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/oom.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstatic inline bool is_memcg_oom(struct oom_control *oc)\n{\n\treturn oc->memcg != NULL;\n}"
  },
  {
    "function_name": "is_sysrq_oom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
    "lines": "143-146",
    "snippet": "static inline bool is_sysrq_oom(struct oom_control *oc)\n{\n\treturn oc->order == -1;\n}",
    "includes": [
      "#include <trace/events/oom.h>",
      "#include \"slab.h\"",
      "#include \"internal.h\"",
      "#include <asm/tlb.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/timex.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/oom.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstatic inline bool is_sysrq_oom(struct oom_control *oc)\n{\n\treturn oc->order == -1;\n}"
  },
  {
    "function_name": "find_lock_task_mm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
    "lines": "120-137",
    "snippet": "struct task_struct *find_lock_task_mm(struct task_struct *p)\n{\n\tstruct task_struct *t;\n\n\trcu_read_lock();\n\n\tfor_each_thread(p, t) {\n\t\ttask_lock(t);\n\t\tif (likely(t->mm))\n\t\t\tgoto found;\n\t\ttask_unlock(t);\n\t}\n\tt = NULL;\nfound:\n\trcu_read_unlock();\n\n\treturn t;\n}",
    "includes": [
      "#include <trace/events/oom.h>",
      "#include \"slab.h\"",
      "#include \"internal.h\"",
      "#include <asm/tlb.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/timex.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/oom.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "t"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "t->mm"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_lock",
          "args": [
            "t"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_thread",
          "args": [
            "p",
            "t"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstruct task_struct *find_lock_task_mm(struct task_struct *p)\n{\n\tstruct task_struct *t;\n\n\trcu_read_lock();\n\n\tfor_each_thread(p, t) {\n\t\ttask_lock(t);\n\t\tif (likely(t->mm))\n\t\t\tgoto found;\n\t\ttask_unlock(t);\n\t}\n\tt = NULL;\nfound:\n\trcu_read_unlock();\n\n\treturn t;\n}"
  },
  {
    "function_name": "has_intersects_mems_allowed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
    "lines": "107-111",
    "snippet": "static bool has_intersects_mems_allowed(struct task_struct *tsk,\n\t\t\t\t\tconst nodemask_t *mask)\n{\n\treturn true;\n}",
    "includes": [
      "#include <trace/events/oom.h>",
      "#include \"slab.h\"",
      "#include \"internal.h\"",
      "#include <asm/tlb.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/timex.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/oom.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstatic bool has_intersects_mems_allowed(struct task_struct *tsk,\n\t\t\t\t\tconst nodemask_t *mask)\n{\n\treturn true;\n}"
  },
  {
    "function_name": "has_intersects_mems_allowed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
    "lines": "76-105",
    "snippet": "static bool has_intersects_mems_allowed(struct task_struct *start,\n\t\t\t\t\tconst nodemask_t *mask)\n{\n\tstruct task_struct *tsk;\n\tbool ret = false;\n\n\trcu_read_lock();\n\tfor_each_thread(start, tsk) {\n\t\tif (mask) {\n\t\t\t/*\n\t\t\t * If this is a mempolicy constrained oom, tsk's\n\t\t\t * cpuset is irrelevant.  Only return true if its\n\t\t\t * mempolicy intersects current, otherwise it may be\n\t\t\t * needlessly killed.\n\t\t\t */\n\t\t\tret = mempolicy_nodemask_intersects(tsk, mask);\n\t\t} else {\n\t\t\t/*\n\t\t\t * This is not a mempolicy constrained oom, so only\n\t\t\t * check the mems of tsk's cpuset.\n\t\t\t */\n\t\t\tret = cpuset_mems_allowed_intersects(current, tsk);\n\t\t}\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/oom.h>",
      "#include \"slab.h\"",
      "#include \"internal.h\"",
      "#include <asm/tlb.h>",
      "#include <linux/mmu_notifier.h>",
      "#include <linux/init.h>",
      "#include <linux/kthread.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/timex.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/err.h>",
      "#include <linux/mm.h>",
      "#include <linux/oom.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuset_mems_allowed_intersects",
          "args": [
            "current",
            "tsk"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mempolicy_nodemask_intersects",
          "args": [
            "tsk",
            "mask"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "mempolicy_nodemask_intersects",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mempolicy.c",
          "lines": "1947-1979",
          "snippet": "bool mempolicy_nodemask_intersects(struct task_struct *tsk,\n\t\t\t\t\tconst nodemask_t *mask)\n{\n\tstruct mempolicy *mempolicy;\n\tbool ret = true;\n\n\tif (!mask)\n\t\treturn ret;\n\ttask_lock(tsk);\n\tmempolicy = tsk->mempolicy;\n\tif (!mempolicy)\n\t\tgoto out;\n\n\tswitch (mempolicy->mode) {\n\tcase MPOL_PREFERRED:\n\t\t/*\n\t\t * MPOL_PREFERRED and MPOL_F_LOCAL are only preferred nodes to\n\t\t * allocate from, they may fallback to other nodes when oom.\n\t\t * Thus, it's possible for tsk to have allocated memory from\n\t\t * nodes in mask.\n\t\t */\n\t\tbreak;\n\tcase MPOL_BIND:\n\tcase MPOL_INTERLEAVE:\n\t\tret = nodes_intersects(mempolicy->v.nodes, *mask);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\nout:\n\ttask_unlock(tsk);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/swapops.h>",
            "#include <linux/printk.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/migrate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/swap.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/compat.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <asm/tlbflush.h>\n#include <linux/swapops.h>\n#include <linux/printk.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mm_inline.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/migrate.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/swap.h>\n#include <linux/ptrace.h>\n#include <linux/compat.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/cpuset.h>\n#include <linux/nodemask.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/hugetlb.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n\nbool mempolicy_nodemask_intersects(struct task_struct *tsk,\n\t\t\t\t\tconst nodemask_t *mask)\n{\n\tstruct mempolicy *mempolicy;\n\tbool ret = true;\n\n\tif (!mask)\n\t\treturn ret;\n\ttask_lock(tsk);\n\tmempolicy = tsk->mempolicy;\n\tif (!mempolicy)\n\t\tgoto out;\n\n\tswitch (mempolicy->mode) {\n\tcase MPOL_PREFERRED:\n\t\t/*\n\t\t * MPOL_PREFERRED and MPOL_F_LOCAL are only preferred nodes to\n\t\t * allocate from, they may fallback to other nodes when oom.\n\t\t * Thus, it's possible for tsk to have allocated memory from\n\t\t * nodes in mask.\n\t\t */\n\t\tbreak;\n\tcase MPOL_BIND:\n\tcase MPOL_INTERLEAVE:\n\t\tret = nodes_intersects(mempolicy->v.nodes, *mask);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\nout:\n\ttask_unlock(tsk);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_thread",
          "args": [
            "start",
            "tsk"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nstatic bool has_intersects_mems_allowed(struct task_struct *start,\n\t\t\t\t\tconst nodemask_t *mask)\n{\n\tstruct task_struct *tsk;\n\tbool ret = false;\n\n\trcu_read_lock();\n\tfor_each_thread(start, tsk) {\n\t\tif (mask) {\n\t\t\t/*\n\t\t\t * If this is a mempolicy constrained oom, tsk's\n\t\t\t * cpuset is irrelevant.  Only return true if its\n\t\t\t * mempolicy intersects current, otherwise it may be\n\t\t\t * needlessly killed.\n\t\t\t */\n\t\t\tret = mempolicy_nodemask_intersects(tsk, mask);\n\t\t} else {\n\t\t\t/*\n\t\t\t * This is not a mempolicy constrained oom, so only\n\t\t\t * check the mems of tsk's cpuset.\n\t\t\t */\n\t\t\tret = cpuset_mems_allowed_intersects(current, tsk);\n\t\t}\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}"
  }
]