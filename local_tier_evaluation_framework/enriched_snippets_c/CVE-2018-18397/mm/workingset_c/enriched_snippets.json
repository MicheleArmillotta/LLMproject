[
  {
    "function_name": "workingset_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/workingset.c",
    "lines": "537-571",
    "snippet": "static int __init workingset_init(void)\n{\n\tunsigned int timestamp_bits;\n\tunsigned int max_order;\n\tint ret;\n\n\tBUILD_BUG_ON(BITS_PER_LONG < EVICTION_SHIFT);\n\t/*\n\t * Calculate the eviction bucket size to cover the longest\n\t * actionable refault distance, which is currently half of\n\t * memory (totalram_pages/2). However, memory hotplug may add\n\t * some more pages at runtime, so keep working with up to\n\t * double the initial memory by using totalram_pages as-is.\n\t */\n\ttimestamp_bits = BITS_PER_LONG - EVICTION_SHIFT;\n\tmax_order = fls_long(totalram_pages - 1);\n\tif (max_order > timestamp_bits)\n\t\tbucket_order = max_order - timestamp_bits;\n\tpr_info(\"workingset: timestamp_bits=%d max_order=%d bucket_order=%u\\n\",\n\t       timestamp_bits, max_order, bucket_order);\n\n\tret = prealloc_shrinker(&workingset_shadow_shrinker);\n\tif (ret)\n\t\tgoto err;\n\tret = __list_lru_init(&shadow_nodes, true, &shadow_nodes_key,\n\t\t\t      &workingset_shadow_shrinker);\n\tif (ret)\n\t\tgoto err_list_lru;\n\tregister_shrinker_prepared(&workingset_shadow_shrinker);\n\treturn 0;\nerr_list_lru:\n\tfree_prealloced_shrinker(&workingset_shadow_shrinker);\nerr:\n\treturn ret;\n}",
    "includes": [
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/memcontrol.h>"
    ],
    "macros_used": [
      "#define EVICTION_SHIFT\t((BITS_PER_LONG - BITS_PER_XA_VALUE) +\t\\\n\t\t\t 1 + NODES_SHIFT + MEM_CGROUP_ID_SHIFT)"
    ],
    "globals_used": [
      "static unsigned int bucket_order",
      "static struct list_lru shadow_nodes;",
      "static struct shrinker workingset_shadow_shrinker = {\n\t.count_objects = count_shadow_nodes,\n\t.scan_objects = scan_shadow_nodes,\n\t.seeks = 0, /* ->count reports only fully expendable nodes */\n\t.flags = SHRINKER_NUMA_AWARE | SHRINKER_MEMCG_AWARE,\n};",
      "static struct lock_class_key shadow_nodes_key;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_prealloced_shrinker",
          "args": [
            "&workingset_shadow_shrinker"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "free_prealloced_shrinker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "395-405",
          "snippet": "void free_prealloced_shrinker(struct shrinker *shrinker)\n{\n\tif (!shrinker->nr_deferred)\n\t\treturn;\n\n\tif (shrinker->flags & SHRINKER_MEMCG_AWARE)\n\t\tunregister_memcg_shrinker(shrinker);\n\n\tkfree(shrinker->nr_deferred);\n\tshrinker->nr_deferred = NULL;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid free_prealloced_shrinker(struct shrinker *shrinker)\n{\n\tif (!shrinker->nr_deferred)\n\t\treturn;\n\n\tif (shrinker->flags & SHRINKER_MEMCG_AWARE)\n\t\tunregister_memcg_shrinker(shrinker);\n\n\tkfree(shrinker->nr_deferred);\n\tshrinker->nr_deferred = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_shrinker_prepared",
          "args": [
            "&workingset_shadow_shrinker"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "register_shrinker_prepared",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "407-416",
          "snippet": "void register_shrinker_prepared(struct shrinker *shrinker)\n{\n\tdown_write(&shrinker_rwsem);\n\tlist_add_tail(&shrinker->list, &shrinker_list);\n#ifdef CONFIG_MEMCG_KMEM\n\tif (shrinker->flags & SHRINKER_MEMCG_AWARE)\n\t\tidr_replace(&shrinker_idr, shrinker, shrinker->id);\n#endif\n\tup_write(&shrinker_rwsem);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(shrinker_list);",
            "static DECLARE_RWSEM(shrinker_rwsem);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic LIST_HEAD(shrinker_list);\nstatic DECLARE_RWSEM(shrinker_rwsem);\n\nvoid register_shrinker_prepared(struct shrinker *shrinker)\n{\n\tdown_write(&shrinker_rwsem);\n\tlist_add_tail(&shrinker->list, &shrinker_list);\n#ifdef CONFIG_MEMCG_KMEM\n\tif (shrinker->flags & SHRINKER_MEMCG_AWARE)\n\t\tidr_replace(&shrinker_idr, shrinker, shrinker->id);\n#endif\n\tup_write(&shrinker_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__list_lru_init",
          "args": [
            "&shadow_nodes",
            "true",
            "&shadow_nodes_key",
            "&workingset_shadow_shrinker"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "__list_lru_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
          "lines": "600-638",
          "snippet": "int __list_lru_init(struct list_lru *lru, bool memcg_aware,\n\t\t    struct lock_class_key *key, struct shrinker *shrinker)\n{\n\tint i;\n\tsize_t size = sizeof(*lru->node) * nr_node_ids;\n\tint err = -ENOMEM;\n\n#ifdef CONFIG_MEMCG_KMEM\n\tif (shrinker)\n\t\tlru->shrinker_id = shrinker->id;\n\telse\n\t\tlru->shrinker_id = -1;\n#endif\n\tmemcg_get_cache_ids();\n\n\tlru->node = kzalloc(size, GFP_KERNEL);\n\tif (!lru->node)\n\t\tgoto out;\n\n\tfor_each_node(i) {\n\t\tspin_lock_init(&lru->node[i].lock);\n\t\tif (key)\n\t\t\tlockdep_set_class(&lru->node[i].lock, key);\n\t\tinit_one_lru(&lru->node[i].lru);\n\t}\n\n\terr = memcg_init_list_lru(lru, memcg_aware);\n\tif (err) {\n\t\tkfree(lru->node);\n\t\t/* Do this so a list_lru_destroy() doesn't crash: */\n\t\tlru->node = NULL;\n\t\tgoto out;\n\t}\n\n\tlist_lru_register(lru);\nout:\n\tmemcg_put_cache_ids();\n\treturn err;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint __list_lru_init(struct list_lru *lru, bool memcg_aware,\n\t\t    struct lock_class_key *key, struct shrinker *shrinker)\n{\n\tint i;\n\tsize_t size = sizeof(*lru->node) * nr_node_ids;\n\tint err = -ENOMEM;\n\n#ifdef CONFIG_MEMCG_KMEM\n\tif (shrinker)\n\t\tlru->shrinker_id = shrinker->id;\n\telse\n\t\tlru->shrinker_id = -1;\n#endif\n\tmemcg_get_cache_ids();\n\n\tlru->node = kzalloc(size, GFP_KERNEL);\n\tif (!lru->node)\n\t\tgoto out;\n\n\tfor_each_node(i) {\n\t\tspin_lock_init(&lru->node[i].lock);\n\t\tif (key)\n\t\t\tlockdep_set_class(&lru->node[i].lock, key);\n\t\tinit_one_lru(&lru->node[i].lru);\n\t}\n\n\terr = memcg_init_list_lru(lru, memcg_aware);\n\tif (err) {\n\t\tkfree(lru->node);\n\t\t/* Do this so a list_lru_destroy() doesn't crash: */\n\t\tlru->node = NULL;\n\t\tgoto out;\n\t}\n\n\tlist_lru_register(lru);\nout:\n\tmemcg_put_cache_ids();\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prealloc_shrinker",
          "args": [
            "&workingset_shadow_shrinker"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "prealloc_shrinker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "371-393",
          "snippet": "int prealloc_shrinker(struct shrinker *shrinker)\n{\n\tsize_t size = sizeof(*shrinker->nr_deferred);\n\n\tif (shrinker->flags & SHRINKER_NUMA_AWARE)\n\t\tsize *= nr_node_ids;\n\n\tshrinker->nr_deferred = kzalloc(size, GFP_KERNEL);\n\tif (!shrinker->nr_deferred)\n\t\treturn -ENOMEM;\n\n\tif (shrinker->flags & SHRINKER_MEMCG_AWARE) {\n\t\tif (prealloc_memcg_shrinker(shrinker))\n\t\t\tgoto free_deferred;\n\t}\n\n\treturn 0;\n\nfree_deferred:\n\tkfree(shrinker->nr_deferred);\n\tshrinker->nr_deferred = NULL;\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nint prealloc_shrinker(struct shrinker *shrinker)\n{\n\tsize_t size = sizeof(*shrinker->nr_deferred);\n\n\tif (shrinker->flags & SHRINKER_NUMA_AWARE)\n\t\tsize *= nr_node_ids;\n\n\tshrinker->nr_deferred = kzalloc(size, GFP_KERNEL);\n\tif (!shrinker->nr_deferred)\n\t\treturn -ENOMEM;\n\n\tif (shrinker->flags & SHRINKER_MEMCG_AWARE) {\n\t\tif (prealloc_memcg_shrinker(shrinker))\n\t\t\tgoto free_deferred;\n\t}\n\n\treturn 0;\n\nfree_deferred:\n\tkfree(shrinker->nr_deferred);\n\tshrinker->nr_deferred = NULL;\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"workingset: timestamp_bits=%d max_order=%d bucket_order=%u\\n\"",
            "timestamp_bits",
            "max_order",
            "bucket_order"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fls_long",
          "args": [
            "totalram_pages - 1"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "BITS_PER_LONG < EVICTION_SHIFT"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/pagemap.h>\n#include <linux/shmem_fs.h>\n#include <linux/writeback.h>\n#include <linux/memcontrol.h>\n\n#define EVICTION_SHIFT\t((BITS_PER_LONG - BITS_PER_XA_VALUE) +\t\\\n\t\t\t 1 + NODES_SHIFT + MEM_CGROUP_ID_SHIFT)\n\nstatic unsigned int bucket_order;\nstatic struct list_lru shadow_nodes;\nstatic struct shrinker workingset_shadow_shrinker = {\n\t.count_objects = count_shadow_nodes,\n\t.scan_objects = scan_shadow_nodes,\n\t.seeks = 0, /* ->count reports only fully expendable nodes */\n\t.flags = SHRINKER_NUMA_AWARE | SHRINKER_MEMCG_AWARE,\n};\nstatic struct lock_class_key shadow_nodes_key;\n\nstatic int __init workingset_init(void)\n{\n\tunsigned int timestamp_bits;\n\tunsigned int max_order;\n\tint ret;\n\n\tBUILD_BUG_ON(BITS_PER_LONG < EVICTION_SHIFT);\n\t/*\n\t * Calculate the eviction bucket size to cover the longest\n\t * actionable refault distance, which is currently half of\n\t * memory (totalram_pages/2). However, memory hotplug may add\n\t * some more pages at runtime, so keep working with up to\n\t * double the initial memory by using totalram_pages as-is.\n\t */\n\ttimestamp_bits = BITS_PER_LONG - EVICTION_SHIFT;\n\tmax_order = fls_long(totalram_pages - 1);\n\tif (max_order > timestamp_bits)\n\t\tbucket_order = max_order - timestamp_bits;\n\tpr_info(\"workingset: timestamp_bits=%d max_order=%d bucket_order=%u\\n\",\n\t       timestamp_bits, max_order, bucket_order);\n\n\tret = prealloc_shrinker(&workingset_shadow_shrinker);\n\tif (ret)\n\t\tgoto err;\n\tret = __list_lru_init(&shadow_nodes, true, &shadow_nodes_key,\n\t\t\t      &workingset_shadow_shrinker);\n\tif (ret)\n\t\tgoto err_list_lru;\n\tregister_shrinker_prepared(&workingset_shadow_shrinker);\n\treturn 0;\nerr_list_lru:\n\tfree_prealloced_shrinker(&workingset_shadow_shrinker);\nerr:\n\treturn ret;\n}"
  },
  {
    "function_name": "scan_shadow_nodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/workingset.c",
    "lines": "516-522",
    "snippet": "static unsigned long scan_shadow_nodes(struct shrinker *shrinker,\n\t\t\t\t       struct shrink_control *sc)\n{\n\t/* list_lru lock nests inside the IRQ-safe i_pages lock */\n\treturn list_lru_shrink_walk_irq(&shadow_nodes, sc, shadow_lru_isolate,\n\t\t\t\t\tNULL);\n}",
    "includes": [
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/memcontrol.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct list_lru shadow_nodes;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_lru_shrink_walk_irq",
          "args": [
            "&shadow_nodes",
            "sc",
            "shadow_lru_isolate",
            "NULL"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/pagemap.h>\n#include <linux/shmem_fs.h>\n#include <linux/writeback.h>\n#include <linux/memcontrol.h>\n\nstatic struct list_lru shadow_nodes;\n\nstatic unsigned long scan_shadow_nodes(struct shrinker *shrinker,\n\t\t\t\t       struct shrink_control *sc)\n{\n\t/* list_lru lock nests inside the IRQ-safe i_pages lock */\n\treturn list_lru_shrink_walk_irq(&shadow_nodes, sc, shadow_lru_isolate,\n\t\t\t\t\tNULL);\n}"
  },
  {
    "function_name": "shadow_lru_isolate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/workingset.c",
    "lines": "450-514",
    "snippet": "static enum lru_status shadow_lru_isolate(struct list_head *item,\n\t\t\t\t\t  struct list_lru_one *lru,\n\t\t\t\t\t  spinlock_t *lru_lock,\n\t\t\t\t\t  void *arg) __must_hold(lru_lock)\n{\n\tstruct xa_node *node = container_of(item, struct xa_node, private_list);\n\tXA_STATE(xas, node->array, 0);\n\tstruct address_space *mapping;\n\tint ret;\n\n\t/*\n\t * Page cache insertions and deletions synchroneously maintain\n\t * the shadow node LRU under the i_pages lock and the\n\t * lru_lock.  Because the page cache tree is emptied before\n\t * the inode can be destroyed, holding the lru_lock pins any\n\t * address_space that has nodes on the LRU.\n\t *\n\t * We can then safely transition to the i_pages lock to\n\t * pin only the address_space of the particular node we want\n\t * to reclaim, take the node off-LRU, and drop the lru_lock.\n\t */\n\n\tmapping = container_of(node->array, struct address_space, i_pages);\n\n\t/* Coming from the list, invert the lock order */\n\tif (!xa_trylock(&mapping->i_pages)) {\n\t\tspin_unlock_irq(lru_lock);\n\t\tret = LRU_RETRY;\n\t\tgoto out;\n\t}\n\n\tlist_lru_isolate(lru, item);\n\t__dec_lruvec_page_state(virt_to_page(node), WORKINGSET_NODES);\n\n\tspin_unlock(lru_lock);\n\n\t/*\n\t * The nodes should only contain one or more shadow entries,\n\t * no pages, so we expect to be able to remove them all and\n\t * delete and free the empty node afterwards.\n\t */\n\tif (WARN_ON_ONCE(!node->nr_values))\n\t\tgoto out_invalid;\n\tif (WARN_ON_ONCE(node->count != node->nr_values))\n\t\tgoto out_invalid;\n\tmapping->nrexceptional -= node->nr_values;\n\txas.xa_node = xa_parent_locked(&mapping->i_pages, node);\n\txas.xa_offset = node->offset;\n\txas.xa_shift = node->shift + XA_CHUNK_SHIFT;\n\txas_set_update(&xas, workingset_update_node);\n\t/*\n\t * We could store a shadow entry here which was the minimum of the\n\t * shadow entries we were tracking ...\n\t */\n\txas_store(&xas, NULL);\n\t__inc_lruvec_page_state(virt_to_page(node), WORKINGSET_NODERECLAIM);\n\nout_invalid:\n\txa_unlock_irq(&mapping->i_pages);\n\tret = LRU_REMOVED_RETRY;\nout:\n\tcond_resched();\n\tspin_lock_irq(lru_lock);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/memcontrol.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "lru_lock"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_unlock_irq",
          "args": [
            "&mapping->i_pages"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__inc_lruvec_page_state",
          "args": [
            "virt_to_page(node)",
            "WORKINGSET_NODERECLAIM"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "node"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_store",
          "args": [
            "&xas",
            "NULL"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_set_update",
          "args": [
            "&xas",
            "workingset_update_node"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_parent_locked",
          "args": [
            "&mapping->i_pages",
            "node"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "node->count != node->nr_values"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!node->nr_values"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "lru_lock"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__dec_lruvec_page_state",
          "args": [
            "virt_to_page(node)",
            "WORKINGSET_NODES"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "node"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_lru_isolate",
          "args": [
            "lru",
            "item"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "list_lru_isolate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
          "lines": "171-175",
          "snippet": "void list_lru_isolate(struct list_lru_one *list, struct list_head *item)\n{\n\tlist_del_init(item);\n\tlist->nr_items--;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nvoid list_lru_isolate(struct list_lru_one *list, struct list_head *item)\n{\n\tlist_del_init(item);\n\tlist->nr_items--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "lru_lock"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_trylock",
          "args": [
            "&mapping->i_pages"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "node->array",
            "structaddress_space",
            "i_pages"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XA_STATE",
          "args": [
            "xas",
            "node->array",
            "0"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "item",
            "structxa_node",
            "private_list"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__must_hold",
          "args": [
            "lru_lock"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/pagemap.h>\n#include <linux/shmem_fs.h>\n#include <linux/writeback.h>\n#include <linux/memcontrol.h>\n\nstatic enum lru_status shadow_lru_isolate(struct list_head *item,\n\t\t\t\t\t  struct list_lru_one *lru,\n\t\t\t\t\t  spinlock_t *lru_lock,\n\t\t\t\t\t  void *arg) __must_hold(lru_lock)\n{\n\tstruct xa_node *node = container_of(item, struct xa_node, private_list);\n\tXA_STATE(xas, node->array, 0);\n\tstruct address_space *mapping;\n\tint ret;\n\n\t/*\n\t * Page cache insertions and deletions synchroneously maintain\n\t * the shadow node LRU under the i_pages lock and the\n\t * lru_lock.  Because the page cache tree is emptied before\n\t * the inode can be destroyed, holding the lru_lock pins any\n\t * address_space that has nodes on the LRU.\n\t *\n\t * We can then safely transition to the i_pages lock to\n\t * pin only the address_space of the particular node we want\n\t * to reclaim, take the node off-LRU, and drop the lru_lock.\n\t */\n\n\tmapping = container_of(node->array, struct address_space, i_pages);\n\n\t/* Coming from the list, invert the lock order */\n\tif (!xa_trylock(&mapping->i_pages)) {\n\t\tspin_unlock_irq(lru_lock);\n\t\tret = LRU_RETRY;\n\t\tgoto out;\n\t}\n\n\tlist_lru_isolate(lru, item);\n\t__dec_lruvec_page_state(virt_to_page(node), WORKINGSET_NODES);\n\n\tspin_unlock(lru_lock);\n\n\t/*\n\t * The nodes should only contain one or more shadow entries,\n\t * no pages, so we expect to be able to remove them all and\n\t * delete and free the empty node afterwards.\n\t */\n\tif (WARN_ON_ONCE(!node->nr_values))\n\t\tgoto out_invalid;\n\tif (WARN_ON_ONCE(node->count != node->nr_values))\n\t\tgoto out_invalid;\n\tmapping->nrexceptional -= node->nr_values;\n\txas.xa_node = xa_parent_locked(&mapping->i_pages, node);\n\txas.xa_offset = node->offset;\n\txas.xa_shift = node->shift + XA_CHUNK_SHIFT;\n\txas_set_update(&xas, workingset_update_node);\n\t/*\n\t * We could store a shadow entry here which was the minimum of the\n\t * shadow entries we were tracking ...\n\t */\n\txas_store(&xas, NULL);\n\t__inc_lruvec_page_state(virt_to_page(node), WORKINGSET_NODERECLAIM);\n\nout_invalid:\n\txa_unlock_irq(&mapping->i_pages);\n\tret = LRU_REMOVED_RETRY;\nout:\n\tcond_resched();\n\tspin_lock_irq(lru_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "count_shadow_nodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/workingset.c",
    "lines": "396-448",
    "snippet": "static unsigned long count_shadow_nodes(struct shrinker *shrinker,\n\t\t\t\t\tstruct shrink_control *sc)\n{\n\tunsigned long max_nodes;\n\tunsigned long nodes;\n\tunsigned long pages;\n\n\tnodes = list_lru_shrink_count(&shadow_nodes, sc);\n\n\t/*\n\t * Approximate a reasonable limit for the nodes\n\t * containing shadow entries. We don't need to keep more\n\t * shadow entries than possible pages on the active list,\n\t * since refault distances bigger than that are dismissed.\n\t *\n\t * The size of the active list converges toward 100% of\n\t * overall page cache as memory grows, with only a tiny\n\t * inactive list. Assume the total cache size for that.\n\t *\n\t * Nodes might be sparsely populated, with only one shadow\n\t * entry in the extreme case. Obviously, we cannot keep one\n\t * node for every eligible shadow entry, so compromise on a\n\t * worst-case density of 1/8th. Below that, not all eligible\n\t * refaults can be detected anymore.\n\t *\n\t * On 64-bit with 7 xa_nodes per page and 64 slots\n\t * each, this will reclaim shadow entries when they consume\n\t * ~1.8% of available memory:\n\t *\n\t * PAGE_SIZE / xa_nodes / node_entries * 8 / PAGE_SIZE\n\t */\n#ifdef CONFIG_MEMCG\n\tif (sc->memcg) {\n\t\tstruct lruvec *lruvec;\n\n\t\tpages = mem_cgroup_node_nr_lru_pages(sc->memcg, sc->nid,\n\t\t\t\t\t\t     LRU_ALL);\n\t\tlruvec = mem_cgroup_lruvec(NODE_DATA(sc->nid), sc->memcg);\n\t\tpages += lruvec_page_state(lruvec, NR_SLAB_RECLAIMABLE);\n\t\tpages += lruvec_page_state(lruvec, NR_SLAB_UNRECLAIMABLE);\n\t} else\n#endif\n\t\tpages = node_present_pages(sc->nid);\n\n\tmax_nodes = pages >> (XA_CHUNK_SHIFT - 3);\n\n\tif (!nodes)\n\t\treturn SHRINK_EMPTY;\n\n\tif (nodes <= max_nodes)\n\t\treturn 0;\n\treturn nodes - max_nodes;\n}",
    "includes": [
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/memcontrol.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct list_lru shadow_nodes;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "node_present_pages",
          "args": [
            "sc->nid"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "reset_node_present_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memory_hotplug.c",
          "lines": "932-940",
          "snippet": "static void reset_node_present_pages(pg_data_t *pgdat)\n{\n\tstruct zone *z;\n\n\tfor (z = pgdat->node_zones; z < pgdat->node_zones + MAX_NR_ZONES; z++)\n\t\tz->present_pages = 0;\n\n\tpgdat->node_present_pages = 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <linux/compaction.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/firmware-map.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/suspend.h>",
            "#include <linux/pfn.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/migrate.h>",
            "#include <linux/delay.h>",
            "#include <linux/ioport.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/highmem.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/memremap.h>",
            "#include <linux/memory.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <linux/compaction.h>\n#include <linux/memblock.h>\n#include <linux/hugetlb.h>\n#include <linux/stop_machine.h>\n#include <linux/firmware-map.h>\n#include <linux/mm_inline.h>\n#include <linux/suspend.h>\n#include <linux/pfn.h>\n#include <linux/page-isolation.h>\n#include <linux/migrate.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/memory_hotplug.h>\n#include <linux/memremap.h>\n#include <linux/memory.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void reset_node_present_pages(pg_data_t *pgdat)\n{\n\tstruct zone *z;\n\n\tfor (z = pgdat->node_zones; z < pgdat->node_zones + MAX_NR_ZONES; z++)\n\t\tz->present_pages = 0;\n\n\tpgdat->node_present_pages = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lruvec_page_state",
          "args": [
            "lruvec",
            "NR_SLAB_UNRECLAIMABLE"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lruvec_page_state",
          "args": [
            "lruvec",
            "NR_SLAB_RECLAIMABLE"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_lruvec",
          "args": [
            "NODE_DATA(sc->nid)",
            "sc->memcg"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "sc->nid"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_node_nr_lru_pages",
          "args": [
            "sc->memcg",
            "sc->nid",
            "LRU_ALL"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_node_nr_lru_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "721-736",
          "snippet": "unsigned long mem_cgroup_node_nr_lru_pages(struct mem_cgroup *memcg,\n\t\t\t\t\t   int nid, unsigned int lru_mask)\n{\n\tstruct lruvec *lruvec = mem_cgroup_lruvec(NODE_DATA(nid), memcg);\n\tunsigned long nr = 0;\n\tenum lru_list lru;\n\n\tVM_BUG_ON((unsigned)nid >= nr_node_ids);\n\n\tfor_each_lru(lru) {\n\t\tif (!(BIT(lru) & lru_mask))\n\t\t\tcontinue;\n\t\tnr += mem_cgroup_get_lru_size(lruvec, lru);\n\t}\n\treturn nr;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nunsigned long mem_cgroup_node_nr_lru_pages(struct mem_cgroup *memcg,\n\t\t\t\t\t   int nid, unsigned int lru_mask)\n{\n\tstruct lruvec *lruvec = mem_cgroup_lruvec(NODE_DATA(nid), memcg);\n\tunsigned long nr = 0;\n\tenum lru_list lru;\n\n\tVM_BUG_ON((unsigned)nid >= nr_node_ids);\n\n\tfor_each_lru(lru) {\n\t\tif (!(BIT(lru) & lru_mask))\n\t\t\tcontinue;\n\t\tnr += mem_cgroup_get_lru_size(lruvec, lru);\n\t}\n\treturn nr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_lru_shrink_count",
          "args": [
            "&shadow_nodes",
            "sc"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/pagemap.h>\n#include <linux/shmem_fs.h>\n#include <linux/writeback.h>\n#include <linux/memcontrol.h>\n\nstatic struct list_lru shadow_nodes;\n\nstatic unsigned long count_shadow_nodes(struct shrinker *shrinker,\n\t\t\t\t\tstruct shrink_control *sc)\n{\n\tunsigned long max_nodes;\n\tunsigned long nodes;\n\tunsigned long pages;\n\n\tnodes = list_lru_shrink_count(&shadow_nodes, sc);\n\n\t/*\n\t * Approximate a reasonable limit for the nodes\n\t * containing shadow entries. We don't need to keep more\n\t * shadow entries than possible pages on the active list,\n\t * since refault distances bigger than that are dismissed.\n\t *\n\t * The size of the active list converges toward 100% of\n\t * overall page cache as memory grows, with only a tiny\n\t * inactive list. Assume the total cache size for that.\n\t *\n\t * Nodes might be sparsely populated, with only one shadow\n\t * entry in the extreme case. Obviously, we cannot keep one\n\t * node for every eligible shadow entry, so compromise on a\n\t * worst-case density of 1/8th. Below that, not all eligible\n\t * refaults can be detected anymore.\n\t *\n\t * On 64-bit with 7 xa_nodes per page and 64 slots\n\t * each, this will reclaim shadow entries when they consume\n\t * ~1.8% of available memory:\n\t *\n\t * PAGE_SIZE / xa_nodes / node_entries * 8 / PAGE_SIZE\n\t */\n#ifdef CONFIG_MEMCG\n\tif (sc->memcg) {\n\t\tstruct lruvec *lruvec;\n\n\t\tpages = mem_cgroup_node_nr_lru_pages(sc->memcg, sc->nid,\n\t\t\t\t\t\t     LRU_ALL);\n\t\tlruvec = mem_cgroup_lruvec(NODE_DATA(sc->nid), sc->memcg);\n\t\tpages += lruvec_page_state(lruvec, NR_SLAB_RECLAIMABLE);\n\t\tpages += lruvec_page_state(lruvec, NR_SLAB_UNRECLAIMABLE);\n\t} else\n#endif\n\t\tpages = node_present_pages(sc->nid);\n\n\tmax_nodes = pages >> (XA_CHUNK_SHIFT - 3);\n\n\tif (!nodes)\n\t\treturn SHRINK_EMPTY;\n\n\tif (nodes <= max_nodes)\n\t\treturn 0;\n\treturn nodes - max_nodes;\n}"
  },
  {
    "function_name": "workingset_update_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/workingset.c",
    "lines": "369-394",
    "snippet": "void workingset_update_node(struct xa_node *node)\n{\n\t/*\n\t * Track non-empty nodes that contain only shadow entries;\n\t * unlink those that contain pages or are being freed.\n\t *\n\t * Avoid acquiring the list_lru lock when the nodes are\n\t * already where they should be. The list_empty() test is safe\n\t * as node->private_list is protected by the i_pages lock.\n\t */\n\tVM_WARN_ON_ONCE(!irqs_disabled());  /* For __inc_lruvec_page_state */\n\n\tif (node->count && node->count == node->nr_values) {\n\t\tif (list_empty(&node->private_list)) {\n\t\t\tlist_lru_add(&shadow_nodes, &node->private_list);\n\t\t\t__inc_lruvec_page_state(virt_to_page(node),\n\t\t\t\t\t\tWORKINGSET_NODES);\n\t\t}\n\t} else {\n\t\tif (!list_empty(&node->private_list)) {\n\t\t\tlist_lru_del(&shadow_nodes, &node->private_list);\n\t\t\t__dec_lruvec_page_state(virt_to_page(node),\n\t\t\t\t\t\tWORKINGSET_NODES);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/memcontrol.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct list_lru shadow_nodes;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__dec_lruvec_page_state",
          "args": [
            "virt_to_page(node)",
            "WORKINGSET_NODES"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "node"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_lru_del",
          "args": [
            "&shadow_nodes",
            "&node->private_list"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "list_lru_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
          "lines": "151-168",
          "snippet": "bool list_lru_del(struct list_lru *lru, struct list_head *item)\n{\n\tint nid = page_to_nid(virt_to_page(item));\n\tstruct list_lru_node *nlru = &lru->node[nid];\n\tstruct list_lru_one *l;\n\n\tspin_lock(&nlru->lock);\n\tif (!list_empty(item)) {\n\t\tl = list_lru_from_kmem(nlru, item, NULL);\n\t\tlist_del_init(item);\n\t\tl->nr_items--;\n\t\tnlru->nr_items--;\n\t\tspin_unlock(&nlru->lock);\n\t\treturn true;\n\t}\n\tspin_unlock(&nlru->lock);\n\treturn false;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nbool list_lru_del(struct list_lru *lru, struct list_head *item)\n{\n\tint nid = page_to_nid(virt_to_page(item));\n\tstruct list_lru_node *nlru = &lru->node[nid];\n\tstruct list_lru_one *l;\n\n\tspin_lock(&nlru->lock);\n\tif (!list_empty(item)) {\n\t\tl = list_lru_from_kmem(nlru, item, NULL);\n\t\tlist_del_init(item);\n\t\tl->nr_items--;\n\t\tnlru->nr_items--;\n\t\tspin_unlock(&nlru->lock);\n\t\treturn true;\n\t}\n\tspin_unlock(&nlru->lock);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&node->private_list"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__inc_lruvec_page_state",
          "args": [
            "virt_to_page(node)",
            "WORKINGSET_NODES"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "node"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_lru_add",
          "args": [
            "&shadow_nodes",
            "&node->private_list"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "list_lru_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/list_lru.c",
          "lines": "127-148",
          "snippet": "bool list_lru_add(struct list_lru *lru, struct list_head *item)\n{\n\tint nid = page_to_nid(virt_to_page(item));\n\tstruct list_lru_node *nlru = &lru->node[nid];\n\tstruct mem_cgroup *memcg;\n\tstruct list_lru_one *l;\n\n\tspin_lock(&nlru->lock);\n\tif (list_empty(item)) {\n\t\tl = list_lru_from_kmem(nlru, item, &memcg);\n\t\tlist_add_tail(item, &l->list);\n\t\t/* Set shrinker bit if the first element was added */\n\t\tif (!l->nr_items++)\n\t\t\tmemcg_set_shrinker_bit(memcg, nid,\n\t\t\t\t\t       lru_shrinker_id(lru));\n\t\tnlru->nr_items++;\n\t\tspin_unlock(&nlru->lock);\n\t\treturn true;\n\t}\n\tspin_unlock(&nlru->lock);\n\treturn false;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/list_lru.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nbool list_lru_add(struct list_lru *lru, struct list_head *item)\n{\n\tint nid = page_to_nid(virt_to_page(item));\n\tstruct list_lru_node *nlru = &lru->node[nid];\n\tstruct mem_cgroup *memcg;\n\tstruct list_lru_one *l;\n\n\tspin_lock(&nlru->lock);\n\tif (list_empty(item)) {\n\t\tl = list_lru_from_kmem(nlru, item, &memcg);\n\t\tlist_add_tail(item, &l->list);\n\t\t/* Set shrinker bit if the first element was added */\n\t\tif (!l->nr_items++)\n\t\t\tmemcg_set_shrinker_bit(memcg, nid,\n\t\t\t\t\t       lru_shrinker_id(lru));\n\t\tnlru->nr_items++;\n\t\tspin_unlock(&nlru->lock);\n\t\treturn true;\n\t}\n\tspin_unlock(&nlru->lock);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_WARN_ON_ONCE",
          "args": [
            "!irqs_disabled()"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/pagemap.h>\n#include <linux/shmem_fs.h>\n#include <linux/writeback.h>\n#include <linux/memcontrol.h>\n\nstatic struct list_lru shadow_nodes;\n\nvoid workingset_update_node(struct xa_node *node)\n{\n\t/*\n\t * Track non-empty nodes that contain only shadow entries;\n\t * unlink those that contain pages or are being freed.\n\t *\n\t * Avoid acquiring the list_lru lock when the nodes are\n\t * already where they should be. The list_empty() test is safe\n\t * as node->private_list is protected by the i_pages lock.\n\t */\n\tVM_WARN_ON_ONCE(!irqs_disabled());  /* For __inc_lruvec_page_state */\n\n\tif (node->count && node->count == node->nr_values) {\n\t\tif (list_empty(&node->private_list)) {\n\t\t\tlist_lru_add(&shadow_nodes, &node->private_list);\n\t\t\t__inc_lruvec_page_state(virt_to_page(node),\n\t\t\t\t\t\tWORKINGSET_NODES);\n\t\t}\n\t} else {\n\t\tif (!list_empty(&node->private_list)) {\n\t\t\tlist_lru_del(&shadow_nodes, &node->private_list);\n\t\t\t__dec_lruvec_page_state(virt_to_page(node),\n\t\t\t\t\t\tWORKINGSET_NODES);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "workingset_activation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/workingset.c",
    "lines": "333-353",
    "snippet": "void workingset_activation(struct page *page)\n{\n\tstruct mem_cgroup *memcg;\n\tstruct lruvec *lruvec;\n\n\trcu_read_lock();\n\t/*\n\t * Filter non-memcg pages here, e.g. unmap can call\n\t * mark_page_accessed() on VDSO pages.\n\t *\n\t * XXX: See workingset_refault() - this should return\n\t * root_mem_cgroup even for !CONFIG_MEMCG.\n\t */\n\tmemcg = page_memcg_rcu(page);\n\tif (!mem_cgroup_disabled() && !memcg)\n\t\tgoto out;\n\tlruvec = mem_cgroup_lruvec(page_pgdat(page), memcg);\n\tatomic_long_inc(&lruvec->inactive_age);\nout:\n\trcu_read_unlock();\n}",
    "includes": [
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/memcontrol.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_inc",
          "args": [
            "&lruvec->inactive_age"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_lruvec",
          "args": [
            "page_pgdat(page)",
            "memcg"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_pgdat",
          "args": [
            "page"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_disabled",
          "args": [],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_memcg_rcu",
          "args": [
            "page"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/pagemap.h>\n#include <linux/shmem_fs.h>\n#include <linux/writeback.h>\n#include <linux/memcontrol.h>\n\nvoid workingset_activation(struct page *page)\n{\n\tstruct mem_cgroup *memcg;\n\tstruct lruvec *lruvec;\n\n\trcu_read_lock();\n\t/*\n\t * Filter non-memcg pages here, e.g. unmap can call\n\t * mark_page_accessed() on VDSO pages.\n\t *\n\t * XXX: See workingset_refault() - this should return\n\t * root_mem_cgroup even for !CONFIG_MEMCG.\n\t */\n\tmemcg = page_memcg_rcu(page);\n\tif (!mem_cgroup_disabled() && !memcg)\n\t\tgoto out;\n\tlruvec = mem_cgroup_lruvec(page_pgdat(page), memcg);\n\tatomic_long_inc(&lruvec->inactive_age);\nout:\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "workingset_refault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/workingset.c",
    "lines": "250-327",
    "snippet": "void workingset_refault(struct page *page, void *shadow)\n{\n\tunsigned long refault_distance;\n\tstruct pglist_data *pgdat;\n\tunsigned long active_file;\n\tstruct mem_cgroup *memcg;\n\tunsigned long eviction;\n\tstruct lruvec *lruvec;\n\tunsigned long refault;\n\tbool workingset;\n\tint memcgid;\n\n\tunpack_shadow(shadow, &memcgid, &pgdat, &eviction, &workingset);\n\n\trcu_read_lock();\n\t/*\n\t * Look up the memcg associated with the stored ID. It might\n\t * have been deleted since the page's eviction.\n\t *\n\t * Note that in rare events the ID could have been recycled\n\t * for a new cgroup that refaults a shared page. This is\n\t * impossible to tell from the available data. However, this\n\t * should be a rare and limited disturbance, and activations\n\t * are always speculative anyway. Ultimately, it's the aging\n\t * algorithm's job to shake out the minimum access frequency\n\t * for the active cache.\n\t *\n\t * XXX: On !CONFIG_MEMCG, this will always return NULL; it\n\t * would be better if the root_mem_cgroup existed in all\n\t * configurations instead.\n\t */\n\tmemcg = mem_cgroup_from_id(memcgid);\n\tif (!mem_cgroup_disabled() && !memcg)\n\t\tgoto out;\n\tlruvec = mem_cgroup_lruvec(pgdat, memcg);\n\trefault = atomic_long_read(&lruvec->inactive_age);\n\tactive_file = lruvec_lru_size(lruvec, LRU_ACTIVE_FILE, MAX_NR_ZONES);\n\n\t/*\n\t * Calculate the refault distance\n\t *\n\t * The unsigned subtraction here gives an accurate distance\n\t * across inactive_age overflows in most cases. There is a\n\t * special case: usually, shadow entries have a short lifetime\n\t * and are either refaulted or reclaimed along with the inode\n\t * before they get too old.  But it is not impossible for the\n\t * inactive_age to lap a shadow entry in the field, which can\n\t * then result in a false small refault distance, leading to a\n\t * false activation should this old entry actually refault\n\t * again.  However, earlier kernels used to deactivate\n\t * unconditionally with *every* reclaim invocation for the\n\t * longest time, so the occasional inappropriate activation\n\t * leading to pressure on the active list is not a problem.\n\t */\n\trefault_distance = (refault - eviction) & EVICTION_MASK;\n\n\tinc_lruvec_state(lruvec, WORKINGSET_REFAULT);\n\n\t/*\n\t * Compare the distance to the existing workingset size. We\n\t * don't act on pages that couldn't stay resident even if all\n\t * the memory was available to the page cache.\n\t */\n\tif (refault_distance > active_file)\n\t\tgoto out;\n\n\tSetPageActive(page);\n\tatomic_long_inc(&lruvec->inactive_age);\n\tinc_lruvec_state(lruvec, WORKINGSET_ACTIVATE);\n\n\t/* Page was active prior to eviction */\n\tif (workingset) {\n\t\tSetPageWorkingset(page);\n\t\tinc_lruvec_state(lruvec, WORKINGSET_RESTORE);\n\t}\nout:\n\trcu_read_unlock();\n}",
    "includes": [
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/memcontrol.h>"
    ],
    "macros_used": [
      "#define EVICTION_MASK\t(~0UL >> EVICTION_SHIFT)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_lruvec_state",
          "args": [
            "lruvec",
            "WORKINGSET_RESTORE"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageWorkingset",
          "args": [
            "page"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_lruvec_state",
          "args": [
            "lruvec",
            "WORKINGSET_ACTIVATE"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_inc",
          "args": [
            "&lruvec->inactive_age"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageActive",
          "args": [
            "page"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_lruvec_state",
          "args": [
            "lruvec",
            "WORKINGSET_REFAULT"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lruvec_lru_size",
          "args": [
            "lruvec",
            "LRU_ACTIVE_FILE",
            "MAX_NR_ZONES"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "lruvec_lru_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "339-366",
          "snippet": "unsigned long lruvec_lru_size(struct lruvec *lruvec, enum lru_list lru, int zone_idx)\n{\n\tunsigned long lru_size;\n\tint zid;\n\n\tif (!mem_cgroup_disabled())\n\t\tlru_size = mem_cgroup_get_lru_size(lruvec, lru);\n\telse\n\t\tlru_size = node_page_state(lruvec_pgdat(lruvec), NR_LRU_BASE + lru);\n\n\tfor (zid = zone_idx + 1; zid < MAX_NR_ZONES; zid++) {\n\t\tstruct zone *zone = &lruvec_pgdat(lruvec)->node_zones[zid];\n\t\tunsigned long size;\n\n\t\tif (!managed_zone(zone))\n\t\t\tcontinue;\n\n\t\tif (!mem_cgroup_disabled())\n\t\t\tsize = mem_cgroup_get_zone_lru_size(lruvec, lru, zid);\n\t\telse\n\t\t\tsize = zone_page_state(&lruvec_pgdat(lruvec)->node_zones[zid],\n\t\t\t\t       NR_ZONE_LRU_BASE + lru);\n\t\tlru_size -= min(size, lru_size);\n\t}\n\n\treturn lru_size;\n\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nunsigned long lruvec_lru_size(struct lruvec *lruvec, enum lru_list lru, int zone_idx)\n{\n\tunsigned long lru_size;\n\tint zid;\n\n\tif (!mem_cgroup_disabled())\n\t\tlru_size = mem_cgroup_get_lru_size(lruvec, lru);\n\telse\n\t\tlru_size = node_page_state(lruvec_pgdat(lruvec), NR_LRU_BASE + lru);\n\n\tfor (zid = zone_idx + 1; zid < MAX_NR_ZONES; zid++) {\n\t\tstruct zone *zone = &lruvec_pgdat(lruvec)->node_zones[zid];\n\t\tunsigned long size;\n\n\t\tif (!managed_zone(zone))\n\t\t\tcontinue;\n\n\t\tif (!mem_cgroup_disabled())\n\t\t\tsize = mem_cgroup_get_zone_lru_size(lruvec, lru, zid);\n\t\telse\n\t\t\tsize = zone_page_state(&lruvec_pgdat(lruvec)->node_zones[zid],\n\t\t\t\t       NR_ZONE_LRU_BASE + lru);\n\t\tlru_size -= min(size, lru_size);\n\t}\n\n\treturn lru_size;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&lruvec->inactive_age"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_lruvec",
          "args": [
            "pgdat",
            "memcg"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_disabled",
          "args": [],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_from_id",
          "args": [
            "memcgid"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_from_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "4331-4335",
          "snippet": "struct mem_cgroup *mem_cgroup_from_id(unsigned short id)\n{\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\treturn idr_find(&mem_cgroup_idr, id);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static DEFINE_IDR(mem_cgroup_idr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\nstatic DEFINE_IDR(mem_cgroup_idr);\n\nstruct mem_cgroup *mem_cgroup_from_id(unsigned short id)\n{\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\treturn idr_find(&mem_cgroup_idr, id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unpack_shadow",
          "args": [
            "shadow",
            "&memcgid",
            "&pgdat",
            "&eviction",
            "&workingset"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "unpack_shadow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/workingset.c",
          "lines": "196-214",
          "snippet": "static void unpack_shadow(void *shadow, int *memcgidp, pg_data_t **pgdat,\n\t\t\t  unsigned long *evictionp, bool *workingsetp)\n{\n\tunsigned long entry = xa_to_value(shadow);\n\tint memcgid, nid;\n\tbool workingset;\n\n\tworkingset = entry & 1;\n\tentry >>= 1;\n\tnid = entry & ((1UL << NODES_SHIFT) - 1);\n\tentry >>= NODES_SHIFT;\n\tmemcgid = entry & ((1UL << MEM_CGROUP_ID_SHIFT) - 1);\n\tentry >>= MEM_CGROUP_ID_SHIFT;\n\n\t*memcgidp = memcgid;\n\t*pgdat = NODE_DATA(nid);\n\t*evictionp = entry << bucket_order;\n\t*workingsetp = workingset;\n}",
          "includes": [
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/memcontrol.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int bucket_order"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/pagemap.h>\n#include <linux/shmem_fs.h>\n#include <linux/writeback.h>\n#include <linux/memcontrol.h>\n\nstatic unsigned int bucket_order;\n\nstatic void unpack_shadow(void *shadow, int *memcgidp, pg_data_t **pgdat,\n\t\t\t  unsigned long *evictionp, bool *workingsetp)\n{\n\tunsigned long entry = xa_to_value(shadow);\n\tint memcgid, nid;\n\tbool workingset;\n\n\tworkingset = entry & 1;\n\tentry >>= 1;\n\tnid = entry & ((1UL << NODES_SHIFT) - 1);\n\tentry >>= NODES_SHIFT;\n\tmemcgid = entry & ((1UL << MEM_CGROUP_ID_SHIFT) - 1);\n\tentry >>= MEM_CGROUP_ID_SHIFT;\n\n\t*memcgidp = memcgid;\n\t*pgdat = NODE_DATA(nid);\n\t*evictionp = entry << bucket_order;\n\t*workingsetp = workingset;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/pagemap.h>\n#include <linux/shmem_fs.h>\n#include <linux/writeback.h>\n#include <linux/memcontrol.h>\n\n#define EVICTION_MASK\t(~0UL >> EVICTION_SHIFT)\n\nvoid workingset_refault(struct page *page, void *shadow)\n{\n\tunsigned long refault_distance;\n\tstruct pglist_data *pgdat;\n\tunsigned long active_file;\n\tstruct mem_cgroup *memcg;\n\tunsigned long eviction;\n\tstruct lruvec *lruvec;\n\tunsigned long refault;\n\tbool workingset;\n\tint memcgid;\n\n\tunpack_shadow(shadow, &memcgid, &pgdat, &eviction, &workingset);\n\n\trcu_read_lock();\n\t/*\n\t * Look up the memcg associated with the stored ID. It might\n\t * have been deleted since the page's eviction.\n\t *\n\t * Note that in rare events the ID could have been recycled\n\t * for a new cgroup that refaults a shared page. This is\n\t * impossible to tell from the available data. However, this\n\t * should be a rare and limited disturbance, and activations\n\t * are always speculative anyway. Ultimately, it's the aging\n\t * algorithm's job to shake out the minimum access frequency\n\t * for the active cache.\n\t *\n\t * XXX: On !CONFIG_MEMCG, this will always return NULL; it\n\t * would be better if the root_mem_cgroup existed in all\n\t * configurations instead.\n\t */\n\tmemcg = mem_cgroup_from_id(memcgid);\n\tif (!mem_cgroup_disabled() && !memcg)\n\t\tgoto out;\n\tlruvec = mem_cgroup_lruvec(pgdat, memcg);\n\trefault = atomic_long_read(&lruvec->inactive_age);\n\tactive_file = lruvec_lru_size(lruvec, LRU_ACTIVE_FILE, MAX_NR_ZONES);\n\n\t/*\n\t * Calculate the refault distance\n\t *\n\t * The unsigned subtraction here gives an accurate distance\n\t * across inactive_age overflows in most cases. There is a\n\t * special case: usually, shadow entries have a short lifetime\n\t * and are either refaulted or reclaimed along with the inode\n\t * before they get too old.  But it is not impossible for the\n\t * inactive_age to lap a shadow entry in the field, which can\n\t * then result in a false small refault distance, leading to a\n\t * false activation should this old entry actually refault\n\t * again.  However, earlier kernels used to deactivate\n\t * unconditionally with *every* reclaim invocation for the\n\t * longest time, so the occasional inappropriate activation\n\t * leading to pressure on the active list is not a problem.\n\t */\n\trefault_distance = (refault - eviction) & EVICTION_MASK;\n\n\tinc_lruvec_state(lruvec, WORKINGSET_REFAULT);\n\n\t/*\n\t * Compare the distance to the existing workingset size. We\n\t * don't act on pages that couldn't stay resident even if all\n\t * the memory was available to the page cache.\n\t */\n\tif (refault_distance > active_file)\n\t\tgoto out;\n\n\tSetPageActive(page);\n\tatomic_long_inc(&lruvec->inactive_age);\n\tinc_lruvec_state(lruvec, WORKINGSET_ACTIVATE);\n\n\t/* Page was active prior to eviction */\n\tif (workingset) {\n\t\tSetPageWorkingset(page);\n\t\tinc_lruvec_state(lruvec, WORKINGSET_RESTORE);\n\t}\nout:\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "workingset_eviction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/workingset.c",
    "lines": "224-240",
    "snippet": "void *workingset_eviction(struct address_space *mapping, struct page *page)\n{\n\tstruct pglist_data *pgdat = page_pgdat(page);\n\tstruct mem_cgroup *memcg = page_memcg(page);\n\tint memcgid = mem_cgroup_id(memcg);\n\tunsigned long eviction;\n\tstruct lruvec *lruvec;\n\n\t/* Page is fully exclusive and pins page->mem_cgroup */\n\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\tVM_BUG_ON_PAGE(page_count(page), page);\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\tlruvec = mem_cgroup_lruvec(pgdat, memcg);\n\teviction = atomic_long_inc_return(&lruvec->inactive_age);\n\treturn pack_shadow(memcgid, pgdat, eviction, PageWorkingset(page));\n}",
    "includes": [
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/memcontrol.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pack_shadow",
          "args": [
            "memcgid",
            "pgdat",
            "eviction",
            "PageWorkingset(page)"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "pack_shadow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/workingset.c",
          "lines": "184-194",
          "snippet": "static void *pack_shadow(int memcgid, pg_data_t *pgdat, unsigned long eviction,\n\t\t\t bool workingset)\n{\n\teviction >>= bucket_order;\n\teviction &= EVICTION_MASK;\n\teviction = (eviction << MEM_CGROUP_ID_SHIFT) | memcgid;\n\teviction = (eviction << NODES_SHIFT) | pgdat->node_id;\n\teviction = (eviction << 1) | workingset;\n\n\treturn xa_mk_value(eviction);\n}",
          "includes": [
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/dax.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/memcontrol.h>"
          ],
          "macros_used": [
            "#define EVICTION_MASK\t(~0UL >> EVICTION_SHIFT)"
          ],
          "globals_used": [
            "static unsigned int bucket_order"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/pagemap.h>\n#include <linux/shmem_fs.h>\n#include <linux/writeback.h>\n#include <linux/memcontrol.h>\n\n#define EVICTION_MASK\t(~0UL >> EVICTION_SHIFT)\n\nstatic unsigned int bucket_order;\n\nstatic void *pack_shadow(int memcgid, pg_data_t *pgdat, unsigned long eviction,\n\t\t\t bool workingset)\n{\n\teviction >>= bucket_order;\n\teviction &= EVICTION_MASK;\n\teviction = (eviction << MEM_CGROUP_ID_SHIFT) | memcgid;\n\teviction = (eviction << NODES_SHIFT) | pgdat->node_id;\n\teviction = (eviction << 1) | workingset;\n\n\treturn xa_mk_value(eviction);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageWorkingset",
          "args": [
            "page"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_inc_return",
          "args": [
            "&lruvec->inactive_age"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_lruvec",
          "args": [
            "pgdat",
            "memcg"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!PageLocked(page)",
            "page"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "page_count(page)",
            "page"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "page"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "PageLRU(page)",
            "page"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "page"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_id",
          "args": [
            "memcg"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "mem_cgroup_id_get_online",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "6356-6372",
          "snippet": "static struct mem_cgroup *mem_cgroup_id_get_online(struct mem_cgroup *memcg)\n{\n\twhile (!refcount_inc_not_zero(&memcg->id.ref)) {\n\t\t/*\n\t\t * The root cgroup cannot be destroyed, so it's refcount must\n\t\t * always be >= 1.\n\t\t */\n\t\tif (WARN_ON_ONCE(memcg == root_mem_cgroup)) {\n\t\t\tVM_BUG_ON(1);\n\t\t\tbreak;\n\t\t}\n\t\tmemcg = parent_mem_cgroup(memcg);\n\t\tif (!memcg)\n\t\t\tmemcg = root_mem_cgroup;\n\t}\n\treturn memcg;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mem_cgroup *root_mem_cgroup",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct mem_cgroup *root_mem_cgroup;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic struct mem_cgroup *mem_cgroup_id_get_online(struct mem_cgroup *memcg)\n{\n\twhile (!refcount_inc_not_zero(&memcg->id.ref)) {\n\t\t/*\n\t\t * The root cgroup cannot be destroyed, so it's refcount must\n\t\t * always be >= 1.\n\t\t */\n\t\tif (WARN_ON_ONCE(memcg == root_mem_cgroup)) {\n\t\t\tVM_BUG_ON(1);\n\t\t\tbreak;\n\t\t}\n\t\tmemcg = parent_mem_cgroup(memcg);\n\t\tif (!memcg)\n\t\t\tmemcg = root_mem_cgroup;\n\t}\n\treturn memcg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_memcg",
          "args": [
            "page"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_page_memcg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1916-1919",
          "snippet": "void unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic __always_inline struct;\n\nvoid unlock_page_memcg(struct page *page)\n{\n\t__unlock_page_memcg(page->mem_cgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_pgdat",
          "args": [
            "page"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/pagemap.h>\n#include <linux/shmem_fs.h>\n#include <linux/writeback.h>\n#include <linux/memcontrol.h>\n\nvoid *workingset_eviction(struct address_space *mapping, struct page *page)\n{\n\tstruct pglist_data *pgdat = page_pgdat(page);\n\tstruct mem_cgroup *memcg = page_memcg(page);\n\tint memcgid = mem_cgroup_id(memcg);\n\tunsigned long eviction;\n\tstruct lruvec *lruvec;\n\n\t/* Page is fully exclusive and pins page->mem_cgroup */\n\tVM_BUG_ON_PAGE(PageLRU(page), page);\n\tVM_BUG_ON_PAGE(page_count(page), page);\n\tVM_BUG_ON_PAGE(!PageLocked(page), page);\n\n\tlruvec = mem_cgroup_lruvec(pgdat, memcg);\n\teviction = atomic_long_inc_return(&lruvec->inactive_age);\n\treturn pack_shadow(memcgid, pgdat, eviction, PageWorkingset(page));\n}"
  },
  {
    "function_name": "unpack_shadow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/workingset.c",
    "lines": "196-214",
    "snippet": "static void unpack_shadow(void *shadow, int *memcgidp, pg_data_t **pgdat,\n\t\t\t  unsigned long *evictionp, bool *workingsetp)\n{\n\tunsigned long entry = xa_to_value(shadow);\n\tint memcgid, nid;\n\tbool workingset;\n\n\tworkingset = entry & 1;\n\tentry >>= 1;\n\tnid = entry & ((1UL << NODES_SHIFT) - 1);\n\tentry >>= NODES_SHIFT;\n\tmemcgid = entry & ((1UL << MEM_CGROUP_ID_SHIFT) - 1);\n\tentry >>= MEM_CGROUP_ID_SHIFT;\n\n\t*memcgidp = memcgid;\n\t*pgdat = NODE_DATA(nid);\n\t*evictionp = entry << bucket_order;\n\t*workingsetp = workingset;\n}",
    "includes": [
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/memcontrol.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int bucket_order"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "nid"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_to_value",
          "args": [
            "shadow"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/pagemap.h>\n#include <linux/shmem_fs.h>\n#include <linux/writeback.h>\n#include <linux/memcontrol.h>\n\nstatic unsigned int bucket_order;\n\nstatic void unpack_shadow(void *shadow, int *memcgidp, pg_data_t **pgdat,\n\t\t\t  unsigned long *evictionp, bool *workingsetp)\n{\n\tunsigned long entry = xa_to_value(shadow);\n\tint memcgid, nid;\n\tbool workingset;\n\n\tworkingset = entry & 1;\n\tentry >>= 1;\n\tnid = entry & ((1UL << NODES_SHIFT) - 1);\n\tentry >>= NODES_SHIFT;\n\tmemcgid = entry & ((1UL << MEM_CGROUP_ID_SHIFT) - 1);\n\tentry >>= MEM_CGROUP_ID_SHIFT;\n\n\t*memcgidp = memcgid;\n\t*pgdat = NODE_DATA(nid);\n\t*evictionp = entry << bucket_order;\n\t*workingsetp = workingset;\n}"
  },
  {
    "function_name": "pack_shadow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/workingset.c",
    "lines": "184-194",
    "snippet": "static void *pack_shadow(int memcgid, pg_data_t *pgdat, unsigned long eviction,\n\t\t\t bool workingset)\n{\n\teviction >>= bucket_order;\n\teviction &= EVICTION_MASK;\n\teviction = (eviction << MEM_CGROUP_ID_SHIFT) | memcgid;\n\teviction = (eviction << NODES_SHIFT) | pgdat->node_id;\n\teviction = (eviction << 1) | workingset;\n\n\treturn xa_mk_value(eviction);\n}",
    "includes": [
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/dax.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/memcontrol.h>"
    ],
    "macros_used": [
      "#define EVICTION_MASK\t(~0UL >> EVICTION_SHIFT)"
    ],
    "globals_used": [
      "static unsigned int bucket_order"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xa_mk_value",
          "args": [
            "eviction"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/dax.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/pagemap.h>\n#include <linux/shmem_fs.h>\n#include <linux/writeback.h>\n#include <linux/memcontrol.h>\n\n#define EVICTION_MASK\t(~0UL >> EVICTION_SHIFT)\n\nstatic unsigned int bucket_order;\n\nstatic void *pack_shadow(int memcgid, pg_data_t *pgdat, unsigned long eviction,\n\t\t\t bool workingset)\n{\n\teviction >>= bucket_order;\n\teviction &= EVICTION_MASK;\n\teviction = (eviction << MEM_CGROUP_ID_SHIFT) | memcgid;\n\teviction = (eviction << NODES_SHIFT) | pgdat->node_id;\n\teviction = (eviction << 1) | workingset;\n\n\treturn xa_mk_value(eviction);\n}"
  }
]