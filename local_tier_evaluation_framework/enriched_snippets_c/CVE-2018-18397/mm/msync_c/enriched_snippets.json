[
  {
    "function_name": "msync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/msync.c",
    "lines": "32-108",
    "snippet": "SYSCALL_DEFINE3(msync, unsigned long, start, size_t, len, int, flags)\n{\n\tunsigned long end;\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma;\n\tint unmapped_error = 0;\n\tint error = -EINVAL;\n\n\tif (flags & ~(MS_ASYNC | MS_INVALIDATE | MS_SYNC))\n\t\tgoto out;\n\tif (offset_in_page(start))\n\t\tgoto out;\n\tif ((flags & MS_ASYNC) && (flags & MS_SYNC))\n\t\tgoto out;\n\terror = -ENOMEM;\n\tlen = (len + ~PAGE_MASK) & PAGE_MASK;\n\tend = start + len;\n\tif (end < start)\n\t\tgoto out;\n\terror = 0;\n\tif (end == start)\n\t\tgoto out;\n\t/*\n\t * If the interval [start,end) covers some unmapped address ranges,\n\t * just ignore them, but return -ENOMEM at the end.\n\t */\n\tdown_read(&mm->mmap_sem);\n\tvma = find_vma(mm, start);\n\tfor (;;) {\n\t\tstruct file *file;\n\t\tloff_t fstart, fend;\n\n\t\t/* Still start < end. */\n\t\terror = -ENOMEM;\n\t\tif (!vma)\n\t\t\tgoto out_unlock;\n\t\t/* Here start < vma->vm_end. */\n\t\tif (start < vma->vm_start) {\n\t\t\tstart = vma->vm_start;\n\t\t\tif (start >= end)\n\t\t\t\tgoto out_unlock;\n\t\t\tunmapped_error = -ENOMEM;\n\t\t}\n\t\t/* Here vma->vm_start <= start < vma->vm_end. */\n\t\tif ((flags & MS_INVALIDATE) &&\n\t\t\t\t(vma->vm_flags & VM_LOCKED)) {\n\t\t\terror = -EBUSY;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tfile = vma->vm_file;\n\t\tfstart = (start - vma->vm_start) +\n\t\t\t ((loff_t)vma->vm_pgoff << PAGE_SHIFT);\n\t\tfend = fstart + (min(end, vma->vm_end) - start) - 1;\n\t\tstart = vma->vm_end;\n\t\tif ((flags & MS_SYNC) && file &&\n\t\t\t\t(vma->vm_flags & VM_SHARED)) {\n\t\t\tget_file(file);\n\t\t\tup_read(&mm->mmap_sem);\n\t\t\terror = vfs_fsync_range(file, fstart, fend, 1);\n\t\t\tfput(file);\n\t\t\tif (error || start >= end)\n\t\t\t\tgoto out;\n\t\t\tdown_read(&mm->mmap_sem);\n\t\t\tvma = find_vma(mm, start);\n\t\t} else {\n\t\t\tif (start >= end) {\n\t\t\t\terror = 0;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tvma = vma->vm_next;\n\t\t}\n\t}\nout_unlock:\n\tup_read(&mm->mmap_sem);\nout:\n\treturn error ? : unmapped_error;\n}",
    "includes": [
      "#include <linux/sched.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/file.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sched.h>\n#include <linux/syscalls.h>\n#include <linux/file.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nSYSCALL_DEFINE3(msync, unsigned long, start, size_t, len, int, flags)\n{\n\tunsigned long end;\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma;\n\tint unmapped_error = 0;\n\tint error = -EINVAL;\n\n\tif (flags & ~(MS_ASYNC | MS_INVALIDATE | MS_SYNC))\n\t\tgoto out;\n\tif (offset_in_page(start))\n\t\tgoto out;\n\tif ((flags & MS_ASYNC) && (flags & MS_SYNC))\n\t\tgoto out;\n\terror = -ENOMEM;\n\tlen = (len + ~PAGE_MASK) & PAGE_MASK;\n\tend = start + len;\n\tif (end < start)\n\t\tgoto out;\n\terror = 0;\n\tif (end == start)\n\t\tgoto out;\n\t/*\n\t * If the interval [start,end) covers some unmapped address ranges,\n\t * just ignore them, but return -ENOMEM at the end.\n\t */\n\tdown_read(&mm->mmap_sem);\n\tvma = find_vma(mm, start);\n\tfor (;;) {\n\t\tstruct file *file;\n\t\tloff_t fstart, fend;\n\n\t\t/* Still start < end. */\n\t\terror = -ENOMEM;\n\t\tif (!vma)\n\t\t\tgoto out_unlock;\n\t\t/* Here start < vma->vm_end. */\n\t\tif (start < vma->vm_start) {\n\t\t\tstart = vma->vm_start;\n\t\t\tif (start >= end)\n\t\t\t\tgoto out_unlock;\n\t\t\tunmapped_error = -ENOMEM;\n\t\t}\n\t\t/* Here vma->vm_start <= start < vma->vm_end. */\n\t\tif ((flags & MS_INVALIDATE) &&\n\t\t\t\t(vma->vm_flags & VM_LOCKED)) {\n\t\t\terror = -EBUSY;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tfile = vma->vm_file;\n\t\tfstart = (start - vma->vm_start) +\n\t\t\t ((loff_t)vma->vm_pgoff << PAGE_SHIFT);\n\t\tfend = fstart + (min(end, vma->vm_end) - start) - 1;\n\t\tstart = vma->vm_end;\n\t\tif ((flags & MS_SYNC) && file &&\n\t\t\t\t(vma->vm_flags & VM_SHARED)) {\n\t\t\tget_file(file);\n\t\t\tup_read(&mm->mmap_sem);\n\t\t\terror = vfs_fsync_range(file, fstart, fend, 1);\n\t\t\tfput(file);\n\t\t\tif (error || start >= end)\n\t\t\t\tgoto out;\n\t\t\tdown_read(&mm->mmap_sem);\n\t\t\tvma = find_vma(mm, start);\n\t\t} else {\n\t\t\tif (start >= end) {\n\t\t\t\terror = 0;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tvma = vma->vm_next;\n\t\t}\n\t}\nout_unlock:\n\tup_read(&mm->mmap_sem);\nout:\n\treturn error ? : unmapped_error;\n}"
  }
]