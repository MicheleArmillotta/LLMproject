[
  {
    "function_name": "show_free_areas",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "4851-8225",
    "snippet": "void show_free_areas(unsigned int filter, nodemask_t *nodemask)\n{\n\tunsigned long free_pcp = 0;\n\tint cpu;\n\tstruct zone *zone;\n\tpg_data_t *pgdat;\n\n\tfor_each_populated_zone(zone) {\n\t\tif (show_mem_node_skip(filter, zone_to_nid(zone), nodemask))\n\t\t\tcontinue;\n\n\t\tfor_each_online_cpu(cpu)\n\t\t\tfree_pcp += per_cpu_ptr(zone->pageset, cpu)->pcp.count;\n\t}\n\n\tprintk(\"active_anon:%lu inactive_anon:%lu isolated_anon:%lu\\n\"\n\t\t\" active_file:%lu inactive_file:%lu isolated_file:%lu\\n\"\n\t\t\" unevictable:%lu dirty:%lu writeback:%lu unstable:%lu\\n\"\n\t\t\" slab_reclaimable:%lu slab_unreclaimable:%lu\\n\"\n\t\t\" mapped:%lu shmem:%lu pagetables:%lu bounce:%lu\\n\"\n\t\t\" free:%lu free_pcp:%lu free_cma:%lu\\n\",\n\t\tglobal_node_page_state(NR_ACTIVE_ANON),\n\t\tglobal_node_page_state(NR_INACTIVE_ANON),\n\t\tglobal_node_page_state(NR_ISOLATED_ANON),\n\t\tglobal_node_page_state(NR_ACTIVE_FILE),\n\t\tglobal_node_page_state(NR_INACTIVE_FILE),\n\t\tglobal_node_page_state(NR_ISOLATED_FILE),\n\t\tglobal_node_page_state(NR_UNEVICTABLE),\n\t\tglobal_node_page_state(NR_FILE_DIRTY),\n\t\tglobal_node_page_state(NR_WRITEBACK),\n\t\tglobal_node_page_state(NR_UNSTABLE_NFS),\n\t\tglobal_node_page_state(NR_SLAB_RECLAIMABLE),\n\t\tglobal_node_page_state(NR_SLAB_UNRECLAIMABLE),\n\t\tglobal_node_page_state(NR_FILE_MAPPED),\n\t\tglobal_node_page_state(NR_SHMEM),\n\t\tglobal_zone_page_state(NR_PAGETABLE),\n\t\tglobal_zone_page_state(NR_BOUNCE),\n\t\tglobal_zone_page_state(NR_FREE_PAGES),\n\t\tfree_pcp,\n\t\tglobal_zone_page_state(NR_FREE_CMA_PAGES));\n\n\tfor_each_online_pgdat(pgdat) {\n\t\tif (show_mem_node_skip(filter, pgdat->node_id, nodemask))\n\t\t\tcontinue;\n\n\t\tprintk(\"Node %d\"\n\t\t\t\" active_anon:%lukB\"\n\t\t\t\" inactive_anon:%lukB\"\n\t\t\t\" active_file:%lukB\"\n\t\t\t\" inactive_file:%lukB\"\n\t\t\t\" unevictable:%lukB\"\n\t\t\t\" isolated(anon):%lukB\"\n\t\t\t\" isolated(file):%lukB\"\n\t\t\t\" mapped:%lukB\"\n\t\t\t\" dirty:%lukB\"\n\t\t\t\" writeback:%lukB\"\n\t\t\t\" shmem:%lukB\"\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\t\t\t\" shmem_thp: %lukB\"\n\t\t\t\" shmem_pmdmapped: %lukB\"\n\t\t\t\" anon_thp: %lukB\"\n#endif\n\t\t\t\" writeback_tmp:%lukB\"\n\t\t\t\" unstable:%lukB\"\n\t\t\t\" all_unreclaimable? %s\"\n\t\t\t\"\\n\",\n\t\t\tpgdat->node_id,\n\t\t\tK(node_page_state(pgdat, NR_ACTIVE_ANON)),\n\t\t\tK(node_page_state(pgdat, NR_INACTIVE_ANON)),\n\t\t\tK(node_page_state(pgdat, NR_ACTIVE_FILE)),\n\t\t\tK(node_page_state(pgdat, NR_INACTIVE_FILE)),\n\t\t\tK(node_page_state(pgdat, NR_UNEVICTABLE)),\n\t\t\tK(node_page_state(pgdat, NR_ISOLATED_ANON)),\n\t\t\tK(node_page_state(pgdat, NR_ISOLATED_FILE)),\n\t\t\tK(node_page_state(pgdat, NR_FILE_MAPPED)),\n\t\t\tK(node_page_state(pgdat, NR_FILE_DIRTY)),\n\t\t\tK(node_page_state(pgdat, NR_WRITEBACK)),\n\t\t\tK(node_page_state(pgdat, NR_SHMEM)),\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\t\t\tK(node_page_state(pgdat, NR_SHMEM_THPS) * HPAGE_PMD_NR),\n\t\t\tK(node_page_state(pgdat, NR_SHMEM_PMDMAPPED)\n\t\t\t\t\t* HPAGE_PMD_NR),\n\t\t\tK(node_page_state(pgdat, NR_ANON_THPS) * HPAGE_PMD_NR),\n#endif\n\t\t\tK(node_page_state(pgdat, NR_WRITEBACK_TEMP)),\n\t\t\tK(node_page_state(pgdat, NR_UNSTABLE_NFS)),\n\t\t\tpgdat->kswapd_failures >= MAX_RECLAIM_RETRIES ?\n\t\t\t\t\"yes\" : \"no\");\n\t}\n\n\tfor_each_populated_zone(zone) {\n\t\tint i;\n\n\t\tif (show_mem_node_skip(filter, zone_to_nid(zone), nodemask))\n\t\t\tcontinue;\n\n\t\tfree_pcp = 0;\n\t\tfor_each_online_cpu(cpu)\n\t\t\tfree_pcp += per_cpu_ptr(zone->pageset, cpu)->pcp.count;\n\n\t\tshow_node(zone);\n\t\tprintk(KERN_CONT\n\t\t\t\"%s\"\n\t\t\t\" free:%lukB\"\n\t\t\t\" min:%lukB\"\n\t\t\t\" low:%lukB\"\n\t\t\t\" high:%lukB\"\n\t\t\t\" active_anon:%lukB\"\n\t\t\t\" inactive_anon:%lukB\"\n\t\t\t\" active_file:%lukB\"\n\t\t\t\" inactive_file:%lukB\"\n\t\t\t\" unevictable:%lukB\"\n\t\t\t\" writepending:%lukB\"\n\t\t\t\" present:%lukB\"\n\t\t\t\" managed:%lukB\"\n\t\t\t\" mlocked:%lukB\"\n\t\t\t\" kernel_stack:%lukB\"\n\t\t\t\" pagetables:%lukB\"\n\t\t\t\" bounce:%lukB\"\n\t\t\t\" free_pcp:%lukB\"\n\t\t\t\" local_pcp:%ukB\"\n\t\t\t\" free_cma:%lukB\"\n\t\t\t\"\\n\",\n\t\t\tzone->name,\n\t\t\tK(zone_page_state(zone, NR_FREE_PAGES)),\n\t\t\tK(min_wmark_pages(zone)),\n\t\t\tK(low_wmark_pages(zone)),\n\t\t\tK(high_wmark_pages(zone)),\n\t\t\tK(zone_page_state(zone, NR_ZONE_ACTIVE_ANON)),\n\t\t\tK(zone_page_state(zone, NR_ZONE_INACTIVE_ANON)),\n\t\t\tK(zone_page_state(zone, NR_ZONE_ACTIVE_FILE)),\n\t\t\tK(zone_page_state(zone, NR_ZONE_INACTIVE_FILE)),\n\t\t\tK(zone_page_state(zone, NR_ZONE_UNEVICTABLE)),\n\t\t\tK(zone_page_state(zone, NR_ZONE_WRITE_PENDING)),\n\t\t\tK(zone->present_pages),\n\t\t\tK(zone->managed_pages),\n\t\t\tK(zone_page_state(zone, NR_MLOCK)),\n\t\t\tzone_page_state(zone, NR_KERNEL_STACK_KB),\n\t\t\tK(zone_page_state(zone, NR_PAGETABLE)),\n\t\t\tK(zone_page_state(zone, NR_BOUNCE)),\n\t\t\tK(free_pcp),\n\t\t\tK(this_cpu_read(zone->pageset->pcp.count)),\n\t\t\tK(zone_page_state(zone, NR_FREE_CMA_PAGES)));\n\t\tprintk(\"lowmem_reserve[]:\");\n\t\tfor (i = 0; i < MAX_NR_ZONES; i++)\n\t\t\tprintk(KERN_CONT \" %ld\", zone->lowmem_reserve[i]);\n\t\tprintk(KERN_CONT \"\\n\");\n\t}\n\n\tfor_each_populated_zone(zone) {\n\t\tunsigned int order;\n\t\tunsigned long nr[MAX_ORDER], flags, total = 0;\n\t\tunsigned char types[MAX_ORDER];\n\n\t\tif (show_mem_node_skip(filter, zone_to_nid(zone), nodemask))\n\t\t\tcontinue;\n\t\tshow_node(zone);\n\t\tprintk(KERN_CONT \"%s: \", zone->name);\n\n\t\tspin_lock_irqsave(&zone->lock, flags);\n\t\tfor (order = 0; order < MAX_ORDER; order++) {\n\t\t\tstruct free_area *area = &zone->free_area[order];\n\t\t\tint type;\n\n\t\t\tnr[order] = area->nr_free;\n\t\t\ttotal += nr[order] << order;\n\n\t\t\ttypes[order] = 0;\n\t\t\tfor (type = 0; type < MIGRATE_TYPES; type++) {\n\t\t\t\tif (!list_empty(&area->free_list[type]))\n\t\t\t\t\ttypes[order] |= 1 << type;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&zone->lock, flags);\n\t\tfor (order = 0; order < MAX_ORDER; order++) {\n\t\t\tprintk(KERN_CONT \"%lu*%lukB \",\n\t\t\t       nr[order], K(1UL) << order);\n\t\t\tif (nr[order])\n\t\t\t\tshow_migration_types(types[order]);\n\t\t}\n\t\tprintk(KERN_CONT \"= %lukB\\n\", K(total));\n\t}\n\n\thugetlb_show_meminfo();\n\n\tprintk(\"%ld total pagecache pages\\n\", global_node_page_state(NR_FILE_PAGES));\n\n\tshow_swap_cache_info();\n}\n\nstatic void zoneref_set_zone(struct zone *zone, struct zoneref *zoneref)\n{\n\tzoneref->zone = zone;\n\tzoneref->zone_idx = zone_idx(zone);\n}\n\n/*\n * Builds allocation fallback zone lists.\n *\n * Add all populated zones of a node to the zonelist.\n */\nstatic int build_zonerefs_node(pg_data_t *pgdat, struct zoneref *zonerefs)\n{\n\tstruct zone *zone;\n\tenum zone_type zone_type = MAX_NR_ZONES;\n\tint nr_zones = 0;\n\n\tdo {\n\t\tzone_type--;\n\t\tzone = pgdat->node_zones + zone_type;\n\t\tif (managed_zone(zone)) {\n\t\t\tzoneref_set_zone(zone, &zonerefs[nr_zones++]);\n\t\t\tcheck_highest_zone(zone_type);\n\t\t}\n\t} while (zone_type);\n\n\treturn nr_zones;\n}\n\n#ifdef CONFIG_NUMA\n\nstatic int __parse_numa_zonelist_order(char *s)\n{\n\t/*\n\t * We used to support different zonlists modes but they turned\n\t * out to be just not useful. Let's keep the warning in place\n\t * if somebody still use the cmd line parameter so that we do\n\t * not fail it silently\n\t */\n\tif (!(*s == 'd' || *s == 'D' || *s == 'n' || *s == 'N')) {\n\t\tpr_warn(\"Ignoring unsupported numa_zonelist_order value:  %s\\n\", s);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic __init int setup_numa_zonelist_order(char *s)\n{\n\tif (!s)\n\t\treturn 0;\n\n\treturn __parse_numa_zonelist_order(s);\n}\nearly_param(\"numa_zonelist_order\", setup_numa_zonelist_order);\n\nchar numa_zonelist_order[] = \"Node\";\n\n/*\n * sysctl handler for numa_zonelist_order\n */\nint numa_zonelist_order_handler(struct ctl_table *table, int write,\n\t\tvoid __user *buffer, size_t *length,\n\t\tloff_t *ppos)\n{\n\tchar *str;\n\tint ret;\n\n\tif (!write)\n\t\treturn proc_dostring(table, write, buffer, length, ppos);\n\tstr = memdup_user_nul(buffer, 16);\n\tif (IS_ERR(str))\n\t\treturn PTR_ERR(str);\n\n\tret = __parse_numa_zonelist_order(str);\n\tkfree(str);\n\treturn ret;\n}\n\n\n#define MAX_NODE_LOAD (nr_online_nodes)\nstatic int node_load[MAX_NUMNODES];\n\n/**\n * find_next_best_node - find the next node that should appear in a given node's fallback list\n * @node: node whose fallback list we're appending\n * @used_node_mask: nodemask_t of already used nodes\n *\n * We use a number of factors to determine which is the next node that should\n * appear on a given node's fallback list.  The node should not have appeared\n * already in @node's fallback list, and it should be the next closest node\n * according to the distance array (which contains arbitrary distance values\n * from each node to each node in the system), and should also prefer nodes\n * with no CPUs, since presumably they'll have very little allocation pressure\n * on them otherwise.\n * It returns -1 if no node is found.\n */\nstatic int find_next_best_node(int node, nodemask_t *used_node_mask)\n{\n\tint n, val;\n\tint min_val = INT_MAX;\n\tint best_node = NUMA_NO_NODE;\n\tconst struct cpumask *tmp = cpumask_of_node(0);\n\n\t/* Use the local node if we haven't already */\n\tif (!node_isset(node, *used_node_mask)) {\n\t\tnode_set(node, *used_node_mask);\n\t\treturn node;\n\t}\n\n\tfor_each_node_state(n, N_MEMORY) {\n\n\t\t/* Don't want a node to appear more than once */\n\t\tif (node_isset(n, *used_node_mask))\n\t\t\tcontinue;\n\n\t\t/* Use the distance array to find the distance */\n\t\tval = node_distance(node, n);\n\n\t\t/* Penalize nodes under us (\"prefer the next node\") */\n\t\tval += (n < node);\n\n\t\t/* Give preference to headless and unused nodes */\n\t\ttmp = cpumask_of_node(n);\n\t\tif (!cpumask_empty(tmp))\n\t\t\tval += PENALTY_FOR_NODE_WITH_CPUS;\n\n\t\t/* Slight preference for less loaded node */\n\t\tval *= (MAX_NODE_LOAD*MAX_NUMNODES);\n\t\tval += node_load[n];\n\n\t\tif (val < min_val) {\n\t\t\tmin_val = val;\n\t\t\tbest_node = n;\n\t\t}\n\t}\n\n\tif (best_node >= 0)\n\t\tnode_set(best_node, *used_node_mask);\n\n\treturn best_node;\n}\n\n\n/*\n * Build zonelists ordered by node and zones within node.\n * This results in maximum locality--normal zone overflows into local\n * DMA zone, if any--but risks exhausting DMA zone.\n */\nstatic void build_zonelists_in_node_order(pg_data_t *pgdat, int *node_order,\n\t\tunsigned nr_nodes)\n{\n\tstruct zoneref *zonerefs;\n\tint i;\n\n\tzonerefs = pgdat->node_zonelists[ZONELIST_FALLBACK]._zonerefs;\n\n\tfor (i = 0; i < nr_nodes; i++) {\n\t\tint nr_zones;\n\n\t\tpg_data_t *node = NODE_DATA(node_order[i]);\n\n\t\tnr_zones = build_zonerefs_node(node, zonerefs);\n\t\tzonerefs += nr_zones;\n\t}\n\tzonerefs->zone = NULL;\n\tzonerefs->zone_idx = 0;\n}\n\n/*\n * Build gfp_thisnode zonelists\n */\nstatic void build_thisnode_zonelists(pg_data_t *pgdat)\n{\n\tstruct zoneref *zonerefs;\n\tint nr_zones;\n\n\tzonerefs = pgdat->node_zonelists[ZONELIST_NOFALLBACK]._zonerefs;\n\tnr_zones = build_zonerefs_node(pgdat, zonerefs);\n\tzonerefs += nr_zones;\n\tzonerefs->zone = NULL;\n\tzonerefs->zone_idx = 0;\n}\n\n/*\n * Build zonelists ordered by zone and nodes within zones.\n * This results in conserving DMA zone[s] until all Normal memory is\n * exhausted, but results in overflowing to remote node while memory\n * may still exist in local DMA zone.\n */\n\nstatic void build_zonelists(pg_data_t *pgdat)\n{\n\tstatic int node_order[MAX_NUMNODES];\n\tint node, load, nr_nodes = 0;\n\tnodemask_t used_mask;\n\tint local_node, prev_node;\n\n\t/* NUMA-aware ordering of nodes */\n\tlocal_node = pgdat->node_id;\n\tload = nr_online_nodes;\n\tprev_node = local_node;\n\tnodes_clear(used_mask);\n\n\tmemset(node_order, 0, sizeof(node_order));\n\twhile ((node = find_next_best_node(local_node, &used_mask)) >= 0) {\n\t\t/*\n\t\t * We don't want to pressure a particular node.\n\t\t * So adding penalty to the first node in same\n\t\t * distance group to make it round-robin.\n\t\t */\n\t\tif (node_distance(local_node, node) !=\n\t\t    node_distance(local_node, prev_node))\n\t\t\tnode_load[node] = load;\n\n\t\tnode_order[nr_nodes++] = node;\n\t\tprev_node = node;\n\t\tload--;\n\t}\n\n\tbuild_zonelists_in_node_order(pgdat, node_order, nr_nodes);\n\tbuild_thisnode_zonelists(pgdat);\n}\n\n#ifdef CONFIG_HAVE_MEMORYLESS_NODES\n/*\n * Return node id of node used for \"local\" allocations.\n * I.e., first node id of first zone in arg node's generic zonelist.\n * Used for initializing percpu 'numa_mem', which is used primarily\n * for kernel allocations, so use GFP_KERNEL flags to locate zonelist.\n */\nint local_memory_node(int node)\n{\n\tstruct zoneref *z;\n\n\tz = first_zones_zonelist(node_zonelist(node, GFP_KERNEL),\n\t\t\t\t   gfp_zone(GFP_KERNEL),\n\t\t\t\t   NULL);\n\treturn zone_to_nid(z->zone);\n}\n#endif\n\nstatic void setup_min_unmapped_ratio(void);\nstatic void setup_min_slab_ratio(void);\n#else\t/* CONFIG_NUMA */\n\nstatic void build_zonelists(pg_data_t *pgdat)\n{\n\tint node, local_node;\n\tstruct zoneref *zonerefs;\n\tint nr_zones;\n\n\tlocal_node = pgdat->node_id;\n\n\tzonerefs = pgdat->node_zonelists[ZONELIST_FALLBACK]._zonerefs;\n\tnr_zones = build_zonerefs_node(pgdat, zonerefs);\n\tzonerefs += nr_zones;\n\n\t/*\n\t * Now we build the zonelist so that it contains the zones\n\t * of all the other nodes.\n\t * We don't want to pressure a particular node, so when\n\t * building the zones for node N, we make sure that the\n\t * zones coming right after the local ones are those from\n\t * node N+1 (modulo N)\n\t */\n\tfor (node = local_node + 1; node < MAX_NUMNODES; node++) {\n\t\tif (!node_online(node))\n\t\t\tcontinue;\n\t\tnr_zones = build_zonerefs_node(NODE_DATA(node), zonerefs);\n\t\tzonerefs += nr_zones;\n\t}\n\tfor (node = 0; node < local_node; node++) {\n\t\tif (!node_online(node))\n\t\t\tcontinue;\n\t\tnr_zones = build_zonerefs_node(NODE_DATA(node), zonerefs);\n\t\tzonerefs += nr_zones;\n\t}\n\n\tzonerefs->zone = NULL;\n\tzonerefs->zone_idx = 0;\n}\n\n#endif\t/* CONFIG_NUMA */\n\n/*\n * Boot pageset table. One per cpu which is going to be used for all\n * zones and all nodes. The parameters will be set in such a way\n * that an item put on a list will immediately be handed over to\n * the buddy list. This is safe since pageset manipulation is done\n * with interrupts disabled.\n *\n * The boot_pagesets must be kept even after bootup is complete for\n * unused processors and/or zones. They do play a role for bootstrapping\n * hotplugged processors.\n *\n * zoneinfo_show() and maybe other functions do\n * not check if the processor is online before following the pageset pointer.\n * Other parts of the kernel may not check if the zone is available.\n */\nstatic void setup_pageset(struct per_cpu_pageset *p, unsigned long batch);\nstatic DEFINE_PER_CPU(struct per_cpu_pageset, boot_pageset);\nstatic DEFINE_PER_CPU(struct per_cpu_nodestat, boot_nodestats);\n\nstatic void __build_all_zonelists(void *data)\n{\n\tint nid;\n\tint __maybe_unused cpu;\n\tpg_data_t *self = data;\n\tstatic DEFINE_SPINLOCK(lock);\n\n\tspin_lock(&lock);\n\n#ifdef CONFIG_NUMA\n\tmemset(node_load, 0, sizeof(node_load));\n#endif\n\n\t/*\n\t * This node is hotadded and no memory is yet present.   So just\n\t * building zonelists is fine - no need to touch other nodes.\n\t */\n\tif (self && !node_online(self->node_id)) {\n\t\tbuild_zonelists(self);\n\t} else {\n\t\tfor_each_online_node(nid) {\n\t\t\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\t\t\tbuild_zonelists(pgdat);\n\t\t}\n\n#ifdef CONFIG_HAVE_MEMORYLESS_NODES\n\t\t/*\n\t\t * We now know the \"local memory node\" for each node--\n\t\t * i.e., the node of the first zone in the generic zonelist.\n\t\t * Set up numa_mem percpu variable for on-line cpus.  During\n\t\t * boot, only the boot cpu should be on-line;  we'll init the\n\t\t * secondary cpus' numa_mem as they come on-line.  During\n\t\t * node/memory hotplug, we'll fixup all on-line cpus.\n\t\t */\n\t\tfor_each_online_cpu(cpu)\n\t\t\tset_cpu_numa_mem(cpu, local_memory_node(cpu_to_node(cpu)));\n#endif\n\t}\n\n\tspin_unlock(&lock);\n}\n\nstatic noinline void __init\nbuild_all_zonelists_init(void)\n{\n\tint cpu;\n\n\t__build_all_zonelists(NULL);\n\n\t/*\n\t * Initialize the boot_pagesets that are going to be used\n\t * for bootstrapping processors. The real pagesets for\n\t * each zone will be allocated later when the per cpu\n\t * allocator is available.\n\t *\n\t * boot_pagesets are used also for bootstrapping offline\n\t * cpus if the system is already booted because the pagesets\n\t * are needed to initialize allocators on a specific cpu too.\n\t * F.e. the percpu allocator needs the page allocator which\n\t * needs the percpu allocator in order to allocate its pagesets\n\t * (a chicken-egg dilemma).\n\t */\n\tfor_each_possible_cpu(cpu)\n\t\tsetup_pageset(&per_cpu(boot_pageset, cpu), 0);\n\n\tmminit_verify_zonelist();\n\tcpuset_init_current_mems_allowed();\n}\n\n/*\n * unless system_state == SYSTEM_BOOTING.\n *\n * __ref due to call of __init annotated helper build_all_zonelists_init\n * [protected by SYSTEM_BOOTING].\n */\nvoid __ref build_all_zonelists(pg_data_t *pgdat)\n{\n\tif (system_state == SYSTEM_BOOTING) {\n\t\tbuild_all_zonelists_init();\n\t} else {\n\t\t__build_all_zonelists(pgdat);\n\t\t/* cpuset refresh routine should be here */\n\t}\n\tvm_total_pages = nr_free_pagecache_pages();\n\t/*\n\t * Disable grouping by mobility if the number of pages in the\n\t * system is too low to allow the mechanism to work. It would be\n\t * more accurate, but expensive to check per-zone. This check is\n\t * made on memory-hotadd so a system can start with mobility\n\t * disabled and enable it later\n\t */\n\tif (vm_total_pages < (pageblock_nr_pages * MIGRATE_TYPES))\n\t\tpage_group_by_mobility_disabled = 1;\n\telse\n\t\tpage_group_by_mobility_disabled = 0;\n\n\tpr_info(\"Built %i zonelists, mobility grouping %s.  Total pages: %ld\\n\",\n\t\tnr_online_nodes,\n\t\tpage_group_by_mobility_disabled ? \"off\" : \"on\",\n\t\tvm_total_pages);\n#ifdef CONFIG_NUMA\n\tpr_info(\"Policy zone: %s\\n\", zone_names[policy_zone]);\n#endif\n}\n\n/* If zone is ZONE_MOVABLE but memory is mirrored, it is an overlapped init */\nstatic bool __meminit\noverlap_memmap_init(unsigned long zone, unsigned long *pfn)\n{\n#ifdef CONFIG_HAVE_MEMBLOCK_NODE_MAP\n\tstatic struct memblock_region *r;\n\n\tif (mirrored_kernelcore && zone == ZONE_MOVABLE) {\n\t\tif (!r || *pfn >= memblock_region_memory_end_pfn(r)) {\n\t\t\tfor_each_memblock(memory, r) {\n\t\t\t\tif (*pfn < memblock_region_memory_end_pfn(r))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (*pfn >= memblock_region_memory_base_pfn(r) &&\n\t\t    memblock_is_mirror(r)) {\n\t\t\t*pfn = memblock_region_memory_end_pfn(r);\n\t\t\treturn true;\n\t\t}\n\t}\n#endif\n\treturn false;\n}\n\n/*\n * Initially all pages are reserved - free ones are freed\n * up by memblock_free_all() once the early boot process is\n * done. Non-atomic initialization, single-pass.\n */\nvoid __meminit memmap_init_zone(unsigned long size, int nid, unsigned long zone,\n\t\tunsigned long start_pfn, enum memmap_context context,\n\t\tstruct vmem_altmap *altmap)\n{\n\tunsigned long pfn, end_pfn = start_pfn + size;\n\tstruct page *page;\n\n\tif (highest_memmap_pfn < end_pfn - 1)\n\t\thighest_memmap_pfn = end_pfn - 1;\n\n#ifdef CONFIG_ZONE_DEVICE\n\t/*\n\t * Honor reservation requested by the driver for this ZONE_DEVICE\n\t * memory. We limit the total number of pages to initialize to just\n\t * those that might contain the memory mapping. We will defer the\n\t * ZONE_DEVICE page initialization until after we have released\n\t * the hotplug lock.\n\t */\n\tif (zone == ZONE_DEVICE) {\n\t\tif (!altmap)\n\t\t\treturn;\n\n\t\tif (start_pfn == altmap->base_pfn)\n\t\t\tstart_pfn += altmap->reserve;\n\t\tend_pfn = altmap->base_pfn + vmem_altmap_offset(altmap);\n\t}\n#endif\n\n\tfor (pfn = start_pfn; pfn < end_pfn; pfn++) {\n\t\t/*\n\t\t * There can be holes in boot-time mem_map[]s handed to this\n\t\t * function.  They do not exist on hotplugged memory.\n\t\t */\n\t\tif (context == MEMMAP_EARLY) {\n\t\t\tif (!early_pfn_valid(pfn))\n\t\t\t\tcontinue;\n\t\t\tif (!early_pfn_in_nid(pfn, nid))\n\t\t\t\tcontinue;\n\t\t\tif (overlap_memmap_init(zone, &pfn))\n\t\t\t\tcontinue;\n\t\t\tif (defer_init(nid, pfn, end_pfn))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tpage = pfn_to_page(pfn);\n\t\t__init_single_page(page, pfn, zone, nid);\n\t\tif (context == MEMMAP_HOTPLUG)\n\t\t\t__SetPageReserved(page);\n\n\t\t/*\n\t\t * Mark the block movable so that blocks are reserved for\n\t\t * movable at startup. This will force kernel allocations\n\t\t * to reserve their blocks rather than leaking throughout\n\t\t * the address space during boot when many long-lived\n\t\t * kernel allocations are made.\n\t\t *\n\t\t * bitmap is created for zone's valid pfn range. but memmap\n\t\t * can be created for invalid pages (for alignment)\n\t\t * check here not to call set_pageblock_migratetype() against\n\t\t * pfn out of zone.\n\t\t */\n\t\tif (!(pfn & (pageblock_nr_pages - 1))) {\n\t\t\tset_pageblock_migratetype(page, MIGRATE_MOVABLE);\n\t\t\tcond_resched();\n\t\t}\n\t}\n}\n\n#ifdef CONFIG_ZONE_DEVICE\nvoid __ref memmap_init_zone_device(struct zone *zone,\n\t\t\t\t   unsigned long start_pfn,\n\t\t\t\t   unsigned long size,\n\t\t\t\t   struct dev_pagemap *pgmap)\n{\n\tunsigned long pfn, end_pfn = start_pfn + size;\n\tstruct pglist_data *pgdat = zone->zone_pgdat;\n\tunsigned long zone_idx = zone_idx(zone);\n\tunsigned long start = jiffies;\n\tint nid = pgdat->node_id;\n\n\tif (WARN_ON_ONCE(!pgmap || !is_dev_zone(zone)))\n\t\treturn;\n\n\t/*\n\t * The call to memmap_init_zone should have already taken care\n\t * of the pages reserved for the memmap, so we can just jump to\n\t * the end of that region and start processing the device pages.\n\t */\n\tif (pgmap->altmap_valid) {\n\t\tstruct vmem_altmap *altmap = &pgmap->altmap;\n\n\t\tstart_pfn = altmap->base_pfn + vmem_altmap_offset(altmap);\n\t\tsize = end_pfn - start_pfn;\n\t}\n\n\tfor (pfn = start_pfn; pfn < end_pfn; pfn++) {\n\t\tstruct page *page = pfn_to_page(pfn);\n\n\t\t__init_single_page(page, pfn, zone_idx, nid);\n\n\t\t/*\n\t\t * Mark page reserved as it will need to wait for onlining\n\t\t * phase for it to be fully associated with a zone.\n\t\t *\n\t\t * We can use the non-atomic __set_bit operation for setting\n\t\t * the flag as we are still initializing the pages.\n\t\t */\n\t\t__SetPageReserved(page);\n\n\t\t/*\n\t\t * ZONE_DEVICE pages union ->lru with a ->pgmap back\n\t\t * pointer and hmm_data.  It is a bug if a ZONE_DEVICE\n\t\t * page is ever freed or placed on a driver-private list.\n\t\t */\n\t\tpage->pgmap = pgmap;\n\t\tpage->hmm_data = 0;\n\n\t\t/*\n\t\t * Mark the block movable so that blocks are reserved for\n\t\t * movable at startup. This will force kernel allocations\n\t\t * to reserve their blocks rather than leaking throughout\n\t\t * the address space during boot when many long-lived\n\t\t * kernel allocations are made.\n\t\t *\n\t\t * bitmap is created for zone's valid pfn range. but memmap\n\t\t * can be created for invalid pages (for alignment)\n\t\t * check here not to call set_pageblock_migratetype() against\n\t\t * pfn out of zone.\n\t\t *\n\t\t * Please note that MEMMAP_HOTPLUG path doesn't clear memmap\n\t\t * because this is done early in sparse_add_one_section\n\t\t */\n\t\tif (!(pfn & (pageblock_nr_pages - 1))) {\n\t\t\tset_pageblock_migratetype(page, MIGRATE_MOVABLE);\n\t\t\tcond_resched();\n\t\t}\n\t}\n\n\tpr_info(\"%s initialised, %lu pages in %ums\\n\", dev_name(pgmap->dev),\n\t\tsize, jiffies_to_msecs(jiffies - start));\n}\n\n#endif\nstatic void __meminit zone_init_free_lists(struct zone *zone)\n{\n\tunsigned int order, t;\n\tfor_each_migratetype_order(order, t) {\n\t\tINIT_LIST_HEAD(&zone->free_area[order].free_list[t]);\n\t\tzone->free_area[order].nr_free = 0;\n\t}\n}\n\nvoid __meminit __weak memmap_init(unsigned long size, int nid,\n\t\t\t\t  unsigned long zone, unsigned long start_pfn)\n{\n\tmemmap_init_zone(size, nid, zone, start_pfn, MEMMAP_EARLY, NULL);\n}\n\nstatic int zone_batchsize(struct zone *zone)\n{\n#ifdef CONFIG_MMU\n\tint batch;\n\n\t/*\n\t * The per-cpu-pages pools are set to around 1000th of the\n\t * size of the zone.\n\t */\n\tbatch = zone->managed_pages / 1024;\n\t/* But no more than a meg. */\n\tif (batch * PAGE_SIZE > 1024 * 1024)\n\t\tbatch = (1024 * 1024) / PAGE_SIZE;\n\tbatch /= 4;\t\t/* We effectively *= 4 below */\n\tif (batch < 1)\n\t\tbatch = 1;\n\n\t/*\n\t * Clamp the batch to a 2^n - 1 value. Having a power\n\t * of 2 value was found to be more likely to have\n\t * suboptimal cache aliasing properties in some cases.\n\t *\n\t * For example if 2 tasks are alternately allocating\n\t * batches of pages, one task can end up with a lot\n\t * of pages of one half of the possible page colors\n\t * and the other with pages of the other colors.\n\t */\n\tbatch = rounddown_pow_of_two(batch + batch/2) - 1;\n\n\treturn batch;\n\n#else\n\t/* The deferral and batching of frees should be suppressed under NOMMU\n\t * conditions.\n\t *\n\t * The problem is that NOMMU needs to be able to allocate large chunks\n\t * of contiguous memory as there's no hardware page translation to\n\t * assemble apparent contiguous memory from discontiguous pages.\n\t *\n\t * Queueing large contiguous runs of pages for batching, however,\n\t * causes the pages to actually be freed in smaller chunks.  As there\n\t * can be a significant delay between the individual batches being\n\t * recycled, this leads to the once large chunks of space being\n\t * fragmented and becoming unavailable for high-order allocations.\n\t */\n\treturn 0;\n#endif\n}\n\n/*\n * pcp->high and pcp->batch values are related and dependent on one another:\n * ->batch must never be higher then ->high.\n * The following function updates them in a safe manner without read side\n * locking.\n *\n * Any new users of pcp->batch and pcp->high should ensure they can cope with\n * those fields changing asynchronously (acording the the above rule).\n *\n * mutex_is_locked(&pcp_batch_high_lock) required when calling this function\n * outside of boot time (or some other assurance that no concurrent updaters\n * exist).\n */\nstatic void pageset_update(struct per_cpu_pages *pcp, unsigned long high,\n\t\tunsigned long batch)\n{\n       /* start with a fail safe value for batch */\n\tpcp->batch = 1;\n\tsmp_wmb();\n\n       /* Update high, then batch, in order */\n\tpcp->high = high;\n\tsmp_wmb();\n\n\tpcp->batch = batch;\n}\n\n/* a companion to pageset_set_high() */\nstatic void pageset_set_batch(struct per_cpu_pageset *p, unsigned long batch)\n{\n\tpageset_update(&p->pcp, 6 * batch, max(1UL, 1 * batch));\n}\n\nstatic void pageset_init(struct per_cpu_pageset *p)\n{\n\tstruct per_cpu_pages *pcp;\n\tint migratetype;\n\n\tmemset(p, 0, sizeof(*p));\n\n\tpcp = &p->pcp;\n\tpcp->count = 0;\n\tfor (migratetype = 0; migratetype < MIGRATE_PCPTYPES; migratetype++)\n\t\tINIT_LIST_HEAD(&pcp->lists[migratetype]);\n}\n\nstatic void setup_pageset(struct per_cpu_pageset *p, unsigned long batch)\n{\n\tpageset_init(p);\n\tpageset_set_batch(p, batch);\n}\n\n/*\n * pageset_set_high() sets the high water mark for hot per_cpu_pagelist\n * to the value high for the pageset p.\n */\nstatic void pageset_set_high(struct per_cpu_pageset *p,\n\t\t\t\tunsigned long high)\n{\n\tunsigned long batch = max(1UL, high / 4);\n\tif ((high / 4) > (PAGE_SHIFT * 8))\n\t\tbatch = PAGE_SHIFT * 8;\n\n\tpageset_update(&p->pcp, high, batch);\n}\n\nstatic void pageset_set_high_and_batch(struct zone *zone,\n\t\t\t\t       struct per_cpu_pageset *pcp)\n{\n\tif (percpu_pagelist_fraction)\n\t\tpageset_set_high(pcp,\n\t\t\t(zone->managed_pages /\n\t\t\t\tpercpu_pagelist_fraction));\n\telse\n\t\tpageset_set_batch(pcp, zone_batchsize(zone));\n}\n\nstatic void __meminit zone_pageset_init(struct zone *zone, int cpu)\n{\n\tstruct per_cpu_pageset *pcp = per_cpu_ptr(zone->pageset, cpu);\n\n\tpageset_init(pcp);\n\tpageset_set_high_and_batch(zone, pcp);\n}\n\nvoid __meminit setup_zone_pageset(struct zone *zone)\n{\n\tint cpu;\n\tzone->pageset = alloc_percpu(struct per_cpu_pageset);\n\tfor_each_possible_cpu(cpu)\n\t\tzone_pageset_init(zone, cpu);\n}\n\n/*\n * Allocate per cpu pagesets and initialize them.\n * Before this call only boot pagesets were available.\n */\nvoid __init setup_per_cpu_pageset(void)\n{\n\tstruct pglist_data *pgdat;\n\tstruct zone *zone;\n\n\tfor_each_populated_zone(zone)\n\t\tsetup_zone_pageset(zone);\n\n\tfor_each_online_pgdat(pgdat)\n\t\tpgdat->per_cpu_nodestats =\n\t\t\talloc_percpu(struct per_cpu_nodestat);\n}\n\nstatic __meminit void zone_pcp_init(struct zone *zone)\n{\n\t/*\n\t * per cpu subsystem is not up at this point. The following code\n\t * relies on the ability of the linker to provide the\n\t * offset of a (static) per cpu variable into the per cpu area.\n\t */\n\tzone->pageset = &boot_pageset;\n\n\tif (populated_zone(zone))\n\t\tprintk(KERN_DEBUG \"  %s zone: %lu pages, LIFO batch:%u\\n\",\n\t\t\tzone->name, zone->present_pages,\n\t\t\t\t\t zone_batchsize(zone));\n}\n\nvoid __meminit init_currently_empty_zone(struct zone *zone,\n\t\t\t\t\tunsigned long zone_start_pfn,\n\t\t\t\t\tunsigned long size)\n{\n\tstruct pglist_data *pgdat = zone->zone_pgdat;\n\tint zone_idx = zone_idx(zone) + 1;\n\n\tif (zone_idx > pgdat->nr_zones)\n\t\tpgdat->nr_zones = zone_idx;\n\n\tzone->zone_start_pfn = zone_start_pfn;\n\n\tmminit_dprintk(MMINIT_TRACE, \"memmap_init\",\n\t\t\t\"Initialising map node %d zone %lu pfns %lu -> %lu\\n\",\n\t\t\tpgdat->node_id,\n\t\t\t(unsigned long)zone_idx(zone),\n\t\t\tzone_start_pfn, (zone_start_pfn + size));\n\n\tzone_init_free_lists(zone);\n\tzone->initialized = 1;\n}\n\n#ifdef CONFIG_HAVE_MEMBLOCK_NODE_MAP\n#ifndef CONFIG_HAVE_ARCH_EARLY_PFN_TO_NID\n\n/*\n * Required by SPARSEMEM. Given a PFN, return what node the PFN is on.\n */\nint __meminit __early_pfn_to_nid(unsigned long pfn,\n\t\t\t\t\tstruct mminit_pfnnid_cache *state)\n{\n\tunsigned long start_pfn, end_pfn;\n\tint nid;\n\n\tif (state->last_start <= pfn && pfn < state->last_end)\n\t\treturn state->last_nid;\n\n\tnid = memblock_search_pfn_nid(pfn, &start_pfn, &end_pfn);\n\tif (nid != -1) {\n\t\tstate->last_start = start_pfn;\n\t\tstate->last_end = end_pfn;\n\t\tstate->last_nid = nid;\n\t}\n\n\treturn nid;\n}\n#endif /* CONFIG_HAVE_ARCH_EARLY_PFN_TO_NID */\n\n/**\n * free_bootmem_with_active_regions - Call memblock_free_early_nid for each active range\n * @nid: The node to free memory on. If MAX_NUMNODES, all nodes are freed.\n * @max_low_pfn: The highest PFN that will be passed to memblock_free_early_nid\n *\n * If an architecture guarantees that all ranges registered contain no holes\n * and may be freed, this this function may be used instead of calling\n * memblock_free_early_nid() manually.\n */\nvoid __init free_bootmem_with_active_regions(int nid, unsigned long max_low_pfn)\n{\n\tunsigned long start_pfn, end_pfn;\n\tint i, this_nid;\n\n\tfor_each_mem_pfn_range(i, nid, &start_pfn, &end_pfn, &this_nid) {\n\t\tstart_pfn = min(start_pfn, max_low_pfn);\n\t\tend_pfn = min(end_pfn, max_low_pfn);\n\n\t\tif (start_pfn < end_pfn)\n\t\t\tmemblock_free_early_nid(PFN_PHYS(start_pfn),\n\t\t\t\t\t(end_pfn - start_pfn) << PAGE_SHIFT,\n\t\t\t\t\tthis_nid);\n\t}\n}\n\n/**\n * sparse_memory_present_with_active_regions - Call memory_present for each active range\n * @nid: The node to call memory_present for. If MAX_NUMNODES, all nodes will be used.\n *\n * If an architecture guarantees that all ranges registered contain no holes and may\n * be freed, this function may be used instead of calling memory_present() manually.\n */\nvoid __init sparse_memory_present_with_active_regions(int nid)\n{\n\tunsigned long start_pfn, end_pfn;\n\tint i, this_nid;\n\n\tfor_each_mem_pfn_range(i, nid, &start_pfn, &end_pfn, &this_nid)\n\t\tmemory_present(this_nid, start_pfn, end_pfn);\n}\n\n/**\n * get_pfn_range_for_nid - Return the start and end page frames for a node\n * @nid: The nid to return the range for. If MAX_NUMNODES, the min and max PFN are returned.\n * @start_pfn: Passed by reference. On return, it will have the node start_pfn.\n * @end_pfn: Passed by reference. On return, it will have the node end_pfn.\n *\n * It returns the start and end page frame of a node based on information\n * provided by memblock_set_node(). If called for a node\n * with no available memory, a warning is printed and the start and end\n * PFNs will be 0.\n */\nvoid __meminit get_pfn_range_for_nid(unsigned int nid,\n\t\t\tunsigned long *start_pfn, unsigned long *end_pfn)\n{\n\tunsigned long this_start_pfn, this_end_pfn;\n\tint i;\n\n\t*start_pfn = -1UL;\n\t*end_pfn = 0;\n\n\tfor_each_mem_pfn_range(i, nid, &this_start_pfn, &this_end_pfn, NULL) {\n\t\t*start_pfn = min(*start_pfn, this_start_pfn);\n\t\t*end_pfn = max(*end_pfn, this_end_pfn);\n\t}\n\n\tif (*start_pfn == -1UL)\n\t\t*start_pfn = 0;\n}\n\n/*\n * This finds a zone that can be used for ZONE_MOVABLE pages. The\n * assumption is made that zones within a node are ordered in monotonic\n * increasing memory addresses so that the \"highest\" populated zone is used\n */\nstatic void __init find_usable_zone_for_movable(void)\n{\n\tint zone_index;\n\tfor (zone_index = MAX_NR_ZONES - 1; zone_index >= 0; zone_index--) {\n\t\tif (zone_index == ZONE_MOVABLE)\n\t\t\tcontinue;\n\n\t\tif (arch_zone_highest_possible_pfn[zone_index] >\n\t\t\t\tarch_zone_lowest_possible_pfn[zone_index])\n\t\t\tbreak;\n\t}\n\n\tVM_BUG_ON(zone_index == -1);\n\tmovable_zone = zone_index;\n}\n\n/*\n * The zone ranges provided by the architecture do not include ZONE_MOVABLE\n * because it is sized independent of architecture. Unlike the other zones,\n * the starting point for ZONE_MOVABLE is not fixed. It may be different\n * in each node depending on the size of each node and how evenly kernelcore\n * is distributed. This helper function adjusts the zone ranges\n * provided by the architecture for a given node by using the end of the\n * highest usable zone for ZONE_MOVABLE. This preserves the assumption that\n * zones within a node are in order of monotonic increases memory addresses\n */\nstatic void __meminit adjust_zone_range_for_zone_movable(int nid,\n\t\t\t\t\tunsigned long zone_type,\n\t\t\t\t\tunsigned long node_start_pfn,\n\t\t\t\t\tunsigned long node_end_pfn,\n\t\t\t\t\tunsigned long *zone_start_pfn,\n\t\t\t\t\tunsigned long *zone_end_pfn)\n{\n\t/* Only adjust if ZONE_MOVABLE is on this node */\n\tif (zone_movable_pfn[nid]) {\n\t\t/* Size ZONE_MOVABLE */\n\t\tif (zone_type == ZONE_MOVABLE) {\n\t\t\t*zone_start_pfn = zone_movable_pfn[nid];\n\t\t\t*zone_end_pfn = min(node_end_pfn,\n\t\t\t\tarch_zone_highest_possible_pfn[movable_zone]);\n\n\t\t/* Adjust for ZONE_MOVABLE starting within this range */\n\t\t} else if (!mirrored_kernelcore &&\n\t\t\t*zone_start_pfn < zone_movable_pfn[nid] &&\n\t\t\t*zone_end_pfn > zone_movable_pfn[nid]) {\n\t\t\t*zone_end_pfn = zone_movable_pfn[nid];\n\n\t\t/* Check if this whole range is within ZONE_MOVABLE */\n\t\t} else if (*zone_start_pfn >= zone_movable_pfn[nid])\n\t\t\t*zone_start_pfn = *zone_end_pfn;\n\t}\n}\n\n/*\n * Return the number of pages a zone spans in a node, including holes\n * present_pages = zone_spanned_pages_in_node() - zone_absent_pages_in_node()\n */\nstatic unsigned long __meminit zone_spanned_pages_in_node(int nid,\n\t\t\t\t\tunsigned long zone_type,\n\t\t\t\t\tunsigned long node_start_pfn,\n\t\t\t\t\tunsigned long node_end_pfn,\n\t\t\t\t\tunsigned long *zone_start_pfn,\n\t\t\t\t\tunsigned long *zone_end_pfn,\n\t\t\t\t\tunsigned long *ignored)\n{\n\t/* When hotadd a new node from cpu_up(), the node should be empty */\n\tif (!node_start_pfn && !node_end_pfn)\n\t\treturn 0;\n\n\t/* Get the start and end of the zone */\n\t*zone_start_pfn = arch_zone_lowest_possible_pfn[zone_type];\n\t*zone_end_pfn = arch_zone_highest_possible_pfn[zone_type];\n\tadjust_zone_range_for_zone_movable(nid, zone_type,\n\t\t\t\tnode_start_pfn, node_end_pfn,\n\t\t\t\tzone_start_pfn, zone_end_pfn);\n\n\t/* Check that this node has pages within the zone's required range */\n\tif (*zone_end_pfn < node_start_pfn || *zone_start_pfn > node_end_pfn)\n\t\treturn 0;\n\n\t/* Move the zone boundaries inside the node if necessary */\n\t*zone_end_pfn = min(*zone_end_pfn, node_end_pfn);\n\t*zone_start_pfn = max(*zone_start_pfn, node_start_pfn);\n\n\t/* Return the spanned pages */\n\treturn *zone_end_pfn - *zone_start_pfn;\n}\n\n/*\n * Return the number of holes in a range on a node. If nid is MAX_NUMNODES,\n * then all holes in the requested range will be accounted for.\n */\nunsigned long __meminit __absent_pages_in_range(int nid,\n\t\t\t\tunsigned long range_start_pfn,\n\t\t\t\tunsigned long range_end_pfn)\n{\n\tunsigned long nr_absent = range_end_pfn - range_start_pfn;\n\tunsigned long start_pfn, end_pfn;\n\tint i;\n\n\tfor_each_mem_pfn_range(i, nid, &start_pfn, &end_pfn, NULL) {\n\t\tstart_pfn = clamp(start_pfn, range_start_pfn, range_end_pfn);\n\t\tend_pfn = clamp(end_pfn, range_start_pfn, range_end_pfn);\n\t\tnr_absent -= end_pfn - start_pfn;\n\t}\n\treturn nr_absent;\n}\n\n/**\n * absent_pages_in_range - Return number of page frames in holes within a range\n * @start_pfn: The start PFN to start searching for holes\n * @end_pfn: The end PFN to stop searching for holes\n *\n * It returns the number of pages frames in memory holes within a range.\n */\nunsigned long __init absent_pages_in_range(unsigned long start_pfn,\n\t\t\t\t\t\t\tunsigned long end_pfn)\n{\n\treturn __absent_pages_in_range(MAX_NUMNODES, start_pfn, end_pfn);\n}\n\n/* Return the number of page frames in holes in a zone on a node */\nstatic unsigned long __meminit zone_absent_pages_in_node(int nid,\n\t\t\t\t\tunsigned long zone_type,\n\t\t\t\t\tunsigned long node_start_pfn,\n\t\t\t\t\tunsigned long node_end_pfn,\n\t\t\t\t\tunsigned long *ignored)\n{\n\tunsigned long zone_low = arch_zone_lowest_possible_pfn[zone_type];\n\tunsigned long zone_high = arch_zone_highest_possible_pfn[zone_type];\n\tunsigned long zone_start_pfn, zone_end_pfn;\n\tunsigned long nr_absent;\n\n\t/* When hotadd a new node from cpu_up(), the node should be empty */\n\tif (!node_start_pfn && !node_end_pfn)\n\t\treturn 0;\n\n\tzone_start_pfn = clamp(node_start_pfn, zone_low, zone_high);\n\tzone_end_pfn = clamp(node_end_pfn, zone_low, zone_high);\n\n\tadjust_zone_range_for_zone_movable(nid, zone_type,\n\t\t\tnode_start_pfn, node_end_pfn,\n\t\t\t&zone_start_pfn, &zone_end_pfn);\n\tnr_absent = __absent_pages_in_range(nid, zone_start_pfn, zone_end_pfn);\n\n\t/*\n\t * ZONE_MOVABLE handling.\n\t * Treat pages to be ZONE_MOVABLE in ZONE_NORMAL as absent pages\n\t * and vice versa.\n\t */\n\tif (mirrored_kernelcore && zone_movable_pfn[nid]) {\n\t\tunsigned long start_pfn, end_pfn;\n\t\tstruct memblock_region *r;\n\n\t\tfor_each_memblock(memory, r) {\n\t\t\tstart_pfn = clamp(memblock_region_memory_base_pfn(r),\n\t\t\t\t\t  zone_start_pfn, zone_end_pfn);\n\t\t\tend_pfn = clamp(memblock_region_memory_end_pfn(r),\n\t\t\t\t\tzone_start_pfn, zone_end_pfn);\n\n\t\t\tif (zone_type == ZONE_MOVABLE &&\n\t\t\t    memblock_is_mirror(r))\n\t\t\t\tnr_absent += end_pfn - start_pfn;\n\n\t\t\tif (zone_type == ZONE_NORMAL &&\n\t\t\t    !memblock_is_mirror(r))\n\t\t\t\tnr_absent += end_pfn - start_pfn;\n\t\t}\n\t}\n\n\treturn nr_absent;\n}\n\n#else /* CONFIG_HAVE_MEMBLOCK_NODE_MAP */\nstatic inline unsigned long __meminit zone_spanned_pages_in_node(int nid,\n\t\t\t\t\tunsigned long zone_type,\n\t\t\t\t\tunsigned long node_start_pfn,\n\t\t\t\t\tunsigned long node_end_pfn,\n\t\t\t\t\tunsigned long *zone_start_pfn,\n\t\t\t\t\tunsigned long *zone_end_pfn,\n\t\t\t\t\tunsigned long *zones_size)\n{\n\tunsigned int zone;\n\n\t*zone_start_pfn = node_start_pfn;\n\tfor (zone = 0; zone < zone_type; zone++)\n\t\t*zone_start_pfn += zones_size[zone];\n\n\t*zone_end_pfn = *zone_start_pfn + zones_size[zone_type];\n\n\treturn zones_size[zone_type];\n}\n\nstatic inline unsigned long __meminit zone_absent_pages_in_node(int nid,\n\t\t\t\t\t\tunsigned long zone_type,\n\t\t\t\t\t\tunsigned long node_start_pfn,\n\t\t\t\t\t\tunsigned long node_end_pfn,\n\t\t\t\t\t\tunsigned long *zholes_size)\n{\n\tif (!zholes_size)\n\t\treturn 0;\n\n\treturn zholes_size[zone_type];\n}\n\n#endif /* CONFIG_HAVE_MEMBLOCK_NODE_MAP */\n\nstatic void __meminit calculate_node_totalpages(struct pglist_data *pgdat,\n\t\t\t\t\t\tunsigned long node_start_pfn,\n\t\t\t\t\t\tunsigned long node_end_pfn,\n\t\t\t\t\t\tunsigned long *zones_size,\n\t\t\t\t\t\tunsigned long *zholes_size)\n{\n\tunsigned long realtotalpages = 0, totalpages = 0;\n\tenum zone_type i;\n\n\tfor (i = 0; i < MAX_NR_ZONES; i++) {\n\t\tstruct zone *zone = pgdat->node_zones + i;\n\t\tunsigned long zone_start_pfn, zone_end_pfn;\n\t\tunsigned long size, real_size;\n\n\t\tsize = zone_spanned_pages_in_node(pgdat->node_id, i,\n\t\t\t\t\t\t  node_start_pfn,\n\t\t\t\t\t\t  node_end_pfn,\n\t\t\t\t\t\t  &zone_start_pfn,\n\t\t\t\t\t\t  &zone_end_pfn,\n\t\t\t\t\t\t  zones_size);\n\t\treal_size = size - zone_absent_pages_in_node(pgdat->node_id, i,\n\t\t\t\t\t\t  node_start_pfn, node_end_pfn,\n\t\t\t\t\t\t  zholes_size);\n\t\tif (size)\n\t\t\tzone->zone_start_pfn = zone_start_pfn;\n\t\telse\n\t\t\tzone->zone_start_pfn = 0;\n\t\tzone->spanned_pages = size;\n\t\tzone->present_pages = real_size;\n\n\t\ttotalpages += size;\n\t\trealtotalpages += real_size;\n\t}\n\n\tpgdat->node_spanned_pages = totalpages;\n\tpgdat->node_present_pages = realtotalpages;\n\tprintk(KERN_DEBUG \"On node %d totalpages: %lu\\n\", pgdat->node_id,\n\t\t\t\t\t\t\trealtotalpages);\n}\n\n#ifndef CONFIG_SPARSEMEM\n/*\n * Calculate the size of the zone->blockflags rounded to an unsigned long\n * Start by making sure zonesize is a multiple of pageblock_order by rounding\n * up. Then use 1 NR_PAGEBLOCK_BITS worth of bits per pageblock, finally\n * round what is now in bits to nearest long in bits, then return it in\n * bytes.\n */\nstatic unsigned long __init usemap_size(unsigned long zone_start_pfn, unsigned long zonesize)\n{\n\tunsigned long usemapsize;\n\n\tzonesize += zone_start_pfn & (pageblock_nr_pages-1);\n\tusemapsize = roundup(zonesize, pageblock_nr_pages);\n\tusemapsize = usemapsize >> pageblock_order;\n\tusemapsize *= NR_PAGEBLOCK_BITS;\n\tusemapsize = roundup(usemapsize, 8 * sizeof(unsigned long));\n\n\treturn usemapsize / 8;\n}\n\nstatic void __ref setup_usemap(struct pglist_data *pgdat,\n\t\t\t\tstruct zone *zone,\n\t\t\t\tunsigned long zone_start_pfn,\n\t\t\t\tunsigned long zonesize)\n{\n\tunsigned long usemapsize = usemap_size(zone_start_pfn, zonesize);\n\tzone->pageblock_flags = NULL;\n\tif (usemapsize)\n\t\tzone->pageblock_flags =\n\t\t\tmemblock_alloc_node_nopanic(usemapsize,\n\t\t\t\t\t\t\t pgdat->node_id);\n}\n#else\nstatic inline void setup_usemap(struct pglist_data *pgdat, struct zone *zone,\n\t\t\t\tunsigned long zone_start_pfn, unsigned long zonesize) {}\n#endif /* CONFIG_SPARSEMEM */\n\n#ifdef CONFIG_HUGETLB_PAGE_SIZE_VARIABLE\n\n/* Initialise the number of pages represented by NR_PAGEBLOCK_BITS */\nvoid __init set_pageblock_order(void)\n{\n\tunsigned int order;\n\n\t/* Check that pageblock_nr_pages has not already been setup */\n\tif (pageblock_order)\n\t\treturn;\n\n\tif (HPAGE_SHIFT > PAGE_SHIFT)\n\t\torder = HUGETLB_PAGE_ORDER;\n\telse\n\t\torder = MAX_ORDER - 1;\n\n\t/*\n\t * Assume the largest contiguous order of interest is a huge page.\n\t * This value may be variable depending on boot parameters on IA64 and\n\t * powerpc.\n\t */\n\tpageblock_order = order;\n}\n#else /* CONFIG_HUGETLB_PAGE_SIZE_VARIABLE */\n\n/*\n * When CONFIG_HUGETLB_PAGE_SIZE_VARIABLE is not set, set_pageblock_order()\n * is unused as pageblock_order is set at compile-time. See\n * include/linux/pageblock-flags.h for the values of pageblock_order based on\n * the kernel config\n */\nvoid __init set_pageblock_order(void)\n{\n}\n\n#endif /* CONFIG_HUGETLB_PAGE_SIZE_VARIABLE */\n\nstatic unsigned long __init calc_memmap_size(unsigned long spanned_pages,\n\t\t\t\t\t\tunsigned long present_pages)\n{\n\tunsigned long pages = spanned_pages;\n\n\t/*\n\t * Provide a more accurate estimation if there are holes within\n\t * the zone and SPARSEMEM is in use. If there are holes within the\n\t * zone, each populated memory region may cost us one or two extra\n\t * memmap pages due to alignment because memmap pages for each\n\t * populated regions may not be naturally aligned on page boundary.\n\t * So the (present_pages >> 4) heuristic is a tradeoff for that.\n\t */\n\tif (spanned_pages > present_pages + (present_pages >> 4) &&\n\t    IS_ENABLED(CONFIG_SPARSEMEM))\n\t\tpages = present_pages;\n\n\treturn PAGE_ALIGN(pages * sizeof(struct page)) >> PAGE_SHIFT;\n}\n\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\nstatic void pgdat_init_split_queue(struct pglist_data *pgdat)\n{\n\tspin_lock_init(&pgdat->split_queue_lock);\n\tINIT_LIST_HEAD(&pgdat->split_queue);\n\tpgdat->split_queue_len = 0;\n}\n#else\nstatic void pgdat_init_split_queue(struct pglist_data *pgdat) {}\n#endif\n\n#ifdef CONFIG_COMPACTION\nstatic void pgdat_init_kcompactd(struct pglist_data *pgdat)\n{\n\tinit_waitqueue_head(&pgdat->kcompactd_wait);\n}\n#else\nstatic void pgdat_init_kcompactd(struct pglist_data *pgdat) {}\n#endif\n\nstatic void __meminit pgdat_init_internals(struct pglist_data *pgdat)\n{\n\tpgdat_resize_init(pgdat);\n\n\tpgdat_init_split_queue(pgdat);\n\tpgdat_init_kcompactd(pgdat);\n\n\tinit_waitqueue_head(&pgdat->kswapd_wait);\n\tinit_waitqueue_head(&pgdat->pfmemalloc_wait);\n\n\tpgdat_page_ext_init(pgdat);\n\tspin_lock_init(&pgdat->lru_lock);\n\tlruvec_init(node_lruvec(pgdat));\n}\n\nstatic void __meminit zone_init_internals(struct zone *zone, enum zone_type idx, int nid,\n\t\t\t\t\t\t\tunsigned long remaining_pages)\n{\n\tzone->managed_pages = remaining_pages;\n\tzone_set_nid(zone, nid);\n\tzone->name = zone_names[idx];\n\tzone->zone_pgdat = NODE_DATA(nid);\n\tspin_lock_init(&zone->lock);\n\tzone_seqlock_init(zone);\n\tzone_pcp_init(zone);\n}\n\n/*\n * Set up the zone data structures\n * - init pgdat internals\n * - init all zones belonging to this node\n *\n * NOTE: this function is only called during memory hotplug\n */\n#ifdef CONFIG_MEMORY_HOTPLUG\nvoid __ref free_area_init_core_hotplug(int nid)\n{\n\tenum zone_type z;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tpgdat_init_internals(pgdat);\n\tfor (z = 0; z < MAX_NR_ZONES; z++)\n\t\tzone_init_internals(&pgdat->node_zones[z], z, nid, 0);\n}\n#endif\n\n/*\n * Set up the zone data structures:\n *   - mark all pages reserved\n *   - mark all memory queues empty\n *   - clear the memory bitmaps\n *\n * NOTE: pgdat should get zeroed by caller.\n * NOTE: this function is only called during early init.\n */\nstatic void __init free_area_init_core(struct pglist_data *pgdat)\n{\n\tenum zone_type j;\n\tint nid = pgdat->node_id;\n\n\tpgdat_init_internals(pgdat);\n\tpgdat->per_cpu_nodestats = &boot_nodestats;\n\n\tfor (j = 0; j < MAX_NR_ZONES; j++) {\n\t\tstruct zone *zone = pgdat->node_zones + j;\n\t\tunsigned long size, freesize, memmap_pages;\n\t\tunsigned long zone_start_pfn = zone->zone_start_pfn;\n\n\t\tsize = zone->spanned_pages;\n\t\tfreesize = zone->present_pages;\n\n\t\t/*\n\t\t * Adjust freesize so that it accounts for how much memory\n\t\t * is used by this zone for memmap. This affects the watermark\n\t\t * and per-cpu initialisations\n\t\t */\n\t\tmemmap_pages = calc_memmap_size(size, freesize);\n\t\tif (!is_highmem_idx(j)) {\n\t\t\tif (freesize >= memmap_pages) {\n\t\t\t\tfreesize -= memmap_pages;\n\t\t\t\tif (memmap_pages)\n\t\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\t       \"  %s zone: %lu pages used for memmap\\n\",\n\t\t\t\t\t       zone_names[j], memmap_pages);\n\t\t\t} else\n\t\t\t\tpr_warn(\"  %s zone: %lu pages exceeds freesize %lu\\n\",\n\t\t\t\t\tzone_names[j], memmap_pages, freesize);\n\t\t}\n\n\t\t/* Account for reserved pages */\n\t\tif (j == 0 && freesize > dma_reserve) {\n\t\t\tfreesize -= dma_reserve;\n\t\t\tprintk(KERN_DEBUG \"  %s zone: %lu pages reserved\\n\",\n\t\t\t\t\tzone_names[0], dma_reserve);\n\t\t}\n\n\t\tif (!is_highmem_idx(j))\n\t\t\tnr_kernel_pages += freesize;\n\t\t/* Charge for highmem memmap if there are enough kernel pages */\n\t\telse if (nr_kernel_pages > memmap_pages * 2)\n\t\t\tnr_kernel_pages -= memmap_pages;\n\t\tnr_all_pages += freesize;\n\n\t\t/*\n\t\t * Set an approximate value for lowmem here, it will be adjusted\n\t\t * when the bootmem allocator frees pages into the buddy system.\n\t\t * And all highmem pages will be managed by the buddy system.\n\t\t */\n\t\tzone_init_internals(zone, j, nid, freesize);\n\n\t\tif (!size)\n\t\t\tcontinue;\n\n\t\tset_pageblock_order();\n\t\tsetup_usemap(pgdat, zone, zone_start_pfn, size);\n\t\tinit_currently_empty_zone(zone, zone_start_pfn, size);\n\t\tmemmap_init(size, nid, j, zone_start_pfn);\n\t}\n}\n\n#ifdef CONFIG_FLAT_NODE_MEM_MAP\nstatic void __ref alloc_node_mem_map(struct pglist_data *pgdat)\n{\n\tunsigned long __maybe_unused start = 0;\n\tunsigned long __maybe_unused offset = 0;\n\n\t/* Skip empty nodes */\n\tif (!pgdat->node_spanned_pages)\n\t\treturn;\n\n\tstart = pgdat->node_start_pfn & ~(MAX_ORDER_NR_PAGES - 1);\n\toffset = pgdat->node_start_pfn - start;\n\t/* ia64 gets its own node_mem_map, before this, without bootmem */\n\tif (!pgdat->node_mem_map) {\n\t\tunsigned long size, end;\n\t\tstruct page *map;\n\n\t\t/*\n\t\t * The zone's endpoints aren't required to be MAX_ORDER\n\t\t * aligned but the node_mem_map endpoints must be in order\n\t\t * for the buddy allocator to function correctly.\n\t\t */\n\t\tend = pgdat_end_pfn(pgdat);\n\t\tend = ALIGN(end, MAX_ORDER_NR_PAGES);\n\t\tsize =  (end - start) * sizeof(struct page);\n\t\tmap = memblock_alloc_node_nopanic(size, pgdat->node_id);\n\t\tpgdat->node_mem_map = map + offset;\n\t}\n\tpr_debug(\"%s: node %d, pgdat %08lx, node_mem_map %08lx\\n\",\n\t\t\t\t__func__, pgdat->node_id, (unsigned long)pgdat,\n\t\t\t\t(unsigned long)pgdat->node_mem_map);\n#ifndef CONFIG_NEED_MULTIPLE_NODES\n\t/*\n\t * With no DISCONTIG, the global mem_map is just set as node 0's\n\t */\n\tif (pgdat == NODE_DATA(0)) {\n\t\tmem_map = NODE_DATA(0)->node_mem_map;\n#if defined(CONFIG_HAVE_MEMBLOCK_NODE_MAP) || defined(CONFIG_FLATMEM)\n\t\tif (page_to_pfn(mem_map) != pgdat->node_start_pfn)\n\t\t\tmem_map -= offset;\n#endif /* CONFIG_HAVE_MEMBLOCK_NODE_MAP */\n\t}\n#endif\n}\n#else\nstatic void __ref alloc_node_mem_map(struct pglist_data *pgdat) { }\n#endif /* CONFIG_FLAT_NODE_MEM_MAP */\n\n#ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT\nstatic inline void pgdat_set_deferred_range(pg_data_t *pgdat)\n{\n\t/*\n\t * We start only with one section of pages, more pages are added as\n\t * needed until the rest of deferred pages are initialized.\n\t */\n\tpgdat->static_init_pgcnt = min_t(unsigned long, PAGES_PER_SECTION,\n\t\t\t\t\t\tpgdat->node_spanned_pages);\n\tpgdat->first_deferred_pfn = ULONG_MAX;\n}\n#else\nstatic inline void pgdat_set_deferred_range(pg_data_t *pgdat) {}\n#endif\n\nvoid __init free_area_init_node(int nid, unsigned long *zones_size,\n\t\t\t\t   unsigned long node_start_pfn,\n\t\t\t\t   unsigned long *zholes_size)\n{\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\tunsigned long start_pfn = 0;\n\tunsigned long end_pfn = 0;\n\n\t/* pg_data_t should be reset to zero when it's allocated */\n\tWARN_ON(pgdat->nr_zones || pgdat->kswapd_classzone_idx);\n\n\tpgdat->node_id = nid;\n\tpgdat->node_start_pfn = node_start_pfn;\n\tpgdat->per_cpu_nodestats = NULL;\n#ifdef CONFIG_HAVE_MEMBLOCK_NODE_MAP\n\tget_pfn_range_for_nid(nid, &start_pfn, &end_pfn);\n\tpr_info(\"Initmem setup node %d [mem %#018Lx-%#018Lx]\\n\", nid,\n\t\t(u64)start_pfn << PAGE_SHIFT,\n\t\tend_pfn ? ((u64)end_pfn << PAGE_SHIFT) - 1 : 0);\n#else\n\tstart_pfn = node_start_pfn;\n#endif\n\tcalculate_node_totalpages(pgdat, start_pfn, end_pfn,\n\t\t\t\t  zones_size, zholes_size);\n\n\talloc_node_mem_map(pgdat);\n\tpgdat_set_deferred_range(pgdat);\n\n\tfree_area_init_core(pgdat);\n}\n\n#if !defined(CONFIG_FLAT_NODE_MEM_MAP)\n/*\n * Zero all valid struct pages in range [spfn, epfn), return number of struct\n * pages zeroed\n */\nstatic u64 zero_pfn_range(unsigned long spfn, unsigned long epfn)\n{\n\tunsigned long pfn;\n\tu64 pgcnt = 0;\n\n\tfor (pfn = spfn; pfn < epfn; pfn++) {\n\t\tif (!pfn_valid(ALIGN_DOWN(pfn, pageblock_nr_pages))) {\n\t\t\tpfn = ALIGN_DOWN(pfn, pageblock_nr_pages)\n\t\t\t\t+ pageblock_nr_pages - 1;\n\t\t\tcontinue;\n\t\t}\n\t\tmm_zero_struct_page(pfn_to_page(pfn));\n\t\tpgcnt++;\n\t}\n\n\treturn pgcnt;\n}\n\n/*\n * Only struct pages that are backed by physical memory are zeroed and\n * initialized by going through __init_single_page(). But, there are some\n * struct pages which are reserved in memblock allocator and their fields\n * may be accessed (for example page_to_pfn() on some configuration accesses\n * flags). We must explicitly zero those struct pages.\n *\n * This function also addresses a similar issue where struct pages are left\n * uninitialized because the physical address range is not covered by\n * memblock.memory or memblock.reserved. That could happen when memblock\n * layout is manually configured via memmap=.\n */\nvoid __init zero_resv_unavail(void)\n{\n\tphys_addr_t start, end;\n\tu64 i, pgcnt;\n\tphys_addr_t next = 0;\n\n\t/*\n\t * Loop through unavailable ranges not covered by memblock.memory.\n\t */\n\tpgcnt = 0;\n\tfor_each_mem_range(i, &memblock.memory, NULL,\n\t\t\tNUMA_NO_NODE, MEMBLOCK_NONE, &start, &end, NULL) {\n\t\tif (next < start)\n\t\t\tpgcnt += zero_pfn_range(PFN_DOWN(next), PFN_UP(start));\n\t\tnext = end;\n\t}\n\tpgcnt += zero_pfn_range(PFN_DOWN(next), max_pfn);\n\n\t/*\n\t * Struct pages that do not have backing memory. This could be because\n\t * firmware is using some of this memory, or for some other reasons.\n\t */\n\tif (pgcnt)\n\t\tpr_info(\"Zeroed struct page in unavailable ranges: %lld pages\", pgcnt);\n}\n#endif /* !CONFIG_FLAT_NODE_MEM_MAP */\n\n#ifdef CONFIG_HAVE_MEMBLOCK_NODE_MAP\n\n#if MAX_NUMNODES > 1\n/*\n * Figure out the number of possible node ids.\n */\nvoid __init setup_nr_node_ids(void)\n{\n\tunsigned int highest;\n\n\thighest = find_last_bit(node_possible_map.bits, MAX_NUMNODES);\n\tnr_node_ids = highest + 1;\n}\n#endif\n\n/**\n * node_map_pfn_alignment - determine the maximum internode alignment\n *\n * This function should be called after node map is populated and sorted.\n * It calculates the maximum power of two alignment which can distinguish\n * all the nodes.\n *\n * For example, if all nodes are 1GiB and aligned to 1GiB, the return value\n * would indicate 1GiB alignment with (1 << (30 - PAGE_SHIFT)).  If the\n * nodes are shifted by 256MiB, 256MiB.  Note that if only the last node is\n * shifted, 1GiB is enough and this function will indicate so.\n *\n * This is used to test whether pfn -> nid mapping of the chosen memory\n * model has fine enough granularity to avoid incorrect mapping for the\n * populated node map.\n *\n * Returns the determined alignment in pfn's.  0 if there is no alignment\n * requirement (single node).\n */\nunsigned long __init node_map_pfn_alignment(void)\n{\n\tunsigned long accl_mask = 0, last_end = 0;\n\tunsigned long start, end, mask;\n\tint last_nid = -1;\n\tint i, nid;\n\n\tfor_each_mem_pfn_range(i, MAX_NUMNODES, &start, &end, &nid) {\n\t\tif (!start || last_nid < 0 || last_nid == nid) {\n\t\t\tlast_nid = nid;\n\t\t\tlast_end = end;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Start with a mask granular enough to pin-point to the\n\t\t * start pfn and tick off bits one-by-one until it becomes\n\t\t * too coarse to separate the current node from the last.\n\t\t */\n\t\tmask = ~((1 << __ffs(start)) - 1);\n\t\twhile (mask && last_end <= (start & (mask << 1)))\n\t\t\tmask <<= 1;\n\n\t\t/* accumulate all internode masks */\n\t\taccl_mask |= mask;\n\t}\n\n\t/* convert mask to number of pages */\n\treturn ~accl_mask + 1;\n}\n\n/* Find the lowest pfn for a node */\nstatic unsigned long __init find_min_pfn_for_node(int nid)\n{\n\tunsigned long min_pfn = ULONG_MAX;\n\tunsigned long start_pfn;\n\tint i;\n\n\tfor_each_mem_pfn_range(i, nid, &start_pfn, NULL, NULL)\n\t\tmin_pfn = min(min_pfn, start_pfn);\n\n\tif (min_pfn == ULONG_MAX) {\n\t\tpr_warn(\"Could not find start_pfn for node %d\\n\", nid);\n\t\treturn 0;\n\t}\n\n\treturn min_pfn;\n}\n\n/**\n * find_min_pfn_with_active_regions - Find the minimum PFN registered\n *\n * It returns the minimum PFN based on information provided via\n * memblock_set_node().\n */\nunsigned long __init find_min_pfn_with_active_regions(void)\n{\n\treturn find_min_pfn_for_node(MAX_NUMNODES);\n}\n\n/*\n * early_calculate_totalpages()\n * Sum pages in active regions for movable zone.\n * Populate N_MEMORY for calculating usable_nodes.\n */\nstatic unsigned long __init early_calculate_totalpages(void)\n{\n\tunsigned long totalpages = 0;\n\tunsigned long start_pfn, end_pfn;\n\tint i, nid;\n\n\tfor_each_mem_pfn_range(i, MAX_NUMNODES, &start_pfn, &end_pfn, &nid) {\n\t\tunsigned long pages = end_pfn - start_pfn;\n\n\t\ttotalpages += pages;\n\t\tif (pages)\n\t\t\tnode_set_state(nid, N_MEMORY);\n\t}\n\treturn totalpages;\n}\n\n/*\n * Find the PFN the Movable zone begins in each node. Kernel memory\n * is spread evenly between nodes as long as the nodes have enough\n * memory. When they don't, some nodes will have more kernelcore than\n * others\n */\nstatic void __init find_zone_movable_pfns_for_nodes(void)\n{\n\tint i, nid;\n\tunsigned long usable_startpfn;\n\tunsigned long kernelcore_node, kernelcore_remaining;\n\t/* save the state before borrow the nodemask */\n\tnodemask_t saved_node_state = node_states[N_MEMORY];\n\tunsigned long totalpages = early_calculate_totalpages();\n\tint usable_nodes = nodes_weight(node_states[N_MEMORY]);\n\tstruct memblock_region *r;\n\n\t/* Need to find movable_zone earlier when movable_node is specified. */\n\tfind_usable_zone_for_movable();\n\n\t/*\n\t * If movable_node is specified, ignore kernelcore and movablecore\n\t * options.\n\t */\n\tif (movable_node_is_enabled()) {\n\t\tfor_each_memblock(memory, r) {\n\t\t\tif (!memblock_is_hotpluggable(r))\n\t\t\t\tcontinue;\n\n\t\t\tnid = r->nid;\n\n\t\t\tusable_startpfn = PFN_DOWN(r->base);\n\t\t\tzone_movable_pfn[nid] = zone_movable_pfn[nid] ?\n\t\t\t\tmin(usable_startpfn, zone_movable_pfn[nid]) :\n\t\t\t\tusable_startpfn;\n\t\t}\n\n\t\tgoto out2;\n\t}\n\n\t/*\n\t * If kernelcore=mirror is specified, ignore movablecore option\n\t */\n\tif (mirrored_kernelcore) {\n\t\tbool mem_below_4gb_not_mirrored = false;\n\n\t\tfor_each_memblock(memory, r) {\n\t\t\tif (memblock_is_mirror(r))\n\t\t\t\tcontinue;\n\n\t\t\tnid = r->nid;\n\n\t\t\tusable_startpfn = memblock_region_memory_base_pfn(r);\n\n\t\t\tif (usable_startpfn < 0x100000) {\n\t\t\t\tmem_below_4gb_not_mirrored = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tzone_movable_pfn[nid] = zone_movable_pfn[nid] ?\n\t\t\t\tmin(usable_startpfn, zone_movable_pfn[nid]) :\n\t\t\t\tusable_startpfn;\n\t\t}\n\n\t\tif (mem_below_4gb_not_mirrored)\n\t\t\tpr_warn(\"This configuration results in unmirrored kernel memory.\");\n\n\t\tgoto out2;\n\t}\n\n\t/*\n\t * If kernelcore=nn% or movablecore=nn% was specified, calculate the\n\t * amount of necessary memory.\n\t */\n\tif (required_kernelcore_percent)\n\t\trequired_kernelcore = (totalpages * 100 * required_kernelcore_percent) /\n\t\t\t\t       10000UL;\n\tif (required_movablecore_percent)\n\t\trequired_movablecore = (totalpages * 100 * required_movablecore_percent) /\n\t\t\t\t\t10000UL;\n\n\t/*\n\t * If movablecore= was specified, calculate what size of\n\t * kernelcore that corresponds so that memory usable for\n\t * any allocation type is evenly spread. If both kernelcore\n\t * and movablecore are specified, then the value of kernelcore\n\t * will be used for required_kernelcore if it's greater than\n\t * what movablecore would have allowed.\n\t */\n\tif (required_movablecore) {\n\t\tunsigned long corepages;\n\n\t\t/*\n\t\t * Round-up so that ZONE_MOVABLE is at least as large as what\n\t\t * was requested by the user\n\t\t */\n\t\trequired_movablecore =\n\t\t\troundup(required_movablecore, MAX_ORDER_NR_PAGES);\n\t\trequired_movablecore = min(totalpages, required_movablecore);\n\t\tcorepages = totalpages - required_movablecore;\n\n\t\trequired_kernelcore = max(required_kernelcore, corepages);\n\t}\n\n\t/*\n\t * If kernelcore was not specified or kernelcore size is larger\n\t * than totalpages, there is no ZONE_MOVABLE.\n\t */\n\tif (!required_kernelcore || required_kernelcore >= totalpages)\n\t\tgoto out;\n\n\t/* usable_startpfn is the lowest possible pfn ZONE_MOVABLE can be at */\n\tusable_startpfn = arch_zone_lowest_possible_pfn[movable_zone];\n\nrestart:\n\t/* Spread kernelcore memory as evenly as possible throughout nodes */\n\tkernelcore_node = required_kernelcore / usable_nodes;\n\tfor_each_node_state(nid, N_MEMORY) {\n\t\tunsigned long start_pfn, end_pfn;\n\n\t\t/*\n\t\t * Recalculate kernelcore_node if the division per node\n\t\t * now exceeds what is necessary to satisfy the requested\n\t\t * amount of memory for the kernel\n\t\t */\n\t\tif (required_kernelcore < kernelcore_node)\n\t\t\tkernelcore_node = required_kernelcore / usable_nodes;\n\n\t\t/*\n\t\t * As the map is walked, we track how much memory is usable\n\t\t * by the kernel using kernelcore_remaining. When it is\n\t\t * 0, the rest of the node is usable by ZONE_MOVABLE\n\t\t */\n\t\tkernelcore_remaining = kernelcore_node;\n\n\t\t/* Go through each range of PFNs within this node */\n\t\tfor_each_mem_pfn_range(i, nid, &start_pfn, &end_pfn, NULL) {\n\t\t\tunsigned long size_pages;\n\n\t\t\tstart_pfn = max(start_pfn, zone_movable_pfn[nid]);\n\t\t\tif (start_pfn >= end_pfn)\n\t\t\t\tcontinue;\n\n\t\t\t/* Account for what is only usable for kernelcore */\n\t\t\tif (start_pfn < usable_startpfn) {\n\t\t\t\tunsigned long kernel_pages;\n\t\t\t\tkernel_pages = min(end_pfn, usable_startpfn)\n\t\t\t\t\t\t\t\t- start_pfn;\n\n\t\t\t\tkernelcore_remaining -= min(kernel_pages,\n\t\t\t\t\t\t\tkernelcore_remaining);\n\t\t\t\trequired_kernelcore -= min(kernel_pages,\n\t\t\t\t\t\t\trequired_kernelcore);\n\n\t\t\t\t/* Continue if range is now fully accounted */\n\t\t\t\tif (end_pfn <= usable_startpfn) {\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Push zone_movable_pfn to the end so\n\t\t\t\t\t * that if we have to rebalance\n\t\t\t\t\t * kernelcore across nodes, we will\n\t\t\t\t\t * not double account here\n\t\t\t\t\t */\n\t\t\t\t\tzone_movable_pfn[nid] = end_pfn;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tstart_pfn = usable_startpfn;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The usable PFN range for ZONE_MOVABLE is from\n\t\t\t * start_pfn->end_pfn. Calculate size_pages as the\n\t\t\t * number of pages used as kernelcore\n\t\t\t */\n\t\t\tsize_pages = end_pfn - start_pfn;\n\t\t\tif (size_pages > kernelcore_remaining)\n\t\t\t\tsize_pages = kernelcore_remaining;\n\t\t\tzone_movable_pfn[nid] = start_pfn + size_pages;\n\n\t\t\t/*\n\t\t\t * Some kernelcore has been met, update counts and\n\t\t\t * break if the kernelcore for this node has been\n\t\t\t * satisfied\n\t\t\t */\n\t\t\trequired_kernelcore -= min(required_kernelcore,\n\t\t\t\t\t\t\t\tsize_pages);\n\t\t\tkernelcore_remaining -= size_pages;\n\t\t\tif (!kernelcore_remaining)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * If there is still required_kernelcore, we do another pass with one\n\t * less node in the count. This will push zone_movable_pfn[nid] further\n\t * along on the nodes that still have memory until kernelcore is\n\t * satisfied\n\t */\n\tusable_nodes--;\n\tif (usable_nodes && required_kernelcore > usable_nodes)\n\t\tgoto restart;\n\nout2:\n\t/* Align start of ZONE_MOVABLE on all nids to MAX_ORDER_NR_PAGES */\n\tfor (nid = 0; nid < MAX_NUMNODES; nid++)\n\t\tzone_movable_pfn[nid] =\n\t\t\troundup(zone_movable_pfn[nid], MAX_ORDER_NR_PAGES);\n\nout:\n\t/* restore the node_state */\n\tnode_states[N_MEMORY] = saved_node_state;\n}\n\n/* Any regular or high memory on that node ? */\nstatic void check_for_memory(pg_data_t *pgdat, int nid)\n{\n\tenum zone_type zone_type;\n\n\tfor (zone_type = 0; zone_type <= ZONE_MOVABLE - 1; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\t\tif (populated_zone(zone)) {\n\t\t\tif (IS_ENABLED(CONFIG_HIGHMEM))\n\t\t\t\tnode_set_state(nid, N_HIGH_MEMORY);\n\t\t\tif (zone_type <= ZONE_NORMAL)\n\t\t\t\tnode_set_state(nid, N_NORMAL_MEMORY);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/**\n * free_area_init_nodes - Initialise all pg_data_t and zone data\n * @max_zone_pfn: an array of max PFNs for each zone\n *\n * This will call free_area_init_node() for each active node in the system.\n * Using the page ranges provided by memblock_set_node(), the size of each\n * zone in each node and their holes is calculated. If the maximum PFN\n * between two adjacent zones match, it is assumed that the zone is empty.\n * For example, if arch_max_dma_pfn == arch_max_dma32_pfn, it is assumed\n * that arch_max_dma32_pfn has no pages. It is also assumed that a zone\n * starts where the previous one ended. For example, ZONE_DMA32 starts\n * at arch_max_dma_pfn.\n */\nvoid __init free_area_init_nodes(unsigned long *max_zone_pfn)\n{\n\tunsigned long start_pfn, end_pfn;\n\tint i, nid;\n\n\t/* Record where the zone boundaries are */\n\tmemset(arch_zone_lowest_possible_pfn, 0,\n\t\t\t\tsizeof(arch_zone_lowest_possible_pfn));\n\tmemset(arch_zone_highest_possible_pfn, 0,\n\t\t\t\tsizeof(arch_zone_highest_possible_pfn));\n\n\tstart_pfn = find_min_pfn_with_active_regions();\n\n\tfor (i = 0; i < MAX_NR_ZONES; i++) {\n\t\tif (i == ZONE_MOVABLE)\n\t\t\tcontinue;\n\n\t\tend_pfn = max(max_zone_pfn[i], start_pfn);\n\t\tarch_zone_lowest_possible_pfn[i] = start_pfn;\n\t\tarch_zone_highest_possible_pfn[i] = end_pfn;\n\n\t\tstart_pfn = end_pfn;\n\t}\n\n\t/* Find the PFNs that ZONE_MOVABLE begins at in each node */\n\tmemset(zone_movable_pfn, 0, sizeof(zone_movable_pfn));\n\tfind_zone_movable_pfns_for_nodes();\n\n\t/* Print out the zone ranges */\n\tpr_info(\"Zone ranges:\\n\");\n\tfor (i = 0; i < MAX_NR_ZONES; i++) {\n\t\tif (i == ZONE_MOVABLE)\n\t\t\tcontinue;\n\t\tpr_info(\"  %-8s \", zone_names[i]);\n\t\tif (arch_zone_lowest_possible_pfn[i] ==\n\t\t\t\tarch_zone_highest_possible_pfn[i])\n\t\t\tpr_cont(\"empty\\n\");\n\t\telse\n\t\t\tpr_cont(\"[mem %#018Lx-%#018Lx]\\n\",\n\t\t\t\t(u64)arch_zone_lowest_possible_pfn[i]\n\t\t\t\t\t<< PAGE_SHIFT,\n\t\t\t\t((u64)arch_zone_highest_possible_pfn[i]\n\t\t\t\t\t<< PAGE_SHIFT) - 1);\n\t}\n\n\t/* Print out the PFNs ZONE_MOVABLE begins at in each node */\n\tpr_info(\"Movable zone start for each node\\n\");\n\tfor (i = 0; i < MAX_NUMNODES; i++) {\n\t\tif (zone_movable_pfn[i])\n\t\t\tpr_info(\"  Node %d: %#018Lx\\n\", i,\n\t\t\t       (u64)zone_movable_pfn[i] << PAGE_SHIFT);\n\t}\n\n\t/* Print out the early node map */\n\tpr_info(\"Early memory node ranges\\n\");\n\tfor_each_mem_pfn_range(i, MAX_NUMNODES, &start_pfn, &end_pfn, &nid)\n\t\tpr_info(\"  node %3d: [mem %#018Lx-%#018Lx]\\n\", nid,\n\t\t\t(u64)start_pfn << PAGE_SHIFT,\n\t\t\t((u64)end_pfn << PAGE_SHIFT) - 1);\n\n\t/* Initialise every node */\n\tmminit_verify_pageflags_layout();\n\tsetup_nr_node_ids();\n\tzero_resv_unavail();\n\tfor_each_online_node(nid) {\n\t\tpg_data_t *pgdat = NODE_DATA(nid);\n\t\tfree_area_init_node(nid, NULL,\n\t\t\t\tfind_min_pfn_for_node(nid), NULL);\n\n\t\t/* Any memory on that node */\n\t\tif (pgdat->node_present_pages)\n\t\t\tnode_set_state(nid, N_MEMORY);\n\t\tcheck_for_memory(pgdat, nid);\n\t}\n}\n\nstatic int __init cmdline_parse_core(char *p, unsigned long *core,\n\t\t\t\t     unsigned long *percent)\n{\n\tunsigned long long coremem;\n\tchar *endptr;\n\n\tif (!p)\n\t\treturn -EINVAL;\n\n\t/* Value may be a percentage of total memory, otherwise bytes */\n\tcoremem = simple_strtoull(p, &endptr, 0);\n\tif (*endptr == '%') {\n\t\t/* Paranoid check for percent values greater than 100 */\n\t\tWARN_ON(coremem > 100);\n\n\t\t*percent = coremem;\n\t} else {\n\t\tcoremem = memparse(p, &p);\n\t\t/* Paranoid check that UL is enough for the coremem value */\n\t\tWARN_ON((coremem >> PAGE_SHIFT) > ULONG_MAX);\n\n\t\t*core = coremem >> PAGE_SHIFT;\n\t\t*percent = 0UL;\n\t}\n\treturn 0;\n}\n\n/*\n * kernelcore=size sets the amount of memory for use for allocations that\n * cannot be reclaimed or migrated.\n */\nstatic int __init cmdline_parse_kernelcore(char *p)\n{\n\t/* parse kernelcore=mirror */\n\tif (parse_option_str(p, \"mirror\")) {\n\t\tmirrored_kernelcore = true;\n\t\treturn 0;\n\t}\n\n\treturn cmdline_parse_core(p, &required_kernelcore,\n\t\t\t\t  &required_kernelcore_percent);\n}\n\n/*\n * movablecore=size sets the amount of memory for use for allocations that\n * can be reclaimed or migrated.\n */\nstatic int __init cmdline_parse_movablecore(char *p)\n{\n\treturn cmdline_parse_core(p, &required_movablecore,\n\t\t\t\t  &required_movablecore_percent);\n}\n\nearly_param(\"kernelcore\", cmdline_parse_kernelcore);\nearly_param(\"movablecore\", cmdline_parse_movablecore);\n\n#endif /* CONFIG_HAVE_MEMBLOCK_NODE_MAP */\n\nvoid adjust_managed_page_count(struct page *page, long count)\n{\n\tspin_lock(&managed_page_count_lock);\n\tpage_zone(page)->managed_pages += count;\n\ttotalram_pages += count;\n#ifdef CONFIG_HIGHMEM\n\tif (PageHighMem(page))\n\t\ttotalhigh_pages += count;\n#endif\n\tspin_unlock(&managed_page_count_lock);\n}\nEXPORT_SYMBOL(adjust_managed_page_count);\n\nunsigned long free_reserved_area(void *start, void *end, int poison, char *s)\n{\n\tvoid *pos;\n\tunsigned long pages = 0;\n\n\tstart = (void *)PAGE_ALIGN((unsigned long)start);\n\tend = (void *)((unsigned long)end & PAGE_MASK);\n\tfor (pos = start; pos < end; pos += PAGE_SIZE, pages++) {\n\t\tstruct page *page = virt_to_page(pos);\n\t\tvoid *direct_map_addr;\n\n\t\t/*\n\t\t * 'direct_map_addr' might be different from 'pos'\n\t\t * because some architectures' virt_to_page()\n\t\t * work with aliases.  Getting the direct map\n\t\t * address ensures that we get a _writeable_\n\t\t * alias for the memset().\n\t\t */\n\t\tdirect_map_addr = page_address(page);\n\t\tif ((unsigned int)poison <= 0xFF)\n\t\t\tmemset(direct_map_addr, poison, PAGE_SIZE);\n\n\t\tfree_reserved_page(page);\n\t}\n\n\tif (pages && s)\n\t\tpr_info(\"Freeing %s memory: %ldK\\n\",\n\t\t\ts, pages << (PAGE_SHIFT - 10));\n\n\treturn pages;\n}\nEXPORT_SYMBOL(free_reserved_area);\n\n#ifdef\tCONFIG_HIGHMEM\nvoid free_highmem_page(struct page *page)\n{\n\t__free_reserved_page(page);\n\ttotalram_pages++;\n\tpage_zone(page)->managed_pages++;\n\ttotalhigh_pages++;\n}\n#endif\n\n\nvoid __init mem_init_print_info(const char *str)\n{\n\tunsigned long physpages, codesize, datasize, rosize, bss_size;\n\tunsigned long init_code_size, init_data_size;\n\n\tphyspages = get_num_physpages();\n\tcodesize = _etext - _stext;\n\tdatasize = _edata - _sdata;\n\trosize = __end_rodata - __start_rodata;\n\tbss_size = __bss_stop - __bss_start;\n\tinit_data_size = __init_end - __init_begin;\n\tinit_code_size = _einittext - _sinittext;\n\n\t/*\n\t * Detect special cases and adjust section sizes accordingly:\n\t * 1) .init.* may be embedded into .data sections\n\t * 2) .init.text.* may be out of [__init_begin, __init_end],\n\t *    please refer to arch/tile/kernel/vmlinux.lds.S.\n\t * 3) .rodata.* may be embedded into .text or .data sections.\n\t */\n#define adj_init_size(start, end, size, pos, adj) \\\n\tdo { \\\n\t\tif (start <= pos && pos < end && size > adj) \\\n\t\t\tsize -= adj; \\\n\t} while (0)\n\n\tadj_init_size(__init_begin, __init_end, init_data_size,\n\t\t     _sinittext, init_code_size);\n\tadj_init_size(_stext, _etext, codesize, _sinittext, init_code_size);\n\tadj_init_size(_sdata, _edata, datasize, __init_begin, init_data_size);\n\tadj_init_size(_stext, _etext, codesize, __start_rodata, rosize);\n\tadj_init_size(_sdata, _edata, datasize, __start_rodata, rosize);\n\n#undef\tadj_init_size\n\n\tpr_info(\"Memory: %luK/%luK available (%luK kernel code, %luK rwdata, %luK rodata, %luK init, %luK bss, %luK reserved, %luK cma-reserved\"\n#ifdef\tCONFIG_HIGHMEM\n\t\t\", %luK highmem\"\n#endif\n\t\t\"%s%s)\\n\",\n\t\tnr_free_pages() << (PAGE_SHIFT - 10),\n\t\tphyspages << (PAGE_SHIFT - 10),\n\t\tcodesize >> 10, datasize >> 10, rosize >> 10,\n\t\t(init_data_size + init_code_size) >> 10, bss_size >> 10,\n\t\t(physpages - totalram_pages - totalcma_pages) << (PAGE_SHIFT - 10),\n\t\ttotalcma_pages << (PAGE_SHIFT - 10),\n#ifdef\tCONFIG_HIGHMEM\n\t\ttotalhigh_pages << (PAGE_SHIFT - 10),\n#endif\n\t\tstr ? \", \" : \"\", str ? str : \"\");\n}\n\n/**\n * set_dma_reserve - set the specified number of pages reserved in the first zone\n * @new_dma_reserve: The number of pages to mark reserved\n *\n * The per-cpu batchsize and zone watermarks are determined by managed_pages.\n * In the DMA zone, a significant percentage may be consumed by kernel image\n * and other unfreeable allocations which can skew the watermarks badly. This\n * function may optionally be used to account for unfreeable pages in the\n * first zone (e.g., ZONE_DMA). The effect will be lower watermarks and\n * smaller per-cpu batchsize.\n */\nvoid __init set_dma_reserve(unsigned long new_dma_reserve)\n{\n\tdma_reserve = new_dma_reserve;\n}\n\nvoid __init free_area_init(unsigned long *zones_size)\n{\n\tzero_resv_unavail();\n\tfree_area_init_node(0, zones_size,\n\t\t\t__pa(PAGE_OFFSET) >> PAGE_SHIFT, NULL);\n}\n\nstatic int page_alloc_cpu_dead(unsigned int cpu)\n{\n\n\tlru_add_drain_cpu(cpu);\n\tdrain_pages(cpu);\n\n\t/*\n\t * Spill the event counters of the dead processor\n\t * into the current processors event counters.\n\t * This artificially elevates the count of the current\n\t * processor.\n\t */\n\tvm_events_fold_cpu(cpu);\n\n\t/*\n\t * Zero the differential counters of the dead processor\n\t * so that the vm statistics are consistent.\n\t *\n\t * This is only okay since the processor is dead and cannot\n\t * race with what we are doing.\n\t */\n\tcpu_vm_stats_fold(cpu);\n\treturn 0;\n}\n\nvoid __init page_alloc_init(void)\n{\n\tint ret;\n\n\tret = cpuhp_setup_state_nocalls(CPUHP_PAGE_ALLOC_DEAD,\n\t\t\t\t\t\"mm/page_alloc:dead\", NULL,\n\t\t\t\t\tpage_alloc_cpu_dead);\n\tWARN_ON(ret < 0);\n}\n\n/*\n * calculate_totalreserve_pages - called when sysctl_lowmem_reserve_ratio\n *\tor min_free_kbytes changes.\n */\nstatic void calculate_totalreserve_pages(void)\n{\n\tstruct pglist_data *pgdat;\n\tunsigned long reserve_pages = 0;\n\tenum zone_type i, j;\n\n\tfor_each_online_pgdat(pgdat) {\n\n\t\tpgdat->totalreserve_pages = 0;\n\n\t\tfor (i = 0; i < MAX_NR_ZONES; i++) {\n\t\t\tstruct zone *zone = pgdat->node_zones + i;\n\t\t\tlong max = 0;\n\n\t\t\t/* Find valid and maximum lowmem_reserve in the zone */\n\t\t\tfor (j = i; j < MAX_NR_ZONES; j++) {\n\t\t\t\tif (zone->lowmem_reserve[j] > max)\n\t\t\t\t\tmax = zone->lowmem_reserve[j];\n\t\t\t}\n\n\t\t\t/* we treat the high watermark as reserved pages. */\n\t\t\tmax += high_wmark_pages(zone);\n\n\t\t\tif (max > zone->managed_pages)\n\t\t\t\tmax = zone->managed_pages;\n\n\t\t\tpgdat->totalreserve_pages += max;\n\n\t\t\treserve_pages += max;\n\t\t}\n\t}\n\ttotalreserve_pages = reserve_pages;\n}\n\n/*\n * setup_per_zone_lowmem_reserve - called whenever\n *\tsysctl_lowmem_reserve_ratio changes.  Ensures that each zone\n *\thas a correct pages reserved value, so an adequate number of\n *\tpages are left in the zone after a successful __alloc_pages().\n */\nstatic void setup_per_zone_lowmem_reserve(void)\n{\n\tstruct pglist_data *pgdat;\n\tenum zone_type j, idx;\n\n\tfor_each_online_pgdat(pgdat) {\n\t\tfor (j = 0; j < MAX_NR_ZONES; j++) {\n\t\t\tstruct zone *zone = pgdat->node_zones + j;\n\t\t\tunsigned long managed_pages = zone->managed_pages;\n\n\t\t\tzone->lowmem_reserve[j] = 0;\n\n\t\t\tidx = j;\n\t\t\twhile (idx) {\n\t\t\t\tstruct zone *lower_zone;\n\n\t\t\t\tidx--;\n\t\t\t\tlower_zone = pgdat->node_zones + idx;\n\n\t\t\t\tif (sysctl_lowmem_reserve_ratio[idx] < 1) {\n\t\t\t\t\tsysctl_lowmem_reserve_ratio[idx] = 0;\n\t\t\t\t\tlower_zone->lowmem_reserve[j] = 0;\n\t\t\t\t} else {\n\t\t\t\t\tlower_zone->lowmem_reserve[j] =\n\t\t\t\t\t\tmanaged_pages / sysctl_lowmem_reserve_ratio[idx];\n\t\t\t\t}\n\t\t\t\tmanaged_pages += lower_zone->managed_pages;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* update totalreserve_pages */\n\tcalculate_totalreserve_pages();\n}\n\nstatic void __setup_per_zone_wmarks(void)\n{\n\tunsigned long pages_min = min_free_kbytes >> (PAGE_SHIFT - 10);\n\tunsigned long lowmem_pages = 0;\n\tstruct zone *zone;\n\tunsigned long flags;\n\n\t/* Calculate total number of !ZONE_HIGHMEM pages */\n\tfor_each_zone(zone) {\n\t\tif (!is_highmem(zone))\n\t\t\tlowmem_pages += zone->managed_pages;\n\t}\n\n\tfor_each_zone(zone) {\n\t\tu64 tmp;\n\n\t\tspin_lock_irqsave(&zone->lock, flags);\n\t\ttmp = (u64)pages_min * zone->managed_pages;\n\t\tdo_div(tmp, lowmem_pages);\n\t\tif (is_highmem(zone)) {\n\t\t\t/*\n\t\t\t * __GFP_HIGH and PF_MEMALLOC allocations usually don't\n\t\t\t * need highmem pages, so cap pages_min to a small\n\t\t\t * value here.\n\t\t\t *\n\t\t\t * The WMARK_HIGH-WMARK_LOW and (WMARK_LOW-WMARK_MIN)\n\t\t\t * deltas control asynch page reclaim, and so should\n\t\t\t * not be capped for highmem.\n\t\t\t */\n\t\t\tunsigned long min_pages;\n\n\t\t\tmin_pages = zone->managed_pages / 1024;\n\t\t\tmin_pages = clamp(min_pages, SWAP_CLUSTER_MAX, 128UL);\n\t\t\tzone->watermark[WMARK_MIN] = min_pages;\n\t\t} else {\n\t\t\t/*\n\t\t\t * If it's a lowmem zone, reserve a number of pages\n\t\t\t * proportionate to the zone's size.\n\t\t\t */\n\t\t\tzone->watermark[WMARK_MIN] = tmp;\n\t\t}\n\n\t\t/*\n\t\t * Set the kswapd watermarks distance according to the\n\t\t * scale factor in proportion to available memory, but\n\t\t * ensure a minimum size on small systems.\n\t\t */\n\t\ttmp = max_t(u64, tmp >> 2,\n\t\t\t    mult_frac(zone->managed_pages,\n\t\t\t\t      watermark_scale_factor, 10000));\n\n\t\tzone->watermark[WMARK_LOW]  = min_wmark_pages(zone) + tmp;\n\t\tzone->watermark[WMARK_HIGH] = min_wmark_pages(zone) + tmp * 2;\n\n\t\tspin_unlock_irqrestore(&zone->lock, flags);\n\t}\n\n\t/* update totalreserve_pages */\n\tcalculate_totalreserve_pages();\n}\n\n/**\n * setup_per_zone_wmarks - called when min_free_kbytes changes\n * or when memory is hot-{added|removed}\n *\n * Ensures that the watermark[min,low,high] values for each zone are set\n * correctly with respect to min_free_kbytes.\n */\nvoid setup_per_zone_wmarks(void)\n{\n\tstatic DEFINE_SPINLOCK(lock);\n\n\tspin_lock(&lock);\n\t__setup_per_zone_wmarks();\n\tspin_unlock(&lock);\n}\n\n/*\n * Initialise min_free_kbytes.\n *\n * For small machines we want it small (128k min).  For large machines\n * we want it large (64MB max).  But it is not linear, because network\n * bandwidth does not increase linearly with machine size.  We use\n *\n *\tmin_free_kbytes = 4 * sqrt(lowmem_kbytes), for better accuracy:\n *\tmin_free_kbytes = sqrt(lowmem_kbytes * 16)\n *\n * which yields\n *\n * 16MB:\t512k\n * 32MB:\t724k\n * 64MB:\t1024k\n * 128MB:\t1448k\n * 256MB:\t2048k\n * 512MB:\t2896k\n * 1024MB:\t4096k\n * 2048MB:\t5792k\n * 4096MB:\t8192k\n * 8192MB:\t11584k\n * 16384MB:\t16384k\n */\nint __meminit init_per_zone_wmark_min(void)\n{\n\tunsigned long lowmem_kbytes;\n\tint new_min_free_kbytes;\n\n\tlowmem_kbytes = nr_free_buffer_pages() * (PAGE_SIZE >> 10);\n\tnew_min_free_kbytes = int_sqrt(lowmem_kbytes * 16);\n\n\tif (new_min_free_kbytes > user_min_free_kbytes) {\n\t\tmin_free_kbytes = new_min_free_kbytes;\n\t\tif (min_free_kbytes < 128)\n\t\t\tmin_free_kbytes = 128;\n\t\tif (min_free_kbytes > 65536)\n\t\t\tmin_free_kbytes = 65536;\n\t} else {\n\t\tpr_warn(\"min_free_kbytes is not updated to %d because user defined value %d is preferred\\n\",\n\t\t\t\tnew_min_free_kbytes, user_min_free_kbytes);\n\t}\n\tsetup_per_zone_wmarks();\n\trefresh_zone_stat_thresholds();\n\tsetup_per_zone_lowmem_reserve();\n\n#ifdef CONFIG_NUMA\n\tsetup_min_unmapped_ratio();\n\tsetup_min_slab_ratio();\n#endif\n\n\treturn 0;\n}\ncore_initcall(init_per_zone_wmark_min)\n\n/*\n * min_free_kbytes_sysctl_handler - just a wrapper around proc_dointvec() so\n *\tthat we can call two helper functions whenever min_free_kbytes\n *\tchanges.\n */\nint min_free_kbytes_sysctl_handler(struct ctl_table *table, int write,\n\tvoid __user *buffer, size_t *length, loff_t *ppos)\n{\n\tint rc;\n\n\trc = proc_dointvec_minmax(table, write, buffer, length, ppos);\n\tif (rc)\n\t\treturn rc;\n\n\tif (write) {\n\t\tuser_min_free_kbytes = min_free_kbytes;\n\t\tsetup_per_zone_wmarks();\n\t}\n\treturn 0;\n}\n\nint watermark_scale_factor_sysctl_handler(struct ctl_table *table, int write,\n\tvoid __user *buffer, size_t *length, loff_t *ppos)\n{\n\tint rc;\n\n\trc = proc_dointvec_minmax(table, write, buffer, length, ppos);\n\tif (rc)\n\t\treturn rc;\n\n\tif (write)\n\t\tsetup_per_zone_wmarks();\n\n\treturn 0;\n}\n\n#ifdef CONFIG_NUMA\nstatic void setup_min_unmapped_ratio(void)\n{\n\tpg_data_t *pgdat;\n\tstruct zone *zone;\n\n\tfor_each_online_pgdat(pgdat)\n\t\tpgdat->min_unmapped_pages = 0;\n\n\tfor_each_zone(zone)\n\t\tzone->zone_pgdat->min_unmapped_pages += (zone->managed_pages *\n\t\t\t\tsysctl_min_unmapped_ratio) / 100;\n}\n\n\nint sysctl_min_unmapped_ratio_sysctl_handler(struct ctl_table *table, int write,\n\tvoid __user *buffer, size_t *length, loff_t *ppos)\n{\n\tint rc;\n\n\trc = proc_dointvec_minmax(table, write, buffer, length, ppos);\n\tif (rc)\n\t\treturn rc;\n\n\tsetup_min_unmapped_ratio();\n\n\treturn 0;\n}\n\nstatic void setup_min_slab_ratio(void)\n{\n\tpg_data_t *pgdat;\n\tstruct zone *zone;\n\n\tfor_each_online_pgdat(pgdat)\n\t\tpgdat->min_slab_pages = 0;\n\n\tfor_each_zone(zone)\n\t\tzone->zone_pgdat->min_slab_pages += (zone->managed_pages *\n\t\t\t\tsysctl_min_slab_ratio) / 100;\n}\n\nint sysctl_min_slab_ratio_sysctl_handler(struct ctl_table *table, int write,\n\tvoid __user *buffer, size_t *length, loff_t *ppos)\n{\n\tint rc;\n\n\trc = proc_dointvec_minmax(table, write, buffer, length, ppos);\n\tif (rc)\n\t\treturn rc;\n\n\tsetup_min_slab_ratio();\n\n\treturn 0;\n}\n#endif\n\n/*\n * lowmem_reserve_ratio_sysctl_handler - just a wrapper around\n *\tproc_dointvec() so that we can call setup_per_zone_lowmem_reserve()\n *\twhenever sysctl_lowmem_reserve_ratio changes.\n *\n * The reserve ratio obviously has absolutely no relation with the\n * minimum watermarks. The lowmem reserve ratio can only make sense\n * if in function of the boot time zone sizes.\n */\nint lowmem_reserve_ratio_sysctl_handler(struct ctl_table *table, int write,\n\tvoid __user *buffer, size_t *length, loff_t *ppos)\n{\n\tproc_dointvec_minmax(table, write, buffer, length, ppos);\n\tsetup_per_zone_lowmem_reserve();\n\treturn 0;\n}\n\n/*\n * percpu_pagelist_fraction - changes the pcp->high for each zone on each\n * cpu.  It is the fraction of total pages in each zone that a hot per cpu\n * pagelist can have before it gets flushed back to buddy allocator.\n */\nint percpu_pagelist_fraction_sysctl_handler(struct ctl_table *table, int write,\n\tvoid __user *buffer, size_t *length, loff_t *ppos)\n{\n\tstruct zone *zone;\n\tint old_percpu_pagelist_fraction;\n\tint ret;\n\n\tmutex_lock(&pcp_batch_high_lock);\n\told_percpu_pagelist_fraction = percpu_pagelist_fraction;\n\n\tret = proc_dointvec_minmax(table, write, buffer, length, ppos);\n\tif (!write || ret < 0)\n\t\tgoto out;\n\n\t/* Sanity checking to avoid pcp imbalance */\n\tif (percpu_pagelist_fraction &&\n\t    percpu_pagelist_fraction < MIN_PERCPU_PAGELIST_FRACTION) {\n\t\tpercpu_pagelist_fraction = old_percpu_pagelist_fraction;\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* No change? */\n\tif (percpu_pagelist_fraction == old_percpu_pagelist_fraction)\n\t\tgoto out;\n\n\tfor_each_populated_zone(zone) {\n\t\tunsigned int cpu;\n\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tpageset_set_high_and_batch(zone,\n\t\t\t\t\tper_cpu_ptr(zone->pageset, cpu));\n\t}\nout:\n\tmutex_unlock(&pcp_batch_high_lock);\n\treturn ret;\n}\n\n#ifdef CONFIG_NUMA\nint hashdist = HASHDIST_DEFAULT;\n\nstatic int __init set_hashdist(char *str)\n{\n\tif (!str)\n\t\treturn 0;\n\thashdist = simple_strtoul(str, &str, 0);\n\treturn 1;\n}\n__setup(\"hashdist=\", set_hashdist);\n#endif\n\n#ifndef __HAVE_ARCH_RESERVED_KERNEL_PAGES\n/*\n * Returns the number of pages that arch has reserved but\n * is not known to alloc_large_system_hash().\n */\nstatic unsigned long __init arch_reserved_kernel_pages(void)\n{\n\treturn 0;\n}\n#endif\n\n/*\n * Adaptive scale is meant to reduce sizes of hash tables on large memory\n * machines. As memory size is increased the scale is also increased but at\n * slower pace.  Starting from ADAPT_SCALE_BASE (64G), every time memory\n * quadruples the scale is increased by one, which means the size of hash table\n * only doubles, instead of quadrupling as well.\n * Because 32-bit systems cannot have large physical memory, where this scaling\n * makes sense, it is disabled on such platforms.\n */\n#if __BITS_PER_LONG > 32\n#define ADAPT_SCALE_BASE\t(64ul << 30)\n#define ADAPT_SCALE_SHIFT\t2\n#define ADAPT_SCALE_NPAGES\t(ADAPT_SCALE_BASE >> PAGE_SHIFT)\n#endif\n\n/*\n * allocate a large system hash table from bootmem\n * - it is assumed that the hash table must contain an exact power-of-2\n *   quantity of entries\n * - limit is the number of hash buckets, not the total allocation size\n */\nvoid *__init alloc_large_system_hash(const char *tablename,\n\t\t\t\t     unsigned long bucketsize,\n\t\t\t\t     unsigned long numentries,\n\t\t\t\t     int scale,\n\t\t\t\t     int flags,\n\t\t\t\t     unsigned int *_hash_shift,\n\t\t\t\t     unsigned int *_hash_mask,\n\t\t\t\t     unsigned long low_limit,\n\t\t\t\t     unsigned long high_limit)\n{\n\tunsigned long long max = high_limit;\n\tunsigned long log2qty, size;\n\tvoid *table = NULL;\n\tgfp_t gfp_flags;\n\n\t/* allow the kernel cmdline to have a say */\n\tif (!numentries) {\n\t\t/* round applicable memory size up to nearest megabyte */\n\t\tnumentries = nr_kernel_pages;\n\t\tnumentries -= arch_reserved_kernel_pages();\n\n\t\t/* It isn't necessary when PAGE_SIZE >= 1MB */\n\t\tif (PAGE_SHIFT < 20)\n\t\t\tnumentries = round_up(numentries, (1<<20)/PAGE_SIZE);\n\n#if __BITS_PER_LONG > 32\n\t\tif (!high_limit) {\n\t\t\tunsigned long adapt;\n\n\t\t\tfor (adapt = ADAPT_SCALE_NPAGES; adapt < numentries;\n\t\t\t     adapt <<= ADAPT_SCALE_SHIFT)\n\t\t\t\tscale++;\n\t\t}\n#endif\n\n\t\t/* limit to 1 bucket per 2^scale bytes of low memory */\n\t\tif (scale > PAGE_SHIFT)\n\t\t\tnumentries >>= (scale - PAGE_SHIFT);\n\t\telse\n\t\t\tnumentries <<= (PAGE_SHIFT - scale);\n\n\t\t/* Make sure we've got at least a 0-order allocation.. */\n\t\tif (unlikely(flags & HASH_SMALL)) {\n\t\t\t/* Makes no sense without HASH_EARLY */\n\t\t\tWARN_ON(!(flags & HASH_EARLY));\n\t\t\tif (!(numentries >> *_hash_shift)) {\n\t\t\t\tnumentries = 1UL << *_hash_shift;\n\t\t\t\tBUG_ON(!numentries);\n\t\t\t}\n\t\t} else if (unlikely((numentries * bucketsize) < PAGE_SIZE))\n\t\t\tnumentries = PAGE_SIZE / bucketsize;\n\t}\n\tnumentries = roundup_pow_of_two(numentries);\n\n\t/* limit allocation size to 1/16 total memory by default */\n\tif (max == 0) {\n\t\tmax = ((unsigned long long)nr_all_pages << PAGE_SHIFT) >> 4;\n\t\tdo_div(max, bucketsize);\n\t}\n\tmax = min(max, 0x80000000ULL);\n\n\tif (numentries < low_limit)\n\t\tnumentries = low_limit;\n\tif (numentries > max)\n\t\tnumentries = max;\n\n\tlog2qty = ilog2(numentries);\n\n\tgfp_flags = (flags & HASH_ZERO) ? GFP_ATOMIC | __GFP_ZERO : GFP_ATOMIC;\n\tdo {\n\t\tsize = bucketsize << log2qty;\n\t\tif (flags & HASH_EARLY) {\n\t\t\tif (flags & HASH_ZERO)\n\t\t\t\ttable = memblock_alloc_nopanic(size,\n\t\t\t\t\t\t\t       SMP_CACHE_BYTES);\n\t\t\telse\n\t\t\t\ttable = memblock_alloc_raw(size,\n\t\t\t\t\t\t\t   SMP_CACHE_BYTES);\n\t\t} else if (hashdist) {\n\t\t\ttable = __vmalloc(size, gfp_flags, PAGE_KERNEL);\n\t\t} else {\n\t\t\t/*\n\t\t\t * If bucketsize is not a power-of-two, we may free\n\t\t\t * some pages at the end of hash table which\n\t\t\t * alloc_pages_exact() automatically does\n\t\t\t */\n\t\t\tif (get_order(size) < MAX_ORDER) {\n\t\t\t\ttable = alloc_pages_exact(size, gfp_flags);\n\t\t\t\tkmemleak_alloc(table, size, 1, gfp_flags);\n\t\t\t}\n\t\t}\n\t} while (!table && size > PAGE_SIZE && --log2qty);\n\n\tif (!table)\n\t\tpanic(\"Failed to allocate %s hash table\\n\", tablename);\n\n\tpr_info(\"%s hash table entries: %ld (order: %d, %lu bytes)\\n\",\n\t\ttablename, 1UL << log2qty, ilog2(size) - PAGE_SHIFT, size);\n\n\tif (_hash_shift)\n\t\t*_hash_shift = log2qty;\n\tif (_hash_mask)\n\t\t*_hash_mask = (1 << log2qty) - 1;\n\n\treturn table;\n}\n\n/*\n * This function checks whether pageblock includes unmovable pages or not.\n * If @count is not zero, it is okay to include less @count unmovable pages\n *\n * PageLRU check without isolation or lru_lock could race so that\n * MIGRATE_MOVABLE block might include unmovable pages. And __PageMovable\n * check without lock_page also may miss some movable non-lru pages at\n * race condition. So you can't expect this function should be exact.\n */\nbool has_unmovable_pages(struct zone *zone, struct page *page, int count,\n\t\t\t int migratetype,\n\t\t\t bool skip_hwpoisoned_pages)\n{\n\tunsigned long pfn, iter, found;\n\n\t/*\n\t * TODO we could make this much more efficient by not checking every\n\t * page in the range if we know all of them are in MOVABLE_ZONE and\n\t * that the movable zone guarantees that pages are migratable but\n\t * the later is not the case right now unfortunatelly. E.g. movablecore\n\t * can still lead to having bootmem allocations in zone_movable.\n\t */\n\n\t/*\n\t * CMA allocations (alloc_contig_range) really need to mark isolate\n\t * CMA pageblocks even when they are not movable in fact so consider\n\t * them movable here.\n\t */\n\tif (is_migrate_cma(migratetype) &&\n\t\t\tis_migrate_cma(get_pageblock_migratetype(page)))\n\t\treturn false;\n\n\tpfn = page_to_pfn(page);\n\tfor (found = 0, iter = 0; iter < pageblock_nr_pages; iter++) {\n\t\tunsigned long check = pfn + iter;\n\n\t\tif (!pfn_valid_within(check))\n\t\t\tcontinue;\n\n\t\tpage = pfn_to_page(check);\n\n\t\tif (PageReserved(page))\n\t\t\tgoto unmovable;\n\n\t\t/*\n\t\t * If the zone is movable and we have ruled out all reserved\n\t\t * pages then it should be reasonably safe to assume the rest\n\t\t * is movable.\n\t\t */\n\t\tif (zone_idx(zone) == ZONE_MOVABLE)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Hugepages are not in LRU lists, but they're movable.\n\t\t * We need not scan over tail pages bacause we don't\n\t\t * handle each tail page individually in migration.\n\t\t */\n\t\tif (PageHuge(page)) {\n\n\t\t\tif (!hugepage_migration_supported(page_hstate(page)))\n\t\t\t\tgoto unmovable;\n\n\t\t\titer = round_up(iter + 1, 1<<compound_order(page)) - 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * We can't use page_count without pin a page\n\t\t * because another CPU can free compound page.\n\t\t * This check already skips compound tails of THP\n\t\t * because their page->_refcount is zero at all time.\n\t\t */\n\t\tif (!page_ref_count(page)) {\n\t\t\tif (PageBuddy(page))\n\t\t\t\titer += (1 << page_order(page)) - 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * The HWPoisoned page may be not in buddy system, and\n\t\t * page_count() is not 0.\n\t\t */\n\t\tif (skip_hwpoisoned_pages && PageHWPoison(page))\n\t\t\tcontinue;\n\n\t\tif (__PageMovable(page))\n\t\t\tcontinue;\n\n\t\tif (!PageLRU(page))\n\t\t\tfound++;\n\t\t/*\n\t\t * If there are RECLAIMABLE pages, we need to check\n\t\t * it.  But now, memory offline itself doesn't call\n\t\t * shrink_node_slabs() and it still to be fixed.\n\t\t */\n\t\t/*\n\t\t * If the page is not RAM, page_count()should be 0.\n\t\t * we don't need more check. This is an _used_ not-movable page.\n\t\t *\n\t\t * The problematic thing here is PG_reserved pages. PG_reserved\n\t\t * is set to both of a memory hole page and a _used_ kernel\n\t\t * page at boot.\n\t\t */\n\t\tif (found > count)\n\t\t\tgoto unmovable;\n\t}\n\treturn false;\nunmovable:\n\tWARN_ON_ONCE(zone_idx(zone) == ZONE_MOVABLE);\n\treturn true;\n}\n\n#if (defined(CONFIG_MEMORY_ISOLATION) && defined(CONFIG_COMPACTION)) || defined(CONFIG_CMA)\n\nstatic unsigned long pfn_max_align_down(unsigned long pfn)\n{\n\treturn pfn & ~(max_t(unsigned long, MAX_ORDER_NR_PAGES,\n\t\t\t     pageblock_nr_pages) - 1);\n}\n\nstatic unsigned long pfn_max_align_up(unsigned long pfn)\n{\n\treturn ALIGN(pfn, max_t(unsigned long, MAX_ORDER_NR_PAGES,\n\t\t\t\tpageblock_nr_pages));\n}\n\n/* [start, end) must belong to a single zone. */\nstatic int __alloc_contig_migrate_range(struct compact_control *cc,\n\t\t\t\t\tunsigned long start, unsigned long end)\n{\n\t/* This function is based on compact_zone() from compaction.c. */\n\tunsigned long nr_reclaimed;\n\tunsigned long pfn = start;\n\tunsigned int tries = 0;\n\tint ret = 0;\n\n\tmigrate_prep();\n\n\twhile (pfn < end || !list_empty(&cc->migratepages)) {\n\t\tif (fatal_signal_pending(current)) {\n\t\t\tret = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (list_empty(&cc->migratepages)) {\n\t\t\tcc->nr_migratepages = 0;\n\t\t\tpfn = isolate_migratepages_range(cc, pfn, end);\n\t\t\tif (!pfn) {\n\t\t\t\tret = -EINTR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttries = 0;\n\t\t} else if (++tries == 5) {\n\t\t\tret = ret < 0 ? ret : -EBUSY;\n\t\t\tbreak;\n\t\t}\n\n\t\tnr_reclaimed = reclaim_clean_pages_from_list(cc->zone,\n\t\t\t\t\t\t\t&cc->migratepages);\n\t\tcc->nr_migratepages -= nr_reclaimed;\n\n\t\tret = migrate_pages(&cc->migratepages, alloc_migrate_target,\n\t\t\t\t    NULL, 0, cc->mode, MR_CONTIG_RANGE);\n\t}\n\tif (ret < 0) {\n\t\tputback_movable_pages(&cc->migratepages);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\n/**\n * alloc_contig_range() -- tries to allocate given range of pages\n * @start:\tstart PFN to allocate\n * @end:\tone-past-the-last PFN to allocate\n * @migratetype:\tmigratetype of the underlaying pageblocks (either\n *\t\t\t#MIGRATE_MOVABLE or #MIGRATE_CMA).  All pageblocks\n *\t\t\tin range must have the same migratetype and it must\n *\t\t\tbe either of the two.\n * @gfp_mask:\tGFP mask to use during compaction\n *\n * The PFN range does not have to be pageblock or MAX_ORDER_NR_PAGES\n * aligned.  The PFN range must belong to a single zone.\n *\n * The first thing this routine does is attempt to MIGRATE_ISOLATE all\n * pageblocks in the range.  Once isolated, the pageblocks should not\n * be modified by others.\n *\n * Returns zero on success or negative error code.  On success all\n * pages which PFN is in [start, end) are allocated for the caller and\n * need to be freed with free_contig_range().\n */\nint alloc_contig_range(unsigned long start, unsigned long end,\n\t\t       unsigned migratetype, gfp_t gfp_mask)\n{\n\tunsigned long outer_start, outer_end;\n\tunsigned int order;\n\tint ret = 0;\n\n\tstruct compact_control cc = {\n\t\t.nr_migratepages = 0,\n\t\t.order = -1,\n\t\t.zone = page_zone(pfn_to_page(start)),\n\t\t.mode = MIGRATE_SYNC,\n\t\t.ignore_skip_hint = true,\n\t\t.no_set_skip_hint = true,\n\t\t.gfp_mask = current_gfp_context(gfp_mask),\n\t};\n\tINIT_LIST_HEAD(&cc.migratepages);\n\n\t/*\n\t * What we do here is we mark all pageblocks in range as\n\t * MIGRATE_ISOLATE.  Because pageblock and max order pages may\n\t * have different sizes, and due to the way page allocator\n\t * work, we align the range to biggest of the two pages so\n\t * that page allocator won't try to merge buddies from\n\t * different pageblocks and change MIGRATE_ISOLATE to some\n\t * other migration type.\n\t *\n\t * Once the pageblocks are marked as MIGRATE_ISOLATE, we\n\t * migrate the pages from an unaligned range (ie. pages that\n\t * we are interested in).  This will put all the pages in\n\t * range back to page allocator as MIGRATE_ISOLATE.\n\t *\n\t * When this is done, we take the pages in range from page\n\t * allocator removing them from the buddy system.  This way\n\t * page allocator will never consider using them.\n\t *\n\t * This lets us mark the pageblocks back as\n\t * MIGRATE_CMA/MIGRATE_MOVABLE so that free pages in the\n\t * aligned range but not in the unaligned, original range are\n\t * put back to page allocator so that buddy can use them.\n\t */\n\n\tret = start_isolate_page_range(pfn_max_align_down(start),\n\t\t\t\t       pfn_max_align_up(end), migratetype,\n\t\t\t\t       false);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * In case of -EBUSY, we'd like to know which page causes problem.\n\t * So, just fall through. test_pages_isolated() has a tracepoint\n\t * which will report the busy page.\n\t *\n\t * It is possible that busy pages could become available before\n\t * the call to test_pages_isolated, and the range will actually be\n\t * allocated.  So, if we fall through be sure to clear ret so that\n\t * -EBUSY is not accidentally used or returned to caller.\n\t */\n\tret = __alloc_contig_migrate_range(&cc, start, end);\n\tif (ret && ret != -EBUSY)\n\t\tgoto done;\n\tret =0;\n\n\t/*\n\t * Pages from [start, end) are within a MAX_ORDER_NR_PAGES\n\t * aligned blocks that are marked as MIGRATE_ISOLATE.  What's\n\t * more, all pages in [start, end) are free in page allocator.\n\t * What we are going to do is to allocate all pages from\n\t * [start, end) (that is remove them from page allocator).\n\t *\n\t * The only problem is that pages at the beginning and at the\n\t * end of interesting range may be not aligned with pages that\n\t * page allocator holds, ie. they can be part of higher order\n\t * pages.  Because of this, we reserve the bigger range and\n\t * once this is done free the pages we are not interested in.\n\t *\n\t * We don't have to hold zone->lock here because the pages are\n\t * isolated thus they won't get removed from buddy.\n\t */\n\n\tlru_add_drain_all();\n\tdrain_all_pages(cc.zone);\n\n\torder = 0;\n\touter_start = start;\n\twhile (!PageBuddy(pfn_to_page(outer_start))) {\n\t\tif (++order >= MAX_ORDER) {\n\t\t\touter_start = start;\n\t\t\tbreak;\n\t\t}\n\t\touter_start &= ~0UL << order;\n\t}\n\n\tif (outer_start != start) {\n\t\torder = page_order(pfn_to_page(outer_start));\n\n\t\t/*\n\t\t * outer_start page could be small order buddy page and\n\t\t * it doesn't include start page. Adjust outer_start\n\t\t * in this case to report failed page properly\n\t\t * on tracepoint in test_pages_isolated()\n\t\t */\n\t\tif (outer_start + (1UL << order) <= start)\n\t\t\touter_start = start;\n\t}\n\n\t/* Make sure the range is really isolated. */\n\tif (test_pages_isolated(outer_start, end, false)) {\n\t\tpr_info_ratelimited(\"%s: [%lx, %lx) PFNs busy\\n\",\n\t\t\t__func__, outer_start, end);\n\t\tret = -EBUSY;\n\t\tgoto done;\n\t}\n\n\t/* Grab isolated pages from freelists. */\n\touter_end = isolate_freepages_range(&cc, outer_start, end);\n\tif (!outer_end) {\n\t\tret = -EBUSY;\n\t\tgoto done;\n\t}\n\n\t/* Free head and tail (if any) */\n\tif (start != outer_start)\n\t\tfree_contig_range(outer_start, start - outer_start);\n\tif (end != outer_end)\n\t\tfree_contig_range(end, outer_end - end);\n\ndone:\n\tundo_isolate_page_range(pfn_max_align_down(start),\n\t\t\t\tpfn_max_align_up(end), migratetype);\n\treturn ret;\n}\n\nvoid free_contig_range(unsigned long pfn, unsigned nr_pages)\n{\n\tunsigned int count = 0;\n\n\tfor (; nr_pages--; pfn++) {\n\t\tstruct page *page = pfn_to_page(pfn);\n\n\t\tcount += page_count(page) != 1;\n\t\t__free_page(page);\n\t}\n\tWARN(count != 0, \"%d pages are still in use!\\n\", count);\n}\n#endif\n\n#ifdef CONFIG_MEMORY_HOTPLUG\n/*\n * The zone indicated has a new number of managed_pages; batch sizes and percpu\n * page high values need to be recalulated.\n */\nvoid __meminit zone_pcp_update(struct zone *zone)\n{\n\tunsigned cpu;\n\tmutex_lock(&pcp_batch_high_lock);\n\tfor_each_possible_cpu(cpu)\n\t\tpageset_set_high_and_batch(zone,\n\t\t\t\tper_cpu_ptr(zone->pageset, cpu));\n\tmutex_unlock(&pcp_batch_high_lock);\n}\n#endif\n\nvoid zone_pcp_reset(struct zone *zone)\n{\n\tunsigned long flags;\n\tint cpu;\n\tstruct per_cpu_pageset *pset;\n\n\t/* avoid races with drain_pages()  */\n\tlocal_irq_save(flags);\n\tif (zone->pageset != &boot_pageset) {\n\t\tfor_each_online_cpu(cpu) {\n\t\t\tpset = per_cpu_ptr(zone->pageset, cpu);\n\t\t\tdrain_zonestat(zone, pset);\n\t\t}\n\t\tfree_percpu(zone->pageset);\n\t\tzone->pageset = &boot_pageset;\n\t}\n\tlocal_irq_restore(flags);\n}\n\n#ifdef CONFIG_MEMORY_HOTREMOVE\n/*\n * All pages in the range must be in a single zone and isolated\n * before calling this.\n */\nvoid\n__offline_isolated_pages(unsigned long start_pfn, unsigned long end_pfn)\n{\n\tstruct page *page;\n\tstruct zone *zone;\n\tunsigned int order, i;\n\tunsigned long pfn;\n\tunsigned long flags;\n\t/* find the first valid pfn */\n\tfor (pfn = start_pfn; pfn < end_pfn; pfn++)\n\t\tif (pfn_valid(pfn))\n\t\t\tbreak;\n\tif (pfn == end_pfn)\n\t\treturn;\n\toffline_mem_sections(pfn, end_pfn);\n\tzone = page_zone(pfn_to_page(pfn));\n\tspin_lock_irqsave(&zone->lock, flags);\n\tpfn = start_pfn;\n\twhile (pfn < end_pfn) {\n\t\tif (!pfn_valid(pfn)) {\n\t\t\tpfn++;\n\t\t\tcontinue;\n\t\t}\n\t\tpage = pfn_to_page(pfn);\n\t\t/*\n\t\t * The HWPoisoned page may be not in buddy system, and\n\t\t * page_count() is not 0.\n\t\t */\n\t\tif (unlikely(!PageBuddy(page) && PageHWPoison(page))) {\n\t\t\tpfn++;\n\t\t\tSetPageReserved(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\tBUG_ON(page_count(page));\n\t\tBUG_ON(!PageBuddy(page));\n\t\torder = page_order(page);\n#ifdef CONFIG_DEBUG_VM\n\t\tpr_info(\"remove from free list %lx %d %lx\\n\",\n\t\t\tpfn, 1 << order, end_pfn);\n#endif\n\t\tlist_del(&page->lru);\n\t\trmv_page_order(page);\n\t\tzone->free_area[order].nr_free--;\n\t\tfor (i = 0; i < (1 << order); i++)\n\t\t\tSetPageReserved((page+i));\n\t\tpfn += (1 << order);\n\t}\n\tspin_unlock_irqrestore(&zone->lock, flags);\n}\n#endif\n\nbool is_free_buddy_page(struct page *page)\n{\n\tstruct zone *zone = page_zone(page);\n\tunsigned long pfn = page_to_pfn(page);\n\tunsigned long flags;\n\tunsigned int order;\n\n\tspin_lock_irqsave(&zone->lock, flags);\n\tfor (order = 0; order < MAX_ORDER; order++) {\n\t\tstruct page *page_head = page - (pfn & ((1 << order) - 1));\n\n\t\tif (PageBuddy(page_head) && page_order(page_head) >= order)\n\t\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&zone->lock, flags);\n\n\treturn order < MAX_ORDER;\n}\n\n#ifdef CONFIG_MEMORY_FAILURE\n/*\n * Set PG_hwpoison flag if a given page is confirmed to be a free page.  This\n * test is performed under the zone lock to prevent a race against page\n * allocation.\n */\nbool set_hwpoison_free_buddy_page(struct page *page)\n{\n\tstruct zone *zone = page_zone(page);\n\tunsigned long pfn = page_to_pfn(page);\n\tunsigned long flags;\n\tunsigned int order;\n\tbool hwpoisoned = false;\n\n\tspin_lock_irqsave(&zone->lock, flags);\n\tfor (order = 0; order < MAX_ORDER; order++) {\n\t\tstruct page *page_head = page - (pfn & ((1 << order) - 1));\n\n\t\tif (PageBuddy(page_head) && page_order(page_head) >= order) {\n\t\t\tif (!TestSetPageHWPoison(page))\n\t\t\t\thwpoisoned = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&zone->lock, flags);\n\n\treturn hwpoisoned;\n}\n#endif",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [
      "#define ADAPT_SCALE_NPAGES\t(ADAPT_SCALE_BASE >> PAGE_SHIFT)",
      "#define ADAPT_SCALE_SHIFT\t2",
      "#define ADAPT_SCALE_BASE\t(64ul << 30)",
      "#define MAX_NODE_LOAD (nr_online_nodes)",
      "#define MIN_PERCPU_PAGELIST_FRACTION\t(8)"
    ],
    "globals_used": [
      "static DEFINE_MUTEX(pcp_batch_high_lock);",
      "nodemask_t node_states[NR_NODE_STATES] __read_mostly = {\n\t[N_POSSIBLE] = NODE_MASK_ALL,\n\t[N_ONLINE] = { { [0] = 1UL } },\n#ifndef CONFIG_NUMA\n\t[N_NORMAL_MEMORY] = { { [0] = 1UL } },\n#ifdef CONFIG_HIGHMEM\n\t[N_HIGH_MEMORY] = { { [0] = 1UL } },\n#endif\n\t[N_MEMORY] = { { [0] = 1UL } },\n\t[N_CPU] = { { [0] = 1UL } },\n#endif\t/* NUMA */\n};",
      "static DEFINE_SPINLOCK(managed_page_count_lock);",
      "int percpu_pagelist_fraction;",
      "static void __free_pages_ok(struct page *page, unsigned int order);",
      "int sysctl_lowmem_reserve_ratio[MAX_NR_ZONES] = {\n#ifdef CONFIG_ZONE_DMA\n\t[ZONE_DMA] = 256,\n#endif\n#ifdef CONFIG_ZONE_DMA32\n\t[ZONE_DMA32] = 256,\n#endif\n\t[ZONE_NORMAL] = 32,\n#ifdef CONFIG_HIGHMEM\n\t[ZONE_HIGHMEM] = 0,\n#endif\n\t[ZONE_MOVABLE] = 0,\n};",
      "static char * const zone_names[MAX_NR_ZONES] = {\n#ifdef CONFIG_ZONE_DMA\n\t \"DMA\",\n#endif\n#ifdef CONFIG_ZONE_DMA32\n\t \"DMA32\",\n#endif\n\t \"Normal\",\n#ifdef CONFIG_HIGHMEM\n\t \"HighMem\",\n#endif\n\t \"Movable\",\n#ifdef CONFIG_ZONE_DEVICE\n\t \"Device\",\n#endif\n};",
      "int min_free_kbytes = 1024;",
      "int user_min_free_kbytes = -1;",
      "int watermark_scale_factor = 10;",
      "int page_group_by_mobility_disabled",
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&zone->lock",
            "flags"
          ],
          "line": 8221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TestSetPageHWPoison",
          "args": [
            "page"
          ],
          "line": 8216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_order",
          "args": [
            "page_head"
          ],
          "line": 8215
        },
        "resolved": true,
        "details": {
          "function_name": "rmv_page_order",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "707-711",
          "snippet": "static inline void rmv_page_order(struct page *page)\n{\n\t__ClearPageBuddy(page);\n\tset_page_private(page, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline void rmv_page_order(struct page *page)\n{\n\t__ClearPageBuddy(page);\n\tset_page_private(page, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageBuddy",
          "args": [
            "page_head"
          ],
          "line": 8215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&zone->lock",
            "flags"
          ],
          "line": 8211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "page"
          ],
          "line": 8206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "page"
          ],
          "line": 8205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&zone->lock",
            "flags"
          ],
          "line": 8192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageBuddy",
          "args": [
            "page_head"
          ],
          "line": 8189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&zone->lock",
            "flags"
          ],
          "line": 8185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "page"
          ],
          "line": 8181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "page"
          ],
          "line": 8180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&zone->lock",
            "flags"
          ],
          "line": 8174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageReserved",
          "args": [
            "(page+i)"
          ],
          "line": 8171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&page->lru"
          ],
          "line": 8167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"remove from free list %lx %d %lx\\n\"",
            "pfn",
            "1 << order",
            "end_pfn"
          ],
          "line": 8164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageBuddy(page)"
          ],
          "line": 8161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageBuddy",
          "args": [
            "page"
          ],
          "line": 8161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "page_count(page)"
          ],
          "line": 8160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "page"
          ],
          "line": 8160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageReserved",
          "args": [
            "page"
          ],
          "line": 8156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!PageBuddy(page) && PageHWPoison(page)"
          ],
          "line": 8154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHWPoison",
          "args": [
            "page"
          ],
          "line": 8154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageBuddy",
          "args": [
            "page"
          ],
          "line": 8154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 8149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_valid",
          "args": [
            "pfn"
          ],
          "line": 8145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&zone->lock",
            "flags"
          ],
          "line": 8142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "pfn_to_page(pfn)"
          ],
          "line": 8141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 8141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offline_mem_sections",
          "args": [
            "pfn",
            "end_pfn"
          ],
          "line": 8140
        },
        "resolved": true,
        "details": {
          "function_name": "offline_mem_sections",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "544-562",
          "snippet": "void offline_mem_sections(unsigned long start_pfn, unsigned long end_pfn)\n{\n\tunsigned long pfn;\n\n\tfor (pfn = start_pfn; pfn < end_pfn; pfn += PAGES_PER_SECTION) {\n\t\tunsigned long section_nr = pfn_to_section_nr(pfn);\n\t\tstruct mem_section *ms;\n\n\t\t/*\n\t\t * TODO this needs some double checking. Offlining code makes\n\t\t * sure to check pfn_valid but those checks might be just bogus\n\t\t */\n\t\tif (WARN_ON(!valid_section_nr(section_nr)))\n\t\t\tcontinue;\n\n\t\tms = __nr_to_section(section_nr);\n\t\tms->section_mem_map &= ~SECTION_IS_ONLINE;\n\t}\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid offline_mem_sections(unsigned long start_pfn, unsigned long end_pfn)\n{\n\tunsigned long pfn;\n\n\tfor (pfn = start_pfn; pfn < end_pfn; pfn += PAGES_PER_SECTION) {\n\t\tunsigned long section_nr = pfn_to_section_nr(pfn);\n\t\tstruct mem_section *ms;\n\n\t\t/*\n\t\t * TODO this needs some double checking. Offlining code makes\n\t\t * sure to check pfn_valid but those checks might be just bogus\n\t\t */\n\t\tif (WARN_ON(!valid_section_nr(section_nr)))\n\t\t\tcontinue;\n\n\t\tms = __nr_to_section(section_nr);\n\t\tms->section_mem_map &= ~SECTION_IS_ONLINE;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfn_valid",
          "args": [
            "pfn"
          ],
          "line": 8136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 8118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "zone->pageset"
          ],
          "line": 8115
        },
        "resolved": true,
        "details": {
          "function_name": "free_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/percpu.c",
          "lines": "1718-1753",
          "snippet": "void free_percpu(void __percpu *ptr)\n{\n\tvoid *addr;\n\tstruct pcpu_chunk *chunk;\n\tunsigned long flags;\n\tint off;\n\n\tif (!ptr)\n\t\treturn;\n\n\tkmemleak_free_percpu(ptr);\n\n\taddr = __pcpu_ptr_to_addr(ptr);\n\n\tspin_lock_irqsave(&pcpu_lock, flags);\n\n\tchunk = pcpu_chunk_addr_search(addr);\n\toff = addr - chunk->base_addr;\n\n\tpcpu_free_area(chunk, off);\n\n\t/* if there are more than one fully free chunks, wake up grim reaper */\n\tif (chunk->free_bytes == pcpu_unit_size) {\n\t\tstruct pcpu_chunk *pos;\n\n\t\tlist_for_each_entry(pos, &pcpu_slot[pcpu_nr_slots - 1], list)\n\t\t\tif (pos != chunk) {\n\t\t\t\tpcpu_schedule_balance_work();\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\ttrace_percpu_free_percpu(chunk->base_addr, off, ptr);\n\n\tspin_unlock_irqrestore(&pcpu_lock, flags);\n}",
          "includes": [
            "#include \"percpu-vm.c\"",
            "#include \"percpu-km.c\"",
            "#include \"percpu-internal.h\"",
            "#include <trace/events/percpu.h>",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/sched.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/pfn.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/list.h>",
            "#include <linux/lcm.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <linux/bitmap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int pcpu_unit_size",
            "int pcpu_nr_slots",
            "static void pcpu_destroy_chunk(struct pcpu_chunk *chunk);",
            "static struct page *pcpu_addr_to_page(void *addr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu-vm.c\"\n#include \"percpu-km.c\"\n#include \"percpu-internal.h\"\n#include <trace/events/percpu.h>\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <asm/cacheflush.h>\n#include <linux/sched.h>\n#include <linux/kmemleak.h>\n#include <linux/workqueue.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/pfn.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/list.h>\n#include <linux/lcm.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <linux/bitmap.h>\n\nstatic int pcpu_unit_size;\nint pcpu_nr_slots;\nstatic void pcpu_destroy_chunk(struct pcpu_chunk *chunk);\nstatic struct page *pcpu_addr_to_page(void *addr);\n\nvoid free_percpu(void __percpu *ptr)\n{\n\tvoid *addr;\n\tstruct pcpu_chunk *chunk;\n\tunsigned long flags;\n\tint off;\n\n\tif (!ptr)\n\t\treturn;\n\n\tkmemleak_free_percpu(ptr);\n\n\taddr = __pcpu_ptr_to_addr(ptr);\n\n\tspin_lock_irqsave(&pcpu_lock, flags);\n\n\tchunk = pcpu_chunk_addr_search(addr);\n\toff = addr - chunk->base_addr;\n\n\tpcpu_free_area(chunk, off);\n\n\t/* if there are more than one fully free chunks, wake up grim reaper */\n\tif (chunk->free_bytes == pcpu_unit_size) {\n\t\tstruct pcpu_chunk *pos;\n\n\t\tlist_for_each_entry(pos, &pcpu_slot[pcpu_nr_slots - 1], list)\n\t\t\tif (pos != chunk) {\n\t\t\t\tpcpu_schedule_balance_work();\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\ttrace_percpu_free_percpu(chunk->base_addr, off, ptr);\n\n\tspin_unlock_irqrestore(&pcpu_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "drain_zonestat",
          "args": [
            "zone",
            "pset"
          ],
          "line": 8113
        },
        "resolved": true,
        "details": {
          "function_name": "drain_zonestat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "912-934",
          "snippet": "void drain_zonestat(struct zone *zone, struct per_cpu_pageset *pset)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_VM_ZONE_STAT_ITEMS; i++)\n\t\tif (pset->vm_stat_diff[i]) {\n\t\t\tint v = pset->vm_stat_diff[i];\n\t\t\tpset->vm_stat_diff[i] = 0;\n\t\t\tatomic_long_add(v, &zone->vm_stat[i]);\n\t\t\tatomic_long_add(v, &vm_zone_stat[i]);\n\t\t}\n\n#ifdef CONFIG_NUMA\n\tfor (i = 0; i < NR_VM_NUMA_STAT_ITEMS; i++)\n\t\tif (pset->vm_numa_stat_diff[i]) {\n\t\t\tint v = pset->vm_numa_stat_diff[i];\n\n\t\t\tpset->vm_numa_stat_diff[i] = 0;\n\t\t\tatomic_long_add(v, &zone->vm_numa_stat[i]);\n\t\t\tatomic_long_add(v, &vm_numa_stat[i]);\n\t\t}\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "atomic_long_t vm_zone_stat[NR_VM_ZONE_STAT_ITEMS]",
            "atomic_long_t vm_numa_stat[NR_VM_NUMA_STAT_ITEMS]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\natomic_long_t vm_zone_stat[NR_VM_ZONE_STAT_ITEMS];\natomic_long_t vm_numa_stat[NR_VM_NUMA_STAT_ITEMS];\n\nvoid drain_zonestat(struct zone *zone, struct per_cpu_pageset *pset)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_VM_ZONE_STAT_ITEMS; i++)\n\t\tif (pset->vm_stat_diff[i]) {\n\t\t\tint v = pset->vm_stat_diff[i];\n\t\t\tpset->vm_stat_diff[i] = 0;\n\t\t\tatomic_long_add(v, &zone->vm_stat[i]);\n\t\t\tatomic_long_add(v, &vm_zone_stat[i]);\n\t\t}\n\n#ifdef CONFIG_NUMA\n\tfor (i = 0; i < NR_VM_NUMA_STAT_ITEMS; i++)\n\t\tif (pset->vm_numa_stat_diff[i]) {\n\t\t\tint v = pset->vm_numa_stat_diff[i];\n\n\t\t\tpset->vm_numa_stat_diff[i] = 0;\n\t\t\tatomic_long_add(v, &zone->vm_numa_stat[i]);\n\t\t\tatomic_long_add(v, &vm_numa_stat[i]);\n\t\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "zone->pageset",
            "cpu"
          ],
          "line": 8112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 8109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&pcp_batch_high_lock"
          ],
          "line": 8098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&pcp_batch_high_lock"
          ],
          "line": 8094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "count != 0",
            "\"%d pages are still in use!\\n\"",
            "count"
          ],
          "line": 8082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "page"
          ],
          "line": 8080
        },
        "resolved": true,
        "details": {
          "function_name": "__free_page_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
          "lines": "280-291",
          "snippet": "static void __free_page_ext(unsigned long pfn)\n{\n\tstruct mem_section *ms;\n\tstruct page_ext *base;\n\n\tms = __pfn_to_section(pfn);\n\tif (!ms || !ms->page_ext)\n\t\treturn;\n\tbase = get_entry(ms->page_ext, pfn);\n\tfree_page_ext(base);\n\tms->page_ext = NULL;\n}",
          "includes": [
            "#include <linux/page_idle.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/memory.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nstatic void __free_page_ext(unsigned long pfn)\n{\n\tstruct mem_section *ms;\n\tstruct page_ext *base;\n\n\tms = __pfn_to_section(pfn);\n\tif (!ms || !ms->page_ext)\n\t\treturn;\n\tbase = get_entry(ms->page_ext, pfn);\n\tfree_page_ext(base);\n\tms->page_ext = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "page"
          ],
          "line": 8079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 8077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "undo_isolate_page_range",
          "args": [
            "pfn_max_align_down(start)",
            "pfn_max_align_up(end)",
            "migratetype"
          ],
          "line": 8067
        },
        "resolved": true,
        "details": {
          "function_name": "undo_isolate_page_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_isolation.c",
          "lines": "224-242",
          "snippet": "int undo_isolate_page_range(unsigned long start_pfn, unsigned long end_pfn,\n\t\t\t    unsigned migratetype)\n{\n\tunsigned long pfn;\n\tstruct page *page;\n\n\tBUG_ON(!IS_ALIGNED(start_pfn, pageblock_nr_pages));\n\tBUG_ON(!IS_ALIGNED(end_pfn, pageblock_nr_pages));\n\n\tfor (pfn = start_pfn;\n\t     pfn < end_pfn;\n\t     pfn += pageblock_nr_pages) {\n\t\tpage = __first_valid_page(pfn, pageblock_nr_pages);\n\t\tif (!page || !is_migrate_isolate_page(page))\n\t\t\tcontinue;\n\t\tunset_migratetype_isolate(page, migratetype);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/page_isolation.h>",
            "#include \"internal.h\"",
            "#include <linux/migrate.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/memory.h>",
            "#include <linux/pageblock-flags.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/page_isolation.h>\n#include \"internal.h\"\n#include <linux/migrate.h>\n#include <linux/page_owner.h>\n#include <linux/hugetlb.h>\n#include <linux/memory.h>\n#include <linux/pageblock-flags.h>\n#include <linux/page-isolation.h>\n#include <linux/mm.h>\n\nint undo_isolate_page_range(unsigned long start_pfn, unsigned long end_pfn,\n\t\t\t    unsigned migratetype)\n{\n\tunsigned long pfn;\n\tstruct page *page;\n\n\tBUG_ON(!IS_ALIGNED(start_pfn, pageblock_nr_pages));\n\tBUG_ON(!IS_ALIGNED(end_pfn, pageblock_nr_pages));\n\n\tfor (pfn = start_pfn;\n\t     pfn < end_pfn;\n\t     pfn += pageblock_nr_pages) {\n\t\tpage = __first_valid_page(pfn, pageblock_nr_pages);\n\t\tif (!page || !is_migrate_isolate_page(page))\n\t\t\tcontinue;\n\t\tunset_migratetype_isolate(page, migratetype);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfn_max_align_up",
          "args": [
            "end"
          ],
          "line": 8068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_max_align_down",
          "args": [
            "start"
          ],
          "line": 8067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_contig_range",
          "args": [
            "end",
            "outer_end - end"
          ],
          "line": 8064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_contig_range",
          "args": [
            "outer_start",
            "start - outer_start"
          ],
          "line": 8062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isolate_freepages_range",
          "args": [
            "&cc",
            "outer_start",
            "end"
          ],
          "line": 8054
        },
        "resolved": true,
        "details": {
          "function_name": "isolate_freepages_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "592-657",
          "snippet": "unsigned long\nisolate_freepages_range(struct compact_control *cc,\n\t\t\tunsigned long start_pfn, unsigned long end_pfn)\n{\n\tunsigned long isolated, pfn, block_start_pfn, block_end_pfn;\n\tLIST_HEAD(freelist);\n\n\tpfn = start_pfn;\n\tblock_start_pfn = pageblock_start_pfn(pfn);\n\tif (block_start_pfn < cc->zone->zone_start_pfn)\n\t\tblock_start_pfn = cc->zone->zone_start_pfn;\n\tblock_end_pfn = pageblock_end_pfn(pfn);\n\n\tfor (; pfn < end_pfn; pfn += isolated,\n\t\t\t\tblock_start_pfn = block_end_pfn,\n\t\t\t\tblock_end_pfn += pageblock_nr_pages) {\n\t\t/* Protect pfn from changing by isolate_freepages_block */\n\t\tunsigned long isolate_start_pfn = pfn;\n\n\t\tblock_end_pfn = min(block_end_pfn, end_pfn);\n\n\t\t/*\n\t\t * pfn could pass the block_end_pfn if isolated freepage\n\t\t * is more than pageblock order. In this case, we adjust\n\t\t * scanning range to right one.\n\t\t */\n\t\tif (pfn >= block_end_pfn) {\n\t\t\tblock_start_pfn = pageblock_start_pfn(pfn);\n\t\t\tblock_end_pfn = pageblock_end_pfn(pfn);\n\t\t\tblock_end_pfn = min(block_end_pfn, end_pfn);\n\t\t}\n\n\t\tif (!pageblock_pfn_to_page(block_start_pfn,\n\t\t\t\t\tblock_end_pfn, cc->zone))\n\t\t\tbreak;\n\n\t\tisolated = isolate_freepages_block(cc, &isolate_start_pfn,\n\t\t\t\t\t\tblock_end_pfn, &freelist, true);\n\n\t\t/*\n\t\t * In strict mode, isolate_freepages_block() returns 0 if\n\t\t * there are any holes in the block (ie. invalid PFNs or\n\t\t * non-free pages).\n\t\t */\n\t\tif (!isolated)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * If we managed to isolate pages, it is always (1 << n) *\n\t\t * pageblock_nr_pages for some non-negative n.  (Max order\n\t\t * page may span two pageblocks).\n\t\t */\n\t}\n\n\t/* __isolate_free_page() does not map the pages */\n\tmap_pages(&freelist);\n\n\tif (pfn < end_pfn) {\n\t\t/* Loop terminated early, cleanup. */\n\t\trelease_freepages(&freelist);\n\t\treturn 0;\n\t}\n\n\t/* We don't use freelists for anything. */\n\treturn pfn;\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nunsigned long\nisolate_freepages_range(struct compact_control *cc,\n\t\t\tunsigned long start_pfn, unsigned long end_pfn)\n{\n\tunsigned long isolated, pfn, block_start_pfn, block_end_pfn;\n\tLIST_HEAD(freelist);\n\n\tpfn = start_pfn;\n\tblock_start_pfn = pageblock_start_pfn(pfn);\n\tif (block_start_pfn < cc->zone->zone_start_pfn)\n\t\tblock_start_pfn = cc->zone->zone_start_pfn;\n\tblock_end_pfn = pageblock_end_pfn(pfn);\n\n\tfor (; pfn < end_pfn; pfn += isolated,\n\t\t\t\tblock_start_pfn = block_end_pfn,\n\t\t\t\tblock_end_pfn += pageblock_nr_pages) {\n\t\t/* Protect pfn from changing by isolate_freepages_block */\n\t\tunsigned long isolate_start_pfn = pfn;\n\n\t\tblock_end_pfn = min(block_end_pfn, end_pfn);\n\n\t\t/*\n\t\t * pfn could pass the block_end_pfn if isolated freepage\n\t\t * is more than pageblock order. In this case, we adjust\n\t\t * scanning range to right one.\n\t\t */\n\t\tif (pfn >= block_end_pfn) {\n\t\t\tblock_start_pfn = pageblock_start_pfn(pfn);\n\t\t\tblock_end_pfn = pageblock_end_pfn(pfn);\n\t\t\tblock_end_pfn = min(block_end_pfn, end_pfn);\n\t\t}\n\n\t\tif (!pageblock_pfn_to_page(block_start_pfn,\n\t\t\t\t\tblock_end_pfn, cc->zone))\n\t\t\tbreak;\n\n\t\tisolated = isolate_freepages_block(cc, &isolate_start_pfn,\n\t\t\t\t\t\tblock_end_pfn, &freelist, true);\n\n\t\t/*\n\t\t * In strict mode, isolate_freepages_block() returns 0 if\n\t\t * there are any holes in the block (ie. invalid PFNs or\n\t\t * non-free pages).\n\t\t */\n\t\tif (!isolated)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * If we managed to isolate pages, it is always (1 << n) *\n\t\t * pageblock_nr_pages for some non-negative n.  (Max order\n\t\t * page may span two pageblocks).\n\t\t */\n\t}\n\n\t/* __isolate_free_page() does not map the pages */\n\tmap_pages(&freelist);\n\n\tif (pfn < end_pfn) {\n\t\t/* Loop terminated early, cleanup. */\n\t\trelease_freepages(&freelist);\n\t\treturn 0;\n\t}\n\n\t/* We don't use freelists for anything. */\n\treturn pfn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info_ratelimited",
          "args": [
            "\"%s: [%lx, %lx) PFNs busy\\n\"",
            "__func__",
            "outer_start",
            "end"
          ],
          "line": 8047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_pages_isolated",
          "args": [
            "outer_start",
            "end",
            "false"
          ],
          "line": 8046
        },
        "resolved": true,
        "details": {
          "function_name": "test_pages_isolated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_isolation.c",
          "lines": "280-310",
          "snippet": "int test_pages_isolated(unsigned long start_pfn, unsigned long end_pfn,\n\t\t\tbool skip_hwpoisoned_pages)\n{\n\tunsigned long pfn, flags;\n\tstruct page *page;\n\tstruct zone *zone;\n\n\t/*\n\t * Note: pageblock_nr_pages != MAX_ORDER. Then, chunks of free pages\n\t * are not aligned to pageblock_nr_pages.\n\t * Then we just check migratetype first.\n\t */\n\tfor (pfn = start_pfn; pfn < end_pfn; pfn += pageblock_nr_pages) {\n\t\tpage = __first_valid_page(pfn, pageblock_nr_pages);\n\t\tif (page && !is_migrate_isolate_page(page))\n\t\t\tbreak;\n\t}\n\tpage = __first_valid_page(start_pfn, end_pfn - start_pfn);\n\tif ((pfn < end_pfn) || !page)\n\t\treturn -EBUSY;\n\t/* Check all pages are free or marked as ISOLATED */\n\tzone = page_zone(page);\n\tspin_lock_irqsave(&zone->lock, flags);\n\tpfn = __test_page_isolated_in_pageblock(start_pfn, end_pfn,\n\t\t\t\t\t\tskip_hwpoisoned_pages);\n\tspin_unlock_irqrestore(&zone->lock, flags);\n\n\ttrace_test_pages_isolated(start_pfn, end_pfn, pfn);\n\n\treturn pfn < end_pfn ? -EBUSY : 0;\n}",
          "includes": [
            "#include <trace/events/page_isolation.h>",
            "#include \"internal.h\"",
            "#include <linux/migrate.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/memory.h>",
            "#include <linux/pageblock-flags.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/page_isolation.h>\n#include \"internal.h\"\n#include <linux/migrate.h>\n#include <linux/page_owner.h>\n#include <linux/hugetlb.h>\n#include <linux/memory.h>\n#include <linux/pageblock-flags.h>\n#include <linux/page-isolation.h>\n#include <linux/mm.h>\n\nint test_pages_isolated(unsigned long start_pfn, unsigned long end_pfn,\n\t\t\tbool skip_hwpoisoned_pages)\n{\n\tunsigned long pfn, flags;\n\tstruct page *page;\n\tstruct zone *zone;\n\n\t/*\n\t * Note: pageblock_nr_pages != MAX_ORDER. Then, chunks of free pages\n\t * are not aligned to pageblock_nr_pages.\n\t * Then we just check migratetype first.\n\t */\n\tfor (pfn = start_pfn; pfn < end_pfn; pfn += pageblock_nr_pages) {\n\t\tpage = __first_valid_page(pfn, pageblock_nr_pages);\n\t\tif (page && !is_migrate_isolate_page(page))\n\t\t\tbreak;\n\t}\n\tpage = __first_valid_page(start_pfn, end_pfn - start_pfn);\n\tif ((pfn < end_pfn) || !page)\n\t\treturn -EBUSY;\n\t/* Check all pages are free or marked as ISOLATED */\n\tzone = page_zone(page);\n\tspin_lock_irqsave(&zone->lock, flags);\n\tpfn = __test_page_isolated_in_pageblock(start_pfn, end_pfn,\n\t\t\t\t\t\tskip_hwpoisoned_pages);\n\tspin_unlock_irqrestore(&zone->lock, flags);\n\n\ttrace_test_pages_isolated(start_pfn, end_pfn, pfn);\n\n\treturn pfn < end_pfn ? -EBUSY : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "outer_start"
          ],
          "line": 8033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageBuddy",
          "args": [
            "pfn_to_page(outer_start)"
          ],
          "line": 8024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "outer_start"
          ],
          "line": 8024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "drain_all_pages",
          "args": [
            "cc.zone"
          ],
          "line": 8020
        },
        "resolved": true,
        "details": {
          "function_name": "drain_all_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "2614-2682",
          "snippet": "void drain_all_pages(struct zone *zone)\n{\n\tint cpu;\n\n\t/*\n\t * Allocate in the BSS so we wont require allocation in\n\t * direct reclaim path for CONFIG_CPUMASK_OFFSTACK=y\n\t */\n\tstatic cpumask_t cpus_with_pcps;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON_ONCE(!mm_percpu_wq))\n\t\treturn;\n\n\t/*\n\t * Do not drain if one is already in progress unless it's specific to\n\t * a zone. Such callers are primarily CMA and memory hotplug and need\n\t * the drain to be complete when the call returns.\n\t */\n\tif (unlikely(!mutex_trylock(&pcpu_drain_mutex))) {\n\t\tif (!zone)\n\t\t\treturn;\n\t\tmutex_lock(&pcpu_drain_mutex);\n\t}\n\n\t/*\n\t * We don't care about racing with CPU hotplug event\n\t * as offline notification will cause the notified\n\t * cpu to drain that CPU pcps and on_each_cpu_mask\n\t * disables preemption as part of its processing\n\t */\n\tfor_each_online_cpu(cpu) {\n\t\tstruct per_cpu_pageset *pcp;\n\t\tstruct zone *z;\n\t\tbool has_pcps = false;\n\n\t\tif (zone) {\n\t\t\tpcp = per_cpu_ptr(zone->pageset, cpu);\n\t\t\tif (pcp->pcp.count)\n\t\t\t\thas_pcps = true;\n\t\t} else {\n\t\t\tfor_each_populated_zone(z) {\n\t\t\t\tpcp = per_cpu_ptr(z->pageset, cpu);\n\t\t\t\tif (pcp->pcp.count) {\n\t\t\t\t\thas_pcps = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (has_pcps)\n\t\t\tcpumask_set_cpu(cpu, &cpus_with_pcps);\n\t\telse\n\t\t\tcpumask_clear_cpu(cpu, &cpus_with_pcps);\n\t}\n\n\tfor_each_cpu(cpu, &cpus_with_pcps) {\n\t\tstruct work_struct *work = per_cpu_ptr(&pcpu_drain, cpu);\n\t\tINIT_WORK(work, drain_local_pages_wq);\n\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t}\n\tfor_each_cpu(cpu, &cpus_with_pcps)\n\t\tflush_work(per_cpu_ptr(&pcpu_drain, cpu));\n\n\tmutex_unlock(&pcpu_drain_mutex);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid drain_all_pages(struct zone *zone)\n{\n\tint cpu;\n\n\t/*\n\t * Allocate in the BSS so we wont require allocation in\n\t * direct reclaim path for CONFIG_CPUMASK_OFFSTACK=y\n\t */\n\tstatic cpumask_t cpus_with_pcps;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON_ONCE(!mm_percpu_wq))\n\t\treturn;\n\n\t/*\n\t * Do not drain if one is already in progress unless it's specific to\n\t * a zone. Such callers are primarily CMA and memory hotplug and need\n\t * the drain to be complete when the call returns.\n\t */\n\tif (unlikely(!mutex_trylock(&pcpu_drain_mutex))) {\n\t\tif (!zone)\n\t\t\treturn;\n\t\tmutex_lock(&pcpu_drain_mutex);\n\t}\n\n\t/*\n\t * We don't care about racing with CPU hotplug event\n\t * as offline notification will cause the notified\n\t * cpu to drain that CPU pcps and on_each_cpu_mask\n\t * disables preemption as part of its processing\n\t */\n\tfor_each_online_cpu(cpu) {\n\t\tstruct per_cpu_pageset *pcp;\n\t\tstruct zone *z;\n\t\tbool has_pcps = false;\n\n\t\tif (zone) {\n\t\t\tpcp = per_cpu_ptr(zone->pageset, cpu);\n\t\t\tif (pcp->pcp.count)\n\t\t\t\thas_pcps = true;\n\t\t} else {\n\t\t\tfor_each_populated_zone(z) {\n\t\t\t\tpcp = per_cpu_ptr(z->pageset, cpu);\n\t\t\t\tif (pcp->pcp.count) {\n\t\t\t\t\thas_pcps = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (has_pcps)\n\t\t\tcpumask_set_cpu(cpu, &cpus_with_pcps);\n\t\telse\n\t\t\tcpumask_clear_cpu(cpu, &cpus_with_pcps);\n\t}\n\n\tfor_each_cpu(cpu, &cpus_with_pcps) {\n\t\tstruct work_struct *work = per_cpu_ptr(&pcpu_drain, cpu);\n\t\tINIT_WORK(work, drain_local_pages_wq);\n\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t}\n\tfor_each_cpu(cpu, &cpus_with_pcps)\n\t\tflush_work(per_cpu_ptr(&pcpu_drain, cpu));\n\n\tmutex_unlock(&pcpu_drain_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lru_add_drain_all",
          "args": [],
          "line": 8019
        },
        "resolved": true,
        "details": {
          "function_name": "lru_add_drain_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "670-704",
          "snippet": "void lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct pagevec, lru_add_pvec);",
            "static DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);",
            "static DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_PER_CPU(struct pagevec, lru_add_pvec);\nstatic DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);\nstatic DEFINE_PER_CPU(struct work_struct, lru_add_drain_work);\n\nvoid lru_add_drain_all(void)\n{\n\tstatic DEFINE_MUTEX(lock);\n\tstatic struct cpumask has_work;\n\tint cpu;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON(!mm_percpu_wq))\n\t\treturn;\n\n\tmutex_lock(&lock);\n\tcpumask_clear(&has_work);\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = &per_cpu(lru_add_drain_work, cpu);\n\n\t\tif (pagevec_count(&per_cpu(lru_add_pvec, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_rotate_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_deactivate_file_pvecs, cpu)) ||\n\t\t    pagevec_count(&per_cpu(lru_lazyfree_pvecs, cpu)) ||\n\t\t    need_activate_page_drain(cpu)) {\n\t\t\tINIT_WORK(work, lru_add_drain_per_cpu);\n\t\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t\t\tcpumask_set_cpu(cpu, &has_work);\n\t\t}\n\t}\n\n\tfor_each_cpu(cpu, &has_work)\n\t\tflush_work(&per_cpu(lru_add_drain_work, cpu));\n\n\tmutex_unlock(&lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__alloc_contig_migrate_range",
          "args": [
            "&cc",
            "start",
            "end"
          ],
          "line": 7997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "start_isolate_page_range",
          "args": [
            "pfn_max_align_down(start)",
            "pfn_max_align_up(end)",
            "migratetype",
            "false"
          ],
          "line": 7981
        },
        "resolved": true,
        "details": {
          "function_name": "start_isolate_page_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_isolation.c",
          "lines": "187-219",
          "snippet": "int start_isolate_page_range(unsigned long start_pfn, unsigned long end_pfn,\n\t\t\t     unsigned migratetype, bool skip_hwpoisoned_pages)\n{\n\tunsigned long pfn;\n\tunsigned long undo_pfn;\n\tstruct page *page;\n\n\tBUG_ON(!IS_ALIGNED(start_pfn, pageblock_nr_pages));\n\tBUG_ON(!IS_ALIGNED(end_pfn, pageblock_nr_pages));\n\n\tfor (pfn = start_pfn;\n\t     pfn < end_pfn;\n\t     pfn += pageblock_nr_pages) {\n\t\tpage = __first_valid_page(pfn, pageblock_nr_pages);\n\t\tif (page &&\n\t\t    set_migratetype_isolate(page, migratetype, skip_hwpoisoned_pages)) {\n\t\t\tundo_pfn = pfn;\n\t\t\tgoto undo;\n\t\t}\n\t}\n\treturn 0;\nundo:\n\tfor (pfn = start_pfn;\n\t     pfn < undo_pfn;\n\t     pfn += pageblock_nr_pages) {\n\t\tstruct page *page = pfn_to_online_page(pfn);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tunset_migratetype_isolate(page, migratetype);\n\t}\n\n\treturn -EBUSY;\n}",
          "includes": [
            "#include <trace/events/page_isolation.h>",
            "#include \"internal.h\"",
            "#include <linux/migrate.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/memory.h>",
            "#include <linux/pageblock-flags.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/page_isolation.h>\n#include \"internal.h\"\n#include <linux/migrate.h>\n#include <linux/page_owner.h>\n#include <linux/hugetlb.h>\n#include <linux/memory.h>\n#include <linux/pageblock-flags.h>\n#include <linux/page-isolation.h>\n#include <linux/mm.h>\n\nint start_isolate_page_range(unsigned long start_pfn, unsigned long end_pfn,\n\t\t\t     unsigned migratetype, bool skip_hwpoisoned_pages)\n{\n\tunsigned long pfn;\n\tunsigned long undo_pfn;\n\tstruct page *page;\n\n\tBUG_ON(!IS_ALIGNED(start_pfn, pageblock_nr_pages));\n\tBUG_ON(!IS_ALIGNED(end_pfn, pageblock_nr_pages));\n\n\tfor (pfn = start_pfn;\n\t     pfn < end_pfn;\n\t     pfn += pageblock_nr_pages) {\n\t\tpage = __first_valid_page(pfn, pageblock_nr_pages);\n\t\tif (page &&\n\t\t    set_migratetype_isolate(page, migratetype, skip_hwpoisoned_pages)) {\n\t\t\tundo_pfn = pfn;\n\t\t\tgoto undo;\n\t\t}\n\t}\n\treturn 0;\nundo:\n\tfor (pfn = start_pfn;\n\t     pfn < undo_pfn;\n\t     pfn += pageblock_nr_pages) {\n\t\tstruct page *page = pfn_to_online_page(pfn);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tunset_migratetype_isolate(page, migratetype);\n\t}\n\n\treturn -EBUSY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfn_max_align_up",
          "args": [
            "end"
          ],
          "line": 7982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_max_align_down",
          "args": [
            "start"
          ],
          "line": 7981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cc.migratepages"
          ],
          "line": 7955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_gfp_context",
          "args": [
            "gfp_mask"
          ],
          "line": 7953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "pfn_to_page(start)"
          ],
          "line": 7949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "start"
          ],
          "line": 7949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "putback_movable_pages",
          "args": [
            "&cc->migratepages"
          ],
          "line": 7912
        },
        "resolved": true,
        "details": {
          "function_name": "putback_movable_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "167-198",
          "snippet": "void putback_movable_pages(struct list_head *l)\n{\n\tstruct page *page;\n\tstruct page *page2;\n\n\tlist_for_each_entry_safe(page, page2, l, lru) {\n\t\tif (unlikely(PageHuge(page))) {\n\t\t\tputback_active_hugepage(page);\n\t\t\tcontinue;\n\t\t}\n\t\tlist_del(&page->lru);\n\t\t/*\n\t\t * We isolated non-lru movable page so here we can use\n\t\t * __PageMovable because LRU page's mapping cannot have\n\t\t * PAGE_MAPPING_MOVABLE.\n\t\t */\n\t\tif (unlikely(__PageMovable(page))) {\n\t\t\tVM_BUG_ON_PAGE(!PageIsolated(page), page);\n\t\t\tlock_page(page);\n\t\t\tif (PageMovable(page))\n\t\t\t\tputback_movable_page(page);\n\t\t\telse\n\t\t\t\t__ClearPageIsolated(page);\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t} else {\n\t\t\tmod_node_page_state(page_pgdat(page), NR_ISOLATED_ANON +\n\t\t\t\t\tpage_is_file_cache(page), -hpage_nr_pages(page));\n\t\t\tputback_lru_page(page);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nvoid putback_movable_pages(struct list_head *l)\n{\n\tstruct page *page;\n\tstruct page *page2;\n\n\tlist_for_each_entry_safe(page, page2, l, lru) {\n\t\tif (unlikely(PageHuge(page))) {\n\t\t\tputback_active_hugepage(page);\n\t\t\tcontinue;\n\t\t}\n\t\tlist_del(&page->lru);\n\t\t/*\n\t\t * We isolated non-lru movable page so here we can use\n\t\t * __PageMovable because LRU page's mapping cannot have\n\t\t * PAGE_MAPPING_MOVABLE.\n\t\t */\n\t\tif (unlikely(__PageMovable(page))) {\n\t\t\tVM_BUG_ON_PAGE(!PageIsolated(page), page);\n\t\t\tlock_page(page);\n\t\t\tif (PageMovable(page))\n\t\t\t\tputback_movable_page(page);\n\t\t\telse\n\t\t\t\t__ClearPageIsolated(page);\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t} else {\n\t\t\tmod_node_page_state(page_pgdat(page), NR_ISOLATED_ANON +\n\t\t\t\t\tpage_is_file_cache(page), -hpage_nr_pages(page));\n\t\t\tputback_lru_page(page);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "migrate_pages",
          "args": [
            "&cc->migratepages",
            "alloc_migrate_target",
            "NULL",
            "0",
            "cc->mode",
            "MR_CONTIG_RANGE"
          ],
          "line": 7908
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "1362-1449",
          "snippet": "int migrate_pages(struct list_head *from, new_page_t get_new_page,\n\t\tfree_page_t put_new_page, unsigned long private,\n\t\tenum migrate_mode mode, int reason)\n{\n\tint retry = 1;\n\tint nr_failed = 0;\n\tint nr_succeeded = 0;\n\tint pass = 0;\n\tstruct page *page;\n\tstruct page *page2;\n\tint swapwrite = current->flags & PF_SWAPWRITE;\n\tint rc;\n\n\tif (!swapwrite)\n\t\tcurrent->flags |= PF_SWAPWRITE;\n\n\tfor(pass = 0; pass < 10 && retry; pass++) {\n\t\tretry = 0;\n\n\t\tlist_for_each_entry_safe(page, page2, from, lru) {\nretry:\n\t\t\tcond_resched();\n\n\t\t\tif (PageHuge(page))\n\t\t\t\trc = unmap_and_move_huge_page(get_new_page,\n\t\t\t\t\t\tput_new_page, private, page,\n\t\t\t\t\t\tpass > 2, mode, reason);\n\t\t\telse\n\t\t\t\trc = unmap_and_move(get_new_page, put_new_page,\n\t\t\t\t\t\tprivate, page, pass > 2, mode,\n\t\t\t\t\t\treason);\n\n\t\t\tswitch(rc) {\n\t\t\tcase -ENOMEM:\n\t\t\t\t/*\n\t\t\t\t * THP migration might be unsupported or the\n\t\t\t\t * allocation could've failed so we should\n\t\t\t\t * retry on the same page with the THP split\n\t\t\t\t * to base pages.\n\t\t\t\t *\n\t\t\t\t * Head page is retried immediately and tail\n\t\t\t\t * pages are added to the tail of the list so\n\t\t\t\t * we encounter them after the rest of the list\n\t\t\t\t * is processed.\n\t\t\t\t */\n\t\t\t\tif (PageTransHuge(page) && !PageHuge(page)) {\n\t\t\t\t\tlock_page(page);\n\t\t\t\t\trc = split_huge_page_to_list(page, from);\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tif (!rc) {\n\t\t\t\t\t\tlist_safe_reset_next(page, page2, lru);\n\t\t\t\t\t\tgoto retry;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnr_failed++;\n\t\t\t\tgoto out;\n\t\t\tcase -EAGAIN:\n\t\t\t\tretry++;\n\t\t\t\tbreak;\n\t\t\tcase MIGRATEPAGE_SUCCESS:\n\t\t\t\tnr_succeeded++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/*\n\t\t\t\t * Permanent failure (-EBUSY, -ENOSYS, etc.):\n\t\t\t\t * unlike -EAGAIN case, the failed page is\n\t\t\t\t * removed from migration page list and not\n\t\t\t\t * retried in the next outer loop.\n\t\t\t\t */\n\t\t\t\tnr_failed++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tnr_failed += retry;\n\trc = nr_failed;\nout:\n\tif (nr_succeeded)\n\t\tcount_vm_events(PGMIGRATE_SUCCESS, nr_succeeded);\n\tif (nr_failed)\n\t\tcount_vm_events(PGMIGRATE_FAIL, nr_failed);\n\ttrace_mm_migrate_pages(nr_succeeded, nr_failed, mode, reason);\n\n\tif (!swapwrite)\n\t\tcurrent->flags &= ~PF_SWAPWRITE;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nint migrate_pages(struct list_head *from, new_page_t get_new_page,\n\t\tfree_page_t put_new_page, unsigned long private,\n\t\tenum migrate_mode mode, int reason)\n{\n\tint retry = 1;\n\tint nr_failed = 0;\n\tint nr_succeeded = 0;\n\tint pass = 0;\n\tstruct page *page;\n\tstruct page *page2;\n\tint swapwrite = current->flags & PF_SWAPWRITE;\n\tint rc;\n\n\tif (!swapwrite)\n\t\tcurrent->flags |= PF_SWAPWRITE;\n\n\tfor(pass = 0; pass < 10 && retry; pass++) {\n\t\tretry = 0;\n\n\t\tlist_for_each_entry_safe(page, page2, from, lru) {\nretry:\n\t\t\tcond_resched();\n\n\t\t\tif (PageHuge(page))\n\t\t\t\trc = unmap_and_move_huge_page(get_new_page,\n\t\t\t\t\t\tput_new_page, private, page,\n\t\t\t\t\t\tpass > 2, mode, reason);\n\t\t\telse\n\t\t\t\trc = unmap_and_move(get_new_page, put_new_page,\n\t\t\t\t\t\tprivate, page, pass > 2, mode,\n\t\t\t\t\t\treason);\n\n\t\t\tswitch(rc) {\n\t\t\tcase -ENOMEM:\n\t\t\t\t/*\n\t\t\t\t * THP migration might be unsupported or the\n\t\t\t\t * allocation could've failed so we should\n\t\t\t\t * retry on the same page with the THP split\n\t\t\t\t * to base pages.\n\t\t\t\t *\n\t\t\t\t * Head page is retried immediately and tail\n\t\t\t\t * pages are added to the tail of the list so\n\t\t\t\t * we encounter them after the rest of the list\n\t\t\t\t * is processed.\n\t\t\t\t */\n\t\t\t\tif (PageTransHuge(page) && !PageHuge(page)) {\n\t\t\t\t\tlock_page(page);\n\t\t\t\t\trc = split_huge_page_to_list(page, from);\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tif (!rc) {\n\t\t\t\t\t\tlist_safe_reset_next(page, page2, lru);\n\t\t\t\t\t\tgoto retry;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnr_failed++;\n\t\t\t\tgoto out;\n\t\t\tcase -EAGAIN:\n\t\t\t\tretry++;\n\t\t\t\tbreak;\n\t\t\tcase MIGRATEPAGE_SUCCESS:\n\t\t\t\tnr_succeeded++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/*\n\t\t\t\t * Permanent failure (-EBUSY, -ENOSYS, etc.):\n\t\t\t\t * unlike -EAGAIN case, the failed page is\n\t\t\t\t * removed from migration page list and not\n\t\t\t\t * retried in the next outer loop.\n\t\t\t\t */\n\t\t\t\tnr_failed++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tnr_failed += retry;\n\trc = nr_failed;\nout:\n\tif (nr_succeeded)\n\t\tcount_vm_events(PGMIGRATE_SUCCESS, nr_succeeded);\n\tif (nr_failed)\n\t\tcount_vm_events(PGMIGRATE_FAIL, nr_failed);\n\ttrace_mm_migrate_pages(nr_succeeded, nr_failed, mode, reason);\n\n\tif (!swapwrite)\n\t\tcurrent->flags &= ~PF_SWAPWRITE;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reclaim_clean_pages_from_list",
          "args": [
            "cc->zone",
            "&cc->migratepages"
          ],
          "line": 7904
        },
        "resolved": true,
        "details": {
          "function_name": "reclaim_clean_pages_from_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "1519-1544",
          "snippet": "unsigned long reclaim_clean_pages_from_list(struct zone *zone,\n\t\t\t\t\t    struct list_head *page_list)\n{\n\tstruct scan_control sc = {\n\t\t.gfp_mask = GFP_KERNEL,\n\t\t.priority = DEF_PRIORITY,\n\t\t.may_unmap = 1,\n\t};\n\tunsigned long ret;\n\tstruct page *page, *next;\n\tLIST_HEAD(clean_pages);\n\n\tlist_for_each_entry_safe(page, next, page_list, lru) {\n\t\tif (page_is_file_cache(page) && !PageDirty(page) &&\n\t\t    !__PageMovable(page)) {\n\t\t\tClearPageActive(page);\n\t\t\tlist_move(&page->lru, &clean_pages);\n\t\t}\n\t}\n\n\tret = shrink_page_list(&clean_pages, zone->zone_pgdat, &sc,\n\t\t\tTTU_IGNORE_ACCESS, NULL, true);\n\tlist_splice(&clean_pages, page_list);\n\tmod_node_page_state(zone->zone_pgdat, NR_ISOLATED_FILE, -ret);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nunsigned long reclaim_clean_pages_from_list(struct zone *zone,\n\t\t\t\t\t    struct list_head *page_list)\n{\n\tstruct scan_control sc = {\n\t\t.gfp_mask = GFP_KERNEL,\n\t\t.priority = DEF_PRIORITY,\n\t\t.may_unmap = 1,\n\t};\n\tunsigned long ret;\n\tstruct page *page, *next;\n\tLIST_HEAD(clean_pages);\n\n\tlist_for_each_entry_safe(page, next, page_list, lru) {\n\t\tif (page_is_file_cache(page) && !PageDirty(page) &&\n\t\t    !__PageMovable(page)) {\n\t\t\tClearPageActive(page);\n\t\t\tlist_move(&page->lru, &clean_pages);\n\t\t}\n\t}\n\n\tret = shrink_page_list(&clean_pages, zone->zone_pgdat, &sc,\n\t\t\tTTU_IGNORE_ACCESS, NULL, true);\n\tlist_splice(&clean_pages, page_list);\n\tmod_node_page_state(zone->zone_pgdat, NR_ISOLATED_FILE, -ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isolate_migratepages_range",
          "args": [
            "cc",
            "pfn",
            "end"
          ],
          "line": 7893
        },
        "resolved": true,
        "details": {
          "function_name": "isolate_migratepages_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "972-1006",
          "snippet": "unsigned long\nisolate_migratepages_range(struct compact_control *cc, unsigned long start_pfn,\n\t\t\t\t\t\t\tunsigned long end_pfn)\n{\n\tunsigned long pfn, block_start_pfn, block_end_pfn;\n\n\t/* Scan block by block. First and last block may be incomplete */\n\tpfn = start_pfn;\n\tblock_start_pfn = pageblock_start_pfn(pfn);\n\tif (block_start_pfn < cc->zone->zone_start_pfn)\n\t\tblock_start_pfn = cc->zone->zone_start_pfn;\n\tblock_end_pfn = pageblock_end_pfn(pfn);\n\n\tfor (; pfn < end_pfn; pfn = block_end_pfn,\n\t\t\t\tblock_start_pfn = block_end_pfn,\n\t\t\t\tblock_end_pfn += pageblock_nr_pages) {\n\n\t\tblock_end_pfn = min(block_end_pfn, end_pfn);\n\n\t\tif (!pageblock_pfn_to_page(block_start_pfn,\n\t\t\t\t\tblock_end_pfn, cc->zone))\n\t\t\tcontinue;\n\n\t\tpfn = isolate_migratepages_block(cc, pfn, block_end_pfn,\n\t\t\t\t\t\t\tISOLATE_UNEVICTABLE);\n\n\t\tif (!pfn)\n\t\t\tbreak;\n\n\t\tif (cc->nr_migratepages == COMPACT_CLUSTER_MAX)\n\t\t\tbreak;\n\t}\n\n\treturn pfn;\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nunsigned long\nisolate_migratepages_range(struct compact_control *cc, unsigned long start_pfn,\n\t\t\t\t\t\t\tunsigned long end_pfn)\n{\n\tunsigned long pfn, block_start_pfn, block_end_pfn;\n\n\t/* Scan block by block. First and last block may be incomplete */\n\tpfn = start_pfn;\n\tblock_start_pfn = pageblock_start_pfn(pfn);\n\tif (block_start_pfn < cc->zone->zone_start_pfn)\n\t\tblock_start_pfn = cc->zone->zone_start_pfn;\n\tblock_end_pfn = pageblock_end_pfn(pfn);\n\n\tfor (; pfn < end_pfn; pfn = block_end_pfn,\n\t\t\t\tblock_start_pfn = block_end_pfn,\n\t\t\t\tblock_end_pfn += pageblock_nr_pages) {\n\n\t\tblock_end_pfn = min(block_end_pfn, end_pfn);\n\n\t\tif (!pageblock_pfn_to_page(block_start_pfn,\n\t\t\t\t\tblock_end_pfn, cc->zone))\n\t\t\tcontinue;\n\n\t\tpfn = isolate_migratepages_block(cc, pfn, block_end_pfn,\n\t\t\t\t\t\t\tISOLATE_UNEVICTABLE);\n\n\t\tif (!pfn)\n\t\t\tbreak;\n\n\t\tif (cc->nr_migratepages == COMPACT_CLUSTER_MAX)\n\t\t\tbreak;\n\t}\n\n\treturn pfn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&cc->migratepages"
          ],
          "line": 7891
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal_signal_pending",
          "args": [
            "current"
          ],
          "line": 7886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migrate_prep",
          "args": [],
          "line": 7883
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_prep_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/migrate.c",
          "lines": "77-82",
          "snippet": "int migrate_prep_local(void)\n{\n\tlru_add_drain();\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/migrate.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/page_idle.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/memremap.h>",
            "#include <linux/pfn_t.h>",
            "#include <linux/gfp.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/compaction.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/writeback.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/migrate.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/migrate.h>\n#include <asm/tlbflush.h>\n#include <linux/ptrace.h>\n#include <linux/sched/mm.h>\n#include <linux/page_owner.h>\n#include <linux/page_idle.h>\n#include <linux/mmu_notifier.h>\n#include <linux/balloon_compaction.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/memremap.h>\n#include <linux/pfn_t.h>\n#include <linux/gfp.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/compaction.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/mempolicy.h>\n#include <linux/writeback.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/pagevec.h>\n#include <linux/nsproxy.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n\nint migrate_prep_local(void)\n{\n\tlru_add_drain();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "pfn",
            "max_t(unsigned long, MAX_ORDER_NR_PAGES,\n\t\t\t\tpageblock_nr_pages)"
          ],
          "line": 7869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "unsignedlong",
            "MAX_ORDER_NR_PAGES",
            "pageblock_nr_pages"
          ],
          "line": 7869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "zone_idx(zone) == ZONE_MOVABLE"
          ],
          "line": 7855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_idx",
          "args": [
            "zone"
          ],
          "line": 7855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "page"
          ],
          "line": 7835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__PageMovable",
          "args": [
            "page"
          ],
          "line": 7832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHWPoison",
          "args": [
            "page"
          ],
          "line": 7829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageBuddy",
          "args": [
            "page"
          ],
          "line": 7820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_ref_count",
          "args": [
            "page"
          ],
          "line": 7819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "iter + 1",
            "1<<compound_order(page)"
          ],
          "line": 7809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_order",
          "args": [
            "page"
          ],
          "line": 7809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugepage_migration_supported",
          "args": [
            "page_hstate(page)"
          ],
          "line": 7806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_hstate",
          "args": [
            "page"
          ],
          "line": 7806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHuge",
          "args": [
            "page"
          ],
          "line": 7804
        },
        "resolved": true,
        "details": {
          "function_name": "PageHugeObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/zsmalloc.c",
          "lines": "225-228",
          "snippet": "static int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mount.h>",
            "#include <linux/zpool.h>",
            "#include <linux/zsmalloc.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/types.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cpu.h>",
            "#include <linux/cpumask.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/highmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/bitops.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/migrate.h>\n#include <linux/mount.h>\n#include <linux/zpool.h>\n#include <linux/zsmalloc.h>\n#include <linux/debugfs.h>\n#include <linux/types.h>\n#include <linux/shrinker.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/vmalloc.h>\n#include <linux/cpu.h>\n#include <linux/cpumask.h>\n#include <asm/pgtable.h>\n#include <asm/tlbflush.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/highmem.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/magic.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int PageHugeObject(struct page *page)\n{\n\treturn PageOwnerPriv1(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "zone_idx",
          "args": [
            "zone"
          ],
          "line": 7796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageReserved",
          "args": [
            "page"
          ],
          "line": 7788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "check"
          ],
          "line": 7786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_valid_within",
          "args": [
            "check"
          ],
          "line": 7783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "page"
          ],
          "line": 7779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_migrate_cma",
          "args": [
            "get_pageblock_migratetype(page)"
          ],
          "line": 7776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_pageblock_migratetype",
          "args": [
            "page"
          ],
          "line": 7776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_migrate_cma",
          "args": [
            "migratetype"
          ],
          "line": 7775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s hash table entries: %ld (order: %d, %lu bytes)\\n\"",
            "tablename",
            "1UL << log2qty",
            "ilog2(size) - PAGE_SHIFT",
            "size"
          ],
          "line": 7736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "size"
          ],
          "line": 7737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"Failed to allocate %s hash table\\n\"",
            "tablename"
          ],
          "line": 7734
        },
        "resolved": true,
        "details": {
          "function_name": "check_panic_on_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
          "lines": "1008-1028",
          "snippet": "static void check_panic_on_oom(struct oom_control *oc,\n\t\t\t       enum oom_constraint constraint)\n{\n\tif (likely(!sysctl_panic_on_oom))\n\t\treturn;\n\tif (sysctl_panic_on_oom != 2) {\n\t\t/*\n\t\t * panic_on_oom == 1 only affects CONSTRAINT_NONE, the kernel\n\t\t * does not panic for cpuset, mempolicy, or memcg allocation\n\t\t * failures.\n\t\t */\n\t\tif (constraint != CONSTRAINT_NONE)\n\t\t\treturn;\n\t}\n\t/* Do not panic for oom kills triggered by sysrq */\n\tif (is_sysrq_oom(oc))\n\t\treturn;\n\tdump_header(oc, NULL);\n\tpanic(\"Out of memory: %s panic_on_oom is enabled\\n\",\n\t\tsysctl_panic_on_oom == 2 ? \"compulsory\" : \"system-wide\");\n}",
          "includes": [
            "#include <trace/events/oom.h>",
            "#include \"slab.h\"",
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/timex.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/oom.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int sysctl_panic_on_oom;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nint sysctl_panic_on_oom;\n\nstatic void check_panic_on_oom(struct oom_control *oc,\n\t\t\t       enum oom_constraint constraint)\n{\n\tif (likely(!sysctl_panic_on_oom))\n\t\treturn;\n\tif (sysctl_panic_on_oom != 2) {\n\t\t/*\n\t\t * panic_on_oom == 1 only affects CONSTRAINT_NONE, the kernel\n\t\t * does not panic for cpuset, mempolicy, or memcg allocation\n\t\t * failures.\n\t\t */\n\t\tif (constraint != CONSTRAINT_NONE)\n\t\t\treturn;\n\t}\n\t/* Do not panic for oom kills triggered by sysrq */\n\tif (is_sysrq_oom(oc))\n\t\treturn;\n\tdump_header(oc, NULL);\n\tpanic(\"Out of memory: %s panic_on_oom is enabled\\n\",\n\t\tsysctl_panic_on_oom == 2 ? \"compulsory\" : \"system-wide\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmemleak_alloc",
          "args": [
            "table",
            "size",
            "1",
            "gfp_flags"
          ],
          "line": 7728
        },
        "resolved": true,
        "details": {
          "function_name": "kmemleak_alloc_phys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1220-1225",
          "snippet": "void __ref kmemleak_alloc_phys(phys_addr_t phys, size_t size, int min_count,\n\t\t\t       gfp_t gfp)\n{\n\tif (!IS_ENABLED(CONFIG_HIGHMEM) || PHYS_PFN(phys) < max_low_pfn)\n\t\tkmemleak_alloc(__va(phys), size, min_count, gfp);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nvoid __ref kmemleak_alloc_phys(phys_addr_t phys, size_t size, int min_count,\n\t\t\t       gfp_t gfp)\n{\n\tif (!IS_ENABLED(CONFIG_HIGHMEM) || PHYS_PFN(phys) < max_low_pfn)\n\t\tkmemleak_alloc(__va(phys), size, min_count, gfp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_pages_exact",
          "args": [
            "size",
            "gfp_flags"
          ],
          "line": 7727
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_pages_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4594-4601",
          "snippet": "void *alloc_pages_exact(size_t size, gfp_t gfp_mask)\n{\n\tunsigned int order = get_order(size);\n\tunsigned long addr;\n\n\taddr = __get_free_pages(gfp_mask, order);\n\treturn make_alloc_exact(addr, order, size);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\n\nvoid *alloc_pages_exact(size_t size, gfp_t gfp_mask)\n{\n\tunsigned int order = get_order(size);\n\tunsigned long addr;\n\n\taddr = __get_free_pages(gfp_mask, order);\n\treturn make_alloc_exact(addr, order, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "size"
          ],
          "line": 7726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__vmalloc",
          "args": [
            "size",
            "gfp_flags",
            "PAGE_KERNEL"
          ],
          "line": 7719
        },
        "resolved": true,
        "details": {
          "function_name": "__vmalloc_node_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "240-243",
          "snippet": "void *__vmalloc_node_flags(unsigned long size, int node, gfp_t flags)\n{\n\treturn __vmalloc(size, flags, PAGE_KERNEL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nvoid *__vmalloc_node_flags(unsigned long size, int node, gfp_t flags)\n{\n\treturn __vmalloc(size, flags, PAGE_KERNEL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_alloc_raw",
          "args": [
            "size",
            "SMP_CACHE_BYTES"
          ],
          "line": 7716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_alloc_nopanic",
          "args": [
            "size",
            "SMP_CACHE_BYTES"
          ],
          "line": 7713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "numentries"
          ],
          "line": 7706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "max",
            "0x80000000ULL"
          ],
          "line": 7699
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "max",
            "bucketsize"
          ],
          "line": 7697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundup_pow_of_two",
          "args": [
            "numentries"
          ],
          "line": 7692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(numentries * bucketsize) < PAGE_SIZE"
          ],
          "line": 7689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!numentries"
          ],
          "line": 7687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!(flags & HASH_EARLY)"
          ],
          "line": 7684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "flags & HASH_SMALL"
          ],
          "line": 7682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "numentries",
            "(1<<20)/PAGE_SIZE"
          ],
          "line": 7663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_reserved_kernel_pages",
          "args": [],
          "line": 7659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__setup",
          "args": [
            "\"hashdist=\"",
            "set_hashdist"
          ],
          "line": 7605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "str",
            "&str",
            "0"
          ],
          "line": 7602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&pcp_batch_high_lock"
          ],
          "line": 7591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_dointvec_minmax",
          "args": [
            "table",
            "write",
            "buffer",
            "length",
            "ppos"
          ],
          "line": 7567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&pcp_batch_high_lock"
          ],
          "line": 7564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_per_zone_lowmem_reserve",
          "args": [],
          "line": 7548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_dointvec_minmax",
          "args": [
            "table",
            "write",
            "buffer",
            "length",
            "ppos"
          ],
          "line": 7547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_min_slab_ratio",
          "args": [],
          "line": 7529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_dointvec_minmax",
          "args": [
            "table",
            "write",
            "buffer",
            "length",
            "ppos"
          ],
          "line": 7525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_min_unmapped_ratio",
          "args": [],
          "line": 7502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_dointvec_minmax",
          "args": [
            "table",
            "write",
            "buffer",
            "length",
            "ppos"
          ],
          "line": 7498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_per_zone_wmarks",
          "args": [],
          "line": 7473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_dointvec_minmax",
          "args": [
            "table",
            "write",
            "buffer",
            "length",
            "ppos"
          ],
          "line": 7468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_per_zone_wmarks",
          "args": [],
          "line": 7458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_dointvec_minmax",
          "args": [
            "table",
            "write",
            "buffer",
            "length",
            "ppos"
          ],
          "line": 7452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_min_slab_ratio",
          "args": [],
          "line": 7435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_min_unmapped_ratio",
          "args": [],
          "line": 7434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_per_zone_lowmem_reserve",
          "args": [],
          "line": 7431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refresh_zone_stat_thresholds",
          "args": [],
          "line": 7430
        },
        "resolved": true,
        "details": {
          "function_name": "refresh_zone_stat_thresholds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "245-288",
          "snippet": "void refresh_zone_stat_thresholds(void)\n{\n\tstruct pglist_data *pgdat;\n\tstruct zone *zone;\n\tint cpu;\n\tint threshold;\n\n\t/* Zero current pgdat thresholds */\n\tfor_each_online_pgdat(pgdat) {\n\t\tfor_each_online_cpu(cpu) {\n\t\t\tper_cpu_ptr(pgdat->per_cpu_nodestats, cpu)->stat_threshold = 0;\n\t\t}\n\t}\n\n\tfor_each_populated_zone(zone) {\n\t\tstruct pglist_data *pgdat = zone->zone_pgdat;\n\t\tunsigned long max_drift, tolerate_drift;\n\n\t\tthreshold = calculate_normal_threshold(zone);\n\n\t\tfor_each_online_cpu(cpu) {\n\t\t\tint pgdat_threshold;\n\n\t\t\tper_cpu_ptr(zone->pageset, cpu)->stat_threshold\n\t\t\t\t\t\t\t= threshold;\n\n\t\t\t/* Base nodestat threshold on the largest populated zone. */\n\t\t\tpgdat_threshold = per_cpu_ptr(pgdat->per_cpu_nodestats, cpu)->stat_threshold;\n\t\t\tper_cpu_ptr(pgdat->per_cpu_nodestats, cpu)->stat_threshold\n\t\t\t\t= max(threshold, pgdat_threshold);\n\t\t}\n\n\t\t/*\n\t\t * Only set percpu_drift_mark if there is a danger that\n\t\t * NR_FREE_PAGES reports the low watermark is ok when in fact\n\t\t * the min watermark could be breached by an allocation\n\t\t */\n\t\ttolerate_drift = low_wmark_pages(zone) - min_wmark_pages(zone);\n\t\tmax_drift = num_online_cpus() * threshold;\n\t\tif (max_drift > tolerate_drift)\n\t\t\tzone->percpu_drift_mark = high_wmark_pages(zone) +\n\t\t\t\t\tmax_drift;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid refresh_zone_stat_thresholds(void)\n{\n\tstruct pglist_data *pgdat;\n\tstruct zone *zone;\n\tint cpu;\n\tint threshold;\n\n\t/* Zero current pgdat thresholds */\n\tfor_each_online_pgdat(pgdat) {\n\t\tfor_each_online_cpu(cpu) {\n\t\t\tper_cpu_ptr(pgdat->per_cpu_nodestats, cpu)->stat_threshold = 0;\n\t\t}\n\t}\n\n\tfor_each_populated_zone(zone) {\n\t\tstruct pglist_data *pgdat = zone->zone_pgdat;\n\t\tunsigned long max_drift, tolerate_drift;\n\n\t\tthreshold = calculate_normal_threshold(zone);\n\n\t\tfor_each_online_cpu(cpu) {\n\t\t\tint pgdat_threshold;\n\n\t\t\tper_cpu_ptr(zone->pageset, cpu)->stat_threshold\n\t\t\t\t\t\t\t= threshold;\n\n\t\t\t/* Base nodestat threshold on the largest populated zone. */\n\t\t\tpgdat_threshold = per_cpu_ptr(pgdat->per_cpu_nodestats, cpu)->stat_threshold;\n\t\t\tper_cpu_ptr(pgdat->per_cpu_nodestats, cpu)->stat_threshold\n\t\t\t\t= max(threshold, pgdat_threshold);\n\t\t}\n\n\t\t/*\n\t\t * Only set percpu_drift_mark if there is a danger that\n\t\t * NR_FREE_PAGES reports the low watermark is ok when in fact\n\t\t * the min watermark could be breached by an allocation\n\t\t */\n\t\ttolerate_drift = low_wmark_pages(zone) - min_wmark_pages(zone);\n\t\tmax_drift = num_online_cpus() * threshold;\n\t\tif (max_drift > tolerate_drift)\n\t\t\tzone->percpu_drift_mark = high_wmark_pages(zone) +\n\t\t\t\t\tmax_drift;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_per_zone_wmarks",
          "args": [],
          "line": 7429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"min_free_kbytes is not updated to %d because user defined value %d is preferred\\n\"",
            "new_min_free_kbytes",
            "user_min_free_kbytes"
          ],
          "line": 7426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "int_sqrt",
          "args": [
            "lowmem_kbytes * 16"
          ],
          "line": 7417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nr_free_buffer_pages",
          "args": [],
          "line": 7416
        },
        "resolved": true,
        "details": {
          "function_name": "nr_free_buffer_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4678-4681",
          "snippet": "unsigned long nr_free_buffer_pages(void)\n{\n\treturn nr_free_zone_pages(gfp_zone(GFP_USER));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nunsigned long nr_free_buffer_pages(void)\n{\n\treturn nr_free_zone_pages(gfp_zone(GFP_USER));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&lock"
          ],
          "line": 7384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__setup_per_zone_wmarks",
          "args": [],
          "line": 7383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&lock"
          ],
          "line": 7382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calculate_totalreserve_pages",
          "args": [],
          "line": 7368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&zone->lock",
            "flags"
          ],
          "line": 7364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_wmark_pages",
          "args": [
            "zone"
          ],
          "line": 7362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_wmark_pages",
          "args": [
            "zone"
          ],
          "line": 7361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "u64",
            "tmp >> 2",
            "mult_frac(zone->managed_pages,\n\t\t\t\t      watermark_scale_factor, 10000)"
          ],
          "line": 7357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mult_frac",
          "args": [
            "zone->managed_pages",
            "watermark_scale_factor",
            "10000"
          ],
          "line": 7358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clamp",
          "args": [
            "min_pages",
            "SWAP_CLUSTER_MAX",
            "128UL"
          ],
          "line": 7342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_highmem",
          "args": [
            "zone"
          ],
          "line": 7329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "tmp",
            "lowmem_pages"
          ],
          "line": 7328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&zone->lock",
            "flags"
          ],
          "line": 7326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_highmem",
          "args": [
            "zone"
          ],
          "line": 7319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calculate_totalreserve_pages",
          "args": [],
          "line": 7307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "high_wmark_pages",
          "args": [
            "zone"
          ],
          "line": 7256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret < 0"
          ],
          "line": 7228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_setup_state_nocalls",
          "args": [
            "CPUHP_PAGE_ALLOC_DEAD",
            "\"mm/page_alloc:dead\"",
            "NULL",
            "page_alloc_cpu_dead"
          ],
          "line": 7225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_vm_stats_fold",
          "args": [
            "cpu"
          ],
          "line": 7217
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_vm_stats_fold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "846-906",
          "snippet": "void cpu_vm_stats_fold(int cpu)\n{\n\tstruct pglist_data *pgdat;\n\tstruct zone *zone;\n\tint i;\n\tint global_zone_diff[NR_VM_ZONE_STAT_ITEMS] = { 0, };\n#ifdef CONFIG_NUMA\n\tint global_numa_diff[NR_VM_NUMA_STAT_ITEMS] = { 0, };\n#endif\n\tint global_node_diff[NR_VM_NODE_STAT_ITEMS] = { 0, };\n\n\tfor_each_populated_zone(zone) {\n\t\tstruct per_cpu_pageset *p;\n\n\t\tp = per_cpu_ptr(zone->pageset, cpu);\n\n\t\tfor (i = 0; i < NR_VM_ZONE_STAT_ITEMS; i++)\n\t\t\tif (p->vm_stat_diff[i]) {\n\t\t\t\tint v;\n\n\t\t\t\tv = p->vm_stat_diff[i];\n\t\t\t\tp->vm_stat_diff[i] = 0;\n\t\t\t\tatomic_long_add(v, &zone->vm_stat[i]);\n\t\t\t\tglobal_zone_diff[i] += v;\n\t\t\t}\n\n#ifdef CONFIG_NUMA\n\t\tfor (i = 0; i < NR_VM_NUMA_STAT_ITEMS; i++)\n\t\t\tif (p->vm_numa_stat_diff[i]) {\n\t\t\t\tint v;\n\n\t\t\t\tv = p->vm_numa_stat_diff[i];\n\t\t\t\tp->vm_numa_stat_diff[i] = 0;\n\t\t\t\tatomic_long_add(v, &zone->vm_numa_stat[i]);\n\t\t\t\tglobal_numa_diff[i] += v;\n\t\t\t}\n#endif\n\t}\n\n\tfor_each_online_pgdat(pgdat) {\n\t\tstruct per_cpu_nodestat *p;\n\n\t\tp = per_cpu_ptr(pgdat->per_cpu_nodestats, cpu);\n\n\t\tfor (i = 0; i < NR_VM_NODE_STAT_ITEMS; i++)\n\t\t\tif (p->vm_node_stat_diff[i]) {\n\t\t\t\tint v;\n\n\t\t\t\tv = p->vm_node_stat_diff[i];\n\t\t\t\tp->vm_node_stat_diff[i] = 0;\n\t\t\t\tatomic_long_add(v, &pgdat->vm_stat[i]);\n\t\t\t\tglobal_node_diff[i] += v;\n\t\t\t}\n\t}\n\n#ifdef CONFIG_NUMA\n\tfold_diff(global_zone_diff, global_numa_diff, global_node_diff);\n#else\n\tfold_diff(global_zone_diff, global_node_diff);\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "atomic_long_t vm_numa_stat[NR_VM_NUMA_STAT_ITEMS]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\natomic_long_t vm_numa_stat[NR_VM_NUMA_STAT_ITEMS];\n\nvoid cpu_vm_stats_fold(int cpu)\n{\n\tstruct pglist_data *pgdat;\n\tstruct zone *zone;\n\tint i;\n\tint global_zone_diff[NR_VM_ZONE_STAT_ITEMS] = { 0, };\n#ifdef CONFIG_NUMA\n\tint global_numa_diff[NR_VM_NUMA_STAT_ITEMS] = { 0, };\n#endif\n\tint global_node_diff[NR_VM_NODE_STAT_ITEMS] = { 0, };\n\n\tfor_each_populated_zone(zone) {\n\t\tstruct per_cpu_pageset *p;\n\n\t\tp = per_cpu_ptr(zone->pageset, cpu);\n\n\t\tfor (i = 0; i < NR_VM_ZONE_STAT_ITEMS; i++)\n\t\t\tif (p->vm_stat_diff[i]) {\n\t\t\t\tint v;\n\n\t\t\t\tv = p->vm_stat_diff[i];\n\t\t\t\tp->vm_stat_diff[i] = 0;\n\t\t\t\tatomic_long_add(v, &zone->vm_stat[i]);\n\t\t\t\tglobal_zone_diff[i] += v;\n\t\t\t}\n\n#ifdef CONFIG_NUMA\n\t\tfor (i = 0; i < NR_VM_NUMA_STAT_ITEMS; i++)\n\t\t\tif (p->vm_numa_stat_diff[i]) {\n\t\t\t\tint v;\n\n\t\t\t\tv = p->vm_numa_stat_diff[i];\n\t\t\t\tp->vm_numa_stat_diff[i] = 0;\n\t\t\t\tatomic_long_add(v, &zone->vm_numa_stat[i]);\n\t\t\t\tglobal_numa_diff[i] += v;\n\t\t\t}\n#endif\n\t}\n\n\tfor_each_online_pgdat(pgdat) {\n\t\tstruct per_cpu_nodestat *p;\n\n\t\tp = per_cpu_ptr(pgdat->per_cpu_nodestats, cpu);\n\n\t\tfor (i = 0; i < NR_VM_NODE_STAT_ITEMS; i++)\n\t\t\tif (p->vm_node_stat_diff[i]) {\n\t\t\t\tint v;\n\n\t\t\t\tv = p->vm_node_stat_diff[i];\n\t\t\t\tp->vm_node_stat_diff[i] = 0;\n\t\t\t\tatomic_long_add(v, &pgdat->vm_stat[i]);\n\t\t\t\tglobal_node_diff[i] += v;\n\t\t\t}\n\t}\n\n#ifdef CONFIG_NUMA\n\tfold_diff(global_zone_diff, global_numa_diff, global_node_diff);\n#else\n\tfold_diff(global_zone_diff, global_node_diff);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "vm_events_fold_cpu",
          "args": [
            "cpu"
          ],
          "line": 7208
        },
        "resolved": true,
        "details": {
          "function_name": "vm_events_fold_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "144-153",
          "snippet": "void vm_events_fold_cpu(int cpu)\n{\n\tstruct vm_event_state *fold_state = &per_cpu(vm_event_states, cpu);\n\tint i;\n\n\tfor (i = 0; i < NR_VM_EVENT_ITEMS; i++) {\n\t\tcount_vm_events(i, fold_state->event[i]);\n\t\tfold_state->event[i] = 0;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid vm_events_fold_cpu(int cpu)\n{\n\tstruct vm_event_state *fold_state = &per_cpu(vm_event_states, cpu);\n\tint i;\n\n\tfor (i = 0; i < NR_VM_EVENT_ITEMS; i++) {\n\t\tcount_vm_events(i, fold_state->event[i]);\n\t\tfold_state->event[i] = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "drain_pages",
          "args": [
            "cpu"
          ],
          "line": 7200
        },
        "resolved": true,
        "details": {
          "function_name": "drain_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "2568-2575",
          "snippet": "static void drain_pages(unsigned int cpu)\n{\n\tstruct zone *zone;\n\n\tfor_each_populated_zone(zone) {\n\t\tdrain_pages_zone(cpu, zone);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic void drain_pages(unsigned int cpu)\n{\n\tstruct zone *zone;\n\n\tfor_each_populated_zone(zone) {\n\t\tdrain_pages_zone(cpu, zone);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lru_add_drain_cpu",
          "args": [
            "cpu"
          ],
          "line": 7199
        },
        "resolved": true,
        "details": {
          "function_name": "lru_add_drain_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap.c",
          "lines": "576-602",
          "snippet": "void lru_add_drain_cpu(int cpu)\n{\n\tstruct pagevec *pvec = &per_cpu(lru_add_pvec, cpu);\n\n\tif (pagevec_count(pvec))\n\t\t__pagevec_lru_add(pvec);\n\n\tpvec = &per_cpu(lru_rotate_pvecs, cpu);\n\tif (pagevec_count(pvec)) {\n\t\tunsigned long flags;\n\n\t\t/* No harm done if a racing interrupt already did this */\n\t\tlocal_irq_save(flags);\n\t\tpagevec_move_tail(pvec);\n\t\tlocal_irq_restore(flags);\n\t}\n\n\tpvec = &per_cpu(lru_deactivate_file_pvecs, cpu);\n\tif (pagevec_count(pvec))\n\t\tpagevec_lru_move_fn(pvec, lru_deactivate_file_fn, NULL);\n\n\tpvec = &per_cpu(lru_lazyfree_pvecs, cpu);\n\tif (pagevec_count(pvec))\n\t\tpagevec_lru_move_fn(pvec, lru_lazyfree_fn, NULL);\n\n\tactivate_page_drain(cpu);\n}",
          "includes": [
            "#include <trace/events/pagemap.h>",
            "#include \"internal.h\"",
            "#include <linux/page_idle.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/uio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/memremap.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct pagevec, lru_add_pvec);",
            "static DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);",
            "static DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/pagemap.h>\n#include \"internal.h\"\n#include <linux/page_idle.h>\n#include <linux/hugetlb.h>\n#include <linux/uio.h>\n#include <linux/gfp.h>\n#include <linux/memcontrol.h>\n#include <linux/backing-dev.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/memremap.h>\n#include <linux/percpu_counter.h>\n#include <linux/mm_inline.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n\nstatic DEFINE_PER_CPU(struct pagevec, lru_add_pvec);\nstatic DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_deactivate_file_pvecs);\nstatic DEFINE_PER_CPU(struct pagevec, lru_lazyfree_pvecs);\n\nvoid lru_add_drain_cpu(int cpu)\n{\n\tstruct pagevec *pvec = &per_cpu(lru_add_pvec, cpu);\n\n\tif (pagevec_count(pvec))\n\t\t__pagevec_lru_add(pvec);\n\n\tpvec = &per_cpu(lru_rotate_pvecs, cpu);\n\tif (pagevec_count(pvec)) {\n\t\tunsigned long flags;\n\n\t\t/* No harm done if a racing interrupt already did this */\n\t\tlocal_irq_save(flags);\n\t\tpagevec_move_tail(pvec);\n\t\tlocal_irq_restore(flags);\n\t}\n\n\tpvec = &per_cpu(lru_deactivate_file_pvecs, cpu);\n\tif (pagevec_count(pvec))\n\t\tpagevec_lru_move_fn(pvec, lru_deactivate_file_fn, NULL);\n\n\tpvec = &per_cpu(lru_lazyfree_pvecs, cpu);\n\tif (pagevec_count(pvec))\n\t\tpagevec_lru_move_fn(pvec, lru_lazyfree_fn, NULL);\n\n\tactivate_page_drain(cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_area_init_node",
          "args": [
            "0",
            "zones_size",
            "__pa(PAGE_OFFSET) >> PAGE_SHIFT",
            "NULL"
          ],
          "line": 7192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "PAGE_OFFSET"
          ],
          "line": 7193
        },
        "resolved": true,
        "details": {
          "function_name": "__page_mapcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "536-552",
          "snippet": "int __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_resv_unavail",
          "args": [],
          "line": 7191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nr_free_pages",
          "args": [],
          "line": 7161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Memory: %luK/%luK available (%luK kernel code, %luK rwdata, %luK rodata, %luK init, %luK bss, %luK reserved, %luK cma-reserved\"\n#ifdef\tCONFIG_HIGHMEM\n\t\t\", %luK highmem\"\n#endif\n\t\t\"%s%s"
          ],
          "line": 7156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adj_init_size",
          "args": [
            "_sdata",
            "_edata",
            "datasize",
            "__start_rodata",
            "rosize"
          ],
          "line": 7152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adj_init_size",
          "args": [
            "_stext",
            "_etext",
            "codesize",
            "__start_rodata",
            "rosize"
          ],
          "line": 7151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adj_init_size",
          "args": [
            "_sdata",
            "_edata",
            "datasize",
            "__init_begin",
            "init_data_size"
          ],
          "line": 7150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adj_init_size",
          "args": [
            "_stext",
            "_etext",
            "codesize",
            "_sinittext",
            "init_code_size"
          ],
          "line": 7149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adj_init_size",
          "args": [
            "__init_begin",
            "__init_end",
            "init_data_size",
            "_sinittext",
            "init_code_size"
          ],
          "line": 7147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_num_physpages",
          "args": [],
          "line": 7126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "page"
          ],
          "line": 7115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_reserved_page",
          "args": [
            "page"
          ],
          "line": 7113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPORT_SYMBOL",
          "args": [
            "free_reserved_area"
          ],
          "line": 7108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Freeing %s memory: %ldK\\n\"",
            "s",
            "pages << (PAGE_SHIFT - 10)"
          ],
          "line": 7103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_reserved_page",
          "args": [
            "page"
          ],
          "line": 7099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "direct_map_addr",
            "poison",
            "PAGE_SIZE"
          ],
          "line": 7097
        },
        "resolved": true,
        "details": {
          "function_name": "memset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "283-288",
          "snippet": "void *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);",
            "__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\n__alias(__asan_loadN)\nvoid __asan_loadN_noabort(unsigned long, size_t);\n__alias(__asan_storeN)\nvoid __asan_storeN_noabort(unsigned long, size_t);\n\nvoid *memset(void *addr, int c, size_t len)\n{\n\tcheck_memory_region((unsigned long)addr, len, true, _RET_IP_);\n\n\treturn __memset(addr, c, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 7095
        },
        "resolved": true,
        "details": {
          "function_name": "page_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
          "lines": "409-434",
          "snippet": "void *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/tlbflush.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nvoid *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "pos"
          ],
          "line": 7085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "(unsigned long)start"
          ],
          "line": 7082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPORT_SYMBOL",
          "args": [
            "adjust_managed_page_count"
          ],
          "line": 7075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&managed_page_count_lock"
          ],
          "line": 7073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHighMem",
          "args": [
            "page"
          ],
          "line": 7070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "page"
          ],
          "line": 7067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&managed_page_count_lock"
          ],
          "line": 7066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "early_param",
          "args": [
            "\"movablecore\"",
            "cmdline_parse_movablecore"
          ],
          "line": 7060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "early_param",
          "args": [
            "\"kernelcore\"",
            "cmdline_parse_kernelcore"
          ],
          "line": 7059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmdline_parse_core",
          "args": [
            "p",
            "&required_movablecore",
            "&required_movablecore_percent"
          ],
          "line": 7055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmdline_parse_core",
          "args": [
            "p",
            "&required_kernelcore",
            "&required_kernelcore_percent"
          ],
          "line": 7045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_option_str",
          "args": [
            "p",
            "\"mirror\""
          ],
          "line": 7040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "(coremem >> PAGE_SHIFT) > ULONG_MAX"
          ],
          "line": 7025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memparse",
          "args": [
            "p",
            "&p"
          ],
          "line": 7023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "coremem > 100"
          ],
          "line": 7019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_strtoull",
          "args": [
            "p",
            "&endptr",
            "0"
          ],
          "line": 7016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_for_memory",
          "args": [
            "pgdat",
            "nid"
          ],
          "line": 7002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_set_state",
          "args": [
            "nid",
            "N_MEMORY"
          ],
          "line": 7001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_area_init_node",
          "args": [
            "nid",
            "NULL",
            "find_min_pfn_for_node(nid)",
            "NULL"
          ],
          "line": 6996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_min_pfn_for_node",
          "args": [
            "nid"
          ],
          "line": 6997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "nid"
          ],
          "line": 6995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_resv_unavail",
          "args": [],
          "line": 6993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_nr_node_ids",
          "args": [],
          "line": 6992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mminit_verify_pageflags_layout",
          "args": [],
          "line": 6991
        },
        "resolved": true,
        "details": {
          "function_name": "mminit_verify_pageflags_layout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "422-424",
          "snippet": "static inline void mminit_verify_pageflags_layout(void)\n{\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void mminit_verify_pageflags_layout(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"  node %3d: [mem %#018Lx-%#018Lx]\\n\"",
            "nid",
            "(u64)start_pfn << PAGE_SHIFT",
            "((u64)end_pfn << PAGE_SHIFT) - 1"
          ],
          "line": 6986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_mem_pfn_range",
          "args": [
            "i",
            "MAX_NUMNODES",
            "&start_pfn",
            "&end_pfn",
            "&nid"
          ],
          "line": 6985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Early memory node ranges\\n\""
          ],
          "line": 6984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"  Node %d: %#018Lx\\n\"",
            "i",
            "(u64)zone_movable_pfn[i] << PAGE_SHIFT"
          ],
          "line": 6979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Movable zone start for each node\\n\""
          ],
          "line": 6976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"[mem %#018Lx-%#018Lx]\\n\"",
            "(u64)arch_zone_lowest_possible_pfn[i]\n\t\t\t\t\t<< PAGE_SHIFT",
            "((u64)arch_zone_highest_possible_pfn[i]\n\t\t\t\t\t<< PAGE_SHIFT) - 1"
          ],
          "line": 6968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"empty\\n\""
          ],
          "line": 6966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"  %-8s \"",
            "zone_names[i]"
          ],
          "line": 6963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Zone ranges:\\n\""
          ],
          "line": 6959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_zone_movable_pfns_for_nodes",
          "args": [],
          "line": 6956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "max_zone_pfn[i]",
            "start_pfn"
          ],
          "line": 6947
        },
        "resolved": true,
        "details": {
          "function_name": "wb_max_pause",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1418-1435",
          "snippet": "static unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_PAUSE\t\tmax(HZ/5, 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define MAX_PAUSE\t\tmax(HZ/5, 1)\n\nstatic unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_min_pfn_with_active_regions",
          "args": [],
          "line": 6941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_set_state",
          "args": [
            "nid",
            "N_NORMAL_MEMORY"
          ],
          "line": 6911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_set_state",
          "args": [
            "nid",
            "N_HIGH_MEMORY"
          ],
          "line": 6909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_HIGHMEM"
          ],
          "line": 6908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "populated_zone",
          "args": [
            "zone"
          ],
          "line": 6907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "zone_movable_pfn[nid]",
            "MAX_ORDER_NR_PAGES"
          ],
          "line": 6893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_mem_pfn_range",
          "args": [
            "i",
            "nid",
            "&start_pfn",
            "&end_pfn",
            "NULL"
          ],
          "line": 6823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_node_state",
          "args": [
            "nid",
            "N_MEMORY"
          ],
          "line": 6804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "required_movablecore",
            "MAX_ORDER_NR_PAGES"
          ],
          "line": 6784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"This configuration results in unmirrored kernel memory.\""
          ],
          "line": 6752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_region_memory_base_pfn",
          "args": [
            "r"
          ],
          "line": 6739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_is_mirror",
          "args": [
            "r"
          ],
          "line": 6734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_memblock",
          "args": [
            "memory",
            "r"
          ],
          "line": 6733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_DOWN",
          "args": [
            "r->base"
          ],
          "line": 6718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_is_hotpluggable",
          "args": [
            "r"
          ],
          "line": 6713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_memblock",
          "args": [
            "memory",
            "r"
          ],
          "line": 6712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "movable_node_is_enabled",
          "args": [],
          "line": 6711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_usable_zone_for_movable",
          "args": [],
          "line": 6705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes_weight",
          "args": [
            "node_states[N_MEMORY]"
          ],
          "line": 6701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "early_calculate_totalpages",
          "args": [],
          "line": 6700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_set_state",
          "args": [
            "nid",
            "N_MEMORY"
          ],
          "line": 6682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_mem_pfn_range",
          "args": [
            "i",
            "MAX_NUMNODES",
            "&start_pfn",
            "&end_pfn",
            "&nid"
          ],
          "line": 6677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_min_pfn_for_node",
          "args": [
            "MAX_NUMNODES"
          ],
          "line": 6663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Could not find start_pfn for node %d\\n\"",
            "nid"
          ],
          "line": 6648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_mem_pfn_range",
          "args": [
            "i",
            "nid",
            "&start_pfn",
            "NULL",
            "NULL"
          ],
          "line": 6644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ffs",
          "args": [
            "start"
          ],
          "line": 6625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_mem_pfn_range",
          "args": [
            "i",
            "MAX_NUMNODES",
            "&start",
            "&end",
            "&nid"
          ],
          "line": 6613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_last_bit",
          "args": [
            "node_possible_map.bits",
            "MAX_NUMNODES"
          ],
          "line": 6582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Zeroed struct page in unavailable ranges: %lld pages\"",
            "pgcnt"
          ],
          "line": 6568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_pfn_range",
          "args": [
            "PFN_DOWN(next)",
            "max_pfn"
          ],
          "line": 6561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_DOWN",
          "args": [
            "next"
          ],
          "line": 6561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_pfn_range",
          "args": [
            "PFN_DOWN(next)",
            "PFN_UP(start)"
          ],
          "line": 6558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_UP",
          "args": [
            "start"
          ],
          "line": 6558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_DOWN",
          "args": [
            "next"
          ],
          "line": 6558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_mem_range",
          "args": [
            "i",
            "&memblock.memory",
            "NULL",
            "NUMA_NO_NODE",
            "MEMBLOCK_NONE",
            "&start",
            "&end",
            "NULL"
          ],
          "line": 6555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_zero_struct_page",
          "args": [
            "pfn_to_page(pfn)"
          ],
          "line": 6526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 6526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN_DOWN",
          "args": [
            "pfn",
            "pageblock_nr_pages"
          ],
          "line": 6522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_valid",
          "args": [
            "ALIGN_DOWN(pfn, pageblock_nr_pages)"
          ],
          "line": 6521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN_DOWN",
          "args": [
            "pfn",
            "pageblock_nr_pages"
          ],
          "line": 6521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_area_init_core",
          "args": [
            "pgdat"
          ],
          "line": 6507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgdat_set_deferred_range",
          "args": [
            "pgdat"
          ],
          "line": 6505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_node_mem_map",
          "args": [
            "pgdat"
          ],
          "line": 6504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calculate_node_totalpages",
          "args": [
            "pgdat",
            "start_pfn",
            "end_pfn",
            "zones_size",
            "zholes_size"
          ],
          "line": 6501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Initmem setup node %d [mem %#018Lx-%#018Lx]\\n\"",
            "nid",
            "(u64)start_pfn << PAGE_SHIFT",
            "end_pfn ? ((u64)end_pfn << PAGE_SHIFT) - 1 : 0"
          ],
          "line": 6495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_pfn_range_for_nid",
          "args": [
            "nid",
            "&start_pfn",
            "&end_pfn"
          ],
          "line": 6494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "pgdat->nr_zones || pgdat->kswapd_classzone_idx"
          ],
          "line": 6488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "nid"
          ],
          "line": 6483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedlong",
            "PAGES_PER_SECTION",
            "pgdat->node_spanned_pages"
          ],
          "line": 6471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "mem_map"
          ],
          "line": 6454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "0"
          ],
          "line": 6452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "0"
          ],
          "line": 6451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s: node %d, pgdat %08lx, node_mem_map %08lx\\n\"",
            "__func__",
            "pgdat->node_id",
            "(unsigned long)pgdat",
            "(unsigned long)pgdat->node_mem_map"
          ],
          "line": 6444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_alloc_node_nopanic",
          "args": [
            "size",
            "pgdat->node_id"
          ],
          "line": 6441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "end",
            "MAX_ORDER_NR_PAGES"
          ],
          "line": 6439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgdat_end_pfn",
          "args": [
            "pgdat"
          ],
          "line": 6438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmap_init",
          "args": [
            "size",
            "nid",
            "j",
            "zone_start_pfn"
          ],
          "line": 6412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_currently_empty_zone",
          "args": [
            "zone",
            "zone_start_pfn",
            "size"
          ],
          "line": 6411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_usemap",
          "args": [
            "pgdat",
            "zone",
            "zone_start_pfn",
            "size"
          ],
          "line": 6410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pageblock_order",
          "args": [],
          "line": 6409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_init_internals",
          "args": [
            "zone",
            "j",
            "nid",
            "freesize"
          ],
          "line": 6404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_highmem_idx",
          "args": [
            "j"
          ],
          "line": 6392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"  %s zone: %lu pages reserved\\n\"",
            "zone_names[0]",
            "dma_reserve"
          ],
          "line": 6388
        },
        "resolved": true,
        "details": {
          "function_name": "mminit_dprintk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "417-420",
          "snippet": "static inline void mminit_dprintk(enum mminit_level level,\n\t\t\t\tconst char *prefix, const char *fmt, ...)\n{\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void mminit_dprintk(enum mminit_level level,\n\t\t\t\tconst char *prefix, const char *fmt, ...)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"  %s zone: %lu pages exceeds freesize %lu\\n\"",
            "zone_names[j]",
            "memmap_pages",
            "freesize"
          ],
          "line": 6381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_highmem_idx",
          "args": [
            "j"
          ],
          "line": 6373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calc_memmap_size",
          "args": [
            "size",
            "freesize"
          ],
          "line": 6372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgdat_init_internals",
          "args": [
            "pgdat"
          ],
          "line": 6356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_init_internals",
          "args": [
            "&pgdat->node_zones[z]",
            "z",
            "nid",
            "0"
          ],
          "line": 6338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgdat_init_internals",
          "args": [
            "pgdat"
          ],
          "line": 6336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "nid"
          ],
          "line": 6334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_pcp_init",
          "args": [
            "zone"
          ],
          "line": 6320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_seqlock_init",
          "args": [
            "zone"
          ],
          "line": 6319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&zone->lock"
          ],
          "line": 6318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "nid"
          ],
          "line": 6317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_set_nid",
          "args": [
            "zone",
            "nid"
          ],
          "line": 6315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lruvec_init",
          "args": [
            "node_lruvec(pgdat)"
          ],
          "line": 6308
        },
        "resolved": true,
        "details": {
          "function_name": "lruvec_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/mmzone.c",
          "lines": "89-97",
          "snippet": "void lruvec_init(struct lruvec *lruvec)\n{\n\tenum lru_list lru;\n\n\tmemset(lruvec, 0, sizeof(struct lruvec));\n\n\tfor_each_lru(lru)\n\t\tINIT_LIST_HEAD(&lruvec->lists[lru]);\n}",
          "includes": [
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid lruvec_init(struct lruvec *lruvec)\n{\n\tenum lru_list lru;\n\n\tmemset(lruvec, 0, sizeof(struct lruvec));\n\n\tfor_each_lru(lru)\n\t\tINIT_LIST_HEAD(&lruvec->lists[lru]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "node_lruvec",
          "args": [
            "pgdat"
          ],
          "line": 6308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&pgdat->lru_lock"
          ],
          "line": 6307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgdat_page_ext_init",
          "args": [
            "pgdat"
          ],
          "line": 6306
        },
        "resolved": true,
        "details": {
          "function_name": "pgdat_page_ext_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
          "lines": "420-422",
          "snippet": "void __meminit pgdat_page_ext_init(struct pglist_data *pgdat)\n{\n}",
          "includes": [
            "#include <linux/page_idle.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/memory.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nvoid __meminit pgdat_page_ext_init(struct pglist_data *pgdat)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&pgdat->pfmemalloc_wait"
          ],
          "line": 6304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&pgdat->kswapd_wait"
          ],
          "line": 6303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgdat_init_kcompactd",
          "args": [
            "pgdat"
          ],
          "line": 6301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgdat_init_split_queue",
          "args": [
            "pgdat"
          ],
          "line": 6300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgdat_resize_init",
          "args": [
            "pgdat"
          ],
          "line": 6298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&pgdat->kcompactd_wait"
          ],
          "line": 6290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&pgdat->split_queue"
          ],
          "line": 6280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&pgdat->split_queue_lock"
          ],
          "line": 6279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "pages * sizeof(struct page)"
          ],
          "line": 6273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_SPARSEMEM"
          ],
          "line": 6270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_alloc_node_nopanic",
          "args": [
            "usemapsize",
            "pgdat->node_id"
          ],
          "line": 6211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usemap_size",
          "args": [
            "zone_start_pfn",
            "zonesize"
          ],
          "line": 6207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "usemapsize",
            "8 * sizeof(unsigned long)"
          ],
          "line": 6197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "zonesize",
            "pageblock_nr_pages"
          ],
          "line": 6194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_absent_pages_in_node",
          "args": [
            "pgdat->node_id",
            "i",
            "node_start_pfn",
            "node_end_pfn",
            "zholes_size"
          ],
          "line": 6161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_spanned_pages_in_node",
          "args": [
            "pgdat->node_id",
            "i",
            "node_start_pfn",
            "node_end_pfn",
            "&zone_start_pfn",
            "&zone_end_pfn",
            "zones_size"
          ],
          "line": 6155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_is_mirror",
          "args": [
            "r"
          ],
          "line": 6099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_is_mirror",
          "args": [
            "r"
          ],
          "line": 6095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clamp",
          "args": [
            "memblock_region_memory_end_pfn(r)",
            "zone_start_pfn",
            "zone_end_pfn"
          ],
          "line": 6091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_region_memory_end_pfn",
          "args": [
            "r"
          ],
          "line": 6091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clamp",
          "args": [
            "memblock_region_memory_base_pfn(r)",
            "zone_start_pfn",
            "zone_end_pfn"
          ],
          "line": 6089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_region_memory_base_pfn",
          "args": [
            "r"
          ],
          "line": 6089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_memblock",
          "args": [
            "memory",
            "r"
          ],
          "line": 6088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__absent_pages_in_range",
          "args": [
            "nid",
            "zone_start_pfn",
            "zone_end_pfn"
          ],
          "line": 6077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adjust_zone_range_for_zone_movable",
          "args": [
            "nid",
            "zone_type",
            "node_start_pfn",
            "node_end_pfn",
            "&zone_start_pfn",
            "&zone_end_pfn"
          ],
          "line": 6074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clamp",
          "args": [
            "node_end_pfn",
            "zone_low",
            "zone_high"
          ],
          "line": 6072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clamp",
          "args": [
            "node_start_pfn",
            "zone_low",
            "zone_high"
          ],
          "line": 6071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__absent_pages_in_range",
          "args": [
            "MAX_NUMNODES",
            "start_pfn",
            "end_pfn"
          ],
          "line": 6052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clamp",
          "args": [
            "end_pfn",
            "range_start_pfn",
            "range_end_pfn"
          ],
          "line": 6036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clamp",
          "args": [
            "start_pfn",
            "range_start_pfn",
            "range_end_pfn"
          ],
          "line": 6035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_mem_pfn_range",
          "args": [
            "i",
            "nid",
            "&start_pfn",
            "&end_pfn",
            "NULL"
          ],
          "line": 6034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adjust_zone_range_for_zone_movable",
          "args": [
            "nid",
            "zone_type",
            "node_start_pfn",
            "node_end_pfn",
            "zone_start_pfn",
            "zone_end_pfn"
          ],
          "line": 6006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "zone_index == -1"
          ],
          "line": 5946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_mem_pfn_range",
          "args": [
            "i",
            "nid",
            "&this_start_pfn",
            "&this_end_pfn",
            "NULL"
          ],
          "line": 5920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memory_present",
          "args": [
            "this_nid",
            "start_pfn",
            "end_pfn"
          ],
          "line": 5897
        },
        "resolved": true,
        "details": {
          "function_name": "memory_present",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "210-240",
          "snippet": "void __init memory_present(int nid, unsigned long start, unsigned long end)\n{\n\tunsigned long pfn;\n\n#ifdef CONFIG_SPARSEMEM_EXTREME\n\tif (unlikely(!mem_section)) {\n\t\tunsigned long size, align;\n\n\t\tsize = sizeof(struct mem_section*) * NR_SECTION_ROOTS;\n\t\talign = 1 << (INTERNODE_CACHE_SHIFT);\n\t\tmem_section = memblock_alloc(size, align);\n\t}\n#endif\n\n\tstart &= PAGE_SECTION_MASK;\n\tmminit_validate_memmodel_limits(&start, &end);\n\tfor (pfn = start; pfn < end; pfn += PAGES_PER_SECTION) {\n\t\tunsigned long section = pfn_to_section_nr(pfn);\n\t\tstruct mem_section *ms;\n\n\t\tsparse_index_init(section, nid);\n\t\tset_section_nid(section, nid);\n\n\t\tms = __nr_to_section(section);\n\t\tif (!ms->section_mem_map) {\n\t\t\tms->section_mem_map = sparse_encode_early_nid(nid) |\n\t\t\t\t\t\t\tSECTION_IS_ONLINE;\n\t\t\tsection_mark_present(ms);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid __init memory_present(int nid, unsigned long start, unsigned long end)\n{\n\tunsigned long pfn;\n\n#ifdef CONFIG_SPARSEMEM_EXTREME\n\tif (unlikely(!mem_section)) {\n\t\tunsigned long size, align;\n\n\t\tsize = sizeof(struct mem_section*) * NR_SECTION_ROOTS;\n\t\talign = 1 << (INTERNODE_CACHE_SHIFT);\n\t\tmem_section = memblock_alloc(size, align);\n\t}\n#endif\n\n\tstart &= PAGE_SECTION_MASK;\n\tmminit_validate_memmodel_limits(&start, &end);\n\tfor (pfn = start; pfn < end; pfn += PAGES_PER_SECTION) {\n\t\tunsigned long section = pfn_to_section_nr(pfn);\n\t\tstruct mem_section *ms;\n\n\t\tsparse_index_init(section, nid);\n\t\tset_section_nid(section, nid);\n\n\t\tms = __nr_to_section(section);\n\t\tif (!ms->section_mem_map) {\n\t\t\tms->section_mem_map = sparse_encode_early_nid(nid) |\n\t\t\t\t\t\t\tSECTION_IS_ONLINE;\n\t\t\tsection_mark_present(ms);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_mem_pfn_range",
          "args": [
            "i",
            "nid",
            "&start_pfn",
            "&end_pfn",
            "&this_nid"
          ],
          "line": 5896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_free_early_nid",
          "args": [
            "PFN_PHYS(start_pfn)",
            "(end_pfn - start_pfn) << PAGE_SHIFT",
            "this_nid"
          ],
          "line": 5878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_PHYS",
          "args": [
            "start_pfn"
          ],
          "line": 5878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_mem_pfn_range",
          "args": [
            "i",
            "nid",
            "&start_pfn",
            "&end_pfn",
            "&this_nid"
          ],
          "line": 5873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_search_pfn_nid",
          "args": [
            "pfn",
            "&start_pfn",
            "&end_pfn"
          ],
          "line": 5848
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_search_pfn_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "1750-1763",
          "snippet": "int __init_memblock memblock_search_pfn_nid(unsigned long pfn,\n\t\t\t unsigned long *start_pfn, unsigned long *end_pfn)\n{\n\tstruct memblock_type *type = &memblock.memory;\n\tint mid = memblock_search(type, PFN_PHYS(pfn));\n\n\tif (mid == -1)\n\t\treturn -1;\n\n\t*start_pfn = PFN_DOWN(type->regions[mid].base);\n\t*end_pfn = PFN_DOWN(type->regions[mid].base + type->regions[mid].size);\n\n\treturn type->regions[mid].nid;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum memblock_flags __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "phys_addr_t __init_memblock",
            "void __init_memblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nenum memblock_flags __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nphys_addr_t __init_memblock;\nvoid __init_memblock;\n\nint __init_memblock memblock_search_pfn_nid(unsigned long pfn,\n\t\t\t unsigned long *start_pfn, unsigned long *end_pfn)\n{\n\tstruct memblock_type *type = &memblock.memory;\n\tint mid = memblock_search(type, PFN_PHYS(pfn));\n\n\tif (mid == -1)\n\t\treturn -1;\n\n\t*start_pfn = PFN_DOWN(type->regions[mid].base);\n\t*end_pfn = PFN_DOWN(type->regions[mid].base + type->regions[mid].size);\n\n\treturn type->regions[mid].nid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zone_init_free_lists",
          "args": [
            "zone"
          ],
          "line": 5829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_idx",
          "args": [
            "zone"
          ],
          "line": 5826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_idx",
          "args": [
            "zone"
          ],
          "line": 5816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_batchsize",
          "args": [
            "zone"
          ],
          "line": 5808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "populated_zone",
          "args": [
            "zone"
          ],
          "line": 5805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_percpu",
          "args": [
            "structper_cpu_nodestat"
          ],
          "line": 5793
        },
        "resolved": true,
        "details": {
          "function_name": "early_alloc_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "941-950",
          "snippet": "static void early_alloc_percpu(struct early_log *log)\n{\n\tunsigned int cpu;\n\tconst void __percpu *ptr = log->ptr;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tlog->ptr = per_cpu_ptr(ptr, cpu);\n\t\tearly_alloc(log);\n\t}\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct early_log\n\tearly_log[CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic struct early_log\n\tearly_log[CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE];\n\nstatic void early_alloc_percpu(struct early_log *log)\n{\n\tunsigned int cpu;\n\tconst void __percpu *ptr = log->ptr;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tlog->ptr = per_cpu_ptr(ptr, cpu);\n\t\tearly_alloc(log);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pageset_set_high_and_batch",
          "args": [
            "zone",
            "pcp"
          ],
          "line": 5768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pageset_init",
          "args": [
            "pcp"
          ],
          "line": 5767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "zone->pageset",
            "cpu"
          ],
          "line": 5765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pageset_set_batch",
          "args": [
            "pcp",
            "zone_batchsize(zone)"
          ],
          "line": 5760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_batchsize",
          "args": [
            "zone"
          ],
          "line": 5760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pageset_set_high",
          "args": [
            "pcp",
            "(zone->managed_pages /\n\t\t\t\tpercpu_pagelist_fraction)"
          ],
          "line": 5756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pageset_update",
          "args": [
            "&p->pcp",
            "high",
            "batch"
          ],
          "line": 5749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pageset_set_batch",
          "args": [
            "p",
            "batch"
          ],
          "line": 5735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pageset_init",
          "args": [
            "p"
          ],
          "line": 5734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&pcp->lists[migratetype]"
          ],
          "line": 5729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pageset_update",
          "args": [
            "&p->pcp",
            "6 * batch",
            "max(1UL, 1 * batch)"
          ],
          "line": 5716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 5708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 5704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rounddown_pow_of_two",
          "args": [
            "batch + batch/2"
          ],
          "line": 5664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmap_init_zone",
          "args": [
            "size",
            "nid",
            "zone",
            "start_pfn",
            "MEMMAP_EARLY",
            "NULL"
          ],
          "line": 5634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&zone->free_area[order].free_list[t]"
          ],
          "line": 5626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_migratetype_order",
          "args": [
            "order",
            "t"
          ],
          "line": 5625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s initialised, %lu pages in %ums\\n\"",
            "dev_name(pgmap->dev)",
            "size",
            "jiffies_to_msecs(jiffies - start)"
          ],
          "line": 5617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jiffies_to_msecs",
          "args": [
            "jiffies - start"
          ],
          "line": 5618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_name",
          "args": [
            "pgmap->dev"
          ],
          "line": 5617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 5613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pageblock_migratetype",
          "args": [
            "page",
            "MIGRATE_MOVABLE"
          ],
          "line": 5612
        },
        "resolved": true,
        "details": {
          "function_name": "set_pageblock_migratetype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "450-458",
          "snippet": "void set_pageblock_migratetype(struct page *page, int migratetype)\n{\n\tif (unlikely(page_group_by_mobility_disabled &&\n\t\t     migratetype < MIGRATE_PCPTYPES))\n\t\tmigratetype = MIGRATE_UNMOVABLE;\n\n\tset_pageblock_flags_group(page, (unsigned long)migratetype,\n\t\t\t\t\tPB_migrate, PB_migrate_end);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int page_group_by_mobility_disabled",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nint page_group_by_mobility_disabled;\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid set_pageblock_migratetype(struct page *page, int migratetype)\n{\n\tif (unlikely(page_group_by_mobility_disabled &&\n\t\t     migratetype < MIGRATE_PCPTYPES))\n\t\tmigratetype = MIGRATE_UNMOVABLE;\n\n\tset_pageblock_flags_group(page, (unsigned long)migratetype,\n\t\t\t\t\tPB_migrate, PB_migrate_end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__SetPageReserved",
          "args": [
            "page"
          ],
          "line": 5586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__init_single_page",
          "args": [
            "page",
            "pfn",
            "zone_idx",
            "nid"
          ],
          "line": 5577
        },
        "resolved": true,
        "details": {
          "function_name": "__init_single_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1178-1193",
          "snippet": "static void __meminit __init_single_page(struct page *page, unsigned long pfn,\n\t\t\t\tunsigned long zone, int nid)\n{\n\tmm_zero_struct_page(page);\n\tset_page_links(page, zone, nid, pfn);\n\tinit_page_count(page);\n\tpage_mapcount_reset(page);\n\tpage_cpupid_reset_last(page);\n\n\tINIT_LIST_HEAD(&page->lru);\n#ifdef WANT_PAGE_VIRTUAL\n\t/* The shift won't overflow because ZONE_NORMAL is below 4G. */\n\tif (!is_highmem_idx(zone))\n\t\tset_page_address(page, __va(pfn << PAGE_SHIFT));\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic void __meminit __init_single_page(struct page *page, unsigned long pfn,\n\t\t\t\tunsigned long zone, int nid)\n{\n\tmm_zero_struct_page(page);\n\tset_page_links(page, zone, nid, pfn);\n\tinit_page_count(page);\n\tpage_mapcount_reset(page);\n\tpage_cpupid_reset_last(page);\n\n\tINIT_LIST_HEAD(&page->lru);\n#ifdef WANT_PAGE_VIRTUAL\n\t/* The shift won't overflow because ZONE_NORMAL is below 4G. */\n\tif (!is_highmem_idx(zone))\n\t\tset_page_address(page, __va(pfn << PAGE_SHIFT));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 5575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmem_altmap_offset",
          "args": [
            "altmap"
          ],
          "line": 5570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!pgmap || !is_dev_zone(zone)"
          ],
          "line": 5559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_dev_zone",
          "args": [
            "zone"
          ],
          "line": 5559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_idx",
          "args": [
            "zone"
          ],
          "line": 5555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 5542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__SetPageReserved",
          "args": [
            "page"
          ],
          "line": 5526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 5523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "defer_init",
          "args": [
            "nid",
            "pfn",
            "end_pfn"
          ],
          "line": 5519
        },
        "resolved": true,
        "details": {
          "function_name": "defer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "343-346",
          "snippet": "static inline bool defer_init(int nid, unsigned long pfn, unsigned long end_pfn)\n{\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic inline bool defer_init(int nid, unsigned long pfn, unsigned long end_pfn)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "overlap_memmap_init",
          "args": [
            "zone",
            "&pfn"
          ],
          "line": 5517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "early_pfn_in_nid",
          "args": [
            "pfn",
            "nid"
          ],
          "line": 5515
        },
        "resolved": true,
        "details": {
          "function_name": "early_pfn_in_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1328-1331",
          "snippet": "static inline bool __meminit early_pfn_in_nid(unsigned long pfn, int node)\n{\n\treturn true;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic inline bool __meminit early_pfn_in_nid(unsigned long pfn, int node)\n{\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "early_pfn_valid",
          "args": [
            "pfn"
          ],
          "line": 5513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmem_altmap_offset",
          "args": [
            "altmap"
          ],
          "line": 5503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_region_memory_end_pfn",
          "args": [
            "r"
          ],
          "line": 5466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_is_mirror",
          "args": [
            "r"
          ],
          "line": 5465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_region_memory_base_pfn",
          "args": [
            "r"
          ],
          "line": 5464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_region_memory_end_pfn",
          "args": [
            "r"
          ],
          "line": 5460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_memblock",
          "args": [
            "memory",
            "r"
          ],
          "line": 5459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_region_memory_end_pfn",
          "args": [
            "r"
          ],
          "line": 5458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Policy zone: %s\\n\"",
            "zone_names[policy_zone]"
          ],
          "line": 5446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Built %i zonelists, mobility grouping %s.  Total pages: %ld\\n\"",
            "nr_online_nodes",
            "page_group_by_mobility_disabled ? \"off\" : \"on\"",
            "vm_total_pages"
          ],
          "line": 5441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nr_free_pagecache_pages",
          "args": [],
          "line": 5428
        },
        "resolved": true,
        "details": {
          "function_name": "nr_free_pagecache_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4690-4693",
          "snippet": "unsigned long nr_free_pagecache_pages(void)\n{\n\treturn nr_free_zone_pages(gfp_zone(GFP_HIGHUSER_MOVABLE));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nunsigned long nr_free_pagecache_pages(void)\n{\n\treturn nr_free_zone_pages(gfp_zone(GFP_HIGHUSER_MOVABLE));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__build_all_zonelists",
          "args": [
            "pgdat"
          ],
          "line": 5425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_all_zonelists_init",
          "args": [],
          "line": 5423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuset_init_current_mems_allowed",
          "args": [],
          "line": 5411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mminit_verify_zonelist",
          "args": [],
          "line": 5410
        },
        "resolved": true,
        "details": {
          "function_name": "mminit_verify_zonelist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "426-428",
          "snippet": "static inline void mminit_verify_zonelist(void)\n{\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void mminit_verify_zonelist(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "__build_all_zonelists",
          "args": [
            "NULL"
          ],
          "line": 5392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&lock"
          ],
          "line": 5384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_zonelists",
          "args": [
            "pgdat"
          ],
          "line": 5367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "nid"
          ],
          "line": 5365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_zonelists",
          "args": [
            "self"
          ],
          "line": 5362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_online",
          "args": [
            "self->node_id"
          ],
          "line": 5361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&lock"
          ],
          "line": 5351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_zonerefs_node",
          "args": [
            "NODE_DATA(node)",
            "zonerefs"
          ],
          "line": 5315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "node"
          ],
          "line": 5315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_online",
          "args": [
            "node"
          ],
          "line": 5313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_zonerefs_node",
          "args": [
            "NODE_DATA(node)",
            "zonerefs"
          ],
          "line": 5309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "node"
          ],
          "line": 5309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_online",
          "args": [
            "node"
          ],
          "line": 5307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_zonerefs_node",
          "args": [
            "pgdat",
            "zonerefs"
          ],
          "line": 5295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_to_nid",
          "args": [
            "z->zone"
          ],
          "line": 5278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "first_zones_zonelist",
          "args": [
            "node_zonelist(node, GFP_KERNEL)",
            "gfp_zone(GFP_KERNEL)",
            "NULL"
          ],
          "line": 5275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfp_zone",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 5276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_zonelist",
          "args": [
            "node",
            "GFP_KERNEL"
          ],
          "line": 5275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_thisnode_zonelists",
          "args": [
            "pgdat"
          ],
          "line": 5261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_zonelists_in_node_order",
          "args": [
            "pgdat",
            "node_order",
            "nr_nodes"
          ],
          "line": 5260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_distance",
          "args": [
            "local_node",
            "prev_node"
          ],
          "line": 5252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_distance",
          "args": [
            "local_node",
            "node"
          ],
          "line": 5251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_next_best_node",
          "args": [
            "local_node",
            "&used_mask"
          ],
          "line": 5245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes_clear",
          "args": [
            "used_mask"
          ],
          "line": 5242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_zonerefs_node",
          "args": [
            "pgdat",
            "zonerefs"
          ],
          "line": 5218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_zonerefs_node",
          "args": [
            "node",
            "zonerefs"
          ],
          "line": 5202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "node_order[i]"
          ],
          "line": 5200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_set",
          "args": [
            "best_node",
            "*used_node_mask"
          ],
          "line": 5178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "tmp"
          ],
          "line": 5164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_of_node",
          "args": [
            "n"
          ],
          "line": 5163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_distance",
          "args": [
            "node",
            "n"
          ],
          "line": 5157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_isset",
          "args": [
            "n",
            "*used_node_mask"
          ],
          "line": 5153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_node_state",
          "args": [
            "n",
            "N_MEMORY"
          ],
          "line": 5150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_set",
          "args": [
            "node",
            "*used_node_mask"
          ],
          "line": 5146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_isset",
          "args": [
            "node",
            "*used_node_mask"
          ],
          "line": 5145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_of_node",
          "args": [
            "0"
          ],
          "line": 5142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "str"
          ],
          "line": 5115
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__parse_numa_zonelist_order",
          "args": [
            "str"
          ],
          "line": 5114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "str"
          ],
          "line": 5112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "str"
          ],
          "line": 5111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user_nul",
          "args": [
            "buffer",
            "16"
          ],
          "line": 5110
        },
        "resolved": true,
        "details": {
          "function_name": "memdup_user_nul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "229-249",
          "snippet": "void *memdup_user_nul(const void __user *src, size_t len)\n{\n\tchar *p;\n\n\t/*\n\t * Always use GFP_KERNEL, since copy_from_user() can sleep and\n\t * cause pagefault, which makes it pointless to use GFP_NOFS\n\t * or GFP_ATOMIC.\n\t */\n\tp = kmalloc_track_caller(len + 1, GFP_KERNEL);\n\tif (!p)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (copy_from_user(p, src, len)) {\n\t\tkfree(p);\n\t\treturn ERR_PTR(-EFAULT);\n\t}\n\tp[len] = '\\0';\n\n\treturn p;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid *memdup_user_nul(const void __user *src, size_t len)\n{\n\tchar *p;\n\n\t/*\n\t * Always use GFP_KERNEL, since copy_from_user() can sleep and\n\t * cause pagefault, which makes it pointless to use GFP_NOFS\n\t * or GFP_ATOMIC.\n\t */\n\tp = kmalloc_track_caller(len + 1, GFP_KERNEL);\n\tif (!p)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (copy_from_user(p, src, len)) {\n\t\tkfree(p);\n\t\treturn ERR_PTR(-EFAULT);\n\t}\n\tp[len] = '\\0';\n\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_dostring",
          "args": [
            "table",
            "write",
            "buffer",
            "length",
            "ppos"
          ],
          "line": 5109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "early_param",
          "args": [
            "\"numa_zonelist_order\"",
            "setup_numa_zonelist_order"
          ],
          "line": 5094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__parse_numa_zonelist_order",
          "args": [
            "s"
          ],
          "line": 5092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Ignoring unsupported numa_zonelist_order value:  %s\\n\"",
            "s"
          ],
          "line": 5081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_highest_zone",
          "args": [
            "zone_type"
          ],
          "line": 5063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zoneref_set_zone",
          "args": [
            "zone",
            "&zonerefs[nr_zones++]"
          ],
          "line": 5062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "managed_zone",
          "args": [
            "zone"
          ],
          "line": 5061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_idx",
          "args": [
            "zone"
          ],
          "line": 5044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "show_swap_cache_info",
          "args": [],
          "line": 5038
        },
        "resolved": true,
        "details": {
          "function_name": "show_swap_cache_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swap_state.c",
          "lines": "98-107",
          "snippet": "void show_swap_cache_info(void)\n{\n\tprintk(\"%lu pages in swap cache\\n\", total_swapcache_pages());\n\tprintk(\"Swap cache stats: add %lu, delete %lu, find %lu/%lu\\n\",\n\t\tswap_cache_info.add_total, swap_cache_info.del_total,\n\t\tswap_cache_info.find_success, swap_cache_info.find_total);\n\tprintk(\"Free swap  = %ldkB\\n\",\n\t\tget_nr_swap_pages() << (PAGE_SHIFT - 10));\n\tprintk(\"Total swap = %lukB\\n\", total_swap_pages << (PAGE_SHIFT - 10));\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/migrate.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tunsigned long add_total;\n\tunsigned long del_total;\n\tunsigned long find_success;\n\tunsigned long find_total;\n} swap_cache_info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <linux/huge_mm.h>\n#include <linux/swap_slots.h>\n#include <linux/vmalloc.h>\n#include <linux/migrate.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\nstatic struct {\n\tunsigned long add_total;\n\tunsigned long del_total;\n\tunsigned long find_success;\n\tunsigned long find_total;\n} swap_cache_info;\n\nvoid show_swap_cache_info(void)\n{\n\tprintk(\"%lu pages in swap cache\\n\", total_swapcache_pages());\n\tprintk(\"Swap cache stats: add %lu, delete %lu, find %lu/%lu\\n\",\n\t\tswap_cache_info.add_total, swap_cache_info.del_total,\n\t\tswap_cache_info.find_success, swap_cache_info.find_total);\n\tprintk(\"Free swap  = %ldkB\\n\",\n\t\tget_nr_swap_pages() << (PAGE_SHIFT - 10));\n\tprintk(\"Total swap = %lukB\\n\", total_swap_pages << (PAGE_SHIFT - 10));\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"%ld total pagecache pages\\n\"",
            "global_node_page_state(NR_FILE_PAGES)"
          ],
          "line": 5036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_node_page_state",
          "args": [
            "NR_FILE_PAGES"
          ],
          "line": 5036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hugetlb_show_meminfo",
          "args": [],
          "line": 5034
        },
        "resolved": true,
        "details": {
          "function_name": "hugetlb_show_meminfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/hugetlb.c",
          "lines": "3017-3033",
          "snippet": "void hugetlb_show_meminfo(void)\n{\n\tstruct hstate *h;\n\tint nid;\n\n\tif (!hugepages_supported())\n\t\treturn;\n\n\tfor_each_node_state(nid, N_MEMORY)\n\t\tfor_each_hstate(h)\n\t\t\tpr_info(\"Node %d hugepages_total=%u hugepages_free=%u hugepages_surp=%u hugepages_size=%lukB\\n\",\n\t\t\t\tnid,\n\t\t\t\th->nr_huge_pages_node[nid],\n\t\t\t\th->free_huge_pages_node[nid],\n\t\t\t\th->surplus_huge_pages_node[nid],\n\t\t\t\t1UL << (huge_page_order(h) + PAGE_SHIFT - 10));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/node.h>",
            "#include <linux/hugetlb_cgroup.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/io.h>",
            "#include <asm/tlb.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/jhash.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/rmap.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mmdebug.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/compiler.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/node.h>\n#include <linux/hugetlb_cgroup.h>\n#include <linux/hugetlb.h>\n#include <linux/io.h>\n#include <asm/tlb.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/jhash.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/string_helpers.h>\n#include <linux/rmap.h>\n#include <linux/sched/signal.h>\n#include <linux/mmdebug.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/memblock.h>\n#include <linux/mutex.h>\n#include <linux/cpuset.h>\n#include <linux/compiler.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/nodemask.h>\n#include <linux/mmu_notifier.h>\n#include <linux/highmem.h>\n#include <linux/sysctl.h>\n#include <linux/seq_file.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/list.h>\n\nvoid hugetlb_show_meminfo(void)\n{\n\tstruct hstate *h;\n\tint nid;\n\n\tif (!hugepages_supported())\n\t\treturn;\n\n\tfor_each_node_state(nid, N_MEMORY)\n\t\tfor_each_hstate(h)\n\t\t\tpr_info(\"Node %d hugepages_total=%u hugepages_free=%u hugepages_surp=%u hugepages_size=%lukB\\n\",\n\t\t\t\tnid,\n\t\t\t\th->nr_huge_pages_node[nid],\n\t\t\t\th->free_huge_pages_node[nid],\n\t\t\t\th->surplus_huge_pages_node[nid],\n\t\t\t\t1UL << (huge_page_order(h) + PAGE_SHIFT - 10));\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \"= %lukB\\n\"",
            "K(total)"
          ],
          "line": 5031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "total"
          ],
          "line": 5031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "show_migration_types",
          "args": [
            "types[order]"
          ],
          "line": 5029
        },
        "resolved": true,
        "details": {
          "function_name": "show_migration_types",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4815-4840",
          "snippet": "static void show_migration_types(unsigned char type)\n{\n\tstatic const char types[MIGRATE_TYPES] = {\n\t\t[MIGRATE_UNMOVABLE]\t= 'U',\n\t\t[MIGRATE_MOVABLE]\t= 'M',\n\t\t[MIGRATE_RECLAIMABLE]\t= 'E',\n\t\t[MIGRATE_HIGHATOMIC]\t= 'H',\n#ifdef CONFIG_CMA\n\t\t[MIGRATE_CMA]\t\t= 'C',\n#endif\n#ifdef CONFIG_MEMORY_ISOLATION\n\t\t[MIGRATE_ISOLATE]\t= 'I',\n#endif\n\t};\n\tchar tmp[MIGRATE_TYPES + 1];\n\tchar *p = tmp;\n\tint i;\n\n\tfor (i = 0; i < MIGRATE_TYPES; i++) {\n\t\tif (type & (1 << i))\n\t\t\t*p++ = types[i];\n\t}\n\n\t*p = '\\0';\n\tprintk(KERN_CONT \"(%s) \", tmp);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void show_migration_types(unsigned char type)\n{\n\tstatic const char types[MIGRATE_TYPES] = {\n\t\t[MIGRATE_UNMOVABLE]\t= 'U',\n\t\t[MIGRATE_MOVABLE]\t= 'M',\n\t\t[MIGRATE_RECLAIMABLE]\t= 'E',\n\t\t[MIGRATE_HIGHATOMIC]\t= 'H',\n#ifdef CONFIG_CMA\n\t\t[MIGRATE_CMA]\t\t= 'C',\n#endif\n#ifdef CONFIG_MEMORY_ISOLATION\n\t\t[MIGRATE_ISOLATE]\t= 'I',\n#endif\n\t};\n\tchar tmp[MIGRATE_TYPES + 1];\n\tchar *p = tmp;\n\tint i;\n\n\tfor (i = 0; i < MIGRATE_TYPES; i++) {\n\t\tif (type & (1 << i))\n\t\t\t*p++ = types[i];\n\t}\n\n\t*p = '\\0';\n\tprintk(KERN_CONT \"(%s) \", tmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "1UL"
          ],
          "line": 5027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&zone->lock",
            "flags"
          ],
          "line": 5024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&zone->lock",
            "flags"
          ],
          "line": 5010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \"%s: \"",
            "zone->name"
          ],
          "line": 5008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "show_node",
          "args": [
            "zone"
          ],
          "line": 5007
        },
        "resolved": true,
        "details": {
          "function_name": "show_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4695-4699",
          "snippet": "static inline void show_node(struct zone *zone)\n{\n\tif (IS_ENABLED(CONFIG_NUMA))\n\t\tprintk(\"Node %d \", zone_to_nid(zone));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline void show_node(struct zone *zone)\n{\n\tif (IS_ENABLED(CONFIG_NUMA))\n\t\tprintk(\"Node %d \", zone_to_nid(zone));\n}"
        }
      },
      {
        "call_info": {
          "callee": "show_mem_node_skip",
          "args": [
            "filter",
            "zone_to_nid(zone)",
            "nodemask"
          ],
          "line": 5005
        },
        "resolved": true,
        "details": {
          "function_name": "show_mem_node_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4797-4811",
          "snippet": "static bool show_mem_node_skip(unsigned int flags, int nid, nodemask_t *nodemask)\n{\n\tif (!(flags & SHOW_MEM_FILTER_NODES))\n\t\treturn false;\n\n\t/*\n\t * no node mask - aka implicit memory numa policy. Do not bother with\n\t * the synchronization - read_mems_allowed_begin - because we do not\n\t * have to be precise here.\n\t */\n\tif (!nodemask)\n\t\tnodemask = &cpuset_current_mems_allowed;\n\n\treturn !node_isset(nid, *nodemask);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic bool show_mem_node_skip(unsigned int flags, int nid, nodemask_t *nodemask)\n{\n\tif (!(flags & SHOW_MEM_FILTER_NODES))\n\t\treturn false;\n\n\t/*\n\t * no node mask - aka implicit memory numa policy. Do not bother with\n\t * the synchronization - read_mems_allowed_begin - because we do not\n\t * have to be precise here.\n\t */\n\tif (!nodemask)\n\t\tnodemask = &cpuset_current_mems_allowed;\n\n\treturn !node_isset(nid, *nodemask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "zone_to_nid",
          "args": [
            "zone"
          ],
          "line": 5005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \"\\n\""
          ],
          "line": 4997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \" %ld\"",
            "zone->lowmem_reserve[i]"
          ],
          "line": 4996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"lowmem_reserve[]:\""
          ],
          "line": 4994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "zone_page_state(zone, NR_FREE_CMA_PAGES)"
          ],
          "line": 4993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_page_state",
          "args": [
            "zone",
            "NR_FREE_CMA_PAGES"
          ],
          "line": 4993
        },
        "resolved": true,
        "details": {
          "function_name": "dec_zone_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "624-631",
          "snippet": "void dec_zone_page_state(struct page *page, enum zone_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__dec_zone_page_state(page, item);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid dec_zone_page_state(struct page *page, enum zone_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__dec_zone_page_state(page, item);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "this_cpu_read(zone->pageset->pcp.count)"
          ],
          "line": 4992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_read",
          "args": [
            "zone->pageset->pcp.count"
          ],
          "line": 4992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "free_pcp"
          ],
          "line": 4991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "zone_page_state(zone, NR_BOUNCE)"
          ],
          "line": 4990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "zone_page_state(zone, NR_PAGETABLE)"
          ],
          "line": 4989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "zone_page_state(zone, NR_MLOCK)"
          ],
          "line": 4987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "zone->managed_pages"
          ],
          "line": 4986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "zone->present_pages"
          ],
          "line": 4985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "zone_page_state(zone, NR_ZONE_WRITE_PENDING)"
          ],
          "line": 4984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "zone_page_state(zone, NR_ZONE_UNEVICTABLE)"
          ],
          "line": 4983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "zone_page_state(zone, NR_ZONE_INACTIVE_FILE)"
          ],
          "line": 4982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "zone_page_state(zone, NR_ZONE_ACTIVE_FILE)"
          ],
          "line": 4981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "zone_page_state(zone, NR_ZONE_INACTIVE_ANON)"
          ],
          "line": 4980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "zone_page_state(zone, NR_ZONE_ACTIVE_ANON)"
          ],
          "line": 4979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "high_wmark_pages(zone)"
          ],
          "line": 4978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "high_wmark_pages",
          "args": [
            "zone"
          ],
          "line": 4978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "low_wmark_pages(zone)"
          ],
          "line": 4977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "low_wmark_pages",
          "args": [
            "zone"
          ],
          "line": 4977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "min_wmark_pages(zone)"
          ],
          "line": 4976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_wmark_pages",
          "args": [
            "zone"
          ],
          "line": 4976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "zone_page_state(zone, NR_FREE_PAGES)"
          ],
          "line": 4975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_to_nid",
          "args": [
            "zone"
          ],
          "line": 4944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "node_page_state(pgdat, NR_UNSTABLE_NFS)"
          ],
          "line": 4936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_page_state",
          "args": [
            "pgdat",
            "NR_UNSTABLE_NFS"
          ],
          "line": 4936
        },
        "resolved": true,
        "details": {
          "function_name": "node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "991-1000",
          "snippet": "unsigned long node_page_state(struct pglist_data *pgdat,\n\t\t\t\tenum node_stat_item item)\n{\n\tlong x = atomic_long_read(&pgdat->vm_stat[item]);\n#ifdef CONFIG_SMP\n\tif (x < 0)\n\t\tx = 0;\n#endif\n\treturn x;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nunsigned long node_page_state(struct pglist_data *pgdat,\n\t\t\t\tenum node_stat_item item)\n{\n\tlong x = atomic_long_read(&pgdat->vm_stat[item]);\n#ifdef CONFIG_SMP\n\tif (x < 0)\n\t\tx = 0;\n#endif\n\treturn x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "node_page_state(pgdat, NR_WRITEBACK_TEMP)"
          ],
          "line": 4935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "node_page_state(pgdat, NR_ANON_THPS) * HPAGE_PMD_NR"
          ],
          "line": 4933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "node_page_state(pgdat, NR_SHMEM_PMDMAPPED)\n\t\t\t\t\t* HPAGE_PMD_NR"
          ],
          "line": 4931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "node_page_state(pgdat, NR_SHMEM_THPS) * HPAGE_PMD_NR"
          ],
          "line": 4930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "node_page_state(pgdat, NR_SHMEM)"
          ],
          "line": 4928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "node_page_state(pgdat, NR_WRITEBACK)"
          ],
          "line": 4927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "node_page_state(pgdat, NR_FILE_DIRTY)"
          ],
          "line": 4926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "node_page_state(pgdat, NR_FILE_MAPPED)"
          ],
          "line": 4925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "node_page_state(pgdat, NR_ISOLATED_FILE)"
          ],
          "line": 4924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "node_page_state(pgdat, NR_ISOLATED_ANON)"
          ],
          "line": 4923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "node_page_state(pgdat, NR_UNEVICTABLE)"
          ],
          "line": 4922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "node_page_state(pgdat, NR_INACTIVE_FILE)"
          ],
          "line": 4921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "node_page_state(pgdat, NR_ACTIVE_FILE)"
          ],
          "line": 4920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "node_page_state(pgdat, NR_INACTIVE_ANON)"
          ],
          "line": 4919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "node_page_state(pgdat, NR_ACTIVE_ANON)"
          ],
          "line": 4918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_zone_page_state",
          "args": [
            "NR_FREE_CMA_PAGES"
          ],
          "line": 4890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_zone_page_state",
          "args": [
            "NR_FREE_PAGES"
          ],
          "line": 4888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_zone_page_state",
          "args": [
            "NR_BOUNCE"
          ],
          "line": 4887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_zone_page_state",
          "args": [
            "NR_PAGETABLE"
          ],
          "line": 4886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_node_page_state",
          "args": [
            "NR_SHMEM"
          ],
          "line": 4885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_node_page_state",
          "args": [
            "NR_FILE_MAPPED"
          ],
          "line": 4884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_node_page_state",
          "args": [
            "NR_SLAB_UNRECLAIMABLE"
          ],
          "line": 4883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_node_page_state",
          "args": [
            "NR_SLAB_RECLAIMABLE"
          ],
          "line": 4882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_node_page_state",
          "args": [
            "NR_UNSTABLE_NFS"
          ],
          "line": 4881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_node_page_state",
          "args": [
            "NR_WRITEBACK"
          ],
          "line": 4880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_node_page_state",
          "args": [
            "NR_FILE_DIRTY"
          ],
          "line": 4879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_node_page_state",
          "args": [
            "NR_UNEVICTABLE"
          ],
          "line": 4878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_node_page_state",
          "args": [
            "NR_ISOLATED_FILE"
          ],
          "line": 4877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_node_page_state",
          "args": [
            "NR_INACTIVE_FILE"
          ],
          "line": 4876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_node_page_state",
          "args": [
            "NR_ACTIVE_FILE"
          ],
          "line": 4875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_node_page_state",
          "args": [
            "NR_ISOLATED_ANON"
          ],
          "line": 4874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_node_page_state",
          "args": [
            "NR_INACTIVE_ANON"
          ],
          "line": 4873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_node_page_state",
          "args": [
            "NR_ACTIVE_ANON"
          ],
          "line": 4872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_to_nid",
          "args": [
            "zone"
          ],
          "line": 4859
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\n#define ADAPT_SCALE_NPAGES\t(ADAPT_SCALE_BASE >> PAGE_SHIFT)\n#define ADAPT_SCALE_SHIFT\t2\n#define ADAPT_SCALE_BASE\t(64ul << 30)\n#define MAX_NODE_LOAD (nr_online_nodes)\n#define MIN_PERCPU_PAGELIST_FRACTION\t(8)\n\nstatic DEFINE_MUTEX(pcp_batch_high_lock);\nnodemask_t node_states[NR_NODE_STATES] __read_mostly = {\n\t[N_POSSIBLE] = NODE_MASK_ALL,\n\t[N_ONLINE] = { { [0] = 1UL } },\n#ifndef CONFIG_NUMA\n\t[N_NORMAL_MEMORY] = { { [0] = 1UL } },\n#ifdef CONFIG_HIGHMEM\n\t[N_HIGH_MEMORY] = { { [0] = 1UL } },\n#endif\n\t[N_MEMORY] = { { [0] = 1UL } },\n\t[N_CPU] = { { [0] = 1UL } },\n#endif\t/* NUMA */\n};\nstatic DEFINE_SPINLOCK(managed_page_count_lock);\nint percpu_pagelist_fraction;\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nint sysctl_lowmem_reserve_ratio[MAX_NR_ZONES] = {\n#ifdef CONFIG_ZONE_DMA\n\t[ZONE_DMA] = 256,\n#endif\n#ifdef CONFIG_ZONE_DMA32\n\t[ZONE_DMA32] = 256,\n#endif\n\t[ZONE_NORMAL] = 32,\n#ifdef CONFIG_HIGHMEM\n\t[ZONE_HIGHMEM] = 0,\n#endif\n\t[ZONE_MOVABLE] = 0,\n};\nstatic char * const zone_names[MAX_NR_ZONES] = {\n#ifdef CONFIG_ZONE_DMA\n\t \"DMA\",\n#endif\n#ifdef CONFIG_ZONE_DMA32\n\t \"DMA32\",\n#endif\n\t \"Normal\",\n#ifdef CONFIG_HIGHMEM\n\t \"HighMem\",\n#endif\n\t \"Movable\",\n#ifdef CONFIG_ZONE_DEVICE\n\t \"Device\",\n#endif\n};\nint min_free_kbytes = 1024;\nint user_min_free_kbytes = -1;\nint watermark_scale_factor = 10;\nint page_group_by_mobility_disabled;\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid show_free_areas(unsigned int filter, nodemask_t *nodemask)\n{\n\tunsigned long free_pcp = 0;\n\tint cpu;\n\tstruct zone *zone;\n\tpg_data_t *pgdat;\n\n\tfor_each_populated_zone(zone) {\n\t\tif (show_mem_node_skip(filter, zone_to_nid(zone), nodemask))\n\t\t\tcontinue;\n\n\t\tfor_each_online_cpu(cpu)\n\t\t\tfree_pcp += per_cpu_ptr(zone->pageset, cpu)->pcp.count;\n\t}\n\n\tprintk(\"active_anon:%lu inactive_anon:%lu isolated_anon:%lu\\n\"\n\t\t\" active_file:%lu inactive_file:%lu isolated_file:%lu\\n\"\n\t\t\" unevictable:%lu dirty:%lu writeback:%lu unstable:%lu\\n\"\n\t\t\" slab_reclaimable:%lu slab_unreclaimable:%lu\\n\"\n\t\t\" mapped:%lu shmem:%lu pagetables:%lu bounce:%lu\\n\"\n\t\t\" free:%lu free_pcp:%lu free_cma:%lu\\n\",\n\t\tglobal_node_page_state(NR_ACTIVE_ANON),\n\t\tglobal_node_page_state(NR_INACTIVE_ANON),\n\t\tglobal_node_page_state(NR_ISOLATED_ANON),\n\t\tglobal_node_page_state(NR_ACTIVE_FILE),\n\t\tglobal_node_page_state(NR_INACTIVE_FILE),\n\t\tglobal_node_page_state(NR_ISOLATED_FILE),\n\t\tglobal_node_page_state(NR_UNEVICTABLE),\n\t\tglobal_node_page_state(NR_FILE_DIRTY),\n\t\tglobal_node_page_state(NR_WRITEBACK),\n\t\tglobal_node_page_state(NR_UNSTABLE_NFS),\n\t\tglobal_node_page_state(NR_SLAB_RECLAIMABLE),\n\t\tglobal_node_page_state(NR_SLAB_UNRECLAIMABLE),\n\t\tglobal_node_page_state(NR_FILE_MAPPED),\n\t\tglobal_node_page_state(NR_SHMEM),\n\t\tglobal_zone_page_state(NR_PAGETABLE),\n\t\tglobal_zone_page_state(NR_BOUNCE),\n\t\tglobal_zone_page_state(NR_FREE_PAGES),\n\t\tfree_pcp,\n\t\tglobal_zone_page_state(NR_FREE_CMA_PAGES));\n\n\tfor_each_online_pgdat(pgdat) {\n\t\tif (show_mem_node_skip(filter, pgdat->node_id, nodemask))\n\t\t\tcontinue;\n\n\t\tprintk(\"Node %d\"\n\t\t\t\" active_anon:%lukB\"\n\t\t\t\" inactive_anon:%lukB\"\n\t\t\t\" active_file:%lukB\"\n\t\t\t\" inactive_file:%lukB\"\n\t\t\t\" unevictable:%lukB\"\n\t\t\t\" isolated(anon):%lukB\"\n\t\t\t\" isolated(file):%lukB\"\n\t\t\t\" mapped:%lukB\"\n\t\t\t\" dirty:%lukB\"\n\t\t\t\" writeback:%lukB\"\n\t\t\t\" shmem:%lukB\"\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\t\t\t\" shmem_thp: %lukB\"\n\t\t\t\" shmem_pmdmapped: %lukB\"\n\t\t\t\" anon_thp: %lukB\"\n#endif\n\t\t\t\" writeback_tmp:%lukB\"\n\t\t\t\" unstable:%lukB\"\n\t\t\t\" all_unreclaimable? %s\"\n\t\t\t\"\\n\",\n\t\t\tpgdat->node_id,\n\t\t\tK(node_page_state(pgdat, NR_ACTIVE_ANON)),\n\t\t\tK(node_page_state(pgdat, NR_INACTIVE_ANON)),\n\t\t\tK(node_page_state(pgdat, NR_ACTIVE_FILE)),\n\t\t\tK(node_page_state(pgdat, NR_INACTIVE_FILE)),\n\t\t\tK(node_page_state(pgdat, NR_UNEVICTABLE)),\n\t\t\tK(node_page_state(pgdat, NR_ISOLATED_ANON)),\n\t\t\tK(node_page_state(pgdat, NR_ISOLATED_FILE)),\n\t\t\tK(node_page_state(pgdat, NR_FILE_MAPPED)),\n\t\t\tK(node_page_state(pgdat, NR_FILE_DIRTY)),\n\t\t\tK(node_page_state(pgdat, NR_WRITEBACK)),\n\t\t\tK(node_page_state(pgdat, NR_SHMEM)),\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\t\t\tK(node_page_state(pgdat, NR_SHMEM_THPS) * HPAGE_PMD_NR),\n\t\t\tK(node_page_state(pgdat, NR_SHMEM_PMDMAPPED)\n\t\t\t\t\t* HPAGE_PMD_NR),\n\t\t\tK(node_page_state(pgdat, NR_ANON_THPS) * HPAGE_PMD_NR),\n#endif\n\t\t\tK(node_page_state(pgdat, NR_WRITEBACK_TEMP)),\n\t\t\tK(node_page_state(pgdat, NR_UNSTABLE_NFS)),\n\t\t\tpgdat->kswapd_failures >= MAX_RECLAIM_RETRIES ?\n\t\t\t\t\"yes\" : \"no\");\n\t}\n\n\tfor_each_populated_zone(zone) {\n\t\tint i;\n\n\t\tif (show_mem_node_skip(filter, zone_to_nid(zone), nodemask))\n\t\t\tcontinue;\n\n\t\tfree_pcp = 0;\n\t\tfor_each_online_cpu(cpu)\n\t\t\tfree_pcp += per_cpu_ptr(zone->pageset, cpu)->pcp.count;\n\n\t\tshow_node(zone);\n\t\tprintk(KERN_CONT\n\t\t\t\"%s\"\n\t\t\t\" free:%lukB\"\n\t\t\t\" min:%lukB\"\n\t\t\t\" low:%lukB\"\n\t\t\t\" high:%lukB\"\n\t\t\t\" active_anon:%lukB\"\n\t\t\t\" inactive_anon:%lukB\"\n\t\t\t\" active_file:%lukB\"\n\t\t\t\" inactive_file:%lukB\"\n\t\t\t\" unevictable:%lukB\"\n\t\t\t\" writepending:%lukB\"\n\t\t\t\" present:%lukB\"\n\t\t\t\" managed:%lukB\"\n\t\t\t\" mlocked:%lukB\"\n\t\t\t\" kernel_stack:%lukB\"\n\t\t\t\" pagetables:%lukB\"\n\t\t\t\" bounce:%lukB\"\n\t\t\t\" free_pcp:%lukB\"\n\t\t\t\" local_pcp:%ukB\"\n\t\t\t\" free_cma:%lukB\"\n\t\t\t\"\\n\",\n\t\t\tzone->name,\n\t\t\tK(zone_page_state(zone, NR_FREE_PAGES)),\n\t\t\tK(min_wmark_pages(zone)),\n\t\t\tK(low_wmark_pages(zone)),\n\t\t\tK(high_wmark_pages(zone)),\n\t\t\tK(zone_page_state(zone, NR_ZONE_ACTIVE_ANON)),\n\t\t\tK(zone_page_state(zone, NR_ZONE_INACTIVE_ANON)),\n\t\t\tK(zone_page_state(zone, NR_ZONE_ACTIVE_FILE)),\n\t\t\tK(zone_page_state(zone, NR_ZONE_INACTIVE_FILE)),\n\t\t\tK(zone_page_state(zone, NR_ZONE_UNEVICTABLE)),\n\t\t\tK(zone_page_state(zone, NR_ZONE_WRITE_PENDING)),\n\t\t\tK(zone->present_pages),\n\t\t\tK(zone->managed_pages),\n\t\t\tK(zone_page_state(zone, NR_MLOCK)),\n\t\t\tzone_page_state(zone, NR_KERNEL_STACK_KB),\n\t\t\tK(zone_page_state(zone, NR_PAGETABLE)),\n\t\t\tK(zone_page_state(zone, NR_BOUNCE)),\n\t\t\tK(free_pcp),\n\t\t\tK(this_cpu_read(zone->pageset->pcp.count)),\n\t\t\tK(zone_page_state(zone, NR_FREE_CMA_PAGES)));\n\t\tprintk(\"lowmem_reserve[]:\");\n\t\tfor (i = 0; i < MAX_NR_ZONES; i++)\n\t\t\tprintk(KERN_CONT \" %ld\", zone->lowmem_reserve[i]);\n\t\tprintk(KERN_CONT \"\\n\");\n\t}\n\n\tfor_each_populated_zone(zone) {\n\t\tunsigned int order;\n\t\tunsigned long nr[MAX_ORDER], flags, total = 0;\n\t\tunsigned char types[MAX_ORDER];\n\n\t\tif (show_mem_node_skip(filter, zone_to_nid(zone), nodemask))\n\t\t\tcontinue;\n\t\tshow_node(zone);\n\t\tprintk(KERN_CONT \"%s: \", zone->name);\n\n\t\tspin_lock_irqsave(&zone->lock, flags);\n\t\tfor (order = 0; order < MAX_ORDER; order++) {\n\t\t\tstruct free_area *area = &zone->free_area[order];\n\t\t\tint type;\n\n\t\t\tnr[order] = area->nr_free;\n\t\t\ttotal += nr[order] << order;\n\n\t\t\ttypes[order] = 0;\n\t\t\tfor (type = 0; type < MIGRATE_TYPES; type++) {\n\t\t\t\tif (!list_empty(&area->free_list[type]))\n\t\t\t\t\ttypes[order] |= 1 << type;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&zone->lock, flags);\n\t\tfor (order = 0; order < MAX_ORDER; order++) {\n\t\t\tprintk(KERN_CONT \"%lu*%lukB \",\n\t\t\t       nr[order], K(1UL) << order);\n\t\t\tif (nr[order])\n\t\t\t\tshow_migration_types(types[order]);\n\t\t}\n\t\tprintk(KERN_CONT \"= %lukB\\n\", K(total));\n\t}\n\n\thugetlb_show_meminfo();\n\n\tprintk(\"%ld total pagecache pages\\n\", global_node_page_state(NR_FILE_PAGES));\n\n\tshow_swap_cache_info();\n}\n\nstatic void zoneref_set_zone(struct zone *zone, struct zoneref *zoneref)\n{\n\tzoneref->zone = zone;\n\tzoneref->zone_idx = zone_idx(zone);\n}\n\n/*\n * Builds allocation fallback zone lists.\n *\n * Add all populated zones of a node to the zonelist.\n */\nstatic int build_zonerefs_node(pg_data_t *pgdat, struct zoneref *zonerefs)\n{\n\tstruct zone *zone;\n\tenum zone_type zone_type = MAX_NR_ZONES;\n\tint nr_zones = 0;\n\n\tdo {\n\t\tzone_type--;\n\t\tzone = pgdat->node_zones + zone_type;\n\t\tif (managed_zone(zone)) {\n\t\t\tzoneref_set_zone(zone, &zonerefs[nr_zones++]);\n\t\t\tcheck_highest_zone(zone_type);\n\t\t}\n\t} while (zone_type);\n\n\treturn nr_zones;\n}\n\n#ifdef CONFIG_NUMA\n\nstatic int __parse_numa_zonelist_order(char *s)\n{\n\t/*\n\t * We used to support different zonlists modes but they turned\n\t * out to be just not useful. Let's keep the warning in place\n\t * if somebody still use the cmd line parameter so that we do\n\t * not fail it silently\n\t */\n\tif (!(*s == 'd' || *s == 'D' || *s == 'n' || *s == 'N')) {\n\t\tpr_warn(\"Ignoring unsupported numa_zonelist_order value:  %s\\n\", s);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic __init int setup_numa_zonelist_order(char *s)\n{\n\tif (!s)\n\t\treturn 0;\n\n\treturn __parse_numa_zonelist_order(s);\n}\nearly_param(\"numa_zonelist_order\", setup_numa_zonelist_order);\n\nchar numa_zonelist_order[] = \"Node\";\n\n/*\n * sysctl handler for numa_zonelist_order\n */\nint numa_zonelist_order_handler(struct ctl_table *table, int write,\n\t\tvoid __user *buffer, size_t *length,\n\t\tloff_t *ppos)\n{\n\tchar *str;\n\tint ret;\n\n\tif (!write)\n\t\treturn proc_dostring(table, write, buffer, length, ppos);\n\tstr = memdup_user_nul(buffer, 16);\n\tif (IS_ERR(str))\n\t\treturn PTR_ERR(str);\n\n\tret = __parse_numa_zonelist_order(str);\n\tkfree(str);\n\treturn ret;\n}\n\n\n#define MAX_NODE_LOAD (nr_online_nodes)\nstatic int node_load[MAX_NUMNODES];\n\n/**\n * find_next_best_node - find the next node that should appear in a given node's fallback list\n * @node: node whose fallback list we're appending\n * @used_node_mask: nodemask_t of already used nodes\n *\n * We use a number of factors to determine which is the next node that should\n * appear on a given node's fallback list.  The node should not have appeared\n * already in @node's fallback list, and it should be the next closest node\n * according to the distance array (which contains arbitrary distance values\n * from each node to each node in the system), and should also prefer nodes\n * with no CPUs, since presumably they'll have very little allocation pressure\n * on them otherwise.\n * It returns -1 if no node is found.\n */\nstatic int find_next_best_node(int node, nodemask_t *used_node_mask)\n{\n\tint n, val;\n\tint min_val = INT_MAX;\n\tint best_node = NUMA_NO_NODE;\n\tconst struct cpumask *tmp = cpumask_of_node(0);\n\n\t/* Use the local node if we haven't already */\n\tif (!node_isset(node, *used_node_mask)) {\n\t\tnode_set(node, *used_node_mask);\n\t\treturn node;\n\t}\n\n\tfor_each_node_state(n, N_MEMORY) {\n\n\t\t/* Don't want a node to appear more than once */\n\t\tif (node_isset(n, *used_node_mask))\n\t\t\tcontinue;\n\n\t\t/* Use the distance array to find the distance */\n\t\tval = node_distance(node, n);\n\n\t\t/* Penalize nodes under us (\"prefer the next node\") */\n\t\tval += (n < node);\n\n\t\t/* Give preference to headless and unused nodes */\n\t\ttmp = cpumask_of_node(n);\n\t\tif (!cpumask_empty(tmp))\n\t\t\tval += PENALTY_FOR_NODE_WITH_CPUS;\n\n\t\t/* Slight preference for less loaded node */\n\t\tval *= (MAX_NODE_LOAD*MAX_NUMNODES);\n\t\tval += node_load[n];\n\n\t\tif (val < min_val) {\n\t\t\tmin_val = val;\n\t\t\tbest_node = n;\n\t\t}\n\t}\n\n\tif (best_node >= 0)\n\t\tnode_set(best_node, *used_node_mask);\n\n\treturn best_node;\n}\n\n\n/*\n * Build zonelists ordered by node and zones within node.\n * This results in maximum locality--normal zone overflows into local\n * DMA zone, if any--but risks exhausting DMA zone.\n */\nstatic void build_zonelists_in_node_order(pg_data_t *pgdat, int *node_order,\n\t\tunsigned nr_nodes)\n{\n\tstruct zoneref *zonerefs;\n\tint i;\n\n\tzonerefs = pgdat->node_zonelists[ZONELIST_FALLBACK]._zonerefs;\n\n\tfor (i = 0; i < nr_nodes; i++) {\n\t\tint nr_zones;\n\n\t\tpg_data_t *node = NODE_DATA(node_order[i]);\n\n\t\tnr_zones = build_zonerefs_node(node, zonerefs);\n\t\tzonerefs += nr_zones;\n\t}\n\tzonerefs->zone = NULL;\n\tzonerefs->zone_idx = 0;\n}\n\n/*\n * Build gfp_thisnode zonelists\n */\nstatic void build_thisnode_zonelists(pg_data_t *pgdat)\n{\n\tstruct zoneref *zonerefs;\n\tint nr_zones;\n\n\tzonerefs = pgdat->node_zonelists[ZONELIST_NOFALLBACK]._zonerefs;\n\tnr_zones = build_zonerefs_node(pgdat, zonerefs);\n\tzonerefs += nr_zones;\n\tzonerefs->zone = NULL;\n\tzonerefs->zone_idx = 0;\n}\n\n/*\n * Build zonelists ordered by zone and nodes within zones.\n * This results in conserving DMA zone[s] until all Normal memory is\n * exhausted, but results in overflowing to remote node while memory\n * may still exist in local DMA zone.\n */\n\nstatic void build_zonelists(pg_data_t *pgdat)\n{\n\tstatic int node_order[MAX_NUMNODES];\n\tint node, load, nr_nodes = 0;\n\tnodemask_t used_mask;\n\tint local_node, prev_node;\n\n\t/* NUMA-aware ordering of nodes */\n\tlocal_node = pgdat->node_id;\n\tload = nr_online_nodes;\n\tprev_node = local_node;\n\tnodes_clear(used_mask);\n\n\tmemset(node_order, 0, sizeof(node_order));\n\twhile ((node = find_next_best_node(local_node, &used_mask)) >= 0) {\n\t\t/*\n\t\t * We don't want to pressure a particular node.\n\t\t * So adding penalty to the first node in same\n\t\t * distance group to make it round-robin.\n\t\t */\n\t\tif (node_distance(local_node, node) !=\n\t\t    node_distance(local_node, prev_node))\n\t\t\tnode_load[node] = load;\n\n\t\tnode_order[nr_nodes++] = node;\n\t\tprev_node = node;\n\t\tload--;\n\t}\n\n\tbuild_zonelists_in_node_order(pgdat, node_order, nr_nodes);\n\tbuild_thisnode_zonelists(pgdat);\n}\n\n#ifdef CONFIG_HAVE_MEMORYLESS_NODES\n/*\n * Return node id of node used for \"local\" allocations.\n * I.e., first node id of first zone in arg node's generic zonelist.\n * Used for initializing percpu 'numa_mem', which is used primarily\n * for kernel allocations, so use GFP_KERNEL flags to locate zonelist.\n */\nint local_memory_node(int node)\n{\n\tstruct zoneref *z;\n\n\tz = first_zones_zonelist(node_zonelist(node, GFP_KERNEL),\n\t\t\t\t   gfp_zone(GFP_KERNEL),\n\t\t\t\t   NULL);\n\treturn zone_to_nid(z->zone);\n}\n#endif\n\nstatic void setup_min_unmapped_ratio(void);\nstatic void setup_min_slab_ratio(void);\n#else\t/* CONFIG_NUMA */\n\nstatic void build_zonelists(pg_data_t *pgdat)\n{\n\tint node, local_node;\n\tstruct zoneref *zonerefs;\n\tint nr_zones;\n\n\tlocal_node = pgdat->node_id;\n\n\tzonerefs = pgdat->node_zonelists[ZONELIST_FALLBACK]._zonerefs;\n\tnr_zones = build_zonerefs_node(pgdat, zonerefs);\n\tzonerefs += nr_zones;\n\n\t/*\n\t * Now we build the zonelist so that it contains the zones\n\t * of all the other nodes.\n\t * We don't want to pressure a particular node, so when\n\t * building the zones for node N, we make sure that the\n\t * zones coming right after the local ones are those from\n\t * node N+1 (modulo N)\n\t */\n\tfor (node = local_node + 1; node < MAX_NUMNODES; node++) {\n\t\tif (!node_online(node))\n\t\t\tcontinue;\n\t\tnr_zones = build_zonerefs_node(NODE_DATA(node), zonerefs);\n\t\tzonerefs += nr_zones;\n\t}\n\tfor (node = 0; node < local_node; node++) {\n\t\tif (!node_online(node))\n\t\t\tcontinue;\n\t\tnr_zones = build_zonerefs_node(NODE_DATA(node), zonerefs);\n\t\tzonerefs += nr_zones;\n\t}\n\n\tzonerefs->zone = NULL;\n\tzonerefs->zone_idx = 0;\n}\n\n#endif\t/* CONFIG_NUMA */\n\n/*\n * Boot pageset table. One per cpu which is going to be used for all\n * zones and all nodes. The parameters will be set in such a way\n * that an item put on a list will immediately be handed over to\n * the buddy list. This is safe since pageset manipulation is done\n * with interrupts disabled.\n *\n * The boot_pagesets must be kept even after bootup is complete for\n * unused processors and/or zones. They do play a role for bootstrapping\n * hotplugged processors.\n *\n * zoneinfo_show() and maybe other functions do\n * not check if the processor is online before following the pageset pointer.\n * Other parts of the kernel may not check if the zone is available.\n */\nstatic void setup_pageset(struct per_cpu_pageset *p, unsigned long batch);\nstatic DEFINE_PER_CPU(struct per_cpu_pageset, boot_pageset);\nstatic DEFINE_PER_CPU(struct per_cpu_nodestat, boot_nodestats);\n\nstatic void __build_all_zonelists(void *data)\n{\n\tint nid;\n\tint __maybe_unused cpu;\n\tpg_data_t *self = data;\n\tstatic DEFINE_SPINLOCK(lock);\n\n\tspin_lock(&lock);\n\n#ifdef CONFIG_NUMA\n\tmemset(node_load, 0, sizeof(node_load));\n#endif\n\n\t/*\n\t * This node is hotadded and no memory is yet present.   So just\n\t * building zonelists is fine - no need to touch other nodes.\n\t */\n\tif (self && !node_online(self->node_id)) {\n\t\tbuild_zonelists(self);\n\t} else {\n\t\tfor_each_online_node(nid) {\n\t\t\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\t\t\tbuild_zonelists(pgdat);\n\t\t}\n\n#ifdef CONFIG_HAVE_MEMORYLESS_NODES\n\t\t/*\n\t\t * We now know the \"local memory node\" for each node--\n\t\t * i.e., the node of the first zone in the generic zonelist.\n\t\t * Set up numa_mem percpu variable for on-line cpus.  During\n\t\t * boot, only the boot cpu should be on-line;  we'll init the\n\t\t * secondary cpus' numa_mem as they come on-line.  During\n\t\t * node/memory hotplug, we'll fixup all on-line cpus.\n\t\t */\n\t\tfor_each_online_cpu(cpu)\n\t\t\tset_cpu_numa_mem(cpu, local_memory_node(cpu_to_node(cpu)));\n#endif\n\t}\n\n\tspin_unlock(&lock);\n}\n\nstatic noinline void __init\nbuild_all_zonelists_init(void)\n{\n\tint cpu;\n\n\t__build_all_zonelists(NULL);\n\n\t/*\n\t * Initialize the boot_pagesets that are going to be used\n\t * for bootstrapping processors. The real pagesets for\n\t * each zone will be allocated later when the per cpu\n\t * allocator is available.\n\t *\n\t * boot_pagesets are used also for bootstrapping offline\n\t * cpus if the system is already booted because the pagesets\n\t * are needed to initialize allocators on a specific cpu too.\n\t * F.e. the percpu allocator needs the page allocator which\n\t * needs the percpu allocator in order to allocate its pagesets\n\t * (a chicken-egg dilemma).\n\t */\n\tfor_each_possible_cpu(cpu)\n\t\tsetup_pageset(&per_cpu(boot_pageset, cpu), 0);\n\n\tmminit_verify_zonelist();\n\tcpuset_init_current_mems_allowed();\n}\n\n/*\n * unless system_state == SYSTEM_BOOTING.\n *\n * __ref due to call of __init annotated helper build_all_zonelists_init\n * [protected by SYSTEM_BOOTING].\n */\nvoid __ref build_all_zonelists(pg_data_t *pgdat)\n{\n\tif (system_state == SYSTEM_BOOTING) {\n\t\tbuild_all_zonelists_init();\n\t} else {\n\t\t__build_all_zonelists(pgdat);\n\t\t/* cpuset refresh routine should be here */\n\t}\n\tvm_total_pages = nr_free_pagecache_pages();\n\t/*\n\t * Disable grouping by mobility if the number of pages in the\n\t * system is too low to allow the mechanism to work. It would be\n\t * more accurate, but expensive to check per-zone. This check is\n\t * made on memory-hotadd so a system can start with mobility\n\t * disabled and enable it later\n\t */\n\tif (vm_total_pages < (pageblock_nr_pages * MIGRATE_TYPES))\n\t\tpage_group_by_mobility_disabled = 1;\n\telse\n\t\tpage_group_by_mobility_disabled = 0;\n\n\tpr_info(\"Built %i zonelists, mobility grouping %s.  Total pages: %ld\\n\",\n\t\tnr_online_nodes,\n\t\tpage_group_by_mobility_disabled ? \"off\" : \"on\",\n\t\tvm_total_pages);\n#ifdef CONFIG_NUMA\n\tpr_info(\"Policy zone: %s\\n\", zone_names[policy_zone]);\n#endif\n}\n\n/* If zone is ZONE_MOVABLE but memory is mirrored, it is an overlapped init */\nstatic bool __meminit\noverlap_memmap_init(unsigned long zone, unsigned long *pfn)\n{\n#ifdef CONFIG_HAVE_MEMBLOCK_NODE_MAP\n\tstatic struct memblock_region *r;\n\n\tif (mirrored_kernelcore && zone == ZONE_MOVABLE) {\n\t\tif (!r || *pfn >= memblock_region_memory_end_pfn(r)) {\n\t\t\tfor_each_memblock(memory, r) {\n\t\t\t\tif (*pfn < memblock_region_memory_end_pfn(r))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (*pfn >= memblock_region_memory_base_pfn(r) &&\n\t\t    memblock_is_mirror(r)) {\n\t\t\t*pfn = memblock_region_memory_end_pfn(r);\n\t\t\treturn true;\n\t\t}\n\t}\n#endif\n\treturn false;\n}\n\n/*\n * Initially all pages are reserved - free ones are freed\n * up by memblock_free_all() once the early boot process is\n * done. Non-atomic initialization, single-pass.\n */\nvoid __meminit memmap_init_zone(unsigned long size, int nid, unsigned long zone,\n\t\tunsigned long start_pfn, enum memmap_context context,\n\t\tstruct vmem_altmap *altmap)\n{\n\tunsigned long pfn, end_pfn = start_pfn + size;\n\tstruct page *page;\n\n\tif (highest_memmap_pfn < end_pfn - 1)\n\t\thighest_memmap_pfn = end_pfn - 1;\n\n#ifdef CONFIG_ZONE_DEVICE\n\t/*\n\t * Honor reservation requested by the driver for this ZONE_DEVICE\n\t * memory. We limit the total number of pages to initialize to just\n\t * those that might contain the memory mapping. We will defer the\n\t * ZONE_DEVICE page initialization until after we have released\n\t * the hotplug lock.\n\t */\n\tif (zone == ZONE_DEVICE) {\n\t\tif (!altmap)\n\t\t\treturn;\n\n\t\tif (start_pfn == altmap->base_pfn)\n\t\t\tstart_pfn += altmap->reserve;\n\t\tend_pfn = altmap->base_pfn + vmem_altmap_offset(altmap);\n\t}\n#endif\n\n\tfor (pfn = start_pfn; pfn < end_pfn; pfn++) {\n\t\t/*\n\t\t * There can be holes in boot-time mem_map[]s handed to this\n\t\t * function.  They do not exist on hotplugged memory.\n\t\t */\n\t\tif (context == MEMMAP_EARLY) {\n\t\t\tif (!early_pfn_valid(pfn))\n\t\t\t\tcontinue;\n\t\t\tif (!early_pfn_in_nid(pfn, nid))\n\t\t\t\tcontinue;\n\t\t\tif (overlap_memmap_init(zone, &pfn))\n\t\t\t\tcontinue;\n\t\t\tif (defer_init(nid, pfn, end_pfn))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tpage = pfn_to_page(pfn);\n\t\t__init_single_page(page, pfn, zone, nid);\n\t\tif (context == MEMMAP_HOTPLUG)\n\t\t\t__SetPageReserved(page);\n\n\t\t/*\n\t\t * Mark the block movable so that blocks are reserved for\n\t\t * movable at startup. This will force kernel allocations\n\t\t * to reserve their blocks rather than leaking throughout\n\t\t * the address space during boot when many long-lived\n\t\t * kernel allocations are made.\n\t\t *\n\t\t * bitmap is created for zone's valid pfn range. but memmap\n\t\t * can be created for invalid pages (for alignment)\n\t\t * check here not to call set_pageblock_migratetype() against\n\t\t * pfn out of zone.\n\t\t */\n\t\tif (!(pfn & (pageblock_nr_pages - 1))) {\n\t\t\tset_pageblock_migratetype(page, MIGRATE_MOVABLE);\n\t\t\tcond_resched();\n\t\t}\n\t}\n}\n\n#ifdef CONFIG_ZONE_DEVICE\nvoid __ref memmap_init_zone_device(struct zone *zone,\n\t\t\t\t   unsigned long start_pfn,\n\t\t\t\t   unsigned long size,\n\t\t\t\t   struct dev_pagemap *pgmap)\n{\n\tunsigned long pfn, end_pfn = start_pfn + size;\n\tstruct pglist_data *pgdat = zone->zone_pgdat;\n\tunsigned long zone_idx = zone_idx(zone);\n\tunsigned long start = jiffies;\n\tint nid = pgdat->node_id;\n\n\tif (WARN_ON_ONCE(!pgmap || !is_dev_zone(zone)))\n\t\treturn;\n\n\t/*\n\t * The call to memmap_init_zone should have already taken care\n\t * of the pages reserved for the memmap, so we can just jump to\n\t * the end of that region and start processing the device pages.\n\t */\n\tif (pgmap->altmap_valid) {\n\t\tstruct vmem_altmap *altmap = &pgmap->altmap;\n\n\t\tstart_pfn = altmap->base_pfn + vmem_altmap_offset(altmap);\n\t\tsize = end_pfn - start_pfn;\n\t}\n\n\tfor (pfn = start_pfn; pfn < end_pfn; pfn++) {\n\t\tstruct page *page = pfn_to_page(pfn);\n\n\t\t__init_single_page(page, pfn, zone_idx, nid);\n\n\t\t/*\n\t\t * Mark page reserved as it will need to wait for onlining\n\t\t * phase for it to be fully associated with a zone.\n\t\t *\n\t\t * We can use the non-atomic __set_bit operation for setting\n\t\t * the flag as we are still initializing the pages.\n\t\t */\n\t\t__SetPageReserved(page);\n\n\t\t/*\n\t\t * ZONE_DEVICE pages union ->lru with a ->pgmap back\n\t\t * pointer and hmm_data.  It is a bug if a ZONE_DEVICE\n\t\t * page is ever freed or placed on a driver-private list.\n\t\t */\n\t\tpage->pgmap = pgmap;\n\t\tpage->hmm_data = 0;\n\n\t\t/*\n\t\t * Mark the block movable so that blocks are reserved for\n\t\t * movable at startup. This will force kernel allocations\n\t\t * to reserve their blocks rather than leaking throughout\n\t\t * the address space during boot when many long-lived\n\t\t * kernel allocations are made.\n\t\t *\n\t\t * bitmap is created for zone's valid pfn range. but memmap\n\t\t * can be created for invalid pages (for alignment)\n\t\t * check here not to call set_pageblock_migratetype() against\n\t\t * pfn out of zone.\n\t\t *\n\t\t * Please note that MEMMAP_HOTPLUG path doesn't clear memmap\n\t\t * because this is done early in sparse_add_one_section\n\t\t */\n\t\tif (!(pfn & (pageblock_nr_pages - 1))) {\n\t\t\tset_pageblock_migratetype(page, MIGRATE_MOVABLE);\n\t\t\tcond_resched();\n\t\t}\n\t}\n\n\tpr_info(\"%s initialised, %lu pages in %ums\\n\", dev_name(pgmap->dev),\n\t\tsize, jiffies_to_msecs(jiffies - start));\n}\n\n#endif\nstatic void __meminit zone_init_free_lists(struct zone *zone)\n{\n\tunsigned int order, t;\n\tfor_each_migratetype_order(order, t) {\n\t\tINIT_LIST_HEAD(&zone->free_area[order].free_list[t]);\n\t\tzone->free_area[order].nr_free = 0;\n\t}\n}\n\nvoid __meminit __weak memmap_init(unsigned long size, int nid,\n\t\t\t\t  unsigned long zone, unsigned long start_pfn)\n{\n\tmemmap_init_zone(size, nid, zone, start_pfn, MEMMAP_EARLY, NULL);\n}\n\nstatic int zone_batchsize(struct zone *zone)\n{\n#ifdef CONFIG_MMU\n\tint batch;\n\n\t/*\n\t * The per-cpu-pages pools are set to around 1000th of the\n\t * size of the zone.\n\t */\n\tbatch = zone->managed_pages / 1024;\n\t/* But no more than a meg. */\n\tif (batch * PAGE_SIZE > 1024 * 1024)\n\t\tbatch = (1024 * 1024) / PAGE_SIZE;\n\tbatch /= 4;\t\t/* We effectively *= 4 below */\n\tif (batch < 1)\n\t\tbatch = 1;\n\n\t/*\n\t * Clamp the batch to a 2^n - 1 value. Having a power\n\t * of 2 value was found to be more likely to have\n\t * suboptimal cache aliasing properties in some cases.\n\t *\n\t * For example if 2 tasks are alternately allocating\n\t * batches of pages, one task can end up with a lot\n\t * of pages of one half of the possible page colors\n\t * and the other with pages of the other colors.\n\t */\n\tbatch = rounddown_pow_of_two(batch + batch/2) - 1;\n\n\treturn batch;\n\n#else\n\t/* The deferral and batching of frees should be suppressed under NOMMU\n\t * conditions.\n\t *\n\t * The problem is that NOMMU needs to be able to allocate large chunks\n\t * of contiguous memory as there's no hardware page translation to\n\t * assemble apparent contiguous memory from discontiguous pages.\n\t *\n\t * Queueing large contiguous runs of pages for batching, however,\n\t * causes the pages to actually be freed in smaller chunks.  As there\n\t * can be a significant delay between the individual batches being\n\t * recycled, this leads to the once large chunks of space being\n\t * fragmented and becoming unavailable for high-order allocations.\n\t */\n\treturn 0;\n#endif\n}\n\n/*\n * pcp->high and pcp->batch values are related and dependent on one another:\n * ->batch must never be higher then ->high.\n * The following function updates them in a safe manner without read side\n * locking.\n *\n * Any new users of pcp->batch and pcp->high should ensure they can cope with\n * those fields changing asynchronously (acording the the above rule).\n *\n * mutex_is_locked(&pcp_batch_high_lock) required when calling this function\n * outside of boot time (or some other assurance that no concurrent updaters\n * exist).\n */\nstatic void pageset_update(struct per_cpu_pages *pcp, unsigned long high,\n\t\tunsigned long batch)\n{\n       /* start with a fail safe value for batch */\n\tpcp->batch = 1;\n\tsmp_wmb();\n\n       /* Update high, then batch, in order */\n\tpcp->high = high;\n\tsmp_wmb();\n\n\tpcp->batch = batch;\n}\n\n/* a companion to pageset_set_high() */\nstatic void pageset_set_batch(struct per_cpu_pageset *p, unsigned long batch)\n{\n\tpageset_update(&p->pcp, 6 * batch, max(1UL, 1 * batch));\n}\n\nstatic void pageset_init(struct per_cpu_pageset *p)\n{\n\tstruct per_cpu_pages *pcp;\n\tint migratetype;\n\n\tmemset(p, 0, sizeof(*p));\n\n\tpcp = &p->pcp;\n\tpcp->count = 0;\n\tfor (migratetype = 0; migratetype < MIGRATE_PCPTYPES; migratetype++)\n\t\tINIT_LIST_HEAD(&pcp->lists[migratetype]);\n}\n\nstatic void setup_pageset(struct per_cpu_pageset *p, unsigned long batch)\n{\n\tpageset_init(p);\n\tpageset_set_batch(p, batch);\n}\n\n/*\n * pageset_set_high() sets the high water mark for hot per_cpu_pagelist\n * to the value high for the pageset p.\n */\nstatic void pageset_set_high(struct per_cpu_pageset *p,\n\t\t\t\tunsigned long high)\n{\n\tunsigned long batch = max(1UL, high / 4);\n\tif ((high / 4) > (PAGE_SHIFT * 8))\n\t\tbatch = PAGE_SHIFT * 8;\n\n\tpageset_update(&p->pcp, high, batch);\n}\n\nstatic void pageset_set_high_and_batch(struct zone *zone,\n\t\t\t\t       struct per_cpu_pageset *pcp)\n{\n\tif (percpu_pagelist_fraction)\n\t\tpageset_set_high(pcp,\n\t\t\t(zone->managed_pages /\n\t\t\t\tpercpu_pagelist_fraction));\n\telse\n\t\tpageset_set_batch(pcp, zone_batchsize(zone));\n}\n\nstatic void __meminit zone_pageset_init(struct zone *zone, int cpu)\n{\n\tstruct per_cpu_pageset *pcp = per_cpu_ptr(zone->pageset, cpu);\n\n\tpageset_init(pcp);\n\tpageset_set_high_and_batch(zone, pcp);\n}\n\nvoid __meminit setup_zone_pageset(struct zone *zone)\n{\n\tint cpu;\n\tzone->pageset = alloc_percpu(struct per_cpu_pageset);\n\tfor_each_possible_cpu(cpu)\n\t\tzone_pageset_init(zone, cpu);\n}\n\n/*\n * Allocate per cpu pagesets and initialize them.\n * Before this call only boot pagesets were available.\n */\nvoid __init setup_per_cpu_pageset(void)\n{\n\tstruct pglist_data *pgdat;\n\tstruct zone *zone;\n\n\tfor_each_populated_zone(zone)\n\t\tsetup_zone_pageset(zone);\n\n\tfor_each_online_pgdat(pgdat)\n\t\tpgdat->per_cpu_nodestats =\n\t\t\talloc_percpu(struct per_cpu_nodestat);\n}\n\nstatic __meminit void zone_pcp_init(struct zone *zone)\n{\n\t/*\n\t * per cpu subsystem is not up at this point. The following code\n\t * relies on the ability of the linker to provide the\n\t * offset of a (static) per cpu variable into the per cpu area.\n\t */\n\tzone->pageset = &boot_pageset;\n\n\tif (populated_zone(zone))\n\t\tprintk(KERN_DEBUG \"  %s zone: %lu pages, LIFO batch:%u\\n\",\n\t\t\tzone->name, zone->present_pages,\n\t\t\t\t\t zone_batchsize(zone));\n}\n\nvoid __meminit init_currently_empty_zone(struct zone *zone,\n\t\t\t\t\tunsigned long zone_start_pfn,\n\t\t\t\t\tunsigned long size)\n{\n\tstruct pglist_data *pgdat = zone->zone_pgdat;\n\tint zone_idx = zone_idx(zone) + 1;\n\n\tif (zone_idx > pgdat->nr_zones)\n\t\tpgdat->nr_zones = zone_idx;\n\n\tzone->zone_start_pfn = zone_start_pfn;\n\n\tmminit_dprintk(MMINIT_TRACE, \"memmap_init\",\n\t\t\t\"Initialising map node %d zone %lu pfns %lu -> %lu\\n\",\n\t\t\tpgdat->node_id,\n\t\t\t(unsigned long)zone_idx(zone),\n\t\t\tzone_start_pfn, (zone_start_pfn + size));\n\n\tzone_init_free_lists(zone);\n\tzone->initialized = 1;\n}\n\n#ifdef CONFIG_HAVE_MEMBLOCK_NODE_MAP\n#ifndef CONFIG_HAVE_ARCH_EARLY_PFN_TO_NID\n\n/*\n * Required by SPARSEMEM. Given a PFN, return what node the PFN is on.\n */\nint __meminit __early_pfn_to_nid(unsigned long pfn,\n\t\t\t\t\tstruct mminit_pfnnid_cache *state)\n{\n\tunsigned long start_pfn, end_pfn;\n\tint nid;\n\n\tif (state->last_start <= pfn && pfn < state->last_end)\n\t\treturn state->last_nid;\n\n\tnid = memblock_search_pfn_nid(pfn, &start_pfn, &end_pfn);\n\tif (nid != -1) {\n\t\tstate->last_start = start_pfn;\n\t\tstate->last_end = end_pfn;\n\t\tstate->last_nid = nid;\n\t}\n\n\treturn nid;\n}\n#endif /* CONFIG_HAVE_ARCH_EARLY_PFN_TO_NID */\n\n/**\n * free_bootmem_with_active_regions - Call memblock_free_early_nid for each active range\n * @nid: The node to free memory on. If MAX_NUMNODES, all nodes are freed.\n * @max_low_pfn: The highest PFN that will be passed to memblock_free_early_nid\n *\n * If an architecture guarantees that all ranges registered contain no holes\n * and may be freed, this this function may be used instead of calling\n * memblock_free_early_nid() manually.\n */\nvoid __init free_bootmem_with_active_regions(int nid, unsigned long max_low_pfn)\n{\n\tunsigned long start_pfn, end_pfn;\n\tint i, this_nid;\n\n\tfor_each_mem_pfn_range(i, nid, &start_pfn, &end_pfn, &this_nid) {\n\t\tstart_pfn = min(start_pfn, max_low_pfn);\n\t\tend_pfn = min(end_pfn, max_low_pfn);\n\n\t\tif (start_pfn < end_pfn)\n\t\t\tmemblock_free_early_nid(PFN_PHYS(start_pfn),\n\t\t\t\t\t(end_pfn - start_pfn) << PAGE_SHIFT,\n\t\t\t\t\tthis_nid);\n\t}\n}\n\n/**\n * sparse_memory_present_with_active_regions - Call memory_present for each active range\n * @nid: The node to call memory_present for. If MAX_NUMNODES, all nodes will be used.\n *\n * If an architecture guarantees that all ranges registered contain no holes and may\n * be freed, this function may be used instead of calling memory_present() manually.\n */\nvoid __init sparse_memory_present_with_active_regions(int nid)\n{\n\tunsigned long start_pfn, end_pfn;\n\tint i, this_nid;\n\n\tfor_each_mem_pfn_range(i, nid, &start_pfn, &end_pfn, &this_nid)\n\t\tmemory_present(this_nid, start_pfn, end_pfn);\n}\n\n/**\n * get_pfn_range_for_nid - Return the start and end page frames for a node\n * @nid: The nid to return the range for. If MAX_NUMNODES, the min and max PFN are returned.\n * @start_pfn: Passed by reference. On return, it will have the node start_pfn.\n * @end_pfn: Passed by reference. On return, it will have the node end_pfn.\n *\n * It returns the start and end page frame of a node based on information\n * provided by memblock_set_node(). If called for a node\n * with no available memory, a warning is printed and the start and end\n * PFNs will be 0.\n */\nvoid __meminit get_pfn_range_for_nid(unsigned int nid,\n\t\t\tunsigned long *start_pfn, unsigned long *end_pfn)\n{\n\tunsigned long this_start_pfn, this_end_pfn;\n\tint i;\n\n\t*start_pfn = -1UL;\n\t*end_pfn = 0;\n\n\tfor_each_mem_pfn_range(i, nid, &this_start_pfn, &this_end_pfn, NULL) {\n\t\t*start_pfn = min(*start_pfn, this_start_pfn);\n\t\t*end_pfn = max(*end_pfn, this_end_pfn);\n\t}\n\n\tif (*start_pfn == -1UL)\n\t\t*start_pfn = 0;\n}\n\n/*\n * This finds a zone that can be used for ZONE_MOVABLE pages. The\n * assumption is made that zones within a node are ordered in monotonic\n * increasing memory addresses so that the \"highest\" populated zone is used\n */\nstatic void __init find_usable_zone_for_movable(void)\n{\n\tint zone_index;\n\tfor (zone_index = MAX_NR_ZONES - 1; zone_index >= 0; zone_index--) {\n\t\tif (zone_index == ZONE_MOVABLE)\n\t\t\tcontinue;\n\n\t\tif (arch_zone_highest_possible_pfn[zone_index] >\n\t\t\t\tarch_zone_lowest_possible_pfn[zone_index])\n\t\t\tbreak;\n\t}\n\n\tVM_BUG_ON(zone_index == -1);\n\tmovable_zone = zone_index;\n}\n\n/*\n * The zone ranges provided by the architecture do not include ZONE_MOVABLE\n * because it is sized independent of architecture. Unlike the other zones,\n * the starting point for ZONE_MOVABLE is not fixed. It may be different\n * in each node depending on the size of each node and how evenly kernelcore\n * is distributed. This helper function adjusts the zone ranges\n * provided by the architecture for a given node by using the end of the\n * highest usable zone for ZONE_MOVABLE. This preserves the assumption that\n * zones within a node are in order of monotonic increases memory addresses\n */\nstatic void __meminit adjust_zone_range_for_zone_movable(int nid,\n\t\t\t\t\tunsigned long zone_type,\n\t\t\t\t\tunsigned long node_start_pfn,\n\t\t\t\t\tunsigned long node_end_pfn,\n\t\t\t\t\tunsigned long *zone_start_pfn,\n\t\t\t\t\tunsigned long *zone_end_pfn)\n{\n\t/* Only adjust if ZONE_MOVABLE is on this node */\n\tif (zone_movable_pfn[nid]) {\n\t\t/* Size ZONE_MOVABLE */\n\t\tif (zone_type == ZONE_MOVABLE) {\n\t\t\t*zone_start_pfn = zone_movable_pfn[nid];\n\t\t\t*zone_end_pfn = min(node_end_pfn,\n\t\t\t\tarch_zone_highest_possible_pfn[movable_zone]);\n\n\t\t/* Adjust for ZONE_MOVABLE starting within this range */\n\t\t} else if (!mirrored_kernelcore &&\n\t\t\t*zone_start_pfn < zone_movable_pfn[nid] &&\n\t\t\t*zone_end_pfn > zone_movable_pfn[nid]) {\n\t\t\t*zone_end_pfn = zone_movable_pfn[nid];\n\n\t\t/* Check if this whole range is within ZONE_MOVABLE */\n\t\t} else if (*zone_start_pfn >= zone_movable_pfn[nid])\n\t\t\t*zone_start_pfn = *zone_end_pfn;\n\t}\n}\n\n/*\n * Return the number of pages a zone spans in a node, including holes\n * present_pages = zone_spanned_pages_in_node() - zone_absent_pages_in_node()\n */\nstatic unsigned long __meminit zone_spanned_pages_in_node(int nid,\n\t\t\t\t\tunsigned long zone_type,\n\t\t\t\t\tunsigned long node_start_pfn,\n\t\t\t\t\tunsigned long node_end_pfn,\n\t\t\t\t\tunsigned long *zone_start_pfn,\n\t\t\t\t\tunsigned long *zone_end_pfn,\n\t\t\t\t\tunsigned long *ignored)\n{\n\t/* When hotadd a new node from cpu_up(), the node should be empty */\n\tif (!node_start_pfn && !node_end_pfn)\n\t\treturn 0;\n\n\t/* Get the start and end of the zone */\n\t*zone_start_pfn = arch_zone_lowest_possible_pfn[zone_type];\n\t*zone_end_pfn = arch_zone_highest_possible_pfn[zone_type];\n\tadjust_zone_range_for_zone_movable(nid, zone_type,\n\t\t\t\tnode_start_pfn, node_end_pfn,\n\t\t\t\tzone_start_pfn, zone_end_pfn);\n\n\t/* Check that this node has pages within the zone's required range */\n\tif (*zone_end_pfn < node_start_pfn || *zone_start_pfn > node_end_pfn)\n\t\treturn 0;\n\n\t/* Move the zone boundaries inside the node if necessary */\n\t*zone_end_pfn = min(*zone_end_pfn, node_end_pfn);\n\t*zone_start_pfn = max(*zone_start_pfn, node_start_pfn);\n\n\t/* Return the spanned pages */\n\treturn *zone_end_pfn - *zone_start_pfn;\n}\n\n/*\n * Return the number of holes in a range on a node. If nid is MAX_NUMNODES,\n * then all holes in the requested range will be accounted for.\n */\nunsigned long __meminit __absent_pages_in_range(int nid,\n\t\t\t\tunsigned long range_start_pfn,\n\t\t\t\tunsigned long range_end_pfn)\n{\n\tunsigned long nr_absent = range_end_pfn - range_start_pfn;\n\tunsigned long start_pfn, end_pfn;\n\tint i;\n\n\tfor_each_mem_pfn_range(i, nid, &start_pfn, &end_pfn, NULL) {\n\t\tstart_pfn = clamp(start_pfn, range_start_pfn, range_end_pfn);\n\t\tend_pfn = clamp(end_pfn, range_start_pfn, range_end_pfn);\n\t\tnr_absent -= end_pfn - start_pfn;\n\t}\n\treturn nr_absent;\n}\n\n/**\n * absent_pages_in_range - Return number of page frames in holes within a range\n * @start_pfn: The start PFN to start searching for holes\n * @end_pfn: The end PFN to stop searching for holes\n *\n * It returns the number of pages frames in memory holes within a range.\n */\nunsigned long __init absent_pages_in_range(unsigned long start_pfn,\n\t\t\t\t\t\t\tunsigned long end_pfn)\n{\n\treturn __absent_pages_in_range(MAX_NUMNODES, start_pfn, end_pfn);\n}\n\n/* Return the number of page frames in holes in a zone on a node */\nstatic unsigned long __meminit zone_absent_pages_in_node(int nid,\n\t\t\t\t\tunsigned long zone_type,\n\t\t\t\t\tunsigned long node_start_pfn,\n\t\t\t\t\tunsigned long node_end_pfn,\n\t\t\t\t\tunsigned long *ignored)\n{\n\tunsigned long zone_low = arch_zone_lowest_possible_pfn[zone_type];\n\tunsigned long zone_high = arch_zone_highest_possible_pfn[zone_type];\n\tunsigned long zone_start_pfn, zone_end_pfn;\n\tunsigned long nr_absent;\n\n\t/* When hotadd a new node from cpu_up(), the node should be empty */\n\tif (!node_start_pfn && !node_end_pfn)\n\t\treturn 0;\n\n\tzone_start_pfn = clamp(node_start_pfn, zone_low, zone_high);\n\tzone_end_pfn = clamp(node_end_pfn, zone_low, zone_high);\n\n\tadjust_zone_range_for_zone_movable(nid, zone_type,\n\t\t\tnode_start_pfn, node_end_pfn,\n\t\t\t&zone_start_pfn, &zone_end_pfn);\n\tnr_absent = __absent_pages_in_range(nid, zone_start_pfn, zone_end_pfn);\n\n\t/*\n\t * ZONE_MOVABLE handling.\n\t * Treat pages to be ZONE_MOVABLE in ZONE_NORMAL as absent pages\n\t * and vice versa.\n\t */\n\tif (mirrored_kernelcore && zone_movable_pfn[nid]) {\n\t\tunsigned long start_pfn, end_pfn;\n\t\tstruct memblock_region *r;\n\n\t\tfor_each_memblock(memory, r) {\n\t\t\tstart_pfn = clamp(memblock_region_memory_base_pfn(r),\n\t\t\t\t\t  zone_start_pfn, zone_end_pfn);\n\t\t\tend_pfn = clamp(memblock_region_memory_end_pfn(r),\n\t\t\t\t\tzone_start_pfn, zone_end_pfn);\n\n\t\t\tif (zone_type == ZONE_MOVABLE &&\n\t\t\t    memblock_is_mirror(r))\n\t\t\t\tnr_absent += end_pfn - start_pfn;\n\n\t\t\tif (zone_type == ZONE_NORMAL &&\n\t\t\t    !memblock_is_mirror(r))\n\t\t\t\tnr_absent += end_pfn - start_pfn;\n\t\t}\n\t}\n\n\treturn nr_absent;\n}\n\n#else /* CONFIG_HAVE_MEMBLOCK_NODE_MAP */\nstatic inline unsigned long __meminit zone_spanned_pages_in_node(int nid,\n\t\t\t\t\tunsigned long zone_type,\n\t\t\t\t\tunsigned long node_start_pfn,\n\t\t\t\t\tunsigned long node_end_pfn,\n\t\t\t\t\tunsigned long *zone_start_pfn,\n\t\t\t\t\tunsigned long *zone_end_pfn,\n\t\t\t\t\tunsigned long *zones_size)\n{\n\tunsigned int zone;\n\n\t*zone_start_pfn = node_start_pfn;\n\tfor (zone = 0; zone < zone_type; zone++)\n\t\t*zone_start_pfn += zones_size[zone];\n\n\t*zone_end_pfn = *zone_start_pfn + zones_size[zone_type];\n\n\treturn zones_size[zone_type];\n}\n\nstatic inline unsigned long __meminit zone_absent_pages_in_node(int nid,\n\t\t\t\t\t\tunsigned long zone_type,\n\t\t\t\t\t\tunsigned long node_start_pfn,\n\t\t\t\t\t\tunsigned long node_end_pfn,\n\t\t\t\t\t\tunsigned long *zholes_size)\n{\n\tif (!zholes_size)\n\t\treturn 0;\n\n\treturn zholes_size[zone_type];\n}\n\n#endif /* CONFIG_HAVE_MEMBLOCK_NODE_MAP */\n\nstatic void __meminit calculate_node_totalpages(struct pglist_data *pgdat,\n\t\t\t\t\t\tunsigned long node_start_pfn,\n\t\t\t\t\t\tunsigned long node_end_pfn,\n\t\t\t\t\t\tunsigned long *zones_size,\n\t\t\t\t\t\tunsigned long *zholes_size)\n{\n\tunsigned long realtotalpages = 0, totalpages = 0;\n\tenum zone_type i;\n\n\tfor (i = 0; i < MAX_NR_ZONES; i++) {\n\t\tstruct zone *zone = pgdat->node_zones + i;\n\t\tunsigned long zone_start_pfn, zone_end_pfn;\n\t\tunsigned long size, real_size;\n\n\t\tsize = zone_spanned_pages_in_node(pgdat->node_id, i,\n\t\t\t\t\t\t  node_start_pfn,\n\t\t\t\t\t\t  node_end_pfn,\n\t\t\t\t\t\t  &zone_start_pfn,\n\t\t\t\t\t\t  &zone_end_pfn,\n\t\t\t\t\t\t  zones_size);\n\t\treal_size = size - zone_absent_pages_in_node(pgdat->node_id, i,\n\t\t\t\t\t\t  node_start_pfn, node_end_pfn,\n\t\t\t\t\t\t  zholes_size);\n\t\tif (size)\n\t\t\tzone->zone_start_pfn = zone_start_pfn;\n\t\telse\n\t\t\tzone->zone_start_pfn = 0;\n\t\tzone->spanned_pages = size;\n\t\tzone->present_pages = real_size;\n\n\t\ttotalpages += size;\n\t\trealtotalpages += real_size;\n\t}\n\n\tpgdat->node_spanned_pages = totalpages;\n\tpgdat->node_present_pages = realtotalpages;\n\tprintk(KERN_DEBUG \"On node %d totalpages: %lu\\n\", pgdat->node_id,\n\t\t\t\t\t\t\trealtotalpages);\n}\n\n#ifndef CONFIG_SPARSEMEM\n/*\n * Calculate the size of the zone->blockflags rounded to an unsigned long\n * Start by making sure zonesize is a multiple of pageblock_order by rounding\n * up. Then use 1 NR_PAGEBLOCK_BITS worth of bits per pageblock, finally\n * round what is now in bits to nearest long in bits, then return it in\n * bytes.\n */\nstatic unsigned long __init usemap_size(unsigned long zone_start_pfn, unsigned long zonesize)\n{\n\tunsigned long usemapsize;\n\n\tzonesize += zone_start_pfn & (pageblock_nr_pages-1);\n\tusemapsize = roundup(zonesize, pageblock_nr_pages);\n\tusemapsize = usemapsize >> pageblock_order;\n\tusemapsize *= NR_PAGEBLOCK_BITS;\n\tusemapsize = roundup(usemapsize, 8 * sizeof(unsigned long));\n\n\treturn usemapsize / 8;\n}\n\nstatic void __ref setup_usemap(struct pglist_data *pgdat,\n\t\t\t\tstruct zone *zone,\n\t\t\t\tunsigned long zone_start_pfn,\n\t\t\t\tunsigned long zonesize)\n{\n\tunsigned long usemapsize = usemap_size(zone_start_pfn, zonesize);\n\tzone->pageblock_flags = NULL;\n\tif (usemapsize)\n\t\tzone->pageblock_flags =\n\t\t\tmemblock_alloc_node_nopanic(usemapsize,\n\t\t\t\t\t\t\t pgdat->node_id);\n}\n#else\nstatic inline void setup_usemap(struct pglist_data *pgdat, struct zone *zone,\n\t\t\t\tunsigned long zone_start_pfn, unsigned long zonesize) {}\n#endif /* CONFIG_SPARSEMEM */\n\n#ifdef CONFIG_HUGETLB_PAGE_SIZE_VARIABLE\n\n/* Initialise the number of pages represented by NR_PAGEBLOCK_BITS */\nvoid __init set_pageblock_order(void)\n{\n\tunsigned int order;\n\n\t/* Check that pageblock_nr_pages has not already been setup */\n\tif (pageblock_order)\n\t\treturn;\n\n\tif (HPAGE_SHIFT > PAGE_SHIFT)\n\t\torder = HUGETLB_PAGE_ORDER;\n\telse\n\t\torder = MAX_ORDER - 1;\n\n\t/*\n\t * Assume the largest contiguous order of interest is a huge page.\n\t * This value may be variable depending on boot parameters on IA64 and\n\t * powerpc.\n\t */\n\tpageblock_order = order;\n}\n#else /* CONFIG_HUGETLB_PAGE_SIZE_VARIABLE */\n\n/*\n * When CONFIG_HUGETLB_PAGE_SIZE_VARIABLE is not set, set_pageblock_order()\n * is unused as pageblock_order is set at compile-time. See\n * include/linux/pageblock-flags.h for the values of pageblock_order based on\n * the kernel config\n */\nvoid __init set_pageblock_order(void)\n{\n}\n\n#endif /* CONFIG_HUGETLB_PAGE_SIZE_VARIABLE */\n\nstatic unsigned long __init calc_memmap_size(unsigned long spanned_pages,\n\t\t\t\t\t\tunsigned long present_pages)\n{\n\tunsigned long pages = spanned_pages;\n\n\t/*\n\t * Provide a more accurate estimation if there are holes within\n\t * the zone and SPARSEMEM is in use. If there are holes within the\n\t * zone, each populated memory region may cost us one or two extra\n\t * memmap pages due to alignment because memmap pages for each\n\t * populated regions may not be naturally aligned on page boundary.\n\t * So the (present_pages >> 4) heuristic is a tradeoff for that.\n\t */\n\tif (spanned_pages > present_pages + (present_pages >> 4) &&\n\t    IS_ENABLED(CONFIG_SPARSEMEM))\n\t\tpages = present_pages;\n\n\treturn PAGE_ALIGN(pages * sizeof(struct page)) >> PAGE_SHIFT;\n}\n\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\nstatic void pgdat_init_split_queue(struct pglist_data *pgdat)\n{\n\tspin_lock_init(&pgdat->split_queue_lock);\n\tINIT_LIST_HEAD(&pgdat->split_queue);\n\tpgdat->split_queue_len = 0;\n}\n#else\nstatic void pgdat_init_split_queue(struct pglist_data *pgdat) {}\n#endif\n\n#ifdef CONFIG_COMPACTION\nstatic void pgdat_init_kcompactd(struct pglist_data *pgdat)\n{\n\tinit_waitqueue_head(&pgdat->kcompactd_wait);\n}\n#else\nstatic void pgdat_init_kcompactd(struct pglist_data *pgdat) {}\n#endif\n\nstatic void __meminit pgdat_init_internals(struct pglist_data *pgdat)\n{\n\tpgdat_resize_init(pgdat);\n\n\tpgdat_init_split_queue(pgdat);\n\tpgdat_init_kcompactd(pgdat);\n\n\tinit_waitqueue_head(&pgdat->kswapd_wait);\n\tinit_waitqueue_head(&pgdat->pfmemalloc_wait);\n\n\tpgdat_page_ext_init(pgdat);\n\tspin_lock_init(&pgdat->lru_lock);\n\tlruvec_init(node_lruvec(pgdat));\n}\n\nstatic void __meminit zone_init_internals(struct zone *zone, enum zone_type idx, int nid,\n\t\t\t\t\t\t\tunsigned long remaining_pages)\n{\n\tzone->managed_pages = remaining_pages;\n\tzone_set_nid(zone, nid);\n\tzone->name = zone_names[idx];\n\tzone->zone_pgdat = NODE_DATA(nid);\n\tspin_lock_init(&zone->lock);\n\tzone_seqlock_init(zone);\n\tzone_pcp_init(zone);\n}\n\n/*\n * Set up the zone data structures\n * - init pgdat internals\n * - init all zones belonging to this node\n *\n * NOTE: this function is only called during memory hotplug\n */\n#ifdef CONFIG_MEMORY_HOTPLUG\nvoid __ref free_area_init_core_hotplug(int nid)\n{\n\tenum zone_type z;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tpgdat_init_internals(pgdat);\n\tfor (z = 0; z < MAX_NR_ZONES; z++)\n\t\tzone_init_internals(&pgdat->node_zones[z], z, nid, 0);\n}\n#endif\n\n/*\n * Set up the zone data structures:\n *   - mark all pages reserved\n *   - mark all memory queues empty\n *   - clear the memory bitmaps\n *\n * NOTE: pgdat should get zeroed by caller.\n * NOTE: this function is only called during early init.\n */\nstatic void __init free_area_init_core(struct pglist_data *pgdat)\n{\n\tenum zone_type j;\n\tint nid = pgdat->node_id;\n\n\tpgdat_init_internals(pgdat);\n\tpgdat->per_cpu_nodestats = &boot_nodestats;\n\n\tfor (j = 0; j < MAX_NR_ZONES; j++) {\n\t\tstruct zone *zone = pgdat->node_zones + j;\n\t\tunsigned long size, freesize, memmap_pages;\n\t\tunsigned long zone_start_pfn = zone->zone_start_pfn;\n\n\t\tsize = zone->spanned_pages;\n\t\tfreesize = zone->present_pages;\n\n\t\t/*\n\t\t * Adjust freesize so that it accounts for how much memory\n\t\t * is used by this zone for memmap. This affects the watermark\n\t\t * and per-cpu initialisations\n\t\t */\n\t\tmemmap_pages = calc_memmap_size(size, freesize);\n\t\tif (!is_highmem_idx(j)) {\n\t\t\tif (freesize >= memmap_pages) {\n\t\t\t\tfreesize -= memmap_pages;\n\t\t\t\tif (memmap_pages)\n\t\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\t       \"  %s zone: %lu pages used for memmap\\n\",\n\t\t\t\t\t       zone_names[j], memmap_pages);\n\t\t\t} else\n\t\t\t\tpr_warn(\"  %s zone: %lu pages exceeds freesize %lu\\n\",\n\t\t\t\t\tzone_names[j], memmap_pages, freesize);\n\t\t}\n\n\t\t/* Account for reserved pages */\n\t\tif (j == 0 && freesize > dma_reserve) {\n\t\t\tfreesize -= dma_reserve;\n\t\t\tprintk(KERN_DEBUG \"  %s zone: %lu pages reserved\\n\",\n\t\t\t\t\tzone_names[0], dma_reserve);\n\t\t}\n\n\t\tif (!is_highmem_idx(j))\n\t\t\tnr_kernel_pages += freesize;\n\t\t/* Charge for highmem memmap if there are enough kernel pages */\n\t\telse if (nr_kernel_pages > memmap_pages * 2)\n\t\t\tnr_kernel_pages -= memmap_pages;\n\t\tnr_all_pages += freesize;\n\n\t\t/*\n\t\t * Set an approximate value for lowmem here, it will be adjusted\n\t\t * when the bootmem allocator frees pages into the buddy system.\n\t\t * And all highmem pages will be managed by the buddy system.\n\t\t */\n\t\tzone_init_internals(zone, j, nid, freesize);\n\n\t\tif (!size)\n\t\t\tcontinue;\n\n\t\tset_pageblock_order();\n\t\tsetup_usemap(pgdat, zone, zone_start_pfn, size);\n\t\tinit_currently_empty_zone(zone, zone_start_pfn, size);\n\t\tmemmap_init(size, nid, j, zone_start_pfn);\n\t}\n}\n\n#ifdef CONFIG_FLAT_NODE_MEM_MAP\nstatic void __ref alloc_node_mem_map(struct pglist_data *pgdat)\n{\n\tunsigned long __maybe_unused start = 0;\n\tunsigned long __maybe_unused offset = 0;\n\n\t/* Skip empty nodes */\n\tif (!pgdat->node_spanned_pages)\n\t\treturn;\n\n\tstart = pgdat->node_start_pfn & ~(MAX_ORDER_NR_PAGES - 1);\n\toffset = pgdat->node_start_pfn - start;\n\t/* ia64 gets its own node_mem_map, before this, without bootmem */\n\tif (!pgdat->node_mem_map) {\n\t\tunsigned long size, end;\n\t\tstruct page *map;\n\n\t\t/*\n\t\t * The zone's endpoints aren't required to be MAX_ORDER\n\t\t * aligned but the node_mem_map endpoints must be in order\n\t\t * for the buddy allocator to function correctly.\n\t\t */\n\t\tend = pgdat_end_pfn(pgdat);\n\t\tend = ALIGN(end, MAX_ORDER_NR_PAGES);\n\t\tsize =  (end - start) * sizeof(struct page);\n\t\tmap = memblock_alloc_node_nopanic(size, pgdat->node_id);\n\t\tpgdat->node_mem_map = map + offset;\n\t}\n\tpr_debug(\"%s: node %d, pgdat %08lx, node_mem_map %08lx\\n\",\n\t\t\t\t__func__, pgdat->node_id, (unsigned long)pgdat,\n\t\t\t\t(unsigned long)pgdat->node_mem_map);\n#ifndef CONFIG_NEED_MULTIPLE_NODES\n\t/*\n\t * With no DISCONTIG, the global mem_map is just set as node 0's\n\t */\n\tif (pgdat == NODE_DATA(0)) {\n\t\tmem_map = NODE_DATA(0)->node_mem_map;\n#if defined(CONFIG_HAVE_MEMBLOCK_NODE_MAP) || defined(CONFIG_FLATMEM)\n\t\tif (page_to_pfn(mem_map) != pgdat->node_start_pfn)\n\t\t\tmem_map -= offset;\n#endif /* CONFIG_HAVE_MEMBLOCK_NODE_MAP */\n\t}\n#endif\n}\n#else\nstatic void __ref alloc_node_mem_map(struct pglist_data *pgdat) { }\n#endif /* CONFIG_FLAT_NODE_MEM_MAP */\n\n#ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT\nstatic inline void pgdat_set_deferred_range(pg_data_t *pgdat)\n{\n\t/*\n\t * We start only with one section of pages, more pages are added as\n\t * needed until the rest of deferred pages are initialized.\n\t */\n\tpgdat->static_init_pgcnt = min_t(unsigned long, PAGES_PER_SECTION,\n\t\t\t\t\t\tpgdat->node_spanned_pages);\n\tpgdat->first_deferred_pfn = ULONG_MAX;\n}\n#else\nstatic inline void pgdat_set_deferred_range(pg_data_t *pgdat) {}\n#endif\n\nvoid __init free_area_init_node(int nid, unsigned long *zones_size,\n\t\t\t\t   unsigned long node_start_pfn,\n\t\t\t\t   unsigned long *zholes_size)\n{\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\tunsigned long start_pfn = 0;\n\tunsigned long end_pfn = 0;\n\n\t/* pg_data_t should be reset to zero when it's allocated */\n\tWARN_ON(pgdat->nr_zones || pgdat->kswapd_classzone_idx);\n\n\tpgdat->node_id = nid;\n\tpgdat->node_start_pfn = node_start_pfn;\n\tpgdat->per_cpu_nodestats = NULL;\n#ifdef CONFIG_HAVE_MEMBLOCK_NODE_MAP\n\tget_pfn_range_for_nid(nid, &start_pfn, &end_pfn);\n\tpr_info(\"Initmem setup node %d [mem %#018Lx-%#018Lx]\\n\", nid,\n\t\t(u64)start_pfn << PAGE_SHIFT,\n\t\tend_pfn ? ((u64)end_pfn << PAGE_SHIFT) - 1 : 0);\n#else\n\tstart_pfn = node_start_pfn;\n#endif\n\tcalculate_node_totalpages(pgdat, start_pfn, end_pfn,\n\t\t\t\t  zones_size, zholes_size);\n\n\talloc_node_mem_map(pgdat);\n\tpgdat_set_deferred_range(pgdat);\n\n\tfree_area_init_core(pgdat);\n}\n\n#if !defined(CONFIG_FLAT_NODE_MEM_MAP)\n/*\n * Zero all valid struct pages in range [spfn, epfn), return number of struct\n * pages zeroed\n */\nstatic u64 zero_pfn_range(unsigned long spfn, unsigned long epfn)\n{\n\tunsigned long pfn;\n\tu64 pgcnt = 0;\n\n\tfor (pfn = spfn; pfn < epfn; pfn++) {\n\t\tif (!pfn_valid(ALIGN_DOWN(pfn, pageblock_nr_pages))) {\n\t\t\tpfn = ALIGN_DOWN(pfn, pageblock_nr_pages)\n\t\t\t\t+ pageblock_nr_pages - 1;\n\t\t\tcontinue;\n\t\t}\n\t\tmm_zero_struct_page(pfn_to_page(pfn));\n\t\tpgcnt++;\n\t}\n\n\treturn pgcnt;\n}\n\n/*\n * Only struct pages that are backed by physical memory are zeroed and\n * initialized by going through __init_single_page(). But, there are some\n * struct pages which are reserved in memblock allocator and their fields\n * may be accessed (for example page_to_pfn() on some configuration accesses\n * flags). We must explicitly zero those struct pages.\n *\n * This function also addresses a similar issue where struct pages are left\n * uninitialized because the physical address range is not covered by\n * memblock.memory or memblock.reserved. That could happen when memblock\n * layout is manually configured via memmap=.\n */\nvoid __init zero_resv_unavail(void)\n{\n\tphys_addr_t start, end;\n\tu64 i, pgcnt;\n\tphys_addr_t next = 0;\n\n\t/*\n\t * Loop through unavailable ranges not covered by memblock.memory.\n\t */\n\tpgcnt = 0;\n\tfor_each_mem_range(i, &memblock.memory, NULL,\n\t\t\tNUMA_NO_NODE, MEMBLOCK_NONE, &start, &end, NULL) {\n\t\tif (next < start)\n\t\t\tpgcnt += zero_pfn_range(PFN_DOWN(next), PFN_UP(start));\n\t\tnext = end;\n\t}\n\tpgcnt += zero_pfn_range(PFN_DOWN(next), max_pfn);\n\n\t/*\n\t * Struct pages that do not have backing memory. This could be because\n\t * firmware is using some of this memory, or for some other reasons.\n\t */\n\tif (pgcnt)\n\t\tpr_info(\"Zeroed struct page in unavailable ranges: %lld pages\", pgcnt);\n}\n#endif /* !CONFIG_FLAT_NODE_MEM_MAP */\n\n#ifdef CONFIG_HAVE_MEMBLOCK_NODE_MAP\n\n#if MAX_NUMNODES > 1\n/*\n * Figure out the number of possible node ids.\n */\nvoid __init setup_nr_node_ids(void)\n{\n\tunsigned int highest;\n\n\thighest = find_last_bit(node_possible_map.bits, MAX_NUMNODES);\n\tnr_node_ids = highest + 1;\n}\n#endif\n\n/**\n * node_map_pfn_alignment - determine the maximum internode alignment\n *\n * This function should be called after node map is populated and sorted.\n * It calculates the maximum power of two alignment which can distinguish\n * all the nodes.\n *\n * For example, if all nodes are 1GiB and aligned to 1GiB, the return value\n * would indicate 1GiB alignment with (1 << (30 - PAGE_SHIFT)).  If the\n * nodes are shifted by 256MiB, 256MiB.  Note that if only the last node is\n * shifted, 1GiB is enough and this function will indicate so.\n *\n * This is used to test whether pfn -> nid mapping of the chosen memory\n * model has fine enough granularity to avoid incorrect mapping for the\n * populated node map.\n *\n * Returns the determined alignment in pfn's.  0 if there is no alignment\n * requirement (single node).\n */\nunsigned long __init node_map_pfn_alignment(void)\n{\n\tunsigned long accl_mask = 0, last_end = 0;\n\tunsigned long start, end, mask;\n\tint last_nid = -1;\n\tint i, nid;\n\n\tfor_each_mem_pfn_range(i, MAX_NUMNODES, &start, &end, &nid) {\n\t\tif (!start || last_nid < 0 || last_nid == nid) {\n\t\t\tlast_nid = nid;\n\t\t\tlast_end = end;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Start with a mask granular enough to pin-point to the\n\t\t * start pfn and tick off bits one-by-one until it becomes\n\t\t * too coarse to separate the current node from the last.\n\t\t */\n\t\tmask = ~((1 << __ffs(start)) - 1);\n\t\twhile (mask && last_end <= (start & (mask << 1)))\n\t\t\tmask <<= 1;\n\n\t\t/* accumulate all internode masks */\n\t\taccl_mask |= mask;\n\t}\n\n\t/* convert mask to number of pages */\n\treturn ~accl_mask + 1;\n}\n\n/* Find the lowest pfn for a node */\nstatic unsigned long __init find_min_pfn_for_node(int nid)\n{\n\tunsigned long min_pfn = ULONG_MAX;\n\tunsigned long start_pfn;\n\tint i;\n\n\tfor_each_mem_pfn_range(i, nid, &start_pfn, NULL, NULL)\n\t\tmin_pfn = min(min_pfn, start_pfn);\n\n\tif (min_pfn == ULONG_MAX) {\n\t\tpr_warn(\"Could not find start_pfn for node %d\\n\", nid);\n\t\treturn 0;\n\t}\n\n\treturn min_pfn;\n}\n\n/**\n * find_min_pfn_with_active_regions - Find the minimum PFN registered\n *\n * It returns the minimum PFN based on information provided via\n * memblock_set_node().\n */\nunsigned long __init find_min_pfn_with_active_regions(void)\n{\n\treturn find_min_pfn_for_node(MAX_NUMNODES);\n}\n\n/*\n * early_calculate_totalpages()\n * Sum pages in active regions for movable zone.\n * Populate N_MEMORY for calculating usable_nodes.\n */\nstatic unsigned long __init early_calculate_totalpages(void)\n{\n\tunsigned long totalpages = 0;\n\tunsigned long start_pfn, end_pfn;\n\tint i, nid;\n\n\tfor_each_mem_pfn_range(i, MAX_NUMNODES, &start_pfn, &end_pfn, &nid) {\n\t\tunsigned long pages = end_pfn - start_pfn;\n\n\t\ttotalpages += pages;\n\t\tif (pages)\n\t\t\tnode_set_state(nid, N_MEMORY);\n\t}\n\treturn totalpages;\n}\n\n/*\n * Find the PFN the Movable zone begins in each node. Kernel memory\n * is spread evenly between nodes as long as the nodes have enough\n * memory. When they don't, some nodes will have more kernelcore than\n * others\n */\nstatic void __init find_zone_movable_pfns_for_nodes(void)\n{\n\tint i, nid;\n\tunsigned long usable_startpfn;\n\tunsigned long kernelcore_node, kernelcore_remaining;\n\t/* save the state before borrow the nodemask */\n\tnodemask_t saved_node_state = node_states[N_MEMORY];\n\tunsigned long totalpages = early_calculate_totalpages();\n\tint usable_nodes = nodes_weight(node_states[N_MEMORY]);\n\tstruct memblock_region *r;\n\n\t/* Need to find movable_zone earlier when movable_node is specified. */\n\tfind_usable_zone_for_movable();\n\n\t/*\n\t * If movable_node is specified, ignore kernelcore and movablecore\n\t * options.\n\t */\n\tif (movable_node_is_enabled()) {\n\t\tfor_each_memblock(memory, r) {\n\t\t\tif (!memblock_is_hotpluggable(r))\n\t\t\t\tcontinue;\n\n\t\t\tnid = r->nid;\n\n\t\t\tusable_startpfn = PFN_DOWN(r->base);\n\t\t\tzone_movable_pfn[nid] = zone_movable_pfn[nid] ?\n\t\t\t\tmin(usable_startpfn, zone_movable_pfn[nid]) :\n\t\t\t\tusable_startpfn;\n\t\t}\n\n\t\tgoto out2;\n\t}\n\n\t/*\n\t * If kernelcore=mirror is specified, ignore movablecore option\n\t */\n\tif (mirrored_kernelcore) {\n\t\tbool mem_below_4gb_not_mirrored = false;\n\n\t\tfor_each_memblock(memory, r) {\n\t\t\tif (memblock_is_mirror(r))\n\t\t\t\tcontinue;\n\n\t\t\tnid = r->nid;\n\n\t\t\tusable_startpfn = memblock_region_memory_base_pfn(r);\n\n\t\t\tif (usable_startpfn < 0x100000) {\n\t\t\t\tmem_below_4gb_not_mirrored = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tzone_movable_pfn[nid] = zone_movable_pfn[nid] ?\n\t\t\t\tmin(usable_startpfn, zone_movable_pfn[nid]) :\n\t\t\t\tusable_startpfn;\n\t\t}\n\n\t\tif (mem_below_4gb_not_mirrored)\n\t\t\tpr_warn(\"This configuration results in unmirrored kernel memory.\");\n\n\t\tgoto out2;\n\t}\n\n\t/*\n\t * If kernelcore=nn% or movablecore=nn% was specified, calculate the\n\t * amount of necessary memory.\n\t */\n\tif (required_kernelcore_percent)\n\t\trequired_kernelcore = (totalpages * 100 * required_kernelcore_percent) /\n\t\t\t\t       10000UL;\n\tif (required_movablecore_percent)\n\t\trequired_movablecore = (totalpages * 100 * required_movablecore_percent) /\n\t\t\t\t\t10000UL;\n\n\t/*\n\t * If movablecore= was specified, calculate what size of\n\t * kernelcore that corresponds so that memory usable for\n\t * any allocation type is evenly spread. If both kernelcore\n\t * and movablecore are specified, then the value of kernelcore\n\t * will be used for required_kernelcore if it's greater than\n\t * what movablecore would have allowed.\n\t */\n\tif (required_movablecore) {\n\t\tunsigned long corepages;\n\n\t\t/*\n\t\t * Round-up so that ZONE_MOVABLE is at least as large as what\n\t\t * was requested by the user\n\t\t */\n\t\trequired_movablecore =\n\t\t\troundup(required_movablecore, MAX_ORDER_NR_PAGES);\n\t\trequired_movablecore = min(totalpages, required_movablecore);\n\t\tcorepages = totalpages - required_movablecore;\n\n\t\trequired_kernelcore = max(required_kernelcore, corepages);\n\t}\n\n\t/*\n\t * If kernelcore was not specified or kernelcore size is larger\n\t * than totalpages, there is no ZONE_MOVABLE.\n\t */\n\tif (!required_kernelcore || required_kernelcore >= totalpages)\n\t\tgoto out;\n\n\t/* usable_startpfn is the lowest possible pfn ZONE_MOVABLE can be at */\n\tusable_startpfn = arch_zone_lowest_possible_pfn[movable_zone];\n\nrestart:\n\t/* Spread kernelcore memory as evenly as possible throughout nodes */\n\tkernelcore_node = required_kernelcore / usable_nodes;\n\tfor_each_node_state(nid, N_MEMORY) {\n\t\tunsigned long start_pfn, end_pfn;\n\n\t\t/*\n\t\t * Recalculate kernelcore_node if the division per node\n\t\t * now exceeds what is necessary to satisfy the requested\n\t\t * amount of memory for the kernel\n\t\t */\n\t\tif (required_kernelcore < kernelcore_node)\n\t\t\tkernelcore_node = required_kernelcore / usable_nodes;\n\n\t\t/*\n\t\t * As the map is walked, we track how much memory is usable\n\t\t * by the kernel using kernelcore_remaining. When it is\n\t\t * 0, the rest of the node is usable by ZONE_MOVABLE\n\t\t */\n\t\tkernelcore_remaining = kernelcore_node;\n\n\t\t/* Go through each range of PFNs within this node */\n\t\tfor_each_mem_pfn_range(i, nid, &start_pfn, &end_pfn, NULL) {\n\t\t\tunsigned long size_pages;\n\n\t\t\tstart_pfn = max(start_pfn, zone_movable_pfn[nid]);\n\t\t\tif (start_pfn >= end_pfn)\n\t\t\t\tcontinue;\n\n\t\t\t/* Account for what is only usable for kernelcore */\n\t\t\tif (start_pfn < usable_startpfn) {\n\t\t\t\tunsigned long kernel_pages;\n\t\t\t\tkernel_pages = min(end_pfn, usable_startpfn)\n\t\t\t\t\t\t\t\t- start_pfn;\n\n\t\t\t\tkernelcore_remaining -= min(kernel_pages,\n\t\t\t\t\t\t\tkernelcore_remaining);\n\t\t\t\trequired_kernelcore -= min(kernel_pages,\n\t\t\t\t\t\t\trequired_kernelcore);\n\n\t\t\t\t/* Continue if range is now fully accounted */\n\t\t\t\tif (end_pfn <= usable_startpfn) {\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Push zone_movable_pfn to the end so\n\t\t\t\t\t * that if we have to rebalance\n\t\t\t\t\t * kernelcore across nodes, we will\n\t\t\t\t\t * not double account here\n\t\t\t\t\t */\n\t\t\t\t\tzone_movable_pfn[nid] = end_pfn;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tstart_pfn = usable_startpfn;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The usable PFN range for ZONE_MOVABLE is from\n\t\t\t * start_pfn->end_pfn. Calculate size_pages as the\n\t\t\t * number of pages used as kernelcore\n\t\t\t */\n\t\t\tsize_pages = end_pfn - start_pfn;\n\t\t\tif (size_pages > kernelcore_remaining)\n\t\t\t\tsize_pages = kernelcore_remaining;\n\t\t\tzone_movable_pfn[nid] = start_pfn + size_pages;\n\n\t\t\t/*\n\t\t\t * Some kernelcore has been met, update counts and\n\t\t\t * break if the kernelcore for this node has been\n\t\t\t * satisfied\n\t\t\t */\n\t\t\trequired_kernelcore -= min(required_kernelcore,\n\t\t\t\t\t\t\t\tsize_pages);\n\t\t\tkernelcore_remaining -= size_pages;\n\t\t\tif (!kernelcore_remaining)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * If there is still required_kernelcore, we do another pass with one\n\t * less node in the count. This will push zone_movable_pfn[nid] further\n\t * along on the nodes that still have memory until kernelcore is\n\t * satisfied\n\t */\n\tusable_nodes--;\n\tif (usable_nodes && required_kernelcore > usable_nodes)\n\t\tgoto restart;\n\nout2:\n\t/* Align start of ZONE_MOVABLE on all nids to MAX_ORDER_NR_PAGES */\n\tfor (nid = 0; nid < MAX_NUMNODES; nid++)\n\t\tzone_movable_pfn[nid] =\n\t\t\troundup(zone_movable_pfn[nid], MAX_ORDER_NR_PAGES);\n\nout:\n\t/* restore the node_state */\n\tnode_states[N_MEMORY] = saved_node_state;\n}\n\n/* Any regular or high memory on that node ? */\nstatic void check_for_memory(pg_data_t *pgdat, int nid)\n{\n\tenum zone_type zone_type;\n\n\tfor (zone_type = 0; zone_type <= ZONE_MOVABLE - 1; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\t\tif (populated_zone(zone)) {\n\t\t\tif (IS_ENABLED(CONFIG_HIGHMEM))\n\t\t\t\tnode_set_state(nid, N_HIGH_MEMORY);\n\t\t\tif (zone_type <= ZONE_NORMAL)\n\t\t\t\tnode_set_state(nid, N_NORMAL_MEMORY);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/**\n * free_area_init_nodes - Initialise all pg_data_t and zone data\n * @max_zone_pfn: an array of max PFNs for each zone\n *\n * This will call free_area_init_node() for each active node in the system.\n * Using the page ranges provided by memblock_set_node(), the size of each\n * zone in each node and their holes is calculated. If the maximum PFN\n * between two adjacent zones match, it is assumed that the zone is empty.\n * For example, if arch_max_dma_pfn == arch_max_dma32_pfn, it is assumed\n * that arch_max_dma32_pfn has no pages. It is also assumed that a zone\n * starts where the previous one ended. For example, ZONE_DMA32 starts\n * at arch_max_dma_pfn.\n */\nvoid __init free_area_init_nodes(unsigned long *max_zone_pfn)\n{\n\tunsigned long start_pfn, end_pfn;\n\tint i, nid;\n\n\t/* Record where the zone boundaries are */\n\tmemset(arch_zone_lowest_possible_pfn, 0,\n\t\t\t\tsizeof(arch_zone_lowest_possible_pfn));\n\tmemset(arch_zone_highest_possible_pfn, 0,\n\t\t\t\tsizeof(arch_zone_highest_possible_pfn));\n\n\tstart_pfn = find_min_pfn_with_active_regions();\n\n\tfor (i = 0; i < MAX_NR_ZONES; i++) {\n\t\tif (i == ZONE_MOVABLE)\n\t\t\tcontinue;\n\n\t\tend_pfn = max(max_zone_pfn[i], start_pfn);\n\t\tarch_zone_lowest_possible_pfn[i] = start_pfn;\n\t\tarch_zone_highest_possible_pfn[i] = end_pfn;\n\n\t\tstart_pfn = end_pfn;\n\t}\n\n\t/* Find the PFNs that ZONE_MOVABLE begins at in each node */\n\tmemset(zone_movable_pfn, 0, sizeof(zone_movable_pfn));\n\tfind_zone_movable_pfns_for_nodes();\n\n\t/* Print out the zone ranges */\n\tpr_info(\"Zone ranges:\\n\");\n\tfor (i = 0; i < MAX_NR_ZONES; i++) {\n\t\tif (i == ZONE_MOVABLE)\n\t\t\tcontinue;\n\t\tpr_info(\"  %-8s \", zone_names[i]);\n\t\tif (arch_zone_lowest_possible_pfn[i] ==\n\t\t\t\tarch_zone_highest_possible_pfn[i])\n\t\t\tpr_cont(\"empty\\n\");\n\t\telse\n\t\t\tpr_cont(\"[mem %#018Lx-%#018Lx]\\n\",\n\t\t\t\t(u64)arch_zone_lowest_possible_pfn[i]\n\t\t\t\t\t<< PAGE_SHIFT,\n\t\t\t\t((u64)arch_zone_highest_possible_pfn[i]\n\t\t\t\t\t<< PAGE_SHIFT) - 1);\n\t}\n\n\t/* Print out the PFNs ZONE_MOVABLE begins at in each node */\n\tpr_info(\"Movable zone start for each node\\n\");\n\tfor (i = 0; i < MAX_NUMNODES; i++) {\n\t\tif (zone_movable_pfn[i])\n\t\t\tpr_info(\"  Node %d: %#018Lx\\n\", i,\n\t\t\t       (u64)zone_movable_pfn[i] << PAGE_SHIFT);\n\t}\n\n\t/* Print out the early node map */\n\tpr_info(\"Early memory node ranges\\n\");\n\tfor_each_mem_pfn_range(i, MAX_NUMNODES, &start_pfn, &end_pfn, &nid)\n\t\tpr_info(\"  node %3d: [mem %#018Lx-%#018Lx]\\n\", nid,\n\t\t\t(u64)start_pfn << PAGE_SHIFT,\n\t\t\t((u64)end_pfn << PAGE_SHIFT) - 1);\n\n\t/* Initialise every node */\n\tmminit_verify_pageflags_layout();\n\tsetup_nr_node_ids();\n\tzero_resv_unavail();\n\tfor_each_online_node(nid) {\n\t\tpg_data_t *pgdat = NODE_DATA(nid);\n\t\tfree_area_init_node(nid, NULL,\n\t\t\t\tfind_min_pfn_for_node(nid), NULL);\n\n\t\t/* Any memory on that node */\n\t\tif (pgdat->node_present_pages)\n\t\t\tnode_set_state(nid, N_MEMORY);\n\t\tcheck_for_memory(pgdat, nid);\n\t}\n}\n\nstatic int __init cmdline_parse_core(char *p, unsigned long *core,\n\t\t\t\t     unsigned long *percent)\n{\n\tunsigned long long coremem;\n\tchar *endptr;\n\n\tif (!p)\n\t\treturn -EINVAL;\n\n\t/* Value may be a percentage of total memory, otherwise bytes */\n\tcoremem = simple_strtoull(p, &endptr, 0);\n\tif (*endptr == '%') {\n\t\t/* Paranoid check for percent values greater than 100 */\n\t\tWARN_ON(coremem > 100);\n\n\t\t*percent = coremem;\n\t} else {\n\t\tcoremem = memparse(p, &p);\n\t\t/* Paranoid check that UL is enough for the coremem value */\n\t\tWARN_ON((coremem >> PAGE_SHIFT) > ULONG_MAX);\n\n\t\t*core = coremem >> PAGE_SHIFT;\n\t\t*percent = 0UL;\n\t}\n\treturn 0;\n}\n\n/*\n * kernelcore=size sets the amount of memory for use for allocations that\n * cannot be reclaimed or migrated.\n */\nstatic int __init cmdline_parse_kernelcore(char *p)\n{\n\t/* parse kernelcore=mirror */\n\tif (parse_option_str(p, \"mirror\")) {\n\t\tmirrored_kernelcore = true;\n\t\treturn 0;\n\t}\n\n\treturn cmdline_parse_core(p, &required_kernelcore,\n\t\t\t\t  &required_kernelcore_percent);\n}\n\n/*\n * movablecore=size sets the amount of memory for use for allocations that\n * can be reclaimed or migrated.\n */\nstatic int __init cmdline_parse_movablecore(char *p)\n{\n\treturn cmdline_parse_core(p, &required_movablecore,\n\t\t\t\t  &required_movablecore_percent);\n}\n\nearly_param(\"kernelcore\", cmdline_parse_kernelcore);\nearly_param(\"movablecore\", cmdline_parse_movablecore);\n\n#endif /* CONFIG_HAVE_MEMBLOCK_NODE_MAP */\n\nvoid adjust_managed_page_count(struct page *page, long count)\n{\n\tspin_lock(&managed_page_count_lock);\n\tpage_zone(page)->managed_pages += count;\n\ttotalram_pages += count;\n#ifdef CONFIG_HIGHMEM\n\tif (PageHighMem(page))\n\t\ttotalhigh_pages += count;\n#endif\n\tspin_unlock(&managed_page_count_lock);\n}\nEXPORT_SYMBOL(adjust_managed_page_count);\n\nunsigned long free_reserved_area(void *start, void *end, int poison, char *s)\n{\n\tvoid *pos;\n\tunsigned long pages = 0;\n\n\tstart = (void *)PAGE_ALIGN((unsigned long)start);\n\tend = (void *)((unsigned long)end & PAGE_MASK);\n\tfor (pos = start; pos < end; pos += PAGE_SIZE, pages++) {\n\t\tstruct page *page = virt_to_page(pos);\n\t\tvoid *direct_map_addr;\n\n\t\t/*\n\t\t * 'direct_map_addr' might be different from 'pos'\n\t\t * because some architectures' virt_to_page()\n\t\t * work with aliases.  Getting the direct map\n\t\t * address ensures that we get a _writeable_\n\t\t * alias for the memset().\n\t\t */\n\t\tdirect_map_addr = page_address(page);\n\t\tif ((unsigned int)poison <= 0xFF)\n\t\t\tmemset(direct_map_addr, poison, PAGE_SIZE);\n\n\t\tfree_reserved_page(page);\n\t}\n\n\tif (pages && s)\n\t\tpr_info(\"Freeing %s memory: %ldK\\n\",\n\t\t\ts, pages << (PAGE_SHIFT - 10));\n\n\treturn pages;\n}\nEXPORT_SYMBOL(free_reserved_area);\n\n#ifdef\tCONFIG_HIGHMEM\nvoid free_highmem_page(struct page *page)\n{\n\t__free_reserved_page(page);\n\ttotalram_pages++;\n\tpage_zone(page)->managed_pages++;\n\ttotalhigh_pages++;\n}\n#endif\n\n\nvoid __init mem_init_print_info(const char *str)\n{\n\tunsigned long physpages, codesize, datasize, rosize, bss_size;\n\tunsigned long init_code_size, init_data_size;\n\n\tphyspages = get_num_physpages();\n\tcodesize = _etext - _stext;\n\tdatasize = _edata - _sdata;\n\trosize = __end_rodata - __start_rodata;\n\tbss_size = __bss_stop - __bss_start;\n\tinit_data_size = __init_end - __init_begin;\n\tinit_code_size = _einittext - _sinittext;\n\n\t/*\n\t * Detect special cases and adjust section sizes accordingly:\n\t * 1) .init.* may be embedded into .data sections\n\t * 2) .init.text.* may be out of [__init_begin, __init_end],\n\t *    please refer to arch/tile/kernel/vmlinux.lds.S.\n\t * 3) .rodata.* may be embedded into .text or .data sections.\n\t */\n#define adj_init_size(start, end, size, pos, adj) \\\n\tdo { \\\n\t\tif (start <= pos && pos < end && size > adj) \\\n\t\t\tsize -= adj; \\\n\t} while (0)\n\n\tadj_init_size(__init_begin, __init_end, init_data_size,\n\t\t     _sinittext, init_code_size);\n\tadj_init_size(_stext, _etext, codesize, _sinittext, init_code_size);\n\tadj_init_size(_sdata, _edata, datasize, __init_begin, init_data_size);\n\tadj_init_size(_stext, _etext, codesize, __start_rodata, rosize);\n\tadj_init_size(_sdata, _edata, datasize, __start_rodata, rosize);\n\n#undef\tadj_init_size\n\n\tpr_info(\"Memory: %luK/%luK available (%luK kernel code, %luK rwdata, %luK rodata, %luK init, %luK bss, %luK reserved, %luK cma-reserved\"\n#ifdef\tCONFIG_HIGHMEM\n\t\t\", %luK highmem\"\n#endif\n\t\t\"%s%s)\\n\",\n\t\tnr_free_pages() << (PAGE_SHIFT - 10),\n\t\tphyspages << (PAGE_SHIFT - 10),\n\t\tcodesize >> 10, datasize >> 10, rosize >> 10,\n\t\t(init_data_size + init_code_size) >> 10, bss_size >> 10,\n\t\t(physpages - totalram_pages - totalcma_pages) << (PAGE_SHIFT - 10),\n\t\ttotalcma_pages << (PAGE_SHIFT - 10),\n#ifdef\tCONFIG_HIGHMEM\n\t\ttotalhigh_pages << (PAGE_SHIFT - 10),\n#endif\n\t\tstr ? \", \" : \"\", str ? str : \"\");\n}\n\n/**\n * set_dma_reserve - set the specified number of pages reserved in the first zone\n * @new_dma_reserve: The number of pages to mark reserved\n *\n * The per-cpu batchsize and zone watermarks are determined by managed_pages.\n * In the DMA zone, a significant percentage may be consumed by kernel image\n * and other unfreeable allocations which can skew the watermarks badly. This\n * function may optionally be used to account for unfreeable pages in the\n * first zone (e.g., ZONE_DMA). The effect will be lower watermarks and\n * smaller per-cpu batchsize.\n */\nvoid __init set_dma_reserve(unsigned long new_dma_reserve)\n{\n\tdma_reserve = new_dma_reserve;\n}\n\nvoid __init free_area_init(unsigned long *zones_size)\n{\n\tzero_resv_unavail();\n\tfree_area_init_node(0, zones_size,\n\t\t\t__pa(PAGE_OFFSET) >> PAGE_SHIFT, NULL);\n}\n\nstatic int page_alloc_cpu_dead(unsigned int cpu)\n{\n\n\tlru_add_drain_cpu(cpu);\n\tdrain_pages(cpu);\n\n\t/*\n\t * Spill the event counters of the dead processor\n\t * into the current processors event counters.\n\t * This artificially elevates the count of the current\n\t * processor.\n\t */\n\tvm_events_fold_cpu(cpu);\n\n\t/*\n\t * Zero the differential counters of the dead processor\n\t * so that the vm statistics are consistent.\n\t *\n\t * This is only okay since the processor is dead and cannot\n\t * race with what we are doing.\n\t */\n\tcpu_vm_stats_fold(cpu);\n\treturn 0;\n}\n\nvoid __init page_alloc_init(void)\n{\n\tint ret;\n\n\tret = cpuhp_setup_state_nocalls(CPUHP_PAGE_ALLOC_DEAD,\n\t\t\t\t\t\"mm/page_alloc:dead\", NULL,\n\t\t\t\t\tpage_alloc_cpu_dead);\n\tWARN_ON(ret < 0);\n}\n\n/*\n * calculate_totalreserve_pages - called when sysctl_lowmem_reserve_ratio\n *\tor min_free_kbytes changes.\n */\nstatic void calculate_totalreserve_pages(void)\n{\n\tstruct pglist_data *pgdat;\n\tunsigned long reserve_pages = 0;\n\tenum zone_type i, j;\n\n\tfor_each_online_pgdat(pgdat) {\n\n\t\tpgdat->totalreserve_pages = 0;\n\n\t\tfor (i = 0; i < MAX_NR_ZONES; i++) {\n\t\t\tstruct zone *zone = pgdat->node_zones + i;\n\t\t\tlong max = 0;\n\n\t\t\t/* Find valid and maximum lowmem_reserve in the zone */\n\t\t\tfor (j = i; j < MAX_NR_ZONES; j++) {\n\t\t\t\tif (zone->lowmem_reserve[j] > max)\n\t\t\t\t\tmax = zone->lowmem_reserve[j];\n\t\t\t}\n\n\t\t\t/* we treat the high watermark as reserved pages. */\n\t\t\tmax += high_wmark_pages(zone);\n\n\t\t\tif (max > zone->managed_pages)\n\t\t\t\tmax = zone->managed_pages;\n\n\t\t\tpgdat->totalreserve_pages += max;\n\n\t\t\treserve_pages += max;\n\t\t}\n\t}\n\ttotalreserve_pages = reserve_pages;\n}\n\n/*\n * setup_per_zone_lowmem_reserve - called whenever\n *\tsysctl_lowmem_reserve_ratio changes.  Ensures that each zone\n *\thas a correct pages reserved value, so an adequate number of\n *\tpages are left in the zone after a successful __alloc_pages().\n */\nstatic void setup_per_zone_lowmem_reserve(void)\n{\n\tstruct pglist_data *pgdat;\n\tenum zone_type j, idx;\n\n\tfor_each_online_pgdat(pgdat) {\n\t\tfor (j = 0; j < MAX_NR_ZONES; j++) {\n\t\t\tstruct zone *zone = pgdat->node_zones + j;\n\t\t\tunsigned long managed_pages = zone->managed_pages;\n\n\t\t\tzone->lowmem_reserve[j] = 0;\n\n\t\t\tidx = j;\n\t\t\twhile (idx) {\n\t\t\t\tstruct zone *lower_zone;\n\n\t\t\t\tidx--;\n\t\t\t\tlower_zone = pgdat->node_zones + idx;\n\n\t\t\t\tif (sysctl_lowmem_reserve_ratio[idx] < 1) {\n\t\t\t\t\tsysctl_lowmem_reserve_ratio[idx] = 0;\n\t\t\t\t\tlower_zone->lowmem_reserve[j] = 0;\n\t\t\t\t} else {\n\t\t\t\t\tlower_zone->lowmem_reserve[j] =\n\t\t\t\t\t\tmanaged_pages / sysctl_lowmem_reserve_ratio[idx];\n\t\t\t\t}\n\t\t\t\tmanaged_pages += lower_zone->managed_pages;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* update totalreserve_pages */\n\tcalculate_totalreserve_pages();\n}\n\nstatic void __setup_per_zone_wmarks(void)\n{\n\tunsigned long pages_min = min_free_kbytes >> (PAGE_SHIFT - 10);\n\tunsigned long lowmem_pages = 0;\n\tstruct zone *zone;\n\tunsigned long flags;\n\n\t/* Calculate total number of !ZONE_HIGHMEM pages */\n\tfor_each_zone(zone) {\n\t\tif (!is_highmem(zone))\n\t\t\tlowmem_pages += zone->managed_pages;\n\t}\n\n\tfor_each_zone(zone) {\n\t\tu64 tmp;\n\n\t\tspin_lock_irqsave(&zone->lock, flags);\n\t\ttmp = (u64)pages_min * zone->managed_pages;\n\t\tdo_div(tmp, lowmem_pages);\n\t\tif (is_highmem(zone)) {\n\t\t\t/*\n\t\t\t * __GFP_HIGH and PF_MEMALLOC allocations usually don't\n\t\t\t * need highmem pages, so cap pages_min to a small\n\t\t\t * value here.\n\t\t\t *\n\t\t\t * The WMARK_HIGH-WMARK_LOW and (WMARK_LOW-WMARK_MIN)\n\t\t\t * deltas control asynch page reclaim, and so should\n\t\t\t * not be capped for highmem.\n\t\t\t */\n\t\t\tunsigned long min_pages;\n\n\t\t\tmin_pages = zone->managed_pages / 1024;\n\t\t\tmin_pages = clamp(min_pages, SWAP_CLUSTER_MAX, 128UL);\n\t\t\tzone->watermark[WMARK_MIN] = min_pages;\n\t\t} else {\n\t\t\t/*\n\t\t\t * If it's a lowmem zone, reserve a number of pages\n\t\t\t * proportionate to the zone's size.\n\t\t\t */\n\t\t\tzone->watermark[WMARK_MIN] = tmp;\n\t\t}\n\n\t\t/*\n\t\t * Set the kswapd watermarks distance according to the\n\t\t * scale factor in proportion to available memory, but\n\t\t * ensure a minimum size on small systems.\n\t\t */\n\t\ttmp = max_t(u64, tmp >> 2,\n\t\t\t    mult_frac(zone->managed_pages,\n\t\t\t\t      watermark_scale_factor, 10000));\n\n\t\tzone->watermark[WMARK_LOW]  = min_wmark_pages(zone) + tmp;\n\t\tzone->watermark[WMARK_HIGH] = min_wmark_pages(zone) + tmp * 2;\n\n\t\tspin_unlock_irqrestore(&zone->lock, flags);\n\t}\n\n\t/* update totalreserve_pages */\n\tcalculate_totalreserve_pages();\n}\n\n/**\n * setup_per_zone_wmarks - called when min_free_kbytes changes\n * or when memory is hot-{added|removed}\n *\n * Ensures that the watermark[min,low,high] values for each zone are set\n * correctly with respect to min_free_kbytes.\n */\nvoid setup_per_zone_wmarks(void)\n{\n\tstatic DEFINE_SPINLOCK(lock);\n\n\tspin_lock(&lock);\n\t__setup_per_zone_wmarks();\n\tspin_unlock(&lock);\n}\n\n/*\n * Initialise min_free_kbytes.\n *\n * For small machines we want it small (128k min).  For large machines\n * we want it large (64MB max).  But it is not linear, because network\n * bandwidth does not increase linearly with machine size.  We use\n *\n *\tmin_free_kbytes = 4 * sqrt(lowmem_kbytes), for better accuracy:\n *\tmin_free_kbytes = sqrt(lowmem_kbytes * 16)\n *\n * which yields\n *\n * 16MB:\t512k\n * 32MB:\t724k\n * 64MB:\t1024k\n * 128MB:\t1448k\n * 256MB:\t2048k\n * 512MB:\t2896k\n * 1024MB:\t4096k\n * 2048MB:\t5792k\n * 4096MB:\t8192k\n * 8192MB:\t11584k\n * 16384MB:\t16384k\n */\nint __meminit init_per_zone_wmark_min(void)\n{\n\tunsigned long lowmem_kbytes;\n\tint new_min_free_kbytes;\n\n\tlowmem_kbytes = nr_free_buffer_pages() * (PAGE_SIZE >> 10);\n\tnew_min_free_kbytes = int_sqrt(lowmem_kbytes * 16);\n\n\tif (new_min_free_kbytes > user_min_free_kbytes) {\n\t\tmin_free_kbytes = new_min_free_kbytes;\n\t\tif (min_free_kbytes < 128)\n\t\t\tmin_free_kbytes = 128;\n\t\tif (min_free_kbytes > 65536)\n\t\t\tmin_free_kbytes = 65536;\n\t} else {\n\t\tpr_warn(\"min_free_kbytes is not updated to %d because user defined value %d is preferred\\n\",\n\t\t\t\tnew_min_free_kbytes, user_min_free_kbytes);\n\t}\n\tsetup_per_zone_wmarks();\n\trefresh_zone_stat_thresholds();\n\tsetup_per_zone_lowmem_reserve();\n\n#ifdef CONFIG_NUMA\n\tsetup_min_unmapped_ratio();\n\tsetup_min_slab_ratio();\n#endif\n\n\treturn 0;\n}\ncore_initcall(init_per_zone_wmark_min)\n\n/*\n * min_free_kbytes_sysctl_handler - just a wrapper around proc_dointvec() so\n *\tthat we can call two helper functions whenever min_free_kbytes\n *\tchanges.\n */\nint min_free_kbytes_sysctl_handler(struct ctl_table *table, int write,\n\tvoid __user *buffer, size_t *length, loff_t *ppos)\n{\n\tint rc;\n\n\trc = proc_dointvec_minmax(table, write, buffer, length, ppos);\n\tif (rc)\n\t\treturn rc;\n\n\tif (write) {\n\t\tuser_min_free_kbytes = min_free_kbytes;\n\t\tsetup_per_zone_wmarks();\n\t}\n\treturn 0;\n}\n\nint watermark_scale_factor_sysctl_handler(struct ctl_table *table, int write,\n\tvoid __user *buffer, size_t *length, loff_t *ppos)\n{\n\tint rc;\n\n\trc = proc_dointvec_minmax(table, write, buffer, length, ppos);\n\tif (rc)\n\t\treturn rc;\n\n\tif (write)\n\t\tsetup_per_zone_wmarks();\n\n\treturn 0;\n}\n\n#ifdef CONFIG_NUMA\nstatic void setup_min_unmapped_ratio(void)\n{\n\tpg_data_t *pgdat;\n\tstruct zone *zone;\n\n\tfor_each_online_pgdat(pgdat)\n\t\tpgdat->min_unmapped_pages = 0;\n\n\tfor_each_zone(zone)\n\t\tzone->zone_pgdat->min_unmapped_pages += (zone->managed_pages *\n\t\t\t\tsysctl_min_unmapped_ratio) / 100;\n}\n\n\nint sysctl_min_unmapped_ratio_sysctl_handler(struct ctl_table *table, int write,\n\tvoid __user *buffer, size_t *length, loff_t *ppos)\n{\n\tint rc;\n\n\trc = proc_dointvec_minmax(table, write, buffer, length, ppos);\n\tif (rc)\n\t\treturn rc;\n\n\tsetup_min_unmapped_ratio();\n\n\treturn 0;\n}\n\nstatic void setup_min_slab_ratio(void)\n{\n\tpg_data_t *pgdat;\n\tstruct zone *zone;\n\n\tfor_each_online_pgdat(pgdat)\n\t\tpgdat->min_slab_pages = 0;\n\n\tfor_each_zone(zone)\n\t\tzone->zone_pgdat->min_slab_pages += (zone->managed_pages *\n\t\t\t\tsysctl_min_slab_ratio) / 100;\n}\n\nint sysctl_min_slab_ratio_sysctl_handler(struct ctl_table *table, int write,\n\tvoid __user *buffer, size_t *length, loff_t *ppos)\n{\n\tint rc;\n\n\trc = proc_dointvec_minmax(table, write, buffer, length, ppos);\n\tif (rc)\n\t\treturn rc;\n\n\tsetup_min_slab_ratio();\n\n\treturn 0;\n}\n#endif\n\n/*\n * lowmem_reserve_ratio_sysctl_handler - just a wrapper around\n *\tproc_dointvec() so that we can call setup_per_zone_lowmem_reserve()\n *\twhenever sysctl_lowmem_reserve_ratio changes.\n *\n * The reserve ratio obviously has absolutely no relation with the\n * minimum watermarks. The lowmem reserve ratio can only make sense\n * if in function of the boot time zone sizes.\n */\nint lowmem_reserve_ratio_sysctl_handler(struct ctl_table *table, int write,\n\tvoid __user *buffer, size_t *length, loff_t *ppos)\n{\n\tproc_dointvec_minmax(table, write, buffer, length, ppos);\n\tsetup_per_zone_lowmem_reserve();\n\treturn 0;\n}\n\n/*\n * percpu_pagelist_fraction - changes the pcp->high for each zone on each\n * cpu.  It is the fraction of total pages in each zone that a hot per cpu\n * pagelist can have before it gets flushed back to buddy allocator.\n */\nint percpu_pagelist_fraction_sysctl_handler(struct ctl_table *table, int write,\n\tvoid __user *buffer, size_t *length, loff_t *ppos)\n{\n\tstruct zone *zone;\n\tint old_percpu_pagelist_fraction;\n\tint ret;\n\n\tmutex_lock(&pcp_batch_high_lock);\n\told_percpu_pagelist_fraction = percpu_pagelist_fraction;\n\n\tret = proc_dointvec_minmax(table, write, buffer, length, ppos);\n\tif (!write || ret < 0)\n\t\tgoto out;\n\n\t/* Sanity checking to avoid pcp imbalance */\n\tif (percpu_pagelist_fraction &&\n\t    percpu_pagelist_fraction < MIN_PERCPU_PAGELIST_FRACTION) {\n\t\tpercpu_pagelist_fraction = old_percpu_pagelist_fraction;\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* No change? */\n\tif (percpu_pagelist_fraction == old_percpu_pagelist_fraction)\n\t\tgoto out;\n\n\tfor_each_populated_zone(zone) {\n\t\tunsigned int cpu;\n\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tpageset_set_high_and_batch(zone,\n\t\t\t\t\tper_cpu_ptr(zone->pageset, cpu));\n\t}\nout:\n\tmutex_unlock(&pcp_batch_high_lock);\n\treturn ret;\n}\n\n#ifdef CONFIG_NUMA\nint hashdist = HASHDIST_DEFAULT;\n\nstatic int __init set_hashdist(char *str)\n{\n\tif (!str)\n\t\treturn 0;\n\thashdist = simple_strtoul(str, &str, 0);\n\treturn 1;\n}\n__setup(\"hashdist=\", set_hashdist);\n#endif\n\n#ifndef __HAVE_ARCH_RESERVED_KERNEL_PAGES\n/*\n * Returns the number of pages that arch has reserved but\n * is not known to alloc_large_system_hash().\n */\nstatic unsigned long __init arch_reserved_kernel_pages(void)\n{\n\treturn 0;\n}\n#endif\n\n/*\n * Adaptive scale is meant to reduce sizes of hash tables on large memory\n * machines. As memory size is increased the scale is also increased but at\n * slower pace.  Starting from ADAPT_SCALE_BASE (64G), every time memory\n * quadruples the scale is increased by one, which means the size of hash table\n * only doubles, instead of quadrupling as well.\n * Because 32-bit systems cannot have large physical memory, where this scaling\n * makes sense, it is disabled on such platforms.\n */\n#if __BITS_PER_LONG > 32\n#define ADAPT_SCALE_BASE\t(64ul << 30)\n#define ADAPT_SCALE_SHIFT\t2\n#define ADAPT_SCALE_NPAGES\t(ADAPT_SCALE_BASE >> PAGE_SHIFT)\n#endif\n\n/*\n * allocate a large system hash table from bootmem\n * - it is assumed that the hash table must contain an exact power-of-2\n *   quantity of entries\n * - limit is the number of hash buckets, not the total allocation size\n */\nvoid *__init alloc_large_system_hash(const char *tablename,\n\t\t\t\t     unsigned long bucketsize,\n\t\t\t\t     unsigned long numentries,\n\t\t\t\t     int scale,\n\t\t\t\t     int flags,\n\t\t\t\t     unsigned int *_hash_shift,\n\t\t\t\t     unsigned int *_hash_mask,\n\t\t\t\t     unsigned long low_limit,\n\t\t\t\t     unsigned long high_limit)\n{\n\tunsigned long long max = high_limit;\n\tunsigned long log2qty, size;\n\tvoid *table = NULL;\n\tgfp_t gfp_flags;\n\n\t/* allow the kernel cmdline to have a say */\n\tif (!numentries) {\n\t\t/* round applicable memory size up to nearest megabyte */\n\t\tnumentries = nr_kernel_pages;\n\t\tnumentries -= arch_reserved_kernel_pages();\n\n\t\t/* It isn't necessary when PAGE_SIZE >= 1MB */\n\t\tif (PAGE_SHIFT < 20)\n\t\t\tnumentries = round_up(numentries, (1<<20)/PAGE_SIZE);\n\n#if __BITS_PER_LONG > 32\n\t\tif (!high_limit) {\n\t\t\tunsigned long adapt;\n\n\t\t\tfor (adapt = ADAPT_SCALE_NPAGES; adapt < numentries;\n\t\t\t     adapt <<= ADAPT_SCALE_SHIFT)\n\t\t\t\tscale++;\n\t\t}\n#endif\n\n\t\t/* limit to 1 bucket per 2^scale bytes of low memory */\n\t\tif (scale > PAGE_SHIFT)\n\t\t\tnumentries >>= (scale - PAGE_SHIFT);\n\t\telse\n\t\t\tnumentries <<= (PAGE_SHIFT - scale);\n\n\t\t/* Make sure we've got at least a 0-order allocation.. */\n\t\tif (unlikely(flags & HASH_SMALL)) {\n\t\t\t/* Makes no sense without HASH_EARLY */\n\t\t\tWARN_ON(!(flags & HASH_EARLY));\n\t\t\tif (!(numentries >> *_hash_shift)) {\n\t\t\t\tnumentries = 1UL << *_hash_shift;\n\t\t\t\tBUG_ON(!numentries);\n\t\t\t}\n\t\t} else if (unlikely((numentries * bucketsize) < PAGE_SIZE))\n\t\t\tnumentries = PAGE_SIZE / bucketsize;\n\t}\n\tnumentries = roundup_pow_of_two(numentries);\n\n\t/* limit allocation size to 1/16 total memory by default */\n\tif (max == 0) {\n\t\tmax = ((unsigned long long)nr_all_pages << PAGE_SHIFT) >> 4;\n\t\tdo_div(max, bucketsize);\n\t}\n\tmax = min(max, 0x80000000ULL);\n\n\tif (numentries < low_limit)\n\t\tnumentries = low_limit;\n\tif (numentries > max)\n\t\tnumentries = max;\n\n\tlog2qty = ilog2(numentries);\n\n\tgfp_flags = (flags & HASH_ZERO) ? GFP_ATOMIC | __GFP_ZERO : GFP_ATOMIC;\n\tdo {\n\t\tsize = bucketsize << log2qty;\n\t\tif (flags & HASH_EARLY) {\n\t\t\tif (flags & HASH_ZERO)\n\t\t\t\ttable = memblock_alloc_nopanic(size,\n\t\t\t\t\t\t\t       SMP_CACHE_BYTES);\n\t\t\telse\n\t\t\t\ttable = memblock_alloc_raw(size,\n\t\t\t\t\t\t\t   SMP_CACHE_BYTES);\n\t\t} else if (hashdist) {\n\t\t\ttable = __vmalloc(size, gfp_flags, PAGE_KERNEL);\n\t\t} else {\n\t\t\t/*\n\t\t\t * If bucketsize is not a power-of-two, we may free\n\t\t\t * some pages at the end of hash table which\n\t\t\t * alloc_pages_exact() automatically does\n\t\t\t */\n\t\t\tif (get_order(size) < MAX_ORDER) {\n\t\t\t\ttable = alloc_pages_exact(size, gfp_flags);\n\t\t\t\tkmemleak_alloc(table, size, 1, gfp_flags);\n\t\t\t}\n\t\t}\n\t} while (!table && size > PAGE_SIZE && --log2qty);\n\n\tif (!table)\n\t\tpanic(\"Failed to allocate %s hash table\\n\", tablename);\n\n\tpr_info(\"%s hash table entries: %ld (order: %d, %lu bytes)\\n\",\n\t\ttablename, 1UL << log2qty, ilog2(size) - PAGE_SHIFT, size);\n\n\tif (_hash_shift)\n\t\t*_hash_shift = log2qty;\n\tif (_hash_mask)\n\t\t*_hash_mask = (1 << log2qty) - 1;\n\n\treturn table;\n}\n\n/*\n * This function checks whether pageblock includes unmovable pages or not.\n * If @count is not zero, it is okay to include less @count unmovable pages\n *\n * PageLRU check without isolation or lru_lock could race so that\n * MIGRATE_MOVABLE block might include unmovable pages. And __PageMovable\n * check without lock_page also may miss some movable non-lru pages at\n * race condition. So you can't expect this function should be exact.\n */\nbool has_unmovable_pages(struct zone *zone, struct page *page, int count,\n\t\t\t int migratetype,\n\t\t\t bool skip_hwpoisoned_pages)\n{\n\tunsigned long pfn, iter, found;\n\n\t/*\n\t * TODO we could make this much more efficient by not checking every\n\t * page in the range if we know all of them are in MOVABLE_ZONE and\n\t * that the movable zone guarantees that pages are migratable but\n\t * the later is not the case right now unfortunatelly. E.g. movablecore\n\t * can still lead to having bootmem allocations in zone_movable.\n\t */\n\n\t/*\n\t * CMA allocations (alloc_contig_range) really need to mark isolate\n\t * CMA pageblocks even when they are not movable in fact so consider\n\t * them movable here.\n\t */\n\tif (is_migrate_cma(migratetype) &&\n\t\t\tis_migrate_cma(get_pageblock_migratetype(page)))\n\t\treturn false;\n\n\tpfn = page_to_pfn(page);\n\tfor (found = 0, iter = 0; iter < pageblock_nr_pages; iter++) {\n\t\tunsigned long check = pfn + iter;\n\n\t\tif (!pfn_valid_within(check))\n\t\t\tcontinue;\n\n\t\tpage = pfn_to_page(check);\n\n\t\tif (PageReserved(page))\n\t\t\tgoto unmovable;\n\n\t\t/*\n\t\t * If the zone is movable and we have ruled out all reserved\n\t\t * pages then it should be reasonably safe to assume the rest\n\t\t * is movable.\n\t\t */\n\t\tif (zone_idx(zone) == ZONE_MOVABLE)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Hugepages are not in LRU lists, but they're movable.\n\t\t * We need not scan over tail pages bacause we don't\n\t\t * handle each tail page individually in migration.\n\t\t */\n\t\tif (PageHuge(page)) {\n\n\t\t\tif (!hugepage_migration_supported(page_hstate(page)))\n\t\t\t\tgoto unmovable;\n\n\t\t\titer = round_up(iter + 1, 1<<compound_order(page)) - 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * We can't use page_count without pin a page\n\t\t * because another CPU can free compound page.\n\t\t * This check already skips compound tails of THP\n\t\t * because their page->_refcount is zero at all time.\n\t\t */\n\t\tif (!page_ref_count(page)) {\n\t\t\tif (PageBuddy(page))\n\t\t\t\titer += (1 << page_order(page)) - 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * The HWPoisoned page may be not in buddy system, and\n\t\t * page_count() is not 0.\n\t\t */\n\t\tif (skip_hwpoisoned_pages && PageHWPoison(page))\n\t\t\tcontinue;\n\n\t\tif (__PageMovable(page))\n\t\t\tcontinue;\n\n\t\tif (!PageLRU(page))\n\t\t\tfound++;\n\t\t/*\n\t\t * If there are RECLAIMABLE pages, we need to check\n\t\t * it.  But now, memory offline itself doesn't call\n\t\t * shrink_node_slabs() and it still to be fixed.\n\t\t */\n\t\t/*\n\t\t * If the page is not RAM, page_count()should be 0.\n\t\t * we don't need more check. This is an _used_ not-movable page.\n\t\t *\n\t\t * The problematic thing here is PG_reserved pages. PG_reserved\n\t\t * is set to both of a memory hole page and a _used_ kernel\n\t\t * page at boot.\n\t\t */\n\t\tif (found > count)\n\t\t\tgoto unmovable;\n\t}\n\treturn false;\nunmovable:\n\tWARN_ON_ONCE(zone_idx(zone) == ZONE_MOVABLE);\n\treturn true;\n}\n\n#if (defined(CONFIG_MEMORY_ISOLATION) && defined(CONFIG_COMPACTION)) || defined(CONFIG_CMA)\n\nstatic unsigned long pfn_max_align_down(unsigned long pfn)\n{\n\treturn pfn & ~(max_t(unsigned long, MAX_ORDER_NR_PAGES,\n\t\t\t     pageblock_nr_pages) - 1);\n}\n\nstatic unsigned long pfn_max_align_up(unsigned long pfn)\n{\n\treturn ALIGN(pfn, max_t(unsigned long, MAX_ORDER_NR_PAGES,\n\t\t\t\tpageblock_nr_pages));\n}\n\n/* [start, end) must belong to a single zone. */\nstatic int __alloc_contig_migrate_range(struct compact_control *cc,\n\t\t\t\t\tunsigned long start, unsigned long end)\n{\n\t/* This function is based on compact_zone() from compaction.c. */\n\tunsigned long nr_reclaimed;\n\tunsigned long pfn = start;\n\tunsigned int tries = 0;\n\tint ret = 0;\n\n\tmigrate_prep();\n\n\twhile (pfn < end || !list_empty(&cc->migratepages)) {\n\t\tif (fatal_signal_pending(current)) {\n\t\t\tret = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (list_empty(&cc->migratepages)) {\n\t\t\tcc->nr_migratepages = 0;\n\t\t\tpfn = isolate_migratepages_range(cc, pfn, end);\n\t\t\tif (!pfn) {\n\t\t\t\tret = -EINTR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttries = 0;\n\t\t} else if (++tries == 5) {\n\t\t\tret = ret < 0 ? ret : -EBUSY;\n\t\t\tbreak;\n\t\t}\n\n\t\tnr_reclaimed = reclaim_clean_pages_from_list(cc->zone,\n\t\t\t\t\t\t\t&cc->migratepages);\n\t\tcc->nr_migratepages -= nr_reclaimed;\n\n\t\tret = migrate_pages(&cc->migratepages, alloc_migrate_target,\n\t\t\t\t    NULL, 0, cc->mode, MR_CONTIG_RANGE);\n\t}\n\tif (ret < 0) {\n\t\tputback_movable_pages(&cc->migratepages);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\n/**\n * alloc_contig_range() -- tries to allocate given range of pages\n * @start:\tstart PFN to allocate\n * @end:\tone-past-the-last PFN to allocate\n * @migratetype:\tmigratetype of the underlaying pageblocks (either\n *\t\t\t#MIGRATE_MOVABLE or #MIGRATE_CMA).  All pageblocks\n *\t\t\tin range must have the same migratetype and it must\n *\t\t\tbe either of the two.\n * @gfp_mask:\tGFP mask to use during compaction\n *\n * The PFN range does not have to be pageblock or MAX_ORDER_NR_PAGES\n * aligned.  The PFN range must belong to a single zone.\n *\n * The first thing this routine does is attempt to MIGRATE_ISOLATE all\n * pageblocks in the range.  Once isolated, the pageblocks should not\n * be modified by others.\n *\n * Returns zero on success or negative error code.  On success all\n * pages which PFN is in [start, end) are allocated for the caller and\n * need to be freed with free_contig_range().\n */\nint alloc_contig_range(unsigned long start, unsigned long end,\n\t\t       unsigned migratetype, gfp_t gfp_mask)\n{\n\tunsigned long outer_start, outer_end;\n\tunsigned int order;\n\tint ret = 0;\n\n\tstruct compact_control cc = {\n\t\t.nr_migratepages = 0,\n\t\t.order = -1,\n\t\t.zone = page_zone(pfn_to_page(start)),\n\t\t.mode = MIGRATE_SYNC,\n\t\t.ignore_skip_hint = true,\n\t\t.no_set_skip_hint = true,\n\t\t.gfp_mask = current_gfp_context(gfp_mask),\n\t};\n\tINIT_LIST_HEAD(&cc.migratepages);\n\n\t/*\n\t * What we do here is we mark all pageblocks in range as\n\t * MIGRATE_ISOLATE.  Because pageblock and max order pages may\n\t * have different sizes, and due to the way page allocator\n\t * work, we align the range to biggest of the two pages so\n\t * that page allocator won't try to merge buddies from\n\t * different pageblocks and change MIGRATE_ISOLATE to some\n\t * other migration type.\n\t *\n\t * Once the pageblocks are marked as MIGRATE_ISOLATE, we\n\t * migrate the pages from an unaligned range (ie. pages that\n\t * we are interested in).  This will put all the pages in\n\t * range back to page allocator as MIGRATE_ISOLATE.\n\t *\n\t * When this is done, we take the pages in range from page\n\t * allocator removing them from the buddy system.  This way\n\t * page allocator will never consider using them.\n\t *\n\t * This lets us mark the pageblocks back as\n\t * MIGRATE_CMA/MIGRATE_MOVABLE so that free pages in the\n\t * aligned range but not in the unaligned, original range are\n\t * put back to page allocator so that buddy can use them.\n\t */\n\n\tret = start_isolate_page_range(pfn_max_align_down(start),\n\t\t\t\t       pfn_max_align_up(end), migratetype,\n\t\t\t\t       false);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * In case of -EBUSY, we'd like to know which page causes problem.\n\t * So, just fall through. test_pages_isolated() has a tracepoint\n\t * which will report the busy page.\n\t *\n\t * It is possible that busy pages could become available before\n\t * the call to test_pages_isolated, and the range will actually be\n\t * allocated.  So, if we fall through be sure to clear ret so that\n\t * -EBUSY is not accidentally used or returned to caller.\n\t */\n\tret = __alloc_contig_migrate_range(&cc, start, end);\n\tif (ret && ret != -EBUSY)\n\t\tgoto done;\n\tret =0;\n\n\t/*\n\t * Pages from [start, end) are within a MAX_ORDER_NR_PAGES\n\t * aligned blocks that are marked as MIGRATE_ISOLATE.  What's\n\t * more, all pages in [start, end) are free in page allocator.\n\t * What we are going to do is to allocate all pages from\n\t * [start, end) (that is remove them from page allocator).\n\t *\n\t * The only problem is that pages at the beginning and at the\n\t * end of interesting range may be not aligned with pages that\n\t * page allocator holds, ie. they can be part of higher order\n\t * pages.  Because of this, we reserve the bigger range and\n\t * once this is done free the pages we are not interested in.\n\t *\n\t * We don't have to hold zone->lock here because the pages are\n\t * isolated thus they won't get removed from buddy.\n\t */\n\n\tlru_add_drain_all();\n\tdrain_all_pages(cc.zone);\n\n\torder = 0;\n\touter_start = start;\n\twhile (!PageBuddy(pfn_to_page(outer_start))) {\n\t\tif (++order >= MAX_ORDER) {\n\t\t\touter_start = start;\n\t\t\tbreak;\n\t\t}\n\t\touter_start &= ~0UL << order;\n\t}\n\n\tif (outer_start != start) {\n\t\torder = page_order(pfn_to_page(outer_start));\n\n\t\t/*\n\t\t * outer_start page could be small order buddy page and\n\t\t * it doesn't include start page. Adjust outer_start\n\t\t * in this case to report failed page properly\n\t\t * on tracepoint in test_pages_isolated()\n\t\t */\n\t\tif (outer_start + (1UL << order) <= start)\n\t\t\touter_start = start;\n\t}\n\n\t/* Make sure the range is really isolated. */\n\tif (test_pages_isolated(outer_start, end, false)) {\n\t\tpr_info_ratelimited(\"%s: [%lx, %lx) PFNs busy\\n\",\n\t\t\t__func__, outer_start, end);\n\t\tret = -EBUSY;\n\t\tgoto done;\n\t}\n\n\t/* Grab isolated pages from freelists. */\n\touter_end = isolate_freepages_range(&cc, outer_start, end);\n\tif (!outer_end) {\n\t\tret = -EBUSY;\n\t\tgoto done;\n\t}\n\n\t/* Free head and tail (if any) */\n\tif (start != outer_start)\n\t\tfree_contig_range(outer_start, start - outer_start);\n\tif (end != outer_end)\n\t\tfree_contig_range(end, outer_end - end);\n\ndone:\n\tundo_isolate_page_range(pfn_max_align_down(start),\n\t\t\t\tpfn_max_align_up(end), migratetype);\n\treturn ret;\n}\n\nvoid free_contig_range(unsigned long pfn, unsigned nr_pages)\n{\n\tunsigned int count = 0;\n\n\tfor (; nr_pages--; pfn++) {\n\t\tstruct page *page = pfn_to_page(pfn);\n\n\t\tcount += page_count(page) != 1;\n\t\t__free_page(page);\n\t}\n\tWARN(count != 0, \"%d pages are still in use!\\n\", count);\n}\n#endif\n\n#ifdef CONFIG_MEMORY_HOTPLUG\n/*\n * The zone indicated has a new number of managed_pages; batch sizes and percpu\n * page high values need to be recalulated.\n */\nvoid __meminit zone_pcp_update(struct zone *zone)\n{\n\tunsigned cpu;\n\tmutex_lock(&pcp_batch_high_lock);\n\tfor_each_possible_cpu(cpu)\n\t\tpageset_set_high_and_batch(zone,\n\t\t\t\tper_cpu_ptr(zone->pageset, cpu));\n\tmutex_unlock(&pcp_batch_high_lock);\n}\n#endif\n\nvoid zone_pcp_reset(struct zone *zone)\n{\n\tunsigned long flags;\n\tint cpu;\n\tstruct per_cpu_pageset *pset;\n\n\t/* avoid races with drain_pages()  */\n\tlocal_irq_save(flags);\n\tif (zone->pageset != &boot_pageset) {\n\t\tfor_each_online_cpu(cpu) {\n\t\t\tpset = per_cpu_ptr(zone->pageset, cpu);\n\t\t\tdrain_zonestat(zone, pset);\n\t\t}\n\t\tfree_percpu(zone->pageset);\n\t\tzone->pageset = &boot_pageset;\n\t}\n\tlocal_irq_restore(flags);\n}\n\n#ifdef CONFIG_MEMORY_HOTREMOVE\n/*\n * All pages in the range must be in a single zone and isolated\n * before calling this.\n */\nvoid\n__offline_isolated_pages(unsigned long start_pfn, unsigned long end_pfn)\n{\n\tstruct page *page;\n\tstruct zone *zone;\n\tunsigned int order, i;\n\tunsigned long pfn;\n\tunsigned long flags;\n\t/* find the first valid pfn */\n\tfor (pfn = start_pfn; pfn < end_pfn; pfn++)\n\t\tif (pfn_valid(pfn))\n\t\t\tbreak;\n\tif (pfn == end_pfn)\n\t\treturn;\n\toffline_mem_sections(pfn, end_pfn);\n\tzone = page_zone(pfn_to_page(pfn));\n\tspin_lock_irqsave(&zone->lock, flags);\n\tpfn = start_pfn;\n\twhile (pfn < end_pfn) {\n\t\tif (!pfn_valid(pfn)) {\n\t\t\tpfn++;\n\t\t\tcontinue;\n\t\t}\n\t\tpage = pfn_to_page(pfn);\n\t\t/*\n\t\t * The HWPoisoned page may be not in buddy system, and\n\t\t * page_count() is not 0.\n\t\t */\n\t\tif (unlikely(!PageBuddy(page) && PageHWPoison(page))) {\n\t\t\tpfn++;\n\t\t\tSetPageReserved(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\tBUG_ON(page_count(page));\n\t\tBUG_ON(!PageBuddy(page));\n\t\torder = page_order(page);\n#ifdef CONFIG_DEBUG_VM\n\t\tpr_info(\"remove from free list %lx %d %lx\\n\",\n\t\t\tpfn, 1 << order, end_pfn);\n#endif\n\t\tlist_del(&page->lru);\n\t\trmv_page_order(page);\n\t\tzone->free_area[order].nr_free--;\n\t\tfor (i = 0; i < (1 << order); i++)\n\t\t\tSetPageReserved((page+i));\n\t\tpfn += (1 << order);\n\t}\n\tspin_unlock_irqrestore(&zone->lock, flags);\n}\n#endif\n\nbool is_free_buddy_page(struct page *page)\n{\n\tstruct zone *zone = page_zone(page);\n\tunsigned long pfn = page_to_pfn(page);\n\tunsigned long flags;\n\tunsigned int order;\n\n\tspin_lock_irqsave(&zone->lock, flags);\n\tfor (order = 0; order < MAX_ORDER; order++) {\n\t\tstruct page *page_head = page - (pfn & ((1 << order) - 1));\n\n\t\tif (PageBuddy(page_head) && page_order(page_head) >= order)\n\t\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&zone->lock, flags);\n\n\treturn order < MAX_ORDER;\n}\n\n#ifdef CONFIG_MEMORY_FAILURE\n/*\n * Set PG_hwpoison flag if a given page is confirmed to be a free page.  This\n * test is performed under the zone lock to prevent a race against page\n * allocation.\n */\nbool set_hwpoison_free_buddy_page(struct page *page)\n{\n\tstruct zone *zone = page_zone(page);\n\tunsigned long pfn = page_to_pfn(page);\n\tunsigned long flags;\n\tunsigned int order;\n\tbool hwpoisoned = false;\n\n\tspin_lock_irqsave(&zone->lock, flags);\n\tfor (order = 0; order < MAX_ORDER; order++) {\n\t\tstruct page *page_head = page - (pfn & ((1 << order) - 1));\n\n\t\tif (PageBuddy(page_head) && page_order(page_head) >= order) {\n\t\t\tif (!TestSetPageHWPoison(page))\n\t\t\t\thwpoisoned = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&zone->lock, flags);\n\n\treturn hwpoisoned;\n}\n#endif"
  },
  {
    "function_name": "show_migration_types",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "4815-4840",
    "snippet": "static void show_migration_types(unsigned char type)\n{\n\tstatic const char types[MIGRATE_TYPES] = {\n\t\t[MIGRATE_UNMOVABLE]\t= 'U',\n\t\t[MIGRATE_MOVABLE]\t= 'M',\n\t\t[MIGRATE_RECLAIMABLE]\t= 'E',\n\t\t[MIGRATE_HIGHATOMIC]\t= 'H',\n#ifdef CONFIG_CMA\n\t\t[MIGRATE_CMA]\t\t= 'C',\n#endif\n#ifdef CONFIG_MEMORY_ISOLATION\n\t\t[MIGRATE_ISOLATE]\t= 'I',\n#endif\n\t};\n\tchar tmp[MIGRATE_TYPES + 1];\n\tchar *p = tmp;\n\tint i;\n\n\tfor (i = 0; i < MIGRATE_TYPES; i++) {\n\t\tif (type & (1 << i))\n\t\t\t*p++ = types[i];\n\t}\n\n\t*p = '\\0';\n\tprintk(KERN_CONT \"(%s) \", tmp);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \"(%s) \"",
            "tmp"
          ],
          "line": 4839
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void show_migration_types(unsigned char type)\n{\n\tstatic const char types[MIGRATE_TYPES] = {\n\t\t[MIGRATE_UNMOVABLE]\t= 'U',\n\t\t[MIGRATE_MOVABLE]\t= 'M',\n\t\t[MIGRATE_RECLAIMABLE]\t= 'E',\n\t\t[MIGRATE_HIGHATOMIC]\t= 'H',\n#ifdef CONFIG_CMA\n\t\t[MIGRATE_CMA]\t\t= 'C',\n#endif\n#ifdef CONFIG_MEMORY_ISOLATION\n\t\t[MIGRATE_ISOLATE]\t= 'I',\n#endif\n\t};\n\tchar tmp[MIGRATE_TYPES + 1];\n\tchar *p = tmp;\n\tint i;\n\n\tfor (i = 0; i < MIGRATE_TYPES; i++) {\n\t\tif (type & (1 << i))\n\t\t\t*p++ = types[i];\n\t}\n\n\t*p = '\\0';\n\tprintk(KERN_CONT \"(%s) \", tmp);\n}"
  },
  {
    "function_name": "show_mem_node_skip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "4797-4811",
    "snippet": "static bool show_mem_node_skip(unsigned int flags, int nid, nodemask_t *nodemask)\n{\n\tif (!(flags & SHOW_MEM_FILTER_NODES))\n\t\treturn false;\n\n\t/*\n\t * no node mask - aka implicit memory numa policy. Do not bother with\n\t * the synchronization - read_mems_allowed_begin - because we do not\n\t * have to be precise here.\n\t */\n\tif (!nodemask)\n\t\tnodemask = &cpuset_current_mems_allowed;\n\n\treturn !node_isset(nid, *nodemask);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "node_isset",
          "args": [
            "nid",
            "*nodemask"
          ],
          "line": 4810
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic bool show_mem_node_skip(unsigned int flags, int nid, nodemask_t *nodemask)\n{\n\tif (!(flags & SHOW_MEM_FILTER_NODES))\n\t\treturn false;\n\n\t/*\n\t * no node mask - aka implicit memory numa policy. Do not bother with\n\t * the synchronization - read_mems_allowed_begin - because we do not\n\t * have to be precise here.\n\t */\n\tif (!nodemask)\n\t\tnodemask = &cpuset_current_mems_allowed;\n\n\treturn !node_isset(nid, *nodemask);\n}"
  },
  {
    "function_name": "si_meminfo_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "4761-4790",
    "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "zone_page_state",
          "args": [
            "zone",
            "NR_FREE_PAGES"
          ],
          "line": 4780
        },
        "resolved": true,
        "details": {
          "function_name": "dec_zone_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "624-631",
          "snippet": "void dec_zone_page_state(struct page *page, enum zone_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__dec_zone_page_state(page, item);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid dec_zone_page_state(struct page *page, enum zone_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__dec_zone_page_state(page, item);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_highmem",
          "args": [
            "zone"
          ],
          "line": 4778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sum_zone_node_page_state",
          "args": [
            "nid",
            "NR_FREE_PAGES"
          ],
          "line": 4773
        },
        "resolved": true,
        "details": {
          "function_name": "sum_zone_node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "958-969",
          "snippet": "unsigned long sum_zone_node_page_state(int node,\n\t\t\t\t enum zone_stat_item item)\n{\n\tstruct zone *zones = NODE_DATA(node)->node_zones;\n\tint i;\n\tunsigned long count = 0;\n\n\tfor (i = 0; i < MAX_NR_ZONES; i++)\n\t\tcount += zone_page_state(zones + i, item);\n\n\treturn count;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nunsigned long sum_zone_node_page_state(int node,\n\t\t\t\t enum zone_stat_item item)\n{\n\tstruct zone *zones = NODE_DATA(node)->node_zones;\n\tint i;\n\tunsigned long count = 0;\n\n\tfor (i = 0; i < MAX_NR_ZONES; i++)\n\t\tcount += zone_page_state(zones + i, item);\n\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "node_page_state",
          "args": [
            "pgdat",
            "NR_SHMEM"
          ],
          "line": 4772
        },
        "resolved": true,
        "details": {
          "function_name": "node_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "991-1000",
          "snippet": "unsigned long node_page_state(struct pglist_data *pgdat,\n\t\t\t\tenum node_stat_item item)\n{\n\tlong x = atomic_long_read(&pgdat->vm_stat[item]);\n#ifdef CONFIG_SMP\n\tif (x < 0)\n\t\tx = 0;\n#endif\n\treturn x;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nunsigned long node_page_state(struct pglist_data *pgdat,\n\t\t\t\tenum node_stat_item item)\n{\n\tlong x = atomic_long_read(&pgdat->vm_stat[item]);\n#ifdef CONFIG_SMP\n\tif (x < 0)\n\t\tx = 0;\n#endif\n\treturn x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "nid"
          ],
          "line": 4767
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
  },
  {
    "function_name": "si_meminfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "4747-4756",
    "snippet": "void si_meminfo(struct sysinfo *val)\n{\n\tval->totalram = totalram_pages;\n\tval->sharedram = global_node_page_state(NR_SHMEM);\n\tval->freeram = global_zone_page_state(NR_FREE_PAGES);\n\tval->bufferram = nr_blockdev_pages();\n\tval->totalhigh = totalhigh_pages;\n\tval->freehigh = nr_free_highpages();\n\tval->mem_unit = PAGE_SIZE;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nr_free_highpages",
          "args": [],
          "line": 4754
        },
        "resolved": true,
        "details": {
          "function_name": "nr_free_highpages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
          "lines": "114-125",
          "snippet": "unsigned int nr_free_highpages (void)\n{\n\tstruct zone *zone;\n\tunsigned int pages = 0;\n\n\tfor_each_populated_zone(zone) {\n\t\tif (is_highmem(zone))\n\t\t\tpages += zone_page_state(zone, NR_FREE_PAGES);\n\t}\n\n\treturn pages;\n}",
          "includes": [
            "#include <asm/tlbflush.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nunsigned int nr_free_highpages (void)\n{\n\tstruct zone *zone;\n\tunsigned int pages = 0;\n\n\tfor_each_populated_zone(zone) {\n\t\tif (is_highmem(zone))\n\t\t\tpages += zone_page_state(zone, NR_FREE_PAGES);\n\t}\n\n\treturn pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nr_blockdev_pages",
          "args": [],
          "line": 4752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_zone_page_state",
          "args": [
            "NR_FREE_PAGES"
          ],
          "line": 4751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_node_page_state",
          "args": [
            "NR_SHMEM"
          ],
          "line": 4750
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo(struct sysinfo *val)\n{\n\tval->totalram = totalram_pages;\n\tval->sharedram = global_node_page_state(NR_SHMEM);\n\tval->freeram = global_zone_page_state(NR_FREE_PAGES);\n\tval->bufferram = nr_blockdev_pages();\n\tval->totalhigh = totalhigh_pages;\n\tval->freehigh = nr_free_highpages();\n\tval->mem_unit = PAGE_SIZE;\n}"
  },
  {
    "function_name": "si_mem_available",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "4701-4744",
    "snippet": "long si_mem_available(void)\n{\n\tlong available;\n\tunsigned long pagecache;\n\tunsigned long wmark_low = 0;\n\tunsigned long pages[NR_LRU_LISTS];\n\tunsigned long reclaimable;\n\tstruct zone *zone;\n\tint lru;\n\n\tfor (lru = LRU_BASE; lru < NR_LRU_LISTS; lru++)\n\t\tpages[lru] = global_node_page_state(NR_LRU_BASE + lru);\n\n\tfor_each_zone(zone)\n\t\twmark_low += zone->watermark[WMARK_LOW];\n\n\t/*\n\t * Estimate the amount of memory available for userspace allocations,\n\t * without causing swapping.\n\t */\n\tavailable = global_zone_page_state(NR_FREE_PAGES) - totalreserve_pages;\n\n\t/*\n\t * Not all the page cache can be freed, otherwise the system will\n\t * start swapping. Assume at least half of the page cache, or the\n\t * low watermark worth of cache, needs to stay.\n\t */\n\tpagecache = pages[LRU_ACTIVE_FILE] + pages[LRU_INACTIVE_FILE];\n\tpagecache -= min(pagecache / 2, wmark_low);\n\tavailable += pagecache;\n\n\t/*\n\t * Part of the reclaimable slab and other kernel memory consists of\n\t * items that are in use, and cannot be freed. Cap this estimate at the\n\t * low watermark.\n\t */\n\treclaimable = global_node_page_state(NR_SLAB_RECLAIMABLE) +\n\t\t\tglobal_node_page_state(NR_KERNEL_MISC_RECLAIMABLE);\n\tavailable += reclaimable - min(reclaimable / 2, wmark_low);\n\n\tif (available < 0)\n\t\tavailable = 0;\n\treturn available;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "min",
          "args": [
            "reclaimable / 2",
            "wmark_low"
          ],
          "line": 4739
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "global_node_page_state",
          "args": [
            "NR_KERNEL_MISC_RECLAIMABLE"
          ],
          "line": 4738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_node_page_state",
          "args": [
            "NR_SLAB_RECLAIMABLE"
          ],
          "line": 4737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_zone_page_state",
          "args": [
            "NR_FREE_PAGES"
          ],
          "line": 4721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_node_page_state",
          "args": [
            "NR_LRU_BASE + lru"
          ],
          "line": 4712
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nlong si_mem_available(void)\n{\n\tlong available;\n\tunsigned long pagecache;\n\tunsigned long wmark_low = 0;\n\tunsigned long pages[NR_LRU_LISTS];\n\tunsigned long reclaimable;\n\tstruct zone *zone;\n\tint lru;\n\n\tfor (lru = LRU_BASE; lru < NR_LRU_LISTS; lru++)\n\t\tpages[lru] = global_node_page_state(NR_LRU_BASE + lru);\n\n\tfor_each_zone(zone)\n\t\twmark_low += zone->watermark[WMARK_LOW];\n\n\t/*\n\t * Estimate the amount of memory available for userspace allocations,\n\t * without causing swapping.\n\t */\n\tavailable = global_zone_page_state(NR_FREE_PAGES) - totalreserve_pages;\n\n\t/*\n\t * Not all the page cache can be freed, otherwise the system will\n\t * start swapping. Assume at least half of the page cache, or the\n\t * low watermark worth of cache, needs to stay.\n\t */\n\tpagecache = pages[LRU_ACTIVE_FILE] + pages[LRU_INACTIVE_FILE];\n\tpagecache -= min(pagecache / 2, wmark_low);\n\tavailable += pagecache;\n\n\t/*\n\t * Part of the reclaimable slab and other kernel memory consists of\n\t * items that are in use, and cannot be freed. Cap this estimate at the\n\t * low watermark.\n\t */\n\treclaimable = global_node_page_state(NR_SLAB_RECLAIMABLE) +\n\t\t\tglobal_node_page_state(NR_KERNEL_MISC_RECLAIMABLE);\n\tavailable += reclaimable - min(reclaimable / 2, wmark_low);\n\n\tif (available < 0)\n\t\tavailable = 0;\n\treturn available;\n}"
  },
  {
    "function_name": "show_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "4695-4699",
    "snippet": "static inline void show_node(struct zone *zone)\n{\n\tif (IS_ENABLED(CONFIG_NUMA))\n\t\tprintk(\"Node %d \", zone_to_nid(zone));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Node %d \"",
            "zone_to_nid(zone)"
          ],
          "line": 4698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_to_nid",
          "args": [
            "zone"
          ],
          "line": 4698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_NUMA"
          ],
          "line": 4697
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline void show_node(struct zone *zone)\n{\n\tif (IS_ENABLED(CONFIG_NUMA))\n\t\tprintk(\"Node %d \", zone_to_nid(zone));\n}"
  },
  {
    "function_name": "nr_free_pagecache_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "4690-4693",
    "snippet": "unsigned long nr_free_pagecache_pages(void)\n{\n\treturn nr_free_zone_pages(gfp_zone(GFP_HIGHUSER_MOVABLE));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nr_free_zone_pages",
          "args": [
            "gfp_zone(GFP_HIGHUSER_MOVABLE)"
          ],
          "line": 4692
        },
        "resolved": true,
        "details": {
          "function_name": "nr_free_zone_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4652-4670",
          "snippet": "static unsigned long nr_free_zone_pages(int offset)\n{\n\tstruct zoneref *z;\n\tstruct zone *zone;\n\n\t/* Just pick one node, since fallback list is circular */\n\tunsigned long sum = 0;\n\n\tstruct zonelist *zonelist = node_zonelist(numa_node_id(), GFP_KERNEL);\n\n\tfor_each_zone_zonelist(zone, z, zonelist, offset) {\n\t\tunsigned long size = zone->managed_pages;\n\t\tunsigned long high = high_wmark_pages(zone);\n\t\tif (size > high)\n\t\t\tsum += size - high;\n\t}\n\n\treturn sum;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic unsigned long nr_free_zone_pages(int offset)\n{\n\tstruct zoneref *z;\n\tstruct zone *zone;\n\n\t/* Just pick one node, since fallback list is circular */\n\tunsigned long sum = 0;\n\n\tstruct zonelist *zonelist = node_zonelist(numa_node_id(), GFP_KERNEL);\n\n\tfor_each_zone_zonelist(zone, z, zonelist, offset) {\n\t\tunsigned long size = zone->managed_pages;\n\t\tunsigned long high = high_wmark_pages(zone);\n\t\tif (size > high)\n\t\t\tsum += size - high;\n\t}\n\n\treturn sum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfp_zone",
          "args": [
            "GFP_HIGHUSER_MOVABLE"
          ],
          "line": 4692
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nunsigned long nr_free_pagecache_pages(void)\n{\n\treturn nr_free_zone_pages(gfp_zone(GFP_HIGHUSER_MOVABLE));\n}"
  },
  {
    "function_name": "nr_free_buffer_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "4678-4681",
    "snippet": "unsigned long nr_free_buffer_pages(void)\n{\n\treturn nr_free_zone_pages(gfp_zone(GFP_USER));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nr_free_zone_pages",
          "args": [
            "gfp_zone(GFP_USER)"
          ],
          "line": 4680
        },
        "resolved": true,
        "details": {
          "function_name": "nr_free_zone_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4652-4670",
          "snippet": "static unsigned long nr_free_zone_pages(int offset)\n{\n\tstruct zoneref *z;\n\tstruct zone *zone;\n\n\t/* Just pick one node, since fallback list is circular */\n\tunsigned long sum = 0;\n\n\tstruct zonelist *zonelist = node_zonelist(numa_node_id(), GFP_KERNEL);\n\n\tfor_each_zone_zonelist(zone, z, zonelist, offset) {\n\t\tunsigned long size = zone->managed_pages;\n\t\tunsigned long high = high_wmark_pages(zone);\n\t\tif (size > high)\n\t\t\tsum += size - high;\n\t}\n\n\treturn sum;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic unsigned long nr_free_zone_pages(int offset)\n{\n\tstruct zoneref *z;\n\tstruct zone *zone;\n\n\t/* Just pick one node, since fallback list is circular */\n\tunsigned long sum = 0;\n\n\tstruct zonelist *zonelist = node_zonelist(numa_node_id(), GFP_KERNEL);\n\n\tfor_each_zone_zonelist(zone, z, zonelist, offset) {\n\t\tunsigned long size = zone->managed_pages;\n\t\tunsigned long high = high_wmark_pages(zone);\n\t\tif (size > high)\n\t\t\tsum += size - high;\n\t}\n\n\treturn sum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfp_zone",
          "args": [
            "GFP_USER"
          ],
          "line": 4680
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nunsigned long nr_free_buffer_pages(void)\n{\n\treturn nr_free_zone_pages(gfp_zone(GFP_USER));\n}"
  },
  {
    "function_name": "nr_free_zone_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "4652-4670",
    "snippet": "static unsigned long nr_free_zone_pages(int offset)\n{\n\tstruct zoneref *z;\n\tstruct zone *zone;\n\n\t/* Just pick one node, since fallback list is circular */\n\tunsigned long sum = 0;\n\n\tstruct zonelist *zonelist = node_zonelist(numa_node_id(), GFP_KERNEL);\n\n\tfor_each_zone_zonelist(zone, z, zonelist, offset) {\n\t\tunsigned long size = zone->managed_pages;\n\t\tunsigned long high = high_wmark_pages(zone);\n\t\tif (size > high)\n\t\t\tsum += size - high;\n\t}\n\n\treturn sum;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "high_wmark_pages",
          "args": [
            "zone"
          ],
          "line": 4664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_zone_zonelist",
          "args": [
            "zone",
            "z",
            "zonelist",
            "offset"
          ],
          "line": 4662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_zonelist",
          "args": [
            "numa_node_id()",
            "GFP_KERNEL"
          ],
          "line": 4660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "numa_node_id",
          "args": [],
          "line": 4660
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic unsigned long nr_free_zone_pages(int offset)\n{\n\tstruct zoneref *z;\n\tstruct zone *zone;\n\n\t/* Just pick one node, since fallback list is circular */\n\tunsigned long sum = 0;\n\n\tstruct zonelist *zonelist = node_zonelist(numa_node_id(), GFP_KERNEL);\n\n\tfor_each_zone_zonelist(zone, z, zonelist, offset) {\n\t\tunsigned long size = zone->managed_pages;\n\t\tunsigned long high = high_wmark_pages(zone);\n\t\tif (size > high)\n\t\t\tsum += size - high;\n\t}\n\n\treturn sum;\n}"
  },
  {
    "function_name": "free_pages_exact",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "4630-4639",
    "snippet": "void free_pages_exact(void *virt, size_t size)\n{\n\tunsigned long addr = (unsigned long)virt;\n\tunsigned long end = addr + PAGE_ALIGN(size);\n\n\twhile (addr < end) {\n\t\tfree_page(addr);\n\t\taddr += PAGE_SIZE;\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "addr"
          ],
          "line": 4636
        },
        "resolved": true,
        "details": {
          "function_name": "mark_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "2691-2736",
          "snippet": "void mark_free_pages(struct zone *zone)\n{\n\tunsigned long pfn, max_zone_pfn, page_count = WD_PAGE_COUNT;\n\tunsigned long flags;\n\tunsigned int order, t;\n\tstruct page *page;\n\n\tif (zone_is_empty(zone))\n\t\treturn;\n\n\tspin_lock_irqsave(&zone->lock, flags);\n\n\tmax_zone_pfn = zone_end_pfn(zone);\n\tfor (pfn = zone->zone_start_pfn; pfn < max_zone_pfn; pfn++)\n\t\tif (pfn_valid(pfn)) {\n\t\t\tpage = pfn_to_page(pfn);\n\n\t\t\tif (!--page_count) {\n\t\t\t\ttouch_nmi_watchdog();\n\t\t\t\tpage_count = WD_PAGE_COUNT;\n\t\t\t}\n\n\t\t\tif (page_zone(page) != zone)\n\t\t\t\tcontinue;\n\n\t\t\tif (!swsusp_page_is_forbidden(page))\n\t\t\t\tswsusp_unset_page_free(page);\n\t\t}\n\n\tfor_each_migratetype_order(order, t) {\n\t\tlist_for_each_entry(page,\n\t\t\t\t&zone->free_area[order].free_list[t], lru) {\n\t\t\tunsigned long i;\n\n\t\t\tpfn = page_to_pfn(page);\n\t\t\tfor (i = 0; i < (1UL << order); i++) {\n\t\t\t\tif (!--page_count) {\n\t\t\t\t\ttouch_nmi_watchdog();\n\t\t\t\t\tpage_count = WD_PAGE_COUNT;\n\t\t\t\t}\n\t\t\t\tswsusp_set_page_free(pfn_to_page(pfn + i));\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&zone->lock, flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [
            "#define WD_PAGE_COUNT\t(128*1024)"
          ],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\n#define WD_PAGE_COUNT\t(128*1024)\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid mark_free_pages(struct zone *zone)\n{\n\tunsigned long pfn, max_zone_pfn, page_count = WD_PAGE_COUNT;\n\tunsigned long flags;\n\tunsigned int order, t;\n\tstruct page *page;\n\n\tif (zone_is_empty(zone))\n\t\treturn;\n\n\tspin_lock_irqsave(&zone->lock, flags);\n\n\tmax_zone_pfn = zone_end_pfn(zone);\n\tfor (pfn = zone->zone_start_pfn; pfn < max_zone_pfn; pfn++)\n\t\tif (pfn_valid(pfn)) {\n\t\t\tpage = pfn_to_page(pfn);\n\n\t\t\tif (!--page_count) {\n\t\t\t\ttouch_nmi_watchdog();\n\t\t\t\tpage_count = WD_PAGE_COUNT;\n\t\t\t}\n\n\t\t\tif (page_zone(page) != zone)\n\t\t\t\tcontinue;\n\n\t\t\tif (!swsusp_page_is_forbidden(page))\n\t\t\t\tswsusp_unset_page_free(page);\n\t\t}\n\n\tfor_each_migratetype_order(order, t) {\n\t\tlist_for_each_entry(page,\n\t\t\t\t&zone->free_area[order].free_list[t], lru) {\n\t\t\tunsigned long i;\n\n\t\t\tpfn = page_to_pfn(page);\n\t\t\tfor (i = 0; i < (1UL << order); i++) {\n\t\t\t\tif (!--page_count) {\n\t\t\t\t\ttouch_nmi_watchdog();\n\t\t\t\t\tpage_count = WD_PAGE_COUNT;\n\t\t\t\t}\n\t\t\t\tswsusp_set_page_free(pfn_to_page(pfn + i));\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&zone->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "size"
          ],
          "line": 4633
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid free_pages_exact(void *virt, size_t size)\n{\n\tunsigned long addr = (unsigned long)virt;\n\tunsigned long end = addr + PAGE_ALIGN(size);\n\n\twhile (addr < end) {\n\t\tfree_page(addr);\n\t\taddr += PAGE_SIZE;\n\t}\n}"
  },
  {
    "function_name": "alloc_pages_exact_nid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "4614-4621",
    "snippet": "void * __meminit alloc_pages_exact_nid(int nid, size_t size, gfp_t gfp_mask)\n{\n\tunsigned int order = get_order(size);\n\tstruct page *p = alloc_pages_node(nid, gfp_mask, order);\n\tif (!p)\n\t\treturn NULL;\n\treturn make_alloc_exact((unsigned long)page_address(p), order, size);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);",
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "make_alloc_exact",
          "args": [
            "(unsigned long)page_address(p)",
            "order",
            "size"
          ],
          "line": 4620
        },
        "resolved": true,
        "details": {
          "function_name": "make_alloc_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4565-4579",
          "snippet": "static void *make_alloc_exact(unsigned long addr, unsigned int order,\n\t\tsize_t size)\n{\n\tif (addr) {\n\t\tunsigned long alloc_end = addr + (PAGE_SIZE << order);\n\t\tunsigned long used = addr + PAGE_ALIGN(size);\n\n\t\tsplit_page(virt_to_page((void *)addr), order);\n\t\twhile (used < alloc_end) {\n\t\t\tfree_page(used);\n\t\t\tused += PAGE_SIZE;\n\t\t}\n\t}\n\treturn (void *)addr;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\n\nstatic void *make_alloc_exact(unsigned long addr, unsigned int order,\n\t\tsize_t size)\n{\n\tif (addr) {\n\t\tunsigned long alloc_end = addr + (PAGE_SIZE << order);\n\t\tunsigned long used = addr + PAGE_ALIGN(size);\n\n\t\tsplit_page(virt_to_page((void *)addr), order);\n\t\twhile (used < alloc_end) {\n\t\t\tfree_page(used);\n\t\t\tused += PAGE_SIZE;\n\t\t}\n\t}\n\treturn (void *)addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "p"
          ],
          "line": 4620
        },
        "resolved": true,
        "details": {
          "function_name": "page_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
          "lines": "409-434",
          "snippet": "void *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/tlbflush.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nvoid *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_pages_node",
          "args": [
            "nid",
            "gfp_mask",
            "order"
          ],
          "line": 4617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "size"
          ],
          "line": 4616
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid * __meminit alloc_pages_exact_nid(int nid, size_t size, gfp_t gfp_mask)\n{\n\tunsigned int order = get_order(size);\n\tstruct page *p = alloc_pages_node(nid, gfp_mask, order);\n\tif (!p)\n\t\treturn NULL;\n\treturn make_alloc_exact((unsigned long)page_address(p), order, size);\n}"
  },
  {
    "function_name": "alloc_pages_exact",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "4594-4601",
    "snippet": "void *alloc_pages_exact(size_t size, gfp_t gfp_mask)\n{\n\tunsigned int order = get_order(size);\n\tunsigned long addr;\n\n\taddr = __get_free_pages(gfp_mask, order);\n\treturn make_alloc_exact(addr, order, size);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "make_alloc_exact",
          "args": [
            "addr",
            "order",
            "size"
          ],
          "line": 4600
        },
        "resolved": true,
        "details": {
          "function_name": "make_alloc_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4565-4579",
          "snippet": "static void *make_alloc_exact(unsigned long addr, unsigned int order,\n\t\tsize_t size)\n{\n\tif (addr) {\n\t\tunsigned long alloc_end = addr + (PAGE_SIZE << order);\n\t\tunsigned long used = addr + PAGE_ALIGN(size);\n\n\t\tsplit_page(virt_to_page((void *)addr), order);\n\t\twhile (used < alloc_end) {\n\t\t\tfree_page(used);\n\t\t\tused += PAGE_SIZE;\n\t\t}\n\t}\n\treturn (void *)addr;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\n\nstatic void *make_alloc_exact(unsigned long addr, unsigned int order,\n\t\tsize_t size)\n{\n\tif (addr) {\n\t\tunsigned long alloc_end = addr + (PAGE_SIZE << order);\n\t\tunsigned long used = addr + PAGE_ALIGN(size);\n\n\t\tsplit_page(virt_to_page((void *)addr), order);\n\t\twhile (used < alloc_end) {\n\t\t\tfree_page(used);\n\t\t\tused += PAGE_SIZE;\n\t\t}\n\t}\n\treturn (void *)addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_free_pages",
          "args": [
            "gfp_mask",
            "order"
          ],
          "line": 4599
        },
        "resolved": true,
        "details": {
          "function_name": "__get_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4413-4421",
          "snippet": "unsigned long __get_free_pages(gfp_t gfp_mask, unsigned int order)\n{\n\tstruct page *page;\n\n\tpage = alloc_pages(gfp_mask & ~__GFP_HIGHMEM, order);\n\tif (!page)\n\t\treturn 0;\n\treturn (unsigned long) page_address(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nunsigned long __get_free_pages(gfp_t gfp_mask, unsigned int order)\n{\n\tstruct page *page;\n\n\tpage = alloc_pages(gfp_mask & ~__GFP_HIGHMEM, order);\n\tif (!page)\n\t\treturn 0;\n\treturn (unsigned long) page_address(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "size"
          ],
          "line": 4596
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\n\nvoid *alloc_pages_exact(size_t size, gfp_t gfp_mask)\n{\n\tunsigned int order = get_order(size);\n\tunsigned long addr;\n\n\taddr = __get_free_pages(gfp_mask, order);\n\treturn make_alloc_exact(addr, order, size);\n}"
  },
  {
    "function_name": "make_alloc_exact",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "4565-4579",
    "snippet": "static void *make_alloc_exact(unsigned long addr, unsigned int order,\n\t\tsize_t size)\n{\n\tif (addr) {\n\t\tunsigned long alloc_end = addr + (PAGE_SIZE << order);\n\t\tunsigned long used = addr + PAGE_ALIGN(size);\n\n\t\tsplit_page(virt_to_page((void *)addr), order);\n\t\twhile (used < alloc_end) {\n\t\t\tfree_page(used);\n\t\t\tused += PAGE_SIZE;\n\t\t}\n\t}\n\treturn (void *)addr;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "used"
          ],
          "line": 4574
        },
        "resolved": true,
        "details": {
          "function_name": "mark_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "2691-2736",
          "snippet": "void mark_free_pages(struct zone *zone)\n{\n\tunsigned long pfn, max_zone_pfn, page_count = WD_PAGE_COUNT;\n\tunsigned long flags;\n\tunsigned int order, t;\n\tstruct page *page;\n\n\tif (zone_is_empty(zone))\n\t\treturn;\n\n\tspin_lock_irqsave(&zone->lock, flags);\n\n\tmax_zone_pfn = zone_end_pfn(zone);\n\tfor (pfn = zone->zone_start_pfn; pfn < max_zone_pfn; pfn++)\n\t\tif (pfn_valid(pfn)) {\n\t\t\tpage = pfn_to_page(pfn);\n\n\t\t\tif (!--page_count) {\n\t\t\t\ttouch_nmi_watchdog();\n\t\t\t\tpage_count = WD_PAGE_COUNT;\n\t\t\t}\n\n\t\t\tif (page_zone(page) != zone)\n\t\t\t\tcontinue;\n\n\t\t\tif (!swsusp_page_is_forbidden(page))\n\t\t\t\tswsusp_unset_page_free(page);\n\t\t}\n\n\tfor_each_migratetype_order(order, t) {\n\t\tlist_for_each_entry(page,\n\t\t\t\t&zone->free_area[order].free_list[t], lru) {\n\t\t\tunsigned long i;\n\n\t\t\tpfn = page_to_pfn(page);\n\t\t\tfor (i = 0; i < (1UL << order); i++) {\n\t\t\t\tif (!--page_count) {\n\t\t\t\t\ttouch_nmi_watchdog();\n\t\t\t\t\tpage_count = WD_PAGE_COUNT;\n\t\t\t\t}\n\t\t\t\tswsusp_set_page_free(pfn_to_page(pfn + i));\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&zone->lock, flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [
            "#define WD_PAGE_COUNT\t(128*1024)"
          ],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\n#define WD_PAGE_COUNT\t(128*1024)\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid mark_free_pages(struct zone *zone)\n{\n\tunsigned long pfn, max_zone_pfn, page_count = WD_PAGE_COUNT;\n\tunsigned long flags;\n\tunsigned int order, t;\n\tstruct page *page;\n\n\tif (zone_is_empty(zone))\n\t\treturn;\n\n\tspin_lock_irqsave(&zone->lock, flags);\n\n\tmax_zone_pfn = zone_end_pfn(zone);\n\tfor (pfn = zone->zone_start_pfn; pfn < max_zone_pfn; pfn++)\n\t\tif (pfn_valid(pfn)) {\n\t\t\tpage = pfn_to_page(pfn);\n\n\t\t\tif (!--page_count) {\n\t\t\t\ttouch_nmi_watchdog();\n\t\t\t\tpage_count = WD_PAGE_COUNT;\n\t\t\t}\n\n\t\t\tif (page_zone(page) != zone)\n\t\t\t\tcontinue;\n\n\t\t\tif (!swsusp_page_is_forbidden(page))\n\t\t\t\tswsusp_unset_page_free(page);\n\t\t}\n\n\tfor_each_migratetype_order(order, t) {\n\t\tlist_for_each_entry(page,\n\t\t\t\t&zone->free_area[order].free_list[t], lru) {\n\t\t\tunsigned long i;\n\n\t\t\tpfn = page_to_pfn(page);\n\t\t\tfor (i = 0; i < (1UL << order); i++) {\n\t\t\t\tif (!--page_count) {\n\t\t\t\t\ttouch_nmi_watchdog();\n\t\t\t\t\tpage_count = WD_PAGE_COUNT;\n\t\t\t\t}\n\t\t\t\tswsusp_set_page_free(pfn_to_page(pfn + i));\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&zone->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "split_page",
          "args": [
            "virt_to_page((void *)addr)",
            "order"
          ],
          "line": 4572
        },
        "resolved": true,
        "details": {
          "function_name": "split_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "2846-2856",
          "snippet": "void split_page(struct page *page, unsigned int order)\n{\n\tint i;\n\n\tVM_BUG_ON_PAGE(PageCompound(page), page);\n\tVM_BUG_ON_PAGE(!page_count(page), page);\n\n\tfor (i = 1; i < (1 << order); i++)\n\t\tset_page_refcounted(page + i);\n\tsplit_page_owner(page, order);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid split_page(struct page *page, unsigned int order)\n{\n\tint i;\n\n\tVM_BUG_ON_PAGE(PageCompound(page), page);\n\tVM_BUG_ON_PAGE(!page_count(page), page);\n\n\tfor (i = 1; i < (1 << order); i++)\n\t\tset_page_refcounted(page + i);\n\tsplit_page_owner(page, order);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "(void *)addr"
          ],
          "line": 4572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "size"
          ],
          "line": 4570
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\n\nstatic void *make_alloc_exact(unsigned long addr, unsigned int order,\n\t\tsize_t size)\n{\n\tif (addr) {\n\t\tunsigned long alloc_end = addr + (PAGE_SIZE << order);\n\t\tunsigned long used = addr + PAGE_ALIGN(size);\n\n\t\tsplit_page(virt_to_page((void *)addr), order);\n\t\twhile (used < alloc_end) {\n\t\t\tfree_page(used);\n\t\t\tused += PAGE_SIZE;\n\t\t}\n\t}\n\treturn (void *)addr;\n}"
  },
  {
    "function_name": "page_frag_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "4556-4562",
    "snippet": "void page_frag_free(void *addr)\n{\n\tstruct page *page = virt_to_head_page(addr);\n\n\tif (unlikely(put_page_testzero(page)))\n\t\t__free_pages_ok(page, compound_order(page));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_pages_ok",
          "args": [
            "page",
            "compound_order(page)"
          ],
          "line": 4561
        },
        "resolved": true,
        "details": {
          "function_name": "__free_pages_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1251-1265",
          "snippet": "static void __free_pages_ok(struct page *page, unsigned int order)\n{\n\tunsigned long flags;\n\tint migratetype;\n\tunsigned long pfn = page_to_pfn(page);\n\n\tif (!free_pages_prepare(page, order, true))\n\t\treturn;\n\n\tmigratetype = get_pfnblock_migratetype(page, pfn);\n\tlocal_irq_save(flags);\n\t__count_vm_events(PGFREE, 1 << order);\n\tfree_one_page(page_zone(page), page, pfn, order, migratetype);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic void __free_pages_ok(struct page *page, unsigned int order)\n{\n\tunsigned long flags;\n\tint migratetype;\n\tunsigned long pfn = page_to_pfn(page);\n\n\tif (!free_pages_prepare(page, order, true))\n\t\treturn;\n\n\tmigratetype = get_pfnblock_migratetype(page, pfn);\n\tlocal_irq_save(flags);\n\t__count_vm_events(PGFREE, 1 << order);\n\tfree_one_page(page_zone(page), page, pfn, order, migratetype);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "compound_order",
          "args": [
            "page"
          ],
          "line": 4561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "put_page_testzero(page)"
          ],
          "line": 4560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page_testzero",
          "args": [
            "page"
          ],
          "line": 4560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_head_page",
          "args": [
            "addr"
          ],
          "line": 4558
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid page_frag_free(void *addr)\n{\n\tstruct page *page = virt_to_head_page(addr);\n\n\tif (unlikely(put_page_testzero(page)))\n\t\t__free_pages_ok(page, compound_order(page));\n}"
  },
  {
    "function_name": "page_frag_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "4499-4550",
    "snippet": "void *page_frag_alloc(struct page_frag_cache *nc,\n\t\t      unsigned int fragsz, gfp_t gfp_mask)\n{\n\tunsigned int size = PAGE_SIZE;\n\tstruct page *page;\n\tint offset;\n\n\tif (unlikely(!nc->va)) {\nrefill:\n\t\tpage = __page_frag_cache_refill(nc, gfp_mask);\n\t\tif (!page)\n\t\t\treturn NULL;\n\n#if (PAGE_SIZE < PAGE_FRAG_CACHE_MAX_SIZE)\n\t\t/* if size can vary use size else just use PAGE_SIZE */\n\t\tsize = nc->size;\n#endif\n\t\t/* Even if we own the page, we do not use atomic_set().\n\t\t * This would break get_page_unless_zero() users.\n\t\t */\n\t\tpage_ref_add(page, size - 1);\n\n\t\t/* reset page count bias and offset to start of new frag */\n\t\tnc->pfmemalloc = page_is_pfmemalloc(page);\n\t\tnc->pagecnt_bias = size;\n\t\tnc->offset = size;\n\t}\n\n\toffset = nc->offset - fragsz;\n\tif (unlikely(offset < 0)) {\n\t\tpage = virt_to_page(nc->va);\n\n\t\tif (!page_ref_sub_and_test(page, nc->pagecnt_bias))\n\t\t\tgoto refill;\n\n#if (PAGE_SIZE < PAGE_FRAG_CACHE_MAX_SIZE)\n\t\t/* if size can vary use size else just use PAGE_SIZE */\n\t\tsize = nc->size;\n#endif\n\t\t/* OK, page count is 0, we can safely set it */\n\t\tset_page_count(page, size);\n\n\t\t/* reset page count bias and offset to start of new frag */\n\t\tnc->pagecnt_bias = size;\n\t\toffset = size - fragsz;\n\t}\n\n\tnc->pagecnt_bias--;\n\tnc->offset = offset;\n\n\treturn nc->va + offset;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_page_count",
          "args": [
            "page",
            "size"
          ],
          "line": 4539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_ref_sub_and_test",
          "args": [
            "page",
            "nc->pagecnt_bias"
          ],
          "line": 4531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "nc->va"
          ],
          "line": 4529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "offset < 0"
          ],
          "line": 4528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_is_pfmemalloc",
          "args": [
            "page"
          ],
          "line": 4522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_ref_add",
          "args": [
            "page",
            "size - 1"
          ],
          "line": 4519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__page_frag_cache_refill",
          "args": [
            "nc",
            "gfp_mask"
          ],
          "line": 4508
        },
        "resolved": true,
        "details": {
          "function_name": "__page_frag_cache_refill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4463-4482",
          "snippet": "static struct page *__page_frag_cache_refill(struct page_frag_cache *nc,\n\t\t\t\t\t     gfp_t gfp_mask)\n{\n\tstruct page *page = NULL;\n\tgfp_t gfp = gfp_mask;\n\n#if (PAGE_SIZE < PAGE_FRAG_CACHE_MAX_SIZE)\n\tgfp_mask |= __GFP_COMP | __GFP_NOWARN | __GFP_NORETRY |\n\t\t    __GFP_NOMEMALLOC;\n\tpage = alloc_pages_node(NUMA_NO_NODE, gfp_mask,\n\t\t\t\tPAGE_FRAG_CACHE_MAX_ORDER);\n\tnc->size = page ? PAGE_FRAG_CACHE_MAX_SIZE : PAGE_SIZE;\n#endif\n\tif (unlikely(!page))\n\t\tpage = alloc_pages_node(NUMA_NO_NODE, gfp, 0);\n\n\tnc->va = page ? page_address(page) : NULL;\n\n\treturn page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic struct page *__page_frag_cache_refill(struct page_frag_cache *nc,\n\t\t\t\t\t     gfp_t gfp_mask)\n{\n\tstruct page *page = NULL;\n\tgfp_t gfp = gfp_mask;\n\n#if (PAGE_SIZE < PAGE_FRAG_CACHE_MAX_SIZE)\n\tgfp_mask |= __GFP_COMP | __GFP_NOWARN | __GFP_NORETRY |\n\t\t    __GFP_NOMEMALLOC;\n\tpage = alloc_pages_node(NUMA_NO_NODE, gfp_mask,\n\t\t\t\tPAGE_FRAG_CACHE_MAX_ORDER);\n\tnc->size = page ? PAGE_FRAG_CACHE_MAX_SIZE : PAGE_SIZE;\n#endif\n\tif (unlikely(!page))\n\t\tpage = alloc_pages_node(NUMA_NO_NODE, gfp, 0);\n\n\tnc->va = page ? page_address(page) : NULL;\n\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!nc->va"
          ],
          "line": 4506
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid *page_frag_alloc(struct page_frag_cache *nc,\n\t\t      unsigned int fragsz, gfp_t gfp_mask)\n{\n\tunsigned int size = PAGE_SIZE;\n\tstruct page *page;\n\tint offset;\n\n\tif (unlikely(!nc->va)) {\nrefill:\n\t\tpage = __page_frag_cache_refill(nc, gfp_mask);\n\t\tif (!page)\n\t\t\treturn NULL;\n\n#if (PAGE_SIZE < PAGE_FRAG_CACHE_MAX_SIZE)\n\t\t/* if size can vary use size else just use PAGE_SIZE */\n\t\tsize = nc->size;\n#endif\n\t\t/* Even if we own the page, we do not use atomic_set().\n\t\t * This would break get_page_unless_zero() users.\n\t\t */\n\t\tpage_ref_add(page, size - 1);\n\n\t\t/* reset page count bias and offset to start of new frag */\n\t\tnc->pfmemalloc = page_is_pfmemalloc(page);\n\t\tnc->pagecnt_bias = size;\n\t\tnc->offset = size;\n\t}\n\n\toffset = nc->offset - fragsz;\n\tif (unlikely(offset < 0)) {\n\t\tpage = virt_to_page(nc->va);\n\n\t\tif (!page_ref_sub_and_test(page, nc->pagecnt_bias))\n\t\t\tgoto refill;\n\n#if (PAGE_SIZE < PAGE_FRAG_CACHE_MAX_SIZE)\n\t\t/* if size can vary use size else just use PAGE_SIZE */\n\t\tsize = nc->size;\n#endif\n\t\t/* OK, page count is 0, we can safely set it */\n\t\tset_page_count(page, size);\n\n\t\t/* reset page count bias and offset to start of new frag */\n\t\tnc->pagecnt_bias = size;\n\t\toffset = size - fragsz;\n\t}\n\n\tnc->pagecnt_bias--;\n\tnc->offset = offset;\n\n\treturn nc->va + offset;\n}"
  },
  {
    "function_name": "__page_frag_cache_drain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "4484-4496",
    "snippet": "void __page_frag_cache_drain(struct page *page, unsigned int count)\n{\n\tVM_BUG_ON_PAGE(page_ref_count(page) == 0, page);\n\n\tif (page_ref_sub_and_test(page, count)) {\n\t\tunsigned int order = compound_order(page);\n\n\t\tif (order == 0)\n\t\t\tfree_unref_page(page);\n\t\telse\n\t\t\t__free_pages_ok(page, order);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);",
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_pages_ok",
          "args": [
            "page",
            "order"
          ],
          "line": 4494
        },
        "resolved": true,
        "details": {
          "function_name": "__free_pages_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1251-1265",
          "snippet": "static void __free_pages_ok(struct page *page, unsigned int order)\n{\n\tunsigned long flags;\n\tint migratetype;\n\tunsigned long pfn = page_to_pfn(page);\n\n\tif (!free_pages_prepare(page, order, true))\n\t\treturn;\n\n\tmigratetype = get_pfnblock_migratetype(page, pfn);\n\tlocal_irq_save(flags);\n\t__count_vm_events(PGFREE, 1 << order);\n\tfree_one_page(page_zone(page), page, pfn, order, migratetype);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic void __free_pages_ok(struct page *page, unsigned int order)\n{\n\tunsigned long flags;\n\tint migratetype;\n\tunsigned long pfn = page_to_pfn(page);\n\n\tif (!free_pages_prepare(page, order, true))\n\t\treturn;\n\n\tmigratetype = get_pfnblock_migratetype(page, pfn);\n\tlocal_irq_save(flags);\n\t__count_vm_events(PGFREE, 1 << order);\n\tfree_one_page(page_zone(page), page, pfn, order, migratetype);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_unref_page",
          "args": [
            "page"
          ],
          "line": 4492
        },
        "resolved": true,
        "details": {
          "function_name": "free_unref_page_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "2803-2836",
          "snippet": "void free_unref_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\tunsigned long flags, pfn;\n\tint batch_count = 0;\n\n\t/* Prepare pages for freeing */\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tpfn = page_to_pfn(page);\n\t\tif (!free_unref_page_prepare(page, pfn))\n\t\t\tlist_del(&page->lru);\n\t\tset_page_private(page, pfn);\n\t}\n\n\tlocal_irq_save(flags);\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tunsigned long pfn = page_private(page);\n\n\t\tset_page_private(page, 0);\n\t\ttrace_mm_page_free_batched(page);\n\t\tfree_unref_page_commit(page, pfn);\n\n\t\t/*\n\t\t * Guard against excessive IRQ disabled times when we get\n\t\t * a large list of pages to free.\n\t\t */\n\t\tif (++batch_count == SWAP_CLUSTER_MAX) {\n\t\t\tlocal_irq_restore(flags);\n\t\t\tbatch_count = 0;\n\t\t\tlocal_irq_save(flags);\n\t\t}\n\t}\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid free_unref_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\tunsigned long flags, pfn;\n\tint batch_count = 0;\n\n\t/* Prepare pages for freeing */\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tpfn = page_to_pfn(page);\n\t\tif (!free_unref_page_prepare(page, pfn))\n\t\t\tlist_del(&page->lru);\n\t\tset_page_private(page, pfn);\n\t}\n\n\tlocal_irq_save(flags);\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tunsigned long pfn = page_private(page);\n\n\t\tset_page_private(page, 0);\n\t\ttrace_mm_page_free_batched(page);\n\t\tfree_unref_page_commit(page, pfn);\n\n\t\t/*\n\t\t * Guard against excessive IRQ disabled times when we get\n\t\t * a large list of pages to free.\n\t\t */\n\t\tif (++batch_count == SWAP_CLUSTER_MAX) {\n\t\t\tlocal_irq_restore(flags);\n\t\t\tbatch_count = 0;\n\t\t\tlocal_irq_save(flags);\n\t\t}\n\t}\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "compound_order",
          "args": [
            "page"
          ],
          "line": 4489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_ref_sub_and_test",
          "args": [
            "page",
            "count"
          ],
          "line": 4488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "page_ref_count(page) == 0",
            "page"
          ],
          "line": 4486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_ref_count",
          "args": [
            "page"
          ],
          "line": 4486
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid __page_frag_cache_drain(struct page *page, unsigned int count)\n{\n\tVM_BUG_ON_PAGE(page_ref_count(page) == 0, page);\n\n\tif (page_ref_sub_and_test(page, count)) {\n\t\tunsigned int order = compound_order(page);\n\n\t\tif (order == 0)\n\t\t\tfree_unref_page(page);\n\t\telse\n\t\t\t__free_pages_ok(page, order);\n\t}\n}"
  },
  {
    "function_name": "__page_frag_cache_refill",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "4463-4482",
    "snippet": "static struct page *__page_frag_cache_refill(struct page_frag_cache *nc,\n\t\t\t\t\t     gfp_t gfp_mask)\n{\n\tstruct page *page = NULL;\n\tgfp_t gfp = gfp_mask;\n\n#if (PAGE_SIZE < PAGE_FRAG_CACHE_MAX_SIZE)\n\tgfp_mask |= __GFP_COMP | __GFP_NOWARN | __GFP_NORETRY |\n\t\t    __GFP_NOMEMALLOC;\n\tpage = alloc_pages_node(NUMA_NO_NODE, gfp_mask,\n\t\t\t\tPAGE_FRAG_CACHE_MAX_ORDER);\n\tnc->size = page ? PAGE_FRAG_CACHE_MAX_SIZE : PAGE_SIZE;\n#endif\n\tif (unlikely(!page))\n\t\tpage = alloc_pages_node(NUMA_NO_NODE, gfp, 0);\n\n\tnc->va = page ? page_address(page) : NULL;\n\n\treturn page;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 4479
        },
        "resolved": true,
        "details": {
          "function_name": "page_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
          "lines": "409-434",
          "snippet": "void *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/tlbflush.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nvoid *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_pages_node",
          "args": [
            "NUMA_NO_NODE",
            "gfp",
            "0"
          ],
          "line": 4477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!page"
          ],
          "line": 4476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_pages_node",
          "args": [
            "NUMA_NO_NODE",
            "gfp_mask",
            "PAGE_FRAG_CACHE_MAX_ORDER"
          ],
          "line": 4472
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic struct page *__page_frag_cache_refill(struct page_frag_cache *nc,\n\t\t\t\t\t     gfp_t gfp_mask)\n{\n\tstruct page *page = NULL;\n\tgfp_t gfp = gfp_mask;\n\n#if (PAGE_SIZE < PAGE_FRAG_CACHE_MAX_SIZE)\n\tgfp_mask |= __GFP_COMP | __GFP_NOWARN | __GFP_NORETRY |\n\t\t    __GFP_NOMEMALLOC;\n\tpage = alloc_pages_node(NUMA_NO_NODE, gfp_mask,\n\t\t\t\tPAGE_FRAG_CACHE_MAX_ORDER);\n\tnc->size = page ? PAGE_FRAG_CACHE_MAX_SIZE : PAGE_SIZE;\n#endif\n\tif (unlikely(!page))\n\t\tpage = alloc_pages_node(NUMA_NO_NODE, gfp, 0);\n\n\tnc->va = page ? page_address(page) : NULL;\n\n\treturn page;\n}"
  },
  {
    "function_name": "free_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "4442-4448",
    "snippet": "void free_pages(unsigned long addr, unsigned int order)\n{\n\tif (addr != 0) {\n\t\tVM_BUG_ON(!virt_addr_valid((void *)addr));\n\t\t__free_pages(virt_to_page((void *)addr), order);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_pages",
          "args": [
            "virt_to_page((void *)addr)",
            "order"
          ],
          "line": 4446
        },
        "resolved": true,
        "details": {
          "function_name": "__free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4430-4438",
          "snippet": "void __free_pages(struct page *page, unsigned int order)\n{\n\tif (put_page_testzero(page)) {\n\t\tif (order == 0)\n\t\t\tfree_unref_page(page);\n\t\telse\n\t\t\t__free_pages_ok(page, order);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid __free_pages(struct page *page, unsigned int order)\n{\n\tif (put_page_testzero(page)) {\n\t\tif (order == 0)\n\t\t\tfree_unref_page(page);\n\t\telse\n\t\t\t__free_pages_ok(page, order);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "(void *)addr"
          ],
          "line": 4446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!virt_addr_valid((void *)addr)"
          ],
          "line": 4445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_addr_valid",
          "args": [
            "(void *)addr"
          ],
          "line": 4445
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\n\nvoid free_pages(unsigned long addr, unsigned int order)\n{\n\tif (addr != 0) {\n\t\tVM_BUG_ON(!virt_addr_valid((void *)addr));\n\t\t__free_pages(virt_to_page((void *)addr), order);\n\t}\n}"
  },
  {
    "function_name": "__free_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "4430-4438",
    "snippet": "void __free_pages(struct page *page, unsigned int order)\n{\n\tif (put_page_testzero(page)) {\n\t\tif (order == 0)\n\t\t\tfree_unref_page(page);\n\t\telse\n\t\t\t__free_pages_ok(page, order);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);",
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_pages_ok",
          "args": [
            "page",
            "order"
          ],
          "line": 4436
        },
        "resolved": true,
        "details": {
          "function_name": "__free_pages_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1251-1265",
          "snippet": "static void __free_pages_ok(struct page *page, unsigned int order)\n{\n\tunsigned long flags;\n\tint migratetype;\n\tunsigned long pfn = page_to_pfn(page);\n\n\tif (!free_pages_prepare(page, order, true))\n\t\treturn;\n\n\tmigratetype = get_pfnblock_migratetype(page, pfn);\n\tlocal_irq_save(flags);\n\t__count_vm_events(PGFREE, 1 << order);\n\tfree_one_page(page_zone(page), page, pfn, order, migratetype);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic void __free_pages_ok(struct page *page, unsigned int order)\n{\n\tunsigned long flags;\n\tint migratetype;\n\tunsigned long pfn = page_to_pfn(page);\n\n\tif (!free_pages_prepare(page, order, true))\n\t\treturn;\n\n\tmigratetype = get_pfnblock_migratetype(page, pfn);\n\tlocal_irq_save(flags);\n\t__count_vm_events(PGFREE, 1 << order);\n\tfree_one_page(page_zone(page), page, pfn, order, migratetype);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_unref_page",
          "args": [
            "page"
          ],
          "line": 4434
        },
        "resolved": true,
        "details": {
          "function_name": "free_unref_page_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "2803-2836",
          "snippet": "void free_unref_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\tunsigned long flags, pfn;\n\tint batch_count = 0;\n\n\t/* Prepare pages for freeing */\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tpfn = page_to_pfn(page);\n\t\tif (!free_unref_page_prepare(page, pfn))\n\t\t\tlist_del(&page->lru);\n\t\tset_page_private(page, pfn);\n\t}\n\n\tlocal_irq_save(flags);\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tunsigned long pfn = page_private(page);\n\n\t\tset_page_private(page, 0);\n\t\ttrace_mm_page_free_batched(page);\n\t\tfree_unref_page_commit(page, pfn);\n\n\t\t/*\n\t\t * Guard against excessive IRQ disabled times when we get\n\t\t * a large list of pages to free.\n\t\t */\n\t\tif (++batch_count == SWAP_CLUSTER_MAX) {\n\t\t\tlocal_irq_restore(flags);\n\t\t\tbatch_count = 0;\n\t\t\tlocal_irq_save(flags);\n\t\t}\n\t}\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid free_unref_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\tunsigned long flags, pfn;\n\tint batch_count = 0;\n\n\t/* Prepare pages for freeing */\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tpfn = page_to_pfn(page);\n\t\tif (!free_unref_page_prepare(page, pfn))\n\t\t\tlist_del(&page->lru);\n\t\tset_page_private(page, pfn);\n\t}\n\n\tlocal_irq_save(flags);\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tunsigned long pfn = page_private(page);\n\n\t\tset_page_private(page, 0);\n\t\ttrace_mm_page_free_batched(page);\n\t\tfree_unref_page_commit(page, pfn);\n\n\t\t/*\n\t\t * Guard against excessive IRQ disabled times when we get\n\t\t * a large list of pages to free.\n\t\t */\n\t\tif (++batch_count == SWAP_CLUSTER_MAX) {\n\t\t\tlocal_irq_restore(flags);\n\t\t\tbatch_count = 0;\n\t\t\tlocal_irq_save(flags);\n\t\t}\n\t}\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_page_testzero",
          "args": [
            "page"
          ],
          "line": 4432
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid __free_pages(struct page *page, unsigned int order)\n{\n\tif (put_page_testzero(page)) {\n\t\tif (order == 0)\n\t\t\tfree_unref_page(page);\n\t\telse\n\t\t\t__free_pages_ok(page, order);\n\t}\n}"
  },
  {
    "function_name": "get_zeroed_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "4424-4427",
    "snippet": "unsigned long get_zeroed_page(gfp_t gfp_mask)\n{\n\treturn __get_free_pages(gfp_mask | __GFP_ZERO, 0);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__get_free_pages",
          "args": [
            "gfp_mask | __GFP_ZERO",
            "0"
          ],
          "line": 4426
        },
        "resolved": true,
        "details": {
          "function_name": "__get_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4413-4421",
          "snippet": "unsigned long __get_free_pages(gfp_t gfp_mask, unsigned int order)\n{\n\tstruct page *page;\n\n\tpage = alloc_pages(gfp_mask & ~__GFP_HIGHMEM, order);\n\tif (!page)\n\t\treturn 0;\n\treturn (unsigned long) page_address(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nunsigned long __get_free_pages(gfp_t gfp_mask, unsigned int order)\n{\n\tstruct page *page;\n\n\tpage = alloc_pages(gfp_mask & ~__GFP_HIGHMEM, order);\n\tif (!page)\n\t\treturn 0;\n\treturn (unsigned long) page_address(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nunsigned long get_zeroed_page(gfp_t gfp_mask)\n{\n\treturn __get_free_pages(gfp_mask | __GFP_ZERO, 0);\n}"
  },
  {
    "function_name": "__get_free_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "4413-4421",
    "snippet": "unsigned long __get_free_pages(gfp_t gfp_mask, unsigned int order)\n{\n\tstruct page *page;\n\n\tpage = alloc_pages(gfp_mask & ~__GFP_HIGHMEM, order);\n\tif (!page)\n\t\treturn 0;\n\treturn (unsigned long) page_address(page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);",
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 4420
        },
        "resolved": true,
        "details": {
          "function_name": "page_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
          "lines": "409-434",
          "snippet": "void *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/tlbflush.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nvoid *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_pages",
          "args": [
            "gfp_mask & ~__GFP_HIGHMEM",
            "order"
          ],
          "line": 4417
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_pages_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4594-4601",
          "snippet": "void *alloc_pages_exact(size_t size, gfp_t gfp_mask)\n{\n\tunsigned int order = get_order(size);\n\tunsigned long addr;\n\n\taddr = __get_free_pages(gfp_mask, order);\n\treturn make_alloc_exact(addr, order, size);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\n\nvoid *alloc_pages_exact(size_t size, gfp_t gfp_mask)\n{\n\tunsigned int order = get_order(size);\n\tunsigned long addr;\n\n\taddr = __get_free_pages(gfp_mask, order);\n\treturn make_alloc_exact(addr, order, size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nunsigned long __get_free_pages(gfp_t gfp_mask, unsigned int order)\n{\n\tstruct page *page;\n\n\tpage = alloc_pages(gfp_mask & ~__GFP_HIGHMEM, order);\n\tif (!page)\n\t\treturn 0;\n\treturn (unsigned long) page_address(page);\n}"
  },
  {
    "function_name": "__alloc_pages_nodemask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "4347-4405",
    "snippet": "struct page *\n__alloc_pages_nodemask(gfp_t gfp_mask, unsigned int order, int preferred_nid,\n\t\t\t\t\t\t\tnodemask_t *nodemask)\n{\n\tstruct page *page;\n\tunsigned int alloc_flags = ALLOC_WMARK_LOW;\n\tgfp_t alloc_mask; /* The gfp_t that was actually used for allocation */\n\tstruct alloc_context ac = { };\n\n\t/*\n\t * There are several places where we assume that the order value is sane\n\t * so bail out early if the request is out of bound.\n\t */\n\tif (unlikely(order >= MAX_ORDER)) {\n\t\tWARN_ON_ONCE(!(gfp_mask & __GFP_NOWARN));\n\t\treturn NULL;\n\t}\n\n\tgfp_mask &= gfp_allowed_mask;\n\talloc_mask = gfp_mask;\n\tif (!prepare_alloc_pages(gfp_mask, order, preferred_nid, nodemask, &ac, &alloc_mask, &alloc_flags))\n\t\treturn NULL;\n\n\tfinalise_ac(gfp_mask, &ac);\n\n\t/* First allocation attempt */\n\tpage = get_page_from_freelist(alloc_mask, order, alloc_flags, &ac);\n\tif (likely(page))\n\t\tgoto out;\n\n\t/*\n\t * Apply scoped allocation constraints. This is mainly about GFP_NOFS\n\t * resp. GFP_NOIO which has to be inherited for all allocation requests\n\t * from a particular context which has been marked by\n\t * memalloc_no{fs,io}_{save,restore}.\n\t */\n\talloc_mask = current_gfp_context(gfp_mask);\n\tac.spread_dirty_pages = false;\n\n\t/*\n\t * Restore the original nodemask if it was potentially replaced with\n\t * &cpuset_current_mems_allowed to optimize the fast-path attempt.\n\t */\n\tif (unlikely(ac.nodemask != nodemask))\n\t\tac.nodemask = nodemask;\n\n\tpage = __alloc_pages_slowpath(alloc_mask, order, &ac);\n\nout:\n\tif (memcg_kmem_enabled() && (gfp_mask & __GFP_ACCOUNT) && page &&\n\t    unlikely(memcg_kmem_charge(page, gfp_mask, order) != 0)) {\n\t\t__free_pages(page, order);\n\t\tpage = NULL;\n\t}\n\n\ttrace_mm_page_alloc(page, order, alloc_mask, ac.migratetype);\n\n\treturn page;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "gfp_t gfp_allowed_mask",
      "static void __free_pages_ok(struct page *page, unsigned int order);",
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_mm_page_alloc",
          "args": [
            "page",
            "order",
            "alloc_mask",
            "ac.migratetype"
          ],
          "line": 4402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_pages",
          "args": [
            "page",
            "order"
          ],
          "line": 4398
        },
        "resolved": true,
        "details": {
          "function_name": "__free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4430-4438",
          "snippet": "void __free_pages(struct page *page, unsigned int order)\n{\n\tif (put_page_testzero(page)) {\n\t\tif (order == 0)\n\t\t\tfree_unref_page(page);\n\t\telse\n\t\t\t__free_pages_ok(page, order);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid __free_pages(struct page *page, unsigned int order)\n{\n\tif (put_page_testzero(page)) {\n\t\tif (order == 0)\n\t\t\tfree_unref_page(page);\n\t\telse\n\t\t\t__free_pages_ok(page, order);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "memcg_kmem_charge(page, gfp_mask, order) != 0"
          ],
          "line": 4397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcg_kmem_charge",
          "args": [
            "page",
            "gfp_mask",
            "order"
          ],
          "line": 4397
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_kmem_charge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "2591-2607",
          "snippet": "int memcg_kmem_charge(struct page *page, gfp_t gfp, int order)\n{\n\tstruct mem_cgroup *memcg;\n\tint ret = 0;\n\n\tif (mem_cgroup_disabled() || memcg_kmem_bypass())\n\t\treturn 0;\n\n\tmemcg = get_mem_cgroup_from_current();\n\tif (!mem_cgroup_is_root(memcg)) {\n\t\tret = memcg_kmem_charge_memcg(page, gfp, order, memcg);\n\t\tif (!ret)\n\t\t\t__SetPageKmemcg(page);\n\t}\n\tcss_put(&memcg->css);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nint memcg_kmem_charge(struct page *page, gfp_t gfp, int order)\n{\n\tstruct mem_cgroup *memcg;\n\tint ret = 0;\n\n\tif (mem_cgroup_disabled() || memcg_kmem_bypass())\n\t\treturn 0;\n\n\tmemcg = get_mem_cgroup_from_current();\n\tif (!mem_cgroup_is_root(memcg)) {\n\t\tret = memcg_kmem_charge_memcg(page, gfp, order, memcg);\n\t\tif (!ret)\n\t\t\t__SetPageKmemcg(page);\n\t}\n\tcss_put(&memcg->css);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcg_kmem_enabled",
          "args": [],
          "line": 4396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__alloc_pages_slowpath",
          "args": [
            "alloc_mask",
            "order",
            "&ac"
          ],
          "line": 4393
        },
        "resolved": true,
        "details": {
          "function_name": "__alloc_pages_slowpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4047-4295",
          "snippet": "static inline struct page *\n__alloc_pages_slowpath(gfp_t gfp_mask, unsigned int order,\n\t\t\t\t\t\tstruct alloc_context *ac)\n{\n\tbool can_direct_reclaim = gfp_mask & __GFP_DIRECT_RECLAIM;\n\tconst bool costly_order = order > PAGE_ALLOC_COSTLY_ORDER;\n\tstruct page *page = NULL;\n\tunsigned int alloc_flags;\n\tunsigned long did_some_progress;\n\tenum compact_priority compact_priority;\n\tenum compact_result compact_result;\n\tint compaction_retries;\n\tint no_progress_loops;\n\tunsigned int cpuset_mems_cookie;\n\tint reserve_flags;\n\n\t/*\n\t * We also sanity check to catch abuse of atomic reserves being used by\n\t * callers that are not in atomic context.\n\t */\n\tif (WARN_ON_ONCE((gfp_mask & (__GFP_ATOMIC|__GFP_DIRECT_RECLAIM)) ==\n\t\t\t\t(__GFP_ATOMIC|__GFP_DIRECT_RECLAIM)))\n\t\tgfp_mask &= ~__GFP_ATOMIC;\n\nretry_cpuset:\n\tcompaction_retries = 0;\n\tno_progress_loops = 0;\n\tcompact_priority = DEF_COMPACT_PRIORITY;\n\tcpuset_mems_cookie = read_mems_allowed_begin();\n\n\t/*\n\t * The fast path uses conservative alloc_flags to succeed only until\n\t * kswapd needs to be woken up, and to avoid the cost of setting up\n\t * alloc_flags precisely. So we do that now.\n\t */\n\talloc_flags = gfp_to_alloc_flags(gfp_mask);\n\n\t/*\n\t * We need to recalculate the starting point for the zonelist iterator\n\t * because we might have used different nodemask in the fast path, or\n\t * there was a cpuset modification and we are retrying - otherwise we\n\t * could end up iterating over non-eligible zones endlessly.\n\t */\n\tac->preferred_zoneref = first_zones_zonelist(ac->zonelist,\n\t\t\t\t\tac->high_zoneidx, ac->nodemask);\n\tif (!ac->preferred_zoneref->zone)\n\t\tgoto nopage;\n\n\tif (gfp_mask & __GFP_KSWAPD_RECLAIM)\n\t\twake_all_kswapds(order, gfp_mask, ac);\n\n\t/*\n\t * The adjusted alloc_flags might result in immediate success, so try\n\t * that first\n\t */\n\tpage = get_page_from_freelist(gfp_mask, order, alloc_flags, ac);\n\tif (page)\n\t\tgoto got_pg;\n\n\t/*\n\t * For costly allocations, try direct compaction first, as it's likely\n\t * that we have enough base pages and don't need to reclaim. For non-\n\t * movable high-order allocations, do that as well, as compaction will\n\t * try prevent permanent fragmentation by migrating from blocks of the\n\t * same migratetype.\n\t * Don't try this for allocations that are allowed to ignore\n\t * watermarks, as the ALLOC_NO_WATERMARKS attempt didn't yet happen.\n\t */\n\tif (can_direct_reclaim &&\n\t\t\t(costly_order ||\n\t\t\t   (order > 0 && ac->migratetype != MIGRATE_MOVABLE))\n\t\t\t&& !gfp_pfmemalloc_allowed(gfp_mask)) {\n\t\tpage = __alloc_pages_direct_compact(gfp_mask, order,\n\t\t\t\t\t\talloc_flags, ac,\n\t\t\t\t\t\tINIT_COMPACT_PRIORITY,\n\t\t\t\t\t\t&compact_result);\n\t\tif (page)\n\t\t\tgoto got_pg;\n\n\t\t/*\n\t\t * Checks for costly allocations with __GFP_NORETRY, which\n\t\t * includes THP page fault allocations\n\t\t */\n\t\tif (costly_order && (gfp_mask & __GFP_NORETRY)) {\n\t\t\t/*\n\t\t\t * If compaction is deferred for high-order allocations,\n\t\t\t * it is because sync compaction recently failed. If\n\t\t\t * this is the case and the caller requested a THP\n\t\t\t * allocation, we do not want to heavily disrupt the\n\t\t\t * system, so we fail the allocation instead of entering\n\t\t\t * direct reclaim.\n\t\t\t */\n\t\t\tif (compact_result == COMPACT_DEFERRED)\n\t\t\t\tgoto nopage;\n\n\t\t\t/*\n\t\t\t * Looks like reclaim/compaction is worth trying, but\n\t\t\t * sync compaction could be very expensive, so keep\n\t\t\t * using async compaction.\n\t\t\t */\n\t\t\tcompact_priority = INIT_COMPACT_PRIORITY;\n\t\t}\n\t}\n\nretry:\n\t/* Ensure kswapd doesn't accidentally go to sleep as long as we loop */\n\tif (gfp_mask & __GFP_KSWAPD_RECLAIM)\n\t\twake_all_kswapds(order, gfp_mask, ac);\n\n\treserve_flags = __gfp_pfmemalloc_flags(gfp_mask);\n\tif (reserve_flags)\n\t\talloc_flags = reserve_flags;\n\n\t/*\n\t * Reset the nodemask and zonelist iterators if memory policies can be\n\t * ignored. These allocations are high priority and system rather than\n\t * user oriented.\n\t */\n\tif (!(alloc_flags & ALLOC_CPUSET) || reserve_flags) {\n\t\tac->nodemask = NULL;\n\t\tac->preferred_zoneref = first_zones_zonelist(ac->zonelist,\n\t\t\t\t\tac->high_zoneidx, ac->nodemask);\n\t}\n\n\t/* Attempt with potentially adjusted zonelist and alloc_flags */\n\tpage = get_page_from_freelist(gfp_mask, order, alloc_flags, ac);\n\tif (page)\n\t\tgoto got_pg;\n\n\t/* Caller is not willing to reclaim, we can't balance anything */\n\tif (!can_direct_reclaim)\n\t\tgoto nopage;\n\n\t/* Avoid recursion of direct reclaim */\n\tif (current->flags & PF_MEMALLOC)\n\t\tgoto nopage;\n\n\t/* Try direct reclaim and then allocating */\n\tpage = __alloc_pages_direct_reclaim(gfp_mask, order, alloc_flags, ac,\n\t\t\t\t\t\t\t&did_some_progress);\n\tif (page)\n\t\tgoto got_pg;\n\n\t/* Try direct compaction and then allocating */\n\tpage = __alloc_pages_direct_compact(gfp_mask, order, alloc_flags, ac,\n\t\t\t\t\tcompact_priority, &compact_result);\n\tif (page)\n\t\tgoto got_pg;\n\n\t/* Do not loop if specifically requested */\n\tif (gfp_mask & __GFP_NORETRY)\n\t\tgoto nopage;\n\n\t/*\n\t * Do not retry costly high order allocations unless they are\n\t * __GFP_RETRY_MAYFAIL\n\t */\n\tif (costly_order && !(gfp_mask & __GFP_RETRY_MAYFAIL))\n\t\tgoto nopage;\n\n\tif (should_reclaim_retry(gfp_mask, order, ac, alloc_flags,\n\t\t\t\t did_some_progress > 0, &no_progress_loops))\n\t\tgoto retry;\n\n\t/*\n\t * It doesn't make any sense to retry for the compaction if the order-0\n\t * reclaim is not able to make any progress because the current\n\t * implementation of the compaction depends on the sufficient amount\n\t * of free memory (see __compaction_suitable)\n\t */\n\tif (did_some_progress > 0 &&\n\t\t\tshould_compact_retry(ac, order, alloc_flags,\n\t\t\t\tcompact_result, &compact_priority,\n\t\t\t\t&compaction_retries))\n\t\tgoto retry;\n\n\n\t/* Deal with possible cpuset update races before we start OOM killing */\n\tif (check_retry_cpuset(cpuset_mems_cookie, ac))\n\t\tgoto retry_cpuset;\n\n\t/* Reclaim has failed us, start killing things */\n\tpage = __alloc_pages_may_oom(gfp_mask, order, ac, &did_some_progress);\n\tif (page)\n\t\tgoto got_pg;\n\n\t/* Avoid allocations with no watermarks from looping endlessly */\n\tif (tsk_is_oom_victim(current) &&\n\t    (alloc_flags == ALLOC_OOM ||\n\t     (gfp_mask & __GFP_NOMEMALLOC)))\n\t\tgoto nopage;\n\n\t/* Retry as long as the OOM killer is making progress */\n\tif (did_some_progress) {\n\t\tno_progress_loops = 0;\n\t\tgoto retry;\n\t}\n\nnopage:\n\t/* Deal with possible cpuset update races before we fail */\n\tif (check_retry_cpuset(cpuset_mems_cookie, ac))\n\t\tgoto retry_cpuset;\n\n\t/*\n\t * Make sure that __GFP_NOFAIL request doesn't leak out and make sure\n\t * we always retry\n\t */\n\tif (gfp_mask & __GFP_NOFAIL) {\n\t\t/*\n\t\t * All existing users of the __GFP_NOFAIL are blockable, so warn\n\t\t * of any new users that actually require GFP_NOWAIT\n\t\t */\n\t\tif (WARN_ON_ONCE(!can_direct_reclaim))\n\t\t\tgoto fail;\n\n\t\t/*\n\t\t * PF_MEMALLOC request from this context is rather bizarre\n\t\t * because we cannot reclaim anything and only can loop waiting\n\t\t * for somebody to do a work for us\n\t\t */\n\t\tWARN_ON_ONCE(current->flags & PF_MEMALLOC);\n\n\t\t/*\n\t\t * non failing costly orders are a hard requirement which we\n\t\t * are not prepared for much so let's warn about these users\n\t\t * so that we can identify them and convert them to something\n\t\t * else.\n\t\t */\n\t\tWARN_ON_ONCE(order > PAGE_ALLOC_COSTLY_ORDER);\n\n\t\t/*\n\t\t * Help non-failing allocations by giving them access to memory\n\t\t * reserves but do not use ALLOC_NO_WATERMARKS because this\n\t\t * could deplete whole memory reserves which would just make\n\t\t * the situation worse\n\t\t */\n\t\tpage = __alloc_pages_cpuset_fallback(gfp_mask, order, ALLOC_HARDER, ac);\n\t\tif (page)\n\t\t\tgoto got_pg;\n\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\nfail:\n\twarn_alloc(gfp_mask, ac->nodemask,\n\t\t\t\"page allocation failure: order:%u\", order);\ngot_pg:\n\treturn page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline struct page *\n__alloc_pages_slowpath(gfp_t gfp_mask, unsigned int order,\n\t\t\t\t\t\tstruct alloc_context *ac)\n{\n\tbool can_direct_reclaim = gfp_mask & __GFP_DIRECT_RECLAIM;\n\tconst bool costly_order = order > PAGE_ALLOC_COSTLY_ORDER;\n\tstruct page *page = NULL;\n\tunsigned int alloc_flags;\n\tunsigned long did_some_progress;\n\tenum compact_priority compact_priority;\n\tenum compact_result compact_result;\n\tint compaction_retries;\n\tint no_progress_loops;\n\tunsigned int cpuset_mems_cookie;\n\tint reserve_flags;\n\n\t/*\n\t * We also sanity check to catch abuse of atomic reserves being used by\n\t * callers that are not in atomic context.\n\t */\n\tif (WARN_ON_ONCE((gfp_mask & (__GFP_ATOMIC|__GFP_DIRECT_RECLAIM)) ==\n\t\t\t\t(__GFP_ATOMIC|__GFP_DIRECT_RECLAIM)))\n\t\tgfp_mask &= ~__GFP_ATOMIC;\n\nretry_cpuset:\n\tcompaction_retries = 0;\n\tno_progress_loops = 0;\n\tcompact_priority = DEF_COMPACT_PRIORITY;\n\tcpuset_mems_cookie = read_mems_allowed_begin();\n\n\t/*\n\t * The fast path uses conservative alloc_flags to succeed only until\n\t * kswapd needs to be woken up, and to avoid the cost of setting up\n\t * alloc_flags precisely. So we do that now.\n\t */\n\talloc_flags = gfp_to_alloc_flags(gfp_mask);\n\n\t/*\n\t * We need to recalculate the starting point for the zonelist iterator\n\t * because we might have used different nodemask in the fast path, or\n\t * there was a cpuset modification and we are retrying - otherwise we\n\t * could end up iterating over non-eligible zones endlessly.\n\t */\n\tac->preferred_zoneref = first_zones_zonelist(ac->zonelist,\n\t\t\t\t\tac->high_zoneidx, ac->nodemask);\n\tif (!ac->preferred_zoneref->zone)\n\t\tgoto nopage;\n\n\tif (gfp_mask & __GFP_KSWAPD_RECLAIM)\n\t\twake_all_kswapds(order, gfp_mask, ac);\n\n\t/*\n\t * The adjusted alloc_flags might result in immediate success, so try\n\t * that first\n\t */\n\tpage = get_page_from_freelist(gfp_mask, order, alloc_flags, ac);\n\tif (page)\n\t\tgoto got_pg;\n\n\t/*\n\t * For costly allocations, try direct compaction first, as it's likely\n\t * that we have enough base pages and don't need to reclaim. For non-\n\t * movable high-order allocations, do that as well, as compaction will\n\t * try prevent permanent fragmentation by migrating from blocks of the\n\t * same migratetype.\n\t * Don't try this for allocations that are allowed to ignore\n\t * watermarks, as the ALLOC_NO_WATERMARKS attempt didn't yet happen.\n\t */\n\tif (can_direct_reclaim &&\n\t\t\t(costly_order ||\n\t\t\t   (order > 0 && ac->migratetype != MIGRATE_MOVABLE))\n\t\t\t&& !gfp_pfmemalloc_allowed(gfp_mask)) {\n\t\tpage = __alloc_pages_direct_compact(gfp_mask, order,\n\t\t\t\t\t\talloc_flags, ac,\n\t\t\t\t\t\tINIT_COMPACT_PRIORITY,\n\t\t\t\t\t\t&compact_result);\n\t\tif (page)\n\t\t\tgoto got_pg;\n\n\t\t/*\n\t\t * Checks for costly allocations with __GFP_NORETRY, which\n\t\t * includes THP page fault allocations\n\t\t */\n\t\tif (costly_order && (gfp_mask & __GFP_NORETRY)) {\n\t\t\t/*\n\t\t\t * If compaction is deferred for high-order allocations,\n\t\t\t * it is because sync compaction recently failed. If\n\t\t\t * this is the case and the caller requested a THP\n\t\t\t * allocation, we do not want to heavily disrupt the\n\t\t\t * system, so we fail the allocation instead of entering\n\t\t\t * direct reclaim.\n\t\t\t */\n\t\t\tif (compact_result == COMPACT_DEFERRED)\n\t\t\t\tgoto nopage;\n\n\t\t\t/*\n\t\t\t * Looks like reclaim/compaction is worth trying, but\n\t\t\t * sync compaction could be very expensive, so keep\n\t\t\t * using async compaction.\n\t\t\t */\n\t\t\tcompact_priority = INIT_COMPACT_PRIORITY;\n\t\t}\n\t}\n\nretry:\n\t/* Ensure kswapd doesn't accidentally go to sleep as long as we loop */\n\tif (gfp_mask & __GFP_KSWAPD_RECLAIM)\n\t\twake_all_kswapds(order, gfp_mask, ac);\n\n\treserve_flags = __gfp_pfmemalloc_flags(gfp_mask);\n\tif (reserve_flags)\n\t\talloc_flags = reserve_flags;\n\n\t/*\n\t * Reset the nodemask and zonelist iterators if memory policies can be\n\t * ignored. These allocations are high priority and system rather than\n\t * user oriented.\n\t */\n\tif (!(alloc_flags & ALLOC_CPUSET) || reserve_flags) {\n\t\tac->nodemask = NULL;\n\t\tac->preferred_zoneref = first_zones_zonelist(ac->zonelist,\n\t\t\t\t\tac->high_zoneidx, ac->nodemask);\n\t}\n\n\t/* Attempt with potentially adjusted zonelist and alloc_flags */\n\tpage = get_page_from_freelist(gfp_mask, order, alloc_flags, ac);\n\tif (page)\n\t\tgoto got_pg;\n\n\t/* Caller is not willing to reclaim, we can't balance anything */\n\tif (!can_direct_reclaim)\n\t\tgoto nopage;\n\n\t/* Avoid recursion of direct reclaim */\n\tif (current->flags & PF_MEMALLOC)\n\t\tgoto nopage;\n\n\t/* Try direct reclaim and then allocating */\n\tpage = __alloc_pages_direct_reclaim(gfp_mask, order, alloc_flags, ac,\n\t\t\t\t\t\t\t&did_some_progress);\n\tif (page)\n\t\tgoto got_pg;\n\n\t/* Try direct compaction and then allocating */\n\tpage = __alloc_pages_direct_compact(gfp_mask, order, alloc_flags, ac,\n\t\t\t\t\tcompact_priority, &compact_result);\n\tif (page)\n\t\tgoto got_pg;\n\n\t/* Do not loop if specifically requested */\n\tif (gfp_mask & __GFP_NORETRY)\n\t\tgoto nopage;\n\n\t/*\n\t * Do not retry costly high order allocations unless they are\n\t * __GFP_RETRY_MAYFAIL\n\t */\n\tif (costly_order && !(gfp_mask & __GFP_RETRY_MAYFAIL))\n\t\tgoto nopage;\n\n\tif (should_reclaim_retry(gfp_mask, order, ac, alloc_flags,\n\t\t\t\t did_some_progress > 0, &no_progress_loops))\n\t\tgoto retry;\n\n\t/*\n\t * It doesn't make any sense to retry for the compaction if the order-0\n\t * reclaim is not able to make any progress because the current\n\t * implementation of the compaction depends on the sufficient amount\n\t * of free memory (see __compaction_suitable)\n\t */\n\tif (did_some_progress > 0 &&\n\t\t\tshould_compact_retry(ac, order, alloc_flags,\n\t\t\t\tcompact_result, &compact_priority,\n\t\t\t\t&compaction_retries))\n\t\tgoto retry;\n\n\n\t/* Deal with possible cpuset update races before we start OOM killing */\n\tif (check_retry_cpuset(cpuset_mems_cookie, ac))\n\t\tgoto retry_cpuset;\n\n\t/* Reclaim has failed us, start killing things */\n\tpage = __alloc_pages_may_oom(gfp_mask, order, ac, &did_some_progress);\n\tif (page)\n\t\tgoto got_pg;\n\n\t/* Avoid allocations with no watermarks from looping endlessly */\n\tif (tsk_is_oom_victim(current) &&\n\t    (alloc_flags == ALLOC_OOM ||\n\t     (gfp_mask & __GFP_NOMEMALLOC)))\n\t\tgoto nopage;\n\n\t/* Retry as long as the OOM killer is making progress */\n\tif (did_some_progress) {\n\t\tno_progress_loops = 0;\n\t\tgoto retry;\n\t}\n\nnopage:\n\t/* Deal with possible cpuset update races before we fail */\n\tif (check_retry_cpuset(cpuset_mems_cookie, ac))\n\t\tgoto retry_cpuset;\n\n\t/*\n\t * Make sure that __GFP_NOFAIL request doesn't leak out and make sure\n\t * we always retry\n\t */\n\tif (gfp_mask & __GFP_NOFAIL) {\n\t\t/*\n\t\t * All existing users of the __GFP_NOFAIL are blockable, so warn\n\t\t * of any new users that actually require GFP_NOWAIT\n\t\t */\n\t\tif (WARN_ON_ONCE(!can_direct_reclaim))\n\t\t\tgoto fail;\n\n\t\t/*\n\t\t * PF_MEMALLOC request from this context is rather bizarre\n\t\t * because we cannot reclaim anything and only can loop waiting\n\t\t * for somebody to do a work for us\n\t\t */\n\t\tWARN_ON_ONCE(current->flags & PF_MEMALLOC);\n\n\t\t/*\n\t\t * non failing costly orders are a hard requirement which we\n\t\t * are not prepared for much so let's warn about these users\n\t\t * so that we can identify them and convert them to something\n\t\t * else.\n\t\t */\n\t\tWARN_ON_ONCE(order > PAGE_ALLOC_COSTLY_ORDER);\n\n\t\t/*\n\t\t * Help non-failing allocations by giving them access to memory\n\t\t * reserves but do not use ALLOC_NO_WATERMARKS because this\n\t\t * could deplete whole memory reserves which would just make\n\t\t * the situation worse\n\t\t */\n\t\tpage = __alloc_pages_cpuset_fallback(gfp_mask, order, ALLOC_HARDER, ac);\n\t\tif (page)\n\t\t\tgoto got_pg;\n\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\nfail:\n\twarn_alloc(gfp_mask, ac->nodemask,\n\t\t\t\"page allocation failure: order:%u\", order);\ngot_pg:\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ac.nodemask != nodemask"
          ],
          "line": 4390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_gfp_context",
          "args": [
            "gfp_mask"
          ],
          "line": 4383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "page"
          ],
          "line": 4374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page_from_freelist",
          "args": [
            "alloc_mask",
            "order",
            "alloc_flags",
            "&ac"
          ],
          "line": 4373
        },
        "resolved": true,
        "details": {
          "function_name": "get_page_from_freelist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3260-3378",
          "snippet": "static struct page *\nget_page_from_freelist(gfp_t gfp_mask, unsigned int order, int alloc_flags,\n\t\t\t\t\t\tconst struct alloc_context *ac)\n{\n\tstruct zoneref *z = ac->preferred_zoneref;\n\tstruct zone *zone;\n\tstruct pglist_data *last_pgdat_dirty_limit = NULL;\n\n\t/*\n\t * Scan zonelist, looking for a zone with enough free.\n\t * See also __cpuset_node_allowed() comment in kernel/cpuset.c.\n\t */\n\tfor_next_zone_zonelist_nodemask(zone, z, ac->zonelist, ac->high_zoneidx,\n\t\t\t\t\t\t\t\tac->nodemask) {\n\t\tstruct page *page;\n\t\tunsigned long mark;\n\n\t\tif (cpusets_enabled() &&\n\t\t\t(alloc_flags & ALLOC_CPUSET) &&\n\t\t\t!__cpuset_zone_allowed(zone, gfp_mask))\n\t\t\t\tcontinue;\n\t\t/*\n\t\t * When allocating a page cache page for writing, we\n\t\t * want to get it from a node that is within its dirty\n\t\t * limit, such that no single node holds more than its\n\t\t * proportional share of globally allowed dirty pages.\n\t\t * The dirty limits take into account the node's\n\t\t * lowmem reserves and high watermark so that kswapd\n\t\t * should be able to balance it without having to\n\t\t * write pages from its LRU list.\n\t\t *\n\t\t * XXX: For now, allow allocations to potentially\n\t\t * exceed the per-node dirty limit in the slowpath\n\t\t * (spread_dirty_pages unset) before going into reclaim,\n\t\t * which is important when on a NUMA setup the allowed\n\t\t * nodes are together not big enough to reach the\n\t\t * global limit.  The proper fix for these situations\n\t\t * will require awareness of nodes in the\n\t\t * dirty-throttling and the flusher threads.\n\t\t */\n\t\tif (ac->spread_dirty_pages) {\n\t\t\tif (last_pgdat_dirty_limit == zone->zone_pgdat)\n\t\t\t\tcontinue;\n\n\t\t\tif (!node_dirty_ok(zone->zone_pgdat)) {\n\t\t\t\tlast_pgdat_dirty_limit = zone->zone_pgdat;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tmark = zone->watermark[alloc_flags & ALLOC_WMARK_MASK];\n\t\tif (!zone_watermark_fast(zone, order, mark,\n\t\t\t\t       ac_classzone_idx(ac), alloc_flags)) {\n\t\t\tint ret;\n\n#ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT\n\t\t\t/*\n\t\t\t * Watermark failed for this zone, but see if we can\n\t\t\t * grow this zone if it contains deferred pages.\n\t\t\t */\n\t\t\tif (static_branch_unlikely(&deferred_pages)) {\n\t\t\t\tif (_deferred_grow_zone(zone, order))\n\t\t\t\t\tgoto try_this_zone;\n\t\t\t}\n#endif\n\t\t\t/* Checked here to keep the fast path fast */\n\t\t\tBUILD_BUG_ON(ALLOC_NO_WATERMARKS < NR_WMARK);\n\t\t\tif (alloc_flags & ALLOC_NO_WATERMARKS)\n\t\t\t\tgoto try_this_zone;\n\n\t\t\tif (node_reclaim_mode == 0 ||\n\t\t\t    !zone_allows_reclaim(ac->preferred_zoneref->zone, zone))\n\t\t\t\tcontinue;\n\n\t\t\tret = node_reclaim(zone->zone_pgdat, gfp_mask, order);\n\t\t\tswitch (ret) {\n\t\t\tcase NODE_RECLAIM_NOSCAN:\n\t\t\t\t/* did not scan */\n\t\t\t\tcontinue;\n\t\t\tcase NODE_RECLAIM_FULL:\n\t\t\t\t/* scanned but unreclaimable */\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\t/* did we reclaim enough */\n\t\t\t\tif (zone_watermark_ok(zone, order, mark,\n\t\t\t\t\t\tac_classzone_idx(ac), alloc_flags))\n\t\t\t\t\tgoto try_this_zone;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\ntry_this_zone:\n\t\tpage = rmqueue(ac->preferred_zoneref->zone, zone, order,\n\t\t\t\tgfp_mask, alloc_flags, ac->migratetype);\n\t\tif (page) {\n\t\t\tprep_new_page(page, order, gfp_mask, alloc_flags);\n\n\t\t\t/*\n\t\t\t * If this is a high-order atomic allocation then check\n\t\t\t * if the pageblock should be reserved for the future\n\t\t\t */\n\t\t\tif (unlikely(order && (alloc_flags & ALLOC_HARDER)))\n\t\t\t\treserve_highatomic_pageblock(page, zone, order);\n\n\t\t\treturn page;\n\t\t} else {\n#ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT\n\t\t\t/* Try again if zone has deferred pages */\n\t\t\tif (static_branch_unlikely(&deferred_pages)) {\n\t\t\t\tif (_deferred_grow_zone(zone, order))\n\t\t\t\t\tgoto try_this_zone;\n\t\t\t}\n#endif\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic struct page *\nget_page_from_freelist(gfp_t gfp_mask, unsigned int order, int alloc_flags,\n\t\t\t\t\t\tconst struct alloc_context *ac)\n{\n\tstruct zoneref *z = ac->preferred_zoneref;\n\tstruct zone *zone;\n\tstruct pglist_data *last_pgdat_dirty_limit = NULL;\n\n\t/*\n\t * Scan zonelist, looking for a zone with enough free.\n\t * See also __cpuset_node_allowed() comment in kernel/cpuset.c.\n\t */\n\tfor_next_zone_zonelist_nodemask(zone, z, ac->zonelist, ac->high_zoneidx,\n\t\t\t\t\t\t\t\tac->nodemask) {\n\t\tstruct page *page;\n\t\tunsigned long mark;\n\n\t\tif (cpusets_enabled() &&\n\t\t\t(alloc_flags & ALLOC_CPUSET) &&\n\t\t\t!__cpuset_zone_allowed(zone, gfp_mask))\n\t\t\t\tcontinue;\n\t\t/*\n\t\t * When allocating a page cache page for writing, we\n\t\t * want to get it from a node that is within its dirty\n\t\t * limit, such that no single node holds more than its\n\t\t * proportional share of globally allowed dirty pages.\n\t\t * The dirty limits take into account the node's\n\t\t * lowmem reserves and high watermark so that kswapd\n\t\t * should be able to balance it without having to\n\t\t * write pages from its LRU list.\n\t\t *\n\t\t * XXX: For now, allow allocations to potentially\n\t\t * exceed the per-node dirty limit in the slowpath\n\t\t * (spread_dirty_pages unset) before going into reclaim,\n\t\t * which is important when on a NUMA setup the allowed\n\t\t * nodes are together not big enough to reach the\n\t\t * global limit.  The proper fix for these situations\n\t\t * will require awareness of nodes in the\n\t\t * dirty-throttling and the flusher threads.\n\t\t */\n\t\tif (ac->spread_dirty_pages) {\n\t\t\tif (last_pgdat_dirty_limit == zone->zone_pgdat)\n\t\t\t\tcontinue;\n\n\t\t\tif (!node_dirty_ok(zone->zone_pgdat)) {\n\t\t\t\tlast_pgdat_dirty_limit = zone->zone_pgdat;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tmark = zone->watermark[alloc_flags & ALLOC_WMARK_MASK];\n\t\tif (!zone_watermark_fast(zone, order, mark,\n\t\t\t\t       ac_classzone_idx(ac), alloc_flags)) {\n\t\t\tint ret;\n\n#ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT\n\t\t\t/*\n\t\t\t * Watermark failed for this zone, but see if we can\n\t\t\t * grow this zone if it contains deferred pages.\n\t\t\t */\n\t\t\tif (static_branch_unlikely(&deferred_pages)) {\n\t\t\t\tif (_deferred_grow_zone(zone, order))\n\t\t\t\t\tgoto try_this_zone;\n\t\t\t}\n#endif\n\t\t\t/* Checked here to keep the fast path fast */\n\t\t\tBUILD_BUG_ON(ALLOC_NO_WATERMARKS < NR_WMARK);\n\t\t\tif (alloc_flags & ALLOC_NO_WATERMARKS)\n\t\t\t\tgoto try_this_zone;\n\n\t\t\tif (node_reclaim_mode == 0 ||\n\t\t\t    !zone_allows_reclaim(ac->preferred_zoneref->zone, zone))\n\t\t\t\tcontinue;\n\n\t\t\tret = node_reclaim(zone->zone_pgdat, gfp_mask, order);\n\t\t\tswitch (ret) {\n\t\t\tcase NODE_RECLAIM_NOSCAN:\n\t\t\t\t/* did not scan */\n\t\t\t\tcontinue;\n\t\t\tcase NODE_RECLAIM_FULL:\n\t\t\t\t/* scanned but unreclaimable */\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\t/* did we reclaim enough */\n\t\t\t\tif (zone_watermark_ok(zone, order, mark,\n\t\t\t\t\t\tac_classzone_idx(ac), alloc_flags))\n\t\t\t\t\tgoto try_this_zone;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\ntry_this_zone:\n\t\tpage = rmqueue(ac->preferred_zoneref->zone, zone, order,\n\t\t\t\tgfp_mask, alloc_flags, ac->migratetype);\n\t\tif (page) {\n\t\t\tprep_new_page(page, order, gfp_mask, alloc_flags);\n\n\t\t\t/*\n\t\t\t * If this is a high-order atomic allocation then check\n\t\t\t * if the pageblock should be reserved for the future\n\t\t\t */\n\t\t\tif (unlikely(order && (alloc_flags & ALLOC_HARDER)))\n\t\t\t\treserve_highatomic_pageblock(page, zone, order);\n\n\t\t\treturn page;\n\t\t} else {\n#ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT\n\t\t\t/* Try again if zone has deferred pages */\n\t\t\tif (static_branch_unlikely(&deferred_pages)) {\n\t\t\t\tif (_deferred_grow_zone(zone, order))\n\t\t\t\t\tgoto try_this_zone;\n\t\t\t}\n#endif\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "finalise_ac",
          "args": [
            "gfp_mask",
            "&ac"
          ],
          "line": 4370
        },
        "resolved": true,
        "details": {
          "function_name": "finalise_ac",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4330-4342",
          "snippet": "static inline void finalise_ac(gfp_t gfp_mask, struct alloc_context *ac)\n{\n\t/* Dirty zone balancing only done in the fast path */\n\tac->spread_dirty_pages = (gfp_mask & __GFP_WRITE);\n\n\t/*\n\t * The preferred zone is used for statistics but crucially it is\n\t * also used as the starting point for the zonelist iterator. It\n\t * may get reset for allocations that ignore memory policies.\n\t */\n\tac->preferred_zoneref = first_zones_zonelist(ac->zonelist,\n\t\t\t\t\tac->high_zoneidx, ac->nodemask);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline void finalise_ac(gfp_t gfp_mask, struct alloc_context *ac)\n{\n\t/* Dirty zone balancing only done in the fast path */\n\tac->spread_dirty_pages = (gfp_mask & __GFP_WRITE);\n\n\t/*\n\t * The preferred zone is used for statistics but crucially it is\n\t * also used as the starting point for the zonelist iterator. It\n\t * may get reset for allocations that ignore memory policies.\n\t */\n\tac->preferred_zoneref = first_zones_zonelist(ac->zonelist,\n\t\t\t\t\tac->high_zoneidx, ac->nodemask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_alloc_pages",
          "args": [
            "gfp_mask",
            "order",
            "preferred_nid",
            "nodemask",
            "&ac",
            "&alloc_mask",
            "&alloc_flags"
          ],
          "line": 4367
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_alloc_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4297-4327",
          "snippet": "static inline bool prepare_alloc_pages(gfp_t gfp_mask, unsigned int order,\n\t\tint preferred_nid, nodemask_t *nodemask,\n\t\tstruct alloc_context *ac, gfp_t *alloc_mask,\n\t\tunsigned int *alloc_flags)\n{\n\tac->high_zoneidx = gfp_zone(gfp_mask);\n\tac->zonelist = node_zonelist(preferred_nid, gfp_mask);\n\tac->nodemask = nodemask;\n\tac->migratetype = gfpflags_to_migratetype(gfp_mask);\n\n\tif (cpusets_enabled()) {\n\t\t*alloc_mask |= __GFP_HARDWALL;\n\t\tif (!ac->nodemask)\n\t\t\tac->nodemask = &cpuset_current_mems_allowed;\n\t\telse\n\t\t\t*alloc_flags |= ALLOC_CPUSET;\n\t}\n\n\tfs_reclaim_acquire(gfp_mask);\n\tfs_reclaim_release(gfp_mask);\n\n\tmight_sleep_if(gfp_mask & __GFP_DIRECT_RECLAIM);\n\n\tif (should_fail_alloc_page(gfp_mask, order))\n\t\treturn false;\n\n\tif (IS_ENABLED(CONFIG_CMA) && ac->migratetype == MIGRATE_MOVABLE)\n\t\t*alloc_flags |= ALLOC_CMA;\n\n\treturn true;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline bool prepare_alloc_pages(gfp_t gfp_mask, unsigned int order,\n\t\tint preferred_nid, nodemask_t *nodemask,\n\t\tstruct alloc_context *ac, gfp_t *alloc_mask,\n\t\tunsigned int *alloc_flags)\n{\n\tac->high_zoneidx = gfp_zone(gfp_mask);\n\tac->zonelist = node_zonelist(preferred_nid, gfp_mask);\n\tac->nodemask = nodemask;\n\tac->migratetype = gfpflags_to_migratetype(gfp_mask);\n\n\tif (cpusets_enabled()) {\n\t\t*alloc_mask |= __GFP_HARDWALL;\n\t\tif (!ac->nodemask)\n\t\t\tac->nodemask = &cpuset_current_mems_allowed;\n\t\telse\n\t\t\t*alloc_flags |= ALLOC_CPUSET;\n\t}\n\n\tfs_reclaim_acquire(gfp_mask);\n\tfs_reclaim_release(gfp_mask);\n\n\tmight_sleep_if(gfp_mask & __GFP_DIRECT_RECLAIM);\n\n\tif (should_fail_alloc_page(gfp_mask, order))\n\t\treturn false;\n\n\tif (IS_ENABLED(CONFIG_CMA) && ac->migratetype == MIGRATE_MOVABLE)\n\t\t*alloc_flags |= ALLOC_CMA;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!(gfp_mask & __GFP_NOWARN)"
          ],
          "line": 4361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "order >= MAX_ORDER"
          ],
          "line": 4360
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\ngfp_t gfp_allowed_mask;\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstruct page *\n__alloc_pages_nodemask(gfp_t gfp_mask, unsigned int order, int preferred_nid,\n\t\t\t\t\t\t\tnodemask_t *nodemask)\n{\n\tstruct page *page;\n\tunsigned int alloc_flags = ALLOC_WMARK_LOW;\n\tgfp_t alloc_mask; /* The gfp_t that was actually used for allocation */\n\tstruct alloc_context ac = { };\n\n\t/*\n\t * There are several places where we assume that the order value is sane\n\t * so bail out early if the request is out of bound.\n\t */\n\tif (unlikely(order >= MAX_ORDER)) {\n\t\tWARN_ON_ONCE(!(gfp_mask & __GFP_NOWARN));\n\t\treturn NULL;\n\t}\n\n\tgfp_mask &= gfp_allowed_mask;\n\talloc_mask = gfp_mask;\n\tif (!prepare_alloc_pages(gfp_mask, order, preferred_nid, nodemask, &ac, &alloc_mask, &alloc_flags))\n\t\treturn NULL;\n\n\tfinalise_ac(gfp_mask, &ac);\n\n\t/* First allocation attempt */\n\tpage = get_page_from_freelist(alloc_mask, order, alloc_flags, &ac);\n\tif (likely(page))\n\t\tgoto out;\n\n\t/*\n\t * Apply scoped allocation constraints. This is mainly about GFP_NOFS\n\t * resp. GFP_NOIO which has to be inherited for all allocation requests\n\t * from a particular context which has been marked by\n\t * memalloc_no{fs,io}_{save,restore}.\n\t */\n\talloc_mask = current_gfp_context(gfp_mask);\n\tac.spread_dirty_pages = false;\n\n\t/*\n\t * Restore the original nodemask if it was potentially replaced with\n\t * &cpuset_current_mems_allowed to optimize the fast-path attempt.\n\t */\n\tif (unlikely(ac.nodemask != nodemask))\n\t\tac.nodemask = nodemask;\n\n\tpage = __alloc_pages_slowpath(alloc_mask, order, &ac);\n\nout:\n\tif (memcg_kmem_enabled() && (gfp_mask & __GFP_ACCOUNT) && page &&\n\t    unlikely(memcg_kmem_charge(page, gfp_mask, order) != 0)) {\n\t\t__free_pages(page, order);\n\t\tpage = NULL;\n\t}\n\n\ttrace_mm_page_alloc(page, order, alloc_mask, ac.migratetype);\n\n\treturn page;\n}"
  },
  {
    "function_name": "finalise_ac",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "4330-4342",
    "snippet": "static inline void finalise_ac(gfp_t gfp_mask, struct alloc_context *ac)\n{\n\t/* Dirty zone balancing only done in the fast path */\n\tac->spread_dirty_pages = (gfp_mask & __GFP_WRITE);\n\n\t/*\n\t * The preferred zone is used for statistics but crucially it is\n\t * also used as the starting point for the zonelist iterator. It\n\t * may get reset for allocations that ignore memory policies.\n\t */\n\tac->preferred_zoneref = first_zones_zonelist(ac->zonelist,\n\t\t\t\t\tac->high_zoneidx, ac->nodemask);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "first_zones_zonelist",
          "args": [
            "ac->zonelist",
            "ac->high_zoneidx",
            "ac->nodemask"
          ],
          "line": 4340
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline void finalise_ac(gfp_t gfp_mask, struct alloc_context *ac)\n{\n\t/* Dirty zone balancing only done in the fast path */\n\tac->spread_dirty_pages = (gfp_mask & __GFP_WRITE);\n\n\t/*\n\t * The preferred zone is used for statistics but crucially it is\n\t * also used as the starting point for the zonelist iterator. It\n\t * may get reset for allocations that ignore memory policies.\n\t */\n\tac->preferred_zoneref = first_zones_zonelist(ac->zonelist,\n\t\t\t\t\tac->high_zoneidx, ac->nodemask);\n}"
  },
  {
    "function_name": "prepare_alloc_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "4297-4327",
    "snippet": "static inline bool prepare_alloc_pages(gfp_t gfp_mask, unsigned int order,\n\t\tint preferred_nid, nodemask_t *nodemask,\n\t\tstruct alloc_context *ac, gfp_t *alloc_mask,\n\t\tunsigned int *alloc_flags)\n{\n\tac->high_zoneidx = gfp_zone(gfp_mask);\n\tac->zonelist = node_zonelist(preferred_nid, gfp_mask);\n\tac->nodemask = nodemask;\n\tac->migratetype = gfpflags_to_migratetype(gfp_mask);\n\n\tif (cpusets_enabled()) {\n\t\t*alloc_mask |= __GFP_HARDWALL;\n\t\tif (!ac->nodemask)\n\t\t\tac->nodemask = &cpuset_current_mems_allowed;\n\t\telse\n\t\t\t*alloc_flags |= ALLOC_CPUSET;\n\t}\n\n\tfs_reclaim_acquire(gfp_mask);\n\tfs_reclaim_release(gfp_mask);\n\n\tmight_sleep_if(gfp_mask & __GFP_DIRECT_RECLAIM);\n\n\tif (should_fail_alloc_page(gfp_mask, order))\n\t\treturn false;\n\n\tif (IS_ENABLED(CONFIG_CMA) && ac->migratetype == MIGRATE_MOVABLE)\n\t\t*alloc_flags |= ALLOC_CMA;\n\n\treturn true;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);",
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_CMA"
          ],
          "line": 4323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "should_fail_alloc_page",
          "args": [
            "gfp_mask",
            "order"
          ],
          "line": 4320
        },
        "resolved": true,
        "details": {
          "function_name": "should_fail_alloc_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3106-3109",
          "snippet": "static inline bool should_fail_alloc_page(gfp_t gfp_mask, unsigned int order)\n{\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\n\nstatic inline bool should_fail_alloc_page(gfp_t gfp_mask, unsigned int order)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "might_sleep_if",
          "args": [
            "gfp_mask & __GFP_DIRECT_RECLAIM"
          ],
          "line": 4318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_reclaim_release",
          "args": [
            "gfp_mask"
          ],
          "line": 4316
        },
        "resolved": true,
        "details": {
          "function_name": "fs_reclaim_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3745-3749",
          "snippet": "void fs_reclaim_release(gfp_t gfp_mask)\n{\n\tif (__need_fs_reclaim(gfp_mask))\n\t\t__fs_reclaim_release();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid fs_reclaim_release(gfp_t gfp_mask)\n{\n\tif (__need_fs_reclaim(gfp_mask))\n\t\t__fs_reclaim_release();\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_reclaim_acquire",
          "args": [
            "gfp_mask"
          ],
          "line": 4315
        },
        "resolved": true,
        "details": {
          "function_name": "fs_reclaim_acquire",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3738-3742",
          "snippet": "void fs_reclaim_acquire(gfp_t gfp_mask)\n{\n\tif (__need_fs_reclaim(gfp_mask))\n\t\t__fs_reclaim_acquire();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid fs_reclaim_acquire(gfp_t gfp_mask)\n{\n\tif (__need_fs_reclaim(gfp_mask))\n\t\t__fs_reclaim_acquire();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpusets_enabled",
          "args": [],
          "line": 4307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfpflags_to_migratetype",
          "args": [
            "gfp_mask"
          ],
          "line": 4305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_zonelist",
          "args": [
            "preferred_nid",
            "gfp_mask"
          ],
          "line": 4303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfp_zone",
          "args": [
            "gfp_mask"
          ],
          "line": 4302
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline bool prepare_alloc_pages(gfp_t gfp_mask, unsigned int order,\n\t\tint preferred_nid, nodemask_t *nodemask,\n\t\tstruct alloc_context *ac, gfp_t *alloc_mask,\n\t\tunsigned int *alloc_flags)\n{\n\tac->high_zoneidx = gfp_zone(gfp_mask);\n\tac->zonelist = node_zonelist(preferred_nid, gfp_mask);\n\tac->nodemask = nodemask;\n\tac->migratetype = gfpflags_to_migratetype(gfp_mask);\n\n\tif (cpusets_enabled()) {\n\t\t*alloc_mask |= __GFP_HARDWALL;\n\t\tif (!ac->nodemask)\n\t\t\tac->nodemask = &cpuset_current_mems_allowed;\n\t\telse\n\t\t\t*alloc_flags |= ALLOC_CPUSET;\n\t}\n\n\tfs_reclaim_acquire(gfp_mask);\n\tfs_reclaim_release(gfp_mask);\n\n\tmight_sleep_if(gfp_mask & __GFP_DIRECT_RECLAIM);\n\n\tif (should_fail_alloc_page(gfp_mask, order))\n\t\treturn false;\n\n\tif (IS_ENABLED(CONFIG_CMA) && ac->migratetype == MIGRATE_MOVABLE)\n\t\t*alloc_flags |= ALLOC_CMA;\n\n\treturn true;\n}"
  },
  {
    "function_name": "__alloc_pages_slowpath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "4047-4295",
    "snippet": "static inline struct page *\n__alloc_pages_slowpath(gfp_t gfp_mask, unsigned int order,\n\t\t\t\t\t\tstruct alloc_context *ac)\n{\n\tbool can_direct_reclaim = gfp_mask & __GFP_DIRECT_RECLAIM;\n\tconst bool costly_order = order > PAGE_ALLOC_COSTLY_ORDER;\n\tstruct page *page = NULL;\n\tunsigned int alloc_flags;\n\tunsigned long did_some_progress;\n\tenum compact_priority compact_priority;\n\tenum compact_result compact_result;\n\tint compaction_retries;\n\tint no_progress_loops;\n\tunsigned int cpuset_mems_cookie;\n\tint reserve_flags;\n\n\t/*\n\t * We also sanity check to catch abuse of atomic reserves being used by\n\t * callers that are not in atomic context.\n\t */\n\tif (WARN_ON_ONCE((gfp_mask & (__GFP_ATOMIC|__GFP_DIRECT_RECLAIM)) ==\n\t\t\t\t(__GFP_ATOMIC|__GFP_DIRECT_RECLAIM)))\n\t\tgfp_mask &= ~__GFP_ATOMIC;\n\nretry_cpuset:\n\tcompaction_retries = 0;\n\tno_progress_loops = 0;\n\tcompact_priority = DEF_COMPACT_PRIORITY;\n\tcpuset_mems_cookie = read_mems_allowed_begin();\n\n\t/*\n\t * The fast path uses conservative alloc_flags to succeed only until\n\t * kswapd needs to be woken up, and to avoid the cost of setting up\n\t * alloc_flags precisely. So we do that now.\n\t */\n\talloc_flags = gfp_to_alloc_flags(gfp_mask);\n\n\t/*\n\t * We need to recalculate the starting point for the zonelist iterator\n\t * because we might have used different nodemask in the fast path, or\n\t * there was a cpuset modification and we are retrying - otherwise we\n\t * could end up iterating over non-eligible zones endlessly.\n\t */\n\tac->preferred_zoneref = first_zones_zonelist(ac->zonelist,\n\t\t\t\t\tac->high_zoneidx, ac->nodemask);\n\tif (!ac->preferred_zoneref->zone)\n\t\tgoto nopage;\n\n\tif (gfp_mask & __GFP_KSWAPD_RECLAIM)\n\t\twake_all_kswapds(order, gfp_mask, ac);\n\n\t/*\n\t * The adjusted alloc_flags might result in immediate success, so try\n\t * that first\n\t */\n\tpage = get_page_from_freelist(gfp_mask, order, alloc_flags, ac);\n\tif (page)\n\t\tgoto got_pg;\n\n\t/*\n\t * For costly allocations, try direct compaction first, as it's likely\n\t * that we have enough base pages and don't need to reclaim. For non-\n\t * movable high-order allocations, do that as well, as compaction will\n\t * try prevent permanent fragmentation by migrating from blocks of the\n\t * same migratetype.\n\t * Don't try this for allocations that are allowed to ignore\n\t * watermarks, as the ALLOC_NO_WATERMARKS attempt didn't yet happen.\n\t */\n\tif (can_direct_reclaim &&\n\t\t\t(costly_order ||\n\t\t\t   (order > 0 && ac->migratetype != MIGRATE_MOVABLE))\n\t\t\t&& !gfp_pfmemalloc_allowed(gfp_mask)) {\n\t\tpage = __alloc_pages_direct_compact(gfp_mask, order,\n\t\t\t\t\t\talloc_flags, ac,\n\t\t\t\t\t\tINIT_COMPACT_PRIORITY,\n\t\t\t\t\t\t&compact_result);\n\t\tif (page)\n\t\t\tgoto got_pg;\n\n\t\t/*\n\t\t * Checks for costly allocations with __GFP_NORETRY, which\n\t\t * includes THP page fault allocations\n\t\t */\n\t\tif (costly_order && (gfp_mask & __GFP_NORETRY)) {\n\t\t\t/*\n\t\t\t * If compaction is deferred for high-order allocations,\n\t\t\t * it is because sync compaction recently failed. If\n\t\t\t * this is the case and the caller requested a THP\n\t\t\t * allocation, we do not want to heavily disrupt the\n\t\t\t * system, so we fail the allocation instead of entering\n\t\t\t * direct reclaim.\n\t\t\t */\n\t\t\tif (compact_result == COMPACT_DEFERRED)\n\t\t\t\tgoto nopage;\n\n\t\t\t/*\n\t\t\t * Looks like reclaim/compaction is worth trying, but\n\t\t\t * sync compaction could be very expensive, so keep\n\t\t\t * using async compaction.\n\t\t\t */\n\t\t\tcompact_priority = INIT_COMPACT_PRIORITY;\n\t\t}\n\t}\n\nretry:\n\t/* Ensure kswapd doesn't accidentally go to sleep as long as we loop */\n\tif (gfp_mask & __GFP_KSWAPD_RECLAIM)\n\t\twake_all_kswapds(order, gfp_mask, ac);\n\n\treserve_flags = __gfp_pfmemalloc_flags(gfp_mask);\n\tif (reserve_flags)\n\t\talloc_flags = reserve_flags;\n\n\t/*\n\t * Reset the nodemask and zonelist iterators if memory policies can be\n\t * ignored. These allocations are high priority and system rather than\n\t * user oriented.\n\t */\n\tif (!(alloc_flags & ALLOC_CPUSET) || reserve_flags) {\n\t\tac->nodemask = NULL;\n\t\tac->preferred_zoneref = first_zones_zonelist(ac->zonelist,\n\t\t\t\t\tac->high_zoneidx, ac->nodemask);\n\t}\n\n\t/* Attempt with potentially adjusted zonelist and alloc_flags */\n\tpage = get_page_from_freelist(gfp_mask, order, alloc_flags, ac);\n\tif (page)\n\t\tgoto got_pg;\n\n\t/* Caller is not willing to reclaim, we can't balance anything */\n\tif (!can_direct_reclaim)\n\t\tgoto nopage;\n\n\t/* Avoid recursion of direct reclaim */\n\tif (current->flags & PF_MEMALLOC)\n\t\tgoto nopage;\n\n\t/* Try direct reclaim and then allocating */\n\tpage = __alloc_pages_direct_reclaim(gfp_mask, order, alloc_flags, ac,\n\t\t\t\t\t\t\t&did_some_progress);\n\tif (page)\n\t\tgoto got_pg;\n\n\t/* Try direct compaction and then allocating */\n\tpage = __alloc_pages_direct_compact(gfp_mask, order, alloc_flags, ac,\n\t\t\t\t\tcompact_priority, &compact_result);\n\tif (page)\n\t\tgoto got_pg;\n\n\t/* Do not loop if specifically requested */\n\tif (gfp_mask & __GFP_NORETRY)\n\t\tgoto nopage;\n\n\t/*\n\t * Do not retry costly high order allocations unless they are\n\t * __GFP_RETRY_MAYFAIL\n\t */\n\tif (costly_order && !(gfp_mask & __GFP_RETRY_MAYFAIL))\n\t\tgoto nopage;\n\n\tif (should_reclaim_retry(gfp_mask, order, ac, alloc_flags,\n\t\t\t\t did_some_progress > 0, &no_progress_loops))\n\t\tgoto retry;\n\n\t/*\n\t * It doesn't make any sense to retry for the compaction if the order-0\n\t * reclaim is not able to make any progress because the current\n\t * implementation of the compaction depends on the sufficient amount\n\t * of free memory (see __compaction_suitable)\n\t */\n\tif (did_some_progress > 0 &&\n\t\t\tshould_compact_retry(ac, order, alloc_flags,\n\t\t\t\tcompact_result, &compact_priority,\n\t\t\t\t&compaction_retries))\n\t\tgoto retry;\n\n\n\t/* Deal with possible cpuset update races before we start OOM killing */\n\tif (check_retry_cpuset(cpuset_mems_cookie, ac))\n\t\tgoto retry_cpuset;\n\n\t/* Reclaim has failed us, start killing things */\n\tpage = __alloc_pages_may_oom(gfp_mask, order, ac, &did_some_progress);\n\tif (page)\n\t\tgoto got_pg;\n\n\t/* Avoid allocations with no watermarks from looping endlessly */\n\tif (tsk_is_oom_victim(current) &&\n\t    (alloc_flags == ALLOC_OOM ||\n\t     (gfp_mask & __GFP_NOMEMALLOC)))\n\t\tgoto nopage;\n\n\t/* Retry as long as the OOM killer is making progress */\n\tif (did_some_progress) {\n\t\tno_progress_loops = 0;\n\t\tgoto retry;\n\t}\n\nnopage:\n\t/* Deal with possible cpuset update races before we fail */\n\tif (check_retry_cpuset(cpuset_mems_cookie, ac))\n\t\tgoto retry_cpuset;\n\n\t/*\n\t * Make sure that __GFP_NOFAIL request doesn't leak out and make sure\n\t * we always retry\n\t */\n\tif (gfp_mask & __GFP_NOFAIL) {\n\t\t/*\n\t\t * All existing users of the __GFP_NOFAIL are blockable, so warn\n\t\t * of any new users that actually require GFP_NOWAIT\n\t\t */\n\t\tif (WARN_ON_ONCE(!can_direct_reclaim))\n\t\t\tgoto fail;\n\n\t\t/*\n\t\t * PF_MEMALLOC request from this context is rather bizarre\n\t\t * because we cannot reclaim anything and only can loop waiting\n\t\t * for somebody to do a work for us\n\t\t */\n\t\tWARN_ON_ONCE(current->flags & PF_MEMALLOC);\n\n\t\t/*\n\t\t * non failing costly orders are a hard requirement which we\n\t\t * are not prepared for much so let's warn about these users\n\t\t * so that we can identify them and convert them to something\n\t\t * else.\n\t\t */\n\t\tWARN_ON_ONCE(order > PAGE_ALLOC_COSTLY_ORDER);\n\n\t\t/*\n\t\t * Help non-failing allocations by giving them access to memory\n\t\t * reserves but do not use ALLOC_NO_WATERMARKS because this\n\t\t * could deplete whole memory reserves which would just make\n\t\t * the situation worse\n\t\t */\n\t\tpage = __alloc_pages_cpuset_fallback(gfp_mask, order, ALLOC_HARDER, ac);\n\t\tif (page)\n\t\t\tgoto got_pg;\n\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\nfail:\n\twarn_alloc(gfp_mask, ac->nodemask,\n\t\t\t\"page allocation failure: order:%u\", order);\ngot_pg:\n\treturn page;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);",
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "warn_alloc",
          "args": [
            "gfp_mask",
            "ac->nodemask",
            "\"page allocation failure: order:%u\"",
            "order"
          ],
          "line": 4291
        },
        "resolved": true,
        "details": {
          "function_name": "warn_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3403-3425",
          "snippet": "void warn_alloc(gfp_t gfp_mask, nodemask_t *nodemask, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstatic DEFINE_RATELIMIT_STATE(nopage_rs, DEFAULT_RATELIMIT_INTERVAL,\n\t\t\t\t      DEFAULT_RATELIMIT_BURST);\n\n\tif ((gfp_mask & __GFP_NOWARN) || !__ratelimit(&nopage_rs))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"%s: %pV, mode:%#x(%pGg), nodemask=%*pbl\\n\",\n\t\t\tcurrent->comm, &vaf, gfp_mask, &gfp_mask,\n\t\t\tnodemask_pr_args(nodemask));\n\tva_end(args);\n\n\tcpuset_print_current_mems_allowed();\n\n\tdump_stack();\n\twarn_alloc_show_mem(gfp_mask, nodemask);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid warn_alloc(gfp_t gfp_mask, nodemask_t *nodemask, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstatic DEFINE_RATELIMIT_STATE(nopage_rs, DEFAULT_RATELIMIT_INTERVAL,\n\t\t\t\t      DEFAULT_RATELIMIT_BURST);\n\n\tif ((gfp_mask & __GFP_NOWARN) || !__ratelimit(&nopage_rs))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"%s: %pV, mode:%#x(%pGg), nodemask=%*pbl\\n\",\n\t\t\tcurrent->comm, &vaf, gfp_mask, &gfp_mask,\n\t\t\tnodemask_pr_args(nodemask));\n\tva_end(args);\n\n\tcpuset_print_current_mems_allowed();\n\n\tdump_stack();\n\twarn_alloc_show_mem(gfp_mask, nodemask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 4287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__alloc_pages_cpuset_fallback",
          "args": [
            "gfp_mask",
            "order",
            "ALLOC_HARDER",
            "ac"
          ],
          "line": 4283
        },
        "resolved": true,
        "details": {
          "function_name": "__alloc_pages_cpuset_fallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3427-3445",
          "snippet": "static inline struct page *\n__alloc_pages_cpuset_fallback(gfp_t gfp_mask, unsigned int order,\n\t\t\t      unsigned int alloc_flags,\n\t\t\t      const struct alloc_context *ac)\n{\n\tstruct page *page;\n\n\tpage = get_page_from_freelist(gfp_mask, order,\n\t\t\talloc_flags|ALLOC_CPUSET, ac);\n\t/*\n\t * fallback to ignore cpuset restriction if our nodes\n\t * are depleted\n\t */\n\tif (!page)\n\t\tpage = get_page_from_freelist(gfp_mask, order,\n\t\t\t\talloc_flags, ac);\n\n\treturn page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline struct page *\n__alloc_pages_cpuset_fallback(gfp_t gfp_mask, unsigned int order,\n\t\t\t      unsigned int alloc_flags,\n\t\t\t      const struct alloc_context *ac)\n{\n\tstruct page *page;\n\n\tpage = get_page_from_freelist(gfp_mask, order,\n\t\t\talloc_flags|ALLOC_CPUSET, ac);\n\t/*\n\t * fallback to ignore cpuset restriction if our nodes\n\t * are depleted\n\t */\n\tif (!page)\n\t\tpage = get_page_from_freelist(gfp_mask, order,\n\t\t\t\talloc_flags, ac);\n\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "order > PAGE_ALLOC_COSTLY_ORDER"
          ],
          "line": 4275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "current->flags & PF_MEMALLOC"
          ],
          "line": 4267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!can_direct_reclaim"
          ],
          "line": 4259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_retry_cpuset",
          "args": [
            "cpuset_mems_cookie",
            "ac"
          ],
          "line": 4247
        },
        "resolved": true,
        "details": {
          "function_name": "check_retry_cpuset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4014-4045",
          "snippet": "static inline bool\ncheck_retry_cpuset(int cpuset_mems_cookie, struct alloc_context *ac)\n{\n\t/*\n\t * It's possible that cpuset's mems_allowed and the nodemask from\n\t * mempolicy don't intersect. This should be normally dealt with by\n\t * policy_nodemask(), but it's possible to race with cpuset update in\n\t * such a way the check therein was true, and then it became false\n\t * before we got our cpuset_mems_cookie here.\n\t * This assumes that for all allocations, ac->nodemask can come only\n\t * from MPOL_BIND mempolicy (whose documented semantics is to be ignored\n\t * when it does not intersect with the cpuset restrictions) or the\n\t * caller can deal with a violated nodemask.\n\t */\n\tif (cpusets_enabled() && ac->nodemask &&\n\t\t\t!cpuset_nodemask_valid_mems_allowed(ac->nodemask)) {\n\t\tac->nodemask = NULL;\n\t\treturn true;\n\t}\n\n\t/*\n\t * When updating a task's mems_allowed or mempolicy nodemask, it is\n\t * possible to race with parallel threads in such a way that our\n\t * allocation can fail while the mask is being updated. If we are about\n\t * to fail, check if the cpuset changed during allocation and if so,\n\t * retry.\n\t */\n\tif (read_mems_allowed_retry(cpuset_mems_cookie))\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline bool\ncheck_retry_cpuset(int cpuset_mems_cookie, struct alloc_context *ac)\n{\n\t/*\n\t * It's possible that cpuset's mems_allowed and the nodemask from\n\t * mempolicy don't intersect. This should be normally dealt with by\n\t * policy_nodemask(), but it's possible to race with cpuset update in\n\t * such a way the check therein was true, and then it became false\n\t * before we got our cpuset_mems_cookie here.\n\t * This assumes that for all allocations, ac->nodemask can come only\n\t * from MPOL_BIND mempolicy (whose documented semantics is to be ignored\n\t * when it does not intersect with the cpuset restrictions) or the\n\t * caller can deal with a violated nodemask.\n\t */\n\tif (cpusets_enabled() && ac->nodemask &&\n\t\t\t!cpuset_nodemask_valid_mems_allowed(ac->nodemask)) {\n\t\tac->nodemask = NULL;\n\t\treturn true;\n\t}\n\n\t/*\n\t * When updating a task's mems_allowed or mempolicy nodemask, it is\n\t * possible to race with parallel threads in such a way that our\n\t * allocation can fail while the mask is being updated. If we are about\n\t * to fail, check if the cpuset changed during allocation and if so,\n\t * retry.\n\t */\n\tif (read_mems_allowed_retry(cpuset_mems_cookie))\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tsk_is_oom_victim",
          "args": [
            "current"
          ],
          "line": 4234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__alloc_pages_may_oom",
          "args": [
            "gfp_mask",
            "order",
            "ac",
            "&did_some_progress"
          ],
          "line": 4229
        },
        "resolved": true,
        "details": {
          "function_name": "__alloc_pages_may_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3447-3533",
          "snippet": "static inline struct page *\n__alloc_pages_may_oom(gfp_t gfp_mask, unsigned int order,\n\tconst struct alloc_context *ac, unsigned long *did_some_progress)\n{\n\tstruct oom_control oc = {\n\t\t.zonelist = ac->zonelist,\n\t\t.nodemask = ac->nodemask,\n\t\t.memcg = NULL,\n\t\t.gfp_mask = gfp_mask,\n\t\t.order = order,\n\t};\n\tstruct page *page;\n\n\t*did_some_progress = 0;\n\n\t/*\n\t * Acquire the oom lock.  If that fails, somebody else is\n\t * making progress for us.\n\t */\n\tif (!mutex_trylock(&oom_lock)) {\n\t\t*did_some_progress = 1;\n\t\tschedule_timeout_uninterruptible(1);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * Go through the zonelist yet one more time, keep very high watermark\n\t * here, this is only to catch a parallel oom killing, we must fail if\n\t * we're still under heavy pressure. But make sure that this reclaim\n\t * attempt shall not depend on __GFP_DIRECT_RECLAIM && !__GFP_NORETRY\n\t * allocation which will never fail due to oom_lock already held.\n\t */\n\tpage = get_page_from_freelist((gfp_mask | __GFP_HARDWALL) &\n\t\t\t\t      ~__GFP_DIRECT_RECLAIM, order,\n\t\t\t\t      ALLOC_WMARK_HIGH|ALLOC_CPUSET, ac);\n\tif (page)\n\t\tgoto out;\n\n\t/* Coredumps can quickly deplete all memory reserves */\n\tif (current->flags & PF_DUMPCORE)\n\t\tgoto out;\n\t/* The OOM killer will not help higher order allocs */\n\tif (order > PAGE_ALLOC_COSTLY_ORDER)\n\t\tgoto out;\n\t/*\n\t * We have already exhausted all our reclaim opportunities without any\n\t * success so it is time to admit defeat. We will skip the OOM killer\n\t * because it is very likely that the caller has a more reasonable\n\t * fallback than shooting a random task.\n\t */\n\tif (gfp_mask & __GFP_RETRY_MAYFAIL)\n\t\tgoto out;\n\t/* The OOM killer does not needlessly kill tasks for lowmem */\n\tif (ac->high_zoneidx < ZONE_NORMAL)\n\t\tgoto out;\n\tif (pm_suspended_storage())\n\t\tgoto out;\n\t/*\n\t * XXX: GFP_NOFS allocations should rather fail than rely on\n\t * other request to make a forward progress.\n\t * We are in an unfortunate situation where out_of_memory cannot\n\t * do much for this context but let's try it to at least get\n\t * access to memory reserved if the current task is killed (see\n\t * out_of_memory). Once filesystems are ready to handle allocation\n\t * failures more gracefully we should just bail out here.\n\t */\n\n\t/* The OOM killer may not free memory on a specific node */\n\tif (gfp_mask & __GFP_THISNODE)\n\t\tgoto out;\n\n\t/* Exhausted what can be done so it's blame time */\n\tif (out_of_memory(&oc) || WARN_ON_ONCE(gfp_mask & __GFP_NOFAIL)) {\n\t\t*did_some_progress = 1;\n\n\t\t/*\n\t\t * Help non-failing allocations by giving them access to memory\n\t\t * reserves\n\t\t */\n\t\tif (gfp_mask & __GFP_NOFAIL)\n\t\t\tpage = __alloc_pages_cpuset_fallback(gfp_mask, order,\n\t\t\t\t\tALLOC_NO_WATERMARKS, ac);\n\t}\nout:\n\tmutex_unlock(&oom_lock);\n\treturn page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline struct page *\n__alloc_pages_may_oom(gfp_t gfp_mask, unsigned int order,\n\tconst struct alloc_context *ac, unsigned long *did_some_progress)\n{\n\tstruct oom_control oc = {\n\t\t.zonelist = ac->zonelist,\n\t\t.nodemask = ac->nodemask,\n\t\t.memcg = NULL,\n\t\t.gfp_mask = gfp_mask,\n\t\t.order = order,\n\t};\n\tstruct page *page;\n\n\t*did_some_progress = 0;\n\n\t/*\n\t * Acquire the oom lock.  If that fails, somebody else is\n\t * making progress for us.\n\t */\n\tif (!mutex_trylock(&oom_lock)) {\n\t\t*did_some_progress = 1;\n\t\tschedule_timeout_uninterruptible(1);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * Go through the zonelist yet one more time, keep very high watermark\n\t * here, this is only to catch a parallel oom killing, we must fail if\n\t * we're still under heavy pressure. But make sure that this reclaim\n\t * attempt shall not depend on __GFP_DIRECT_RECLAIM && !__GFP_NORETRY\n\t * allocation which will never fail due to oom_lock already held.\n\t */\n\tpage = get_page_from_freelist((gfp_mask | __GFP_HARDWALL) &\n\t\t\t\t      ~__GFP_DIRECT_RECLAIM, order,\n\t\t\t\t      ALLOC_WMARK_HIGH|ALLOC_CPUSET, ac);\n\tif (page)\n\t\tgoto out;\n\n\t/* Coredumps can quickly deplete all memory reserves */\n\tif (current->flags & PF_DUMPCORE)\n\t\tgoto out;\n\t/* The OOM killer will not help higher order allocs */\n\tif (order > PAGE_ALLOC_COSTLY_ORDER)\n\t\tgoto out;\n\t/*\n\t * We have already exhausted all our reclaim opportunities without any\n\t * success so it is time to admit defeat. We will skip the OOM killer\n\t * because it is very likely that the caller has a more reasonable\n\t * fallback than shooting a random task.\n\t */\n\tif (gfp_mask & __GFP_RETRY_MAYFAIL)\n\t\tgoto out;\n\t/* The OOM killer does not needlessly kill tasks for lowmem */\n\tif (ac->high_zoneidx < ZONE_NORMAL)\n\t\tgoto out;\n\tif (pm_suspended_storage())\n\t\tgoto out;\n\t/*\n\t * XXX: GFP_NOFS allocations should rather fail than rely on\n\t * other request to make a forward progress.\n\t * We are in an unfortunate situation where out_of_memory cannot\n\t * do much for this context but let's try it to at least get\n\t * access to memory reserved if the current task is killed (see\n\t * out_of_memory). Once filesystems are ready to handle allocation\n\t * failures more gracefully we should just bail out here.\n\t */\n\n\t/* The OOM killer may not free memory on a specific node */\n\tif (gfp_mask & __GFP_THISNODE)\n\t\tgoto out;\n\n\t/* Exhausted what can be done so it's blame time */\n\tif (out_of_memory(&oc) || WARN_ON_ONCE(gfp_mask & __GFP_NOFAIL)) {\n\t\t*did_some_progress = 1;\n\n\t\t/*\n\t\t * Help non-failing allocations by giving them access to memory\n\t\t * reserves\n\t\t */\n\t\tif (gfp_mask & __GFP_NOFAIL)\n\t\t\tpage = __alloc_pages_cpuset_fallback(gfp_mask, order,\n\t\t\t\t\tALLOC_NO_WATERMARKS, ac);\n\t}\nout:\n\tmutex_unlock(&oom_lock);\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "should_compact_retry",
          "args": [
            "ac",
            "order",
            "alloc_flags",
            "compact_result",
            "&compact_priority",
            "&compaction_retries"
          ],
          "line": 4218
        },
        "resolved": true,
        "details": {
          "function_name": "should_compact_retry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3674-3699",
          "snippet": "static inline bool\nshould_compact_retry(struct alloc_context *ac, unsigned int order, int alloc_flags,\n\t\t     enum compact_result compact_result,\n\t\t     enum compact_priority *compact_priority,\n\t\t     int *compaction_retries)\n{\n\tstruct zone *zone;\n\tstruct zoneref *z;\n\n\tif (!order || order > PAGE_ALLOC_COSTLY_ORDER)\n\t\treturn false;\n\n\t/*\n\t * There are setups with compaction disabled which would prefer to loop\n\t * inside the allocator rather than hit the oom killer prematurely.\n\t * Let's give them a good hope and keep retrying while the order-0\n\t * watermarks are OK.\n\t */\n\tfor_each_zone_zonelist_nodemask(zone, z, ac->zonelist, ac->high_zoneidx,\n\t\t\t\t\tac->nodemask) {\n\t\tif (zone_watermark_ok(zone, 0, min_wmark_pages(zone),\n\t\t\t\t\tac_classzone_idx(ac), alloc_flags))\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline bool\nshould_compact_retry(struct alloc_context *ac, unsigned int order, int alloc_flags,\n\t\t     enum compact_result compact_result,\n\t\t     enum compact_priority *compact_priority,\n\t\t     int *compaction_retries)\n{\n\tstruct zone *zone;\n\tstruct zoneref *z;\n\n\tif (!order || order > PAGE_ALLOC_COSTLY_ORDER)\n\t\treturn false;\n\n\t/*\n\t * There are setups with compaction disabled which would prefer to loop\n\t * inside the allocator rather than hit the oom killer prematurely.\n\t * Let's give them a good hope and keep retrying while the order-0\n\t * watermarks are OK.\n\t */\n\tfor_each_zone_zonelist_nodemask(zone, z, ac->zonelist, ac->high_zoneidx,\n\t\t\t\t\tac->nodemask) {\n\t\tif (zone_watermark_ok(zone, 0, min_wmark_pages(zone),\n\t\t\t\t\tac_classzone_idx(ac), alloc_flags))\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "should_reclaim_retry",
          "args": [
            "gfp_mask",
            "order",
            "ac",
            "alloc_flags",
            "did_some_progress > 0",
            "&no_progress_loops"
          ],
          "line": 4207
        },
        "resolved": true,
        "details": {
          "function_name": "should_reclaim_retry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3923-4012",
          "snippet": "static inline bool\nshould_reclaim_retry(gfp_t gfp_mask, unsigned order,\n\t\t     struct alloc_context *ac, int alloc_flags,\n\t\t     bool did_some_progress, int *no_progress_loops)\n{\n\tstruct zone *zone;\n\tstruct zoneref *z;\n\tbool ret = false;\n\n\t/*\n\t * Costly allocations might have made a progress but this doesn't mean\n\t * their order will become available due to high fragmentation so\n\t * always increment the no progress counter for them\n\t */\n\tif (did_some_progress && order <= PAGE_ALLOC_COSTLY_ORDER)\n\t\t*no_progress_loops = 0;\n\telse\n\t\t(*no_progress_loops)++;\n\n\t/*\n\t * Make sure we converge to OOM if we cannot make any progress\n\t * several times in the row.\n\t */\n\tif (*no_progress_loops > MAX_RECLAIM_RETRIES) {\n\t\t/* Before OOM, exhaust highatomic_reserve */\n\t\treturn unreserve_highatomic_pageblock(ac, true);\n\t}\n\n\t/*\n\t * Keep reclaiming pages while there is a chance this will lead\n\t * somewhere.  If none of the target zones can satisfy our allocation\n\t * request even if all reclaimable pages are considered then we are\n\t * screwed and have to go OOM.\n\t */\n\tfor_each_zone_zonelist_nodemask(zone, z, ac->zonelist, ac->high_zoneidx,\n\t\t\t\t\tac->nodemask) {\n\t\tunsigned long available;\n\t\tunsigned long reclaimable;\n\t\tunsigned long min_wmark = min_wmark_pages(zone);\n\t\tbool wmark;\n\n\t\tavailable = reclaimable = zone_reclaimable_pages(zone);\n\t\tavailable += zone_page_state_snapshot(zone, NR_FREE_PAGES);\n\n\t\t/*\n\t\t * Would the allocation succeed if we reclaimed all\n\t\t * reclaimable pages?\n\t\t */\n\t\twmark = __zone_watermark_ok(zone, order, min_wmark,\n\t\t\t\tac_classzone_idx(ac), alloc_flags, available);\n\t\ttrace_reclaim_retry_zone(z, order, reclaimable,\n\t\t\t\tavailable, min_wmark, *no_progress_loops, wmark);\n\t\tif (wmark) {\n\t\t\t/*\n\t\t\t * If we didn't make any progress and have a lot of\n\t\t\t * dirty + writeback pages then we should wait for\n\t\t\t * an IO to complete to slow down the reclaim and\n\t\t\t * prevent from pre mature OOM\n\t\t\t */\n\t\t\tif (!did_some_progress) {\n\t\t\t\tunsigned long write_pending;\n\n\t\t\t\twrite_pending = zone_page_state_snapshot(zone,\n\t\t\t\t\t\t\tNR_ZONE_WRITE_PENDING);\n\n\t\t\t\tif (2 * write_pending > reclaimable) {\n\t\t\t\t\tcongestion_wait(BLK_RW_ASYNC, HZ/10);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tret = true;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\t/*\n\t * Memory allocation/reclaim might be called from a WQ context and the\n\t * current implementation of the WQ concurrency control doesn't\n\t * recognize that a particular WQ is congested if the worker thread is\n\t * looping without ever sleeping. Therefore we have to do a short sleep\n\t * here rather than calling cond_resched().\n\t */\n\tif (current->flags & PF_WQ_WORKER)\n\t\tschedule_timeout_uninterruptible(1);\n\telse\n\t\tcond_resched();\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline bool\nshould_reclaim_retry(gfp_t gfp_mask, unsigned order,\n\t\t     struct alloc_context *ac, int alloc_flags,\n\t\t     bool did_some_progress, int *no_progress_loops)\n{\n\tstruct zone *zone;\n\tstruct zoneref *z;\n\tbool ret = false;\n\n\t/*\n\t * Costly allocations might have made a progress but this doesn't mean\n\t * their order will become available due to high fragmentation so\n\t * always increment the no progress counter for them\n\t */\n\tif (did_some_progress && order <= PAGE_ALLOC_COSTLY_ORDER)\n\t\t*no_progress_loops = 0;\n\telse\n\t\t(*no_progress_loops)++;\n\n\t/*\n\t * Make sure we converge to OOM if we cannot make any progress\n\t * several times in the row.\n\t */\n\tif (*no_progress_loops > MAX_RECLAIM_RETRIES) {\n\t\t/* Before OOM, exhaust highatomic_reserve */\n\t\treturn unreserve_highatomic_pageblock(ac, true);\n\t}\n\n\t/*\n\t * Keep reclaiming pages while there is a chance this will lead\n\t * somewhere.  If none of the target zones can satisfy our allocation\n\t * request even if all reclaimable pages are considered then we are\n\t * screwed and have to go OOM.\n\t */\n\tfor_each_zone_zonelist_nodemask(zone, z, ac->zonelist, ac->high_zoneidx,\n\t\t\t\t\tac->nodemask) {\n\t\tunsigned long available;\n\t\tunsigned long reclaimable;\n\t\tunsigned long min_wmark = min_wmark_pages(zone);\n\t\tbool wmark;\n\n\t\tavailable = reclaimable = zone_reclaimable_pages(zone);\n\t\tavailable += zone_page_state_snapshot(zone, NR_FREE_PAGES);\n\n\t\t/*\n\t\t * Would the allocation succeed if we reclaimed all\n\t\t * reclaimable pages?\n\t\t */\n\t\twmark = __zone_watermark_ok(zone, order, min_wmark,\n\t\t\t\tac_classzone_idx(ac), alloc_flags, available);\n\t\ttrace_reclaim_retry_zone(z, order, reclaimable,\n\t\t\t\tavailable, min_wmark, *no_progress_loops, wmark);\n\t\tif (wmark) {\n\t\t\t/*\n\t\t\t * If we didn't make any progress and have a lot of\n\t\t\t * dirty + writeback pages then we should wait for\n\t\t\t * an IO to complete to slow down the reclaim and\n\t\t\t * prevent from pre mature OOM\n\t\t\t */\n\t\t\tif (!did_some_progress) {\n\t\t\t\tunsigned long write_pending;\n\n\t\t\t\twrite_pending = zone_page_state_snapshot(zone,\n\t\t\t\t\t\t\tNR_ZONE_WRITE_PENDING);\n\n\t\t\t\tif (2 * write_pending > reclaimable) {\n\t\t\t\t\tcongestion_wait(BLK_RW_ASYNC, HZ/10);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tret = true;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\t/*\n\t * Memory allocation/reclaim might be called from a WQ context and the\n\t * current implementation of the WQ concurrency control doesn't\n\t * recognize that a particular WQ is congested if the worker thread is\n\t * looping without ever sleeping. Therefore we have to do a short sleep\n\t * here rather than calling cond_resched().\n\t */\n\tif (current->flags & PF_WQ_WORKER)\n\t\tschedule_timeout_uninterruptible(1);\n\telse\n\t\tcond_resched();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__alloc_pages_direct_compact",
          "args": [
            "gfp_mask",
            "order",
            "alloc_flags",
            "ac",
            "compact_priority",
            "&compact_result"
          ],
          "line": 4191
        },
        "resolved": true,
        "details": {
          "function_name": "__alloc_pages_direct_compact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3665-3672",
          "snippet": "static inline struct page *\n__alloc_pages_direct_compact(gfp_t gfp_mask, unsigned int order,\n\t\tunsigned int alloc_flags, const struct alloc_context *ac,\n\t\tenum compact_priority prio, enum compact_result *compact_result)\n{\n\t*compact_result = COMPACT_SKIPPED;\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline struct page *\n__alloc_pages_direct_compact(gfp_t gfp_mask, unsigned int order,\n\t\tunsigned int alloc_flags, const struct alloc_context *ac,\n\t\tenum compact_priority prio, enum compact_result *compact_result)\n{\n\t*compact_result = COMPACT_SKIPPED;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__alloc_pages_direct_reclaim",
          "args": [
            "gfp_mask",
            "order",
            "alloc_flags",
            "ac",
            "&did_some_progress"
          ],
          "line": 4185
        },
        "resolved": true,
        "details": {
          "function_name": "__alloc_pages_direct_reclaim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3787-3815",
          "snippet": "static inline struct page *\n__alloc_pages_direct_reclaim(gfp_t gfp_mask, unsigned int order,\n\t\tunsigned int alloc_flags, const struct alloc_context *ac,\n\t\tunsigned long *did_some_progress)\n{\n\tstruct page *page = NULL;\n\tbool drained = false;\n\n\t*did_some_progress = __perform_reclaim(gfp_mask, order, ac);\n\tif (unlikely(!(*did_some_progress)))\n\t\treturn NULL;\n\nretry:\n\tpage = get_page_from_freelist(gfp_mask, order, alloc_flags, ac);\n\n\t/*\n\t * If an allocation failed after direct reclaim, it could be because\n\t * pages are pinned on the per-cpu lists or in high alloc reserves.\n\t * Shrink them them and try again\n\t */\n\tif (!page && !drained) {\n\t\tunreserve_highatomic_pageblock(ac, false);\n\t\tdrain_all_pages(NULL);\n\t\tdrained = true;\n\t\tgoto retry;\n\t}\n\n\treturn page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline struct page *\n__alloc_pages_direct_reclaim(gfp_t gfp_mask, unsigned int order,\n\t\tunsigned int alloc_flags, const struct alloc_context *ac,\n\t\tunsigned long *did_some_progress)\n{\n\tstruct page *page = NULL;\n\tbool drained = false;\n\n\t*did_some_progress = __perform_reclaim(gfp_mask, order, ac);\n\tif (unlikely(!(*did_some_progress)))\n\t\treturn NULL;\n\nretry:\n\tpage = get_page_from_freelist(gfp_mask, order, alloc_flags, ac);\n\n\t/*\n\t * If an allocation failed after direct reclaim, it could be because\n\t * pages are pinned on the per-cpu lists or in high alloc reserves.\n\t * Shrink them them and try again\n\t */\n\tif (!page && !drained) {\n\t\tunreserve_highatomic_pageblock(ac, false);\n\t\tdrain_all_pages(NULL);\n\t\tdrained = true;\n\t\tgoto retry;\n\t}\n\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_page_from_freelist",
          "args": [
            "gfp_mask",
            "order",
            "alloc_flags",
            "ac"
          ],
          "line": 4172
        },
        "resolved": true,
        "details": {
          "function_name": "get_page_from_freelist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3260-3378",
          "snippet": "static struct page *\nget_page_from_freelist(gfp_t gfp_mask, unsigned int order, int alloc_flags,\n\t\t\t\t\t\tconst struct alloc_context *ac)\n{\n\tstruct zoneref *z = ac->preferred_zoneref;\n\tstruct zone *zone;\n\tstruct pglist_data *last_pgdat_dirty_limit = NULL;\n\n\t/*\n\t * Scan zonelist, looking for a zone with enough free.\n\t * See also __cpuset_node_allowed() comment in kernel/cpuset.c.\n\t */\n\tfor_next_zone_zonelist_nodemask(zone, z, ac->zonelist, ac->high_zoneidx,\n\t\t\t\t\t\t\t\tac->nodemask) {\n\t\tstruct page *page;\n\t\tunsigned long mark;\n\n\t\tif (cpusets_enabled() &&\n\t\t\t(alloc_flags & ALLOC_CPUSET) &&\n\t\t\t!__cpuset_zone_allowed(zone, gfp_mask))\n\t\t\t\tcontinue;\n\t\t/*\n\t\t * When allocating a page cache page for writing, we\n\t\t * want to get it from a node that is within its dirty\n\t\t * limit, such that no single node holds more than its\n\t\t * proportional share of globally allowed dirty pages.\n\t\t * The dirty limits take into account the node's\n\t\t * lowmem reserves and high watermark so that kswapd\n\t\t * should be able to balance it without having to\n\t\t * write pages from its LRU list.\n\t\t *\n\t\t * XXX: For now, allow allocations to potentially\n\t\t * exceed the per-node dirty limit in the slowpath\n\t\t * (spread_dirty_pages unset) before going into reclaim,\n\t\t * which is important when on a NUMA setup the allowed\n\t\t * nodes are together not big enough to reach the\n\t\t * global limit.  The proper fix for these situations\n\t\t * will require awareness of nodes in the\n\t\t * dirty-throttling and the flusher threads.\n\t\t */\n\t\tif (ac->spread_dirty_pages) {\n\t\t\tif (last_pgdat_dirty_limit == zone->zone_pgdat)\n\t\t\t\tcontinue;\n\n\t\t\tif (!node_dirty_ok(zone->zone_pgdat)) {\n\t\t\t\tlast_pgdat_dirty_limit = zone->zone_pgdat;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tmark = zone->watermark[alloc_flags & ALLOC_WMARK_MASK];\n\t\tif (!zone_watermark_fast(zone, order, mark,\n\t\t\t\t       ac_classzone_idx(ac), alloc_flags)) {\n\t\t\tint ret;\n\n#ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT\n\t\t\t/*\n\t\t\t * Watermark failed for this zone, but see if we can\n\t\t\t * grow this zone if it contains deferred pages.\n\t\t\t */\n\t\t\tif (static_branch_unlikely(&deferred_pages)) {\n\t\t\t\tif (_deferred_grow_zone(zone, order))\n\t\t\t\t\tgoto try_this_zone;\n\t\t\t}\n#endif\n\t\t\t/* Checked here to keep the fast path fast */\n\t\t\tBUILD_BUG_ON(ALLOC_NO_WATERMARKS < NR_WMARK);\n\t\t\tif (alloc_flags & ALLOC_NO_WATERMARKS)\n\t\t\t\tgoto try_this_zone;\n\n\t\t\tif (node_reclaim_mode == 0 ||\n\t\t\t    !zone_allows_reclaim(ac->preferred_zoneref->zone, zone))\n\t\t\t\tcontinue;\n\n\t\t\tret = node_reclaim(zone->zone_pgdat, gfp_mask, order);\n\t\t\tswitch (ret) {\n\t\t\tcase NODE_RECLAIM_NOSCAN:\n\t\t\t\t/* did not scan */\n\t\t\t\tcontinue;\n\t\t\tcase NODE_RECLAIM_FULL:\n\t\t\t\t/* scanned but unreclaimable */\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\t/* did we reclaim enough */\n\t\t\t\tif (zone_watermark_ok(zone, order, mark,\n\t\t\t\t\t\tac_classzone_idx(ac), alloc_flags))\n\t\t\t\t\tgoto try_this_zone;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\ntry_this_zone:\n\t\tpage = rmqueue(ac->preferred_zoneref->zone, zone, order,\n\t\t\t\tgfp_mask, alloc_flags, ac->migratetype);\n\t\tif (page) {\n\t\t\tprep_new_page(page, order, gfp_mask, alloc_flags);\n\n\t\t\t/*\n\t\t\t * If this is a high-order atomic allocation then check\n\t\t\t * if the pageblock should be reserved for the future\n\t\t\t */\n\t\t\tif (unlikely(order && (alloc_flags & ALLOC_HARDER)))\n\t\t\t\treserve_highatomic_pageblock(page, zone, order);\n\n\t\t\treturn page;\n\t\t} else {\n#ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT\n\t\t\t/* Try again if zone has deferred pages */\n\t\t\tif (static_branch_unlikely(&deferred_pages)) {\n\t\t\t\tif (_deferred_grow_zone(zone, order))\n\t\t\t\t\tgoto try_this_zone;\n\t\t\t}\n#endif\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic struct page *\nget_page_from_freelist(gfp_t gfp_mask, unsigned int order, int alloc_flags,\n\t\t\t\t\t\tconst struct alloc_context *ac)\n{\n\tstruct zoneref *z = ac->preferred_zoneref;\n\tstruct zone *zone;\n\tstruct pglist_data *last_pgdat_dirty_limit = NULL;\n\n\t/*\n\t * Scan zonelist, looking for a zone with enough free.\n\t * See also __cpuset_node_allowed() comment in kernel/cpuset.c.\n\t */\n\tfor_next_zone_zonelist_nodemask(zone, z, ac->zonelist, ac->high_zoneidx,\n\t\t\t\t\t\t\t\tac->nodemask) {\n\t\tstruct page *page;\n\t\tunsigned long mark;\n\n\t\tif (cpusets_enabled() &&\n\t\t\t(alloc_flags & ALLOC_CPUSET) &&\n\t\t\t!__cpuset_zone_allowed(zone, gfp_mask))\n\t\t\t\tcontinue;\n\t\t/*\n\t\t * When allocating a page cache page for writing, we\n\t\t * want to get it from a node that is within its dirty\n\t\t * limit, such that no single node holds more than its\n\t\t * proportional share of globally allowed dirty pages.\n\t\t * The dirty limits take into account the node's\n\t\t * lowmem reserves and high watermark so that kswapd\n\t\t * should be able to balance it without having to\n\t\t * write pages from its LRU list.\n\t\t *\n\t\t * XXX: For now, allow allocations to potentially\n\t\t * exceed the per-node dirty limit in the slowpath\n\t\t * (spread_dirty_pages unset) before going into reclaim,\n\t\t * which is important when on a NUMA setup the allowed\n\t\t * nodes are together not big enough to reach the\n\t\t * global limit.  The proper fix for these situations\n\t\t * will require awareness of nodes in the\n\t\t * dirty-throttling and the flusher threads.\n\t\t */\n\t\tif (ac->spread_dirty_pages) {\n\t\t\tif (last_pgdat_dirty_limit == zone->zone_pgdat)\n\t\t\t\tcontinue;\n\n\t\t\tif (!node_dirty_ok(zone->zone_pgdat)) {\n\t\t\t\tlast_pgdat_dirty_limit = zone->zone_pgdat;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tmark = zone->watermark[alloc_flags & ALLOC_WMARK_MASK];\n\t\tif (!zone_watermark_fast(zone, order, mark,\n\t\t\t\t       ac_classzone_idx(ac), alloc_flags)) {\n\t\t\tint ret;\n\n#ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT\n\t\t\t/*\n\t\t\t * Watermark failed for this zone, but see if we can\n\t\t\t * grow this zone if it contains deferred pages.\n\t\t\t */\n\t\t\tif (static_branch_unlikely(&deferred_pages)) {\n\t\t\t\tif (_deferred_grow_zone(zone, order))\n\t\t\t\t\tgoto try_this_zone;\n\t\t\t}\n#endif\n\t\t\t/* Checked here to keep the fast path fast */\n\t\t\tBUILD_BUG_ON(ALLOC_NO_WATERMARKS < NR_WMARK);\n\t\t\tif (alloc_flags & ALLOC_NO_WATERMARKS)\n\t\t\t\tgoto try_this_zone;\n\n\t\t\tif (node_reclaim_mode == 0 ||\n\t\t\t    !zone_allows_reclaim(ac->preferred_zoneref->zone, zone))\n\t\t\t\tcontinue;\n\n\t\t\tret = node_reclaim(zone->zone_pgdat, gfp_mask, order);\n\t\t\tswitch (ret) {\n\t\t\tcase NODE_RECLAIM_NOSCAN:\n\t\t\t\t/* did not scan */\n\t\t\t\tcontinue;\n\t\t\tcase NODE_RECLAIM_FULL:\n\t\t\t\t/* scanned but unreclaimable */\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\t/* did we reclaim enough */\n\t\t\t\tif (zone_watermark_ok(zone, order, mark,\n\t\t\t\t\t\tac_classzone_idx(ac), alloc_flags))\n\t\t\t\t\tgoto try_this_zone;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\ntry_this_zone:\n\t\tpage = rmqueue(ac->preferred_zoneref->zone, zone, order,\n\t\t\t\tgfp_mask, alloc_flags, ac->migratetype);\n\t\tif (page) {\n\t\t\tprep_new_page(page, order, gfp_mask, alloc_flags);\n\n\t\t\t/*\n\t\t\t * If this is a high-order atomic allocation then check\n\t\t\t * if the pageblock should be reserved for the future\n\t\t\t */\n\t\t\tif (unlikely(order && (alloc_flags & ALLOC_HARDER)))\n\t\t\t\treserve_highatomic_pageblock(page, zone, order);\n\n\t\t\treturn page;\n\t\t} else {\n#ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT\n\t\t\t/* Try again if zone has deferred pages */\n\t\t\tif (static_branch_unlikely(&deferred_pages)) {\n\t\t\t\tif (_deferred_grow_zone(zone, order))\n\t\t\t\t\tgoto try_this_zone;\n\t\t\t}\n#endif\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "first_zones_zonelist",
          "args": [
            "ac->zonelist",
            "ac->high_zoneidx",
            "ac->nodemask"
          ],
          "line": 4167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__gfp_pfmemalloc_flags",
          "args": [
            "gfp_mask"
          ],
          "line": 4156
        },
        "resolved": true,
        "details": {
          "function_name": "__gfp_pfmemalloc_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3890-3906",
          "snippet": "static inline int __gfp_pfmemalloc_flags(gfp_t gfp_mask)\n{\n\tif (unlikely(gfp_mask & __GFP_NOMEMALLOC))\n\t\treturn 0;\n\tif (gfp_mask & __GFP_MEMALLOC)\n\t\treturn ALLOC_NO_WATERMARKS;\n\tif (in_serving_softirq() && (current->flags & PF_MEMALLOC))\n\t\treturn ALLOC_NO_WATERMARKS;\n\tif (!in_interrupt()) {\n\t\tif (current->flags & PF_MEMALLOC)\n\t\t\treturn ALLOC_NO_WATERMARKS;\n\t\telse if (oom_reserves_allowed(current))\n\t\t\treturn ALLOC_OOM;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic inline int __gfp_pfmemalloc_flags(gfp_t gfp_mask)\n{\n\tif (unlikely(gfp_mask & __GFP_NOMEMALLOC))\n\t\treturn 0;\n\tif (gfp_mask & __GFP_MEMALLOC)\n\t\treturn ALLOC_NO_WATERMARKS;\n\tif (in_serving_softirq() && (current->flags & PF_MEMALLOC))\n\t\treturn ALLOC_NO_WATERMARKS;\n\tif (!in_interrupt()) {\n\t\tif (current->flags & PF_MEMALLOC)\n\t\t\treturn ALLOC_NO_WATERMARKS;\n\t\telse if (oom_reserves_allowed(current))\n\t\t\treturn ALLOC_OOM;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_all_kswapds",
          "args": [
            "order",
            "gfp_mask",
            "ac"
          ],
          "line": 4154
        },
        "resolved": true,
        "details": {
          "function_name": "wake_all_kswapds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3817-3831",
          "snippet": "static void wake_all_kswapds(unsigned int order, gfp_t gfp_mask,\n\t\t\t     const struct alloc_context *ac)\n{\n\tstruct zoneref *z;\n\tstruct zone *zone;\n\tpg_data_t *last_pgdat = NULL;\n\tenum zone_type high_zoneidx = ac->high_zoneidx;\n\n\tfor_each_zone_zonelist_nodemask(zone, z, ac->zonelist, high_zoneidx,\n\t\t\t\t\tac->nodemask) {\n\t\tif (last_pgdat != zone->zone_pgdat)\n\t\t\twakeup_kswapd(zone, gfp_mask, order, high_zoneidx);\n\t\tlast_pgdat = zone->zone_pgdat;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic void wake_all_kswapds(unsigned int order, gfp_t gfp_mask,\n\t\t\t     const struct alloc_context *ac)\n{\n\tstruct zoneref *z;\n\tstruct zone *zone;\n\tpg_data_t *last_pgdat = NULL;\n\tenum zone_type high_zoneidx = ac->high_zoneidx;\n\n\tfor_each_zone_zonelist_nodemask(zone, z, ac->zonelist, high_zoneidx,\n\t\t\t\t\tac->nodemask) {\n\t\tif (last_pgdat != zone->zone_pgdat)\n\t\t\twakeup_kswapd(zone, gfp_mask, order, high_zoneidx);\n\t\tlast_pgdat = zone->zone_pgdat;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfp_pfmemalloc_allowed",
          "args": [
            "gfp_mask"
          ],
          "line": 4118
        },
        "resolved": true,
        "details": {
          "function_name": "gfp_pfmemalloc_allowed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3908-3911",
          "snippet": "bool gfp_pfmemalloc_allowed(gfp_t gfp_mask)\n{\n\treturn !!__gfp_pfmemalloc_flags(gfp_mask);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nbool gfp_pfmemalloc_allowed(gfp_t gfp_mask)\n{\n\treturn !!__gfp_pfmemalloc_flags(gfp_mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "first_zones_zonelist",
          "args": [
            "ac->zonelist",
            "ac->high_zoneidx",
            "ac->nodemask"
          ],
          "line": 4090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfp_to_alloc_flags",
          "args": [
            "gfp_mask"
          ],
          "line": 4082
        },
        "resolved": true,
        "details": {
          "function_name": "gfp_to_alloc_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3833-3869",
          "snippet": "static inline unsigned int\ngfp_to_alloc_flags(gfp_t gfp_mask)\n{\n\tunsigned int alloc_flags = ALLOC_WMARK_MIN | ALLOC_CPUSET;\n\n\t/* __GFP_HIGH is assumed to be the same as ALLOC_HIGH to save a branch. */\n\tBUILD_BUG_ON(__GFP_HIGH != (__force gfp_t) ALLOC_HIGH);\n\n\t/*\n\t * The caller may dip into page reserves a bit more if the caller\n\t * cannot run direct reclaim, or if the caller has realtime scheduling\n\t * policy or is asking for __GFP_HIGH memory.  GFP_ATOMIC requests will\n\t * set both ALLOC_HARDER (__GFP_ATOMIC) and ALLOC_HIGH (__GFP_HIGH).\n\t */\n\talloc_flags |= (__force int) (gfp_mask & __GFP_HIGH);\n\n\tif (gfp_mask & __GFP_ATOMIC) {\n\t\t/*\n\t\t * Not worth trying to allocate harder for __GFP_NOMEMALLOC even\n\t\t * if it can't schedule.\n\t\t */\n\t\tif (!(gfp_mask & __GFP_NOMEMALLOC))\n\t\t\talloc_flags |= ALLOC_HARDER;\n\t\t/*\n\t\t * Ignore cpuset mems for GFP_ATOMIC rather than fail, see the\n\t\t * comment for __cpuset_node_allowed().\n\t\t */\n\t\talloc_flags &= ~ALLOC_CPUSET;\n\t} else if (unlikely(rt_task(current)) && !in_interrupt())\n\t\talloc_flags |= ALLOC_HARDER;\n\n#ifdef CONFIG_CMA\n\tif (gfpflags_to_migratetype(gfp_mask) == MIGRATE_MOVABLE)\n\t\talloc_flags |= ALLOC_CMA;\n#endif\n\treturn alloc_flags;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic inline unsigned int\ngfp_to_alloc_flags(gfp_t gfp_mask)\n{\n\tunsigned int alloc_flags = ALLOC_WMARK_MIN | ALLOC_CPUSET;\n\n\t/* __GFP_HIGH is assumed to be the same as ALLOC_HIGH to save a branch. */\n\tBUILD_BUG_ON(__GFP_HIGH != (__force gfp_t) ALLOC_HIGH);\n\n\t/*\n\t * The caller may dip into page reserves a bit more if the caller\n\t * cannot run direct reclaim, or if the caller has realtime scheduling\n\t * policy or is asking for __GFP_HIGH memory.  GFP_ATOMIC requests will\n\t * set both ALLOC_HARDER (__GFP_ATOMIC) and ALLOC_HIGH (__GFP_HIGH).\n\t */\n\talloc_flags |= (__force int) (gfp_mask & __GFP_HIGH);\n\n\tif (gfp_mask & __GFP_ATOMIC) {\n\t\t/*\n\t\t * Not worth trying to allocate harder for __GFP_NOMEMALLOC even\n\t\t * if it can't schedule.\n\t\t */\n\t\tif (!(gfp_mask & __GFP_NOMEMALLOC))\n\t\t\talloc_flags |= ALLOC_HARDER;\n\t\t/*\n\t\t * Ignore cpuset mems for GFP_ATOMIC rather than fail, see the\n\t\t * comment for __cpuset_node_allowed().\n\t\t */\n\t\talloc_flags &= ~ALLOC_CPUSET;\n\t} else if (unlikely(rt_task(current)) && !in_interrupt())\n\t\talloc_flags |= ALLOC_HARDER;\n\n#ifdef CONFIG_CMA\n\tif (gfpflags_to_migratetype(gfp_mask) == MIGRATE_MOVABLE)\n\t\talloc_flags |= ALLOC_CMA;\n#endif\n\treturn alloc_flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_mems_allowed_begin",
          "args": [],
          "line": 4075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "(gfp_mask & (__GFP_ATOMIC|__GFP_DIRECT_RECLAIM)) ==\n\t\t\t\t(__GFP_ATOMIC|__GFP_DIRECT_RECLAIM)"
          ],
          "line": 4067
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline struct page *\n__alloc_pages_slowpath(gfp_t gfp_mask, unsigned int order,\n\t\t\t\t\t\tstruct alloc_context *ac)\n{\n\tbool can_direct_reclaim = gfp_mask & __GFP_DIRECT_RECLAIM;\n\tconst bool costly_order = order > PAGE_ALLOC_COSTLY_ORDER;\n\tstruct page *page = NULL;\n\tunsigned int alloc_flags;\n\tunsigned long did_some_progress;\n\tenum compact_priority compact_priority;\n\tenum compact_result compact_result;\n\tint compaction_retries;\n\tint no_progress_loops;\n\tunsigned int cpuset_mems_cookie;\n\tint reserve_flags;\n\n\t/*\n\t * We also sanity check to catch abuse of atomic reserves being used by\n\t * callers that are not in atomic context.\n\t */\n\tif (WARN_ON_ONCE((gfp_mask & (__GFP_ATOMIC|__GFP_DIRECT_RECLAIM)) ==\n\t\t\t\t(__GFP_ATOMIC|__GFP_DIRECT_RECLAIM)))\n\t\tgfp_mask &= ~__GFP_ATOMIC;\n\nretry_cpuset:\n\tcompaction_retries = 0;\n\tno_progress_loops = 0;\n\tcompact_priority = DEF_COMPACT_PRIORITY;\n\tcpuset_mems_cookie = read_mems_allowed_begin();\n\n\t/*\n\t * The fast path uses conservative alloc_flags to succeed only until\n\t * kswapd needs to be woken up, and to avoid the cost of setting up\n\t * alloc_flags precisely. So we do that now.\n\t */\n\talloc_flags = gfp_to_alloc_flags(gfp_mask);\n\n\t/*\n\t * We need to recalculate the starting point for the zonelist iterator\n\t * because we might have used different nodemask in the fast path, or\n\t * there was a cpuset modification and we are retrying - otherwise we\n\t * could end up iterating over non-eligible zones endlessly.\n\t */\n\tac->preferred_zoneref = first_zones_zonelist(ac->zonelist,\n\t\t\t\t\tac->high_zoneidx, ac->nodemask);\n\tif (!ac->preferred_zoneref->zone)\n\t\tgoto nopage;\n\n\tif (gfp_mask & __GFP_KSWAPD_RECLAIM)\n\t\twake_all_kswapds(order, gfp_mask, ac);\n\n\t/*\n\t * The adjusted alloc_flags might result in immediate success, so try\n\t * that first\n\t */\n\tpage = get_page_from_freelist(gfp_mask, order, alloc_flags, ac);\n\tif (page)\n\t\tgoto got_pg;\n\n\t/*\n\t * For costly allocations, try direct compaction first, as it's likely\n\t * that we have enough base pages and don't need to reclaim. For non-\n\t * movable high-order allocations, do that as well, as compaction will\n\t * try prevent permanent fragmentation by migrating from blocks of the\n\t * same migratetype.\n\t * Don't try this for allocations that are allowed to ignore\n\t * watermarks, as the ALLOC_NO_WATERMARKS attempt didn't yet happen.\n\t */\n\tif (can_direct_reclaim &&\n\t\t\t(costly_order ||\n\t\t\t   (order > 0 && ac->migratetype != MIGRATE_MOVABLE))\n\t\t\t&& !gfp_pfmemalloc_allowed(gfp_mask)) {\n\t\tpage = __alloc_pages_direct_compact(gfp_mask, order,\n\t\t\t\t\t\talloc_flags, ac,\n\t\t\t\t\t\tINIT_COMPACT_PRIORITY,\n\t\t\t\t\t\t&compact_result);\n\t\tif (page)\n\t\t\tgoto got_pg;\n\n\t\t/*\n\t\t * Checks for costly allocations with __GFP_NORETRY, which\n\t\t * includes THP page fault allocations\n\t\t */\n\t\tif (costly_order && (gfp_mask & __GFP_NORETRY)) {\n\t\t\t/*\n\t\t\t * If compaction is deferred for high-order allocations,\n\t\t\t * it is because sync compaction recently failed. If\n\t\t\t * this is the case and the caller requested a THP\n\t\t\t * allocation, we do not want to heavily disrupt the\n\t\t\t * system, so we fail the allocation instead of entering\n\t\t\t * direct reclaim.\n\t\t\t */\n\t\t\tif (compact_result == COMPACT_DEFERRED)\n\t\t\t\tgoto nopage;\n\n\t\t\t/*\n\t\t\t * Looks like reclaim/compaction is worth trying, but\n\t\t\t * sync compaction could be very expensive, so keep\n\t\t\t * using async compaction.\n\t\t\t */\n\t\t\tcompact_priority = INIT_COMPACT_PRIORITY;\n\t\t}\n\t}\n\nretry:\n\t/* Ensure kswapd doesn't accidentally go to sleep as long as we loop */\n\tif (gfp_mask & __GFP_KSWAPD_RECLAIM)\n\t\twake_all_kswapds(order, gfp_mask, ac);\n\n\treserve_flags = __gfp_pfmemalloc_flags(gfp_mask);\n\tif (reserve_flags)\n\t\talloc_flags = reserve_flags;\n\n\t/*\n\t * Reset the nodemask and zonelist iterators if memory policies can be\n\t * ignored. These allocations are high priority and system rather than\n\t * user oriented.\n\t */\n\tif (!(alloc_flags & ALLOC_CPUSET) || reserve_flags) {\n\t\tac->nodemask = NULL;\n\t\tac->preferred_zoneref = first_zones_zonelist(ac->zonelist,\n\t\t\t\t\tac->high_zoneidx, ac->nodemask);\n\t}\n\n\t/* Attempt with potentially adjusted zonelist and alloc_flags */\n\tpage = get_page_from_freelist(gfp_mask, order, alloc_flags, ac);\n\tif (page)\n\t\tgoto got_pg;\n\n\t/* Caller is not willing to reclaim, we can't balance anything */\n\tif (!can_direct_reclaim)\n\t\tgoto nopage;\n\n\t/* Avoid recursion of direct reclaim */\n\tif (current->flags & PF_MEMALLOC)\n\t\tgoto nopage;\n\n\t/* Try direct reclaim and then allocating */\n\tpage = __alloc_pages_direct_reclaim(gfp_mask, order, alloc_flags, ac,\n\t\t\t\t\t\t\t&did_some_progress);\n\tif (page)\n\t\tgoto got_pg;\n\n\t/* Try direct compaction and then allocating */\n\tpage = __alloc_pages_direct_compact(gfp_mask, order, alloc_flags, ac,\n\t\t\t\t\tcompact_priority, &compact_result);\n\tif (page)\n\t\tgoto got_pg;\n\n\t/* Do not loop if specifically requested */\n\tif (gfp_mask & __GFP_NORETRY)\n\t\tgoto nopage;\n\n\t/*\n\t * Do not retry costly high order allocations unless they are\n\t * __GFP_RETRY_MAYFAIL\n\t */\n\tif (costly_order && !(gfp_mask & __GFP_RETRY_MAYFAIL))\n\t\tgoto nopage;\n\n\tif (should_reclaim_retry(gfp_mask, order, ac, alloc_flags,\n\t\t\t\t did_some_progress > 0, &no_progress_loops))\n\t\tgoto retry;\n\n\t/*\n\t * It doesn't make any sense to retry for the compaction if the order-0\n\t * reclaim is not able to make any progress because the current\n\t * implementation of the compaction depends on the sufficient amount\n\t * of free memory (see __compaction_suitable)\n\t */\n\tif (did_some_progress > 0 &&\n\t\t\tshould_compact_retry(ac, order, alloc_flags,\n\t\t\t\tcompact_result, &compact_priority,\n\t\t\t\t&compaction_retries))\n\t\tgoto retry;\n\n\n\t/* Deal with possible cpuset update races before we start OOM killing */\n\tif (check_retry_cpuset(cpuset_mems_cookie, ac))\n\t\tgoto retry_cpuset;\n\n\t/* Reclaim has failed us, start killing things */\n\tpage = __alloc_pages_may_oom(gfp_mask, order, ac, &did_some_progress);\n\tif (page)\n\t\tgoto got_pg;\n\n\t/* Avoid allocations with no watermarks from looping endlessly */\n\tif (tsk_is_oom_victim(current) &&\n\t    (alloc_flags == ALLOC_OOM ||\n\t     (gfp_mask & __GFP_NOMEMALLOC)))\n\t\tgoto nopage;\n\n\t/* Retry as long as the OOM killer is making progress */\n\tif (did_some_progress) {\n\t\tno_progress_loops = 0;\n\t\tgoto retry;\n\t}\n\nnopage:\n\t/* Deal with possible cpuset update races before we fail */\n\tif (check_retry_cpuset(cpuset_mems_cookie, ac))\n\t\tgoto retry_cpuset;\n\n\t/*\n\t * Make sure that __GFP_NOFAIL request doesn't leak out and make sure\n\t * we always retry\n\t */\n\tif (gfp_mask & __GFP_NOFAIL) {\n\t\t/*\n\t\t * All existing users of the __GFP_NOFAIL are blockable, so warn\n\t\t * of any new users that actually require GFP_NOWAIT\n\t\t */\n\t\tif (WARN_ON_ONCE(!can_direct_reclaim))\n\t\t\tgoto fail;\n\n\t\t/*\n\t\t * PF_MEMALLOC request from this context is rather bizarre\n\t\t * because we cannot reclaim anything and only can loop waiting\n\t\t * for somebody to do a work for us\n\t\t */\n\t\tWARN_ON_ONCE(current->flags & PF_MEMALLOC);\n\n\t\t/*\n\t\t * non failing costly orders are a hard requirement which we\n\t\t * are not prepared for much so let's warn about these users\n\t\t * so that we can identify them and convert them to something\n\t\t * else.\n\t\t */\n\t\tWARN_ON_ONCE(order > PAGE_ALLOC_COSTLY_ORDER);\n\n\t\t/*\n\t\t * Help non-failing allocations by giving them access to memory\n\t\t * reserves but do not use ALLOC_NO_WATERMARKS because this\n\t\t * could deplete whole memory reserves which would just make\n\t\t * the situation worse\n\t\t */\n\t\tpage = __alloc_pages_cpuset_fallback(gfp_mask, order, ALLOC_HARDER, ac);\n\t\tif (page)\n\t\t\tgoto got_pg;\n\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\nfail:\n\twarn_alloc(gfp_mask, ac->nodemask,\n\t\t\t\"page allocation failure: order:%u\", order);\ngot_pg:\n\treturn page;\n}"
  },
  {
    "function_name": "check_retry_cpuset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "4014-4045",
    "snippet": "static inline bool\ncheck_retry_cpuset(int cpuset_mems_cookie, struct alloc_context *ac)\n{\n\t/*\n\t * It's possible that cpuset's mems_allowed and the nodemask from\n\t * mempolicy don't intersect. This should be normally dealt with by\n\t * policy_nodemask(), but it's possible to race with cpuset update in\n\t * such a way the check therein was true, and then it became false\n\t * before we got our cpuset_mems_cookie here.\n\t * This assumes that for all allocations, ac->nodemask can come only\n\t * from MPOL_BIND mempolicy (whose documented semantics is to be ignored\n\t * when it does not intersect with the cpuset restrictions) or the\n\t * caller can deal with a violated nodemask.\n\t */\n\tif (cpusets_enabled() && ac->nodemask &&\n\t\t\t!cpuset_nodemask_valid_mems_allowed(ac->nodemask)) {\n\t\tac->nodemask = NULL;\n\t\treturn true;\n\t}\n\n\t/*\n\t * When updating a task's mems_allowed or mempolicy nodemask, it is\n\t * possible to race with parallel threads in such a way that our\n\t * allocation can fail while the mask is being updated. If we are about\n\t * to fail, check if the cpuset changed during allocation and if so,\n\t * retry.\n\t */\n\tif (read_mems_allowed_retry(cpuset_mems_cookie))\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_mems_allowed_retry",
          "args": [
            "cpuset_mems_cookie"
          ],
          "line": 4041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuset_nodemask_valid_mems_allowed",
          "args": [
            "ac->nodemask"
          ],
          "line": 4029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpusets_enabled",
          "args": [],
          "line": 4028
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline bool\ncheck_retry_cpuset(int cpuset_mems_cookie, struct alloc_context *ac)\n{\n\t/*\n\t * It's possible that cpuset's mems_allowed and the nodemask from\n\t * mempolicy don't intersect. This should be normally dealt with by\n\t * policy_nodemask(), but it's possible to race with cpuset update in\n\t * such a way the check therein was true, and then it became false\n\t * before we got our cpuset_mems_cookie here.\n\t * This assumes that for all allocations, ac->nodemask can come only\n\t * from MPOL_BIND mempolicy (whose documented semantics is to be ignored\n\t * when it does not intersect with the cpuset restrictions) or the\n\t * caller can deal with a violated nodemask.\n\t */\n\tif (cpusets_enabled() && ac->nodemask &&\n\t\t\t!cpuset_nodemask_valid_mems_allowed(ac->nodemask)) {\n\t\tac->nodemask = NULL;\n\t\treturn true;\n\t}\n\n\t/*\n\t * When updating a task's mems_allowed or mempolicy nodemask, it is\n\t * possible to race with parallel threads in such a way that our\n\t * allocation can fail while the mask is being updated. If we are about\n\t * to fail, check if the cpuset changed during allocation and if so,\n\t * retry.\n\t */\n\tif (read_mems_allowed_retry(cpuset_mems_cookie))\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "should_reclaim_retry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "3923-4012",
    "snippet": "static inline bool\nshould_reclaim_retry(gfp_t gfp_mask, unsigned order,\n\t\t     struct alloc_context *ac, int alloc_flags,\n\t\t     bool did_some_progress, int *no_progress_loops)\n{\n\tstruct zone *zone;\n\tstruct zoneref *z;\n\tbool ret = false;\n\n\t/*\n\t * Costly allocations might have made a progress but this doesn't mean\n\t * their order will become available due to high fragmentation so\n\t * always increment the no progress counter for them\n\t */\n\tif (did_some_progress && order <= PAGE_ALLOC_COSTLY_ORDER)\n\t\t*no_progress_loops = 0;\n\telse\n\t\t(*no_progress_loops)++;\n\n\t/*\n\t * Make sure we converge to OOM if we cannot make any progress\n\t * several times in the row.\n\t */\n\tif (*no_progress_loops > MAX_RECLAIM_RETRIES) {\n\t\t/* Before OOM, exhaust highatomic_reserve */\n\t\treturn unreserve_highatomic_pageblock(ac, true);\n\t}\n\n\t/*\n\t * Keep reclaiming pages while there is a chance this will lead\n\t * somewhere.  If none of the target zones can satisfy our allocation\n\t * request even if all reclaimable pages are considered then we are\n\t * screwed and have to go OOM.\n\t */\n\tfor_each_zone_zonelist_nodemask(zone, z, ac->zonelist, ac->high_zoneidx,\n\t\t\t\t\tac->nodemask) {\n\t\tunsigned long available;\n\t\tunsigned long reclaimable;\n\t\tunsigned long min_wmark = min_wmark_pages(zone);\n\t\tbool wmark;\n\n\t\tavailable = reclaimable = zone_reclaimable_pages(zone);\n\t\tavailable += zone_page_state_snapshot(zone, NR_FREE_PAGES);\n\n\t\t/*\n\t\t * Would the allocation succeed if we reclaimed all\n\t\t * reclaimable pages?\n\t\t */\n\t\twmark = __zone_watermark_ok(zone, order, min_wmark,\n\t\t\t\tac_classzone_idx(ac), alloc_flags, available);\n\t\ttrace_reclaim_retry_zone(z, order, reclaimable,\n\t\t\t\tavailable, min_wmark, *no_progress_loops, wmark);\n\t\tif (wmark) {\n\t\t\t/*\n\t\t\t * If we didn't make any progress and have a lot of\n\t\t\t * dirty + writeback pages then we should wait for\n\t\t\t * an IO to complete to slow down the reclaim and\n\t\t\t * prevent from pre mature OOM\n\t\t\t */\n\t\t\tif (!did_some_progress) {\n\t\t\t\tunsigned long write_pending;\n\n\t\t\t\twrite_pending = zone_page_state_snapshot(zone,\n\t\t\t\t\t\t\tNR_ZONE_WRITE_PENDING);\n\n\t\t\t\tif (2 * write_pending > reclaimable) {\n\t\t\t\t\tcongestion_wait(BLK_RW_ASYNC, HZ/10);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tret = true;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\t/*\n\t * Memory allocation/reclaim might be called from a WQ context and the\n\t * current implementation of the WQ concurrency control doesn't\n\t * recognize that a particular WQ is congested if the worker thread is\n\t * looping without ever sleeping. Therefore we have to do a short sleep\n\t * here rather than calling cond_resched().\n\t */\n\tif (current->flags & PF_WQ_WORKER)\n\t\tschedule_timeout_uninterruptible(1);\n\telse\n\t\tcond_resched();\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);",
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 4010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout_uninterruptible",
          "args": [
            "1"
          ],
          "line": 4008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "congestion_wait",
          "args": [
            "BLK_RW_ASYNC",
            "HZ/10"
          ],
          "line": 3989
        },
        "resolved": true,
        "details": {
          "function_name": "congestion_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/backing-dev.c",
          "lines": "1016-1031",
          "snippet": "long congestion_wait(int sync, long timeout)\n{\n\tlong ret;\n\tunsigned long start = jiffies;\n\tDEFINE_WAIT(wait);\n\twait_queue_head_t *wqh = &congestion_wqh[sync];\n\n\tprepare_to_wait(wqh, &wait, TASK_UNINTERRUPTIBLE);\n\tret = io_schedule_timeout(timeout);\n\tfinish_wait(wqh, &wait);\n\n\ttrace_writeback_congestion_wait(jiffies_to_usecs(timeout),\n\t\t\t\t\tjiffies_to_usecs(jiffies - start));\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <trace/events/writeback.h>",
            "#include <linux/device.h>",
            "#include <linux/writeback.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/wait.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static wait_queue_head_t congestion_wqh[2] = {\n\t\t__WAIT_QUEUE_HEAD_INITIALIZER(congestion_wqh[0]),\n\t\t__WAIT_QUEUE_HEAD_INITIALIZER(congestion_wqh[1])\n\t};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <trace/events/writeback.h>\n#include <linux/device.h>\n#include <linux/writeback.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/wait.h>\n\nstatic wait_queue_head_t congestion_wqh[2] = {\n\t\t__WAIT_QUEUE_HEAD_INITIALIZER(congestion_wqh[0]),\n\t\t__WAIT_QUEUE_HEAD_INITIALIZER(congestion_wqh[1])\n\t};\n\nlong congestion_wait(int sync, long timeout)\n{\n\tlong ret;\n\tunsigned long start = jiffies;\n\tDEFINE_WAIT(wait);\n\twait_queue_head_t *wqh = &congestion_wqh[sync];\n\n\tprepare_to_wait(wqh, &wait, TASK_UNINTERRUPTIBLE);\n\tret = io_schedule_timeout(timeout);\n\tfinish_wait(wqh, &wait);\n\n\ttrace_writeback_congestion_wait(jiffies_to_usecs(timeout),\n\t\t\t\t\tjiffies_to_usecs(jiffies - start));\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zone_page_state_snapshot",
          "args": [
            "zone",
            "NR_ZONE_WRITE_PENDING"
          ],
          "line": 3985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_reclaim_retry_zone",
          "args": [
            "z",
            "order",
            "reclaimable",
            "available",
            "min_wmark",
            "*no_progress_loops",
            "wmark"
          ],
          "line": 3973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__zone_watermark_ok",
          "args": [
            "zone",
            "order",
            "min_wmark",
            "ac_classzone_idx(ac)",
            "alloc_flags",
            "available"
          ],
          "line": 3971
        },
        "resolved": true,
        "details": {
          "function_name": "__zone_watermark_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3119-3196",
          "snippet": "bool __zone_watermark_ok(struct zone *z, unsigned int order, unsigned long mark,\n\t\t\t int classzone_idx, unsigned int alloc_flags,\n\t\t\t long free_pages)\n{\n\tlong min = mark;\n\tint o;\n\tconst bool alloc_harder = (alloc_flags & (ALLOC_HARDER|ALLOC_OOM));\n\n\t/* free_pages may go negative - that's OK */\n\tfree_pages -= (1 << order) - 1;\n\n\tif (alloc_flags & ALLOC_HIGH)\n\t\tmin -= min / 2;\n\n\t/*\n\t * If the caller does not have rights to ALLOC_HARDER then subtract\n\t * the high-atomic reserves. This will over-estimate the size of the\n\t * atomic reserve but it avoids a search.\n\t */\n\tif (likely(!alloc_harder)) {\n\t\tfree_pages -= z->nr_reserved_highatomic;\n\t} else {\n\t\t/*\n\t\t * OOM victims can try even harder than normal ALLOC_HARDER\n\t\t * users on the grounds that it's definitely going to be in\n\t\t * the exit path shortly and free memory. Any allocation it\n\t\t * makes during the free path will be small and short-lived.\n\t\t */\n\t\tif (alloc_flags & ALLOC_OOM)\n\t\t\tmin -= min / 2;\n\t\telse\n\t\t\tmin -= min / 4;\n\t}\n\n\n#ifdef CONFIG_CMA\n\t/* If allocation can't use CMA areas don't use free CMA pages */\n\tif (!(alloc_flags & ALLOC_CMA))\n\t\tfree_pages -= zone_page_state(z, NR_FREE_CMA_PAGES);\n#endif\n\n\t/*\n\t * Check watermarks for an order-0 allocation request. If these\n\t * are not met, then a high-order request also cannot go ahead\n\t * even if a suitable page happened to be free.\n\t */\n\tif (free_pages <= min + z->lowmem_reserve[classzone_idx])\n\t\treturn false;\n\n\t/* If this is an order-0 request then the watermark is fine */\n\tif (!order)\n\t\treturn true;\n\n\t/* For a high-order request, check at least one suitable page is free */\n\tfor (o = order; o < MAX_ORDER; o++) {\n\t\tstruct free_area *area = &z->free_area[o];\n\t\tint mt;\n\n\t\tif (!area->nr_free)\n\t\t\tcontinue;\n\n\t\tfor (mt = 0; mt < MIGRATE_PCPTYPES; mt++) {\n\t\t\tif (!list_empty(&area->free_list[mt]))\n\t\t\t\treturn true;\n\t\t}\n\n#ifdef CONFIG_CMA\n\t\tif ((alloc_flags & ALLOC_CMA) &&\n\t\t    !list_empty(&area->free_list[MIGRATE_CMA])) {\n\t\t\treturn true;\n\t\t}\n#endif\n\t\tif (alloc_harder &&\n\t\t\t!list_empty(&area->free_list[MIGRATE_HIGHATOMIC]))\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nbool __zone_watermark_ok(struct zone *z, unsigned int order, unsigned long mark,\n\t\t\t int classzone_idx, unsigned int alloc_flags,\n\t\t\t long free_pages)\n{\n\tlong min = mark;\n\tint o;\n\tconst bool alloc_harder = (alloc_flags & (ALLOC_HARDER|ALLOC_OOM));\n\n\t/* free_pages may go negative - that's OK */\n\tfree_pages -= (1 << order) - 1;\n\n\tif (alloc_flags & ALLOC_HIGH)\n\t\tmin -= min / 2;\n\n\t/*\n\t * If the caller does not have rights to ALLOC_HARDER then subtract\n\t * the high-atomic reserves. This will over-estimate the size of the\n\t * atomic reserve but it avoids a search.\n\t */\n\tif (likely(!alloc_harder)) {\n\t\tfree_pages -= z->nr_reserved_highatomic;\n\t} else {\n\t\t/*\n\t\t * OOM victims can try even harder than normal ALLOC_HARDER\n\t\t * users on the grounds that it's definitely going to be in\n\t\t * the exit path shortly and free memory. Any allocation it\n\t\t * makes during the free path will be small and short-lived.\n\t\t */\n\t\tif (alloc_flags & ALLOC_OOM)\n\t\t\tmin -= min / 2;\n\t\telse\n\t\t\tmin -= min / 4;\n\t}\n\n\n#ifdef CONFIG_CMA\n\t/* If allocation can't use CMA areas don't use free CMA pages */\n\tif (!(alloc_flags & ALLOC_CMA))\n\t\tfree_pages -= zone_page_state(z, NR_FREE_CMA_PAGES);\n#endif\n\n\t/*\n\t * Check watermarks for an order-0 allocation request. If these\n\t * are not met, then a high-order request also cannot go ahead\n\t * even if a suitable page happened to be free.\n\t */\n\tif (free_pages <= min + z->lowmem_reserve[classzone_idx])\n\t\treturn false;\n\n\t/* If this is an order-0 request then the watermark is fine */\n\tif (!order)\n\t\treturn true;\n\n\t/* For a high-order request, check at least one suitable page is free */\n\tfor (o = order; o < MAX_ORDER; o++) {\n\t\tstruct free_area *area = &z->free_area[o];\n\t\tint mt;\n\n\t\tif (!area->nr_free)\n\t\t\tcontinue;\n\n\t\tfor (mt = 0; mt < MIGRATE_PCPTYPES; mt++) {\n\t\t\tif (!list_empty(&area->free_list[mt]))\n\t\t\t\treturn true;\n\t\t}\n\n#ifdef CONFIG_CMA\n\t\tif ((alloc_flags & ALLOC_CMA) &&\n\t\t    !list_empty(&area->free_list[MIGRATE_CMA])) {\n\t\t\treturn true;\n\t\t}\n#endif\n\t\tif (alloc_harder &&\n\t\t\t!list_empty(&area->free_list[MIGRATE_HIGHATOMIC]))\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ac_classzone_idx",
          "args": [
            "ac"
          ],
          "line": 3972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_page_state_snapshot",
          "args": [
            "zone",
            "NR_FREE_PAGES"
          ],
          "line": 3965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_reclaimable_pages",
          "args": [
            "zone"
          ],
          "line": 3964
        },
        "resolved": true,
        "details": {
          "function_name": "zone_reclaimable_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "320-331",
          "snippet": "unsigned long zone_reclaimable_pages(struct zone *zone)\n{\n\tunsigned long nr;\n\n\tnr = zone_page_state_snapshot(zone, NR_ZONE_INACTIVE_FILE) +\n\t\tzone_page_state_snapshot(zone, NR_ZONE_ACTIVE_FILE);\n\tif (get_nr_swap_pages() > 0)\n\t\tnr += zone_page_state_snapshot(zone, NR_ZONE_INACTIVE_ANON) +\n\t\t\tzone_page_state_snapshot(zone, NR_ZONE_ACTIVE_ANON);\n\n\treturn nr;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nunsigned long zone_reclaimable_pages(struct zone *zone)\n{\n\tunsigned long nr;\n\n\tnr = zone_page_state_snapshot(zone, NR_ZONE_INACTIVE_FILE) +\n\t\tzone_page_state_snapshot(zone, NR_ZONE_ACTIVE_FILE);\n\tif (get_nr_swap_pages() > 0)\n\t\tnr += zone_page_state_snapshot(zone, NR_ZONE_INACTIVE_ANON) +\n\t\t\tzone_page_state_snapshot(zone, NR_ZONE_ACTIVE_ANON);\n\n\treturn nr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_wmark_pages",
          "args": [
            "zone"
          ],
          "line": 3961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_zone_zonelist_nodemask",
          "args": [
            "zone",
            "z",
            "ac->zonelist",
            "ac->high_zoneidx",
            "ac->nodemask"
          ],
          "line": 3957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unreserve_highatomic_pageblock",
          "args": [
            "ac",
            "true"
          ],
          "line": 3948
        },
        "resolved": true,
        "details": {
          "function_name": "unreserve_highatomic_pageblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "2293-2365",
          "snippet": "static bool unreserve_highatomic_pageblock(const struct alloc_context *ac,\n\t\t\t\t\t\tbool force)\n{\n\tstruct zonelist *zonelist = ac->zonelist;\n\tunsigned long flags;\n\tstruct zoneref *z;\n\tstruct zone *zone;\n\tstruct page *page;\n\tint order;\n\tbool ret;\n\n\tfor_each_zone_zonelist_nodemask(zone, z, zonelist, ac->high_zoneidx,\n\t\t\t\t\t\t\t\tac->nodemask) {\n\t\t/*\n\t\t * Preserve at least one pageblock unless memory pressure\n\t\t * is really high.\n\t\t */\n\t\tif (!force && zone->nr_reserved_highatomic <=\n\t\t\t\t\tpageblock_nr_pages)\n\t\t\tcontinue;\n\n\t\tspin_lock_irqsave(&zone->lock, flags);\n\t\tfor (order = 0; order < MAX_ORDER; order++) {\n\t\t\tstruct free_area *area = &(zone->free_area[order]);\n\n\t\t\tpage = list_first_entry_or_null(\n\t\t\t\t\t&area->free_list[MIGRATE_HIGHATOMIC],\n\t\t\t\t\tstruct page, lru);\n\t\t\tif (!page)\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * In page freeing path, migratetype change is racy so\n\t\t\t * we can counter several free pages in a pageblock\n\t\t\t * in this loop althoug we changed the pageblock type\n\t\t\t * from highatomic to ac->migratetype. So we should\n\t\t\t * adjust the count once.\n\t\t\t */\n\t\t\tif (is_migrate_highatomic_page(page)) {\n\t\t\t\t/*\n\t\t\t\t * It should never happen but changes to\n\t\t\t\t * locking could inadvertently allow a per-cpu\n\t\t\t\t * drain to add pages to MIGRATE_HIGHATOMIC\n\t\t\t\t * while unreserving so be safe and watch for\n\t\t\t\t * underflows.\n\t\t\t\t */\n\t\t\t\tzone->nr_reserved_highatomic -= min(\n\t\t\t\t\t\tpageblock_nr_pages,\n\t\t\t\t\t\tzone->nr_reserved_highatomic);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Convert to ac->migratetype and avoid the normal\n\t\t\t * pageblock stealing heuristics. Minimally, the caller\n\t\t\t * is doing the work and needs the pages. More\n\t\t\t * importantly, if the block was always converted to\n\t\t\t * MIGRATE_UNMOVABLE or another type then the number\n\t\t\t * of pageblocks that cannot be completely freed\n\t\t\t * may increase.\n\t\t\t */\n\t\t\tset_pageblock_migratetype(page, ac->migratetype);\n\t\t\tret = move_freepages_block(zone, page, ac->migratetype,\n\t\t\t\t\t\t\t\t\tNULL);\n\t\t\tif (ret) {\n\t\t\t\tspin_unlock_irqrestore(&zone->lock, flags);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&zone->lock, flags);\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool unreserve_highatomic_pageblock(const struct alloc_context *ac,\n\t\t\t\t\t\tbool force)\n{\n\tstruct zonelist *zonelist = ac->zonelist;\n\tunsigned long flags;\n\tstruct zoneref *z;\n\tstruct zone *zone;\n\tstruct page *page;\n\tint order;\n\tbool ret;\n\n\tfor_each_zone_zonelist_nodemask(zone, z, zonelist, ac->high_zoneidx,\n\t\t\t\t\t\t\t\tac->nodemask) {\n\t\t/*\n\t\t * Preserve at least one pageblock unless memory pressure\n\t\t * is really high.\n\t\t */\n\t\tif (!force && zone->nr_reserved_highatomic <=\n\t\t\t\t\tpageblock_nr_pages)\n\t\t\tcontinue;\n\n\t\tspin_lock_irqsave(&zone->lock, flags);\n\t\tfor (order = 0; order < MAX_ORDER; order++) {\n\t\t\tstruct free_area *area = &(zone->free_area[order]);\n\n\t\t\tpage = list_first_entry_or_null(\n\t\t\t\t\t&area->free_list[MIGRATE_HIGHATOMIC],\n\t\t\t\t\tstruct page, lru);\n\t\t\tif (!page)\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * In page freeing path, migratetype change is racy so\n\t\t\t * we can counter several free pages in a pageblock\n\t\t\t * in this loop althoug we changed the pageblock type\n\t\t\t * from highatomic to ac->migratetype. So we should\n\t\t\t * adjust the count once.\n\t\t\t */\n\t\t\tif (is_migrate_highatomic_page(page)) {\n\t\t\t\t/*\n\t\t\t\t * It should never happen but changes to\n\t\t\t\t * locking could inadvertently allow a per-cpu\n\t\t\t\t * drain to add pages to MIGRATE_HIGHATOMIC\n\t\t\t\t * while unreserving so be safe and watch for\n\t\t\t\t * underflows.\n\t\t\t\t */\n\t\t\t\tzone->nr_reserved_highatomic -= min(\n\t\t\t\t\t\tpageblock_nr_pages,\n\t\t\t\t\t\tzone->nr_reserved_highatomic);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Convert to ac->migratetype and avoid the normal\n\t\t\t * pageblock stealing heuristics. Minimally, the caller\n\t\t\t * is doing the work and needs the pages. More\n\t\t\t * importantly, if the block was always converted to\n\t\t\t * MIGRATE_UNMOVABLE or another type then the number\n\t\t\t * of pageblocks that cannot be completely freed\n\t\t\t * may increase.\n\t\t\t */\n\t\t\tset_pageblock_migratetype(page, ac->migratetype);\n\t\t\tret = move_freepages_block(zone, page, ac->migratetype,\n\t\t\t\t\t\t\t\t\tNULL);\n\t\t\tif (ret) {\n\t\t\t\tspin_unlock_irqrestore(&zone->lock, flags);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&zone->lock, flags);\n\t}\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline bool\nshould_reclaim_retry(gfp_t gfp_mask, unsigned order,\n\t\t     struct alloc_context *ac, int alloc_flags,\n\t\t     bool did_some_progress, int *no_progress_loops)\n{\n\tstruct zone *zone;\n\tstruct zoneref *z;\n\tbool ret = false;\n\n\t/*\n\t * Costly allocations might have made a progress but this doesn't mean\n\t * their order will become available due to high fragmentation so\n\t * always increment the no progress counter for them\n\t */\n\tif (did_some_progress && order <= PAGE_ALLOC_COSTLY_ORDER)\n\t\t*no_progress_loops = 0;\n\telse\n\t\t(*no_progress_loops)++;\n\n\t/*\n\t * Make sure we converge to OOM if we cannot make any progress\n\t * several times in the row.\n\t */\n\tif (*no_progress_loops > MAX_RECLAIM_RETRIES) {\n\t\t/* Before OOM, exhaust highatomic_reserve */\n\t\treturn unreserve_highatomic_pageblock(ac, true);\n\t}\n\n\t/*\n\t * Keep reclaiming pages while there is a chance this will lead\n\t * somewhere.  If none of the target zones can satisfy our allocation\n\t * request even if all reclaimable pages are considered then we are\n\t * screwed and have to go OOM.\n\t */\n\tfor_each_zone_zonelist_nodemask(zone, z, ac->zonelist, ac->high_zoneidx,\n\t\t\t\t\tac->nodemask) {\n\t\tunsigned long available;\n\t\tunsigned long reclaimable;\n\t\tunsigned long min_wmark = min_wmark_pages(zone);\n\t\tbool wmark;\n\n\t\tavailable = reclaimable = zone_reclaimable_pages(zone);\n\t\tavailable += zone_page_state_snapshot(zone, NR_FREE_PAGES);\n\n\t\t/*\n\t\t * Would the allocation succeed if we reclaimed all\n\t\t * reclaimable pages?\n\t\t */\n\t\twmark = __zone_watermark_ok(zone, order, min_wmark,\n\t\t\t\tac_classzone_idx(ac), alloc_flags, available);\n\t\ttrace_reclaim_retry_zone(z, order, reclaimable,\n\t\t\t\tavailable, min_wmark, *no_progress_loops, wmark);\n\t\tif (wmark) {\n\t\t\t/*\n\t\t\t * If we didn't make any progress and have a lot of\n\t\t\t * dirty + writeback pages then we should wait for\n\t\t\t * an IO to complete to slow down the reclaim and\n\t\t\t * prevent from pre mature OOM\n\t\t\t */\n\t\t\tif (!did_some_progress) {\n\t\t\t\tunsigned long write_pending;\n\n\t\t\t\twrite_pending = zone_page_state_snapshot(zone,\n\t\t\t\t\t\t\tNR_ZONE_WRITE_PENDING);\n\n\t\t\t\tif (2 * write_pending > reclaimable) {\n\t\t\t\t\tcongestion_wait(BLK_RW_ASYNC, HZ/10);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tret = true;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\t/*\n\t * Memory allocation/reclaim might be called from a WQ context and the\n\t * current implementation of the WQ concurrency control doesn't\n\t * recognize that a particular WQ is congested if the worker thread is\n\t * looping without ever sleeping. Therefore we have to do a short sleep\n\t * here rather than calling cond_resched().\n\t */\n\tif (current->flags & PF_WQ_WORKER)\n\t\tschedule_timeout_uninterruptible(1);\n\telse\n\t\tcond_resched();\n\treturn ret;\n}"
  },
  {
    "function_name": "gfp_pfmemalloc_allowed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "3908-3911",
    "snippet": "bool gfp_pfmemalloc_allowed(gfp_t gfp_mask)\n{\n\treturn !!__gfp_pfmemalloc_flags(gfp_mask);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__gfp_pfmemalloc_flags",
          "args": [
            "gfp_mask"
          ],
          "line": 3910
        },
        "resolved": true,
        "details": {
          "function_name": "__gfp_pfmemalloc_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3890-3906",
          "snippet": "static inline int __gfp_pfmemalloc_flags(gfp_t gfp_mask)\n{\n\tif (unlikely(gfp_mask & __GFP_NOMEMALLOC))\n\t\treturn 0;\n\tif (gfp_mask & __GFP_MEMALLOC)\n\t\treturn ALLOC_NO_WATERMARKS;\n\tif (in_serving_softirq() && (current->flags & PF_MEMALLOC))\n\t\treturn ALLOC_NO_WATERMARKS;\n\tif (!in_interrupt()) {\n\t\tif (current->flags & PF_MEMALLOC)\n\t\t\treturn ALLOC_NO_WATERMARKS;\n\t\telse if (oom_reserves_allowed(current))\n\t\t\treturn ALLOC_OOM;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic inline int __gfp_pfmemalloc_flags(gfp_t gfp_mask)\n{\n\tif (unlikely(gfp_mask & __GFP_NOMEMALLOC))\n\t\treturn 0;\n\tif (gfp_mask & __GFP_MEMALLOC)\n\t\treturn ALLOC_NO_WATERMARKS;\n\tif (in_serving_softirq() && (current->flags & PF_MEMALLOC))\n\t\treturn ALLOC_NO_WATERMARKS;\n\tif (!in_interrupt()) {\n\t\tif (current->flags & PF_MEMALLOC)\n\t\t\treturn ALLOC_NO_WATERMARKS;\n\t\telse if (oom_reserves_allowed(current))\n\t\t\treturn ALLOC_OOM;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nbool gfp_pfmemalloc_allowed(gfp_t gfp_mask)\n{\n\treturn !!__gfp_pfmemalloc_flags(gfp_mask);\n}"
  },
  {
    "function_name": "__gfp_pfmemalloc_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "3890-3906",
    "snippet": "static inline int __gfp_pfmemalloc_flags(gfp_t gfp_mask)\n{\n\tif (unlikely(gfp_mask & __GFP_NOMEMALLOC))\n\t\treturn 0;\n\tif (gfp_mask & __GFP_MEMALLOC)\n\t\treturn ALLOC_NO_WATERMARKS;\n\tif (in_serving_softirq() && (current->flags & PF_MEMALLOC))\n\t\treturn ALLOC_NO_WATERMARKS;\n\tif (!in_interrupt()) {\n\t\tif (current->flags & PF_MEMALLOC)\n\t\t\treturn ALLOC_NO_WATERMARKS;\n\t\telse if (oom_reserves_allowed(current))\n\t\t\treturn ALLOC_OOM;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "oom_reserves_allowed",
          "args": [
            "current"
          ],
          "line": 3901
        },
        "resolved": true,
        "details": {
          "function_name": "oom_reserves_allowed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3871-3884",
          "snippet": "static bool oom_reserves_allowed(struct task_struct *tsk)\n{\n\tif (!tsk_is_oom_victim(tsk))\n\t\treturn false;\n\n\t/*\n\t * !MMU doesn't have oom reaper so give access to memory reserves\n\t * only to the thread with TIF_MEMDIE set\n\t */\n\tif (!IS_ENABLED(CONFIG_MMU) && !test_thread_flag(TIF_MEMDIE))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool oom_reserves_allowed(struct task_struct *tsk)\n{\n\tif (!tsk_is_oom_victim(tsk))\n\t\treturn false;\n\n\t/*\n\t * !MMU doesn't have oom reaper so give access to memory reserves\n\t * only to the thread with TIF_MEMDIE set\n\t */\n\tif (!IS_ENABLED(CONFIG_MMU) && !test_thread_flag(TIF_MEMDIE))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "in_interrupt",
          "args": [],
          "line": 3898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_serving_softirq",
          "args": [],
          "line": 3896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "gfp_mask & __GFP_NOMEMALLOC"
          ],
          "line": 3892
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic inline int __gfp_pfmemalloc_flags(gfp_t gfp_mask)\n{\n\tif (unlikely(gfp_mask & __GFP_NOMEMALLOC))\n\t\treturn 0;\n\tif (gfp_mask & __GFP_MEMALLOC)\n\t\treturn ALLOC_NO_WATERMARKS;\n\tif (in_serving_softirq() && (current->flags & PF_MEMALLOC))\n\t\treturn ALLOC_NO_WATERMARKS;\n\tif (!in_interrupt()) {\n\t\tif (current->flags & PF_MEMALLOC)\n\t\t\treturn ALLOC_NO_WATERMARKS;\n\t\telse if (oom_reserves_allowed(current))\n\t\t\treturn ALLOC_OOM;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "oom_reserves_allowed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "3871-3884",
    "snippet": "static bool oom_reserves_allowed(struct task_struct *tsk)\n{\n\tif (!tsk_is_oom_victim(tsk))\n\t\treturn false;\n\n\t/*\n\t * !MMU doesn't have oom reaper so give access to memory reserves\n\t * only to the thread with TIF_MEMDIE set\n\t */\n\tif (!IS_ENABLED(CONFIG_MMU) && !test_thread_flag(TIF_MEMDIE))\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_thread_flag",
          "args": [
            "TIF_MEMDIE"
          ],
          "line": 3880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_MMU"
          ],
          "line": 3880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tsk_is_oom_victim",
          "args": [
            "tsk"
          ],
          "line": 3873
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool oom_reserves_allowed(struct task_struct *tsk)\n{\n\tif (!tsk_is_oom_victim(tsk))\n\t\treturn false;\n\n\t/*\n\t * !MMU doesn't have oom reaper so give access to memory reserves\n\t * only to the thread with TIF_MEMDIE set\n\t */\n\tif (!IS_ENABLED(CONFIG_MMU) && !test_thread_flag(TIF_MEMDIE))\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "gfp_to_alloc_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "3833-3869",
    "snippet": "static inline unsigned int\ngfp_to_alloc_flags(gfp_t gfp_mask)\n{\n\tunsigned int alloc_flags = ALLOC_WMARK_MIN | ALLOC_CPUSET;\n\n\t/* __GFP_HIGH is assumed to be the same as ALLOC_HIGH to save a branch. */\n\tBUILD_BUG_ON(__GFP_HIGH != (__force gfp_t) ALLOC_HIGH);\n\n\t/*\n\t * The caller may dip into page reserves a bit more if the caller\n\t * cannot run direct reclaim, or if the caller has realtime scheduling\n\t * policy or is asking for __GFP_HIGH memory.  GFP_ATOMIC requests will\n\t * set both ALLOC_HARDER (__GFP_ATOMIC) and ALLOC_HIGH (__GFP_HIGH).\n\t */\n\talloc_flags |= (__force int) (gfp_mask & __GFP_HIGH);\n\n\tif (gfp_mask & __GFP_ATOMIC) {\n\t\t/*\n\t\t * Not worth trying to allocate harder for __GFP_NOMEMALLOC even\n\t\t * if it can't schedule.\n\t\t */\n\t\tif (!(gfp_mask & __GFP_NOMEMALLOC))\n\t\t\talloc_flags |= ALLOC_HARDER;\n\t\t/*\n\t\t * Ignore cpuset mems for GFP_ATOMIC rather than fail, see the\n\t\t * comment for __cpuset_node_allowed().\n\t\t */\n\t\talloc_flags &= ~ALLOC_CPUSET;\n\t} else if (unlikely(rt_task(current)) && !in_interrupt())\n\t\talloc_flags |= ALLOC_HARDER;\n\n#ifdef CONFIG_CMA\n\tif (gfpflags_to_migratetype(gfp_mask) == MIGRATE_MOVABLE)\n\t\talloc_flags |= ALLOC_CMA;\n#endif\n\treturn alloc_flags;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfpflags_to_migratetype",
          "args": [
            "gfp_mask"
          ],
          "line": 3865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_interrupt",
          "args": [],
          "line": 3861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rt_task(current)"
          ],
          "line": 3861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rt_task",
          "args": [
            "current"
          ],
          "line": 3861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "gfp_mask & __GFP_HIGH"
          ],
          "line": 3847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "__GFP_HIGH != (__force gfp_t) ALLOC_HIGH"
          ],
          "line": 3839
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic inline unsigned int\ngfp_to_alloc_flags(gfp_t gfp_mask)\n{\n\tunsigned int alloc_flags = ALLOC_WMARK_MIN | ALLOC_CPUSET;\n\n\t/* __GFP_HIGH is assumed to be the same as ALLOC_HIGH to save a branch. */\n\tBUILD_BUG_ON(__GFP_HIGH != (__force gfp_t) ALLOC_HIGH);\n\n\t/*\n\t * The caller may dip into page reserves a bit more if the caller\n\t * cannot run direct reclaim, or if the caller has realtime scheduling\n\t * policy or is asking for __GFP_HIGH memory.  GFP_ATOMIC requests will\n\t * set both ALLOC_HARDER (__GFP_ATOMIC) and ALLOC_HIGH (__GFP_HIGH).\n\t */\n\talloc_flags |= (__force int) (gfp_mask & __GFP_HIGH);\n\n\tif (gfp_mask & __GFP_ATOMIC) {\n\t\t/*\n\t\t * Not worth trying to allocate harder for __GFP_NOMEMALLOC even\n\t\t * if it can't schedule.\n\t\t */\n\t\tif (!(gfp_mask & __GFP_NOMEMALLOC))\n\t\t\talloc_flags |= ALLOC_HARDER;\n\t\t/*\n\t\t * Ignore cpuset mems for GFP_ATOMIC rather than fail, see the\n\t\t * comment for __cpuset_node_allowed().\n\t\t */\n\t\talloc_flags &= ~ALLOC_CPUSET;\n\t} else if (unlikely(rt_task(current)) && !in_interrupt())\n\t\talloc_flags |= ALLOC_HARDER;\n\n#ifdef CONFIG_CMA\n\tif (gfpflags_to_migratetype(gfp_mask) == MIGRATE_MOVABLE)\n\t\talloc_flags |= ALLOC_CMA;\n#endif\n\treturn alloc_flags;\n}"
  },
  {
    "function_name": "wake_all_kswapds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "3817-3831",
    "snippet": "static void wake_all_kswapds(unsigned int order, gfp_t gfp_mask,\n\t\t\t     const struct alloc_context *ac)\n{\n\tstruct zoneref *z;\n\tstruct zone *zone;\n\tpg_data_t *last_pgdat = NULL;\n\tenum zone_type high_zoneidx = ac->high_zoneidx;\n\n\tfor_each_zone_zonelist_nodemask(zone, z, ac->zonelist, high_zoneidx,\n\t\t\t\t\tac->nodemask) {\n\t\tif (last_pgdat != zone->zone_pgdat)\n\t\t\twakeup_kswapd(zone, gfp_mask, order, high_zoneidx);\n\t\tlast_pgdat = zone->zone_pgdat;\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);",
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wakeup_kswapd",
          "args": [
            "zone",
            "gfp_mask",
            "order",
            "high_zoneidx"
          ],
          "line": 3828
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_kswapd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "3838-3873",
          "snippet": "void wakeup_kswapd(struct zone *zone, gfp_t gfp_flags, int order,\n\t\t   enum zone_type classzone_idx)\n{\n\tpg_data_t *pgdat;\n\n\tif (!managed_zone(zone))\n\t\treturn;\n\n\tif (!cpuset_zone_allowed(zone, gfp_flags))\n\t\treturn;\n\tpgdat = zone->zone_pgdat;\n\tpgdat->kswapd_classzone_idx = kswapd_classzone_idx(pgdat,\n\t\t\t\t\t\t\t   classzone_idx);\n\tpgdat->kswapd_order = max(pgdat->kswapd_order, order);\n\tif (!waitqueue_active(&pgdat->kswapd_wait))\n\t\treturn;\n\n\t/* Hopeless node, leave it to direct reclaim if possible */\n\tif (pgdat->kswapd_failures >= MAX_RECLAIM_RETRIES ||\n\t    pgdat_balanced(pgdat, order, classzone_idx)) {\n\t\t/*\n\t\t * There may be plenty of free memory available, but it's too\n\t\t * fragmented for high-order allocations.  Wake up kcompactd\n\t\t * and rely on compaction_suitable() to determine if it's\n\t\t * needed.  If it fails, it will defer subsequent attempts to\n\t\t * ratelimit its work.\n\t\t */\n\t\tif (!(gfp_flags & __GFP_DIRECT_RECLAIM))\n\t\t\twakeup_kcompactd(pgdat, order, classzone_idx);\n\t\treturn;\n\t}\n\n\ttrace_mm_vmscan_wakeup_kswapd(pgdat->node_id, classzone_idx, order,\n\t\t\t\t      gfp_flags);\n\twake_up_interruptible(&pgdat->kswapd_wait);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nvoid wakeup_kswapd(struct zone *zone, gfp_t gfp_flags, int order,\n\t\t   enum zone_type classzone_idx)\n{\n\tpg_data_t *pgdat;\n\n\tif (!managed_zone(zone))\n\t\treturn;\n\n\tif (!cpuset_zone_allowed(zone, gfp_flags))\n\t\treturn;\n\tpgdat = zone->zone_pgdat;\n\tpgdat->kswapd_classzone_idx = kswapd_classzone_idx(pgdat,\n\t\t\t\t\t\t\t   classzone_idx);\n\tpgdat->kswapd_order = max(pgdat->kswapd_order, order);\n\tif (!waitqueue_active(&pgdat->kswapd_wait))\n\t\treturn;\n\n\t/* Hopeless node, leave it to direct reclaim if possible */\n\tif (pgdat->kswapd_failures >= MAX_RECLAIM_RETRIES ||\n\t    pgdat_balanced(pgdat, order, classzone_idx)) {\n\t\t/*\n\t\t * There may be plenty of free memory available, but it's too\n\t\t * fragmented for high-order allocations.  Wake up kcompactd\n\t\t * and rely on compaction_suitable() to determine if it's\n\t\t * needed.  If it fails, it will defer subsequent attempts to\n\t\t * ratelimit its work.\n\t\t */\n\t\tif (!(gfp_flags & __GFP_DIRECT_RECLAIM))\n\t\t\twakeup_kcompactd(pgdat, order, classzone_idx);\n\t\treturn;\n\t}\n\n\ttrace_mm_vmscan_wakeup_kswapd(pgdat->node_id, classzone_idx, order,\n\t\t\t\t      gfp_flags);\n\twake_up_interruptible(&pgdat->kswapd_wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_zone_zonelist_nodemask",
          "args": [
            "zone",
            "z",
            "ac->zonelist",
            "high_zoneidx",
            "ac->nodemask"
          ],
          "line": 3825
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic void wake_all_kswapds(unsigned int order, gfp_t gfp_mask,\n\t\t\t     const struct alloc_context *ac)\n{\n\tstruct zoneref *z;\n\tstruct zone *zone;\n\tpg_data_t *last_pgdat = NULL;\n\tenum zone_type high_zoneidx = ac->high_zoneidx;\n\n\tfor_each_zone_zonelist_nodemask(zone, z, ac->zonelist, high_zoneidx,\n\t\t\t\t\tac->nodemask) {\n\t\tif (last_pgdat != zone->zone_pgdat)\n\t\t\twakeup_kswapd(zone, gfp_mask, order, high_zoneidx);\n\t\tlast_pgdat = zone->zone_pgdat;\n\t}\n}"
  },
  {
    "function_name": "__alloc_pages_direct_reclaim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "3787-3815",
    "snippet": "static inline struct page *\n__alloc_pages_direct_reclaim(gfp_t gfp_mask, unsigned int order,\n\t\tunsigned int alloc_flags, const struct alloc_context *ac,\n\t\tunsigned long *did_some_progress)\n{\n\tstruct page *page = NULL;\n\tbool drained = false;\n\n\t*did_some_progress = __perform_reclaim(gfp_mask, order, ac);\n\tif (unlikely(!(*did_some_progress)))\n\t\treturn NULL;\n\nretry:\n\tpage = get_page_from_freelist(gfp_mask, order, alloc_flags, ac);\n\n\t/*\n\t * If an allocation failed after direct reclaim, it could be because\n\t * pages are pinned on the per-cpu lists or in high alloc reserves.\n\t * Shrink them them and try again\n\t */\n\tif (!page && !drained) {\n\t\tunreserve_highatomic_pageblock(ac, false);\n\t\tdrain_all_pages(NULL);\n\t\tdrained = true;\n\t\tgoto retry;\n\t}\n\n\treturn page;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);",
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "drain_all_pages",
          "args": [
            "NULL"
          ],
          "line": 3809
        },
        "resolved": true,
        "details": {
          "function_name": "drain_all_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "2614-2682",
          "snippet": "void drain_all_pages(struct zone *zone)\n{\n\tint cpu;\n\n\t/*\n\t * Allocate in the BSS so we wont require allocation in\n\t * direct reclaim path for CONFIG_CPUMASK_OFFSTACK=y\n\t */\n\tstatic cpumask_t cpus_with_pcps;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON_ONCE(!mm_percpu_wq))\n\t\treturn;\n\n\t/*\n\t * Do not drain if one is already in progress unless it's specific to\n\t * a zone. Such callers are primarily CMA and memory hotplug and need\n\t * the drain to be complete when the call returns.\n\t */\n\tif (unlikely(!mutex_trylock(&pcpu_drain_mutex))) {\n\t\tif (!zone)\n\t\t\treturn;\n\t\tmutex_lock(&pcpu_drain_mutex);\n\t}\n\n\t/*\n\t * We don't care about racing with CPU hotplug event\n\t * as offline notification will cause the notified\n\t * cpu to drain that CPU pcps and on_each_cpu_mask\n\t * disables preemption as part of its processing\n\t */\n\tfor_each_online_cpu(cpu) {\n\t\tstruct per_cpu_pageset *pcp;\n\t\tstruct zone *z;\n\t\tbool has_pcps = false;\n\n\t\tif (zone) {\n\t\t\tpcp = per_cpu_ptr(zone->pageset, cpu);\n\t\t\tif (pcp->pcp.count)\n\t\t\t\thas_pcps = true;\n\t\t} else {\n\t\t\tfor_each_populated_zone(z) {\n\t\t\t\tpcp = per_cpu_ptr(z->pageset, cpu);\n\t\t\t\tif (pcp->pcp.count) {\n\t\t\t\t\thas_pcps = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (has_pcps)\n\t\t\tcpumask_set_cpu(cpu, &cpus_with_pcps);\n\t\telse\n\t\t\tcpumask_clear_cpu(cpu, &cpus_with_pcps);\n\t}\n\n\tfor_each_cpu(cpu, &cpus_with_pcps) {\n\t\tstruct work_struct *work = per_cpu_ptr(&pcpu_drain, cpu);\n\t\tINIT_WORK(work, drain_local_pages_wq);\n\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t}\n\tfor_each_cpu(cpu, &cpus_with_pcps)\n\t\tflush_work(per_cpu_ptr(&pcpu_drain, cpu));\n\n\tmutex_unlock(&pcpu_drain_mutex);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid drain_all_pages(struct zone *zone)\n{\n\tint cpu;\n\n\t/*\n\t * Allocate in the BSS so we wont require allocation in\n\t * direct reclaim path for CONFIG_CPUMASK_OFFSTACK=y\n\t */\n\tstatic cpumask_t cpus_with_pcps;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON_ONCE(!mm_percpu_wq))\n\t\treturn;\n\n\t/*\n\t * Do not drain if one is already in progress unless it's specific to\n\t * a zone. Such callers are primarily CMA and memory hotplug and need\n\t * the drain to be complete when the call returns.\n\t */\n\tif (unlikely(!mutex_trylock(&pcpu_drain_mutex))) {\n\t\tif (!zone)\n\t\t\treturn;\n\t\tmutex_lock(&pcpu_drain_mutex);\n\t}\n\n\t/*\n\t * We don't care about racing with CPU hotplug event\n\t * as offline notification will cause the notified\n\t * cpu to drain that CPU pcps and on_each_cpu_mask\n\t * disables preemption as part of its processing\n\t */\n\tfor_each_online_cpu(cpu) {\n\t\tstruct per_cpu_pageset *pcp;\n\t\tstruct zone *z;\n\t\tbool has_pcps = false;\n\n\t\tif (zone) {\n\t\t\tpcp = per_cpu_ptr(zone->pageset, cpu);\n\t\t\tif (pcp->pcp.count)\n\t\t\t\thas_pcps = true;\n\t\t} else {\n\t\t\tfor_each_populated_zone(z) {\n\t\t\t\tpcp = per_cpu_ptr(z->pageset, cpu);\n\t\t\t\tif (pcp->pcp.count) {\n\t\t\t\t\thas_pcps = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (has_pcps)\n\t\t\tcpumask_set_cpu(cpu, &cpus_with_pcps);\n\t\telse\n\t\t\tcpumask_clear_cpu(cpu, &cpus_with_pcps);\n\t}\n\n\tfor_each_cpu(cpu, &cpus_with_pcps) {\n\t\tstruct work_struct *work = per_cpu_ptr(&pcpu_drain, cpu);\n\t\tINIT_WORK(work, drain_local_pages_wq);\n\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t}\n\tfor_each_cpu(cpu, &cpus_with_pcps)\n\t\tflush_work(per_cpu_ptr(&pcpu_drain, cpu));\n\n\tmutex_unlock(&pcpu_drain_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unreserve_highatomic_pageblock",
          "args": [
            "ac",
            "false"
          ],
          "line": 3808
        },
        "resolved": true,
        "details": {
          "function_name": "unreserve_highatomic_pageblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "2293-2365",
          "snippet": "static bool unreserve_highatomic_pageblock(const struct alloc_context *ac,\n\t\t\t\t\t\tbool force)\n{\n\tstruct zonelist *zonelist = ac->zonelist;\n\tunsigned long flags;\n\tstruct zoneref *z;\n\tstruct zone *zone;\n\tstruct page *page;\n\tint order;\n\tbool ret;\n\n\tfor_each_zone_zonelist_nodemask(zone, z, zonelist, ac->high_zoneidx,\n\t\t\t\t\t\t\t\tac->nodemask) {\n\t\t/*\n\t\t * Preserve at least one pageblock unless memory pressure\n\t\t * is really high.\n\t\t */\n\t\tif (!force && zone->nr_reserved_highatomic <=\n\t\t\t\t\tpageblock_nr_pages)\n\t\t\tcontinue;\n\n\t\tspin_lock_irqsave(&zone->lock, flags);\n\t\tfor (order = 0; order < MAX_ORDER; order++) {\n\t\t\tstruct free_area *area = &(zone->free_area[order]);\n\n\t\t\tpage = list_first_entry_or_null(\n\t\t\t\t\t&area->free_list[MIGRATE_HIGHATOMIC],\n\t\t\t\t\tstruct page, lru);\n\t\t\tif (!page)\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * In page freeing path, migratetype change is racy so\n\t\t\t * we can counter several free pages in a pageblock\n\t\t\t * in this loop althoug we changed the pageblock type\n\t\t\t * from highatomic to ac->migratetype. So we should\n\t\t\t * adjust the count once.\n\t\t\t */\n\t\t\tif (is_migrate_highatomic_page(page)) {\n\t\t\t\t/*\n\t\t\t\t * It should never happen but changes to\n\t\t\t\t * locking could inadvertently allow a per-cpu\n\t\t\t\t * drain to add pages to MIGRATE_HIGHATOMIC\n\t\t\t\t * while unreserving so be safe and watch for\n\t\t\t\t * underflows.\n\t\t\t\t */\n\t\t\t\tzone->nr_reserved_highatomic -= min(\n\t\t\t\t\t\tpageblock_nr_pages,\n\t\t\t\t\t\tzone->nr_reserved_highatomic);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Convert to ac->migratetype and avoid the normal\n\t\t\t * pageblock stealing heuristics. Minimally, the caller\n\t\t\t * is doing the work and needs the pages. More\n\t\t\t * importantly, if the block was always converted to\n\t\t\t * MIGRATE_UNMOVABLE or another type then the number\n\t\t\t * of pageblocks that cannot be completely freed\n\t\t\t * may increase.\n\t\t\t */\n\t\t\tset_pageblock_migratetype(page, ac->migratetype);\n\t\t\tret = move_freepages_block(zone, page, ac->migratetype,\n\t\t\t\t\t\t\t\t\tNULL);\n\t\t\tif (ret) {\n\t\t\t\tspin_unlock_irqrestore(&zone->lock, flags);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&zone->lock, flags);\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool unreserve_highatomic_pageblock(const struct alloc_context *ac,\n\t\t\t\t\t\tbool force)\n{\n\tstruct zonelist *zonelist = ac->zonelist;\n\tunsigned long flags;\n\tstruct zoneref *z;\n\tstruct zone *zone;\n\tstruct page *page;\n\tint order;\n\tbool ret;\n\n\tfor_each_zone_zonelist_nodemask(zone, z, zonelist, ac->high_zoneidx,\n\t\t\t\t\t\t\t\tac->nodemask) {\n\t\t/*\n\t\t * Preserve at least one pageblock unless memory pressure\n\t\t * is really high.\n\t\t */\n\t\tif (!force && zone->nr_reserved_highatomic <=\n\t\t\t\t\tpageblock_nr_pages)\n\t\t\tcontinue;\n\n\t\tspin_lock_irqsave(&zone->lock, flags);\n\t\tfor (order = 0; order < MAX_ORDER; order++) {\n\t\t\tstruct free_area *area = &(zone->free_area[order]);\n\n\t\t\tpage = list_first_entry_or_null(\n\t\t\t\t\t&area->free_list[MIGRATE_HIGHATOMIC],\n\t\t\t\t\tstruct page, lru);\n\t\t\tif (!page)\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * In page freeing path, migratetype change is racy so\n\t\t\t * we can counter several free pages in a pageblock\n\t\t\t * in this loop althoug we changed the pageblock type\n\t\t\t * from highatomic to ac->migratetype. So we should\n\t\t\t * adjust the count once.\n\t\t\t */\n\t\t\tif (is_migrate_highatomic_page(page)) {\n\t\t\t\t/*\n\t\t\t\t * It should never happen but changes to\n\t\t\t\t * locking could inadvertently allow a per-cpu\n\t\t\t\t * drain to add pages to MIGRATE_HIGHATOMIC\n\t\t\t\t * while unreserving so be safe and watch for\n\t\t\t\t * underflows.\n\t\t\t\t */\n\t\t\t\tzone->nr_reserved_highatomic -= min(\n\t\t\t\t\t\tpageblock_nr_pages,\n\t\t\t\t\t\tzone->nr_reserved_highatomic);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Convert to ac->migratetype and avoid the normal\n\t\t\t * pageblock stealing heuristics. Minimally, the caller\n\t\t\t * is doing the work and needs the pages. More\n\t\t\t * importantly, if the block was always converted to\n\t\t\t * MIGRATE_UNMOVABLE or another type then the number\n\t\t\t * of pageblocks that cannot be completely freed\n\t\t\t * may increase.\n\t\t\t */\n\t\t\tset_pageblock_migratetype(page, ac->migratetype);\n\t\t\tret = move_freepages_block(zone, page, ac->migratetype,\n\t\t\t\t\t\t\t\t\tNULL);\n\t\t\tif (ret) {\n\t\t\t\tspin_unlock_irqrestore(&zone->lock, flags);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&zone->lock, flags);\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_page_from_freelist",
          "args": [
            "gfp_mask",
            "order",
            "alloc_flags",
            "ac"
          ],
          "line": 3800
        },
        "resolved": true,
        "details": {
          "function_name": "get_page_from_freelist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3260-3378",
          "snippet": "static struct page *\nget_page_from_freelist(gfp_t gfp_mask, unsigned int order, int alloc_flags,\n\t\t\t\t\t\tconst struct alloc_context *ac)\n{\n\tstruct zoneref *z = ac->preferred_zoneref;\n\tstruct zone *zone;\n\tstruct pglist_data *last_pgdat_dirty_limit = NULL;\n\n\t/*\n\t * Scan zonelist, looking for a zone with enough free.\n\t * See also __cpuset_node_allowed() comment in kernel/cpuset.c.\n\t */\n\tfor_next_zone_zonelist_nodemask(zone, z, ac->zonelist, ac->high_zoneidx,\n\t\t\t\t\t\t\t\tac->nodemask) {\n\t\tstruct page *page;\n\t\tunsigned long mark;\n\n\t\tif (cpusets_enabled() &&\n\t\t\t(alloc_flags & ALLOC_CPUSET) &&\n\t\t\t!__cpuset_zone_allowed(zone, gfp_mask))\n\t\t\t\tcontinue;\n\t\t/*\n\t\t * When allocating a page cache page for writing, we\n\t\t * want to get it from a node that is within its dirty\n\t\t * limit, such that no single node holds more than its\n\t\t * proportional share of globally allowed dirty pages.\n\t\t * The dirty limits take into account the node's\n\t\t * lowmem reserves and high watermark so that kswapd\n\t\t * should be able to balance it without having to\n\t\t * write pages from its LRU list.\n\t\t *\n\t\t * XXX: For now, allow allocations to potentially\n\t\t * exceed the per-node dirty limit in the slowpath\n\t\t * (spread_dirty_pages unset) before going into reclaim,\n\t\t * which is important when on a NUMA setup the allowed\n\t\t * nodes are together not big enough to reach the\n\t\t * global limit.  The proper fix for these situations\n\t\t * will require awareness of nodes in the\n\t\t * dirty-throttling and the flusher threads.\n\t\t */\n\t\tif (ac->spread_dirty_pages) {\n\t\t\tif (last_pgdat_dirty_limit == zone->zone_pgdat)\n\t\t\t\tcontinue;\n\n\t\t\tif (!node_dirty_ok(zone->zone_pgdat)) {\n\t\t\t\tlast_pgdat_dirty_limit = zone->zone_pgdat;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tmark = zone->watermark[alloc_flags & ALLOC_WMARK_MASK];\n\t\tif (!zone_watermark_fast(zone, order, mark,\n\t\t\t\t       ac_classzone_idx(ac), alloc_flags)) {\n\t\t\tint ret;\n\n#ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT\n\t\t\t/*\n\t\t\t * Watermark failed for this zone, but see if we can\n\t\t\t * grow this zone if it contains deferred pages.\n\t\t\t */\n\t\t\tif (static_branch_unlikely(&deferred_pages)) {\n\t\t\t\tif (_deferred_grow_zone(zone, order))\n\t\t\t\t\tgoto try_this_zone;\n\t\t\t}\n#endif\n\t\t\t/* Checked here to keep the fast path fast */\n\t\t\tBUILD_BUG_ON(ALLOC_NO_WATERMARKS < NR_WMARK);\n\t\t\tif (alloc_flags & ALLOC_NO_WATERMARKS)\n\t\t\t\tgoto try_this_zone;\n\n\t\t\tif (node_reclaim_mode == 0 ||\n\t\t\t    !zone_allows_reclaim(ac->preferred_zoneref->zone, zone))\n\t\t\t\tcontinue;\n\n\t\t\tret = node_reclaim(zone->zone_pgdat, gfp_mask, order);\n\t\t\tswitch (ret) {\n\t\t\tcase NODE_RECLAIM_NOSCAN:\n\t\t\t\t/* did not scan */\n\t\t\t\tcontinue;\n\t\t\tcase NODE_RECLAIM_FULL:\n\t\t\t\t/* scanned but unreclaimable */\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\t/* did we reclaim enough */\n\t\t\t\tif (zone_watermark_ok(zone, order, mark,\n\t\t\t\t\t\tac_classzone_idx(ac), alloc_flags))\n\t\t\t\t\tgoto try_this_zone;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\ntry_this_zone:\n\t\tpage = rmqueue(ac->preferred_zoneref->zone, zone, order,\n\t\t\t\tgfp_mask, alloc_flags, ac->migratetype);\n\t\tif (page) {\n\t\t\tprep_new_page(page, order, gfp_mask, alloc_flags);\n\n\t\t\t/*\n\t\t\t * If this is a high-order atomic allocation then check\n\t\t\t * if the pageblock should be reserved for the future\n\t\t\t */\n\t\t\tif (unlikely(order && (alloc_flags & ALLOC_HARDER)))\n\t\t\t\treserve_highatomic_pageblock(page, zone, order);\n\n\t\t\treturn page;\n\t\t} else {\n#ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT\n\t\t\t/* Try again if zone has deferred pages */\n\t\t\tif (static_branch_unlikely(&deferred_pages)) {\n\t\t\t\tif (_deferred_grow_zone(zone, order))\n\t\t\t\t\tgoto try_this_zone;\n\t\t\t}\n#endif\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic struct page *\nget_page_from_freelist(gfp_t gfp_mask, unsigned int order, int alloc_flags,\n\t\t\t\t\t\tconst struct alloc_context *ac)\n{\n\tstruct zoneref *z = ac->preferred_zoneref;\n\tstruct zone *zone;\n\tstruct pglist_data *last_pgdat_dirty_limit = NULL;\n\n\t/*\n\t * Scan zonelist, looking for a zone with enough free.\n\t * See also __cpuset_node_allowed() comment in kernel/cpuset.c.\n\t */\n\tfor_next_zone_zonelist_nodemask(zone, z, ac->zonelist, ac->high_zoneidx,\n\t\t\t\t\t\t\t\tac->nodemask) {\n\t\tstruct page *page;\n\t\tunsigned long mark;\n\n\t\tif (cpusets_enabled() &&\n\t\t\t(alloc_flags & ALLOC_CPUSET) &&\n\t\t\t!__cpuset_zone_allowed(zone, gfp_mask))\n\t\t\t\tcontinue;\n\t\t/*\n\t\t * When allocating a page cache page for writing, we\n\t\t * want to get it from a node that is within its dirty\n\t\t * limit, such that no single node holds more than its\n\t\t * proportional share of globally allowed dirty pages.\n\t\t * The dirty limits take into account the node's\n\t\t * lowmem reserves and high watermark so that kswapd\n\t\t * should be able to balance it without having to\n\t\t * write pages from its LRU list.\n\t\t *\n\t\t * XXX: For now, allow allocations to potentially\n\t\t * exceed the per-node dirty limit in the slowpath\n\t\t * (spread_dirty_pages unset) before going into reclaim,\n\t\t * which is important when on a NUMA setup the allowed\n\t\t * nodes are together not big enough to reach the\n\t\t * global limit.  The proper fix for these situations\n\t\t * will require awareness of nodes in the\n\t\t * dirty-throttling and the flusher threads.\n\t\t */\n\t\tif (ac->spread_dirty_pages) {\n\t\t\tif (last_pgdat_dirty_limit == zone->zone_pgdat)\n\t\t\t\tcontinue;\n\n\t\t\tif (!node_dirty_ok(zone->zone_pgdat)) {\n\t\t\t\tlast_pgdat_dirty_limit = zone->zone_pgdat;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tmark = zone->watermark[alloc_flags & ALLOC_WMARK_MASK];\n\t\tif (!zone_watermark_fast(zone, order, mark,\n\t\t\t\t       ac_classzone_idx(ac), alloc_flags)) {\n\t\t\tint ret;\n\n#ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT\n\t\t\t/*\n\t\t\t * Watermark failed for this zone, but see if we can\n\t\t\t * grow this zone if it contains deferred pages.\n\t\t\t */\n\t\t\tif (static_branch_unlikely(&deferred_pages)) {\n\t\t\t\tif (_deferred_grow_zone(zone, order))\n\t\t\t\t\tgoto try_this_zone;\n\t\t\t}\n#endif\n\t\t\t/* Checked here to keep the fast path fast */\n\t\t\tBUILD_BUG_ON(ALLOC_NO_WATERMARKS < NR_WMARK);\n\t\t\tif (alloc_flags & ALLOC_NO_WATERMARKS)\n\t\t\t\tgoto try_this_zone;\n\n\t\t\tif (node_reclaim_mode == 0 ||\n\t\t\t    !zone_allows_reclaim(ac->preferred_zoneref->zone, zone))\n\t\t\t\tcontinue;\n\n\t\t\tret = node_reclaim(zone->zone_pgdat, gfp_mask, order);\n\t\t\tswitch (ret) {\n\t\t\tcase NODE_RECLAIM_NOSCAN:\n\t\t\t\t/* did not scan */\n\t\t\t\tcontinue;\n\t\t\tcase NODE_RECLAIM_FULL:\n\t\t\t\t/* scanned but unreclaimable */\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\t/* did we reclaim enough */\n\t\t\t\tif (zone_watermark_ok(zone, order, mark,\n\t\t\t\t\t\tac_classzone_idx(ac), alloc_flags))\n\t\t\t\t\tgoto try_this_zone;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\ntry_this_zone:\n\t\tpage = rmqueue(ac->preferred_zoneref->zone, zone, order,\n\t\t\t\tgfp_mask, alloc_flags, ac->migratetype);\n\t\tif (page) {\n\t\t\tprep_new_page(page, order, gfp_mask, alloc_flags);\n\n\t\t\t/*\n\t\t\t * If this is a high-order atomic allocation then check\n\t\t\t * if the pageblock should be reserved for the future\n\t\t\t */\n\t\t\tif (unlikely(order && (alloc_flags & ALLOC_HARDER)))\n\t\t\t\treserve_highatomic_pageblock(page, zone, order);\n\n\t\t\treturn page;\n\t\t} else {\n#ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT\n\t\t\t/* Try again if zone has deferred pages */\n\t\t\tif (static_branch_unlikely(&deferred_pages)) {\n\t\t\t\tif (_deferred_grow_zone(zone, order))\n\t\t\t\t\tgoto try_this_zone;\n\t\t\t}\n#endif\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!(*did_some_progress)"
          ],
          "line": 3796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__perform_reclaim",
          "args": [
            "gfp_mask",
            "order",
            "ac"
          ],
          "line": 3795
        },
        "resolved": true,
        "details": {
          "function_name": "__perform_reclaim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3754-3784",
          "snippet": "static int\n__perform_reclaim(gfp_t gfp_mask, unsigned int order,\n\t\t\t\t\tconst struct alloc_context *ac)\n{\n\tstruct reclaim_state reclaim_state;\n\tint progress;\n\tunsigned int noreclaim_flag;\n\tunsigned long pflags;\n\n\tcond_resched();\n\n\t/* We now go into synchronous reclaim */\n\tcpuset_memory_pressure_bump();\n\tpsi_memstall_enter(&pflags);\n\tfs_reclaim_acquire(gfp_mask);\n\tnoreclaim_flag = memalloc_noreclaim_save();\n\treclaim_state.reclaimed_slab = 0;\n\tcurrent->reclaim_state = &reclaim_state;\n\n\tprogress = try_to_free_pages(ac->zonelist, order, gfp_mask,\n\t\t\t\t\t\t\t\tac->nodemask);\n\n\tcurrent->reclaim_state = NULL;\n\tmemalloc_noreclaim_restore(noreclaim_flag);\n\tfs_reclaim_release(gfp_mask);\n\tpsi_memstall_leave(&pflags);\n\n\tcond_resched();\n\n\treturn progress;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic int\n__perform_reclaim(gfp_t gfp_mask, unsigned int order,\n\t\t\t\t\tconst struct alloc_context *ac)\n{\n\tstruct reclaim_state reclaim_state;\n\tint progress;\n\tunsigned int noreclaim_flag;\n\tunsigned long pflags;\n\n\tcond_resched();\n\n\t/* We now go into synchronous reclaim */\n\tcpuset_memory_pressure_bump();\n\tpsi_memstall_enter(&pflags);\n\tfs_reclaim_acquire(gfp_mask);\n\tnoreclaim_flag = memalloc_noreclaim_save();\n\treclaim_state.reclaimed_slab = 0;\n\tcurrent->reclaim_state = &reclaim_state;\n\n\tprogress = try_to_free_pages(ac->zonelist, order, gfp_mask,\n\t\t\t\t\t\t\t\tac->nodemask);\n\n\tcurrent->reclaim_state = NULL;\n\tmemalloc_noreclaim_restore(noreclaim_flag);\n\tfs_reclaim_release(gfp_mask);\n\tpsi_memstall_leave(&pflags);\n\n\tcond_resched();\n\n\treturn progress;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline struct page *\n__alloc_pages_direct_reclaim(gfp_t gfp_mask, unsigned int order,\n\t\tunsigned int alloc_flags, const struct alloc_context *ac,\n\t\tunsigned long *did_some_progress)\n{\n\tstruct page *page = NULL;\n\tbool drained = false;\n\n\t*did_some_progress = __perform_reclaim(gfp_mask, order, ac);\n\tif (unlikely(!(*did_some_progress)))\n\t\treturn NULL;\n\nretry:\n\tpage = get_page_from_freelist(gfp_mask, order, alloc_flags, ac);\n\n\t/*\n\t * If an allocation failed after direct reclaim, it could be because\n\t * pages are pinned on the per-cpu lists or in high alloc reserves.\n\t * Shrink them them and try again\n\t */\n\tif (!page && !drained) {\n\t\tunreserve_highatomic_pageblock(ac, false);\n\t\tdrain_all_pages(NULL);\n\t\tdrained = true;\n\t\tgoto retry;\n\t}\n\n\treturn page;\n}"
  },
  {
    "function_name": "__perform_reclaim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "3754-3784",
    "snippet": "static int\n__perform_reclaim(gfp_t gfp_mask, unsigned int order,\n\t\t\t\t\tconst struct alloc_context *ac)\n{\n\tstruct reclaim_state reclaim_state;\n\tint progress;\n\tunsigned int noreclaim_flag;\n\tunsigned long pflags;\n\n\tcond_resched();\n\n\t/* We now go into synchronous reclaim */\n\tcpuset_memory_pressure_bump();\n\tpsi_memstall_enter(&pflags);\n\tfs_reclaim_acquire(gfp_mask);\n\tnoreclaim_flag = memalloc_noreclaim_save();\n\treclaim_state.reclaimed_slab = 0;\n\tcurrent->reclaim_state = &reclaim_state;\n\n\tprogress = try_to_free_pages(ac->zonelist, order, gfp_mask,\n\t\t\t\t\t\t\t\tac->nodemask);\n\n\tcurrent->reclaim_state = NULL;\n\tmemalloc_noreclaim_restore(noreclaim_flag);\n\tfs_reclaim_release(gfp_mask);\n\tpsi_memstall_leave(&pflags);\n\n\tcond_resched();\n\n\treturn progress;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);",
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 3781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psi_memstall_leave",
          "args": [
            "&pflags"
          ],
          "line": 3779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_reclaim_release",
          "args": [
            "gfp_mask"
          ],
          "line": 3778
        },
        "resolved": true,
        "details": {
          "function_name": "fs_reclaim_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3745-3749",
          "snippet": "void fs_reclaim_release(gfp_t gfp_mask)\n{\n\tif (__need_fs_reclaim(gfp_mask))\n\t\t__fs_reclaim_release();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid fs_reclaim_release(gfp_t gfp_mask)\n{\n\tif (__need_fs_reclaim(gfp_mask))\n\t\t__fs_reclaim_release();\n}"
        }
      },
      {
        "call_info": {
          "callee": "memalloc_noreclaim_restore",
          "args": [
            "noreclaim_flag"
          ],
          "line": 3777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_free_pages",
          "args": [
            "ac->zonelist",
            "order",
            "gfp_mask",
            "ac->nodemask"
          ],
          "line": 3773
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmscan.c",
          "lines": "3227-3269",
          "snippet": "unsigned long try_to_free_pages(struct zonelist *zonelist, int order,\n\t\t\t\tgfp_t gfp_mask, nodemask_t *nodemask)\n{\n\tunsigned long nr_reclaimed;\n\tstruct scan_control sc = {\n\t\t.nr_to_reclaim = SWAP_CLUSTER_MAX,\n\t\t.gfp_mask = current_gfp_context(gfp_mask),\n\t\t.reclaim_idx = gfp_zone(gfp_mask),\n\t\t.order = order,\n\t\t.nodemask = nodemask,\n\t\t.priority = DEF_PRIORITY,\n\t\t.may_writepage = !laptop_mode,\n\t\t.may_unmap = 1,\n\t\t.may_swap = 1,\n\t};\n\n\t/*\n\t * scan_control uses s8 fields for order, priority, and reclaim_idx.\n\t * Confirm they are large enough for max values.\n\t */\n\tBUILD_BUG_ON(MAX_ORDER > S8_MAX);\n\tBUILD_BUG_ON(DEF_PRIORITY > S8_MAX);\n\tBUILD_BUG_ON(MAX_NR_ZONES > S8_MAX);\n\n\t/*\n\t * Do not enter reclaim if fatal signal was delivered while throttled.\n\t * 1 is returned so that the page allocator does not OOM kill at this\n\t * point.\n\t */\n\tif (throttle_direct_reclaim(sc.gfp_mask, zonelist, nodemask))\n\t\treturn 1;\n\n\ttrace_mm_vmscan_direct_reclaim_begin(order,\n\t\t\t\tsc.may_writepage,\n\t\t\t\tsc.gfp_mask,\n\t\t\t\tsc.reclaim_idx);\n\n\tnr_reclaimed = do_try_to_free_pages(zonelist, &sc);\n\n\ttrace_mm_vmscan_direct_reclaim_end(nr_reclaimed);\n\n\treturn nr_reclaimed;\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include \"internal.h\"",
            "#include <linux/balloon_compaction.h>",
            "#include <linux/swapops.h>",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <linux/psi.h>",
            "#include <linux/dax.h>",
            "#include <linux/printk.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/oom.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/notifier.h>",
            "#include <linux/compaction.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/topology.h>",
            "#include <linux/rmap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/gfp.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include \"internal.h\"\n#include <linux/balloon_compaction.h>\n#include <linux/swapops.h>\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <linux/psi.h>\n#include <linux/dax.h>\n#include <linux/printk.h>\n#include <linux/prefetch.h>\n#include <linux/oom.h>\n#include <linux/sysctl.h>\n#include <linux/delayacct.h>\n#include <linux/memcontrol.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/notifier.h>\n#include <linux/compaction.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/topology.h>\n#include <linux/rmap.h>\n#include <linux/backing-dev.h>\n#include <linux/mm_inline.h>\n#include <linux/buffer_head.h>\t/* for try_to_release_page(),\n\t\t\t\t\tbuffer_heads_over_limit */\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/vmstat.h>\n#include <linux/vmpressure.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/gfp.h>\n#include <linux/module.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nunsigned long try_to_free_pages(struct zonelist *zonelist, int order,\n\t\t\t\tgfp_t gfp_mask, nodemask_t *nodemask)\n{\n\tunsigned long nr_reclaimed;\n\tstruct scan_control sc = {\n\t\t.nr_to_reclaim = SWAP_CLUSTER_MAX,\n\t\t.gfp_mask = current_gfp_context(gfp_mask),\n\t\t.reclaim_idx = gfp_zone(gfp_mask),\n\t\t.order = order,\n\t\t.nodemask = nodemask,\n\t\t.priority = DEF_PRIORITY,\n\t\t.may_writepage = !laptop_mode,\n\t\t.may_unmap = 1,\n\t\t.may_swap = 1,\n\t};\n\n\t/*\n\t * scan_control uses s8 fields for order, priority, and reclaim_idx.\n\t * Confirm they are large enough for max values.\n\t */\n\tBUILD_BUG_ON(MAX_ORDER > S8_MAX);\n\tBUILD_BUG_ON(DEF_PRIORITY > S8_MAX);\n\tBUILD_BUG_ON(MAX_NR_ZONES > S8_MAX);\n\n\t/*\n\t * Do not enter reclaim if fatal signal was delivered while throttled.\n\t * 1 is returned so that the page allocator does not OOM kill at this\n\t * point.\n\t */\n\tif (throttle_direct_reclaim(sc.gfp_mask, zonelist, nodemask))\n\t\treturn 1;\n\n\ttrace_mm_vmscan_direct_reclaim_begin(order,\n\t\t\t\tsc.may_writepage,\n\t\t\t\tsc.gfp_mask,\n\t\t\t\tsc.reclaim_idx);\n\n\tnr_reclaimed = do_try_to_free_pages(zonelist, &sc);\n\n\ttrace_mm_vmscan_direct_reclaim_end(nr_reclaimed);\n\n\treturn nr_reclaimed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memalloc_noreclaim_save",
          "args": [],
          "line": 3769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_reclaim_acquire",
          "args": [
            "gfp_mask"
          ],
          "line": 3768
        },
        "resolved": true,
        "details": {
          "function_name": "fs_reclaim_acquire",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3738-3742",
          "snippet": "void fs_reclaim_acquire(gfp_t gfp_mask)\n{\n\tif (__need_fs_reclaim(gfp_mask))\n\t\t__fs_reclaim_acquire();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid fs_reclaim_acquire(gfp_t gfp_mask)\n{\n\tif (__need_fs_reclaim(gfp_mask))\n\t\t__fs_reclaim_acquire();\n}"
        }
      },
      {
        "call_info": {
          "callee": "psi_memstall_enter",
          "args": [
            "&pflags"
          ],
          "line": 3767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuset_memory_pressure_bump",
          "args": [],
          "line": 3766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 3763
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic int\n__perform_reclaim(gfp_t gfp_mask, unsigned int order,\n\t\t\t\t\tconst struct alloc_context *ac)\n{\n\tstruct reclaim_state reclaim_state;\n\tint progress;\n\tunsigned int noreclaim_flag;\n\tunsigned long pflags;\n\n\tcond_resched();\n\n\t/* We now go into synchronous reclaim */\n\tcpuset_memory_pressure_bump();\n\tpsi_memstall_enter(&pflags);\n\tfs_reclaim_acquire(gfp_mask);\n\tnoreclaim_flag = memalloc_noreclaim_save();\n\treclaim_state.reclaimed_slab = 0;\n\tcurrent->reclaim_state = &reclaim_state;\n\n\tprogress = try_to_free_pages(ac->zonelist, order, gfp_mask,\n\t\t\t\t\t\t\t\tac->nodemask);\n\n\tcurrent->reclaim_state = NULL;\n\tmemalloc_noreclaim_restore(noreclaim_flag);\n\tfs_reclaim_release(gfp_mask);\n\tpsi_memstall_leave(&pflags);\n\n\tcond_resched();\n\n\treturn progress;\n}"
  },
  {
    "function_name": "fs_reclaim_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "3745-3749",
    "snippet": "void fs_reclaim_release(gfp_t gfp_mask)\n{\n\tif (__need_fs_reclaim(gfp_mask))\n\t\t__fs_reclaim_release();\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__fs_reclaim_release",
          "args": [],
          "line": 3748
        },
        "resolved": true,
        "details": {
          "function_name": "__fs_reclaim_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3733-3736",
          "snippet": "void __fs_reclaim_release(void)\n{\n\tlock_map_release(&__fs_reclaim_map);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid __fs_reclaim_release(void)\n{\n\tlock_map_release(&__fs_reclaim_map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__need_fs_reclaim",
          "args": [
            "gfp_mask"
          ],
          "line": 3747
        },
        "resolved": true,
        "details": {
          "function_name": "__need_fs_reclaim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3706-3726",
          "snippet": "static bool __need_fs_reclaim(gfp_t gfp_mask)\n{\n\tgfp_mask = current_gfp_context(gfp_mask);\n\n\t/* no reclaim without waiting on it */\n\tif (!(gfp_mask & __GFP_DIRECT_RECLAIM))\n\t\treturn false;\n\n\t/* this guy won't enter reclaim */\n\tif (current->flags & PF_MEMALLOC)\n\t\treturn false;\n\n\t/* We're only interested __GFP_FS allocations for now */\n\tif (!(gfp_mask & __GFP_FS))\n\t\treturn false;\n\n\tif (gfp_mask & __GFP_NOLOCKDEP)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic bool __need_fs_reclaim(gfp_t gfp_mask)\n{\n\tgfp_mask = current_gfp_context(gfp_mask);\n\n\t/* no reclaim without waiting on it */\n\tif (!(gfp_mask & __GFP_DIRECT_RECLAIM))\n\t\treturn false;\n\n\t/* this guy won't enter reclaim */\n\tif (current->flags & PF_MEMALLOC)\n\t\treturn false;\n\n\t/* We're only interested __GFP_FS allocations for now */\n\tif (!(gfp_mask & __GFP_FS))\n\t\treturn false;\n\n\tif (gfp_mask & __GFP_NOLOCKDEP)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid fs_reclaim_release(gfp_t gfp_mask)\n{\n\tif (__need_fs_reclaim(gfp_mask))\n\t\t__fs_reclaim_release();\n}"
  },
  {
    "function_name": "fs_reclaim_acquire",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "3738-3742",
    "snippet": "void fs_reclaim_acquire(gfp_t gfp_mask)\n{\n\tif (__need_fs_reclaim(gfp_mask))\n\t\t__fs_reclaim_acquire();\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__fs_reclaim_acquire",
          "args": [],
          "line": 3741
        },
        "resolved": true,
        "details": {
          "function_name": "__fs_reclaim_acquire",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3728-3731",
          "snippet": "void __fs_reclaim_acquire(void)\n{\n\tlock_map_acquire(&__fs_reclaim_map);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid __fs_reclaim_acquire(void)\n{\n\tlock_map_acquire(&__fs_reclaim_map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__need_fs_reclaim",
          "args": [
            "gfp_mask"
          ],
          "line": 3740
        },
        "resolved": true,
        "details": {
          "function_name": "__need_fs_reclaim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3706-3726",
          "snippet": "static bool __need_fs_reclaim(gfp_t gfp_mask)\n{\n\tgfp_mask = current_gfp_context(gfp_mask);\n\n\t/* no reclaim without waiting on it */\n\tif (!(gfp_mask & __GFP_DIRECT_RECLAIM))\n\t\treturn false;\n\n\t/* this guy won't enter reclaim */\n\tif (current->flags & PF_MEMALLOC)\n\t\treturn false;\n\n\t/* We're only interested __GFP_FS allocations for now */\n\tif (!(gfp_mask & __GFP_FS))\n\t\treturn false;\n\n\tif (gfp_mask & __GFP_NOLOCKDEP)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic bool __need_fs_reclaim(gfp_t gfp_mask)\n{\n\tgfp_mask = current_gfp_context(gfp_mask);\n\n\t/* no reclaim without waiting on it */\n\tif (!(gfp_mask & __GFP_DIRECT_RECLAIM))\n\t\treturn false;\n\n\t/* this guy won't enter reclaim */\n\tif (current->flags & PF_MEMALLOC)\n\t\treturn false;\n\n\t/* We're only interested __GFP_FS allocations for now */\n\tif (!(gfp_mask & __GFP_FS))\n\t\treturn false;\n\n\tif (gfp_mask & __GFP_NOLOCKDEP)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid fs_reclaim_acquire(gfp_t gfp_mask)\n{\n\tif (__need_fs_reclaim(gfp_mask))\n\t\t__fs_reclaim_acquire();\n}"
  },
  {
    "function_name": "__fs_reclaim_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "3733-3736",
    "snippet": "void __fs_reclaim_release(void)\n{\n\tlock_map_release(&__fs_reclaim_map);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lock_map_release",
          "args": [
            "&__fs_reclaim_map"
          ],
          "line": 3735
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid __fs_reclaim_release(void)\n{\n\tlock_map_release(&__fs_reclaim_map);\n}"
  },
  {
    "function_name": "__fs_reclaim_acquire",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "3728-3731",
    "snippet": "void __fs_reclaim_acquire(void)\n{\n\tlock_map_acquire(&__fs_reclaim_map);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lock_map_acquire",
          "args": [
            "&__fs_reclaim_map"
          ],
          "line": 3730
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid __fs_reclaim_acquire(void)\n{\n\tlock_map_acquire(&__fs_reclaim_map);\n}"
  },
  {
    "function_name": "__need_fs_reclaim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "3706-3726",
    "snippet": "static bool __need_fs_reclaim(gfp_t gfp_mask)\n{\n\tgfp_mask = current_gfp_context(gfp_mask);\n\n\t/* no reclaim without waiting on it */\n\tif (!(gfp_mask & __GFP_DIRECT_RECLAIM))\n\t\treturn false;\n\n\t/* this guy won't enter reclaim */\n\tif (current->flags & PF_MEMALLOC)\n\t\treturn false;\n\n\t/* We're only interested __GFP_FS allocations for now */\n\tif (!(gfp_mask & __GFP_FS))\n\t\treturn false;\n\n\tif (gfp_mask & __GFP_NOLOCKDEP)\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "current_gfp_context",
          "args": [
            "gfp_mask"
          ],
          "line": 3708
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic bool __need_fs_reclaim(gfp_t gfp_mask)\n{\n\tgfp_mask = current_gfp_context(gfp_mask);\n\n\t/* no reclaim without waiting on it */\n\tif (!(gfp_mask & __GFP_DIRECT_RECLAIM))\n\t\treturn false;\n\n\t/* this guy won't enter reclaim */\n\tif (current->flags & PF_MEMALLOC)\n\t\treturn false;\n\n\t/* We're only interested __GFP_FS allocations for now */\n\tif (!(gfp_mask & __GFP_FS))\n\t\treturn false;\n\n\tif (gfp_mask & __GFP_NOLOCKDEP)\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "should_compact_retry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "3674-3699",
    "snippet": "static inline bool\nshould_compact_retry(struct alloc_context *ac, unsigned int order, int alloc_flags,\n\t\t     enum compact_result compact_result,\n\t\t     enum compact_priority *compact_priority,\n\t\t     int *compaction_retries)\n{\n\tstruct zone *zone;\n\tstruct zoneref *z;\n\n\tif (!order || order > PAGE_ALLOC_COSTLY_ORDER)\n\t\treturn false;\n\n\t/*\n\t * There are setups with compaction disabled which would prefer to loop\n\t * inside the allocator rather than hit the oom killer prematurely.\n\t * Let's give them a good hope and keep retrying while the order-0\n\t * watermarks are OK.\n\t */\n\tfor_each_zone_zonelist_nodemask(zone, z, ac->zonelist, ac->high_zoneidx,\n\t\t\t\t\tac->nodemask) {\n\t\tif (zone_watermark_ok(zone, 0, min_wmark_pages(zone),\n\t\t\t\t\tac_classzone_idx(ac), alloc_flags))\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);",
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "zone_watermark_ok",
          "args": [
            "zone",
            "0",
            "min_wmark_pages(zone)",
            "ac_classzone_idx(ac)",
            "alloc_flags"
          ],
          "line": 3694
        },
        "resolved": true,
        "details": {
          "function_name": "zone_watermark_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3198-3203",
          "snippet": "bool zone_watermark_ok(struct zone *z, unsigned int order, unsigned long mark,\n\t\t      int classzone_idx, unsigned int alloc_flags)\n{\n\treturn __zone_watermark_ok(z, order, mark, classzone_idx, alloc_flags,\n\t\t\t\t\tzone_page_state(z, NR_FREE_PAGES));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nbool zone_watermark_ok(struct zone *z, unsigned int order, unsigned long mark,\n\t\t      int classzone_idx, unsigned int alloc_flags)\n{\n\treturn __zone_watermark_ok(z, order, mark, classzone_idx, alloc_flags,\n\t\t\t\t\tzone_page_state(z, NR_FREE_PAGES));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ac_classzone_idx",
          "args": [
            "ac"
          ],
          "line": 3695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_wmark_pages",
          "args": [
            "zone"
          ],
          "line": 3694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_zone_zonelist_nodemask",
          "args": [
            "zone",
            "z",
            "ac->zonelist",
            "ac->high_zoneidx",
            "ac->nodemask"
          ],
          "line": 3692
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline bool\nshould_compact_retry(struct alloc_context *ac, unsigned int order, int alloc_flags,\n\t\t     enum compact_result compact_result,\n\t\t     enum compact_priority *compact_priority,\n\t\t     int *compaction_retries)\n{\n\tstruct zone *zone;\n\tstruct zoneref *z;\n\n\tif (!order || order > PAGE_ALLOC_COSTLY_ORDER)\n\t\treturn false;\n\n\t/*\n\t * There are setups with compaction disabled which would prefer to loop\n\t * inside the allocator rather than hit the oom killer prematurely.\n\t * Let's give them a good hope and keep retrying while the order-0\n\t * watermarks are OK.\n\t */\n\tfor_each_zone_zonelist_nodemask(zone, z, ac->zonelist, ac->high_zoneidx,\n\t\t\t\t\tac->nodemask) {\n\t\tif (zone_watermark_ok(zone, 0, min_wmark_pages(zone),\n\t\t\t\t\tac_classzone_idx(ac), alloc_flags))\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "__alloc_pages_direct_compact",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "3665-3672",
    "snippet": "static inline struct page *\n__alloc_pages_direct_compact(gfp_t gfp_mask, unsigned int order,\n\t\tunsigned int alloc_flags, const struct alloc_context *ac,\n\t\tenum compact_priority prio, enum compact_result *compact_result)\n{\n\t*compact_result = COMPACT_SKIPPED;\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);",
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline struct page *\n__alloc_pages_direct_compact(gfp_t gfp_mask, unsigned int order,\n\t\tunsigned int alloc_flags, const struct alloc_context *ac,\n\t\tenum compact_priority prio, enum compact_result *compact_result)\n{\n\t*compact_result = COMPACT_SKIPPED;\n\treturn NULL;\n}"
  },
  {
    "function_name": "should_compact_retry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "3595-3663",
    "snippet": "static inline bool\nshould_compact_retry(struct alloc_context *ac, int order, int alloc_flags,\n\t\t     enum compact_result compact_result,\n\t\t     enum compact_priority *compact_priority,\n\t\t     int *compaction_retries)\n{\n\tint max_retries = MAX_COMPACT_RETRIES;\n\tint min_priority;\n\tbool ret = false;\n\tint retries = *compaction_retries;\n\tenum compact_priority priority = *compact_priority;\n\n\tif (!order)\n\t\treturn false;\n\n\tif (compaction_made_progress(compact_result))\n\t\t(*compaction_retries)++;\n\n\t/*\n\t * compaction considers all the zone as desperately out of memory\n\t * so it doesn't really make much sense to retry except when the\n\t * failure could be caused by insufficient priority\n\t */\n\tif (compaction_failed(compact_result))\n\t\tgoto check_priority;\n\n\t/*\n\t * make sure the compaction wasn't deferred or didn't bail out early\n\t * due to locks contention before we declare that we should give up.\n\t * But do not retry if the given zonelist is not suitable for\n\t * compaction.\n\t */\n\tif (compaction_withdrawn(compact_result)) {\n\t\tret = compaction_zonelist_suitable(ac, order, alloc_flags);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * !costly requests are much more important than __GFP_RETRY_MAYFAIL\n\t * costly ones because they are de facto nofail and invoke OOM\n\t * killer to move on while costly can fail and users are ready\n\t * to cope with that. 1/4 retries is rather arbitrary but we\n\t * would need much more detailed feedback from compaction to\n\t * make a better decision.\n\t */\n\tif (order > PAGE_ALLOC_COSTLY_ORDER)\n\t\tmax_retries /= 4;\n\tif (*compaction_retries <= max_retries) {\n\t\tret = true;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Make sure there are attempts at the highest priority if we exhausted\n\t * all retries or failed at the lower priorities.\n\t */\ncheck_priority:\n\tmin_priority = (order > PAGE_ALLOC_COSTLY_ORDER) ?\n\t\t\tMIN_COMPACT_COSTLY_PRIORITY : MIN_COMPACT_PRIORITY;\n\n\tif (*compact_priority > min_priority) {\n\t\t(*compact_priority)--;\n\t\t*compaction_retries = 0;\n\t\tret = true;\n\t}\nout:\n\ttrace_compact_retry(order, priority, compact_result, retries, max_retries, ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [
      "#define MAX_COMPACT_RETRIES 16"
    ],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);",
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_compact_retry",
          "args": [
            "order",
            "priority",
            "compact_result",
            "retries",
            "max_retries",
            "ret"
          ],
          "line": 3661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compaction_zonelist_suitable",
          "args": [
            "ac",
            "order",
            "alloc_flags"
          ],
          "line": 3628
        },
        "resolved": true,
        "details": {
          "function_name": "compaction_zonelist_suitable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "1505-1535",
          "snippet": "bool compaction_zonelist_suitable(struct alloc_context *ac, int order,\n\t\tint alloc_flags)\n{\n\tstruct zone *zone;\n\tstruct zoneref *z;\n\n\t/*\n\t * Make sure at least one zone would pass __compaction_suitable if we continue\n\t * retrying the reclaim.\n\t */\n\tfor_each_zone_zonelist_nodemask(zone, z, ac->zonelist, ac->high_zoneidx,\n\t\t\t\t\tac->nodemask) {\n\t\tunsigned long available;\n\t\tenum compact_result compact_result;\n\n\t\t/*\n\t\t * Do not consider all the reclaimable memory because we do not\n\t\t * want to trash just for a single high order allocation which\n\t\t * is even not guaranteed to appear even if __compaction_suitable\n\t\t * is happy about the watermark check.\n\t\t */\n\t\tavailable = zone_reclaimable_pages(zone) / order;\n\t\tavailable += zone_page_state_snapshot(zone, NR_FREE_PAGES);\n\t\tcompact_result = __compaction_suitable(zone, order, alloc_flags,\n\t\t\t\tac_classzone_idx(ac), available);\n\t\tif (compact_result != COMPACT_SKIPPED)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nbool compaction_zonelist_suitable(struct alloc_context *ac, int order,\n\t\tint alloc_flags)\n{\n\tstruct zone *zone;\n\tstruct zoneref *z;\n\n\t/*\n\t * Make sure at least one zone would pass __compaction_suitable if we continue\n\t * retrying the reclaim.\n\t */\n\tfor_each_zone_zonelist_nodemask(zone, z, ac->zonelist, ac->high_zoneidx,\n\t\t\t\t\tac->nodemask) {\n\t\tunsigned long available;\n\t\tenum compact_result compact_result;\n\n\t\t/*\n\t\t * Do not consider all the reclaimable memory because we do not\n\t\t * want to trash just for a single high order allocation which\n\t\t * is even not guaranteed to appear even if __compaction_suitable\n\t\t * is happy about the watermark check.\n\t\t */\n\t\tavailable = zone_reclaimable_pages(zone) / order;\n\t\tavailable += zone_page_state_snapshot(zone, NR_FREE_PAGES);\n\t\tcompact_result = __compaction_suitable(zone, order, alloc_flags,\n\t\t\t\tac_classzone_idx(ac), available);\n\t\tif (compact_result != COMPACT_SKIPPED)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "compaction_withdrawn",
          "args": [
            "compact_result"
          ],
          "line": 3627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compaction_failed",
          "args": [
            "compact_result"
          ],
          "line": 3618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compaction_made_progress",
          "args": [
            "compact_result"
          ],
          "line": 3610
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\n#define MAX_COMPACT_RETRIES 16\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline bool\nshould_compact_retry(struct alloc_context *ac, int order, int alloc_flags,\n\t\t     enum compact_result compact_result,\n\t\t     enum compact_priority *compact_priority,\n\t\t     int *compaction_retries)\n{\n\tint max_retries = MAX_COMPACT_RETRIES;\n\tint min_priority;\n\tbool ret = false;\n\tint retries = *compaction_retries;\n\tenum compact_priority priority = *compact_priority;\n\n\tif (!order)\n\t\treturn false;\n\n\tif (compaction_made_progress(compact_result))\n\t\t(*compaction_retries)++;\n\n\t/*\n\t * compaction considers all the zone as desperately out of memory\n\t * so it doesn't really make much sense to retry except when the\n\t * failure could be caused by insufficient priority\n\t */\n\tif (compaction_failed(compact_result))\n\t\tgoto check_priority;\n\n\t/*\n\t * make sure the compaction wasn't deferred or didn't bail out early\n\t * due to locks contention before we declare that we should give up.\n\t * But do not retry if the given zonelist is not suitable for\n\t * compaction.\n\t */\n\tif (compaction_withdrawn(compact_result)) {\n\t\tret = compaction_zonelist_suitable(ac, order, alloc_flags);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * !costly requests are much more important than __GFP_RETRY_MAYFAIL\n\t * costly ones because they are de facto nofail and invoke OOM\n\t * killer to move on while costly can fail and users are ready\n\t * to cope with that. 1/4 retries is rather arbitrary but we\n\t * would need much more detailed feedback from compaction to\n\t * make a better decision.\n\t */\n\tif (order > PAGE_ALLOC_COSTLY_ORDER)\n\t\tmax_retries /= 4;\n\tif (*compaction_retries <= max_retries) {\n\t\tret = true;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Make sure there are attempts at the highest priority if we exhausted\n\t * all retries or failed at the lower priorities.\n\t */\ncheck_priority:\n\tmin_priority = (order > PAGE_ALLOC_COSTLY_ORDER) ?\n\t\t\tMIN_COMPACT_COSTLY_PRIORITY : MIN_COMPACT_PRIORITY;\n\n\tif (*compact_priority > min_priority) {\n\t\t(*compact_priority)--;\n\t\t*compaction_retries = 0;\n\t\tret = true;\n\t}\nout:\n\ttrace_compact_retry(order, priority, compact_result, retries, max_retries, ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "__alloc_pages_direct_compact",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "3543-3593",
    "snippet": "static struct page *\n__alloc_pages_direct_compact(gfp_t gfp_mask, unsigned int order,\n\t\tunsigned int alloc_flags, const struct alloc_context *ac,\n\t\tenum compact_priority prio, enum compact_result *compact_result)\n{\n\tstruct page *page;\n\tunsigned long pflags;\n\tunsigned int noreclaim_flag;\n\n\tif (!order)\n\t\treturn NULL;\n\n\tpsi_memstall_enter(&pflags);\n\tnoreclaim_flag = memalloc_noreclaim_save();\n\n\t*compact_result = try_to_compact_pages(gfp_mask, order, alloc_flags, ac,\n\t\t\t\t\t\t\t\t\tprio);\n\n\tmemalloc_noreclaim_restore(noreclaim_flag);\n\tpsi_memstall_leave(&pflags);\n\n\tif (*compact_result <= COMPACT_INACTIVE)\n\t\treturn NULL;\n\n\t/*\n\t * At least in one zone compaction wasn't deferred or skipped, so let's\n\t * count a compaction stall\n\t */\n\tcount_vm_event(COMPACTSTALL);\n\n\tpage = get_page_from_freelist(gfp_mask, order, alloc_flags, ac);\n\n\tif (page) {\n\t\tstruct zone *zone = page_zone(page);\n\n\t\tzone->compact_blockskip_flush = false;\n\t\tcompaction_defer_reset(zone, order, true);\n\t\tcount_vm_event(COMPACTSUCCESS);\n\t\treturn page;\n\t}\n\n\t/*\n\t * It's bad if compaction run occurs and fails. The most likely reason\n\t * is that pages exist, but not enough to satisfy watermarks.\n\t */\n\tcount_vm_event(COMPACTFAIL);\n\n\tcond_resched();\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);",
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 3590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_vm_event",
          "args": [
            "COMPACTFAIL"
          ],
          "line": 3588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_vm_event",
          "args": [
            "COMPACTSUCCESS"
          ],
          "line": 3580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compaction_defer_reset",
          "args": [
            "zone",
            "order",
            "true"
          ],
          "line": 3579
        },
        "resolved": true,
        "details": {
          "function_name": "compaction_defer_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "181-192",
          "snippet": "void compaction_defer_reset(struct zone *zone, int order,\n\t\tbool alloc_success)\n{\n\tif (alloc_success) {\n\t\tzone->compact_considered = 0;\n\t\tzone->compact_defer_shift = 0;\n\t}\n\tif (order >= zone->compact_order_failed)\n\t\tzone->compact_order_failed = order + 1;\n\n\ttrace_mm_compaction_defer_reset(zone, order);\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nvoid compaction_defer_reset(struct zone *zone, int order,\n\t\tbool alloc_success)\n{\n\tif (alloc_success) {\n\t\tzone->compact_considered = 0;\n\t\tzone->compact_defer_shift = 0;\n\t}\n\tif (order >= zone->compact_order_failed)\n\t\tzone->compact_order_failed = order + 1;\n\n\ttrace_mm_compaction_defer_reset(zone, order);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "page"
          ],
          "line": 3576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page_from_freelist",
          "args": [
            "gfp_mask",
            "order",
            "alloc_flags",
            "ac"
          ],
          "line": 3573
        },
        "resolved": true,
        "details": {
          "function_name": "get_page_from_freelist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3260-3378",
          "snippet": "static struct page *\nget_page_from_freelist(gfp_t gfp_mask, unsigned int order, int alloc_flags,\n\t\t\t\t\t\tconst struct alloc_context *ac)\n{\n\tstruct zoneref *z = ac->preferred_zoneref;\n\tstruct zone *zone;\n\tstruct pglist_data *last_pgdat_dirty_limit = NULL;\n\n\t/*\n\t * Scan zonelist, looking for a zone with enough free.\n\t * See also __cpuset_node_allowed() comment in kernel/cpuset.c.\n\t */\n\tfor_next_zone_zonelist_nodemask(zone, z, ac->zonelist, ac->high_zoneidx,\n\t\t\t\t\t\t\t\tac->nodemask) {\n\t\tstruct page *page;\n\t\tunsigned long mark;\n\n\t\tif (cpusets_enabled() &&\n\t\t\t(alloc_flags & ALLOC_CPUSET) &&\n\t\t\t!__cpuset_zone_allowed(zone, gfp_mask))\n\t\t\t\tcontinue;\n\t\t/*\n\t\t * When allocating a page cache page for writing, we\n\t\t * want to get it from a node that is within its dirty\n\t\t * limit, such that no single node holds more than its\n\t\t * proportional share of globally allowed dirty pages.\n\t\t * The dirty limits take into account the node's\n\t\t * lowmem reserves and high watermark so that kswapd\n\t\t * should be able to balance it without having to\n\t\t * write pages from its LRU list.\n\t\t *\n\t\t * XXX: For now, allow allocations to potentially\n\t\t * exceed the per-node dirty limit in the slowpath\n\t\t * (spread_dirty_pages unset) before going into reclaim,\n\t\t * which is important when on a NUMA setup the allowed\n\t\t * nodes are together not big enough to reach the\n\t\t * global limit.  The proper fix for these situations\n\t\t * will require awareness of nodes in the\n\t\t * dirty-throttling and the flusher threads.\n\t\t */\n\t\tif (ac->spread_dirty_pages) {\n\t\t\tif (last_pgdat_dirty_limit == zone->zone_pgdat)\n\t\t\t\tcontinue;\n\n\t\t\tif (!node_dirty_ok(zone->zone_pgdat)) {\n\t\t\t\tlast_pgdat_dirty_limit = zone->zone_pgdat;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tmark = zone->watermark[alloc_flags & ALLOC_WMARK_MASK];\n\t\tif (!zone_watermark_fast(zone, order, mark,\n\t\t\t\t       ac_classzone_idx(ac), alloc_flags)) {\n\t\t\tint ret;\n\n#ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT\n\t\t\t/*\n\t\t\t * Watermark failed for this zone, but see if we can\n\t\t\t * grow this zone if it contains deferred pages.\n\t\t\t */\n\t\t\tif (static_branch_unlikely(&deferred_pages)) {\n\t\t\t\tif (_deferred_grow_zone(zone, order))\n\t\t\t\t\tgoto try_this_zone;\n\t\t\t}\n#endif\n\t\t\t/* Checked here to keep the fast path fast */\n\t\t\tBUILD_BUG_ON(ALLOC_NO_WATERMARKS < NR_WMARK);\n\t\t\tif (alloc_flags & ALLOC_NO_WATERMARKS)\n\t\t\t\tgoto try_this_zone;\n\n\t\t\tif (node_reclaim_mode == 0 ||\n\t\t\t    !zone_allows_reclaim(ac->preferred_zoneref->zone, zone))\n\t\t\t\tcontinue;\n\n\t\t\tret = node_reclaim(zone->zone_pgdat, gfp_mask, order);\n\t\t\tswitch (ret) {\n\t\t\tcase NODE_RECLAIM_NOSCAN:\n\t\t\t\t/* did not scan */\n\t\t\t\tcontinue;\n\t\t\tcase NODE_RECLAIM_FULL:\n\t\t\t\t/* scanned but unreclaimable */\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\t/* did we reclaim enough */\n\t\t\t\tif (zone_watermark_ok(zone, order, mark,\n\t\t\t\t\t\tac_classzone_idx(ac), alloc_flags))\n\t\t\t\t\tgoto try_this_zone;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\ntry_this_zone:\n\t\tpage = rmqueue(ac->preferred_zoneref->zone, zone, order,\n\t\t\t\tgfp_mask, alloc_flags, ac->migratetype);\n\t\tif (page) {\n\t\t\tprep_new_page(page, order, gfp_mask, alloc_flags);\n\n\t\t\t/*\n\t\t\t * If this is a high-order atomic allocation then check\n\t\t\t * if the pageblock should be reserved for the future\n\t\t\t */\n\t\t\tif (unlikely(order && (alloc_flags & ALLOC_HARDER)))\n\t\t\t\treserve_highatomic_pageblock(page, zone, order);\n\n\t\t\treturn page;\n\t\t} else {\n#ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT\n\t\t\t/* Try again if zone has deferred pages */\n\t\t\tif (static_branch_unlikely(&deferred_pages)) {\n\t\t\t\tif (_deferred_grow_zone(zone, order))\n\t\t\t\t\tgoto try_this_zone;\n\t\t\t}\n#endif\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic struct page *\nget_page_from_freelist(gfp_t gfp_mask, unsigned int order, int alloc_flags,\n\t\t\t\t\t\tconst struct alloc_context *ac)\n{\n\tstruct zoneref *z = ac->preferred_zoneref;\n\tstruct zone *zone;\n\tstruct pglist_data *last_pgdat_dirty_limit = NULL;\n\n\t/*\n\t * Scan zonelist, looking for a zone with enough free.\n\t * See also __cpuset_node_allowed() comment in kernel/cpuset.c.\n\t */\n\tfor_next_zone_zonelist_nodemask(zone, z, ac->zonelist, ac->high_zoneidx,\n\t\t\t\t\t\t\t\tac->nodemask) {\n\t\tstruct page *page;\n\t\tunsigned long mark;\n\n\t\tif (cpusets_enabled() &&\n\t\t\t(alloc_flags & ALLOC_CPUSET) &&\n\t\t\t!__cpuset_zone_allowed(zone, gfp_mask))\n\t\t\t\tcontinue;\n\t\t/*\n\t\t * When allocating a page cache page for writing, we\n\t\t * want to get it from a node that is within its dirty\n\t\t * limit, such that no single node holds more than its\n\t\t * proportional share of globally allowed dirty pages.\n\t\t * The dirty limits take into account the node's\n\t\t * lowmem reserves and high watermark so that kswapd\n\t\t * should be able to balance it without having to\n\t\t * write pages from its LRU list.\n\t\t *\n\t\t * XXX: For now, allow allocations to potentially\n\t\t * exceed the per-node dirty limit in the slowpath\n\t\t * (spread_dirty_pages unset) before going into reclaim,\n\t\t * which is important when on a NUMA setup the allowed\n\t\t * nodes are together not big enough to reach the\n\t\t * global limit.  The proper fix for these situations\n\t\t * will require awareness of nodes in the\n\t\t * dirty-throttling and the flusher threads.\n\t\t */\n\t\tif (ac->spread_dirty_pages) {\n\t\t\tif (last_pgdat_dirty_limit == zone->zone_pgdat)\n\t\t\t\tcontinue;\n\n\t\t\tif (!node_dirty_ok(zone->zone_pgdat)) {\n\t\t\t\tlast_pgdat_dirty_limit = zone->zone_pgdat;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tmark = zone->watermark[alloc_flags & ALLOC_WMARK_MASK];\n\t\tif (!zone_watermark_fast(zone, order, mark,\n\t\t\t\t       ac_classzone_idx(ac), alloc_flags)) {\n\t\t\tint ret;\n\n#ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT\n\t\t\t/*\n\t\t\t * Watermark failed for this zone, but see if we can\n\t\t\t * grow this zone if it contains deferred pages.\n\t\t\t */\n\t\t\tif (static_branch_unlikely(&deferred_pages)) {\n\t\t\t\tif (_deferred_grow_zone(zone, order))\n\t\t\t\t\tgoto try_this_zone;\n\t\t\t}\n#endif\n\t\t\t/* Checked here to keep the fast path fast */\n\t\t\tBUILD_BUG_ON(ALLOC_NO_WATERMARKS < NR_WMARK);\n\t\t\tif (alloc_flags & ALLOC_NO_WATERMARKS)\n\t\t\t\tgoto try_this_zone;\n\n\t\t\tif (node_reclaim_mode == 0 ||\n\t\t\t    !zone_allows_reclaim(ac->preferred_zoneref->zone, zone))\n\t\t\t\tcontinue;\n\n\t\t\tret = node_reclaim(zone->zone_pgdat, gfp_mask, order);\n\t\t\tswitch (ret) {\n\t\t\tcase NODE_RECLAIM_NOSCAN:\n\t\t\t\t/* did not scan */\n\t\t\t\tcontinue;\n\t\t\tcase NODE_RECLAIM_FULL:\n\t\t\t\t/* scanned but unreclaimable */\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\t/* did we reclaim enough */\n\t\t\t\tif (zone_watermark_ok(zone, order, mark,\n\t\t\t\t\t\tac_classzone_idx(ac), alloc_flags))\n\t\t\t\t\tgoto try_this_zone;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\ntry_this_zone:\n\t\tpage = rmqueue(ac->preferred_zoneref->zone, zone, order,\n\t\t\t\tgfp_mask, alloc_flags, ac->migratetype);\n\t\tif (page) {\n\t\t\tprep_new_page(page, order, gfp_mask, alloc_flags);\n\n\t\t\t/*\n\t\t\t * If this is a high-order atomic allocation then check\n\t\t\t * if the pageblock should be reserved for the future\n\t\t\t */\n\t\t\tif (unlikely(order && (alloc_flags & ALLOC_HARDER)))\n\t\t\t\treserve_highatomic_pageblock(page, zone, order);\n\n\t\t\treturn page;\n\t\t} else {\n#ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT\n\t\t\t/* Try again if zone has deferred pages */\n\t\t\tif (static_branch_unlikely(&deferred_pages)) {\n\t\t\t\tif (_deferred_grow_zone(zone, order))\n\t\t\t\t\tgoto try_this_zone;\n\t\t\t}\n#endif\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "count_vm_event",
          "args": [
            "COMPACTSTALL"
          ],
          "line": 3571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psi_memstall_leave",
          "args": [
            "&pflags"
          ],
          "line": 3562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memalloc_noreclaim_restore",
          "args": [
            "noreclaim_flag"
          ],
          "line": 3561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_compact_pages",
          "args": [
            "gfp_mask",
            "order",
            "alloc_flags",
            "ac",
            "prio"
          ],
          "line": 3558
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_compact_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/compaction.c",
          "lines": "1746-1812",
          "snippet": "enum compact_result try_to_compact_pages(gfp_t gfp_mask, unsigned int order,\n\t\tunsigned int alloc_flags, const struct alloc_context *ac,\n\t\tenum compact_priority prio)\n{\n\tint may_perform_io = gfp_mask & __GFP_IO;\n\tstruct zoneref *z;\n\tstruct zone *zone;\n\tenum compact_result rc = COMPACT_SKIPPED;\n\n\t/*\n\t * Check if the GFP flags allow compaction - GFP_NOIO is really\n\t * tricky context because the migration might require IO\n\t */\n\tif (!may_perform_io)\n\t\treturn COMPACT_SKIPPED;\n\n\ttrace_mm_compaction_try_to_compact_pages(order, gfp_mask, prio);\n\n\t/* Compact each zone in the list */\n\tfor_each_zone_zonelist_nodemask(zone, z, ac->zonelist, ac->high_zoneidx,\n\t\t\t\t\t\t\t\tac->nodemask) {\n\t\tenum compact_result status;\n\n\t\tif (prio > MIN_COMPACT_PRIORITY\n\t\t\t\t\t&& compaction_deferred(zone, order)) {\n\t\t\trc = max_t(enum compact_result, COMPACT_DEFERRED, rc);\n\t\t\tcontinue;\n\t\t}\n\n\t\tstatus = compact_zone_order(zone, order, gfp_mask, prio,\n\t\t\t\t\talloc_flags, ac_classzone_idx(ac));\n\t\trc = max(status, rc);\n\n\t\t/* The allocation should succeed, stop compacting */\n\t\tif (status == COMPACT_SUCCESS) {\n\t\t\t/*\n\t\t\t * We think the allocation will succeed in this zone,\n\t\t\t * but it is not certain, hence the false. The caller\n\t\t\t * will repeat this with true if allocation indeed\n\t\t\t * succeeds in this zone.\n\t\t\t */\n\t\t\tcompaction_defer_reset(zone, order, false);\n\n\t\t\tbreak;\n\t\t}\n\n\t\tif (prio != COMPACT_PRIO_ASYNC && (status == COMPACT_COMPLETE ||\n\t\t\t\t\tstatus == COMPACT_PARTIAL_SKIPPED))\n\t\t\t/*\n\t\t\t * We think that allocation won't succeed in this zone\n\t\t\t * so we defer compaction there. If it ends up\n\t\t\t * succeeding after all, it will be reset.\n\t\t\t */\n\t\t\tdefer_compaction(zone, order);\n\n\t\t/*\n\t\t * We might have stopped compacting due to need_resched() in\n\t\t * async compaction, or due to a fatal signal detected. In that\n\t\t * case do not try further zones\n\t\t */\n\t\tif ((prio == COMPACT_PRIO_ASYNC && need_resched())\n\t\t\t\t\t|| fatal_signal_pending(current))\n\t\t\tbreak;\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include <trace/events/compaction.h>",
            "#include \"internal.h\"",
            "#include <linux/psi.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kasan.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/compaction.h>\n#include \"internal.h\"\n#include <linux/psi.h>\n#include <linux/page_owner.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/kasan.h>\n#include <linux/page-isolation.h>\n#include <linux/sysfs.h>\n#include <linux/sysctl.h>\n#include <linux/backing-dev.h>\n#include <linux/sched/signal.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/cpu.h>\n\nenum compact_result try_to_compact_pages(gfp_t gfp_mask, unsigned int order,\n\t\tunsigned int alloc_flags, const struct alloc_context *ac,\n\t\tenum compact_priority prio)\n{\n\tint may_perform_io = gfp_mask & __GFP_IO;\n\tstruct zoneref *z;\n\tstruct zone *zone;\n\tenum compact_result rc = COMPACT_SKIPPED;\n\n\t/*\n\t * Check if the GFP flags allow compaction - GFP_NOIO is really\n\t * tricky context because the migration might require IO\n\t */\n\tif (!may_perform_io)\n\t\treturn COMPACT_SKIPPED;\n\n\ttrace_mm_compaction_try_to_compact_pages(order, gfp_mask, prio);\n\n\t/* Compact each zone in the list */\n\tfor_each_zone_zonelist_nodemask(zone, z, ac->zonelist, ac->high_zoneidx,\n\t\t\t\t\t\t\t\tac->nodemask) {\n\t\tenum compact_result status;\n\n\t\tif (prio > MIN_COMPACT_PRIORITY\n\t\t\t\t\t&& compaction_deferred(zone, order)) {\n\t\t\trc = max_t(enum compact_result, COMPACT_DEFERRED, rc);\n\t\t\tcontinue;\n\t\t}\n\n\t\tstatus = compact_zone_order(zone, order, gfp_mask, prio,\n\t\t\t\t\talloc_flags, ac_classzone_idx(ac));\n\t\trc = max(status, rc);\n\n\t\t/* The allocation should succeed, stop compacting */\n\t\tif (status == COMPACT_SUCCESS) {\n\t\t\t/*\n\t\t\t * We think the allocation will succeed in this zone,\n\t\t\t * but it is not certain, hence the false. The caller\n\t\t\t * will repeat this with true if allocation indeed\n\t\t\t * succeeds in this zone.\n\t\t\t */\n\t\t\tcompaction_defer_reset(zone, order, false);\n\n\t\t\tbreak;\n\t\t}\n\n\t\tif (prio != COMPACT_PRIO_ASYNC && (status == COMPACT_COMPLETE ||\n\t\t\t\t\tstatus == COMPACT_PARTIAL_SKIPPED))\n\t\t\t/*\n\t\t\t * We think that allocation won't succeed in this zone\n\t\t\t * so we defer compaction there. If it ends up\n\t\t\t * succeeding after all, it will be reset.\n\t\t\t */\n\t\t\tdefer_compaction(zone, order);\n\n\t\t/*\n\t\t * We might have stopped compacting due to need_resched() in\n\t\t * async compaction, or due to a fatal signal detected. In that\n\t\t * case do not try further zones\n\t\t */\n\t\tif ((prio == COMPACT_PRIO_ASYNC && need_resched())\n\t\t\t\t\t|| fatal_signal_pending(current))\n\t\t\tbreak;\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memalloc_noreclaim_save",
          "args": [],
          "line": 3556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psi_memstall_enter",
          "args": [
            "&pflags"
          ],
          "line": 3555
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic struct page *\n__alloc_pages_direct_compact(gfp_t gfp_mask, unsigned int order,\n\t\tunsigned int alloc_flags, const struct alloc_context *ac,\n\t\tenum compact_priority prio, enum compact_result *compact_result)\n{\n\tstruct page *page;\n\tunsigned long pflags;\n\tunsigned int noreclaim_flag;\n\n\tif (!order)\n\t\treturn NULL;\n\n\tpsi_memstall_enter(&pflags);\n\tnoreclaim_flag = memalloc_noreclaim_save();\n\n\t*compact_result = try_to_compact_pages(gfp_mask, order, alloc_flags, ac,\n\t\t\t\t\t\t\t\t\tprio);\n\n\tmemalloc_noreclaim_restore(noreclaim_flag);\n\tpsi_memstall_leave(&pflags);\n\n\tif (*compact_result <= COMPACT_INACTIVE)\n\t\treturn NULL;\n\n\t/*\n\t * At least in one zone compaction wasn't deferred or skipped, so let's\n\t * count a compaction stall\n\t */\n\tcount_vm_event(COMPACTSTALL);\n\n\tpage = get_page_from_freelist(gfp_mask, order, alloc_flags, ac);\n\n\tif (page) {\n\t\tstruct zone *zone = page_zone(page);\n\n\t\tzone->compact_blockskip_flush = false;\n\t\tcompaction_defer_reset(zone, order, true);\n\t\tcount_vm_event(COMPACTSUCCESS);\n\t\treturn page;\n\t}\n\n\t/*\n\t * It's bad if compaction run occurs and fails. The most likely reason\n\t * is that pages exist, but not enough to satisfy watermarks.\n\t */\n\tcount_vm_event(COMPACTFAIL);\n\n\tcond_resched();\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "__alloc_pages_may_oom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "3447-3533",
    "snippet": "static inline struct page *\n__alloc_pages_may_oom(gfp_t gfp_mask, unsigned int order,\n\tconst struct alloc_context *ac, unsigned long *did_some_progress)\n{\n\tstruct oom_control oc = {\n\t\t.zonelist = ac->zonelist,\n\t\t.nodemask = ac->nodemask,\n\t\t.memcg = NULL,\n\t\t.gfp_mask = gfp_mask,\n\t\t.order = order,\n\t};\n\tstruct page *page;\n\n\t*did_some_progress = 0;\n\n\t/*\n\t * Acquire the oom lock.  If that fails, somebody else is\n\t * making progress for us.\n\t */\n\tif (!mutex_trylock(&oom_lock)) {\n\t\t*did_some_progress = 1;\n\t\tschedule_timeout_uninterruptible(1);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * Go through the zonelist yet one more time, keep very high watermark\n\t * here, this is only to catch a parallel oom killing, we must fail if\n\t * we're still under heavy pressure. But make sure that this reclaim\n\t * attempt shall not depend on __GFP_DIRECT_RECLAIM && !__GFP_NORETRY\n\t * allocation which will never fail due to oom_lock already held.\n\t */\n\tpage = get_page_from_freelist((gfp_mask | __GFP_HARDWALL) &\n\t\t\t\t      ~__GFP_DIRECT_RECLAIM, order,\n\t\t\t\t      ALLOC_WMARK_HIGH|ALLOC_CPUSET, ac);\n\tif (page)\n\t\tgoto out;\n\n\t/* Coredumps can quickly deplete all memory reserves */\n\tif (current->flags & PF_DUMPCORE)\n\t\tgoto out;\n\t/* The OOM killer will not help higher order allocs */\n\tif (order > PAGE_ALLOC_COSTLY_ORDER)\n\t\tgoto out;\n\t/*\n\t * We have already exhausted all our reclaim opportunities without any\n\t * success so it is time to admit defeat. We will skip the OOM killer\n\t * because it is very likely that the caller has a more reasonable\n\t * fallback than shooting a random task.\n\t */\n\tif (gfp_mask & __GFP_RETRY_MAYFAIL)\n\t\tgoto out;\n\t/* The OOM killer does not needlessly kill tasks for lowmem */\n\tif (ac->high_zoneidx < ZONE_NORMAL)\n\t\tgoto out;\n\tif (pm_suspended_storage())\n\t\tgoto out;\n\t/*\n\t * XXX: GFP_NOFS allocations should rather fail than rely on\n\t * other request to make a forward progress.\n\t * We are in an unfortunate situation where out_of_memory cannot\n\t * do much for this context but let's try it to at least get\n\t * access to memory reserved if the current task is killed (see\n\t * out_of_memory). Once filesystems are ready to handle allocation\n\t * failures more gracefully we should just bail out here.\n\t */\n\n\t/* The OOM killer may not free memory on a specific node */\n\tif (gfp_mask & __GFP_THISNODE)\n\t\tgoto out;\n\n\t/* Exhausted what can be done so it's blame time */\n\tif (out_of_memory(&oc) || WARN_ON_ONCE(gfp_mask & __GFP_NOFAIL)) {\n\t\t*did_some_progress = 1;\n\n\t\t/*\n\t\t * Help non-failing allocations by giving them access to memory\n\t\t * reserves\n\t\t */\n\t\tif (gfp_mask & __GFP_NOFAIL)\n\t\t\tpage = __alloc_pages_cpuset_fallback(gfp_mask, order,\n\t\t\t\t\tALLOC_NO_WATERMARKS, ac);\n\t}\nout:\n\tmutex_unlock(&oom_lock);\n\treturn page;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);",
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&oom_lock"
          ],
          "line": 3531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__alloc_pages_cpuset_fallback",
          "args": [
            "gfp_mask",
            "order",
            "ALLOC_NO_WATERMARKS",
            "ac"
          ],
          "line": 3527
        },
        "resolved": true,
        "details": {
          "function_name": "__alloc_pages_cpuset_fallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3427-3445",
          "snippet": "static inline struct page *\n__alloc_pages_cpuset_fallback(gfp_t gfp_mask, unsigned int order,\n\t\t\t      unsigned int alloc_flags,\n\t\t\t      const struct alloc_context *ac)\n{\n\tstruct page *page;\n\n\tpage = get_page_from_freelist(gfp_mask, order,\n\t\t\talloc_flags|ALLOC_CPUSET, ac);\n\t/*\n\t * fallback to ignore cpuset restriction if our nodes\n\t * are depleted\n\t */\n\tif (!page)\n\t\tpage = get_page_from_freelist(gfp_mask, order,\n\t\t\t\talloc_flags, ac);\n\n\treturn page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline struct page *\n__alloc_pages_cpuset_fallback(gfp_t gfp_mask, unsigned int order,\n\t\t\t      unsigned int alloc_flags,\n\t\t\t      const struct alloc_context *ac)\n{\n\tstruct page *page;\n\n\tpage = get_page_from_freelist(gfp_mask, order,\n\t\t\talloc_flags|ALLOC_CPUSET, ac);\n\t/*\n\t * fallback to ignore cpuset restriction if our nodes\n\t * are depleted\n\t */\n\tif (!page)\n\t\tpage = get_page_from_freelist(gfp_mask, order,\n\t\t\t\talloc_flags, ac);\n\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "gfp_mask & __GFP_NOFAIL"
          ],
          "line": 3519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "out_of_memory",
          "args": [
            "&oc"
          ],
          "line": 3519
        },
        "resolved": true,
        "details": {
          "function_name": "out_of_memory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/oom_kill.c",
          "lines": "1053-1123",
          "snippet": "bool out_of_memory(struct oom_control *oc)\n{\n\tunsigned long freed = 0;\n\tenum oom_constraint constraint = CONSTRAINT_NONE;\n\n\tif (oom_killer_disabled)\n\t\treturn false;\n\n\tif (!is_memcg_oom(oc)) {\n\t\tblocking_notifier_call_chain(&oom_notify_list, 0, &freed);\n\t\tif (freed > 0)\n\t\t\t/* Got some memory back in the last second. */\n\t\t\treturn true;\n\t}\n\n\t/*\n\t * If current has a pending SIGKILL or is exiting, then automatically\n\t * select it.  The goal is to allow it to allocate so that it may\n\t * quickly exit and free its memory.\n\t */\n\tif (task_will_free_mem(current)) {\n\t\tmark_oom_victim(current);\n\t\twake_oom_reaper(current);\n\t\treturn true;\n\t}\n\n\t/*\n\t * The OOM killer does not compensate for IO-less reclaim.\n\t * pagefault_out_of_memory lost its gfp context so we have to\n\t * make sure exclude 0 mask - all other users should have at least\n\t * ___GFP_DIRECT_RECLAIM to get here.\n\t */\n\tif (oc->gfp_mask && !(oc->gfp_mask & __GFP_FS))\n\t\treturn true;\n\n\t/*\n\t * Check if there were limitations on the allocation (only relevant for\n\t * NUMA and memcg) that may require different handling.\n\t */\n\tconstraint = constrained_alloc(oc);\n\tif (constraint != CONSTRAINT_MEMORY_POLICY)\n\t\toc->nodemask = NULL;\n\tcheck_panic_on_oom(oc, constraint);\n\n\tif (!is_memcg_oom(oc) && sysctl_oom_kill_allocating_task &&\n\t    current->mm && !oom_unkillable_task(current, NULL, oc->nodemask) &&\n\t    current->signal->oom_score_adj != OOM_SCORE_ADJ_MIN) {\n\t\tget_task_struct(current);\n\t\toc->chosen = current;\n\t\toom_kill_process(oc, \"Out of memory (oom_kill_allocating_task)\");\n\t\treturn true;\n\t}\n\n\tselect_bad_process(oc);\n\t/* Found nothing?!?! */\n\tif (!oc->chosen) {\n\t\tdump_header(oc, NULL);\n\t\tpr_warn(\"Out of memory and no killable processes...\\n\");\n\t\t/*\n\t\t * If we got here due to an actual allocation at the\n\t\t * system level, we cannot survive this and will enter\n\t\t * an endless loop in the allocator. Bail out now.\n\t\t */\n\t\tif (!is_sysrq_oom(oc) && !is_memcg_oom(oc))\n\t\t\tpanic(\"System is deadlocked on memory\\n\");\n\t}\n\tif (oc->chosen && oc->chosen != (void *)-1UL)\n\t\toom_kill_process(oc, !is_memcg_oom(oc) ? \"Out of memory\" :\n\t\t\t\t \"Memory cgroup out of memory\");\n\treturn !!oc->chosen;\n}",
          "includes": [
            "#include <trace/events/oom.h>",
            "#include \"slab.h\"",
            "#include \"internal.h\"",
            "#include <asm/tlb.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/timex.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/oom.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int sysctl_oom_kill_allocating_task;",
            "static bool oom_killer_disabled",
            "static BLOCKING_NOTIFIER_HEAD(oom_notify_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/oom.h>\n#include \"slab.h\"\n#include \"internal.h\"\n#include <asm/tlb.h>\n#include <linux/mmu_notifier.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/ftrace.h>\n#include <linux/freezer.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mempolicy.h>\n#include <linux/memcontrol.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/cpuset.h>\n#include <linux/jiffies.h>\n#include <linux/timex.h>\n#include <linux/swap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/oom.h>\n\nint sysctl_oom_kill_allocating_task;\nstatic bool oom_killer_disabled;\nstatic BLOCKING_NOTIFIER_HEAD(oom_notify_list);\n\nbool out_of_memory(struct oom_control *oc)\n{\n\tunsigned long freed = 0;\n\tenum oom_constraint constraint = CONSTRAINT_NONE;\n\n\tif (oom_killer_disabled)\n\t\treturn false;\n\n\tif (!is_memcg_oom(oc)) {\n\t\tblocking_notifier_call_chain(&oom_notify_list, 0, &freed);\n\t\tif (freed > 0)\n\t\t\t/* Got some memory back in the last second. */\n\t\t\treturn true;\n\t}\n\n\t/*\n\t * If current has a pending SIGKILL or is exiting, then automatically\n\t * select it.  The goal is to allow it to allocate so that it may\n\t * quickly exit and free its memory.\n\t */\n\tif (task_will_free_mem(current)) {\n\t\tmark_oom_victim(current);\n\t\twake_oom_reaper(current);\n\t\treturn true;\n\t}\n\n\t/*\n\t * The OOM killer does not compensate for IO-less reclaim.\n\t * pagefault_out_of_memory lost its gfp context so we have to\n\t * make sure exclude 0 mask - all other users should have at least\n\t * ___GFP_DIRECT_RECLAIM to get here.\n\t */\n\tif (oc->gfp_mask && !(oc->gfp_mask & __GFP_FS))\n\t\treturn true;\n\n\t/*\n\t * Check if there were limitations on the allocation (only relevant for\n\t * NUMA and memcg) that may require different handling.\n\t */\n\tconstraint = constrained_alloc(oc);\n\tif (constraint != CONSTRAINT_MEMORY_POLICY)\n\t\toc->nodemask = NULL;\n\tcheck_panic_on_oom(oc, constraint);\n\n\tif (!is_memcg_oom(oc) && sysctl_oom_kill_allocating_task &&\n\t    current->mm && !oom_unkillable_task(current, NULL, oc->nodemask) &&\n\t    current->signal->oom_score_adj != OOM_SCORE_ADJ_MIN) {\n\t\tget_task_struct(current);\n\t\toc->chosen = current;\n\t\toom_kill_process(oc, \"Out of memory (oom_kill_allocating_task)\");\n\t\treturn true;\n\t}\n\n\tselect_bad_process(oc);\n\t/* Found nothing?!?! */\n\tif (!oc->chosen) {\n\t\tdump_header(oc, NULL);\n\t\tpr_warn(\"Out of memory and no killable processes...\\n\");\n\t\t/*\n\t\t * If we got here due to an actual allocation at the\n\t\t * system level, we cannot survive this and will enter\n\t\t * an endless loop in the allocator. Bail out now.\n\t\t */\n\t\tif (!is_sysrq_oom(oc) && !is_memcg_oom(oc))\n\t\t\tpanic(\"System is deadlocked on memory\\n\");\n\t}\n\tif (oc->chosen && oc->chosen != (void *)-1UL)\n\t\toom_kill_process(oc, !is_memcg_oom(oc) ? \"Out of memory\" :\n\t\t\t\t \"Memory cgroup out of memory\");\n\treturn !!oc->chosen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_suspended_storage",
          "args": [],
          "line": 3502
        },
        "resolved": true,
        "details": {
          "function_name": "pm_suspended_storage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "182-187",
          "snippet": "bool pm_suspended_storage(void)\n{\n\tif ((gfp_allowed_mask & (__GFP_IO | __GFP_FS)) == (__GFP_IO | __GFP_FS))\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "gfp_t gfp_allowed_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\ngfp_t gfp_allowed_mask;\n\nbool pm_suspended_storage(void)\n{\n\tif ((gfp_allowed_mask & (__GFP_IO | __GFP_FS)) == (__GFP_IO | __GFP_FS))\n\t\treturn false;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_page_from_freelist",
          "args": [
            "(gfp_mask | __GFP_HARDWALL) &\n\t\t\t\t      ~__GFP_DIRECT_RECLAIM",
            "order",
            "ALLOC_WMARK_HIGH|ALLOC_CPUSET",
            "ac"
          ],
          "line": 3479
        },
        "resolved": true,
        "details": {
          "function_name": "get_page_from_freelist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3260-3378",
          "snippet": "static struct page *\nget_page_from_freelist(gfp_t gfp_mask, unsigned int order, int alloc_flags,\n\t\t\t\t\t\tconst struct alloc_context *ac)\n{\n\tstruct zoneref *z = ac->preferred_zoneref;\n\tstruct zone *zone;\n\tstruct pglist_data *last_pgdat_dirty_limit = NULL;\n\n\t/*\n\t * Scan zonelist, looking for a zone with enough free.\n\t * See also __cpuset_node_allowed() comment in kernel/cpuset.c.\n\t */\n\tfor_next_zone_zonelist_nodemask(zone, z, ac->zonelist, ac->high_zoneidx,\n\t\t\t\t\t\t\t\tac->nodemask) {\n\t\tstruct page *page;\n\t\tunsigned long mark;\n\n\t\tif (cpusets_enabled() &&\n\t\t\t(alloc_flags & ALLOC_CPUSET) &&\n\t\t\t!__cpuset_zone_allowed(zone, gfp_mask))\n\t\t\t\tcontinue;\n\t\t/*\n\t\t * When allocating a page cache page for writing, we\n\t\t * want to get it from a node that is within its dirty\n\t\t * limit, such that no single node holds more than its\n\t\t * proportional share of globally allowed dirty pages.\n\t\t * The dirty limits take into account the node's\n\t\t * lowmem reserves and high watermark so that kswapd\n\t\t * should be able to balance it without having to\n\t\t * write pages from its LRU list.\n\t\t *\n\t\t * XXX: For now, allow allocations to potentially\n\t\t * exceed the per-node dirty limit in the slowpath\n\t\t * (spread_dirty_pages unset) before going into reclaim,\n\t\t * which is important when on a NUMA setup the allowed\n\t\t * nodes are together not big enough to reach the\n\t\t * global limit.  The proper fix for these situations\n\t\t * will require awareness of nodes in the\n\t\t * dirty-throttling and the flusher threads.\n\t\t */\n\t\tif (ac->spread_dirty_pages) {\n\t\t\tif (last_pgdat_dirty_limit == zone->zone_pgdat)\n\t\t\t\tcontinue;\n\n\t\t\tif (!node_dirty_ok(zone->zone_pgdat)) {\n\t\t\t\tlast_pgdat_dirty_limit = zone->zone_pgdat;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tmark = zone->watermark[alloc_flags & ALLOC_WMARK_MASK];\n\t\tif (!zone_watermark_fast(zone, order, mark,\n\t\t\t\t       ac_classzone_idx(ac), alloc_flags)) {\n\t\t\tint ret;\n\n#ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT\n\t\t\t/*\n\t\t\t * Watermark failed for this zone, but see if we can\n\t\t\t * grow this zone if it contains deferred pages.\n\t\t\t */\n\t\t\tif (static_branch_unlikely(&deferred_pages)) {\n\t\t\t\tif (_deferred_grow_zone(zone, order))\n\t\t\t\t\tgoto try_this_zone;\n\t\t\t}\n#endif\n\t\t\t/* Checked here to keep the fast path fast */\n\t\t\tBUILD_BUG_ON(ALLOC_NO_WATERMARKS < NR_WMARK);\n\t\t\tif (alloc_flags & ALLOC_NO_WATERMARKS)\n\t\t\t\tgoto try_this_zone;\n\n\t\t\tif (node_reclaim_mode == 0 ||\n\t\t\t    !zone_allows_reclaim(ac->preferred_zoneref->zone, zone))\n\t\t\t\tcontinue;\n\n\t\t\tret = node_reclaim(zone->zone_pgdat, gfp_mask, order);\n\t\t\tswitch (ret) {\n\t\t\tcase NODE_RECLAIM_NOSCAN:\n\t\t\t\t/* did not scan */\n\t\t\t\tcontinue;\n\t\t\tcase NODE_RECLAIM_FULL:\n\t\t\t\t/* scanned but unreclaimable */\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\t/* did we reclaim enough */\n\t\t\t\tif (zone_watermark_ok(zone, order, mark,\n\t\t\t\t\t\tac_classzone_idx(ac), alloc_flags))\n\t\t\t\t\tgoto try_this_zone;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\ntry_this_zone:\n\t\tpage = rmqueue(ac->preferred_zoneref->zone, zone, order,\n\t\t\t\tgfp_mask, alloc_flags, ac->migratetype);\n\t\tif (page) {\n\t\t\tprep_new_page(page, order, gfp_mask, alloc_flags);\n\n\t\t\t/*\n\t\t\t * If this is a high-order atomic allocation then check\n\t\t\t * if the pageblock should be reserved for the future\n\t\t\t */\n\t\t\tif (unlikely(order && (alloc_flags & ALLOC_HARDER)))\n\t\t\t\treserve_highatomic_pageblock(page, zone, order);\n\n\t\t\treturn page;\n\t\t} else {\n#ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT\n\t\t\t/* Try again if zone has deferred pages */\n\t\t\tif (static_branch_unlikely(&deferred_pages)) {\n\t\t\t\tif (_deferred_grow_zone(zone, order))\n\t\t\t\t\tgoto try_this_zone;\n\t\t\t}\n#endif\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic struct page *\nget_page_from_freelist(gfp_t gfp_mask, unsigned int order, int alloc_flags,\n\t\t\t\t\t\tconst struct alloc_context *ac)\n{\n\tstruct zoneref *z = ac->preferred_zoneref;\n\tstruct zone *zone;\n\tstruct pglist_data *last_pgdat_dirty_limit = NULL;\n\n\t/*\n\t * Scan zonelist, looking for a zone with enough free.\n\t * See also __cpuset_node_allowed() comment in kernel/cpuset.c.\n\t */\n\tfor_next_zone_zonelist_nodemask(zone, z, ac->zonelist, ac->high_zoneidx,\n\t\t\t\t\t\t\t\tac->nodemask) {\n\t\tstruct page *page;\n\t\tunsigned long mark;\n\n\t\tif (cpusets_enabled() &&\n\t\t\t(alloc_flags & ALLOC_CPUSET) &&\n\t\t\t!__cpuset_zone_allowed(zone, gfp_mask))\n\t\t\t\tcontinue;\n\t\t/*\n\t\t * When allocating a page cache page for writing, we\n\t\t * want to get it from a node that is within its dirty\n\t\t * limit, such that no single node holds more than its\n\t\t * proportional share of globally allowed dirty pages.\n\t\t * The dirty limits take into account the node's\n\t\t * lowmem reserves and high watermark so that kswapd\n\t\t * should be able to balance it without having to\n\t\t * write pages from its LRU list.\n\t\t *\n\t\t * XXX: For now, allow allocations to potentially\n\t\t * exceed the per-node dirty limit in the slowpath\n\t\t * (spread_dirty_pages unset) before going into reclaim,\n\t\t * which is important when on a NUMA setup the allowed\n\t\t * nodes are together not big enough to reach the\n\t\t * global limit.  The proper fix for these situations\n\t\t * will require awareness of nodes in the\n\t\t * dirty-throttling and the flusher threads.\n\t\t */\n\t\tif (ac->spread_dirty_pages) {\n\t\t\tif (last_pgdat_dirty_limit == zone->zone_pgdat)\n\t\t\t\tcontinue;\n\n\t\t\tif (!node_dirty_ok(zone->zone_pgdat)) {\n\t\t\t\tlast_pgdat_dirty_limit = zone->zone_pgdat;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tmark = zone->watermark[alloc_flags & ALLOC_WMARK_MASK];\n\t\tif (!zone_watermark_fast(zone, order, mark,\n\t\t\t\t       ac_classzone_idx(ac), alloc_flags)) {\n\t\t\tint ret;\n\n#ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT\n\t\t\t/*\n\t\t\t * Watermark failed for this zone, but see if we can\n\t\t\t * grow this zone if it contains deferred pages.\n\t\t\t */\n\t\t\tif (static_branch_unlikely(&deferred_pages)) {\n\t\t\t\tif (_deferred_grow_zone(zone, order))\n\t\t\t\t\tgoto try_this_zone;\n\t\t\t}\n#endif\n\t\t\t/* Checked here to keep the fast path fast */\n\t\t\tBUILD_BUG_ON(ALLOC_NO_WATERMARKS < NR_WMARK);\n\t\t\tif (alloc_flags & ALLOC_NO_WATERMARKS)\n\t\t\t\tgoto try_this_zone;\n\n\t\t\tif (node_reclaim_mode == 0 ||\n\t\t\t    !zone_allows_reclaim(ac->preferred_zoneref->zone, zone))\n\t\t\t\tcontinue;\n\n\t\t\tret = node_reclaim(zone->zone_pgdat, gfp_mask, order);\n\t\t\tswitch (ret) {\n\t\t\tcase NODE_RECLAIM_NOSCAN:\n\t\t\t\t/* did not scan */\n\t\t\t\tcontinue;\n\t\t\tcase NODE_RECLAIM_FULL:\n\t\t\t\t/* scanned but unreclaimable */\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\t/* did we reclaim enough */\n\t\t\t\tif (zone_watermark_ok(zone, order, mark,\n\t\t\t\t\t\tac_classzone_idx(ac), alloc_flags))\n\t\t\t\t\tgoto try_this_zone;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\ntry_this_zone:\n\t\tpage = rmqueue(ac->preferred_zoneref->zone, zone, order,\n\t\t\t\tgfp_mask, alloc_flags, ac->migratetype);\n\t\tif (page) {\n\t\t\tprep_new_page(page, order, gfp_mask, alloc_flags);\n\n\t\t\t/*\n\t\t\t * If this is a high-order atomic allocation then check\n\t\t\t * if the pageblock should be reserved for the future\n\t\t\t */\n\t\t\tif (unlikely(order && (alloc_flags & ALLOC_HARDER)))\n\t\t\t\treserve_highatomic_pageblock(page, zone, order);\n\n\t\t\treturn page;\n\t\t} else {\n#ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT\n\t\t\t/* Try again if zone has deferred pages */\n\t\t\tif (static_branch_unlikely(&deferred_pages)) {\n\t\t\t\tif (_deferred_grow_zone(zone, order))\n\t\t\t\t\tgoto try_this_zone;\n\t\t\t}\n#endif\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_timeout_uninterruptible",
          "args": [
            "1"
          ],
          "line": 3468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_trylock",
          "args": [
            "&oom_lock"
          ],
          "line": 3466
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline struct page *\n__alloc_pages_may_oom(gfp_t gfp_mask, unsigned int order,\n\tconst struct alloc_context *ac, unsigned long *did_some_progress)\n{\n\tstruct oom_control oc = {\n\t\t.zonelist = ac->zonelist,\n\t\t.nodemask = ac->nodemask,\n\t\t.memcg = NULL,\n\t\t.gfp_mask = gfp_mask,\n\t\t.order = order,\n\t};\n\tstruct page *page;\n\n\t*did_some_progress = 0;\n\n\t/*\n\t * Acquire the oom lock.  If that fails, somebody else is\n\t * making progress for us.\n\t */\n\tif (!mutex_trylock(&oom_lock)) {\n\t\t*did_some_progress = 1;\n\t\tschedule_timeout_uninterruptible(1);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * Go through the zonelist yet one more time, keep very high watermark\n\t * here, this is only to catch a parallel oom killing, we must fail if\n\t * we're still under heavy pressure. But make sure that this reclaim\n\t * attempt shall not depend on __GFP_DIRECT_RECLAIM && !__GFP_NORETRY\n\t * allocation which will never fail due to oom_lock already held.\n\t */\n\tpage = get_page_from_freelist((gfp_mask | __GFP_HARDWALL) &\n\t\t\t\t      ~__GFP_DIRECT_RECLAIM, order,\n\t\t\t\t      ALLOC_WMARK_HIGH|ALLOC_CPUSET, ac);\n\tif (page)\n\t\tgoto out;\n\n\t/* Coredumps can quickly deplete all memory reserves */\n\tif (current->flags & PF_DUMPCORE)\n\t\tgoto out;\n\t/* The OOM killer will not help higher order allocs */\n\tif (order > PAGE_ALLOC_COSTLY_ORDER)\n\t\tgoto out;\n\t/*\n\t * We have already exhausted all our reclaim opportunities without any\n\t * success so it is time to admit defeat. We will skip the OOM killer\n\t * because it is very likely that the caller has a more reasonable\n\t * fallback than shooting a random task.\n\t */\n\tif (gfp_mask & __GFP_RETRY_MAYFAIL)\n\t\tgoto out;\n\t/* The OOM killer does not needlessly kill tasks for lowmem */\n\tif (ac->high_zoneidx < ZONE_NORMAL)\n\t\tgoto out;\n\tif (pm_suspended_storage())\n\t\tgoto out;\n\t/*\n\t * XXX: GFP_NOFS allocations should rather fail than rely on\n\t * other request to make a forward progress.\n\t * We are in an unfortunate situation where out_of_memory cannot\n\t * do much for this context but let's try it to at least get\n\t * access to memory reserved if the current task is killed (see\n\t * out_of_memory). Once filesystems are ready to handle allocation\n\t * failures more gracefully we should just bail out here.\n\t */\n\n\t/* The OOM killer may not free memory on a specific node */\n\tif (gfp_mask & __GFP_THISNODE)\n\t\tgoto out;\n\n\t/* Exhausted what can be done so it's blame time */\n\tif (out_of_memory(&oc) || WARN_ON_ONCE(gfp_mask & __GFP_NOFAIL)) {\n\t\t*did_some_progress = 1;\n\n\t\t/*\n\t\t * Help non-failing allocations by giving them access to memory\n\t\t * reserves\n\t\t */\n\t\tif (gfp_mask & __GFP_NOFAIL)\n\t\t\tpage = __alloc_pages_cpuset_fallback(gfp_mask, order,\n\t\t\t\t\tALLOC_NO_WATERMARKS, ac);\n\t}\nout:\n\tmutex_unlock(&oom_lock);\n\treturn page;\n}"
  },
  {
    "function_name": "__alloc_pages_cpuset_fallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "3427-3445",
    "snippet": "static inline struct page *\n__alloc_pages_cpuset_fallback(gfp_t gfp_mask, unsigned int order,\n\t\t\t      unsigned int alloc_flags,\n\t\t\t      const struct alloc_context *ac)\n{\n\tstruct page *page;\n\n\tpage = get_page_from_freelist(gfp_mask, order,\n\t\t\talloc_flags|ALLOC_CPUSET, ac);\n\t/*\n\t * fallback to ignore cpuset restriction if our nodes\n\t * are depleted\n\t */\n\tif (!page)\n\t\tpage = get_page_from_freelist(gfp_mask, order,\n\t\t\t\talloc_flags, ac);\n\n\treturn page;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);",
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_page_from_freelist",
          "args": [
            "gfp_mask",
            "order",
            "alloc_flags",
            "ac"
          ],
          "line": 3441
        },
        "resolved": true,
        "details": {
          "function_name": "get_page_from_freelist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3260-3378",
          "snippet": "static struct page *\nget_page_from_freelist(gfp_t gfp_mask, unsigned int order, int alloc_flags,\n\t\t\t\t\t\tconst struct alloc_context *ac)\n{\n\tstruct zoneref *z = ac->preferred_zoneref;\n\tstruct zone *zone;\n\tstruct pglist_data *last_pgdat_dirty_limit = NULL;\n\n\t/*\n\t * Scan zonelist, looking for a zone with enough free.\n\t * See also __cpuset_node_allowed() comment in kernel/cpuset.c.\n\t */\n\tfor_next_zone_zonelist_nodemask(zone, z, ac->zonelist, ac->high_zoneidx,\n\t\t\t\t\t\t\t\tac->nodemask) {\n\t\tstruct page *page;\n\t\tunsigned long mark;\n\n\t\tif (cpusets_enabled() &&\n\t\t\t(alloc_flags & ALLOC_CPUSET) &&\n\t\t\t!__cpuset_zone_allowed(zone, gfp_mask))\n\t\t\t\tcontinue;\n\t\t/*\n\t\t * When allocating a page cache page for writing, we\n\t\t * want to get it from a node that is within its dirty\n\t\t * limit, such that no single node holds more than its\n\t\t * proportional share of globally allowed dirty pages.\n\t\t * The dirty limits take into account the node's\n\t\t * lowmem reserves and high watermark so that kswapd\n\t\t * should be able to balance it without having to\n\t\t * write pages from its LRU list.\n\t\t *\n\t\t * XXX: For now, allow allocations to potentially\n\t\t * exceed the per-node dirty limit in the slowpath\n\t\t * (spread_dirty_pages unset) before going into reclaim,\n\t\t * which is important when on a NUMA setup the allowed\n\t\t * nodes are together not big enough to reach the\n\t\t * global limit.  The proper fix for these situations\n\t\t * will require awareness of nodes in the\n\t\t * dirty-throttling and the flusher threads.\n\t\t */\n\t\tif (ac->spread_dirty_pages) {\n\t\t\tif (last_pgdat_dirty_limit == zone->zone_pgdat)\n\t\t\t\tcontinue;\n\n\t\t\tif (!node_dirty_ok(zone->zone_pgdat)) {\n\t\t\t\tlast_pgdat_dirty_limit = zone->zone_pgdat;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tmark = zone->watermark[alloc_flags & ALLOC_WMARK_MASK];\n\t\tif (!zone_watermark_fast(zone, order, mark,\n\t\t\t\t       ac_classzone_idx(ac), alloc_flags)) {\n\t\t\tint ret;\n\n#ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT\n\t\t\t/*\n\t\t\t * Watermark failed for this zone, but see if we can\n\t\t\t * grow this zone if it contains deferred pages.\n\t\t\t */\n\t\t\tif (static_branch_unlikely(&deferred_pages)) {\n\t\t\t\tif (_deferred_grow_zone(zone, order))\n\t\t\t\t\tgoto try_this_zone;\n\t\t\t}\n#endif\n\t\t\t/* Checked here to keep the fast path fast */\n\t\t\tBUILD_BUG_ON(ALLOC_NO_WATERMARKS < NR_WMARK);\n\t\t\tif (alloc_flags & ALLOC_NO_WATERMARKS)\n\t\t\t\tgoto try_this_zone;\n\n\t\t\tif (node_reclaim_mode == 0 ||\n\t\t\t    !zone_allows_reclaim(ac->preferred_zoneref->zone, zone))\n\t\t\t\tcontinue;\n\n\t\t\tret = node_reclaim(zone->zone_pgdat, gfp_mask, order);\n\t\t\tswitch (ret) {\n\t\t\tcase NODE_RECLAIM_NOSCAN:\n\t\t\t\t/* did not scan */\n\t\t\t\tcontinue;\n\t\t\tcase NODE_RECLAIM_FULL:\n\t\t\t\t/* scanned but unreclaimable */\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\t/* did we reclaim enough */\n\t\t\t\tif (zone_watermark_ok(zone, order, mark,\n\t\t\t\t\t\tac_classzone_idx(ac), alloc_flags))\n\t\t\t\t\tgoto try_this_zone;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\ntry_this_zone:\n\t\tpage = rmqueue(ac->preferred_zoneref->zone, zone, order,\n\t\t\t\tgfp_mask, alloc_flags, ac->migratetype);\n\t\tif (page) {\n\t\t\tprep_new_page(page, order, gfp_mask, alloc_flags);\n\n\t\t\t/*\n\t\t\t * If this is a high-order atomic allocation then check\n\t\t\t * if the pageblock should be reserved for the future\n\t\t\t */\n\t\t\tif (unlikely(order && (alloc_flags & ALLOC_HARDER)))\n\t\t\t\treserve_highatomic_pageblock(page, zone, order);\n\n\t\t\treturn page;\n\t\t} else {\n#ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT\n\t\t\t/* Try again if zone has deferred pages */\n\t\t\tif (static_branch_unlikely(&deferred_pages)) {\n\t\t\t\tif (_deferred_grow_zone(zone, order))\n\t\t\t\t\tgoto try_this_zone;\n\t\t\t}\n#endif\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic struct page *\nget_page_from_freelist(gfp_t gfp_mask, unsigned int order, int alloc_flags,\n\t\t\t\t\t\tconst struct alloc_context *ac)\n{\n\tstruct zoneref *z = ac->preferred_zoneref;\n\tstruct zone *zone;\n\tstruct pglist_data *last_pgdat_dirty_limit = NULL;\n\n\t/*\n\t * Scan zonelist, looking for a zone with enough free.\n\t * See also __cpuset_node_allowed() comment in kernel/cpuset.c.\n\t */\n\tfor_next_zone_zonelist_nodemask(zone, z, ac->zonelist, ac->high_zoneidx,\n\t\t\t\t\t\t\t\tac->nodemask) {\n\t\tstruct page *page;\n\t\tunsigned long mark;\n\n\t\tif (cpusets_enabled() &&\n\t\t\t(alloc_flags & ALLOC_CPUSET) &&\n\t\t\t!__cpuset_zone_allowed(zone, gfp_mask))\n\t\t\t\tcontinue;\n\t\t/*\n\t\t * When allocating a page cache page for writing, we\n\t\t * want to get it from a node that is within its dirty\n\t\t * limit, such that no single node holds more than its\n\t\t * proportional share of globally allowed dirty pages.\n\t\t * The dirty limits take into account the node's\n\t\t * lowmem reserves and high watermark so that kswapd\n\t\t * should be able to balance it without having to\n\t\t * write pages from its LRU list.\n\t\t *\n\t\t * XXX: For now, allow allocations to potentially\n\t\t * exceed the per-node dirty limit in the slowpath\n\t\t * (spread_dirty_pages unset) before going into reclaim,\n\t\t * which is important when on a NUMA setup the allowed\n\t\t * nodes are together not big enough to reach the\n\t\t * global limit.  The proper fix for these situations\n\t\t * will require awareness of nodes in the\n\t\t * dirty-throttling and the flusher threads.\n\t\t */\n\t\tif (ac->spread_dirty_pages) {\n\t\t\tif (last_pgdat_dirty_limit == zone->zone_pgdat)\n\t\t\t\tcontinue;\n\n\t\t\tif (!node_dirty_ok(zone->zone_pgdat)) {\n\t\t\t\tlast_pgdat_dirty_limit = zone->zone_pgdat;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tmark = zone->watermark[alloc_flags & ALLOC_WMARK_MASK];\n\t\tif (!zone_watermark_fast(zone, order, mark,\n\t\t\t\t       ac_classzone_idx(ac), alloc_flags)) {\n\t\t\tint ret;\n\n#ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT\n\t\t\t/*\n\t\t\t * Watermark failed for this zone, but see if we can\n\t\t\t * grow this zone if it contains deferred pages.\n\t\t\t */\n\t\t\tif (static_branch_unlikely(&deferred_pages)) {\n\t\t\t\tif (_deferred_grow_zone(zone, order))\n\t\t\t\t\tgoto try_this_zone;\n\t\t\t}\n#endif\n\t\t\t/* Checked here to keep the fast path fast */\n\t\t\tBUILD_BUG_ON(ALLOC_NO_WATERMARKS < NR_WMARK);\n\t\t\tif (alloc_flags & ALLOC_NO_WATERMARKS)\n\t\t\t\tgoto try_this_zone;\n\n\t\t\tif (node_reclaim_mode == 0 ||\n\t\t\t    !zone_allows_reclaim(ac->preferred_zoneref->zone, zone))\n\t\t\t\tcontinue;\n\n\t\t\tret = node_reclaim(zone->zone_pgdat, gfp_mask, order);\n\t\t\tswitch (ret) {\n\t\t\tcase NODE_RECLAIM_NOSCAN:\n\t\t\t\t/* did not scan */\n\t\t\t\tcontinue;\n\t\t\tcase NODE_RECLAIM_FULL:\n\t\t\t\t/* scanned but unreclaimable */\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\t/* did we reclaim enough */\n\t\t\t\tif (zone_watermark_ok(zone, order, mark,\n\t\t\t\t\t\tac_classzone_idx(ac), alloc_flags))\n\t\t\t\t\tgoto try_this_zone;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\ntry_this_zone:\n\t\tpage = rmqueue(ac->preferred_zoneref->zone, zone, order,\n\t\t\t\tgfp_mask, alloc_flags, ac->migratetype);\n\t\tif (page) {\n\t\t\tprep_new_page(page, order, gfp_mask, alloc_flags);\n\n\t\t\t/*\n\t\t\t * If this is a high-order atomic allocation then check\n\t\t\t * if the pageblock should be reserved for the future\n\t\t\t */\n\t\t\tif (unlikely(order && (alloc_flags & ALLOC_HARDER)))\n\t\t\t\treserve_highatomic_pageblock(page, zone, order);\n\n\t\t\treturn page;\n\t\t} else {\n#ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT\n\t\t\t/* Try again if zone has deferred pages */\n\t\t\tif (static_branch_unlikely(&deferred_pages)) {\n\t\t\t\tif (_deferred_grow_zone(zone, order))\n\t\t\t\t\tgoto try_this_zone;\n\t\t\t}\n#endif\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline struct page *\n__alloc_pages_cpuset_fallback(gfp_t gfp_mask, unsigned int order,\n\t\t\t      unsigned int alloc_flags,\n\t\t\t      const struct alloc_context *ac)\n{\n\tstruct page *page;\n\n\tpage = get_page_from_freelist(gfp_mask, order,\n\t\t\talloc_flags|ALLOC_CPUSET, ac);\n\t/*\n\t * fallback to ignore cpuset restriction if our nodes\n\t * are depleted\n\t */\n\tif (!page)\n\t\tpage = get_page_from_freelist(gfp_mask, order,\n\t\t\t\talloc_flags, ac);\n\n\treturn page;\n}"
  },
  {
    "function_name": "warn_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "3403-3425",
    "snippet": "void warn_alloc(gfp_t gfp_mask, nodemask_t *nodemask, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstatic DEFINE_RATELIMIT_STATE(nopage_rs, DEFAULT_RATELIMIT_INTERVAL,\n\t\t\t\t      DEFAULT_RATELIMIT_BURST);\n\n\tif ((gfp_mask & __GFP_NOWARN) || !__ratelimit(&nopage_rs))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"%s: %pV, mode:%#x(%pGg), nodemask=%*pbl\\n\",\n\t\t\tcurrent->comm, &vaf, gfp_mask, &gfp_mask,\n\t\t\tnodemask_pr_args(nodemask));\n\tva_end(args);\n\n\tcpuset_print_current_mems_allowed();\n\n\tdump_stack();\n\twarn_alloc_show_mem(gfp_mask, nodemask);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "warn_alloc_show_mem",
          "args": [
            "gfp_mask",
            "nodemask"
          ],
          "line": 3424
        },
        "resolved": true,
        "details": {
          "function_name": "warn_alloc_show_mem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3380-3401",
          "snippet": "static void warn_alloc_show_mem(gfp_t gfp_mask, nodemask_t *nodemask)\n{\n\tunsigned int filter = SHOW_MEM_FILTER_NODES;\n\tstatic DEFINE_RATELIMIT_STATE(show_mem_rs, HZ, 1);\n\n\tif (!__ratelimit(&show_mem_rs))\n\t\treturn;\n\n\t/*\n\t * This documents exceptions given to allocations in certain\n\t * contexts that are allowed to allocate outside current's set\n\t * of allowed nodes.\n\t */\n\tif (!(gfp_mask & __GFP_NOMEMALLOC))\n\t\tif (tsk_is_oom_victim(current) ||\n\t\t    (current->flags & (PF_MEMALLOC | PF_EXITING)))\n\t\t\tfilter &= ~SHOW_MEM_FILTER_NODES;\n\tif (in_interrupt() || !(gfp_mask & __GFP_DIRECT_RECLAIM))\n\t\tfilter &= ~SHOW_MEM_FILTER_NODES;\n\n\tshow_mem(filter, nodemask);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void warn_alloc_show_mem(gfp_t gfp_mask, nodemask_t *nodemask)\n{\n\tunsigned int filter = SHOW_MEM_FILTER_NODES;\n\tstatic DEFINE_RATELIMIT_STATE(show_mem_rs, HZ, 1);\n\n\tif (!__ratelimit(&show_mem_rs))\n\t\treturn;\n\n\t/*\n\t * This documents exceptions given to allocations in certain\n\t * contexts that are allowed to allocate outside current's set\n\t * of allowed nodes.\n\t */\n\tif (!(gfp_mask & __GFP_NOMEMALLOC))\n\t\tif (tsk_is_oom_victim(current) ||\n\t\t    (current->flags & (PF_MEMALLOC | PF_EXITING)))\n\t\t\tfilter &= ~SHOW_MEM_FILTER_NODES;\n\tif (in_interrupt() || !(gfp_mask & __GFP_DIRECT_RECLAIM))\n\t\tfilter &= ~SHOW_MEM_FILTER_NODES;\n\n\tshow_mem(filter, nodemask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 3423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuset_print_current_mems_allowed",
          "args": [],
          "line": 3421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 3419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: %pV, mode:%#x(%pGg), nodemask=%*pbl\\n\"",
            "current->comm",
            "&vaf",
            "gfp_mask",
            "&gfp_mask",
            "nodemask_pr_args(nodemask)"
          ],
          "line": 3416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodemask_pr_args",
          "args": [
            "nodemask"
          ],
          "line": 3418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 3413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ratelimit",
          "args": [
            "&nopage_rs"
          ],
          "line": 3410
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid warn_alloc(gfp_t gfp_mask, nodemask_t *nodemask, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstatic DEFINE_RATELIMIT_STATE(nopage_rs, DEFAULT_RATELIMIT_INTERVAL,\n\t\t\t\t      DEFAULT_RATELIMIT_BURST);\n\n\tif ((gfp_mask & __GFP_NOWARN) || !__ratelimit(&nopage_rs))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"%s: %pV, mode:%#x(%pGg), nodemask=%*pbl\\n\",\n\t\t\tcurrent->comm, &vaf, gfp_mask, &gfp_mask,\n\t\t\tnodemask_pr_args(nodemask));\n\tva_end(args);\n\n\tcpuset_print_current_mems_allowed();\n\n\tdump_stack();\n\twarn_alloc_show_mem(gfp_mask, nodemask);\n}"
  },
  {
    "function_name": "warn_alloc_show_mem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "3380-3401",
    "snippet": "static void warn_alloc_show_mem(gfp_t gfp_mask, nodemask_t *nodemask)\n{\n\tunsigned int filter = SHOW_MEM_FILTER_NODES;\n\tstatic DEFINE_RATELIMIT_STATE(show_mem_rs, HZ, 1);\n\n\tif (!__ratelimit(&show_mem_rs))\n\t\treturn;\n\n\t/*\n\t * This documents exceptions given to allocations in certain\n\t * contexts that are allowed to allocate outside current's set\n\t * of allowed nodes.\n\t */\n\tif (!(gfp_mask & __GFP_NOMEMALLOC))\n\t\tif (tsk_is_oom_victim(current) ||\n\t\t    (current->flags & (PF_MEMALLOC | PF_EXITING)))\n\t\t\tfilter &= ~SHOW_MEM_FILTER_NODES;\n\tif (in_interrupt() || !(gfp_mask & __GFP_DIRECT_RECLAIM))\n\t\tfilter &= ~SHOW_MEM_FILTER_NODES;\n\n\tshow_mem(filter, nodemask);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "show_mem",
          "args": [
            "filter",
            "nodemask"
          ],
          "line": 3400
        },
        "resolved": true,
        "details": {
          "function_name": "warn_alloc_show_mem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3380-3401",
          "snippet": "static void warn_alloc_show_mem(gfp_t gfp_mask, nodemask_t *nodemask)\n{\n\tunsigned int filter = SHOW_MEM_FILTER_NODES;\n\tstatic DEFINE_RATELIMIT_STATE(show_mem_rs, HZ, 1);\n\n\tif (!__ratelimit(&show_mem_rs))\n\t\treturn;\n\n\t/*\n\t * This documents exceptions given to allocations in certain\n\t * contexts that are allowed to allocate outside current's set\n\t * of allowed nodes.\n\t */\n\tif (!(gfp_mask & __GFP_NOMEMALLOC))\n\t\tif (tsk_is_oom_victim(current) ||\n\t\t    (current->flags & (PF_MEMALLOC | PF_EXITING)))\n\t\t\tfilter &= ~SHOW_MEM_FILTER_NODES;\n\tif (in_interrupt() || !(gfp_mask & __GFP_DIRECT_RECLAIM))\n\t\tfilter &= ~SHOW_MEM_FILTER_NODES;\n\n\tshow_mem(filter, nodemask);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "in_interrupt",
          "args": [],
          "line": 3397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tsk_is_oom_victim",
          "args": [
            "current"
          ],
          "line": 3394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ratelimit",
          "args": [
            "&show_mem_rs"
          ],
          "line": 3385
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void warn_alloc_show_mem(gfp_t gfp_mask, nodemask_t *nodemask)\n{\n\tunsigned int filter = SHOW_MEM_FILTER_NODES;\n\tstatic DEFINE_RATELIMIT_STATE(show_mem_rs, HZ, 1);\n\n\tif (!__ratelimit(&show_mem_rs))\n\t\treturn;\n\n\t/*\n\t * This documents exceptions given to allocations in certain\n\t * contexts that are allowed to allocate outside current's set\n\t * of allowed nodes.\n\t */\n\tif (!(gfp_mask & __GFP_NOMEMALLOC))\n\t\tif (tsk_is_oom_victim(current) ||\n\t\t    (current->flags & (PF_MEMALLOC | PF_EXITING)))\n\t\t\tfilter &= ~SHOW_MEM_FILTER_NODES;\n\tif (in_interrupt() || !(gfp_mask & __GFP_DIRECT_RECLAIM))\n\t\tfilter &= ~SHOW_MEM_FILTER_NODES;\n\n\tshow_mem(filter, nodemask);\n}"
  },
  {
    "function_name": "get_page_from_freelist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "3260-3378",
    "snippet": "static struct page *\nget_page_from_freelist(gfp_t gfp_mask, unsigned int order, int alloc_flags,\n\t\t\t\t\t\tconst struct alloc_context *ac)\n{\n\tstruct zoneref *z = ac->preferred_zoneref;\n\tstruct zone *zone;\n\tstruct pglist_data *last_pgdat_dirty_limit = NULL;\n\n\t/*\n\t * Scan zonelist, looking for a zone with enough free.\n\t * See also __cpuset_node_allowed() comment in kernel/cpuset.c.\n\t */\n\tfor_next_zone_zonelist_nodemask(zone, z, ac->zonelist, ac->high_zoneidx,\n\t\t\t\t\t\t\t\tac->nodemask) {\n\t\tstruct page *page;\n\t\tunsigned long mark;\n\n\t\tif (cpusets_enabled() &&\n\t\t\t(alloc_flags & ALLOC_CPUSET) &&\n\t\t\t!__cpuset_zone_allowed(zone, gfp_mask))\n\t\t\t\tcontinue;\n\t\t/*\n\t\t * When allocating a page cache page for writing, we\n\t\t * want to get it from a node that is within its dirty\n\t\t * limit, such that no single node holds more than its\n\t\t * proportional share of globally allowed dirty pages.\n\t\t * The dirty limits take into account the node's\n\t\t * lowmem reserves and high watermark so that kswapd\n\t\t * should be able to balance it without having to\n\t\t * write pages from its LRU list.\n\t\t *\n\t\t * XXX: For now, allow allocations to potentially\n\t\t * exceed the per-node dirty limit in the slowpath\n\t\t * (spread_dirty_pages unset) before going into reclaim,\n\t\t * which is important when on a NUMA setup the allowed\n\t\t * nodes are together not big enough to reach the\n\t\t * global limit.  The proper fix for these situations\n\t\t * will require awareness of nodes in the\n\t\t * dirty-throttling and the flusher threads.\n\t\t */\n\t\tif (ac->spread_dirty_pages) {\n\t\t\tif (last_pgdat_dirty_limit == zone->zone_pgdat)\n\t\t\t\tcontinue;\n\n\t\t\tif (!node_dirty_ok(zone->zone_pgdat)) {\n\t\t\t\tlast_pgdat_dirty_limit = zone->zone_pgdat;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tmark = zone->watermark[alloc_flags & ALLOC_WMARK_MASK];\n\t\tif (!zone_watermark_fast(zone, order, mark,\n\t\t\t\t       ac_classzone_idx(ac), alloc_flags)) {\n\t\t\tint ret;\n\n#ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT\n\t\t\t/*\n\t\t\t * Watermark failed for this zone, but see if we can\n\t\t\t * grow this zone if it contains deferred pages.\n\t\t\t */\n\t\t\tif (static_branch_unlikely(&deferred_pages)) {\n\t\t\t\tif (_deferred_grow_zone(zone, order))\n\t\t\t\t\tgoto try_this_zone;\n\t\t\t}\n#endif\n\t\t\t/* Checked here to keep the fast path fast */\n\t\t\tBUILD_BUG_ON(ALLOC_NO_WATERMARKS < NR_WMARK);\n\t\t\tif (alloc_flags & ALLOC_NO_WATERMARKS)\n\t\t\t\tgoto try_this_zone;\n\n\t\t\tif (node_reclaim_mode == 0 ||\n\t\t\t    !zone_allows_reclaim(ac->preferred_zoneref->zone, zone))\n\t\t\t\tcontinue;\n\n\t\t\tret = node_reclaim(zone->zone_pgdat, gfp_mask, order);\n\t\t\tswitch (ret) {\n\t\t\tcase NODE_RECLAIM_NOSCAN:\n\t\t\t\t/* did not scan */\n\t\t\t\tcontinue;\n\t\t\tcase NODE_RECLAIM_FULL:\n\t\t\t\t/* scanned but unreclaimable */\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\t/* did we reclaim enough */\n\t\t\t\tif (zone_watermark_ok(zone, order, mark,\n\t\t\t\t\t\tac_classzone_idx(ac), alloc_flags))\n\t\t\t\t\tgoto try_this_zone;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\ntry_this_zone:\n\t\tpage = rmqueue(ac->preferred_zoneref->zone, zone, order,\n\t\t\t\tgfp_mask, alloc_flags, ac->migratetype);\n\t\tif (page) {\n\t\t\tprep_new_page(page, order, gfp_mask, alloc_flags);\n\n\t\t\t/*\n\t\t\t * If this is a high-order atomic allocation then check\n\t\t\t * if the pageblock should be reserved for the future\n\t\t\t */\n\t\t\tif (unlikely(order && (alloc_flags & ALLOC_HARDER)))\n\t\t\t\treserve_highatomic_pageblock(page, zone, order);\n\n\t\t\treturn page;\n\t\t} else {\n#ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT\n\t\t\t/* Try again if zone has deferred pages */\n\t\t\tif (static_branch_unlikely(&deferred_pages)) {\n\t\t\t\tif (_deferred_grow_zone(zone, order))\n\t\t\t\t\tgoto try_this_zone;\n\t\t\t}\n#endif\n\t\t}\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);",
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_deferred_grow_zone",
          "args": [
            "zone",
            "order"
          ],
          "line": 3370
        },
        "resolved": true,
        "details": {
          "function_name": "_deferred_grow_zone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1712-1716",
          "snippet": "static bool __ref\n_deferred_grow_zone(struct zone *zone, unsigned int order)\n{\n\treturn deferred_grow_zone(zone, order);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool __ref\n_deferred_grow_zone(struct zone *zone, unsigned int order)\n{\n\treturn deferred_grow_zone(zone, order);\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_unlikely",
          "args": [
            "&deferred_pages"
          ],
          "line": 3369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reserve_highatomic_pageblock",
          "args": [
            "page",
            "zone",
            "order"
          ],
          "line": 3363
        },
        "resolved": true,
        "details": {
          "function_name": "reserve_highatomic_pageblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "2251-2282",
          "snippet": "static void reserve_highatomic_pageblock(struct page *page, struct zone *zone,\n\t\t\t\tunsigned int alloc_order)\n{\n\tint mt;\n\tunsigned long max_managed, flags;\n\n\t/*\n\t * Limit the number reserved to 1 pageblock or roughly 1% of a zone.\n\t * Check is race-prone but harmless.\n\t */\n\tmax_managed = (zone->managed_pages / 100) + pageblock_nr_pages;\n\tif (zone->nr_reserved_highatomic >= max_managed)\n\t\treturn;\n\n\tspin_lock_irqsave(&zone->lock, flags);\n\n\t/* Recheck the nr_reserved_highatomic limit under the lock */\n\tif (zone->nr_reserved_highatomic >= max_managed)\n\t\tgoto out_unlock;\n\n\t/* Yoink! */\n\tmt = get_pageblock_migratetype(page);\n\tif (!is_migrate_highatomic(mt) && !is_migrate_isolate(mt)\n\t    && !is_migrate_cma(mt)) {\n\t\tzone->nr_reserved_highatomic += pageblock_nr_pages;\n\t\tset_pageblock_migratetype(page, MIGRATE_HIGHATOMIC);\n\t\tmove_freepages_block(zone, page, MIGRATE_HIGHATOMIC, NULL);\n\t}\n\nout_unlock:\n\tspin_unlock_irqrestore(&zone->lock, flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic void reserve_highatomic_pageblock(struct page *page, struct zone *zone,\n\t\t\t\tunsigned int alloc_order)\n{\n\tint mt;\n\tunsigned long max_managed, flags;\n\n\t/*\n\t * Limit the number reserved to 1 pageblock or roughly 1% of a zone.\n\t * Check is race-prone but harmless.\n\t */\n\tmax_managed = (zone->managed_pages / 100) + pageblock_nr_pages;\n\tif (zone->nr_reserved_highatomic >= max_managed)\n\t\treturn;\n\n\tspin_lock_irqsave(&zone->lock, flags);\n\n\t/* Recheck the nr_reserved_highatomic limit under the lock */\n\tif (zone->nr_reserved_highatomic >= max_managed)\n\t\tgoto out_unlock;\n\n\t/* Yoink! */\n\tmt = get_pageblock_migratetype(page);\n\tif (!is_migrate_highatomic(mt) && !is_migrate_isolate(mt)\n\t    && !is_migrate_cma(mt)) {\n\t\tzone->nr_reserved_highatomic += pageblock_nr_pages;\n\t\tset_pageblock_migratetype(page, MIGRATE_HIGHATOMIC);\n\t\tmove_freepages_block(zone, page, MIGRATE_HIGHATOMIC, NULL);\n\t}\n\nout_unlock:\n\tspin_unlock_irqrestore(&zone->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "order && (alloc_flags & ALLOC_HARDER)"
          ],
          "line": 3362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prep_new_page",
          "args": [
            "page",
            "order",
            "gfp_mask",
            "alloc_flags"
          ],
          "line": 3356
        },
        "resolved": true,
        "details": {
          "function_name": "prep_new_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1921-1945",
          "snippet": "static void prep_new_page(struct page *page, unsigned int order, gfp_t gfp_flags,\n\t\t\t\t\t\t\tunsigned int alloc_flags)\n{\n\tint i;\n\n\tpost_alloc_hook(page, order, gfp_flags);\n\n\tif (!free_pages_prezeroed() && (gfp_flags & __GFP_ZERO))\n\t\tfor (i = 0; i < (1 << order); i++)\n\t\t\tclear_highpage(page + i);\n\n\tif (order && (gfp_flags & __GFP_COMP))\n\t\tprep_compound_page(page, order);\n\n\t/*\n\t * page is set pfmemalloc when ALLOC_NO_WATERMARKS was necessary to\n\t * allocate the page. The expectation is that the caller is taking\n\t * steps that will free more memory. The caller should avoid the page\n\t * being used for !PFMEMALLOC purposes.\n\t */\n\tif (alloc_flags & ALLOC_NO_WATERMARKS)\n\t\tset_page_pfmemalloc(page);\n\telse\n\t\tclear_page_pfmemalloc(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic void prep_new_page(struct page *page, unsigned int order, gfp_t gfp_flags,\n\t\t\t\t\t\t\tunsigned int alloc_flags)\n{\n\tint i;\n\n\tpost_alloc_hook(page, order, gfp_flags);\n\n\tif (!free_pages_prezeroed() && (gfp_flags & __GFP_ZERO))\n\t\tfor (i = 0; i < (1 << order); i++)\n\t\t\tclear_highpage(page + i);\n\n\tif (order && (gfp_flags & __GFP_COMP))\n\t\tprep_compound_page(page, order);\n\n\t/*\n\t * page is set pfmemalloc when ALLOC_NO_WATERMARKS was necessary to\n\t * allocate the page. The expectation is that the caller is taking\n\t * steps that will free more memory. The caller should avoid the page\n\t * being used for !PFMEMALLOC purposes.\n\t */\n\tif (alloc_flags & ALLOC_NO_WATERMARKS)\n\t\tset_page_pfmemalloc(page);\n\telse\n\t\tclear_page_pfmemalloc(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rmqueue",
          "args": [
            "ac->preferred_zoneref->zone",
            "zone",
            "order",
            "gfp_mask",
            "alloc_flags",
            "ac->migratetype"
          ],
          "line": 3353
        },
        "resolved": true,
        "details": {
          "function_name": "rmqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "2984-3033",
          "snippet": "static inline\nstruct page *rmqueue(struct zone *preferred_zone,\n\t\t\tstruct zone *zone, unsigned int order,\n\t\t\tgfp_t gfp_flags, unsigned int alloc_flags,\n\t\t\tint migratetype)\n{\n\tunsigned long flags;\n\tstruct page *page;\n\n\tif (likely(order == 0)) {\n\t\tpage = rmqueue_pcplist(preferred_zone, zone, order,\n\t\t\t\tgfp_flags, migratetype);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We most definitely don't want callers attempting to\n\t * allocate greater than order-1 page units with __GFP_NOFAIL.\n\t */\n\tWARN_ON_ONCE((gfp_flags & __GFP_NOFAIL) && (order > 1));\n\tspin_lock_irqsave(&zone->lock, flags);\n\n\tdo {\n\t\tpage = NULL;\n\t\tif (alloc_flags & ALLOC_HARDER) {\n\t\t\tpage = __rmqueue_smallest(zone, order, MIGRATE_HIGHATOMIC);\n\t\t\tif (page)\n\t\t\t\ttrace_mm_page_alloc_zone_locked(page, order, migratetype);\n\t\t}\n\t\tif (!page)\n\t\t\tpage = __rmqueue(zone, order, migratetype);\n\t} while (page && check_new_pages(page, order));\n\tspin_unlock(&zone->lock);\n\tif (!page)\n\t\tgoto failed;\n\t__mod_zone_freepage_state(zone, -(1 << order),\n\t\t\t\t  get_pcppage_migratetype(page));\n\n\t__count_zid_vm_events(PGALLOC, page_zonenum(page), 1 << order);\n\tzone_statistics(preferred_zone, zone);\n\tlocal_irq_restore(flags);\n\nout:\n\tVM_BUG_ON_PAGE(page && bad_range(zone, page), page);\n\treturn page;\n\nfailed:\n\tlocal_irq_restore(flags);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline\nstruct page *rmqueue(struct zone *preferred_zone,\n\t\t\tstruct zone *zone, unsigned int order,\n\t\t\tgfp_t gfp_flags, unsigned int alloc_flags,\n\t\t\tint migratetype)\n{\n\tunsigned long flags;\n\tstruct page *page;\n\n\tif (likely(order == 0)) {\n\t\tpage = rmqueue_pcplist(preferred_zone, zone, order,\n\t\t\t\tgfp_flags, migratetype);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We most definitely don't want callers attempting to\n\t * allocate greater than order-1 page units with __GFP_NOFAIL.\n\t */\n\tWARN_ON_ONCE((gfp_flags & __GFP_NOFAIL) && (order > 1));\n\tspin_lock_irqsave(&zone->lock, flags);\n\n\tdo {\n\t\tpage = NULL;\n\t\tif (alloc_flags & ALLOC_HARDER) {\n\t\t\tpage = __rmqueue_smallest(zone, order, MIGRATE_HIGHATOMIC);\n\t\t\tif (page)\n\t\t\t\ttrace_mm_page_alloc_zone_locked(page, order, migratetype);\n\t\t}\n\t\tif (!page)\n\t\t\tpage = __rmqueue(zone, order, migratetype);\n\t} while (page && check_new_pages(page, order));\n\tspin_unlock(&zone->lock);\n\tif (!page)\n\t\tgoto failed;\n\t__mod_zone_freepage_state(zone, -(1 << order),\n\t\t\t\t  get_pcppage_migratetype(page));\n\n\t__count_zid_vm_events(PGALLOC, page_zonenum(page), 1 << order);\n\tzone_statistics(preferred_zone, zone);\n\tlocal_irq_restore(flags);\n\nout:\n\tVM_BUG_ON_PAGE(page && bad_range(zone, page), page);\n\treturn page;\n\nfailed:\n\tlocal_irq_restore(flags);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zone_watermark_ok",
          "args": [
            "zone",
            "order",
            "mark",
            "ac_classzone_idx(ac)",
            "alloc_flags"
          ],
          "line": 3344
        },
        "resolved": true,
        "details": {
          "function_name": "zone_watermark_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3198-3203",
          "snippet": "bool zone_watermark_ok(struct zone *z, unsigned int order, unsigned long mark,\n\t\t      int classzone_idx, unsigned int alloc_flags)\n{\n\treturn __zone_watermark_ok(z, order, mark, classzone_idx, alloc_flags,\n\t\t\t\t\tzone_page_state(z, NR_FREE_PAGES));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nbool zone_watermark_ok(struct zone *z, unsigned int order, unsigned long mark,\n\t\t      int classzone_idx, unsigned int alloc_flags)\n{\n\treturn __zone_watermark_ok(z, order, mark, classzone_idx, alloc_flags,\n\t\t\t\t\tzone_page_state(z, NR_FREE_PAGES));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ac_classzone_idx",
          "args": [
            "ac"
          ],
          "line": 3345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_reclaim",
          "args": [
            "zone->zone_pgdat",
            "gfp_mask",
            "order"
          ],
          "line": 3334
        },
        "resolved": true,
        "details": {
          "function_name": "test_mem_cgroup_node_reclaimable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "1403-1414",
          "snippet": "static bool test_mem_cgroup_node_reclaimable(struct mem_cgroup *memcg,\n\t\tint nid, bool noswap)\n{\n\tif (mem_cgroup_node_nr_lru_pages(memcg, nid, LRU_ALL_FILE))\n\t\treturn true;\n\tif (noswap || !total_swap_pages)\n\t\treturn false;\n\tif (mem_cgroup_node_nr_lru_pages(memcg, nid, LRU_ALL_ANON))\n\t\treturn true;\n\treturn false;\n\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\n\nstatic bool test_mem_cgroup_node_reclaimable(struct mem_cgroup *memcg,\n\t\tint nid, bool noswap)\n{\n\tif (mem_cgroup_node_nr_lru_pages(memcg, nid, LRU_ALL_FILE))\n\t\treturn true;\n\tif (noswap || !total_swap_pages)\n\t\treturn false;\n\tif (mem_cgroup_node_nr_lru_pages(memcg, nid, LRU_ALL_ANON))\n\t\treturn true;\n\treturn false;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "zone_allows_reclaim",
          "args": [
            "ac->preferred_zoneref->zone",
            "zone"
          ],
          "line": 3331
        },
        "resolved": true,
        "details": {
          "function_name": "zone_allows_reclaim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3250-3253",
          "snippet": "static bool zone_allows_reclaim(struct zone *local_zone, struct zone *zone)\n{\n\treturn true;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool zone_allows_reclaim(struct zone *local_zone, struct zone *zone)\n{\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "ALLOC_NO_WATERMARKS < NR_WMARK"
          ],
          "line": 3326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_unlikely",
          "args": [
            "&deferred_pages"
          ],
          "line": 3320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_watermark_fast",
          "args": [
            "zone",
            "order",
            "mark",
            "ac_classzone_idx(ac)",
            "alloc_flags"
          ],
          "line": 3311
        },
        "resolved": true,
        "details": {
          "function_name": "zone_watermark_fast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3205-3229",
          "snippet": "static inline bool zone_watermark_fast(struct zone *z, unsigned int order,\n\t\tunsigned long mark, int classzone_idx, unsigned int alloc_flags)\n{\n\tlong free_pages = zone_page_state(z, NR_FREE_PAGES);\n\tlong cma_pages = 0;\n\n#ifdef CONFIG_CMA\n\t/* If allocation can't use CMA areas don't use free CMA pages */\n\tif (!(alloc_flags & ALLOC_CMA))\n\t\tcma_pages = zone_page_state(z, NR_FREE_CMA_PAGES);\n#endif\n\n\t/*\n\t * Fast check for order-0 only. If this fails then the reserves\n\t * need to be calculated. There is a corner case where the check\n\t * passes but only the high-order atomic reserve are free. If\n\t * the caller is !atomic then it'll uselessly search the free\n\t * list. That corner case is then slower but it is harmless.\n\t */\n\tif (!order && (free_pages - cma_pages) > mark + z->lowmem_reserve[classzone_idx])\n\t\treturn true;\n\n\treturn __zone_watermark_ok(z, order, mark, classzone_idx, alloc_flags,\n\t\t\t\t\tfree_pages);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline bool zone_watermark_fast(struct zone *z, unsigned int order,\n\t\tunsigned long mark, int classzone_idx, unsigned int alloc_flags)\n{\n\tlong free_pages = zone_page_state(z, NR_FREE_PAGES);\n\tlong cma_pages = 0;\n\n#ifdef CONFIG_CMA\n\t/* If allocation can't use CMA areas don't use free CMA pages */\n\tif (!(alloc_flags & ALLOC_CMA))\n\t\tcma_pages = zone_page_state(z, NR_FREE_CMA_PAGES);\n#endif\n\n\t/*\n\t * Fast check for order-0 only. If this fails then the reserves\n\t * need to be calculated. There is a corner case where the check\n\t * passes but only the high-order atomic reserve are free. If\n\t * the caller is !atomic then it'll uselessly search the free\n\t * list. That corner case is then slower but it is harmless.\n\t */\n\tif (!order && (free_pages - cma_pages) > mark + z->lowmem_reserve[classzone_idx])\n\t\treturn true;\n\n\treturn __zone_watermark_ok(z, order, mark, classzone_idx, alloc_flags,\n\t\t\t\t\tfree_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ac_classzone_idx",
          "args": [
            "ac"
          ],
          "line": 3312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_dirty_ok",
          "args": [
            "zone->zone_pgdat"
          ],
          "line": 3304
        },
        "resolved": true,
        "details": {
          "function_name": "node_dirty_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "501-511",
          "snippet": "bool node_dirty_ok(struct pglist_data *pgdat)\n{\n\tunsigned long limit = node_dirty_limit(pgdat);\n\tunsigned long nr_pages = 0;\n\n\tnr_pages += node_page_state(pgdat, NR_FILE_DIRTY);\n\tnr_pages += node_page_state(pgdat, NR_UNSTABLE_NFS);\n\tnr_pages += node_page_state(pgdat, NR_WRITEBACK);\n\n\treturn nr_pages <= limit;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nbool node_dirty_ok(struct pglist_data *pgdat)\n{\n\tunsigned long limit = node_dirty_limit(pgdat);\n\tunsigned long nr_pages = 0;\n\n\tnr_pages += node_page_state(pgdat, NR_FILE_DIRTY);\n\tnr_pages += node_page_state(pgdat, NR_UNSTABLE_NFS);\n\tnr_pages += node_page_state(pgdat, NR_WRITEBACK);\n\n\treturn nr_pages <= limit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__cpuset_zone_allowed",
          "args": [
            "zone",
            "gfp_mask"
          ],
          "line": 3279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpusets_enabled",
          "args": [],
          "line": 3277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_next_zone_zonelist_nodemask",
          "args": [
            "zone",
            "z",
            "ac->zonelist",
            "ac->high_zoneidx",
            "ac->nodemask"
          ],
          "line": 3272
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic struct page *\nget_page_from_freelist(gfp_t gfp_mask, unsigned int order, int alloc_flags,\n\t\t\t\t\t\tconst struct alloc_context *ac)\n{\n\tstruct zoneref *z = ac->preferred_zoneref;\n\tstruct zone *zone;\n\tstruct pglist_data *last_pgdat_dirty_limit = NULL;\n\n\t/*\n\t * Scan zonelist, looking for a zone with enough free.\n\t * See also __cpuset_node_allowed() comment in kernel/cpuset.c.\n\t */\n\tfor_next_zone_zonelist_nodemask(zone, z, ac->zonelist, ac->high_zoneidx,\n\t\t\t\t\t\t\t\tac->nodemask) {\n\t\tstruct page *page;\n\t\tunsigned long mark;\n\n\t\tif (cpusets_enabled() &&\n\t\t\t(alloc_flags & ALLOC_CPUSET) &&\n\t\t\t!__cpuset_zone_allowed(zone, gfp_mask))\n\t\t\t\tcontinue;\n\t\t/*\n\t\t * When allocating a page cache page for writing, we\n\t\t * want to get it from a node that is within its dirty\n\t\t * limit, such that no single node holds more than its\n\t\t * proportional share of globally allowed dirty pages.\n\t\t * The dirty limits take into account the node's\n\t\t * lowmem reserves and high watermark so that kswapd\n\t\t * should be able to balance it without having to\n\t\t * write pages from its LRU list.\n\t\t *\n\t\t * XXX: For now, allow allocations to potentially\n\t\t * exceed the per-node dirty limit in the slowpath\n\t\t * (spread_dirty_pages unset) before going into reclaim,\n\t\t * which is important when on a NUMA setup the allowed\n\t\t * nodes are together not big enough to reach the\n\t\t * global limit.  The proper fix for these situations\n\t\t * will require awareness of nodes in the\n\t\t * dirty-throttling and the flusher threads.\n\t\t */\n\t\tif (ac->spread_dirty_pages) {\n\t\t\tif (last_pgdat_dirty_limit == zone->zone_pgdat)\n\t\t\t\tcontinue;\n\n\t\t\tif (!node_dirty_ok(zone->zone_pgdat)) {\n\t\t\t\tlast_pgdat_dirty_limit = zone->zone_pgdat;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tmark = zone->watermark[alloc_flags & ALLOC_WMARK_MASK];\n\t\tif (!zone_watermark_fast(zone, order, mark,\n\t\t\t\t       ac_classzone_idx(ac), alloc_flags)) {\n\t\t\tint ret;\n\n#ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT\n\t\t\t/*\n\t\t\t * Watermark failed for this zone, but see if we can\n\t\t\t * grow this zone if it contains deferred pages.\n\t\t\t */\n\t\t\tif (static_branch_unlikely(&deferred_pages)) {\n\t\t\t\tif (_deferred_grow_zone(zone, order))\n\t\t\t\t\tgoto try_this_zone;\n\t\t\t}\n#endif\n\t\t\t/* Checked here to keep the fast path fast */\n\t\t\tBUILD_BUG_ON(ALLOC_NO_WATERMARKS < NR_WMARK);\n\t\t\tif (alloc_flags & ALLOC_NO_WATERMARKS)\n\t\t\t\tgoto try_this_zone;\n\n\t\t\tif (node_reclaim_mode == 0 ||\n\t\t\t    !zone_allows_reclaim(ac->preferred_zoneref->zone, zone))\n\t\t\t\tcontinue;\n\n\t\t\tret = node_reclaim(zone->zone_pgdat, gfp_mask, order);\n\t\t\tswitch (ret) {\n\t\t\tcase NODE_RECLAIM_NOSCAN:\n\t\t\t\t/* did not scan */\n\t\t\t\tcontinue;\n\t\t\tcase NODE_RECLAIM_FULL:\n\t\t\t\t/* scanned but unreclaimable */\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\t/* did we reclaim enough */\n\t\t\t\tif (zone_watermark_ok(zone, order, mark,\n\t\t\t\t\t\tac_classzone_idx(ac), alloc_flags))\n\t\t\t\t\tgoto try_this_zone;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\ntry_this_zone:\n\t\tpage = rmqueue(ac->preferred_zoneref->zone, zone, order,\n\t\t\t\tgfp_mask, alloc_flags, ac->migratetype);\n\t\tif (page) {\n\t\t\tprep_new_page(page, order, gfp_mask, alloc_flags);\n\n\t\t\t/*\n\t\t\t * If this is a high-order atomic allocation then check\n\t\t\t * if the pageblock should be reserved for the future\n\t\t\t */\n\t\t\tif (unlikely(order && (alloc_flags & ALLOC_HARDER)))\n\t\t\t\treserve_highatomic_pageblock(page, zone, order);\n\n\t\t\treturn page;\n\t\t} else {\n#ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT\n\t\t\t/* Try again if zone has deferred pages */\n\t\t\tif (static_branch_unlikely(&deferred_pages)) {\n\t\t\t\tif (_deferred_grow_zone(zone, order))\n\t\t\t\t\tgoto try_this_zone;\n\t\t\t}\n#endif\n\t\t}\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "zone_allows_reclaim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "3250-3253",
    "snippet": "static bool zone_allows_reclaim(struct zone *local_zone, struct zone *zone)\n{\n\treturn true;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool zone_allows_reclaim(struct zone *local_zone, struct zone *zone)\n{\n\treturn true;\n}"
  },
  {
    "function_name": "zone_allows_reclaim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "3244-3248",
    "snippet": "static bool zone_allows_reclaim(struct zone *local_zone, struct zone *zone)\n{\n\treturn node_distance(zone_to_nid(local_zone), zone_to_nid(zone)) <=\n\t\t\t\tRECLAIM_DISTANCE;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "node_distance",
          "args": [
            "zone_to_nid(local_zone)",
            "zone_to_nid(zone)"
          ],
          "line": 3246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_to_nid",
          "args": [
            "zone"
          ],
          "line": 3246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_to_nid",
          "args": [
            "local_zone"
          ],
          "line": 3246
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool zone_allows_reclaim(struct zone *local_zone, struct zone *zone)\n{\n\treturn node_distance(zone_to_nid(local_zone), zone_to_nid(zone)) <=\n\t\t\t\tRECLAIM_DISTANCE;\n}"
  },
  {
    "function_name": "zone_watermark_ok_safe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "3231-3241",
    "snippet": "bool zone_watermark_ok_safe(struct zone *z, unsigned int order,\n\t\t\tunsigned long mark, int classzone_idx)\n{\n\tlong free_pages = zone_page_state(z, NR_FREE_PAGES);\n\n\tif (z->percpu_drift_mark && free_pages < z->percpu_drift_mark)\n\t\tfree_pages = zone_page_state_snapshot(z, NR_FREE_PAGES);\n\n\treturn __zone_watermark_ok(z, order, mark, classzone_idx, 0,\n\t\t\t\t\t\t\t\tfree_pages);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);",
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__zone_watermark_ok",
          "args": [
            "z",
            "order",
            "mark",
            "classzone_idx",
            "0",
            "free_pages"
          ],
          "line": 3239
        },
        "resolved": true,
        "details": {
          "function_name": "__zone_watermark_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3119-3196",
          "snippet": "bool __zone_watermark_ok(struct zone *z, unsigned int order, unsigned long mark,\n\t\t\t int classzone_idx, unsigned int alloc_flags,\n\t\t\t long free_pages)\n{\n\tlong min = mark;\n\tint o;\n\tconst bool alloc_harder = (alloc_flags & (ALLOC_HARDER|ALLOC_OOM));\n\n\t/* free_pages may go negative - that's OK */\n\tfree_pages -= (1 << order) - 1;\n\n\tif (alloc_flags & ALLOC_HIGH)\n\t\tmin -= min / 2;\n\n\t/*\n\t * If the caller does not have rights to ALLOC_HARDER then subtract\n\t * the high-atomic reserves. This will over-estimate the size of the\n\t * atomic reserve but it avoids a search.\n\t */\n\tif (likely(!alloc_harder)) {\n\t\tfree_pages -= z->nr_reserved_highatomic;\n\t} else {\n\t\t/*\n\t\t * OOM victims can try even harder than normal ALLOC_HARDER\n\t\t * users on the grounds that it's definitely going to be in\n\t\t * the exit path shortly and free memory. Any allocation it\n\t\t * makes during the free path will be small and short-lived.\n\t\t */\n\t\tif (alloc_flags & ALLOC_OOM)\n\t\t\tmin -= min / 2;\n\t\telse\n\t\t\tmin -= min / 4;\n\t}\n\n\n#ifdef CONFIG_CMA\n\t/* If allocation can't use CMA areas don't use free CMA pages */\n\tif (!(alloc_flags & ALLOC_CMA))\n\t\tfree_pages -= zone_page_state(z, NR_FREE_CMA_PAGES);\n#endif\n\n\t/*\n\t * Check watermarks for an order-0 allocation request. If these\n\t * are not met, then a high-order request also cannot go ahead\n\t * even if a suitable page happened to be free.\n\t */\n\tif (free_pages <= min + z->lowmem_reserve[classzone_idx])\n\t\treturn false;\n\n\t/* If this is an order-0 request then the watermark is fine */\n\tif (!order)\n\t\treturn true;\n\n\t/* For a high-order request, check at least one suitable page is free */\n\tfor (o = order; o < MAX_ORDER; o++) {\n\t\tstruct free_area *area = &z->free_area[o];\n\t\tint mt;\n\n\t\tif (!area->nr_free)\n\t\t\tcontinue;\n\n\t\tfor (mt = 0; mt < MIGRATE_PCPTYPES; mt++) {\n\t\t\tif (!list_empty(&area->free_list[mt]))\n\t\t\t\treturn true;\n\t\t}\n\n#ifdef CONFIG_CMA\n\t\tif ((alloc_flags & ALLOC_CMA) &&\n\t\t    !list_empty(&area->free_list[MIGRATE_CMA])) {\n\t\t\treturn true;\n\t\t}\n#endif\n\t\tif (alloc_harder &&\n\t\t\t!list_empty(&area->free_list[MIGRATE_HIGHATOMIC]))\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nbool __zone_watermark_ok(struct zone *z, unsigned int order, unsigned long mark,\n\t\t\t int classzone_idx, unsigned int alloc_flags,\n\t\t\t long free_pages)\n{\n\tlong min = mark;\n\tint o;\n\tconst bool alloc_harder = (alloc_flags & (ALLOC_HARDER|ALLOC_OOM));\n\n\t/* free_pages may go negative - that's OK */\n\tfree_pages -= (1 << order) - 1;\n\n\tif (alloc_flags & ALLOC_HIGH)\n\t\tmin -= min / 2;\n\n\t/*\n\t * If the caller does not have rights to ALLOC_HARDER then subtract\n\t * the high-atomic reserves. This will over-estimate the size of the\n\t * atomic reserve but it avoids a search.\n\t */\n\tif (likely(!alloc_harder)) {\n\t\tfree_pages -= z->nr_reserved_highatomic;\n\t} else {\n\t\t/*\n\t\t * OOM victims can try even harder than normal ALLOC_HARDER\n\t\t * users on the grounds that it's definitely going to be in\n\t\t * the exit path shortly and free memory. Any allocation it\n\t\t * makes during the free path will be small and short-lived.\n\t\t */\n\t\tif (alloc_flags & ALLOC_OOM)\n\t\t\tmin -= min / 2;\n\t\telse\n\t\t\tmin -= min / 4;\n\t}\n\n\n#ifdef CONFIG_CMA\n\t/* If allocation can't use CMA areas don't use free CMA pages */\n\tif (!(alloc_flags & ALLOC_CMA))\n\t\tfree_pages -= zone_page_state(z, NR_FREE_CMA_PAGES);\n#endif\n\n\t/*\n\t * Check watermarks for an order-0 allocation request. If these\n\t * are not met, then a high-order request also cannot go ahead\n\t * even if a suitable page happened to be free.\n\t */\n\tif (free_pages <= min + z->lowmem_reserve[classzone_idx])\n\t\treturn false;\n\n\t/* If this is an order-0 request then the watermark is fine */\n\tif (!order)\n\t\treturn true;\n\n\t/* For a high-order request, check at least one suitable page is free */\n\tfor (o = order; o < MAX_ORDER; o++) {\n\t\tstruct free_area *area = &z->free_area[o];\n\t\tint mt;\n\n\t\tif (!area->nr_free)\n\t\t\tcontinue;\n\n\t\tfor (mt = 0; mt < MIGRATE_PCPTYPES; mt++) {\n\t\t\tif (!list_empty(&area->free_list[mt]))\n\t\t\t\treturn true;\n\t\t}\n\n#ifdef CONFIG_CMA\n\t\tif ((alloc_flags & ALLOC_CMA) &&\n\t\t    !list_empty(&area->free_list[MIGRATE_CMA])) {\n\t\t\treturn true;\n\t\t}\n#endif\n\t\tif (alloc_harder &&\n\t\t\t!list_empty(&area->free_list[MIGRATE_HIGHATOMIC]))\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zone_page_state_snapshot",
          "args": [
            "z",
            "NR_FREE_PAGES"
          ],
          "line": 3237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_page_state",
          "args": [
            "z",
            "NR_FREE_PAGES"
          ],
          "line": 3234
        },
        "resolved": true,
        "details": {
          "function_name": "dec_zone_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "624-631",
          "snippet": "void dec_zone_page_state(struct page *page, enum zone_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__dec_zone_page_state(page, item);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid dec_zone_page_state(struct page *page, enum zone_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__dec_zone_page_state(page, item);\n\tlocal_irq_restore(flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nbool zone_watermark_ok_safe(struct zone *z, unsigned int order,\n\t\t\tunsigned long mark, int classzone_idx)\n{\n\tlong free_pages = zone_page_state(z, NR_FREE_PAGES);\n\n\tif (z->percpu_drift_mark && free_pages < z->percpu_drift_mark)\n\t\tfree_pages = zone_page_state_snapshot(z, NR_FREE_PAGES);\n\n\treturn __zone_watermark_ok(z, order, mark, classzone_idx, 0,\n\t\t\t\t\t\t\t\tfree_pages);\n}"
  },
  {
    "function_name": "zone_watermark_fast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "3205-3229",
    "snippet": "static inline bool zone_watermark_fast(struct zone *z, unsigned int order,\n\t\tunsigned long mark, int classzone_idx, unsigned int alloc_flags)\n{\n\tlong free_pages = zone_page_state(z, NR_FREE_PAGES);\n\tlong cma_pages = 0;\n\n#ifdef CONFIG_CMA\n\t/* If allocation can't use CMA areas don't use free CMA pages */\n\tif (!(alloc_flags & ALLOC_CMA))\n\t\tcma_pages = zone_page_state(z, NR_FREE_CMA_PAGES);\n#endif\n\n\t/*\n\t * Fast check for order-0 only. If this fails then the reserves\n\t * need to be calculated. There is a corner case where the check\n\t * passes but only the high-order atomic reserve are free. If\n\t * the caller is !atomic then it'll uselessly search the free\n\t * list. That corner case is then slower but it is harmless.\n\t */\n\tif (!order && (free_pages - cma_pages) > mark + z->lowmem_reserve[classzone_idx])\n\t\treturn true;\n\n\treturn __zone_watermark_ok(z, order, mark, classzone_idx, alloc_flags,\n\t\t\t\t\tfree_pages);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);",
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__zone_watermark_ok",
          "args": [
            "z",
            "order",
            "mark",
            "classzone_idx",
            "alloc_flags",
            "free_pages"
          ],
          "line": 3227
        },
        "resolved": true,
        "details": {
          "function_name": "__zone_watermark_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3119-3196",
          "snippet": "bool __zone_watermark_ok(struct zone *z, unsigned int order, unsigned long mark,\n\t\t\t int classzone_idx, unsigned int alloc_flags,\n\t\t\t long free_pages)\n{\n\tlong min = mark;\n\tint o;\n\tconst bool alloc_harder = (alloc_flags & (ALLOC_HARDER|ALLOC_OOM));\n\n\t/* free_pages may go negative - that's OK */\n\tfree_pages -= (1 << order) - 1;\n\n\tif (alloc_flags & ALLOC_HIGH)\n\t\tmin -= min / 2;\n\n\t/*\n\t * If the caller does not have rights to ALLOC_HARDER then subtract\n\t * the high-atomic reserves. This will over-estimate the size of the\n\t * atomic reserve but it avoids a search.\n\t */\n\tif (likely(!alloc_harder)) {\n\t\tfree_pages -= z->nr_reserved_highatomic;\n\t} else {\n\t\t/*\n\t\t * OOM victims can try even harder than normal ALLOC_HARDER\n\t\t * users on the grounds that it's definitely going to be in\n\t\t * the exit path shortly and free memory. Any allocation it\n\t\t * makes during the free path will be small and short-lived.\n\t\t */\n\t\tif (alloc_flags & ALLOC_OOM)\n\t\t\tmin -= min / 2;\n\t\telse\n\t\t\tmin -= min / 4;\n\t}\n\n\n#ifdef CONFIG_CMA\n\t/* If allocation can't use CMA areas don't use free CMA pages */\n\tif (!(alloc_flags & ALLOC_CMA))\n\t\tfree_pages -= zone_page_state(z, NR_FREE_CMA_PAGES);\n#endif\n\n\t/*\n\t * Check watermarks for an order-0 allocation request. If these\n\t * are not met, then a high-order request also cannot go ahead\n\t * even if a suitable page happened to be free.\n\t */\n\tif (free_pages <= min + z->lowmem_reserve[classzone_idx])\n\t\treturn false;\n\n\t/* If this is an order-0 request then the watermark is fine */\n\tif (!order)\n\t\treturn true;\n\n\t/* For a high-order request, check at least one suitable page is free */\n\tfor (o = order; o < MAX_ORDER; o++) {\n\t\tstruct free_area *area = &z->free_area[o];\n\t\tint mt;\n\n\t\tif (!area->nr_free)\n\t\t\tcontinue;\n\n\t\tfor (mt = 0; mt < MIGRATE_PCPTYPES; mt++) {\n\t\t\tif (!list_empty(&area->free_list[mt]))\n\t\t\t\treturn true;\n\t\t}\n\n#ifdef CONFIG_CMA\n\t\tif ((alloc_flags & ALLOC_CMA) &&\n\t\t    !list_empty(&area->free_list[MIGRATE_CMA])) {\n\t\t\treturn true;\n\t\t}\n#endif\n\t\tif (alloc_harder &&\n\t\t\t!list_empty(&area->free_list[MIGRATE_HIGHATOMIC]))\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nbool __zone_watermark_ok(struct zone *z, unsigned int order, unsigned long mark,\n\t\t\t int classzone_idx, unsigned int alloc_flags,\n\t\t\t long free_pages)\n{\n\tlong min = mark;\n\tint o;\n\tconst bool alloc_harder = (alloc_flags & (ALLOC_HARDER|ALLOC_OOM));\n\n\t/* free_pages may go negative - that's OK */\n\tfree_pages -= (1 << order) - 1;\n\n\tif (alloc_flags & ALLOC_HIGH)\n\t\tmin -= min / 2;\n\n\t/*\n\t * If the caller does not have rights to ALLOC_HARDER then subtract\n\t * the high-atomic reserves. This will over-estimate the size of the\n\t * atomic reserve but it avoids a search.\n\t */\n\tif (likely(!alloc_harder)) {\n\t\tfree_pages -= z->nr_reserved_highatomic;\n\t} else {\n\t\t/*\n\t\t * OOM victims can try even harder than normal ALLOC_HARDER\n\t\t * users on the grounds that it's definitely going to be in\n\t\t * the exit path shortly and free memory. Any allocation it\n\t\t * makes during the free path will be small and short-lived.\n\t\t */\n\t\tif (alloc_flags & ALLOC_OOM)\n\t\t\tmin -= min / 2;\n\t\telse\n\t\t\tmin -= min / 4;\n\t}\n\n\n#ifdef CONFIG_CMA\n\t/* If allocation can't use CMA areas don't use free CMA pages */\n\tif (!(alloc_flags & ALLOC_CMA))\n\t\tfree_pages -= zone_page_state(z, NR_FREE_CMA_PAGES);\n#endif\n\n\t/*\n\t * Check watermarks for an order-0 allocation request. If these\n\t * are not met, then a high-order request also cannot go ahead\n\t * even if a suitable page happened to be free.\n\t */\n\tif (free_pages <= min + z->lowmem_reserve[classzone_idx])\n\t\treturn false;\n\n\t/* If this is an order-0 request then the watermark is fine */\n\tif (!order)\n\t\treturn true;\n\n\t/* For a high-order request, check at least one suitable page is free */\n\tfor (o = order; o < MAX_ORDER; o++) {\n\t\tstruct free_area *area = &z->free_area[o];\n\t\tint mt;\n\n\t\tif (!area->nr_free)\n\t\t\tcontinue;\n\n\t\tfor (mt = 0; mt < MIGRATE_PCPTYPES; mt++) {\n\t\t\tif (!list_empty(&area->free_list[mt]))\n\t\t\t\treturn true;\n\t\t}\n\n#ifdef CONFIG_CMA\n\t\tif ((alloc_flags & ALLOC_CMA) &&\n\t\t    !list_empty(&area->free_list[MIGRATE_CMA])) {\n\t\t\treturn true;\n\t\t}\n#endif\n\t\tif (alloc_harder &&\n\t\t\t!list_empty(&area->free_list[MIGRATE_HIGHATOMIC]))\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zone_page_state",
          "args": [
            "z",
            "NR_FREE_CMA_PAGES"
          ],
          "line": 3214
        },
        "resolved": true,
        "details": {
          "function_name": "dec_zone_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "624-631",
          "snippet": "void dec_zone_page_state(struct page *page, enum zone_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__dec_zone_page_state(page, item);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid dec_zone_page_state(struct page *page, enum zone_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__dec_zone_page_state(page, item);\n\tlocal_irq_restore(flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline bool zone_watermark_fast(struct zone *z, unsigned int order,\n\t\tunsigned long mark, int classzone_idx, unsigned int alloc_flags)\n{\n\tlong free_pages = zone_page_state(z, NR_FREE_PAGES);\n\tlong cma_pages = 0;\n\n#ifdef CONFIG_CMA\n\t/* If allocation can't use CMA areas don't use free CMA pages */\n\tif (!(alloc_flags & ALLOC_CMA))\n\t\tcma_pages = zone_page_state(z, NR_FREE_CMA_PAGES);\n#endif\n\n\t/*\n\t * Fast check for order-0 only. If this fails then the reserves\n\t * need to be calculated. There is a corner case where the check\n\t * passes but only the high-order atomic reserve are free. If\n\t * the caller is !atomic then it'll uselessly search the free\n\t * list. That corner case is then slower but it is harmless.\n\t */\n\tif (!order && (free_pages - cma_pages) > mark + z->lowmem_reserve[classzone_idx])\n\t\treturn true;\n\n\treturn __zone_watermark_ok(z, order, mark, classzone_idx, alloc_flags,\n\t\t\t\t\tfree_pages);\n}"
  },
  {
    "function_name": "zone_watermark_ok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "3198-3203",
    "snippet": "bool zone_watermark_ok(struct zone *z, unsigned int order, unsigned long mark,\n\t\t      int classzone_idx, unsigned int alloc_flags)\n{\n\treturn __zone_watermark_ok(z, order, mark, classzone_idx, alloc_flags,\n\t\t\t\t\tzone_page_state(z, NR_FREE_PAGES));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);",
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__zone_watermark_ok",
          "args": [
            "z",
            "order",
            "mark",
            "classzone_idx",
            "alloc_flags",
            "zone_page_state(z, NR_FREE_PAGES)"
          ],
          "line": 3201
        },
        "resolved": true,
        "details": {
          "function_name": "__zone_watermark_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3119-3196",
          "snippet": "bool __zone_watermark_ok(struct zone *z, unsigned int order, unsigned long mark,\n\t\t\t int classzone_idx, unsigned int alloc_flags,\n\t\t\t long free_pages)\n{\n\tlong min = mark;\n\tint o;\n\tconst bool alloc_harder = (alloc_flags & (ALLOC_HARDER|ALLOC_OOM));\n\n\t/* free_pages may go negative - that's OK */\n\tfree_pages -= (1 << order) - 1;\n\n\tif (alloc_flags & ALLOC_HIGH)\n\t\tmin -= min / 2;\n\n\t/*\n\t * If the caller does not have rights to ALLOC_HARDER then subtract\n\t * the high-atomic reserves. This will over-estimate the size of the\n\t * atomic reserve but it avoids a search.\n\t */\n\tif (likely(!alloc_harder)) {\n\t\tfree_pages -= z->nr_reserved_highatomic;\n\t} else {\n\t\t/*\n\t\t * OOM victims can try even harder than normal ALLOC_HARDER\n\t\t * users on the grounds that it's definitely going to be in\n\t\t * the exit path shortly and free memory. Any allocation it\n\t\t * makes during the free path will be small and short-lived.\n\t\t */\n\t\tif (alloc_flags & ALLOC_OOM)\n\t\t\tmin -= min / 2;\n\t\telse\n\t\t\tmin -= min / 4;\n\t}\n\n\n#ifdef CONFIG_CMA\n\t/* If allocation can't use CMA areas don't use free CMA pages */\n\tif (!(alloc_flags & ALLOC_CMA))\n\t\tfree_pages -= zone_page_state(z, NR_FREE_CMA_PAGES);\n#endif\n\n\t/*\n\t * Check watermarks for an order-0 allocation request. If these\n\t * are not met, then a high-order request also cannot go ahead\n\t * even if a suitable page happened to be free.\n\t */\n\tif (free_pages <= min + z->lowmem_reserve[classzone_idx])\n\t\treturn false;\n\n\t/* If this is an order-0 request then the watermark is fine */\n\tif (!order)\n\t\treturn true;\n\n\t/* For a high-order request, check at least one suitable page is free */\n\tfor (o = order; o < MAX_ORDER; o++) {\n\t\tstruct free_area *area = &z->free_area[o];\n\t\tint mt;\n\n\t\tif (!area->nr_free)\n\t\t\tcontinue;\n\n\t\tfor (mt = 0; mt < MIGRATE_PCPTYPES; mt++) {\n\t\t\tif (!list_empty(&area->free_list[mt]))\n\t\t\t\treturn true;\n\t\t}\n\n#ifdef CONFIG_CMA\n\t\tif ((alloc_flags & ALLOC_CMA) &&\n\t\t    !list_empty(&area->free_list[MIGRATE_CMA])) {\n\t\t\treturn true;\n\t\t}\n#endif\n\t\tif (alloc_harder &&\n\t\t\t!list_empty(&area->free_list[MIGRATE_HIGHATOMIC]))\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nbool __zone_watermark_ok(struct zone *z, unsigned int order, unsigned long mark,\n\t\t\t int classzone_idx, unsigned int alloc_flags,\n\t\t\t long free_pages)\n{\n\tlong min = mark;\n\tint o;\n\tconst bool alloc_harder = (alloc_flags & (ALLOC_HARDER|ALLOC_OOM));\n\n\t/* free_pages may go negative - that's OK */\n\tfree_pages -= (1 << order) - 1;\n\n\tif (alloc_flags & ALLOC_HIGH)\n\t\tmin -= min / 2;\n\n\t/*\n\t * If the caller does not have rights to ALLOC_HARDER then subtract\n\t * the high-atomic reserves. This will over-estimate the size of the\n\t * atomic reserve but it avoids a search.\n\t */\n\tif (likely(!alloc_harder)) {\n\t\tfree_pages -= z->nr_reserved_highatomic;\n\t} else {\n\t\t/*\n\t\t * OOM victims can try even harder than normal ALLOC_HARDER\n\t\t * users on the grounds that it's definitely going to be in\n\t\t * the exit path shortly and free memory. Any allocation it\n\t\t * makes during the free path will be small and short-lived.\n\t\t */\n\t\tif (alloc_flags & ALLOC_OOM)\n\t\t\tmin -= min / 2;\n\t\telse\n\t\t\tmin -= min / 4;\n\t}\n\n\n#ifdef CONFIG_CMA\n\t/* If allocation can't use CMA areas don't use free CMA pages */\n\tif (!(alloc_flags & ALLOC_CMA))\n\t\tfree_pages -= zone_page_state(z, NR_FREE_CMA_PAGES);\n#endif\n\n\t/*\n\t * Check watermarks for an order-0 allocation request. If these\n\t * are not met, then a high-order request also cannot go ahead\n\t * even if a suitable page happened to be free.\n\t */\n\tif (free_pages <= min + z->lowmem_reserve[classzone_idx])\n\t\treturn false;\n\n\t/* If this is an order-0 request then the watermark is fine */\n\tif (!order)\n\t\treturn true;\n\n\t/* For a high-order request, check at least one suitable page is free */\n\tfor (o = order; o < MAX_ORDER; o++) {\n\t\tstruct free_area *area = &z->free_area[o];\n\t\tint mt;\n\n\t\tif (!area->nr_free)\n\t\t\tcontinue;\n\n\t\tfor (mt = 0; mt < MIGRATE_PCPTYPES; mt++) {\n\t\t\tif (!list_empty(&area->free_list[mt]))\n\t\t\t\treturn true;\n\t\t}\n\n#ifdef CONFIG_CMA\n\t\tif ((alloc_flags & ALLOC_CMA) &&\n\t\t    !list_empty(&area->free_list[MIGRATE_CMA])) {\n\t\t\treturn true;\n\t\t}\n#endif\n\t\tif (alloc_harder &&\n\t\t\t!list_empty(&area->free_list[MIGRATE_HIGHATOMIC]))\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zone_page_state",
          "args": [
            "z",
            "NR_FREE_PAGES"
          ],
          "line": 3202
        },
        "resolved": true,
        "details": {
          "function_name": "dec_zone_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "624-631",
          "snippet": "void dec_zone_page_state(struct page *page, enum zone_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__dec_zone_page_state(page, item);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid dec_zone_page_state(struct page *page, enum zone_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__dec_zone_page_state(page, item);\n\tlocal_irq_restore(flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nbool zone_watermark_ok(struct zone *z, unsigned int order, unsigned long mark,\n\t\t      int classzone_idx, unsigned int alloc_flags)\n{\n\treturn __zone_watermark_ok(z, order, mark, classzone_idx, alloc_flags,\n\t\t\t\t\tzone_page_state(z, NR_FREE_PAGES));\n}"
  },
  {
    "function_name": "__zone_watermark_ok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "3119-3196",
    "snippet": "bool __zone_watermark_ok(struct zone *z, unsigned int order, unsigned long mark,\n\t\t\t int classzone_idx, unsigned int alloc_flags,\n\t\t\t long free_pages)\n{\n\tlong min = mark;\n\tint o;\n\tconst bool alloc_harder = (alloc_flags & (ALLOC_HARDER|ALLOC_OOM));\n\n\t/* free_pages may go negative - that's OK */\n\tfree_pages -= (1 << order) - 1;\n\n\tif (alloc_flags & ALLOC_HIGH)\n\t\tmin -= min / 2;\n\n\t/*\n\t * If the caller does not have rights to ALLOC_HARDER then subtract\n\t * the high-atomic reserves. This will over-estimate the size of the\n\t * atomic reserve but it avoids a search.\n\t */\n\tif (likely(!alloc_harder)) {\n\t\tfree_pages -= z->nr_reserved_highatomic;\n\t} else {\n\t\t/*\n\t\t * OOM victims can try even harder than normal ALLOC_HARDER\n\t\t * users on the grounds that it's definitely going to be in\n\t\t * the exit path shortly and free memory. Any allocation it\n\t\t * makes during the free path will be small and short-lived.\n\t\t */\n\t\tif (alloc_flags & ALLOC_OOM)\n\t\t\tmin -= min / 2;\n\t\telse\n\t\t\tmin -= min / 4;\n\t}\n\n\n#ifdef CONFIG_CMA\n\t/* If allocation can't use CMA areas don't use free CMA pages */\n\tif (!(alloc_flags & ALLOC_CMA))\n\t\tfree_pages -= zone_page_state(z, NR_FREE_CMA_PAGES);\n#endif\n\n\t/*\n\t * Check watermarks for an order-0 allocation request. If these\n\t * are not met, then a high-order request also cannot go ahead\n\t * even if a suitable page happened to be free.\n\t */\n\tif (free_pages <= min + z->lowmem_reserve[classzone_idx])\n\t\treturn false;\n\n\t/* If this is an order-0 request then the watermark is fine */\n\tif (!order)\n\t\treturn true;\n\n\t/* For a high-order request, check at least one suitable page is free */\n\tfor (o = order; o < MAX_ORDER; o++) {\n\t\tstruct free_area *area = &z->free_area[o];\n\t\tint mt;\n\n\t\tif (!area->nr_free)\n\t\t\tcontinue;\n\n\t\tfor (mt = 0; mt < MIGRATE_PCPTYPES; mt++) {\n\t\t\tif (!list_empty(&area->free_list[mt]))\n\t\t\t\treturn true;\n\t\t}\n\n#ifdef CONFIG_CMA\n\t\tif ((alloc_flags & ALLOC_CMA) &&\n\t\t    !list_empty(&area->free_list[MIGRATE_CMA])) {\n\t\t\treturn true;\n\t\t}\n#endif\n\t\tif (alloc_harder &&\n\t\t\t!list_empty(&area->free_list[MIGRATE_HIGHATOMIC]))\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);",
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&area->free_list[MIGRATE_HIGHATOMIC]"
          ],
          "line": 3192
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "zone_page_state",
          "args": [
            "z",
            "NR_FREE_CMA_PAGES"
          ],
          "line": 3157
        },
        "resolved": true,
        "details": {
          "function_name": "dec_zone_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "624-631",
          "snippet": "void dec_zone_page_state(struct page *page, enum zone_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__dec_zone_page_state(page, item);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid dec_zone_page_state(struct page *page, enum zone_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__dec_zone_page_state(page, item);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!alloc_harder"
          ],
          "line": 3138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nbool __zone_watermark_ok(struct zone *z, unsigned int order, unsigned long mark,\n\t\t\t int classzone_idx, unsigned int alloc_flags,\n\t\t\t long free_pages)\n{\n\tlong min = mark;\n\tint o;\n\tconst bool alloc_harder = (alloc_flags & (ALLOC_HARDER|ALLOC_OOM));\n\n\t/* free_pages may go negative - that's OK */\n\tfree_pages -= (1 << order) - 1;\n\n\tif (alloc_flags & ALLOC_HIGH)\n\t\tmin -= min / 2;\n\n\t/*\n\t * If the caller does not have rights to ALLOC_HARDER then subtract\n\t * the high-atomic reserves. This will over-estimate the size of the\n\t * atomic reserve but it avoids a search.\n\t */\n\tif (likely(!alloc_harder)) {\n\t\tfree_pages -= z->nr_reserved_highatomic;\n\t} else {\n\t\t/*\n\t\t * OOM victims can try even harder than normal ALLOC_HARDER\n\t\t * users on the grounds that it's definitely going to be in\n\t\t * the exit path shortly and free memory. Any allocation it\n\t\t * makes during the free path will be small and short-lived.\n\t\t */\n\t\tif (alloc_flags & ALLOC_OOM)\n\t\t\tmin -= min / 2;\n\t\telse\n\t\t\tmin -= min / 4;\n\t}\n\n\n#ifdef CONFIG_CMA\n\t/* If allocation can't use CMA areas don't use free CMA pages */\n\tif (!(alloc_flags & ALLOC_CMA))\n\t\tfree_pages -= zone_page_state(z, NR_FREE_CMA_PAGES);\n#endif\n\n\t/*\n\t * Check watermarks for an order-0 allocation request. If these\n\t * are not met, then a high-order request also cannot go ahead\n\t * even if a suitable page happened to be free.\n\t */\n\tif (free_pages <= min + z->lowmem_reserve[classzone_idx])\n\t\treturn false;\n\n\t/* If this is an order-0 request then the watermark is fine */\n\tif (!order)\n\t\treturn true;\n\n\t/* For a high-order request, check at least one suitable page is free */\n\tfor (o = order; o < MAX_ORDER; o++) {\n\t\tstruct free_area *area = &z->free_area[o];\n\t\tint mt;\n\n\t\tif (!area->nr_free)\n\t\t\tcontinue;\n\n\t\tfor (mt = 0; mt < MIGRATE_PCPTYPES; mt++) {\n\t\t\tif (!list_empty(&area->free_list[mt]))\n\t\t\t\treturn true;\n\t\t}\n\n#ifdef CONFIG_CMA\n\t\tif ((alloc_flags & ALLOC_CMA) &&\n\t\t    !list_empty(&area->free_list[MIGRATE_CMA])) {\n\t\t\treturn true;\n\t\t}\n#endif\n\t\tif (alloc_harder &&\n\t\t\t!list_empty(&area->free_list[MIGRATE_HIGHATOMIC]))\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "should_fail_alloc_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "3106-3109",
    "snippet": "static inline bool should_fail_alloc_page(gfp_t gfp_mask, unsigned int order)\n{\n\treturn false;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\n\nstatic inline bool should_fail_alloc_page(gfp_t gfp_mask, unsigned int order)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "fail_page_alloc_debugfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "3073-3098",
    "snippet": "static int __init fail_page_alloc_debugfs(void)\n{\n\tumode_t mode = S_IFREG | 0600;\n\tstruct dentry *dir;\n\n\tdir = fault_create_debugfs_attr(\"fail_page_alloc\", NULL,\n\t\t\t\t\t&fail_page_alloc.attr);\n\tif (IS_ERR(dir))\n\t\treturn PTR_ERR(dir);\n\n\tif (!debugfs_create_bool(\"ignore-gfp-wait\", mode, dir,\n\t\t\t\t&fail_page_alloc.ignore_gfp_reclaim))\n\t\tgoto fail;\n\tif (!debugfs_create_bool(\"ignore-gfp-highmem\", mode, dir,\n\t\t\t\t&fail_page_alloc.ignore_gfp_highmem))\n\t\tgoto fail;\n\tif (!debugfs_create_u32(\"min-order\", mode, dir,\n\t\t\t\t&fail_page_alloc.min_order))\n\t\tgoto fail;\n\n\treturn 0;\nfail:\n\tdebugfs_remove_recursive(dir);\n\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);",
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_remove_recursive",
          "args": [
            "dir"
          ],
          "line": 3095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_u32",
          "args": [
            "\"min-order\"",
            "mode",
            "dir",
            "&fail_page_alloc.min_order"
          ],
          "line": 3089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_bool",
          "args": [
            "\"ignore-gfp-highmem\"",
            "mode",
            "dir",
            "&fail_page_alloc.ignore_gfp_highmem"
          ],
          "line": 3086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_bool",
          "args": [
            "\"ignore-gfp-wait\"",
            "mode",
            "dir",
            "&fail_page_alloc.ignore_gfp_reclaim"
          ],
          "line": 3083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dir"
          ],
          "line": 3081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dir"
          ],
          "line": 3080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fault_create_debugfs_attr",
          "args": [
            "\"fail_page_alloc\"",
            "NULL",
            "&fail_page_alloc.attr"
          ],
          "line": 3078
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic int __init fail_page_alloc_debugfs(void)\n{\n\tumode_t mode = S_IFREG | 0600;\n\tstruct dentry *dir;\n\n\tdir = fault_create_debugfs_attr(\"fail_page_alloc\", NULL,\n\t\t\t\t\t&fail_page_alloc.attr);\n\tif (IS_ERR(dir))\n\t\treturn PTR_ERR(dir);\n\n\tif (!debugfs_create_bool(\"ignore-gfp-wait\", mode, dir,\n\t\t\t\t&fail_page_alloc.ignore_gfp_reclaim))\n\t\tgoto fail;\n\tif (!debugfs_create_bool(\"ignore-gfp-highmem\", mode, dir,\n\t\t\t\t&fail_page_alloc.ignore_gfp_highmem))\n\t\tgoto fail;\n\tif (!debugfs_create_u32(\"min-order\", mode, dir,\n\t\t\t\t&fail_page_alloc.min_order))\n\t\tgoto fail;\n\n\treturn 0;\nfail:\n\tdebugfs_remove_recursive(dir);\n\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "should_fail_alloc_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "3056-3069",
    "snippet": "static bool should_fail_alloc_page(gfp_t gfp_mask, unsigned int order)\n{\n\tif (order < fail_page_alloc.min_order)\n\t\treturn false;\n\tif (gfp_mask & __GFP_NOFAIL)\n\t\treturn false;\n\tif (fail_page_alloc.ignore_gfp_highmem && (gfp_mask & __GFP_HIGHMEM))\n\t\treturn false;\n\tif (fail_page_alloc.ignore_gfp_reclaim &&\n\t\t\t(gfp_mask & __GFP_DIRECT_RECLAIM))\n\t\treturn false;\n\n\treturn should_fail(&fail_page_alloc.attr, 1 << order);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "should_fail",
          "args": [
            "&fail_page_alloc.attr",
            "1 << order"
          ],
          "line": 3068
        },
        "resolved": true,
        "details": {
          "function_name": "should_fail_alloc_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3106-3109",
          "snippet": "static inline bool should_fail_alloc_page(gfp_t gfp_mask, unsigned int order)\n{\n\treturn false;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\n\nstatic bool should_fail_alloc_page(gfp_t gfp_mask, unsigned int order)\n{\n\tif (order < fail_page_alloc.min_order)\n\t\treturn false;\n\tif (gfp_mask & __GFP_NOFAIL)\n\t\treturn false;\n\tif (fail_page_alloc.ignore_gfp_highmem && (gfp_mask & __GFP_HIGHMEM))\n\t\treturn false;\n\tif (fail_page_alloc.ignore_gfp_reclaim &&\n\t\t\t(gfp_mask & __GFP_DIRECT_RECLAIM))\n\t\treturn false;\n\n\treturn should_fail(&fail_page_alloc.attr, 1 << order);\n}"
  },
  {
    "function_name": "setup_fail_page_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "3050-3053",
    "snippet": "static int __init setup_fail_page_alloc(char *str)\n{\n\treturn setup_fault_attr(&fail_page_alloc.attr, str);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "setup_fault_attr",
          "args": [
            "&fail_page_alloc.attr",
            "str"
          ],
          "line": 3052
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic int __init setup_fail_page_alloc(char *str)\n{\n\treturn setup_fault_attr(&fail_page_alloc.attr, str);\n}"
  },
  {
    "function_name": "rmqueue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "2984-3033",
    "snippet": "static inline\nstruct page *rmqueue(struct zone *preferred_zone,\n\t\t\tstruct zone *zone, unsigned int order,\n\t\t\tgfp_t gfp_flags, unsigned int alloc_flags,\n\t\t\tint migratetype)\n{\n\tunsigned long flags;\n\tstruct page *page;\n\n\tif (likely(order == 0)) {\n\t\tpage = rmqueue_pcplist(preferred_zone, zone, order,\n\t\t\t\tgfp_flags, migratetype);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We most definitely don't want callers attempting to\n\t * allocate greater than order-1 page units with __GFP_NOFAIL.\n\t */\n\tWARN_ON_ONCE((gfp_flags & __GFP_NOFAIL) && (order > 1));\n\tspin_lock_irqsave(&zone->lock, flags);\n\n\tdo {\n\t\tpage = NULL;\n\t\tif (alloc_flags & ALLOC_HARDER) {\n\t\t\tpage = __rmqueue_smallest(zone, order, MIGRATE_HIGHATOMIC);\n\t\t\tif (page)\n\t\t\t\ttrace_mm_page_alloc_zone_locked(page, order, migratetype);\n\t\t}\n\t\tif (!page)\n\t\t\tpage = __rmqueue(zone, order, migratetype);\n\t} while (page && check_new_pages(page, order));\n\tspin_unlock(&zone->lock);\n\tif (!page)\n\t\tgoto failed;\n\t__mod_zone_freepage_state(zone, -(1 << order),\n\t\t\t\t  get_pcppage_migratetype(page));\n\n\t__count_zid_vm_events(PGALLOC, page_zonenum(page), 1 << order);\n\tzone_statistics(preferred_zone, zone);\n\tlocal_irq_restore(flags);\n\nout:\n\tVM_BUG_ON_PAGE(page && bad_range(zone, page), page);\n\treturn page;\n\nfailed:\n\tlocal_irq_restore(flags);\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);",
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 3031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "page && bad_range(zone, page)",
            "page"
          ],
          "line": 3027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bad_range",
          "args": [
            "zone",
            "page"
          ],
          "line": 3027
        },
        "resolved": true,
        "details": {
          "function_name": "bad_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "506-509",
          "snippet": "static inline int __maybe_unused bad_range(struct zone *zone, struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline int __maybe_unused bad_range(struct zone *zone, struct page *page)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 3024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_statistics",
          "args": [
            "preferred_zone",
            "zone"
          ],
          "line": 3023
        },
        "resolved": true,
        "details": {
          "function_name": "zone_statistics",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "2913-2933",
          "snippet": "static inline void zone_statistics(struct zone *preferred_zone, struct zone *z)\n{\n#ifdef CONFIG_NUMA\n\tenum numa_stat_item local_stat = NUMA_LOCAL;\n\n\t/* skip numa counters update if numa stats is disabled */\n\tif (!static_branch_likely(&vm_numa_stat_key))\n\t\treturn;\n\n\tif (zone_to_nid(z) != numa_node_id())\n\t\tlocal_stat = NUMA_OTHER;\n\n\tif (zone_to_nid(z) == zone_to_nid(preferred_zone))\n\t\t__inc_numa_state(z, NUMA_HIT);\n\telse {\n\t\t__inc_numa_state(z, NUMA_MISS);\n\t\t__inc_numa_state(preferred_zone, NUMA_FOREIGN);\n\t}\n\t__inc_numa_state(z, local_stat);\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline void zone_statistics(struct zone *preferred_zone, struct zone *z)\n{\n#ifdef CONFIG_NUMA\n\tenum numa_stat_item local_stat = NUMA_LOCAL;\n\n\t/* skip numa counters update if numa stats is disabled */\n\tif (!static_branch_likely(&vm_numa_stat_key))\n\t\treturn;\n\n\tif (zone_to_nid(z) != numa_node_id())\n\t\tlocal_stat = NUMA_OTHER;\n\n\tif (zone_to_nid(z) == zone_to_nid(preferred_zone))\n\t\t__inc_numa_state(z, NUMA_HIT);\n\telse {\n\t\t__inc_numa_state(z, NUMA_MISS);\n\t\t__inc_numa_state(preferred_zone, NUMA_FOREIGN);\n\t}\n\t__inc_numa_state(z, local_stat);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "__count_zid_vm_events",
          "args": [
            "PGALLOC",
            "page_zonenum(page)",
            "1 << order"
          ],
          "line": 3022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_zonenum",
          "args": [
            "page"
          ],
          "line": 3022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mod_zone_freepage_state",
          "args": [
            "zone",
            "-(1 << order)",
            "get_pcppage_migratetype(page)"
          ],
          "line": 3019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_pcppage_migratetype",
          "args": [
            "page"
          ],
          "line": 3020
        },
        "resolved": true,
        "details": {
          "function_name": "get_pcppage_migratetype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "142-145",
          "snippet": "static inline int get_pcppage_migratetype(struct page *page)\n{\n\treturn page->index;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline int get_pcppage_migratetype(struct page *page)\n{\n\treturn page->index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&zone->lock"
          ],
          "line": 3016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_new_pages",
          "args": [
            "page",
            "order"
          ],
          "line": 3015
        },
        "resolved": true,
        "details": {
          "function_name": "check_new_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1895-1906",
          "snippet": "static bool check_new_pages(struct page *page, unsigned int order)\n{\n\tint i;\n\tfor (i = 0; i < (1 << order); i++) {\n\t\tstruct page *p = page + i;\n\n\t\tif (unlikely(check_new_page(p)))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool check_new_pages(struct page *page, unsigned int order)\n{\n\tint i;\n\tfor (i = 0; i < (1 << order); i++) {\n\t\tstruct page *p = page + i;\n\n\t\tif (unlikely(check_new_page(p)))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__rmqueue",
          "args": [
            "zone",
            "order",
            "migratetype"
          ],
          "line": 3014
        },
        "resolved": true,
        "details": {
          "function_name": "__rmqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "2449-2466",
          "snippet": "page *\n__rmqueue(struct zone *zone, unsigned int order, int migratetype)\n{\n\tstruct page *page;\n\nretry:\n\tpage = __rmqueue_smallest(zone, order, migratetype);\n\tif (unlikely(!page)) {\n\t\tif (migratetype == MIGRATE_MOVABLE)\n\t\t\tpage = __rmqueue_cma_fallback(zone, order);\n\n\t\tif (!page && __rmqueue_fallback(zone, order, migratetype))\n\t\t\tgoto retry;\n\t}\n\n\ttrace_mm_page_alloc_zone_locked(page, order, migratetype);\n\treturn page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\npage *\n__rmqueue(struct zone *zone, unsigned int order, int migratetype)\n{\n\tstruct page *page;\n\nretry:\n\tpage = __rmqueue_smallest(zone, order, migratetype);\n\tif (unlikely(!page)) {\n\t\tif (migratetype == MIGRATE_MOVABLE)\n\t\t\tpage = __rmqueue_cma_fallback(zone, order);\n\n\t\tif (!page && __rmqueue_fallback(zone, order, migratetype))\n\t\t\tgoto retry;\n\t}\n\n\ttrace_mm_page_alloc_zone_locked(page, order, migratetype);\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_mm_page_alloc_zone_locked",
          "args": [
            "page",
            "order",
            "migratetype"
          ],
          "line": 3011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__rmqueue_smallest",
          "args": [
            "zone",
            "order",
            "MIGRATE_HIGHATOMIC"
          ],
          "line": 3009
        },
        "resolved": true,
        "details": {
          "function_name": "__rmqueue_smallest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1952-1975",
          "snippet": "page *__rmqueue_smallest(struct zone *zone, unsigned int order,\n\t\t\t\t\t\tint migratetype)\n{\n\tunsigned int current_order;\n\tstruct free_area *area;\n\tstruct page *page;\n\n\t/* Find a page of the appropriate size in the preferred list */\n\tfor (current_order = order; current_order < MAX_ORDER; ++current_order) {\n\t\tarea = &(zone->free_area[current_order]);\n\t\tpage = list_first_entry_or_null(&area->free_list[migratetype],\n\t\t\t\t\t\t\tstruct page, lru);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tlist_del(&page->lru);\n\t\trmv_page_order(page);\n\t\tarea->nr_free--;\n\t\texpand(zone, page, order, current_order, area, migratetype);\n\t\tset_pcppage_migratetype(page, migratetype);\n\t\treturn page;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\npage *__rmqueue_smallest(struct zone *zone, unsigned int order,\n\t\t\t\t\t\tint migratetype)\n{\n\tunsigned int current_order;\n\tstruct free_area *area;\n\tstruct page *page;\n\n\t/* Find a page of the appropriate size in the preferred list */\n\tfor (current_order = order; current_order < MAX_ORDER; ++current_order) {\n\t\tarea = &(zone->free_area[current_order]);\n\t\tpage = list_first_entry_or_null(&area->free_list[migratetype],\n\t\t\t\t\t\t\tstruct page, lru);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tlist_del(&page->lru);\n\t\trmv_page_order(page);\n\t\tarea->nr_free--;\n\t\texpand(zone, page, order, current_order, area, migratetype);\n\t\tset_pcppage_migratetype(page, migratetype);\n\t\treturn page;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&zone->lock",
            "flags"
          ],
          "line": 3004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "(gfp_flags & __GFP_NOFAIL) && (order > 1)"
          ],
          "line": 3003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rmqueue_pcplist",
          "args": [
            "preferred_zone",
            "zone",
            "order",
            "gfp_flags",
            "migratetype"
          ],
          "line": 2994
        },
        "resolved": true,
        "details": {
          "function_name": "rmqueue_pcplist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "2960-2979",
          "snippet": "static struct page *rmqueue_pcplist(struct zone *preferred_zone,\n\t\t\tstruct zone *zone, unsigned int order,\n\t\t\tgfp_t gfp_flags, int migratetype)\n{\n\tstruct per_cpu_pages *pcp;\n\tstruct list_head *list;\n\tstruct page *page;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpcp = &this_cpu_ptr(zone->pageset)->pcp;\n\tlist = &pcp->lists[migratetype];\n\tpage = __rmqueue_pcplist(zone,  migratetype, pcp, list);\n\tif (page) {\n\t\t__count_zid_vm_events(PGALLOC, page_zonenum(page), 1 << order);\n\t\tzone_statistics(preferred_zone, zone);\n\t}\n\tlocal_irq_restore(flags);\n\treturn page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic struct page *rmqueue_pcplist(struct zone *preferred_zone,\n\t\t\tstruct zone *zone, unsigned int order,\n\t\t\tgfp_t gfp_flags, int migratetype)\n{\n\tstruct per_cpu_pages *pcp;\n\tstruct list_head *list;\n\tstruct page *page;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpcp = &this_cpu_ptr(zone->pageset)->pcp;\n\tlist = &pcp->lists[migratetype];\n\tpage = __rmqueue_pcplist(zone,  migratetype, pcp, list);\n\tif (page) {\n\t\t__count_zid_vm_events(PGALLOC, page_zonenum(page), 1 << order);\n\t\tzone_statistics(preferred_zone, zone);\n\t}\n\tlocal_irq_restore(flags);\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "order == 0"
          ],
          "line": 2993
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline\nstruct page *rmqueue(struct zone *preferred_zone,\n\t\t\tstruct zone *zone, unsigned int order,\n\t\t\tgfp_t gfp_flags, unsigned int alloc_flags,\n\t\t\tint migratetype)\n{\n\tunsigned long flags;\n\tstruct page *page;\n\n\tif (likely(order == 0)) {\n\t\tpage = rmqueue_pcplist(preferred_zone, zone, order,\n\t\t\t\tgfp_flags, migratetype);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We most definitely don't want callers attempting to\n\t * allocate greater than order-1 page units with __GFP_NOFAIL.\n\t */\n\tWARN_ON_ONCE((gfp_flags & __GFP_NOFAIL) && (order > 1));\n\tspin_lock_irqsave(&zone->lock, flags);\n\n\tdo {\n\t\tpage = NULL;\n\t\tif (alloc_flags & ALLOC_HARDER) {\n\t\t\tpage = __rmqueue_smallest(zone, order, MIGRATE_HIGHATOMIC);\n\t\t\tif (page)\n\t\t\t\ttrace_mm_page_alloc_zone_locked(page, order, migratetype);\n\t\t}\n\t\tif (!page)\n\t\t\tpage = __rmqueue(zone, order, migratetype);\n\t} while (page && check_new_pages(page, order));\n\tspin_unlock(&zone->lock);\n\tif (!page)\n\t\tgoto failed;\n\t__mod_zone_freepage_state(zone, -(1 << order),\n\t\t\t\t  get_pcppage_migratetype(page));\n\n\t__count_zid_vm_events(PGALLOC, page_zonenum(page), 1 << order);\n\tzone_statistics(preferred_zone, zone);\n\tlocal_irq_restore(flags);\n\nout:\n\tVM_BUG_ON_PAGE(page && bad_range(zone, page), page);\n\treturn page;\n\nfailed:\n\tlocal_irq_restore(flags);\n\treturn NULL;\n}"
  },
  {
    "function_name": "rmqueue_pcplist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "2960-2979",
    "snippet": "static struct page *rmqueue_pcplist(struct zone *preferred_zone,\n\t\t\tstruct zone *zone, unsigned int order,\n\t\t\tgfp_t gfp_flags, int migratetype)\n{\n\tstruct per_cpu_pages *pcp;\n\tstruct list_head *list;\n\tstruct page *page;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpcp = &this_cpu_ptr(zone->pageset)->pcp;\n\tlist = &pcp->lists[migratetype];\n\tpage = __rmqueue_pcplist(zone,  migratetype, pcp, list);\n\tif (page) {\n\t\t__count_zid_vm_events(PGALLOC, page_zonenum(page), 1 << order);\n\t\tzone_statistics(preferred_zone, zone);\n\t}\n\tlocal_irq_restore(flags);\n\treturn page;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);",
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 2977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_statistics",
          "args": [
            "preferred_zone",
            "zone"
          ],
          "line": 2975
        },
        "resolved": true,
        "details": {
          "function_name": "zone_statistics",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "2913-2933",
          "snippet": "static inline void zone_statistics(struct zone *preferred_zone, struct zone *z)\n{\n#ifdef CONFIG_NUMA\n\tenum numa_stat_item local_stat = NUMA_LOCAL;\n\n\t/* skip numa counters update if numa stats is disabled */\n\tif (!static_branch_likely(&vm_numa_stat_key))\n\t\treturn;\n\n\tif (zone_to_nid(z) != numa_node_id())\n\t\tlocal_stat = NUMA_OTHER;\n\n\tif (zone_to_nid(z) == zone_to_nid(preferred_zone))\n\t\t__inc_numa_state(z, NUMA_HIT);\n\telse {\n\t\t__inc_numa_state(z, NUMA_MISS);\n\t\t__inc_numa_state(preferred_zone, NUMA_FOREIGN);\n\t}\n\t__inc_numa_state(z, local_stat);\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline void zone_statistics(struct zone *preferred_zone, struct zone *z)\n{\n#ifdef CONFIG_NUMA\n\tenum numa_stat_item local_stat = NUMA_LOCAL;\n\n\t/* skip numa counters update if numa stats is disabled */\n\tif (!static_branch_likely(&vm_numa_stat_key))\n\t\treturn;\n\n\tif (zone_to_nid(z) != numa_node_id())\n\t\tlocal_stat = NUMA_OTHER;\n\n\tif (zone_to_nid(z) == zone_to_nid(preferred_zone))\n\t\t__inc_numa_state(z, NUMA_HIT);\n\telse {\n\t\t__inc_numa_state(z, NUMA_MISS);\n\t\t__inc_numa_state(preferred_zone, NUMA_FOREIGN);\n\t}\n\t__inc_numa_state(z, local_stat);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "__count_zid_vm_events",
          "args": [
            "PGALLOC",
            "page_zonenum(page)",
            "1 << order"
          ],
          "line": 2974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_zonenum",
          "args": [
            "page"
          ],
          "line": 2974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__rmqueue_pcplist",
          "args": [
            "zone",
            "migratetype",
            "pcp",
            "list"
          ],
          "line": 2972
        },
        "resolved": true,
        "details": {
          "function_name": "__rmqueue_pcplist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "2936-2957",
          "snippet": "static struct page *__rmqueue_pcplist(struct zone *zone, int migratetype,\n\t\t\tstruct per_cpu_pages *pcp,\n\t\t\tstruct list_head *list)\n{\n\tstruct page *page;\n\n\tdo {\n\t\tif (list_empty(list)) {\n\t\t\tpcp->count += rmqueue_bulk(zone, 0,\n\t\t\t\t\tpcp->batch, list,\n\t\t\t\t\tmigratetype);\n\t\t\tif (unlikely(list_empty(list)))\n\t\t\t\treturn NULL;\n\t\t}\n\n\t\tpage = list_first_entry(list, struct page, lru);\n\t\tlist_del(&page->lru);\n\t\tpcp->count--;\n\t} while (check_new_pcp(page));\n\n\treturn page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic struct page *__rmqueue_pcplist(struct zone *zone, int migratetype,\n\t\t\tstruct per_cpu_pages *pcp,\n\t\t\tstruct list_head *list)\n{\n\tstruct page *page;\n\n\tdo {\n\t\tif (list_empty(list)) {\n\t\t\tpcp->count += rmqueue_bulk(zone, 0,\n\t\t\t\t\tpcp->batch, list,\n\t\t\t\t\tmigratetype);\n\t\t\tif (unlikely(list_empty(list)))\n\t\t\t\treturn NULL;\n\t\t}\n\n\t\tpage = list_first_entry(list, struct page, lru);\n\t\tlist_del(&page->lru);\n\t\tpcp->count--;\n\t} while (check_new_pcp(page));\n\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "zone->pageset"
          ],
          "line": 2970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 2969
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic struct page *rmqueue_pcplist(struct zone *preferred_zone,\n\t\t\tstruct zone *zone, unsigned int order,\n\t\t\tgfp_t gfp_flags, int migratetype)\n{\n\tstruct per_cpu_pages *pcp;\n\tstruct list_head *list;\n\tstruct page *page;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpcp = &this_cpu_ptr(zone->pageset)->pcp;\n\tlist = &pcp->lists[migratetype];\n\tpage = __rmqueue_pcplist(zone,  migratetype, pcp, list);\n\tif (page) {\n\t\t__count_zid_vm_events(PGALLOC, page_zonenum(page), 1 << order);\n\t\tzone_statistics(preferred_zone, zone);\n\t}\n\tlocal_irq_restore(flags);\n\treturn page;\n}"
  },
  {
    "function_name": "__rmqueue_pcplist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "2936-2957",
    "snippet": "static struct page *__rmqueue_pcplist(struct zone *zone, int migratetype,\n\t\t\tstruct per_cpu_pages *pcp,\n\t\t\tstruct list_head *list)\n{\n\tstruct page *page;\n\n\tdo {\n\t\tif (list_empty(list)) {\n\t\t\tpcp->count += rmqueue_bulk(zone, 0,\n\t\t\t\t\tpcp->batch, list,\n\t\t\t\t\tmigratetype);\n\t\t\tif (unlikely(list_empty(list)))\n\t\t\t\treturn NULL;\n\t\t}\n\n\t\tpage = list_first_entry(list, struct page, lru);\n\t\tlist_del(&page->lru);\n\t\tpcp->count--;\n\t} while (check_new_pcp(page));\n\n\treturn page;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_new_pcp",
          "args": [
            "page"
          ],
          "line": 2954
        },
        "resolved": true,
        "details": {
          "function_name": "check_new_pcp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1889-1892",
          "snippet": "static bool check_new_pcp(struct page *page)\n{\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool check_new_pcp(struct page *page)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&page->lru"
          ],
          "line": 2952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "list",
            "structpage",
            "lru"
          ],
          "line": 2951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "list_empty(list)"
          ],
          "line": 2947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "list"
          ],
          "line": 2947
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rmqueue_bulk",
          "args": [
            "zone",
            "0",
            "pcp->batch",
            "list",
            "migratetype"
          ],
          "line": 2944
        },
        "resolved": true,
        "details": {
          "function_name": "rmqueue_bulk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "2473-2514",
          "snippet": "static int rmqueue_bulk(struct zone *zone, unsigned int order,\n\t\t\tunsigned long count, struct list_head *list,\n\t\t\tint migratetype)\n{\n\tint i, alloced = 0;\n\n\tspin_lock(&zone->lock);\n\tfor (i = 0; i < count; ++i) {\n\t\tstruct page *page = __rmqueue(zone, order, migratetype);\n\t\tif (unlikely(page == NULL))\n\t\t\tbreak;\n\n\t\tif (unlikely(check_pcp_refill(page)))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Split buddy pages returned by expand() are received here in\n\t\t * physical page order. The page is added to the tail of\n\t\t * caller's list. From the callers perspective, the linked list\n\t\t * is ordered by page number under some conditions. This is\n\t\t * useful for IO devices that can forward direction from the\n\t\t * head, thus also in the physical page order. This is useful\n\t\t * for IO devices that can merge IO requests if the physical\n\t\t * pages are ordered properly.\n\t\t */\n\t\tlist_add_tail(&page->lru, list);\n\t\talloced++;\n\t\tif (is_migrate_cma(get_pcppage_migratetype(page)))\n\t\t\t__mod_zone_page_state(zone, NR_FREE_CMA_PAGES,\n\t\t\t\t\t      -(1 << order));\n\t}\n\n\t/*\n\t * i pages were removed from the buddy list even if some leak due\n\t * to check_pcp_refill failing so adjust NR_FREE_PAGES based\n\t * on i. Do not confuse with 'alloced' which is the number of\n\t * pages added to the pcp list.\n\t */\n\t__mod_zone_page_state(zone, NR_FREE_PAGES, -(i << order));\n\tspin_unlock(&zone->lock);\n\treturn alloced;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic int rmqueue_bulk(struct zone *zone, unsigned int order,\n\t\t\tunsigned long count, struct list_head *list,\n\t\t\tint migratetype)\n{\n\tint i, alloced = 0;\n\n\tspin_lock(&zone->lock);\n\tfor (i = 0; i < count; ++i) {\n\t\tstruct page *page = __rmqueue(zone, order, migratetype);\n\t\tif (unlikely(page == NULL))\n\t\t\tbreak;\n\n\t\tif (unlikely(check_pcp_refill(page)))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Split buddy pages returned by expand() are received here in\n\t\t * physical page order. The page is added to the tail of\n\t\t * caller's list. From the callers perspective, the linked list\n\t\t * is ordered by page number under some conditions. This is\n\t\t * useful for IO devices that can forward direction from the\n\t\t * head, thus also in the physical page order. This is useful\n\t\t * for IO devices that can merge IO requests if the physical\n\t\t * pages are ordered properly.\n\t\t */\n\t\tlist_add_tail(&page->lru, list);\n\t\talloced++;\n\t\tif (is_migrate_cma(get_pcppage_migratetype(page)))\n\t\t\t__mod_zone_page_state(zone, NR_FREE_CMA_PAGES,\n\t\t\t\t\t      -(1 << order));\n\t}\n\n\t/*\n\t * i pages were removed from the buddy list even if some leak due\n\t * to check_pcp_refill failing so adjust NR_FREE_PAGES based\n\t * on i. Do not confuse with 'alloced' which is the number of\n\t * pages added to the pcp list.\n\t */\n\t__mod_zone_page_state(zone, NR_FREE_PAGES, -(i << order));\n\tspin_unlock(&zone->lock);\n\treturn alloced;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic struct page *__rmqueue_pcplist(struct zone *zone, int migratetype,\n\t\t\tstruct per_cpu_pages *pcp,\n\t\t\tstruct list_head *list)\n{\n\tstruct page *page;\n\n\tdo {\n\t\tif (list_empty(list)) {\n\t\t\tpcp->count += rmqueue_bulk(zone, 0,\n\t\t\t\t\tpcp->batch, list,\n\t\t\t\t\tmigratetype);\n\t\t\tif (unlikely(list_empty(list)))\n\t\t\t\treturn NULL;\n\t\t}\n\n\t\tpage = list_first_entry(list, struct page, lru);\n\t\tlist_del(&page->lru);\n\t\tpcp->count--;\n\t} while (check_new_pcp(page));\n\n\treturn page;\n}"
  },
  {
    "function_name": "zone_statistics",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "2913-2933",
    "snippet": "static inline void zone_statistics(struct zone *preferred_zone, struct zone *z)\n{\n#ifdef CONFIG_NUMA\n\tenum numa_stat_item local_stat = NUMA_LOCAL;\n\n\t/* skip numa counters update if numa stats is disabled */\n\tif (!static_branch_likely(&vm_numa_stat_key))\n\t\treturn;\n\n\tif (zone_to_nid(z) != numa_node_id())\n\t\tlocal_stat = NUMA_OTHER;\n\n\tif (zone_to_nid(z) == zone_to_nid(preferred_zone))\n\t\t__inc_numa_state(z, NUMA_HIT);\n\telse {\n\t\t__inc_numa_state(z, NUMA_MISS);\n\t\t__inc_numa_state(preferred_zone, NUMA_FOREIGN);\n\t}\n\t__inc_numa_state(z, local_stat);\n#endif\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__inc_numa_state",
          "args": [
            "z",
            "local_stat"
          ],
          "line": 2931
        },
        "resolved": true,
        "details": {
          "function_name": "__inc_numa_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "938-951",
          "snippet": "void __inc_numa_state(struct zone *zone,\n\t\t\t\t enum numa_stat_item item)\n{\n\tstruct per_cpu_pageset __percpu *pcp = zone->pageset;\n\tu16 __percpu *p = pcp->vm_numa_stat_diff + item;\n\tu16 v;\n\n\tv = __this_cpu_inc_return(*p);\n\n\tif (unlikely(v > NUMA_STATS_THRESHOLD)) {\n\t\tzone_numa_state_add(v, zone, item);\n\t\t__this_cpu_write(*p, 0);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define NUMA_STATS_THRESHOLD (U16_MAX - 2)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\n#define NUMA_STATS_THRESHOLD (U16_MAX - 2)\n\nvoid __inc_numa_state(struct zone *zone,\n\t\t\t\t enum numa_stat_item item)\n{\n\tstruct per_cpu_pageset __percpu *pcp = zone->pageset;\n\tu16 __percpu *p = pcp->vm_numa_stat_diff + item;\n\tu16 v;\n\n\tv = __this_cpu_inc_return(*p);\n\n\tif (unlikely(v > NUMA_STATS_THRESHOLD)) {\n\t\tzone_numa_state_add(v, zone, item);\n\t\t__this_cpu_write(*p, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "zone_to_nid",
          "args": [
            "preferred_zone"
          ],
          "line": 2925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_to_nid",
          "args": [
            "z"
          ],
          "line": 2925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "numa_node_id",
          "args": [],
          "line": 2922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_to_nid",
          "args": [
            "z"
          ],
          "line": 2922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_likely",
          "args": [
            "&vm_numa_stat_key"
          ],
          "line": 2919
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline void zone_statistics(struct zone *preferred_zone, struct zone *z)\n{\n#ifdef CONFIG_NUMA\n\tenum numa_stat_item local_stat = NUMA_LOCAL;\n\n\t/* skip numa counters update if numa stats is disabled */\n\tif (!static_branch_likely(&vm_numa_stat_key))\n\t\treturn;\n\n\tif (zone_to_nid(z) != numa_node_id())\n\t\tlocal_stat = NUMA_OTHER;\n\n\tif (zone_to_nid(z) == zone_to_nid(preferred_zone))\n\t\t__inc_numa_state(z, NUMA_HIT);\n\telse {\n\t\t__inc_numa_state(z, NUMA_MISS);\n\t\t__inc_numa_state(preferred_zone, NUMA_FOREIGN);\n\t}\n\t__inc_numa_state(z, local_stat);\n#endif\n}"
  },
  {
    "function_name": "__isolate_free_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "2859-2906",
    "snippet": "int __isolate_free_page(struct page *page, unsigned int order)\n{\n\tunsigned long watermark;\n\tstruct zone *zone;\n\tint mt;\n\n\tBUG_ON(!PageBuddy(page));\n\n\tzone = page_zone(page);\n\tmt = get_pageblock_migratetype(page);\n\n\tif (!is_migrate_isolate(mt)) {\n\t\t/*\n\t\t * Obey watermarks as if the page was being allocated. We can\n\t\t * emulate a high-order watermark check with a raised order-0\n\t\t * watermark, because we already know our high-order page\n\t\t * exists.\n\t\t */\n\t\twatermark = min_wmark_pages(zone) + (1UL << order);\n\t\tif (!zone_watermark_ok(zone, 0, watermark, 0, ALLOC_CMA))\n\t\t\treturn 0;\n\n\t\t__mod_zone_freepage_state(zone, -(1UL << order), mt);\n\t}\n\n\t/* Remove page from free list */\n\tlist_del(&page->lru);\n\tzone->free_area[order].nr_free--;\n\trmv_page_order(page);\n\n\t/*\n\t * Set the pageblock if the isolated page is at least half of a\n\t * pageblock\n\t */\n\tif (order >= pageblock_order - 1) {\n\t\tstruct page *endpage = page + (1 << order) - 1;\n\t\tfor (; page < endpage; page += pageblock_nr_pages) {\n\t\t\tint mt = get_pageblock_migratetype(page);\n\t\t\tif (!is_migrate_isolate(mt) && !is_migrate_cma(mt)\n\t\t\t    && !is_migrate_highatomic(mt))\n\t\t\t\tset_pageblock_migratetype(page,\n\t\t\t\t\t\t\t  MIGRATE_MOVABLE);\n\t\t}\n\t}\n\n\n\treturn 1UL << order;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);",
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_pageblock_migratetype",
          "args": [
            "page",
            "MIGRATE_MOVABLE"
          ],
          "line": 2899
        },
        "resolved": true,
        "details": {
          "function_name": "set_pageblock_migratetype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "450-458",
          "snippet": "void set_pageblock_migratetype(struct page *page, int migratetype)\n{\n\tif (unlikely(page_group_by_mobility_disabled &&\n\t\t     migratetype < MIGRATE_PCPTYPES))\n\t\tmigratetype = MIGRATE_UNMOVABLE;\n\n\tset_pageblock_flags_group(page, (unsigned long)migratetype,\n\t\t\t\t\tPB_migrate, PB_migrate_end);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int page_group_by_mobility_disabled",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nint page_group_by_mobility_disabled;\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid set_pageblock_migratetype(struct page *page, int migratetype)\n{\n\tif (unlikely(page_group_by_mobility_disabled &&\n\t\t     migratetype < MIGRATE_PCPTYPES))\n\t\tmigratetype = MIGRATE_UNMOVABLE;\n\n\tset_pageblock_flags_group(page, (unsigned long)migratetype,\n\t\t\t\t\tPB_migrate, PB_migrate_end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_migrate_highatomic",
          "args": [
            "mt"
          ],
          "line": 2898
        },
        "resolved": true,
        "details": {
          "function_name": "is_migrate_highatomic_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "523-526",
          "snippet": "static inline bool is_migrate_highatomic_page(struct page *page)\n{\n\treturn get_pageblock_migratetype(page) == MIGRATE_HIGHATOMIC;\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline bool is_migrate_highatomic_page(struct page *page)\n{\n\treturn get_pageblock_migratetype(page) == MIGRATE_HIGHATOMIC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_migrate_cma",
          "args": [
            "mt"
          ],
          "line": 2897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_migrate_isolate",
          "args": [
            "mt"
          ],
          "line": 2897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_pageblock_migratetype",
          "args": [
            "page"
          ],
          "line": 2896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rmv_page_order",
          "args": [
            "page"
          ],
          "line": 2887
        },
        "resolved": true,
        "details": {
          "function_name": "rmv_page_order",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "707-711",
          "snippet": "static inline void rmv_page_order(struct page *page)\n{\n\t__ClearPageBuddy(page);\n\tset_page_private(page, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline void rmv_page_order(struct page *page)\n{\n\t__ClearPageBuddy(page);\n\tset_page_private(page, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&page->lru"
          ],
          "line": 2885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mod_zone_freepage_state",
          "args": [
            "zone",
            "-(1UL << order)",
            "mt"
          ],
          "line": 2881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_watermark_ok",
          "args": [
            "zone",
            "0",
            "watermark",
            "0",
            "ALLOC_CMA"
          ],
          "line": 2878
        },
        "resolved": true,
        "details": {
          "function_name": "zone_watermark_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "3198-3203",
          "snippet": "bool zone_watermark_ok(struct zone *z, unsigned int order, unsigned long mark,\n\t\t      int classzone_idx, unsigned int alloc_flags)\n{\n\treturn __zone_watermark_ok(z, order, mark, classzone_idx, alloc_flags,\n\t\t\t\t\tzone_page_state(z, NR_FREE_PAGES));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nbool zone_watermark_ok(struct zone *z, unsigned int order, unsigned long mark,\n\t\t      int classzone_idx, unsigned int alloc_flags)\n{\n\treturn __zone_watermark_ok(z, order, mark, classzone_idx, alloc_flags,\n\t\t\t\t\tzone_page_state(z, NR_FREE_PAGES));\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_wmark_pages",
          "args": [
            "zone"
          ],
          "line": 2877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_migrate_isolate",
          "args": [
            "mt"
          ],
          "line": 2870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_pageblock_migratetype",
          "args": [
            "page"
          ],
          "line": 2868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "page"
          ],
          "line": 2867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageBuddy(page)"
          ],
          "line": 2865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageBuddy",
          "args": [
            "page"
          ],
          "line": 2865
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nint __isolate_free_page(struct page *page, unsigned int order)\n{\n\tunsigned long watermark;\n\tstruct zone *zone;\n\tint mt;\n\n\tBUG_ON(!PageBuddy(page));\n\n\tzone = page_zone(page);\n\tmt = get_pageblock_migratetype(page);\n\n\tif (!is_migrate_isolate(mt)) {\n\t\t/*\n\t\t * Obey watermarks as if the page was being allocated. We can\n\t\t * emulate a high-order watermark check with a raised order-0\n\t\t * watermark, because we already know our high-order page\n\t\t * exists.\n\t\t */\n\t\twatermark = min_wmark_pages(zone) + (1UL << order);\n\t\tif (!zone_watermark_ok(zone, 0, watermark, 0, ALLOC_CMA))\n\t\t\treturn 0;\n\n\t\t__mod_zone_freepage_state(zone, -(1UL << order), mt);\n\t}\n\n\t/* Remove page from free list */\n\tlist_del(&page->lru);\n\tzone->free_area[order].nr_free--;\n\trmv_page_order(page);\n\n\t/*\n\t * Set the pageblock if the isolated page is at least half of a\n\t * pageblock\n\t */\n\tif (order >= pageblock_order - 1) {\n\t\tstruct page *endpage = page + (1 << order) - 1;\n\t\tfor (; page < endpage; page += pageblock_nr_pages) {\n\t\t\tint mt = get_pageblock_migratetype(page);\n\t\t\tif (!is_migrate_isolate(mt) && !is_migrate_cma(mt)\n\t\t\t    && !is_migrate_highatomic(mt))\n\t\t\t\tset_pageblock_migratetype(page,\n\t\t\t\t\t\t\t  MIGRATE_MOVABLE);\n\t\t}\n\t}\n\n\n\treturn 1UL << order;\n}"
  },
  {
    "function_name": "split_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "2846-2856",
    "snippet": "void split_page(struct page *page, unsigned int order)\n{\n\tint i;\n\n\tVM_BUG_ON_PAGE(PageCompound(page), page);\n\tVM_BUG_ON_PAGE(!page_count(page), page);\n\n\tfor (i = 1; i < (1 << order); i++)\n\t\tset_page_refcounted(page + i);\n\tsplit_page_owner(page, order);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);",
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "split_page_owner",
          "args": [
            "page",
            "order"
          ],
          "line": 2855
        },
        "resolved": true,
        "details": {
          "function_name": "__split_page_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_owner.c",
          "lines": "211-224",
          "snippet": "void __split_page_owner(struct page *page, unsigned int order)\n{\n\tint i;\n\tstruct page_ext *page_ext = lookup_page_ext(page);\n\tstruct page_owner *page_owner;\n\n\tif (unlikely(!page_ext))\n\t\treturn;\n\n\tpage_owner = get_page_owner(page_ext);\n\tpage_owner->order = 0;\n\tfor (i = 1; i < (1 << order); i++)\n\t\t__copy_page_owner(page, page + i);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/stackdepot.h>",
            "#include <linux/migrate.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/stackdepot.h>\n#include <linux/migrate.h>\n#include <linux/jump_label.h>\n#include <linux/page_owner.h>\n#include <linux/stacktrace.h>\n#include <linux/memblock.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/debugfs.h>\n\nvoid __split_page_owner(struct page *page, unsigned int order)\n{\n\tint i;\n\tstruct page_ext *page_ext = lookup_page_ext(page);\n\tstruct page_owner *page_owner;\n\n\tif (unlikely(!page_ext))\n\t\treturn;\n\n\tpage_owner = get_page_owner(page_ext);\n\tpage_owner->order = 0;\n\tfor (i = 1; i < (1 << order); i++)\n\t\t__copy_page_owner(page, page + i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_refcounted",
          "args": [
            "page + i"
          ],
          "line": 2854
        },
        "resolved": true,
        "details": {
          "function_name": "set_page_refcounted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "74-79",
          "snippet": "static inline void set_page_refcounted(struct page *page)\n{\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\tVM_BUG_ON_PAGE(page_ref_count(page), page);\n\tset_page_count(page, 1);\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void set_page_refcounted(struct page *page)\n{\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\tVM_BUG_ON_PAGE(page_ref_count(page), page);\n\tset_page_count(page, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!page_count(page)",
            "page"
          ],
          "line": 2851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "page"
          ],
          "line": 2851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "PageCompound(page)",
            "page"
          ],
          "line": 2850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageCompound",
          "args": [
            "page"
          ],
          "line": 2850
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid split_page(struct page *page, unsigned int order)\n{\n\tint i;\n\n\tVM_BUG_ON_PAGE(PageCompound(page), page);\n\tVM_BUG_ON_PAGE(!page_count(page), page);\n\n\tfor (i = 1; i < (1 << order); i++)\n\t\tset_page_refcounted(page + i);\n\tsplit_page_owner(page, order);\n}"
  },
  {
    "function_name": "free_unref_page_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "2803-2836",
    "snippet": "void free_unref_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\tunsigned long flags, pfn;\n\tint batch_count = 0;\n\n\t/* Prepare pages for freeing */\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tpfn = page_to_pfn(page);\n\t\tif (!free_unref_page_prepare(page, pfn))\n\t\t\tlist_del(&page->lru);\n\t\tset_page_private(page, pfn);\n\t}\n\n\tlocal_irq_save(flags);\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tunsigned long pfn = page_private(page);\n\n\t\tset_page_private(page, 0);\n\t\ttrace_mm_page_free_batched(page);\n\t\tfree_unref_page_commit(page, pfn);\n\n\t\t/*\n\t\t * Guard against excessive IRQ disabled times when we get\n\t\t * a large list of pages to free.\n\t\t */\n\t\tif (++batch_count == SWAP_CLUSTER_MAX) {\n\t\t\tlocal_irq_restore(flags);\n\t\t\tbatch_count = 0;\n\t\t\tlocal_irq_save(flags);\n\t\t}\n\t}\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 2835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 2832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 2830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_unref_page_commit",
          "args": [
            "page",
            "pfn"
          ],
          "line": 2823
        },
        "resolved": true,
        "details": {
          "function_name": "free_unref_page_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "2751-2782",
          "snippet": "static void free_unref_page_commit(struct page *page, unsigned long pfn)\n{\n\tstruct zone *zone = page_zone(page);\n\tstruct per_cpu_pages *pcp;\n\tint migratetype;\n\n\tmigratetype = get_pcppage_migratetype(page);\n\t__count_vm_event(PGFREE);\n\n\t/*\n\t * We only track unmovable, reclaimable and movable on pcp lists.\n\t * Free ISOLATE pages back to the allocator because they are being\n\t * offlined but treat HIGHATOMIC as movable pages so we can get those\n\t * areas back if necessary. Otherwise, we may have to free\n\t * excessively into the page allocator\n\t */\n\tif (migratetype >= MIGRATE_PCPTYPES) {\n\t\tif (unlikely(is_migrate_isolate(migratetype))) {\n\t\t\tfree_one_page(zone, page, pfn, 0, migratetype);\n\t\t\treturn;\n\t\t}\n\t\tmigratetype = MIGRATE_MOVABLE;\n\t}\n\n\tpcp = &this_cpu_ptr(zone->pageset)->pcp;\n\tlist_add(&page->lru, &pcp->lists[migratetype]);\n\tpcp->count++;\n\tif (pcp->count >= pcp->high) {\n\t\tunsigned long batch = READ_ONCE(pcp->batch);\n\t\tfree_pcppages_bulk(zone, batch, pcp);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic void free_unref_page_commit(struct page *page, unsigned long pfn)\n{\n\tstruct zone *zone = page_zone(page);\n\tstruct per_cpu_pages *pcp;\n\tint migratetype;\n\n\tmigratetype = get_pcppage_migratetype(page);\n\t__count_vm_event(PGFREE);\n\n\t/*\n\t * We only track unmovable, reclaimable and movable on pcp lists.\n\t * Free ISOLATE pages back to the allocator because they are being\n\t * offlined but treat HIGHATOMIC as movable pages so we can get those\n\t * areas back if necessary. Otherwise, we may have to free\n\t * excessively into the page allocator\n\t */\n\tif (migratetype >= MIGRATE_PCPTYPES) {\n\t\tif (unlikely(is_migrate_isolate(migratetype))) {\n\t\t\tfree_one_page(zone, page, pfn, 0, migratetype);\n\t\t\treturn;\n\t\t}\n\t\tmigratetype = MIGRATE_MOVABLE;\n\t}\n\n\tpcp = &this_cpu_ptr(zone->pageset)->pcp;\n\tlist_add(&page->lru, &pcp->lists[migratetype]);\n\tpcp->count++;\n\tif (pcp->count >= pcp->high) {\n\t\tunsigned long batch = READ_ONCE(pcp->batch);\n\t\tfree_pcppages_bulk(zone, batch, pcp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_mm_page_free_batched",
          "args": [
            "page"
          ],
          "line": 2822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "page",
            "0"
          ],
          "line": 2821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_private",
          "args": [
            "page"
          ],
          "line": 2819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "page",
            "next",
            "list",
            "lru"
          ],
          "line": 2818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 2817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "page",
            "pfn"
          ],
          "line": 2814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&page->lru"
          ],
          "line": 2813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_unref_page_prepare",
          "args": [
            "page",
            "pfn"
          ],
          "line": 2812
        },
        "resolved": true,
        "details": {
          "function_name": "free_unref_page_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "2739-2749",
          "snippet": "static bool free_unref_page_prepare(struct page *page, unsigned long pfn)\n{\n\tint migratetype;\n\n\tif (!free_pcp_prepare(page))\n\t\treturn false;\n\n\tmigratetype = get_pfnblock_migratetype(page, pfn);\n\tset_pcppage_migratetype(page, migratetype);\n\treturn true;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool free_unref_page_prepare(struct page *page, unsigned long pfn)\n{\n\tint migratetype;\n\n\tif (!free_pcp_prepare(page))\n\t\treturn false;\n\n\tmigratetype = get_pfnblock_migratetype(page, pfn);\n\tset_pcppage_migratetype(page, migratetype);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "page"
          ],
          "line": 2811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "page",
            "next",
            "list",
            "lru"
          ],
          "line": 2810
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid free_unref_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\tunsigned long flags, pfn;\n\tint batch_count = 0;\n\n\t/* Prepare pages for freeing */\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tpfn = page_to_pfn(page);\n\t\tif (!free_unref_page_prepare(page, pfn))\n\t\t\tlist_del(&page->lru);\n\t\tset_page_private(page, pfn);\n\t}\n\n\tlocal_irq_save(flags);\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tunsigned long pfn = page_private(page);\n\n\t\tset_page_private(page, 0);\n\t\ttrace_mm_page_free_batched(page);\n\t\tfree_unref_page_commit(page, pfn);\n\n\t\t/*\n\t\t * Guard against excessive IRQ disabled times when we get\n\t\t * a large list of pages to free.\n\t\t */\n\t\tif (++batch_count == SWAP_CLUSTER_MAX) {\n\t\t\tlocal_irq_restore(flags);\n\t\t\tbatch_count = 0;\n\t\t\tlocal_irq_save(flags);\n\t\t}\n\t}\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "free_unref_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "2787-2798",
    "snippet": "void free_unref_page(struct page *page)\n{\n\tunsigned long flags;\n\tunsigned long pfn = page_to_pfn(page);\n\n\tif (!free_unref_page_prepare(page, pfn))\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tfree_unref_page_commit(page, pfn);\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 2797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_unref_page_commit",
          "args": [
            "page",
            "pfn"
          ],
          "line": 2796
        },
        "resolved": true,
        "details": {
          "function_name": "free_unref_page_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "2751-2782",
          "snippet": "static void free_unref_page_commit(struct page *page, unsigned long pfn)\n{\n\tstruct zone *zone = page_zone(page);\n\tstruct per_cpu_pages *pcp;\n\tint migratetype;\n\n\tmigratetype = get_pcppage_migratetype(page);\n\t__count_vm_event(PGFREE);\n\n\t/*\n\t * We only track unmovable, reclaimable and movable on pcp lists.\n\t * Free ISOLATE pages back to the allocator because they are being\n\t * offlined but treat HIGHATOMIC as movable pages so we can get those\n\t * areas back if necessary. Otherwise, we may have to free\n\t * excessively into the page allocator\n\t */\n\tif (migratetype >= MIGRATE_PCPTYPES) {\n\t\tif (unlikely(is_migrate_isolate(migratetype))) {\n\t\t\tfree_one_page(zone, page, pfn, 0, migratetype);\n\t\t\treturn;\n\t\t}\n\t\tmigratetype = MIGRATE_MOVABLE;\n\t}\n\n\tpcp = &this_cpu_ptr(zone->pageset)->pcp;\n\tlist_add(&page->lru, &pcp->lists[migratetype]);\n\tpcp->count++;\n\tif (pcp->count >= pcp->high) {\n\t\tunsigned long batch = READ_ONCE(pcp->batch);\n\t\tfree_pcppages_bulk(zone, batch, pcp);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic void free_unref_page_commit(struct page *page, unsigned long pfn)\n{\n\tstruct zone *zone = page_zone(page);\n\tstruct per_cpu_pages *pcp;\n\tint migratetype;\n\n\tmigratetype = get_pcppage_migratetype(page);\n\t__count_vm_event(PGFREE);\n\n\t/*\n\t * We only track unmovable, reclaimable and movable on pcp lists.\n\t * Free ISOLATE pages back to the allocator because they are being\n\t * offlined but treat HIGHATOMIC as movable pages so we can get those\n\t * areas back if necessary. Otherwise, we may have to free\n\t * excessively into the page allocator\n\t */\n\tif (migratetype >= MIGRATE_PCPTYPES) {\n\t\tif (unlikely(is_migrate_isolate(migratetype))) {\n\t\t\tfree_one_page(zone, page, pfn, 0, migratetype);\n\t\t\treturn;\n\t\t}\n\t\tmigratetype = MIGRATE_MOVABLE;\n\t}\n\n\tpcp = &this_cpu_ptr(zone->pageset)->pcp;\n\tlist_add(&page->lru, &pcp->lists[migratetype]);\n\tpcp->count++;\n\tif (pcp->count >= pcp->high) {\n\t\tunsigned long batch = READ_ONCE(pcp->batch);\n\t\tfree_pcppages_bulk(zone, batch, pcp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 2795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_unref_page_prepare",
          "args": [
            "page",
            "pfn"
          ],
          "line": 2792
        },
        "resolved": true,
        "details": {
          "function_name": "free_unref_page_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "2739-2749",
          "snippet": "static bool free_unref_page_prepare(struct page *page, unsigned long pfn)\n{\n\tint migratetype;\n\n\tif (!free_pcp_prepare(page))\n\t\treturn false;\n\n\tmigratetype = get_pfnblock_migratetype(page, pfn);\n\tset_pcppage_migratetype(page, migratetype);\n\treturn true;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool free_unref_page_prepare(struct page *page, unsigned long pfn)\n{\n\tint migratetype;\n\n\tif (!free_pcp_prepare(page))\n\t\treturn false;\n\n\tmigratetype = get_pfnblock_migratetype(page, pfn);\n\tset_pcppage_migratetype(page, migratetype);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "page"
          ],
          "line": 2790
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid free_unref_page(struct page *page)\n{\n\tunsigned long flags;\n\tunsigned long pfn = page_to_pfn(page);\n\n\tif (!free_unref_page_prepare(page, pfn))\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tfree_unref_page_commit(page, pfn);\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "free_unref_page_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "2751-2782",
    "snippet": "static void free_unref_page_commit(struct page *page, unsigned long pfn)\n{\n\tstruct zone *zone = page_zone(page);\n\tstruct per_cpu_pages *pcp;\n\tint migratetype;\n\n\tmigratetype = get_pcppage_migratetype(page);\n\t__count_vm_event(PGFREE);\n\n\t/*\n\t * We only track unmovable, reclaimable and movable on pcp lists.\n\t * Free ISOLATE pages back to the allocator because they are being\n\t * offlined but treat HIGHATOMIC as movable pages so we can get those\n\t * areas back if necessary. Otherwise, we may have to free\n\t * excessively into the page allocator\n\t */\n\tif (migratetype >= MIGRATE_PCPTYPES) {\n\t\tif (unlikely(is_migrate_isolate(migratetype))) {\n\t\t\tfree_one_page(zone, page, pfn, 0, migratetype);\n\t\t\treturn;\n\t\t}\n\t\tmigratetype = MIGRATE_MOVABLE;\n\t}\n\n\tpcp = &this_cpu_ptr(zone->pageset)->pcp;\n\tlist_add(&page->lru, &pcp->lists[migratetype]);\n\tpcp->count++;\n\tif (pcp->count >= pcp->high) {\n\t\tunsigned long batch = READ_ONCE(pcp->batch);\n\t\tfree_pcppages_bulk(zone, batch, pcp);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_pcppages_bulk",
          "args": [
            "zone",
            "batch",
            "pcp"
          ],
          "line": 2780
        },
        "resolved": true,
        "details": {
          "function_name": "free_pcppages_bulk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1087-1162",
          "snippet": "static void free_pcppages_bulk(struct zone *zone, int count,\n\t\t\t\t\tstruct per_cpu_pages *pcp)\n{\n\tint migratetype = 0;\n\tint batch_free = 0;\n\tint prefetch_nr = 0;\n\tbool isolated_pageblocks;\n\tstruct page *page, *tmp;\n\tLIST_HEAD(head);\n\n\twhile (count) {\n\t\tstruct list_head *list;\n\n\t\t/*\n\t\t * Remove pages from lists in a round-robin fashion. A\n\t\t * batch_free count is maintained that is incremented when an\n\t\t * empty list is encountered.  This is so more pages are freed\n\t\t * off fuller lists instead of spinning excessively around empty\n\t\t * lists\n\t\t */\n\t\tdo {\n\t\t\tbatch_free++;\n\t\t\tif (++migratetype == MIGRATE_PCPTYPES)\n\t\t\t\tmigratetype = 0;\n\t\t\tlist = &pcp->lists[migratetype];\n\t\t} while (list_empty(list));\n\n\t\t/* This is the only non-empty list. Free them all. */\n\t\tif (batch_free == MIGRATE_PCPTYPES)\n\t\t\tbatch_free = count;\n\n\t\tdo {\n\t\t\tpage = list_last_entry(list, struct page, lru);\n\t\t\t/* must delete to avoid corrupting pcp list */\n\t\t\tlist_del(&page->lru);\n\t\t\tpcp->count--;\n\n\t\t\tif (bulkfree_pcp_prepare(page))\n\t\t\t\tcontinue;\n\n\t\t\tlist_add_tail(&page->lru, &head);\n\n\t\t\t/*\n\t\t\t * We are going to put the page back to the global\n\t\t\t * pool, prefetch its buddy to speed up later access\n\t\t\t * under zone->lock. It is believed the overhead of\n\t\t\t * an additional test and calculating buddy_pfn here\n\t\t\t * can be offset by reduced memory latency later. To\n\t\t\t * avoid excessive prefetching due to large count, only\n\t\t\t * prefetch buddy for the first pcp->batch nr of pages.\n\t\t\t */\n\t\t\tif (prefetch_nr++ < pcp->batch)\n\t\t\t\tprefetch_buddy(page);\n\t\t} while (--count && --batch_free && !list_empty(list));\n\t}\n\n\tspin_lock(&zone->lock);\n\tisolated_pageblocks = has_isolate_pageblock(zone);\n\n\t/*\n\t * Use safe version since after __free_one_page(),\n\t * page->lru.next will not point to original list.\n\t */\n\tlist_for_each_entry_safe(page, tmp, &head, lru) {\n\t\tint mt = get_pcppage_migratetype(page);\n\t\t/* MIGRATE_ISOLATE page should not go to pcplists */\n\t\tVM_BUG_ON_PAGE(is_migrate_isolate(mt), page);\n\t\t/* Pageblock could have been isolated meanwhile */\n\t\tif (unlikely(isolated_pageblocks))\n\t\t\tmt = get_pageblock_migratetype(page);\n\n\t\t__free_one_page(page, page_to_pfn(page), zone, 0, mt);\n\t\ttrace_mm_page_pcpu_drain(page, 0, mt);\n\t}\n\tspin_unlock(&zone->lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic void free_pcppages_bulk(struct zone *zone, int count,\n\t\t\t\t\tstruct per_cpu_pages *pcp)\n{\n\tint migratetype = 0;\n\tint batch_free = 0;\n\tint prefetch_nr = 0;\n\tbool isolated_pageblocks;\n\tstruct page *page, *tmp;\n\tLIST_HEAD(head);\n\n\twhile (count) {\n\t\tstruct list_head *list;\n\n\t\t/*\n\t\t * Remove pages from lists in a round-robin fashion. A\n\t\t * batch_free count is maintained that is incremented when an\n\t\t * empty list is encountered.  This is so more pages are freed\n\t\t * off fuller lists instead of spinning excessively around empty\n\t\t * lists\n\t\t */\n\t\tdo {\n\t\t\tbatch_free++;\n\t\t\tif (++migratetype == MIGRATE_PCPTYPES)\n\t\t\t\tmigratetype = 0;\n\t\t\tlist = &pcp->lists[migratetype];\n\t\t} while (list_empty(list));\n\n\t\t/* This is the only non-empty list. Free them all. */\n\t\tif (batch_free == MIGRATE_PCPTYPES)\n\t\t\tbatch_free = count;\n\n\t\tdo {\n\t\t\tpage = list_last_entry(list, struct page, lru);\n\t\t\t/* must delete to avoid corrupting pcp list */\n\t\t\tlist_del(&page->lru);\n\t\t\tpcp->count--;\n\n\t\t\tif (bulkfree_pcp_prepare(page))\n\t\t\t\tcontinue;\n\n\t\t\tlist_add_tail(&page->lru, &head);\n\n\t\t\t/*\n\t\t\t * We are going to put the page back to the global\n\t\t\t * pool, prefetch its buddy to speed up later access\n\t\t\t * under zone->lock. It is believed the overhead of\n\t\t\t * an additional test and calculating buddy_pfn here\n\t\t\t * can be offset by reduced memory latency later. To\n\t\t\t * avoid excessive prefetching due to large count, only\n\t\t\t * prefetch buddy for the first pcp->batch nr of pages.\n\t\t\t */\n\t\t\tif (prefetch_nr++ < pcp->batch)\n\t\t\t\tprefetch_buddy(page);\n\t\t} while (--count && --batch_free && !list_empty(list));\n\t}\n\n\tspin_lock(&zone->lock);\n\tisolated_pageblocks = has_isolate_pageblock(zone);\n\n\t/*\n\t * Use safe version since after __free_one_page(),\n\t * page->lru.next will not point to original list.\n\t */\n\tlist_for_each_entry_safe(page, tmp, &head, lru) {\n\t\tint mt = get_pcppage_migratetype(page);\n\t\t/* MIGRATE_ISOLATE page should not go to pcplists */\n\t\tVM_BUG_ON_PAGE(is_migrate_isolate(mt), page);\n\t\t/* Pageblock could have been isolated meanwhile */\n\t\tif (unlikely(isolated_pageblocks))\n\t\t\tmt = get_pageblock_migratetype(page);\n\n\t\t__free_one_page(page, page_to_pfn(page), zone, 0, mt);\n\t\ttrace_mm_page_pcpu_drain(page, 0, mt);\n\t}\n\tspin_unlock(&zone->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "pcp->batch"
          ],
          "line": 2779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&page->lru",
            "&pcp->lists[migratetype]"
          ],
          "line": 2776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "zone->pageset"
          ],
          "line": 2775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_one_page",
          "args": [
            "zone",
            "page",
            "pfn",
            "0",
            "migratetype"
          ],
          "line": 2769
        },
        "resolved": true,
        "details": {
          "function_name": "free_one_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1164-1176",
          "snippet": "static void free_one_page(struct zone *zone,\n\t\t\t\tstruct page *page, unsigned long pfn,\n\t\t\t\tunsigned int order,\n\t\t\t\tint migratetype)\n{\n\tspin_lock(&zone->lock);\n\tif (unlikely(has_isolate_pageblock(zone) ||\n\t\tis_migrate_isolate(migratetype))) {\n\t\tmigratetype = get_pfnblock_migratetype(page, pfn);\n\t}\n\t__free_one_page(page, pfn, zone, order, migratetype);\n\tspin_unlock(&zone->lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic void free_one_page(struct zone *zone,\n\t\t\t\tstruct page *page, unsigned long pfn,\n\t\t\t\tunsigned int order,\n\t\t\t\tint migratetype)\n{\n\tspin_lock(&zone->lock);\n\tif (unlikely(has_isolate_pageblock(zone) ||\n\t\tis_migrate_isolate(migratetype))) {\n\t\tmigratetype = get_pfnblock_migratetype(page, pfn);\n\t}\n\t__free_one_page(page, pfn, zone, order, migratetype);\n\tspin_unlock(&zone->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "is_migrate_isolate(migratetype)"
          ],
          "line": 2768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_migrate_isolate",
          "args": [
            "migratetype"
          ],
          "line": 2768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__count_vm_event",
          "args": [
            "PGFREE"
          ],
          "line": 2758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_pcppage_migratetype",
          "args": [
            "page"
          ],
          "line": 2757
        },
        "resolved": true,
        "details": {
          "function_name": "get_pcppage_migratetype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "142-145",
          "snippet": "static inline int get_pcppage_migratetype(struct page *page)\n{\n\treturn page->index;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline int get_pcppage_migratetype(struct page *page)\n{\n\treturn page->index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "page"
          ],
          "line": 2753
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic void free_unref_page_commit(struct page *page, unsigned long pfn)\n{\n\tstruct zone *zone = page_zone(page);\n\tstruct per_cpu_pages *pcp;\n\tint migratetype;\n\n\tmigratetype = get_pcppage_migratetype(page);\n\t__count_vm_event(PGFREE);\n\n\t/*\n\t * We only track unmovable, reclaimable and movable on pcp lists.\n\t * Free ISOLATE pages back to the allocator because they are being\n\t * offlined but treat HIGHATOMIC as movable pages so we can get those\n\t * areas back if necessary. Otherwise, we may have to free\n\t * excessively into the page allocator\n\t */\n\tif (migratetype >= MIGRATE_PCPTYPES) {\n\t\tif (unlikely(is_migrate_isolate(migratetype))) {\n\t\t\tfree_one_page(zone, page, pfn, 0, migratetype);\n\t\t\treturn;\n\t\t}\n\t\tmigratetype = MIGRATE_MOVABLE;\n\t}\n\n\tpcp = &this_cpu_ptr(zone->pageset)->pcp;\n\tlist_add(&page->lru, &pcp->lists[migratetype]);\n\tpcp->count++;\n\tif (pcp->count >= pcp->high) {\n\t\tunsigned long batch = READ_ONCE(pcp->batch);\n\t\tfree_pcppages_bulk(zone, batch, pcp);\n\t}\n}"
  },
  {
    "function_name": "free_unref_page_prepare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "2739-2749",
    "snippet": "static bool free_unref_page_prepare(struct page *page, unsigned long pfn)\n{\n\tint migratetype;\n\n\tif (!free_pcp_prepare(page))\n\t\treturn false;\n\n\tmigratetype = get_pfnblock_migratetype(page, pfn);\n\tset_pcppage_migratetype(page, migratetype);\n\treturn true;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_pcppage_migratetype",
          "args": [
            "page",
            "migratetype"
          ],
          "line": 2747
        },
        "resolved": true,
        "details": {
          "function_name": "set_pcppage_migratetype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "147-150",
          "snippet": "static inline void set_pcppage_migratetype(struct page *page, int migratetype)\n{\n\tpage->index = migratetype;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline void set_pcppage_migratetype(struct page *page, int migratetype)\n{\n\tpage->index = migratetype;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pfnblock_migratetype",
          "args": [
            "page",
            "pfn"
          ],
          "line": 2746
        },
        "resolved": true,
        "details": {
          "function_name": "get_pfnblock_migratetype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "406-409",
          "snippet": "static __always_inline int get_pfnblock_migratetype(struct page *page, unsigned long pfn)\n{\n\treturn __get_pfnblock_flags_mask(page, pfn, PB_migrate_end, MIGRATETYPE_MASK);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic __always_inline int get_pfnblock_migratetype(struct page *page, unsigned long pfn)\n{\n\treturn __get_pfnblock_flags_mask(page, pfn, PB_migrate_end, MIGRATETYPE_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_pcp_prepare",
          "args": [
            "page"
          ],
          "line": 2743
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool free_unref_page_prepare(struct page *page, unsigned long pfn)\n{\n\tint migratetype;\n\n\tif (!free_pcp_prepare(page))\n\t\treturn false;\n\n\tmigratetype = get_pfnblock_migratetype(page, pfn);\n\tset_pcppage_migratetype(page, migratetype);\n\treturn true;\n}"
  },
  {
    "function_name": "mark_free_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "2691-2736",
    "snippet": "void mark_free_pages(struct zone *zone)\n{\n\tunsigned long pfn, max_zone_pfn, page_count = WD_PAGE_COUNT;\n\tunsigned long flags;\n\tunsigned int order, t;\n\tstruct page *page;\n\n\tif (zone_is_empty(zone))\n\t\treturn;\n\n\tspin_lock_irqsave(&zone->lock, flags);\n\n\tmax_zone_pfn = zone_end_pfn(zone);\n\tfor (pfn = zone->zone_start_pfn; pfn < max_zone_pfn; pfn++)\n\t\tif (pfn_valid(pfn)) {\n\t\t\tpage = pfn_to_page(pfn);\n\n\t\t\tif (!--page_count) {\n\t\t\t\ttouch_nmi_watchdog();\n\t\t\t\tpage_count = WD_PAGE_COUNT;\n\t\t\t}\n\n\t\t\tif (page_zone(page) != zone)\n\t\t\t\tcontinue;\n\n\t\t\tif (!swsusp_page_is_forbidden(page))\n\t\t\t\tswsusp_unset_page_free(page);\n\t\t}\n\n\tfor_each_migratetype_order(order, t) {\n\t\tlist_for_each_entry(page,\n\t\t\t\t&zone->free_area[order].free_list[t], lru) {\n\t\t\tunsigned long i;\n\n\t\t\tpfn = page_to_pfn(page);\n\t\t\tfor (i = 0; i < (1UL << order); i++) {\n\t\t\t\tif (!--page_count) {\n\t\t\t\t\ttouch_nmi_watchdog();\n\t\t\t\t\tpage_count = WD_PAGE_COUNT;\n\t\t\t\t}\n\t\t\t\tswsusp_set_page_free(pfn_to_page(pfn + i));\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&zone->lock, flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [
      "#define WD_PAGE_COUNT\t(128*1024)"
    ],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);",
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&zone->lock",
            "flags"
          ],
          "line": 2735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swsusp_set_page_free",
          "args": [
            "pfn_to_page(pfn + i)"
          ],
          "line": 2731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn + i"
          ],
          "line": 2731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "touch_nmi_watchdog",
          "args": [],
          "line": 2728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "page"
          ],
          "line": 2725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "page",
            "&zone->free_area[order].free_list[t]",
            "lru"
          ],
          "line": 2721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_migratetype_order",
          "args": [
            "order",
            "t"
          ],
          "line": 2720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swsusp_unset_page_free",
          "args": [
            "page"
          ],
          "line": 2717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swsusp_page_is_forbidden",
          "args": [
            "page"
          ],
          "line": 2716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "page"
          ],
          "line": 2713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "touch_nmi_watchdog",
          "args": [],
          "line": 2709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 2706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_valid",
          "args": [
            "pfn"
          ],
          "line": 2705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_end_pfn",
          "args": [
            "zone"
          ],
          "line": 2703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&zone->lock",
            "flags"
          ],
          "line": 2701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_is_empty",
          "args": [
            "zone"
          ],
          "line": 2698
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\n#define WD_PAGE_COUNT\t(128*1024)\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid mark_free_pages(struct zone *zone)\n{\n\tunsigned long pfn, max_zone_pfn, page_count = WD_PAGE_COUNT;\n\tunsigned long flags;\n\tunsigned int order, t;\n\tstruct page *page;\n\n\tif (zone_is_empty(zone))\n\t\treturn;\n\n\tspin_lock_irqsave(&zone->lock, flags);\n\n\tmax_zone_pfn = zone_end_pfn(zone);\n\tfor (pfn = zone->zone_start_pfn; pfn < max_zone_pfn; pfn++)\n\t\tif (pfn_valid(pfn)) {\n\t\t\tpage = pfn_to_page(pfn);\n\n\t\t\tif (!--page_count) {\n\t\t\t\ttouch_nmi_watchdog();\n\t\t\t\tpage_count = WD_PAGE_COUNT;\n\t\t\t}\n\n\t\t\tif (page_zone(page) != zone)\n\t\t\t\tcontinue;\n\n\t\t\tif (!swsusp_page_is_forbidden(page))\n\t\t\t\tswsusp_unset_page_free(page);\n\t\t}\n\n\tfor_each_migratetype_order(order, t) {\n\t\tlist_for_each_entry(page,\n\t\t\t\t&zone->free_area[order].free_list[t], lru) {\n\t\t\tunsigned long i;\n\n\t\t\tpfn = page_to_pfn(page);\n\t\t\tfor (i = 0; i < (1UL << order); i++) {\n\t\t\t\tif (!--page_count) {\n\t\t\t\t\ttouch_nmi_watchdog();\n\t\t\t\t\tpage_count = WD_PAGE_COUNT;\n\t\t\t\t}\n\t\t\t\tswsusp_set_page_free(pfn_to_page(pfn + i));\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&zone->lock, flags);\n}"
  },
  {
    "function_name": "drain_all_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "2614-2682",
    "snippet": "void drain_all_pages(struct zone *zone)\n{\n\tint cpu;\n\n\t/*\n\t * Allocate in the BSS so we wont require allocation in\n\t * direct reclaim path for CONFIG_CPUMASK_OFFSTACK=y\n\t */\n\tstatic cpumask_t cpus_with_pcps;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON_ONCE(!mm_percpu_wq))\n\t\treturn;\n\n\t/*\n\t * Do not drain if one is already in progress unless it's specific to\n\t * a zone. Such callers are primarily CMA and memory hotplug and need\n\t * the drain to be complete when the call returns.\n\t */\n\tif (unlikely(!mutex_trylock(&pcpu_drain_mutex))) {\n\t\tif (!zone)\n\t\t\treturn;\n\t\tmutex_lock(&pcpu_drain_mutex);\n\t}\n\n\t/*\n\t * We don't care about racing with CPU hotplug event\n\t * as offline notification will cause the notified\n\t * cpu to drain that CPU pcps and on_each_cpu_mask\n\t * disables preemption as part of its processing\n\t */\n\tfor_each_online_cpu(cpu) {\n\t\tstruct per_cpu_pageset *pcp;\n\t\tstruct zone *z;\n\t\tbool has_pcps = false;\n\n\t\tif (zone) {\n\t\t\tpcp = per_cpu_ptr(zone->pageset, cpu);\n\t\t\tif (pcp->pcp.count)\n\t\t\t\thas_pcps = true;\n\t\t} else {\n\t\t\tfor_each_populated_zone(z) {\n\t\t\t\tpcp = per_cpu_ptr(z->pageset, cpu);\n\t\t\t\tif (pcp->pcp.count) {\n\t\t\t\t\thas_pcps = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (has_pcps)\n\t\t\tcpumask_set_cpu(cpu, &cpus_with_pcps);\n\t\telse\n\t\t\tcpumask_clear_cpu(cpu, &cpus_with_pcps);\n\t}\n\n\tfor_each_cpu(cpu, &cpus_with_pcps) {\n\t\tstruct work_struct *work = per_cpu_ptr(&pcpu_drain, cpu);\n\t\tINIT_WORK(work, drain_local_pages_wq);\n\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t}\n\tfor_each_cpu(cpu, &cpus_with_pcps)\n\t\tflush_work(per_cpu_ptr(&pcpu_drain, cpu));\n\n\tmutex_unlock(&pcpu_drain_mutex);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&pcpu_drain_mutex"
          ],
          "line": 2681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_work",
          "args": [
            "per_cpu_ptr(&pcpu_drain, cpu)"
          ],
          "line": 2679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&pcpu_drain",
            "cpu"
          ],
          "line": 2679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "&cpus_with_pcps"
          ],
          "line": 2678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue_work_on",
          "args": [
            "cpu",
            "mm_percpu_wq",
            "work"
          ],
          "line": 2676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "work",
            "drain_local_pages_wq"
          ],
          "line": 2675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&pcpu_drain",
            "cpu"
          ],
          "line": 2674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "&cpus_with_pcps"
          ],
          "line": 2673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "cpu",
            "&cpus_with_pcps"
          ],
          "line": 2670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_set_cpu",
          "args": [
            "cpu",
            "&cpus_with_pcps"
          ],
          "line": 2668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "z->pageset",
            "cpu"
          ],
          "line": 2659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "zone->pageset",
            "cpu"
          ],
          "line": 2654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&pcpu_drain_mutex"
          ],
          "line": 2639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!mutex_trylock(&pcpu_drain_mutex)"
          ],
          "line": 2636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_trylock",
          "args": [
            "&pcpu_drain_mutex"
          ],
          "line": 2636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!mm_percpu_wq"
          ],
          "line": 2628
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid drain_all_pages(struct zone *zone)\n{\n\tint cpu;\n\n\t/*\n\t * Allocate in the BSS so we wont require allocation in\n\t * direct reclaim path for CONFIG_CPUMASK_OFFSTACK=y\n\t */\n\tstatic cpumask_t cpus_with_pcps;\n\n\t/*\n\t * Make sure nobody triggers this path before mm_percpu_wq is fully\n\t * initialized.\n\t */\n\tif (WARN_ON_ONCE(!mm_percpu_wq))\n\t\treturn;\n\n\t/*\n\t * Do not drain if one is already in progress unless it's specific to\n\t * a zone. Such callers are primarily CMA and memory hotplug and need\n\t * the drain to be complete when the call returns.\n\t */\n\tif (unlikely(!mutex_trylock(&pcpu_drain_mutex))) {\n\t\tif (!zone)\n\t\t\treturn;\n\t\tmutex_lock(&pcpu_drain_mutex);\n\t}\n\n\t/*\n\t * We don't care about racing with CPU hotplug event\n\t * as offline notification will cause the notified\n\t * cpu to drain that CPU pcps and on_each_cpu_mask\n\t * disables preemption as part of its processing\n\t */\n\tfor_each_online_cpu(cpu) {\n\t\tstruct per_cpu_pageset *pcp;\n\t\tstruct zone *z;\n\t\tbool has_pcps = false;\n\n\t\tif (zone) {\n\t\t\tpcp = per_cpu_ptr(zone->pageset, cpu);\n\t\t\tif (pcp->pcp.count)\n\t\t\t\thas_pcps = true;\n\t\t} else {\n\t\t\tfor_each_populated_zone(z) {\n\t\t\t\tpcp = per_cpu_ptr(z->pageset, cpu);\n\t\t\t\tif (pcp->pcp.count) {\n\t\t\t\t\thas_pcps = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (has_pcps)\n\t\t\tcpumask_set_cpu(cpu, &cpus_with_pcps);\n\t\telse\n\t\t\tcpumask_clear_cpu(cpu, &cpus_with_pcps);\n\t}\n\n\tfor_each_cpu(cpu, &cpus_with_pcps) {\n\t\tstruct work_struct *work = per_cpu_ptr(&pcpu_drain, cpu);\n\t\tINIT_WORK(work, drain_local_pages_wq);\n\t\tqueue_work_on(cpu, mm_percpu_wq, work);\n\t}\n\tfor_each_cpu(cpu, &cpus_with_pcps)\n\t\tflush_work(per_cpu_ptr(&pcpu_drain, cpu));\n\n\tmutex_unlock(&pcpu_drain_mutex);\n}"
  },
  {
    "function_name": "drain_local_pages_wq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "2593-2605",
    "snippet": "static void drain_local_pages_wq(struct work_struct *work)\n{\n\t/*\n\t * drain_all_pages doesn't use proper cpu hotplug protection so\n\t * we can race with cpu offline when the WQ can move this from\n\t * a cpu pinned worker to an unbound one. We can operate on a different\n\t * cpu which is allright but we also have to make sure to not move to\n\t * a different one.\n\t */\n\tpreempt_disable();\n\tdrain_local_pages(NULL);\n\tpreempt_enable();\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 2604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "drain_local_pages",
          "args": [
            "NULL"
          ],
          "line": 2603
        },
        "resolved": true,
        "details": {
          "function_name": "drain_local_pages_wq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "2593-2605",
          "snippet": "static void drain_local_pages_wq(struct work_struct *work)\n{\n\t/*\n\t * drain_all_pages doesn't use proper cpu hotplug protection so\n\t * we can race with cpu offline when the WQ can move this from\n\t * a cpu pinned worker to an unbound one. We can operate on a different\n\t * cpu which is allright but we also have to make sure to not move to\n\t * a different one.\n\t */\n\tpreempt_disable();\n\tdrain_local_pages(NULL);\n\tpreempt_enable();\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 2602
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic void drain_local_pages_wq(struct work_struct *work)\n{\n\t/*\n\t * drain_all_pages doesn't use proper cpu hotplug protection so\n\t * we can race with cpu offline when the WQ can move this from\n\t * a cpu pinned worker to an unbound one. We can operate on a different\n\t * cpu which is allright but we also have to make sure to not move to\n\t * a different one.\n\t */\n\tpreempt_disable();\n\tdrain_local_pages(NULL);\n\tpreempt_enable();\n}"
  },
  {
    "function_name": "drain_local_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "2583-2591",
    "snippet": "void drain_local_pages(struct zone *zone)\n{\n\tint cpu = smp_processor_id();\n\n\tif (zone)\n\t\tdrain_pages_zone(cpu, zone);\n\telse\n\t\tdrain_pages(cpu);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "drain_pages",
          "args": [
            "cpu"
          ],
          "line": 2590
        },
        "resolved": true,
        "details": {
          "function_name": "drain_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "2568-2575",
          "snippet": "static void drain_pages(unsigned int cpu)\n{\n\tstruct zone *zone;\n\n\tfor_each_populated_zone(zone) {\n\t\tdrain_pages_zone(cpu, zone);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic void drain_pages(unsigned int cpu)\n{\n\tstruct zone *zone;\n\n\tfor_each_populated_zone(zone) {\n\t\tdrain_pages_zone(cpu, zone);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "drain_pages_zone",
          "args": [
            "cpu",
            "zone"
          ],
          "line": 2588
        },
        "resolved": true,
        "details": {
          "function_name": "drain_pages_zone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "2546-2559",
          "snippet": "static void drain_pages_zone(unsigned int cpu, struct zone *zone)\n{\n\tunsigned long flags;\n\tstruct per_cpu_pageset *pset;\n\tstruct per_cpu_pages *pcp;\n\n\tlocal_irq_save(flags);\n\tpset = per_cpu_ptr(zone->pageset, cpu);\n\n\tpcp = &pset->pcp;\n\tif (pcp->count)\n\t\tfree_pcppages_bulk(zone, pcp->count, pcp);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic void drain_pages_zone(unsigned int cpu, struct zone *zone)\n{\n\tunsigned long flags;\n\tstruct per_cpu_pageset *pset;\n\tstruct per_cpu_pages *pcp;\n\n\tlocal_irq_save(flags);\n\tpset = per_cpu_ptr(zone->pageset, cpu);\n\n\tpcp = &pset->pcp;\n\tif (pcp->count)\n\t\tfree_pcppages_bulk(zone, pcp->count, pcp);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 2585
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid drain_local_pages(struct zone *zone)\n{\n\tint cpu = smp_processor_id();\n\n\tif (zone)\n\t\tdrain_pages_zone(cpu, zone);\n\telse\n\t\tdrain_pages(cpu);\n}"
  },
  {
    "function_name": "drain_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "2568-2575",
    "snippet": "static void drain_pages(unsigned int cpu)\n{\n\tstruct zone *zone;\n\n\tfor_each_populated_zone(zone) {\n\t\tdrain_pages_zone(cpu, zone);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "drain_pages_zone",
          "args": [
            "cpu",
            "zone"
          ],
          "line": 2573
        },
        "resolved": true,
        "details": {
          "function_name": "drain_pages_zone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "2546-2559",
          "snippet": "static void drain_pages_zone(unsigned int cpu, struct zone *zone)\n{\n\tunsigned long flags;\n\tstruct per_cpu_pageset *pset;\n\tstruct per_cpu_pages *pcp;\n\n\tlocal_irq_save(flags);\n\tpset = per_cpu_ptr(zone->pageset, cpu);\n\n\tpcp = &pset->pcp;\n\tif (pcp->count)\n\t\tfree_pcppages_bulk(zone, pcp->count, pcp);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic void drain_pages_zone(unsigned int cpu, struct zone *zone)\n{\n\tunsigned long flags;\n\tstruct per_cpu_pageset *pset;\n\tstruct per_cpu_pages *pcp;\n\n\tlocal_irq_save(flags);\n\tpset = per_cpu_ptr(zone->pageset, cpu);\n\n\tpcp = &pset->pcp;\n\tif (pcp->count)\n\t\tfree_pcppages_bulk(zone, pcp->count, pcp);\n\tlocal_irq_restore(flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic void drain_pages(unsigned int cpu)\n{\n\tstruct zone *zone;\n\n\tfor_each_populated_zone(zone) {\n\t\tdrain_pages_zone(cpu, zone);\n\t}\n}"
  },
  {
    "function_name": "drain_pages_zone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "2546-2559",
    "snippet": "static void drain_pages_zone(unsigned int cpu, struct zone *zone)\n{\n\tunsigned long flags;\n\tstruct per_cpu_pageset *pset;\n\tstruct per_cpu_pages *pcp;\n\n\tlocal_irq_save(flags);\n\tpset = per_cpu_ptr(zone->pageset, cpu);\n\n\tpcp = &pset->pcp;\n\tif (pcp->count)\n\t\tfree_pcppages_bulk(zone, pcp->count, pcp);\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 2558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_pcppages_bulk",
          "args": [
            "zone",
            "pcp->count",
            "pcp"
          ],
          "line": 2557
        },
        "resolved": true,
        "details": {
          "function_name": "free_pcppages_bulk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1087-1162",
          "snippet": "static void free_pcppages_bulk(struct zone *zone, int count,\n\t\t\t\t\tstruct per_cpu_pages *pcp)\n{\n\tint migratetype = 0;\n\tint batch_free = 0;\n\tint prefetch_nr = 0;\n\tbool isolated_pageblocks;\n\tstruct page *page, *tmp;\n\tLIST_HEAD(head);\n\n\twhile (count) {\n\t\tstruct list_head *list;\n\n\t\t/*\n\t\t * Remove pages from lists in a round-robin fashion. A\n\t\t * batch_free count is maintained that is incremented when an\n\t\t * empty list is encountered.  This is so more pages are freed\n\t\t * off fuller lists instead of spinning excessively around empty\n\t\t * lists\n\t\t */\n\t\tdo {\n\t\t\tbatch_free++;\n\t\t\tif (++migratetype == MIGRATE_PCPTYPES)\n\t\t\t\tmigratetype = 0;\n\t\t\tlist = &pcp->lists[migratetype];\n\t\t} while (list_empty(list));\n\n\t\t/* This is the only non-empty list. Free them all. */\n\t\tif (batch_free == MIGRATE_PCPTYPES)\n\t\t\tbatch_free = count;\n\n\t\tdo {\n\t\t\tpage = list_last_entry(list, struct page, lru);\n\t\t\t/* must delete to avoid corrupting pcp list */\n\t\t\tlist_del(&page->lru);\n\t\t\tpcp->count--;\n\n\t\t\tif (bulkfree_pcp_prepare(page))\n\t\t\t\tcontinue;\n\n\t\t\tlist_add_tail(&page->lru, &head);\n\n\t\t\t/*\n\t\t\t * We are going to put the page back to the global\n\t\t\t * pool, prefetch its buddy to speed up later access\n\t\t\t * under zone->lock. It is believed the overhead of\n\t\t\t * an additional test and calculating buddy_pfn here\n\t\t\t * can be offset by reduced memory latency later. To\n\t\t\t * avoid excessive prefetching due to large count, only\n\t\t\t * prefetch buddy for the first pcp->batch nr of pages.\n\t\t\t */\n\t\t\tif (prefetch_nr++ < pcp->batch)\n\t\t\t\tprefetch_buddy(page);\n\t\t} while (--count && --batch_free && !list_empty(list));\n\t}\n\n\tspin_lock(&zone->lock);\n\tisolated_pageblocks = has_isolate_pageblock(zone);\n\n\t/*\n\t * Use safe version since after __free_one_page(),\n\t * page->lru.next will not point to original list.\n\t */\n\tlist_for_each_entry_safe(page, tmp, &head, lru) {\n\t\tint mt = get_pcppage_migratetype(page);\n\t\t/* MIGRATE_ISOLATE page should not go to pcplists */\n\t\tVM_BUG_ON_PAGE(is_migrate_isolate(mt), page);\n\t\t/* Pageblock could have been isolated meanwhile */\n\t\tif (unlikely(isolated_pageblocks))\n\t\t\tmt = get_pageblock_migratetype(page);\n\n\t\t__free_one_page(page, page_to_pfn(page), zone, 0, mt);\n\t\ttrace_mm_page_pcpu_drain(page, 0, mt);\n\t}\n\tspin_unlock(&zone->lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic void free_pcppages_bulk(struct zone *zone, int count,\n\t\t\t\t\tstruct per_cpu_pages *pcp)\n{\n\tint migratetype = 0;\n\tint batch_free = 0;\n\tint prefetch_nr = 0;\n\tbool isolated_pageblocks;\n\tstruct page *page, *tmp;\n\tLIST_HEAD(head);\n\n\twhile (count) {\n\t\tstruct list_head *list;\n\n\t\t/*\n\t\t * Remove pages from lists in a round-robin fashion. A\n\t\t * batch_free count is maintained that is incremented when an\n\t\t * empty list is encountered.  This is so more pages are freed\n\t\t * off fuller lists instead of spinning excessively around empty\n\t\t * lists\n\t\t */\n\t\tdo {\n\t\t\tbatch_free++;\n\t\t\tif (++migratetype == MIGRATE_PCPTYPES)\n\t\t\t\tmigratetype = 0;\n\t\t\tlist = &pcp->lists[migratetype];\n\t\t} while (list_empty(list));\n\n\t\t/* This is the only non-empty list. Free them all. */\n\t\tif (batch_free == MIGRATE_PCPTYPES)\n\t\t\tbatch_free = count;\n\n\t\tdo {\n\t\t\tpage = list_last_entry(list, struct page, lru);\n\t\t\t/* must delete to avoid corrupting pcp list */\n\t\t\tlist_del(&page->lru);\n\t\t\tpcp->count--;\n\n\t\t\tif (bulkfree_pcp_prepare(page))\n\t\t\t\tcontinue;\n\n\t\t\tlist_add_tail(&page->lru, &head);\n\n\t\t\t/*\n\t\t\t * We are going to put the page back to the global\n\t\t\t * pool, prefetch its buddy to speed up later access\n\t\t\t * under zone->lock. It is believed the overhead of\n\t\t\t * an additional test and calculating buddy_pfn here\n\t\t\t * can be offset by reduced memory latency later. To\n\t\t\t * avoid excessive prefetching due to large count, only\n\t\t\t * prefetch buddy for the first pcp->batch nr of pages.\n\t\t\t */\n\t\t\tif (prefetch_nr++ < pcp->batch)\n\t\t\t\tprefetch_buddy(page);\n\t\t} while (--count && --batch_free && !list_empty(list));\n\t}\n\n\tspin_lock(&zone->lock);\n\tisolated_pageblocks = has_isolate_pageblock(zone);\n\n\t/*\n\t * Use safe version since after __free_one_page(),\n\t * page->lru.next will not point to original list.\n\t */\n\tlist_for_each_entry_safe(page, tmp, &head, lru) {\n\t\tint mt = get_pcppage_migratetype(page);\n\t\t/* MIGRATE_ISOLATE page should not go to pcplists */\n\t\tVM_BUG_ON_PAGE(is_migrate_isolate(mt), page);\n\t\t/* Pageblock could have been isolated meanwhile */\n\t\tif (unlikely(isolated_pageblocks))\n\t\t\tmt = get_pageblock_migratetype(page);\n\n\t\t__free_one_page(page, page_to_pfn(page), zone, 0, mt);\n\t\ttrace_mm_page_pcpu_drain(page, 0, mt);\n\t}\n\tspin_unlock(&zone->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "zone->pageset",
            "cpu"
          ],
          "line": 2553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 2552
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic void drain_pages_zone(unsigned int cpu, struct zone *zone)\n{\n\tunsigned long flags;\n\tstruct per_cpu_pageset *pset;\n\tstruct per_cpu_pages *pcp;\n\n\tlocal_irq_save(flags);\n\tpset = per_cpu_ptr(zone->pageset, cpu);\n\n\tpcp = &pset->pcp;\n\tif (pcp->count)\n\t\tfree_pcppages_bulk(zone, pcp->count, pcp);\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "drain_zone_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "2525-2536",
    "snippet": "void drain_zone_pages(struct zone *zone, struct per_cpu_pages *pcp)\n{\n\tunsigned long flags;\n\tint to_drain, batch;\n\n\tlocal_irq_save(flags);\n\tbatch = READ_ONCE(pcp->batch);\n\tto_drain = min(pcp->count, batch);\n\tif (to_drain > 0)\n\t\tfree_pcppages_bulk(zone, to_drain, pcp);\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 2535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_pcppages_bulk",
          "args": [
            "zone",
            "to_drain",
            "pcp"
          ],
          "line": 2534
        },
        "resolved": true,
        "details": {
          "function_name": "free_pcppages_bulk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1087-1162",
          "snippet": "static void free_pcppages_bulk(struct zone *zone, int count,\n\t\t\t\t\tstruct per_cpu_pages *pcp)\n{\n\tint migratetype = 0;\n\tint batch_free = 0;\n\tint prefetch_nr = 0;\n\tbool isolated_pageblocks;\n\tstruct page *page, *tmp;\n\tLIST_HEAD(head);\n\n\twhile (count) {\n\t\tstruct list_head *list;\n\n\t\t/*\n\t\t * Remove pages from lists in a round-robin fashion. A\n\t\t * batch_free count is maintained that is incremented when an\n\t\t * empty list is encountered.  This is so more pages are freed\n\t\t * off fuller lists instead of spinning excessively around empty\n\t\t * lists\n\t\t */\n\t\tdo {\n\t\t\tbatch_free++;\n\t\t\tif (++migratetype == MIGRATE_PCPTYPES)\n\t\t\t\tmigratetype = 0;\n\t\t\tlist = &pcp->lists[migratetype];\n\t\t} while (list_empty(list));\n\n\t\t/* This is the only non-empty list. Free them all. */\n\t\tif (batch_free == MIGRATE_PCPTYPES)\n\t\t\tbatch_free = count;\n\n\t\tdo {\n\t\t\tpage = list_last_entry(list, struct page, lru);\n\t\t\t/* must delete to avoid corrupting pcp list */\n\t\t\tlist_del(&page->lru);\n\t\t\tpcp->count--;\n\n\t\t\tif (bulkfree_pcp_prepare(page))\n\t\t\t\tcontinue;\n\n\t\t\tlist_add_tail(&page->lru, &head);\n\n\t\t\t/*\n\t\t\t * We are going to put the page back to the global\n\t\t\t * pool, prefetch its buddy to speed up later access\n\t\t\t * under zone->lock. It is believed the overhead of\n\t\t\t * an additional test and calculating buddy_pfn here\n\t\t\t * can be offset by reduced memory latency later. To\n\t\t\t * avoid excessive prefetching due to large count, only\n\t\t\t * prefetch buddy for the first pcp->batch nr of pages.\n\t\t\t */\n\t\t\tif (prefetch_nr++ < pcp->batch)\n\t\t\t\tprefetch_buddy(page);\n\t\t} while (--count && --batch_free && !list_empty(list));\n\t}\n\n\tspin_lock(&zone->lock);\n\tisolated_pageblocks = has_isolate_pageblock(zone);\n\n\t/*\n\t * Use safe version since after __free_one_page(),\n\t * page->lru.next will not point to original list.\n\t */\n\tlist_for_each_entry_safe(page, tmp, &head, lru) {\n\t\tint mt = get_pcppage_migratetype(page);\n\t\t/* MIGRATE_ISOLATE page should not go to pcplists */\n\t\tVM_BUG_ON_PAGE(is_migrate_isolate(mt), page);\n\t\t/* Pageblock could have been isolated meanwhile */\n\t\tif (unlikely(isolated_pageblocks))\n\t\t\tmt = get_pageblock_migratetype(page);\n\n\t\t__free_one_page(page, page_to_pfn(page), zone, 0, mt);\n\t\ttrace_mm_page_pcpu_drain(page, 0, mt);\n\t}\n\tspin_unlock(&zone->lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic void free_pcppages_bulk(struct zone *zone, int count,\n\t\t\t\t\tstruct per_cpu_pages *pcp)\n{\n\tint migratetype = 0;\n\tint batch_free = 0;\n\tint prefetch_nr = 0;\n\tbool isolated_pageblocks;\n\tstruct page *page, *tmp;\n\tLIST_HEAD(head);\n\n\twhile (count) {\n\t\tstruct list_head *list;\n\n\t\t/*\n\t\t * Remove pages from lists in a round-robin fashion. A\n\t\t * batch_free count is maintained that is incremented when an\n\t\t * empty list is encountered.  This is so more pages are freed\n\t\t * off fuller lists instead of spinning excessively around empty\n\t\t * lists\n\t\t */\n\t\tdo {\n\t\t\tbatch_free++;\n\t\t\tif (++migratetype == MIGRATE_PCPTYPES)\n\t\t\t\tmigratetype = 0;\n\t\t\tlist = &pcp->lists[migratetype];\n\t\t} while (list_empty(list));\n\n\t\t/* This is the only non-empty list. Free them all. */\n\t\tif (batch_free == MIGRATE_PCPTYPES)\n\t\t\tbatch_free = count;\n\n\t\tdo {\n\t\t\tpage = list_last_entry(list, struct page, lru);\n\t\t\t/* must delete to avoid corrupting pcp list */\n\t\t\tlist_del(&page->lru);\n\t\t\tpcp->count--;\n\n\t\t\tif (bulkfree_pcp_prepare(page))\n\t\t\t\tcontinue;\n\n\t\t\tlist_add_tail(&page->lru, &head);\n\n\t\t\t/*\n\t\t\t * We are going to put the page back to the global\n\t\t\t * pool, prefetch its buddy to speed up later access\n\t\t\t * under zone->lock. It is believed the overhead of\n\t\t\t * an additional test and calculating buddy_pfn here\n\t\t\t * can be offset by reduced memory latency later. To\n\t\t\t * avoid excessive prefetching due to large count, only\n\t\t\t * prefetch buddy for the first pcp->batch nr of pages.\n\t\t\t */\n\t\t\tif (prefetch_nr++ < pcp->batch)\n\t\t\t\tprefetch_buddy(page);\n\t\t} while (--count && --batch_free && !list_empty(list));\n\t}\n\n\tspin_lock(&zone->lock);\n\tisolated_pageblocks = has_isolate_pageblock(zone);\n\n\t/*\n\t * Use safe version since after __free_one_page(),\n\t * page->lru.next will not point to original list.\n\t */\n\tlist_for_each_entry_safe(page, tmp, &head, lru) {\n\t\tint mt = get_pcppage_migratetype(page);\n\t\t/* MIGRATE_ISOLATE page should not go to pcplists */\n\t\tVM_BUG_ON_PAGE(is_migrate_isolate(mt), page);\n\t\t/* Pageblock could have been isolated meanwhile */\n\t\tif (unlikely(isolated_pageblocks))\n\t\t\tmt = get_pageblock_migratetype(page);\n\n\t\t__free_one_page(page, page_to_pfn(page), zone, 0, mt);\n\t\ttrace_mm_page_pcpu_drain(page, 0, mt);\n\t}\n\tspin_unlock(&zone->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "pcp->count",
            "batch"
          ],
          "line": 2532
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "pcp->batch"
          ],
          "line": 2531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 2530
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid drain_zone_pages(struct zone *zone, struct per_cpu_pages *pcp)\n{\n\tunsigned long flags;\n\tint to_drain, batch;\n\n\tlocal_irq_save(flags);\n\tbatch = READ_ONCE(pcp->batch);\n\tto_drain = min(pcp->count, batch);\n\tif (to_drain > 0)\n\t\tfree_pcppages_bulk(zone, to_drain, pcp);\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "rmqueue_bulk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "2473-2514",
    "snippet": "static int rmqueue_bulk(struct zone *zone, unsigned int order,\n\t\t\tunsigned long count, struct list_head *list,\n\t\t\tint migratetype)\n{\n\tint i, alloced = 0;\n\n\tspin_lock(&zone->lock);\n\tfor (i = 0; i < count; ++i) {\n\t\tstruct page *page = __rmqueue(zone, order, migratetype);\n\t\tif (unlikely(page == NULL))\n\t\t\tbreak;\n\n\t\tif (unlikely(check_pcp_refill(page)))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Split buddy pages returned by expand() are received here in\n\t\t * physical page order. The page is added to the tail of\n\t\t * caller's list. From the callers perspective, the linked list\n\t\t * is ordered by page number under some conditions. This is\n\t\t * useful for IO devices that can forward direction from the\n\t\t * head, thus also in the physical page order. This is useful\n\t\t * for IO devices that can merge IO requests if the physical\n\t\t * pages are ordered properly.\n\t\t */\n\t\tlist_add_tail(&page->lru, list);\n\t\talloced++;\n\t\tif (is_migrate_cma(get_pcppage_migratetype(page)))\n\t\t\t__mod_zone_page_state(zone, NR_FREE_CMA_PAGES,\n\t\t\t\t\t      -(1 << order));\n\t}\n\n\t/*\n\t * i pages were removed from the buddy list even if some leak due\n\t * to check_pcp_refill failing so adjust NR_FREE_PAGES based\n\t * on i. Do not confuse with 'alloced' which is the number of\n\t * pages added to the pcp list.\n\t */\n\t__mod_zone_page_state(zone, NR_FREE_PAGES, -(i << order));\n\tspin_unlock(&zone->lock);\n\treturn alloced;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);",
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&zone->lock"
          ],
          "line": 2512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mod_zone_page_state",
          "args": [
            "zone",
            "NR_FREE_PAGES",
            "-(i << order)"
          ],
          "line": 2511
        },
        "resolved": true,
        "details": {
          "function_name": "__mod_zone_page_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "315-332",
          "snippet": "void __mod_zone_page_state(struct zone *zone, enum zone_stat_item item,\n\t\t\t   long delta)\n{\n\tstruct per_cpu_pageset __percpu *pcp = zone->pageset;\n\ts8 __percpu *p = pcp->vm_stat_diff + item;\n\tlong x;\n\tlong t;\n\n\tx = delta + __this_cpu_read(*p);\n\n\tt = __this_cpu_read(pcp->stat_threshold);\n\n\tif (unlikely(x > t || x < -t)) {\n\t\tzone_page_state_add(x, zone, item);\n\t\tx = 0;\n\t}\n\t__this_cpu_write(*p, x);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid __mod_zone_page_state(struct zone *zone, enum zone_stat_item item,\n\t\t\t   long delta)\n{\n\tstruct per_cpu_pageset __percpu *pcp = zone->pageset;\n\ts8 __percpu *p = pcp->vm_stat_diff + item;\n\tlong x;\n\tlong t;\n\n\tx = delta + __this_cpu_read(*p);\n\n\tt = __this_cpu_read(pcp->stat_threshold);\n\n\tif (unlikely(x > t || x < -t)) {\n\t\tzone_page_state_add(x, zone, item);\n\t\tx = 0;\n\t}\n\t__this_cpu_write(*p, x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_migrate_cma",
          "args": [
            "get_pcppage_migratetype(page)"
          ],
          "line": 2500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_pcppage_migratetype",
          "args": [
            "page"
          ],
          "line": 2500
        },
        "resolved": true,
        "details": {
          "function_name": "get_pcppage_migratetype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "142-145",
          "snippet": "static inline int get_pcppage_migratetype(struct page *page)\n{\n\treturn page->index;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline int get_pcppage_migratetype(struct page *page)\n{\n\treturn page->index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&page->lru",
            "list"
          ],
          "line": 2498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "check_pcp_refill(page)"
          ],
          "line": 2485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_pcp_refill",
          "args": [
            "page"
          ],
          "line": 2485
        },
        "resolved": true,
        "details": {
          "function_name": "check_pcp_refill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1885-1888",
          "snippet": "static bool check_pcp_refill(struct page *page)\n{\n\treturn check_new_page(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool check_pcp_refill(struct page *page)\n{\n\treturn check_new_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "page == NULL"
          ],
          "line": 2482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__rmqueue",
          "args": [
            "zone",
            "order",
            "migratetype"
          ],
          "line": 2481
        },
        "resolved": true,
        "details": {
          "function_name": "__rmqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "2449-2466",
          "snippet": "page *\n__rmqueue(struct zone *zone, unsigned int order, int migratetype)\n{\n\tstruct page *page;\n\nretry:\n\tpage = __rmqueue_smallest(zone, order, migratetype);\n\tif (unlikely(!page)) {\n\t\tif (migratetype == MIGRATE_MOVABLE)\n\t\t\tpage = __rmqueue_cma_fallback(zone, order);\n\n\t\tif (!page && __rmqueue_fallback(zone, order, migratetype))\n\t\t\tgoto retry;\n\t}\n\n\ttrace_mm_page_alloc_zone_locked(page, order, migratetype);\n\treturn page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\npage *\n__rmqueue(struct zone *zone, unsigned int order, int migratetype)\n{\n\tstruct page *page;\n\nretry:\n\tpage = __rmqueue_smallest(zone, order, migratetype);\n\tif (unlikely(!page)) {\n\t\tif (migratetype == MIGRATE_MOVABLE)\n\t\t\tpage = __rmqueue_cma_fallback(zone, order);\n\n\t\tif (!page && __rmqueue_fallback(zone, order, migratetype))\n\t\t\tgoto retry;\n\t}\n\n\ttrace_mm_page_alloc_zone_locked(page, order, migratetype);\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&zone->lock"
          ],
          "line": 2479
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic int rmqueue_bulk(struct zone *zone, unsigned int order,\n\t\t\tunsigned long count, struct list_head *list,\n\t\t\tint migratetype)\n{\n\tint i, alloced = 0;\n\n\tspin_lock(&zone->lock);\n\tfor (i = 0; i < count; ++i) {\n\t\tstruct page *page = __rmqueue(zone, order, migratetype);\n\t\tif (unlikely(page == NULL))\n\t\t\tbreak;\n\n\t\tif (unlikely(check_pcp_refill(page)))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Split buddy pages returned by expand() are received here in\n\t\t * physical page order. The page is added to the tail of\n\t\t * caller's list. From the callers perspective, the linked list\n\t\t * is ordered by page number under some conditions. This is\n\t\t * useful for IO devices that can forward direction from the\n\t\t * head, thus also in the physical page order. This is useful\n\t\t * for IO devices that can merge IO requests if the physical\n\t\t * pages are ordered properly.\n\t\t */\n\t\tlist_add_tail(&page->lru, list);\n\t\talloced++;\n\t\tif (is_migrate_cma(get_pcppage_migratetype(page)))\n\t\t\t__mod_zone_page_state(zone, NR_FREE_CMA_PAGES,\n\t\t\t\t\t      -(1 << order));\n\t}\n\n\t/*\n\t * i pages were removed from the buddy list even if some leak due\n\t * to check_pcp_refill failing so adjust NR_FREE_PAGES based\n\t * on i. Do not confuse with 'alloced' which is the number of\n\t * pages added to the pcp list.\n\t */\n\t__mod_zone_page_state(zone, NR_FREE_PAGES, -(i << order));\n\tspin_unlock(&zone->lock);\n\treturn alloced;\n}"
  },
  {
    "function_name": "__rmqueue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "2449-2466",
    "snippet": "page *\n__rmqueue(struct zone *zone, unsigned int order, int migratetype)\n{\n\tstruct page *page;\n\nretry:\n\tpage = __rmqueue_smallest(zone, order, migratetype);\n\tif (unlikely(!page)) {\n\t\tif (migratetype == MIGRATE_MOVABLE)\n\t\t\tpage = __rmqueue_cma_fallback(zone, order);\n\n\t\tif (!page && __rmqueue_fallback(zone, order, migratetype))\n\t\t\tgoto retry;\n\t}\n\n\ttrace_mm_page_alloc_zone_locked(page, order, migratetype);\n\treturn page;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);",
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_mm_page_alloc_zone_locked",
          "args": [
            "page",
            "order",
            "migratetype"
          ],
          "line": 2464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__rmqueue_fallback",
          "args": [
            "zone",
            "order",
            "migratetype"
          ],
          "line": 2460
        },
        "resolved": true,
        "details": {
          "function_name": "__rmqueue_fallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "2377-2443",
          "snippet": "static __always_inline bool\n__rmqueue_fallback(struct zone *zone, int order, int start_migratetype)\n{\n\tstruct free_area *area;\n\tint current_order;\n\tstruct page *page;\n\tint fallback_mt;\n\tbool can_steal;\n\n\t/*\n\t * Find the largest available free page in the other list. This roughly\n\t * approximates finding the pageblock with the most free pages, which\n\t * would be too costly to do exactly.\n\t */\n\tfor (current_order = MAX_ORDER - 1; current_order >= order;\n\t\t\t\t--current_order) {\n\t\tarea = &(zone->free_area[current_order]);\n\t\tfallback_mt = find_suitable_fallback(area, current_order,\n\t\t\t\tstart_migratetype, false, &can_steal);\n\t\tif (fallback_mt == -1)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We cannot steal all free pages from the pageblock and the\n\t\t * requested migratetype is movable. In that case it's better to\n\t\t * steal and split the smallest available page instead of the\n\t\t * largest available page, because even if the next movable\n\t\t * allocation falls back into a different pageblock than this\n\t\t * one, it won't cause permanent fragmentation.\n\t\t */\n\t\tif (!can_steal && start_migratetype == MIGRATE_MOVABLE\n\t\t\t\t\t&& current_order > order)\n\t\t\tgoto find_smallest;\n\n\t\tgoto do_steal;\n\t}\n\n\treturn false;\n\nfind_smallest:\n\tfor (current_order = order; current_order < MAX_ORDER;\n\t\t\t\t\t\t\tcurrent_order++) {\n\t\tarea = &(zone->free_area[current_order]);\n\t\tfallback_mt = find_suitable_fallback(area, current_order,\n\t\t\t\tstart_migratetype, false, &can_steal);\n\t\tif (fallback_mt != -1)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * This should not happen - we already found a suitable fallback\n\t * when looking for the largest page.\n\t */\n\tVM_BUG_ON(current_order == MAX_ORDER);\n\ndo_steal:\n\tpage = list_first_entry(&area->free_list[fallback_mt],\n\t\t\t\t\t\t\tstruct page, lru);\n\n\tsteal_suitable_fallback(zone, page, start_migratetype, can_steal);\n\n\ttrace_mm_page_alloc_extfrag(page, order, current_order,\n\t\tstart_migratetype, fallback_mt);\n\n\treturn true;\n\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic __always_inline bool\n__rmqueue_fallback(struct zone *zone, int order, int start_migratetype)\n{\n\tstruct free_area *area;\n\tint current_order;\n\tstruct page *page;\n\tint fallback_mt;\n\tbool can_steal;\n\n\t/*\n\t * Find the largest available free page in the other list. This roughly\n\t * approximates finding the pageblock with the most free pages, which\n\t * would be too costly to do exactly.\n\t */\n\tfor (current_order = MAX_ORDER - 1; current_order >= order;\n\t\t\t\t--current_order) {\n\t\tarea = &(zone->free_area[current_order]);\n\t\tfallback_mt = find_suitable_fallback(area, current_order,\n\t\t\t\tstart_migratetype, false, &can_steal);\n\t\tif (fallback_mt == -1)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We cannot steal all free pages from the pageblock and the\n\t\t * requested migratetype is movable. In that case it's better to\n\t\t * steal and split the smallest available page instead of the\n\t\t * largest available page, because even if the next movable\n\t\t * allocation falls back into a different pageblock than this\n\t\t * one, it won't cause permanent fragmentation.\n\t\t */\n\t\tif (!can_steal && start_migratetype == MIGRATE_MOVABLE\n\t\t\t\t\t&& current_order > order)\n\t\t\tgoto find_smallest;\n\n\t\tgoto do_steal;\n\t}\n\n\treturn false;\n\nfind_smallest:\n\tfor (current_order = order; current_order < MAX_ORDER;\n\t\t\t\t\t\t\tcurrent_order++) {\n\t\tarea = &(zone->free_area[current_order]);\n\t\tfallback_mt = find_suitable_fallback(area, current_order,\n\t\t\t\tstart_migratetype, false, &can_steal);\n\t\tif (fallback_mt != -1)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * This should not happen - we already found a suitable fallback\n\t * when looking for the largest page.\n\t */\n\tVM_BUG_ON(current_order == MAX_ORDER);\n\ndo_steal:\n\tpage = list_first_entry(&area->free_list[fallback_mt],\n\t\t\t\t\t\t\tstruct page, lru);\n\n\tsteal_suitable_fallback(zone, page, start_migratetype, can_steal);\n\n\ttrace_mm_page_alloc_extfrag(page, order, current_order,\n\t\tstart_migratetype, fallback_mt);\n\n\treturn true;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "__rmqueue_cma_fallback",
          "args": [
            "zone",
            "order"
          ],
          "line": 2458
        },
        "resolved": true,
        "details": {
          "function_name": "__rmqueue_cma_fallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "2001-2002",
          "snippet": "static inline struct page *__rmqueue_cma_fallback(struct zone *zone,\n\t\t\t\t\tunsigned int order) { return NULL; }",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline struct page *__rmqueue_cma_fallback(struct zone *zone,\n\t\t\t\t\tunsigned int order) { return NULL; }"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!page"
          ],
          "line": 2456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__rmqueue_smallest",
          "args": [
            "zone",
            "order",
            "migratetype"
          ],
          "line": 2455
        },
        "resolved": true,
        "details": {
          "function_name": "__rmqueue_smallest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1952-1975",
          "snippet": "page *__rmqueue_smallest(struct zone *zone, unsigned int order,\n\t\t\t\t\t\tint migratetype)\n{\n\tunsigned int current_order;\n\tstruct free_area *area;\n\tstruct page *page;\n\n\t/* Find a page of the appropriate size in the preferred list */\n\tfor (current_order = order; current_order < MAX_ORDER; ++current_order) {\n\t\tarea = &(zone->free_area[current_order]);\n\t\tpage = list_first_entry_or_null(&area->free_list[migratetype],\n\t\t\t\t\t\t\tstruct page, lru);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tlist_del(&page->lru);\n\t\trmv_page_order(page);\n\t\tarea->nr_free--;\n\t\texpand(zone, page, order, current_order, area, migratetype);\n\t\tset_pcppage_migratetype(page, migratetype);\n\t\treturn page;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\npage *__rmqueue_smallest(struct zone *zone, unsigned int order,\n\t\t\t\t\t\tint migratetype)\n{\n\tunsigned int current_order;\n\tstruct free_area *area;\n\tstruct page *page;\n\n\t/* Find a page of the appropriate size in the preferred list */\n\tfor (current_order = order; current_order < MAX_ORDER; ++current_order) {\n\t\tarea = &(zone->free_area[current_order]);\n\t\tpage = list_first_entry_or_null(&area->free_list[migratetype],\n\t\t\t\t\t\t\tstruct page, lru);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tlist_del(&page->lru);\n\t\trmv_page_order(page);\n\t\tarea->nr_free--;\n\t\texpand(zone, page, order, current_order, area, migratetype);\n\t\tset_pcppage_migratetype(page, migratetype);\n\t\treturn page;\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\npage *\n__rmqueue(struct zone *zone, unsigned int order, int migratetype)\n{\n\tstruct page *page;\n\nretry:\n\tpage = __rmqueue_smallest(zone, order, migratetype);\n\tif (unlikely(!page)) {\n\t\tif (migratetype == MIGRATE_MOVABLE)\n\t\t\tpage = __rmqueue_cma_fallback(zone, order);\n\n\t\tif (!page && __rmqueue_fallback(zone, order, migratetype))\n\t\t\tgoto retry;\n\t}\n\n\ttrace_mm_page_alloc_zone_locked(page, order, migratetype);\n\treturn page;\n}"
  },
  {
    "function_name": "__rmqueue_fallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "2377-2443",
    "snippet": "static __always_inline bool\n__rmqueue_fallback(struct zone *zone, int order, int start_migratetype)\n{\n\tstruct free_area *area;\n\tint current_order;\n\tstruct page *page;\n\tint fallback_mt;\n\tbool can_steal;\n\n\t/*\n\t * Find the largest available free page in the other list. This roughly\n\t * approximates finding the pageblock with the most free pages, which\n\t * would be too costly to do exactly.\n\t */\n\tfor (current_order = MAX_ORDER - 1; current_order >= order;\n\t\t\t\t--current_order) {\n\t\tarea = &(zone->free_area[current_order]);\n\t\tfallback_mt = find_suitable_fallback(area, current_order,\n\t\t\t\tstart_migratetype, false, &can_steal);\n\t\tif (fallback_mt == -1)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We cannot steal all free pages from the pageblock and the\n\t\t * requested migratetype is movable. In that case it's better to\n\t\t * steal and split the smallest available page instead of the\n\t\t * largest available page, because even if the next movable\n\t\t * allocation falls back into a different pageblock than this\n\t\t * one, it won't cause permanent fragmentation.\n\t\t */\n\t\tif (!can_steal && start_migratetype == MIGRATE_MOVABLE\n\t\t\t\t\t&& current_order > order)\n\t\t\tgoto find_smallest;\n\n\t\tgoto do_steal;\n\t}\n\n\treturn false;\n\nfind_smallest:\n\tfor (current_order = order; current_order < MAX_ORDER;\n\t\t\t\t\t\t\tcurrent_order++) {\n\t\tarea = &(zone->free_area[current_order]);\n\t\tfallback_mt = find_suitable_fallback(area, current_order,\n\t\t\t\tstart_migratetype, false, &can_steal);\n\t\tif (fallback_mt != -1)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * This should not happen - we already found a suitable fallback\n\t * when looking for the largest page.\n\t */\n\tVM_BUG_ON(current_order == MAX_ORDER);\n\ndo_steal:\n\tpage = list_first_entry(&area->free_list[fallback_mt],\n\t\t\t\t\t\t\tstruct page, lru);\n\n\tsteal_suitable_fallback(zone, page, start_migratetype, can_steal);\n\n\ttrace_mm_page_alloc_extfrag(page, order, current_order,\n\t\tstart_migratetype, fallback_mt);\n\n\treturn true;\n\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);",
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_mm_page_alloc_extfrag",
          "args": [
            "page",
            "order",
            "current_order",
            "start_migratetype",
            "fallback_mt"
          ],
          "line": 2438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "steal_suitable_fallback",
          "args": [
            "zone",
            "page",
            "start_migratetype",
            "can_steal"
          ],
          "line": 2436
        },
        "resolved": true,
        "details": {
          "function_name": "steal_suitable_fallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "2140-2208",
          "snippet": "static void steal_suitable_fallback(struct zone *zone, struct page *page,\n\t\t\t\t\tint start_type, bool whole_block)\n{\n\tunsigned int current_order = page_order(page);\n\tstruct free_area *area;\n\tint free_pages, movable_pages, alike_pages;\n\tint old_block_type;\n\n\told_block_type = get_pageblock_migratetype(page);\n\n\t/*\n\t * This can happen due to races and we want to prevent broken\n\t * highatomic accounting.\n\t */\n\tif (is_migrate_highatomic(old_block_type))\n\t\tgoto single_page;\n\n\t/* Take ownership for orders >= pageblock_order */\n\tif (current_order >= pageblock_order) {\n\t\tchange_pageblock_range(page, current_order, start_type);\n\t\tgoto single_page;\n\t}\n\n\t/* We are not allowed to try stealing from the whole block */\n\tif (!whole_block)\n\t\tgoto single_page;\n\n\tfree_pages = move_freepages_block(zone, page, start_type,\n\t\t\t\t\t\t&movable_pages);\n\t/*\n\t * Determine how many pages are compatible with our allocation.\n\t * For movable allocation, it's the number of movable pages which\n\t * we just obtained. For other types it's a bit more tricky.\n\t */\n\tif (start_type == MIGRATE_MOVABLE) {\n\t\talike_pages = movable_pages;\n\t} else {\n\t\t/*\n\t\t * If we are falling back a RECLAIMABLE or UNMOVABLE allocation\n\t\t * to MOVABLE pageblock, consider all non-movable pages as\n\t\t * compatible. If it's UNMOVABLE falling back to RECLAIMABLE or\n\t\t * vice versa, be conservative since we can't distinguish the\n\t\t * exact migratetype of non-movable pages.\n\t\t */\n\t\tif (old_block_type == MIGRATE_MOVABLE)\n\t\t\talike_pages = pageblock_nr_pages\n\t\t\t\t\t\t- (free_pages + movable_pages);\n\t\telse\n\t\t\talike_pages = 0;\n\t}\n\n\t/* moving whole block can fail due to zone boundary conditions */\n\tif (!free_pages)\n\t\tgoto single_page;\n\n\t/*\n\t * If a sufficient number of pages in the block are either free or of\n\t * comparable migratability as our allocation, claim the whole block.\n\t */\n\tif (free_pages + alike_pages >= (1 << (pageblock_order-1)) ||\n\t\t\tpage_group_by_mobility_disabled)\n\t\tset_pageblock_migratetype(page, start_type);\n\n\treturn;\n\nsingle_page:\n\tarea = &zone->free_area[current_order];\n\tlist_move(&page->lru, &area->free_list[start_type]);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int page_group_by_mobility_disabled",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nint page_group_by_mobility_disabled;\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic void steal_suitable_fallback(struct zone *zone, struct page *page,\n\t\t\t\t\tint start_type, bool whole_block)\n{\n\tunsigned int current_order = page_order(page);\n\tstruct free_area *area;\n\tint free_pages, movable_pages, alike_pages;\n\tint old_block_type;\n\n\told_block_type = get_pageblock_migratetype(page);\n\n\t/*\n\t * This can happen due to races and we want to prevent broken\n\t * highatomic accounting.\n\t */\n\tif (is_migrate_highatomic(old_block_type))\n\t\tgoto single_page;\n\n\t/* Take ownership for orders >= pageblock_order */\n\tif (current_order >= pageblock_order) {\n\t\tchange_pageblock_range(page, current_order, start_type);\n\t\tgoto single_page;\n\t}\n\n\t/* We are not allowed to try stealing from the whole block */\n\tif (!whole_block)\n\t\tgoto single_page;\n\n\tfree_pages = move_freepages_block(zone, page, start_type,\n\t\t\t\t\t\t&movable_pages);\n\t/*\n\t * Determine how many pages are compatible with our allocation.\n\t * For movable allocation, it's the number of movable pages which\n\t * we just obtained. For other types it's a bit more tricky.\n\t */\n\tif (start_type == MIGRATE_MOVABLE) {\n\t\talike_pages = movable_pages;\n\t} else {\n\t\t/*\n\t\t * If we are falling back a RECLAIMABLE or UNMOVABLE allocation\n\t\t * to MOVABLE pageblock, consider all non-movable pages as\n\t\t * compatible. If it's UNMOVABLE falling back to RECLAIMABLE or\n\t\t * vice versa, be conservative since we can't distinguish the\n\t\t * exact migratetype of non-movable pages.\n\t\t */\n\t\tif (old_block_type == MIGRATE_MOVABLE)\n\t\t\talike_pages = pageblock_nr_pages\n\t\t\t\t\t\t- (free_pages + movable_pages);\n\t\telse\n\t\t\talike_pages = 0;\n\t}\n\n\t/* moving whole block can fail due to zone boundary conditions */\n\tif (!free_pages)\n\t\tgoto single_page;\n\n\t/*\n\t * If a sufficient number of pages in the block are either free or of\n\t * comparable migratability as our allocation, claim the whole block.\n\t */\n\tif (free_pages + alike_pages >= (1 << (pageblock_order-1)) ||\n\t\t\tpage_group_by_mobility_disabled)\n\t\tset_pageblock_migratetype(page, start_type);\n\n\treturn;\n\nsingle_page:\n\tarea = &zone->free_area[current_order];\n\tlist_move(&page->lru, &area->free_list[start_type]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&area->free_list[fallback_mt]",
            "structpage",
            "lru"
          ],
          "line": 2433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "current_order == MAX_ORDER"
          ],
          "line": 2430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_suitable_fallback",
          "args": [
            "area",
            "current_order",
            "start_migratetype",
            "false",
            "&can_steal"
          ],
          "line": 2420
        },
        "resolved": true,
        "details": {
          "function_name": "find_suitable_fallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "2216-2245",
          "snippet": "int find_suitable_fallback(struct free_area *area, unsigned int order,\n\t\t\tint migratetype, bool only_stealable, bool *can_steal)\n{\n\tint i;\n\tint fallback_mt;\n\n\tif (area->nr_free == 0)\n\t\treturn -1;\n\n\t*can_steal = false;\n\tfor (i = 0;; i++) {\n\t\tfallback_mt = fallbacks[migratetype][i];\n\t\tif (fallback_mt == MIGRATE_TYPES)\n\t\t\tbreak;\n\n\t\tif (list_empty(&area->free_list[fallback_mt]))\n\t\t\tcontinue;\n\n\t\tif (can_steal_fallback(order, migratetype))\n\t\t\t*can_steal = true;\n\n\t\tif (!only_stealable)\n\t\t\treturn fallback_mt;\n\n\t\tif (*can_steal)\n\t\t\treturn fallback_mt;\n\t}\n\n\treturn -1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static int fallbacks[MIGRATE_TYPES][4] = {\n\t[MIGRATE_UNMOVABLE]   = { MIGRATE_RECLAIMABLE, MIGRATE_MOVABLE,   MIGRATE_TYPES },\n\t[MIGRATE_RECLAIMABLE] = { MIGRATE_UNMOVABLE,   MIGRATE_MOVABLE,   MIGRATE_TYPES },\n\t[MIGRATE_MOVABLE]     = { MIGRATE_RECLAIMABLE, MIGRATE_UNMOVABLE, MIGRATE_TYPES },\n#ifdef CONFIG_CMA\n\t[MIGRATE_CMA]         = { MIGRATE_TYPES }, /* Never used */\n#endif\n#ifdef CONFIG_MEMORY_ISOLATION\n\t[MIGRATE_ISOLATE]     = { MIGRATE_TYPES }, /* Never used */\n#endif\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic int fallbacks[MIGRATE_TYPES][4] = {\n\t[MIGRATE_UNMOVABLE]   = { MIGRATE_RECLAIMABLE, MIGRATE_MOVABLE,   MIGRATE_TYPES },\n\t[MIGRATE_RECLAIMABLE] = { MIGRATE_UNMOVABLE,   MIGRATE_MOVABLE,   MIGRATE_TYPES },\n\t[MIGRATE_MOVABLE]     = { MIGRATE_RECLAIMABLE, MIGRATE_UNMOVABLE, MIGRATE_TYPES },\n#ifdef CONFIG_CMA\n\t[MIGRATE_CMA]         = { MIGRATE_TYPES }, /* Never used */\n#endif\n#ifdef CONFIG_MEMORY_ISOLATION\n\t[MIGRATE_ISOLATE]     = { MIGRATE_TYPES }, /* Never used */\n#endif\n};\nstatic __always_inline struct;\n\nint find_suitable_fallback(struct free_area *area, unsigned int order,\n\t\t\tint migratetype, bool only_stealable, bool *can_steal)\n{\n\tint i;\n\tint fallback_mt;\n\n\tif (area->nr_free == 0)\n\t\treturn -1;\n\n\t*can_steal = false;\n\tfor (i = 0;; i++) {\n\t\tfallback_mt = fallbacks[migratetype][i];\n\t\tif (fallback_mt == MIGRATE_TYPES)\n\t\t\tbreak;\n\n\t\tif (list_empty(&area->free_list[fallback_mt]))\n\t\t\tcontinue;\n\n\t\tif (can_steal_fallback(order, migratetype))\n\t\t\t*can_steal = true;\n\n\t\tif (!only_stealable)\n\t\t\treturn fallback_mt;\n\n\t\tif (*can_steal)\n\t\t\treturn fallback_mt;\n\t}\n\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic __always_inline bool\n__rmqueue_fallback(struct zone *zone, int order, int start_migratetype)\n{\n\tstruct free_area *area;\n\tint current_order;\n\tstruct page *page;\n\tint fallback_mt;\n\tbool can_steal;\n\n\t/*\n\t * Find the largest available free page in the other list. This roughly\n\t * approximates finding the pageblock with the most free pages, which\n\t * would be too costly to do exactly.\n\t */\n\tfor (current_order = MAX_ORDER - 1; current_order >= order;\n\t\t\t\t--current_order) {\n\t\tarea = &(zone->free_area[current_order]);\n\t\tfallback_mt = find_suitable_fallback(area, current_order,\n\t\t\t\tstart_migratetype, false, &can_steal);\n\t\tif (fallback_mt == -1)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We cannot steal all free pages from the pageblock and the\n\t\t * requested migratetype is movable. In that case it's better to\n\t\t * steal and split the smallest available page instead of the\n\t\t * largest available page, because even if the next movable\n\t\t * allocation falls back into a different pageblock than this\n\t\t * one, it won't cause permanent fragmentation.\n\t\t */\n\t\tif (!can_steal && start_migratetype == MIGRATE_MOVABLE\n\t\t\t\t\t&& current_order > order)\n\t\t\tgoto find_smallest;\n\n\t\tgoto do_steal;\n\t}\n\n\treturn false;\n\nfind_smallest:\n\tfor (current_order = order; current_order < MAX_ORDER;\n\t\t\t\t\t\t\tcurrent_order++) {\n\t\tarea = &(zone->free_area[current_order]);\n\t\tfallback_mt = find_suitable_fallback(area, current_order,\n\t\t\t\tstart_migratetype, false, &can_steal);\n\t\tif (fallback_mt != -1)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * This should not happen - we already found a suitable fallback\n\t * when looking for the largest page.\n\t */\n\tVM_BUG_ON(current_order == MAX_ORDER);\n\ndo_steal:\n\tpage = list_first_entry(&area->free_list[fallback_mt],\n\t\t\t\t\t\t\tstruct page, lru);\n\n\tsteal_suitable_fallback(zone, page, start_migratetype, can_steal);\n\n\ttrace_mm_page_alloc_extfrag(page, order, current_order,\n\t\tstart_migratetype, fallback_mt);\n\n\treturn true;\n\n}"
  },
  {
    "function_name": "unreserve_highatomic_pageblock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "2293-2365",
    "snippet": "static bool unreserve_highatomic_pageblock(const struct alloc_context *ac,\n\t\t\t\t\t\tbool force)\n{\n\tstruct zonelist *zonelist = ac->zonelist;\n\tunsigned long flags;\n\tstruct zoneref *z;\n\tstruct zone *zone;\n\tstruct page *page;\n\tint order;\n\tbool ret;\n\n\tfor_each_zone_zonelist_nodemask(zone, z, zonelist, ac->high_zoneidx,\n\t\t\t\t\t\t\t\tac->nodemask) {\n\t\t/*\n\t\t * Preserve at least one pageblock unless memory pressure\n\t\t * is really high.\n\t\t */\n\t\tif (!force && zone->nr_reserved_highatomic <=\n\t\t\t\t\tpageblock_nr_pages)\n\t\t\tcontinue;\n\n\t\tspin_lock_irqsave(&zone->lock, flags);\n\t\tfor (order = 0; order < MAX_ORDER; order++) {\n\t\t\tstruct free_area *area = &(zone->free_area[order]);\n\n\t\t\tpage = list_first_entry_or_null(\n\t\t\t\t\t&area->free_list[MIGRATE_HIGHATOMIC],\n\t\t\t\t\tstruct page, lru);\n\t\t\tif (!page)\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * In page freeing path, migratetype change is racy so\n\t\t\t * we can counter several free pages in a pageblock\n\t\t\t * in this loop althoug we changed the pageblock type\n\t\t\t * from highatomic to ac->migratetype. So we should\n\t\t\t * adjust the count once.\n\t\t\t */\n\t\t\tif (is_migrate_highatomic_page(page)) {\n\t\t\t\t/*\n\t\t\t\t * It should never happen but changes to\n\t\t\t\t * locking could inadvertently allow a per-cpu\n\t\t\t\t * drain to add pages to MIGRATE_HIGHATOMIC\n\t\t\t\t * while unreserving so be safe and watch for\n\t\t\t\t * underflows.\n\t\t\t\t */\n\t\t\t\tzone->nr_reserved_highatomic -= min(\n\t\t\t\t\t\tpageblock_nr_pages,\n\t\t\t\t\t\tzone->nr_reserved_highatomic);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Convert to ac->migratetype and avoid the normal\n\t\t\t * pageblock stealing heuristics. Minimally, the caller\n\t\t\t * is doing the work and needs the pages. More\n\t\t\t * importantly, if the block was always converted to\n\t\t\t * MIGRATE_UNMOVABLE or another type then the number\n\t\t\t * of pageblocks that cannot be completely freed\n\t\t\t * may increase.\n\t\t\t */\n\t\t\tset_pageblock_migratetype(page, ac->migratetype);\n\t\t\tret = move_freepages_block(zone, page, ac->migratetype,\n\t\t\t\t\t\t\t\t\tNULL);\n\t\t\tif (ret) {\n\t\t\t\tspin_unlock_irqrestore(&zone->lock, flags);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&zone->lock, flags);\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);",
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&zone->lock",
            "flags"
          ],
          "line": 2361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&zone->lock",
            "flags"
          ],
          "line": 2357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "move_freepages_block",
          "args": [
            "zone",
            "page",
            "ac->migratetype",
            "NULL"
          ],
          "line": 2354
        },
        "resolved": true,
        "details": {
          "function_name": "move_freepages_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "2063-2086",
          "snippet": "int move_freepages_block(struct zone *zone, struct page *page,\n\t\t\t\tint migratetype, int *num_movable)\n{\n\tunsigned long start_pfn, end_pfn;\n\tstruct page *start_page, *end_page;\n\n\tif (num_movable)\n\t\t*num_movable = 0;\n\n\tstart_pfn = page_to_pfn(page);\n\tstart_pfn = start_pfn & ~(pageblock_nr_pages-1);\n\tstart_page = pfn_to_page(start_pfn);\n\tend_page = start_page + pageblock_nr_pages - 1;\n\tend_pfn = start_pfn + pageblock_nr_pages - 1;\n\n\t/* Do not cross zone boundaries */\n\tif (!zone_spans_pfn(zone, start_pfn))\n\t\tstart_page = page;\n\tif (!zone_spans_pfn(zone, end_pfn))\n\t\treturn 0;\n\n\treturn move_freepages(zone, start_page, end_page, migratetype,\n\t\t\t\t\t\t\t\tnum_movable);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nint move_freepages_block(struct zone *zone, struct page *page,\n\t\t\t\tint migratetype, int *num_movable)\n{\n\tunsigned long start_pfn, end_pfn;\n\tstruct page *start_page, *end_page;\n\n\tif (num_movable)\n\t\t*num_movable = 0;\n\n\tstart_pfn = page_to_pfn(page);\n\tstart_pfn = start_pfn & ~(pageblock_nr_pages-1);\n\tstart_page = pfn_to_page(start_pfn);\n\tend_page = start_page + pageblock_nr_pages - 1;\n\tend_pfn = start_pfn + pageblock_nr_pages - 1;\n\n\t/* Do not cross zone boundaries */\n\tif (!zone_spans_pfn(zone, start_pfn))\n\t\tstart_page = page;\n\tif (!zone_spans_pfn(zone, end_pfn))\n\t\treturn 0;\n\n\treturn move_freepages(zone, start_page, end_page, migratetype,\n\t\t\t\t\t\t\t\tnum_movable);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_pageblock_migratetype",
          "args": [
            "page",
            "ac->migratetype"
          ],
          "line": 2353
        },
        "resolved": true,
        "details": {
          "function_name": "set_pageblock_migratetype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "450-458",
          "snippet": "void set_pageblock_migratetype(struct page *page, int migratetype)\n{\n\tif (unlikely(page_group_by_mobility_disabled &&\n\t\t     migratetype < MIGRATE_PCPTYPES))\n\t\tmigratetype = MIGRATE_UNMOVABLE;\n\n\tset_pageblock_flags_group(page, (unsigned long)migratetype,\n\t\t\t\t\tPB_migrate, PB_migrate_end);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int page_group_by_mobility_disabled",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nint page_group_by_mobility_disabled;\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid set_pageblock_migratetype(struct page *page, int migratetype)\n{\n\tif (unlikely(page_group_by_mobility_disabled &&\n\t\t     migratetype < MIGRATE_PCPTYPES))\n\t\tmigratetype = MIGRATE_UNMOVABLE;\n\n\tset_pageblock_flags_group(page, (unsigned long)migratetype,\n\t\t\t\t\tPB_migrate, PB_migrate_end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "pageblock_nr_pages",
            "zone->nr_reserved_highatomic"
          ],
          "line": 2339
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_migrate_highatomic_page",
          "args": [
            "page"
          ],
          "line": 2331
        },
        "resolved": true,
        "details": {
          "function_name": "is_migrate_highatomic_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "523-526",
          "snippet": "static inline bool is_migrate_highatomic_page(struct page *page)\n{\n\treturn get_pageblock_migratetype(page) == MIGRATE_HIGHATOMIC;\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline bool is_migrate_highatomic_page(struct page *page)\n{\n\treturn get_pageblock_migratetype(page) == MIGRATE_HIGHATOMIC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry_or_null",
          "args": [
            "&area->free_list[MIGRATE_HIGHATOMIC]",
            "structpage",
            "lru"
          ],
          "line": 2318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&zone->lock",
            "flags"
          ],
          "line": 2314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_zone_zonelist_nodemask",
          "args": [
            "zone",
            "z",
            "zonelist",
            "ac->high_zoneidx",
            "ac->nodemask"
          ],
          "line": 2304
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool unreserve_highatomic_pageblock(const struct alloc_context *ac,\n\t\t\t\t\t\tbool force)\n{\n\tstruct zonelist *zonelist = ac->zonelist;\n\tunsigned long flags;\n\tstruct zoneref *z;\n\tstruct zone *zone;\n\tstruct page *page;\n\tint order;\n\tbool ret;\n\n\tfor_each_zone_zonelist_nodemask(zone, z, zonelist, ac->high_zoneidx,\n\t\t\t\t\t\t\t\tac->nodemask) {\n\t\t/*\n\t\t * Preserve at least one pageblock unless memory pressure\n\t\t * is really high.\n\t\t */\n\t\tif (!force && zone->nr_reserved_highatomic <=\n\t\t\t\t\tpageblock_nr_pages)\n\t\t\tcontinue;\n\n\t\tspin_lock_irqsave(&zone->lock, flags);\n\t\tfor (order = 0; order < MAX_ORDER; order++) {\n\t\t\tstruct free_area *area = &(zone->free_area[order]);\n\n\t\t\tpage = list_first_entry_or_null(\n\t\t\t\t\t&area->free_list[MIGRATE_HIGHATOMIC],\n\t\t\t\t\tstruct page, lru);\n\t\t\tif (!page)\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * In page freeing path, migratetype change is racy so\n\t\t\t * we can counter several free pages in a pageblock\n\t\t\t * in this loop althoug we changed the pageblock type\n\t\t\t * from highatomic to ac->migratetype. So we should\n\t\t\t * adjust the count once.\n\t\t\t */\n\t\t\tif (is_migrate_highatomic_page(page)) {\n\t\t\t\t/*\n\t\t\t\t * It should never happen but changes to\n\t\t\t\t * locking could inadvertently allow a per-cpu\n\t\t\t\t * drain to add pages to MIGRATE_HIGHATOMIC\n\t\t\t\t * while unreserving so be safe and watch for\n\t\t\t\t * underflows.\n\t\t\t\t */\n\t\t\t\tzone->nr_reserved_highatomic -= min(\n\t\t\t\t\t\tpageblock_nr_pages,\n\t\t\t\t\t\tzone->nr_reserved_highatomic);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Convert to ac->migratetype and avoid the normal\n\t\t\t * pageblock stealing heuristics. Minimally, the caller\n\t\t\t * is doing the work and needs the pages. More\n\t\t\t * importantly, if the block was always converted to\n\t\t\t * MIGRATE_UNMOVABLE or another type then the number\n\t\t\t * of pageblocks that cannot be completely freed\n\t\t\t * may increase.\n\t\t\t */\n\t\t\tset_pageblock_migratetype(page, ac->migratetype);\n\t\t\tret = move_freepages_block(zone, page, ac->migratetype,\n\t\t\t\t\t\t\t\t\tNULL);\n\t\t\tif (ret) {\n\t\t\t\tspin_unlock_irqrestore(&zone->lock, flags);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&zone->lock, flags);\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "reserve_highatomic_pageblock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "2251-2282",
    "snippet": "static void reserve_highatomic_pageblock(struct page *page, struct zone *zone,\n\t\t\t\tunsigned int alloc_order)\n{\n\tint mt;\n\tunsigned long max_managed, flags;\n\n\t/*\n\t * Limit the number reserved to 1 pageblock or roughly 1% of a zone.\n\t * Check is race-prone but harmless.\n\t */\n\tmax_managed = (zone->managed_pages / 100) + pageblock_nr_pages;\n\tif (zone->nr_reserved_highatomic >= max_managed)\n\t\treturn;\n\n\tspin_lock_irqsave(&zone->lock, flags);\n\n\t/* Recheck the nr_reserved_highatomic limit under the lock */\n\tif (zone->nr_reserved_highatomic >= max_managed)\n\t\tgoto out_unlock;\n\n\t/* Yoink! */\n\tmt = get_pageblock_migratetype(page);\n\tif (!is_migrate_highatomic(mt) && !is_migrate_isolate(mt)\n\t    && !is_migrate_cma(mt)) {\n\t\tzone->nr_reserved_highatomic += pageblock_nr_pages;\n\t\tset_pageblock_migratetype(page, MIGRATE_HIGHATOMIC);\n\t\tmove_freepages_block(zone, page, MIGRATE_HIGHATOMIC, NULL);\n\t}\n\nout_unlock:\n\tspin_unlock_irqrestore(&zone->lock, flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&zone->lock",
            "flags"
          ],
          "line": 2281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "move_freepages_block",
          "args": [
            "zone",
            "page",
            "MIGRATE_HIGHATOMIC",
            "NULL"
          ],
          "line": 2277
        },
        "resolved": true,
        "details": {
          "function_name": "move_freepages_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "2063-2086",
          "snippet": "int move_freepages_block(struct zone *zone, struct page *page,\n\t\t\t\tint migratetype, int *num_movable)\n{\n\tunsigned long start_pfn, end_pfn;\n\tstruct page *start_page, *end_page;\n\n\tif (num_movable)\n\t\t*num_movable = 0;\n\n\tstart_pfn = page_to_pfn(page);\n\tstart_pfn = start_pfn & ~(pageblock_nr_pages-1);\n\tstart_page = pfn_to_page(start_pfn);\n\tend_page = start_page + pageblock_nr_pages - 1;\n\tend_pfn = start_pfn + pageblock_nr_pages - 1;\n\n\t/* Do not cross zone boundaries */\n\tif (!zone_spans_pfn(zone, start_pfn))\n\t\tstart_page = page;\n\tif (!zone_spans_pfn(zone, end_pfn))\n\t\treturn 0;\n\n\treturn move_freepages(zone, start_page, end_page, migratetype,\n\t\t\t\t\t\t\t\tnum_movable);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nint move_freepages_block(struct zone *zone, struct page *page,\n\t\t\t\tint migratetype, int *num_movable)\n{\n\tunsigned long start_pfn, end_pfn;\n\tstruct page *start_page, *end_page;\n\n\tif (num_movable)\n\t\t*num_movable = 0;\n\n\tstart_pfn = page_to_pfn(page);\n\tstart_pfn = start_pfn & ~(pageblock_nr_pages-1);\n\tstart_page = pfn_to_page(start_pfn);\n\tend_page = start_page + pageblock_nr_pages - 1;\n\tend_pfn = start_pfn + pageblock_nr_pages - 1;\n\n\t/* Do not cross zone boundaries */\n\tif (!zone_spans_pfn(zone, start_pfn))\n\t\tstart_page = page;\n\tif (!zone_spans_pfn(zone, end_pfn))\n\t\treturn 0;\n\n\treturn move_freepages(zone, start_page, end_page, migratetype,\n\t\t\t\t\t\t\t\tnum_movable);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_pageblock_migratetype",
          "args": [
            "page",
            "MIGRATE_HIGHATOMIC"
          ],
          "line": 2276
        },
        "resolved": true,
        "details": {
          "function_name": "set_pageblock_migratetype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "450-458",
          "snippet": "void set_pageblock_migratetype(struct page *page, int migratetype)\n{\n\tif (unlikely(page_group_by_mobility_disabled &&\n\t\t     migratetype < MIGRATE_PCPTYPES))\n\t\tmigratetype = MIGRATE_UNMOVABLE;\n\n\tset_pageblock_flags_group(page, (unsigned long)migratetype,\n\t\t\t\t\tPB_migrate, PB_migrate_end);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int page_group_by_mobility_disabled",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nint page_group_by_mobility_disabled;\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid set_pageblock_migratetype(struct page *page, int migratetype)\n{\n\tif (unlikely(page_group_by_mobility_disabled &&\n\t\t     migratetype < MIGRATE_PCPTYPES))\n\t\tmigratetype = MIGRATE_UNMOVABLE;\n\n\tset_pageblock_flags_group(page, (unsigned long)migratetype,\n\t\t\t\t\tPB_migrate, PB_migrate_end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_migrate_cma",
          "args": [
            "mt"
          ],
          "line": 2274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_migrate_isolate",
          "args": [
            "mt"
          ],
          "line": 2273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_migrate_highatomic",
          "args": [
            "mt"
          ],
          "line": 2273
        },
        "resolved": true,
        "details": {
          "function_name": "is_migrate_highatomic_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "523-526",
          "snippet": "static inline bool is_migrate_highatomic_page(struct page *page)\n{\n\treturn get_pageblock_migratetype(page) == MIGRATE_HIGHATOMIC;\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline bool is_migrate_highatomic_page(struct page *page)\n{\n\treturn get_pageblock_migratetype(page) == MIGRATE_HIGHATOMIC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pageblock_migratetype",
          "args": [
            "page"
          ],
          "line": 2272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&zone->lock",
            "flags"
          ],
          "line": 2265
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic void reserve_highatomic_pageblock(struct page *page, struct zone *zone,\n\t\t\t\tunsigned int alloc_order)\n{\n\tint mt;\n\tunsigned long max_managed, flags;\n\n\t/*\n\t * Limit the number reserved to 1 pageblock or roughly 1% of a zone.\n\t * Check is race-prone but harmless.\n\t */\n\tmax_managed = (zone->managed_pages / 100) + pageblock_nr_pages;\n\tif (zone->nr_reserved_highatomic >= max_managed)\n\t\treturn;\n\n\tspin_lock_irqsave(&zone->lock, flags);\n\n\t/* Recheck the nr_reserved_highatomic limit under the lock */\n\tif (zone->nr_reserved_highatomic >= max_managed)\n\t\tgoto out_unlock;\n\n\t/* Yoink! */\n\tmt = get_pageblock_migratetype(page);\n\tif (!is_migrate_highatomic(mt) && !is_migrate_isolate(mt)\n\t    && !is_migrate_cma(mt)) {\n\t\tzone->nr_reserved_highatomic += pageblock_nr_pages;\n\t\tset_pageblock_migratetype(page, MIGRATE_HIGHATOMIC);\n\t\tmove_freepages_block(zone, page, MIGRATE_HIGHATOMIC, NULL);\n\t}\n\nout_unlock:\n\tspin_unlock_irqrestore(&zone->lock, flags);\n}"
  },
  {
    "function_name": "find_suitable_fallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "2216-2245",
    "snippet": "int find_suitable_fallback(struct free_area *area, unsigned int order,\n\t\t\tint migratetype, bool only_stealable, bool *can_steal)\n{\n\tint i;\n\tint fallback_mt;\n\n\tif (area->nr_free == 0)\n\t\treturn -1;\n\n\t*can_steal = false;\n\tfor (i = 0;; i++) {\n\t\tfallback_mt = fallbacks[migratetype][i];\n\t\tif (fallback_mt == MIGRATE_TYPES)\n\t\t\tbreak;\n\n\t\tif (list_empty(&area->free_list[fallback_mt]))\n\t\t\tcontinue;\n\n\t\tif (can_steal_fallback(order, migratetype))\n\t\t\t*can_steal = true;\n\n\t\tif (!only_stealable)\n\t\t\treturn fallback_mt;\n\n\t\tif (*can_steal)\n\t\t\treturn fallback_mt;\n\t}\n\n\treturn -1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);",
      "static __always_inline\nstruct",
      "static int fallbacks[MIGRATE_TYPES][4] = {\n\t[MIGRATE_UNMOVABLE]   = { MIGRATE_RECLAIMABLE, MIGRATE_MOVABLE,   MIGRATE_TYPES },\n\t[MIGRATE_RECLAIMABLE] = { MIGRATE_UNMOVABLE,   MIGRATE_MOVABLE,   MIGRATE_TYPES },\n\t[MIGRATE_MOVABLE]     = { MIGRATE_RECLAIMABLE, MIGRATE_UNMOVABLE, MIGRATE_TYPES },\n#ifdef CONFIG_CMA\n\t[MIGRATE_CMA]         = { MIGRATE_TYPES }, /* Never used */\n#endif\n#ifdef CONFIG_MEMORY_ISOLATION\n\t[MIGRATE_ISOLATE]     = { MIGRATE_TYPES }, /* Never used */\n#endif\n};",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "can_steal_fallback",
          "args": [
            "order",
            "migratetype"
          ],
          "line": 2234
        },
        "resolved": true,
        "details": {
          "function_name": "can_steal_fallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "2111-2130",
          "snippet": "static bool can_steal_fallback(unsigned int order, int start_mt)\n{\n\t/*\n\t * Leaving this order check is intended, although there is\n\t * relaxed order check in next check. The reason is that\n\t * we can actually steal whole pageblock if this condition met,\n\t * but, below check doesn't guarantee it and that is just heuristic\n\t * so could be changed anytime.\n\t */\n\tif (order >= pageblock_order)\n\t\treturn true;\n\n\tif (order >= pageblock_order / 2 ||\n\t\tstart_mt == MIGRATE_RECLAIMABLE ||\n\t\tstart_mt == MIGRATE_UNMOVABLE ||\n\t\tpage_group_by_mobility_disabled)\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "int page_group_by_mobility_disabled"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nint page_group_by_mobility_disabled;\n\nstatic bool can_steal_fallback(unsigned int order, int start_mt)\n{\n\t/*\n\t * Leaving this order check is intended, although there is\n\t * relaxed order check in next check. The reason is that\n\t * we can actually steal whole pageblock if this condition met,\n\t * but, below check doesn't guarantee it and that is just heuristic\n\t * so could be changed anytime.\n\t */\n\tif (order >= pageblock_order)\n\t\treturn true;\n\n\tif (order >= pageblock_order / 2 ||\n\t\tstart_mt == MIGRATE_RECLAIMABLE ||\n\t\tstart_mt == MIGRATE_UNMOVABLE ||\n\t\tpage_group_by_mobility_disabled)\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&area->free_list[fallback_mt]"
          ],
          "line": 2231
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic int fallbacks[MIGRATE_TYPES][4] = {\n\t[MIGRATE_UNMOVABLE]   = { MIGRATE_RECLAIMABLE, MIGRATE_MOVABLE,   MIGRATE_TYPES },\n\t[MIGRATE_RECLAIMABLE] = { MIGRATE_UNMOVABLE,   MIGRATE_MOVABLE,   MIGRATE_TYPES },\n\t[MIGRATE_MOVABLE]     = { MIGRATE_RECLAIMABLE, MIGRATE_UNMOVABLE, MIGRATE_TYPES },\n#ifdef CONFIG_CMA\n\t[MIGRATE_CMA]         = { MIGRATE_TYPES }, /* Never used */\n#endif\n#ifdef CONFIG_MEMORY_ISOLATION\n\t[MIGRATE_ISOLATE]     = { MIGRATE_TYPES }, /* Never used */\n#endif\n};\nstatic __always_inline struct;\n\nint find_suitable_fallback(struct free_area *area, unsigned int order,\n\t\t\tint migratetype, bool only_stealable, bool *can_steal)\n{\n\tint i;\n\tint fallback_mt;\n\n\tif (area->nr_free == 0)\n\t\treturn -1;\n\n\t*can_steal = false;\n\tfor (i = 0;; i++) {\n\t\tfallback_mt = fallbacks[migratetype][i];\n\t\tif (fallback_mt == MIGRATE_TYPES)\n\t\t\tbreak;\n\n\t\tif (list_empty(&area->free_list[fallback_mt]))\n\t\t\tcontinue;\n\n\t\tif (can_steal_fallback(order, migratetype))\n\t\t\t*can_steal = true;\n\n\t\tif (!only_stealable)\n\t\t\treturn fallback_mt;\n\n\t\tif (*can_steal)\n\t\t\treturn fallback_mt;\n\t}\n\n\treturn -1;\n}"
  },
  {
    "function_name": "steal_suitable_fallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "2140-2208",
    "snippet": "static void steal_suitable_fallback(struct zone *zone, struct page *page,\n\t\t\t\t\tint start_type, bool whole_block)\n{\n\tunsigned int current_order = page_order(page);\n\tstruct free_area *area;\n\tint free_pages, movable_pages, alike_pages;\n\tint old_block_type;\n\n\told_block_type = get_pageblock_migratetype(page);\n\n\t/*\n\t * This can happen due to races and we want to prevent broken\n\t * highatomic accounting.\n\t */\n\tif (is_migrate_highatomic(old_block_type))\n\t\tgoto single_page;\n\n\t/* Take ownership for orders >= pageblock_order */\n\tif (current_order >= pageblock_order) {\n\t\tchange_pageblock_range(page, current_order, start_type);\n\t\tgoto single_page;\n\t}\n\n\t/* We are not allowed to try stealing from the whole block */\n\tif (!whole_block)\n\t\tgoto single_page;\n\n\tfree_pages = move_freepages_block(zone, page, start_type,\n\t\t\t\t\t\t&movable_pages);\n\t/*\n\t * Determine how many pages are compatible with our allocation.\n\t * For movable allocation, it's the number of movable pages which\n\t * we just obtained. For other types it's a bit more tricky.\n\t */\n\tif (start_type == MIGRATE_MOVABLE) {\n\t\talike_pages = movable_pages;\n\t} else {\n\t\t/*\n\t\t * If we are falling back a RECLAIMABLE or UNMOVABLE allocation\n\t\t * to MOVABLE pageblock, consider all non-movable pages as\n\t\t * compatible. If it's UNMOVABLE falling back to RECLAIMABLE or\n\t\t * vice versa, be conservative since we can't distinguish the\n\t\t * exact migratetype of non-movable pages.\n\t\t */\n\t\tif (old_block_type == MIGRATE_MOVABLE)\n\t\t\talike_pages = pageblock_nr_pages\n\t\t\t\t\t\t- (free_pages + movable_pages);\n\t\telse\n\t\t\talike_pages = 0;\n\t}\n\n\t/* moving whole block can fail due to zone boundary conditions */\n\tif (!free_pages)\n\t\tgoto single_page;\n\n\t/*\n\t * If a sufficient number of pages in the block are either free or of\n\t * comparable migratability as our allocation, claim the whole block.\n\t */\n\tif (free_pages + alike_pages >= (1 << (pageblock_order-1)) ||\n\t\t\tpage_group_by_mobility_disabled)\n\t\tset_pageblock_migratetype(page, start_type);\n\n\treturn;\n\nsingle_page:\n\tarea = &zone->free_area[current_order];\n\tlist_move(&page->lru, &area->free_list[start_type]);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int page_group_by_mobility_disabled",
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&page->lru",
            "&area->free_list[start_type]"
          ],
          "line": 2207
        },
        "resolved": true,
        "details": {
          "function_name": "qlist_move_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/quarantine.c",
          "lines": "72-88",
          "snippet": "static void qlist_move_all(struct qlist_head *from, struct qlist_head *to)\n{\n\tif (unlikely(qlist_empty(from)))\n\t\treturn;\n\n\tif (qlist_empty(to)) {\n\t\t*to = *from;\n\t\tqlist_init(from);\n\t\treturn;\n\t}\n\n\tto->tail->next = from->head;\n\tto->tail = from->tail;\n\tto->bytes += from->bytes;\n\n\tqlist_init(from);\n}",
          "includes": [
            "#include \"kasan.h\"",
            "#include \"../slab.h\"",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/srcu.h>",
            "#include <linux/slab.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/printk.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hash.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kasan.h\"\n#include \"../slab.h\"\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/srcu.h>\n#include <linux/slab.h>\n#include <linux/shrinker.h>\n#include <linux/printk.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/hash.h>\n#include <linux/gfp.h>\n\nstatic void qlist_move_all(struct qlist_head *from, struct qlist_head *to)\n{\n\tif (unlikely(qlist_empty(from)))\n\t\treturn;\n\n\tif (qlist_empty(to)) {\n\t\t*to = *from;\n\t\tqlist_init(from);\n\t\treturn;\n\t}\n\n\tto->tail->next = from->head;\n\tto->tail = from->tail;\n\tto->bytes += from->bytes;\n\n\tqlist_init(from);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_pageblock_migratetype",
          "args": [
            "page",
            "start_type"
          ],
          "line": 2201
        },
        "resolved": true,
        "details": {
          "function_name": "set_pageblock_migratetype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "450-458",
          "snippet": "void set_pageblock_migratetype(struct page *page, int migratetype)\n{\n\tif (unlikely(page_group_by_mobility_disabled &&\n\t\t     migratetype < MIGRATE_PCPTYPES))\n\t\tmigratetype = MIGRATE_UNMOVABLE;\n\n\tset_pageblock_flags_group(page, (unsigned long)migratetype,\n\t\t\t\t\tPB_migrate, PB_migrate_end);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int page_group_by_mobility_disabled",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nint page_group_by_mobility_disabled;\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid set_pageblock_migratetype(struct page *page, int migratetype)\n{\n\tif (unlikely(page_group_by_mobility_disabled &&\n\t\t     migratetype < MIGRATE_PCPTYPES))\n\t\tmigratetype = MIGRATE_UNMOVABLE;\n\n\tset_pageblock_flags_group(page, (unsigned long)migratetype,\n\t\t\t\t\tPB_migrate, PB_migrate_end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "move_freepages_block",
          "args": [
            "zone",
            "page",
            "start_type",
            "&movable_pages"
          ],
          "line": 2167
        },
        "resolved": true,
        "details": {
          "function_name": "move_freepages_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "2063-2086",
          "snippet": "int move_freepages_block(struct zone *zone, struct page *page,\n\t\t\t\tint migratetype, int *num_movable)\n{\n\tunsigned long start_pfn, end_pfn;\n\tstruct page *start_page, *end_page;\n\n\tif (num_movable)\n\t\t*num_movable = 0;\n\n\tstart_pfn = page_to_pfn(page);\n\tstart_pfn = start_pfn & ~(pageblock_nr_pages-1);\n\tstart_page = pfn_to_page(start_pfn);\n\tend_page = start_page + pageblock_nr_pages - 1;\n\tend_pfn = start_pfn + pageblock_nr_pages - 1;\n\n\t/* Do not cross zone boundaries */\n\tif (!zone_spans_pfn(zone, start_pfn))\n\t\tstart_page = page;\n\tif (!zone_spans_pfn(zone, end_pfn))\n\t\treturn 0;\n\n\treturn move_freepages(zone, start_page, end_page, migratetype,\n\t\t\t\t\t\t\t\tnum_movable);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nint move_freepages_block(struct zone *zone, struct page *page,\n\t\t\t\tint migratetype, int *num_movable)\n{\n\tunsigned long start_pfn, end_pfn;\n\tstruct page *start_page, *end_page;\n\n\tif (num_movable)\n\t\t*num_movable = 0;\n\n\tstart_pfn = page_to_pfn(page);\n\tstart_pfn = start_pfn & ~(pageblock_nr_pages-1);\n\tstart_page = pfn_to_page(start_pfn);\n\tend_page = start_page + pageblock_nr_pages - 1;\n\tend_pfn = start_pfn + pageblock_nr_pages - 1;\n\n\t/* Do not cross zone boundaries */\n\tif (!zone_spans_pfn(zone, start_pfn))\n\t\tstart_page = page;\n\tif (!zone_spans_pfn(zone, end_pfn))\n\t\treturn 0;\n\n\treturn move_freepages(zone, start_page, end_page, migratetype,\n\t\t\t\t\t\t\t\tnum_movable);\n}"
        }
      },
      {
        "call_info": {
          "callee": "change_pageblock_range",
          "args": [
            "page",
            "current_order",
            "start_type"
          ],
          "line": 2159
        },
        "resolved": true,
        "details": {
          "function_name": "change_pageblock_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "2088-2097",
          "snippet": "static void change_pageblock_range(struct page *pageblock_page,\n\t\t\t\t\tint start_order, int migratetype)\n{\n\tint nr_pageblocks = 1 << (start_order - pageblock_order);\n\n\twhile (nr_pageblocks--) {\n\t\tset_pageblock_migratetype(pageblock_page, migratetype);\n\t\tpageblock_page += pageblock_nr_pages;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic void change_pageblock_range(struct page *pageblock_page,\n\t\t\t\t\tint start_order, int migratetype)\n{\n\tint nr_pageblocks = 1 << (start_order - pageblock_order);\n\n\twhile (nr_pageblocks--) {\n\t\tset_pageblock_migratetype(pageblock_page, migratetype);\n\t\tpageblock_page += pageblock_nr_pages;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_migrate_highatomic",
          "args": [
            "old_block_type"
          ],
          "line": 2154
        },
        "resolved": true,
        "details": {
          "function_name": "is_migrate_highatomic_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "523-526",
          "snippet": "static inline bool is_migrate_highatomic_page(struct page *page)\n{\n\treturn get_pageblock_migratetype(page) == MIGRATE_HIGHATOMIC;\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline bool is_migrate_highatomic_page(struct page *page)\n{\n\treturn get_pageblock_migratetype(page) == MIGRATE_HIGHATOMIC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pageblock_migratetype",
          "args": [
            "page"
          ],
          "line": 2148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_order",
          "args": [
            "page"
          ],
          "line": 2143
        },
        "resolved": true,
        "details": {
          "function_name": "rmv_page_order",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "707-711",
          "snippet": "static inline void rmv_page_order(struct page *page)\n{\n\t__ClearPageBuddy(page);\n\tset_page_private(page, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline void rmv_page_order(struct page *page)\n{\n\t__ClearPageBuddy(page);\n\tset_page_private(page, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nint page_group_by_mobility_disabled;\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic void steal_suitable_fallback(struct zone *zone, struct page *page,\n\t\t\t\t\tint start_type, bool whole_block)\n{\n\tunsigned int current_order = page_order(page);\n\tstruct free_area *area;\n\tint free_pages, movable_pages, alike_pages;\n\tint old_block_type;\n\n\told_block_type = get_pageblock_migratetype(page);\n\n\t/*\n\t * This can happen due to races and we want to prevent broken\n\t * highatomic accounting.\n\t */\n\tif (is_migrate_highatomic(old_block_type))\n\t\tgoto single_page;\n\n\t/* Take ownership for orders >= pageblock_order */\n\tif (current_order >= pageblock_order) {\n\t\tchange_pageblock_range(page, current_order, start_type);\n\t\tgoto single_page;\n\t}\n\n\t/* We are not allowed to try stealing from the whole block */\n\tif (!whole_block)\n\t\tgoto single_page;\n\n\tfree_pages = move_freepages_block(zone, page, start_type,\n\t\t\t\t\t\t&movable_pages);\n\t/*\n\t * Determine how many pages are compatible with our allocation.\n\t * For movable allocation, it's the number of movable pages which\n\t * we just obtained. For other types it's a bit more tricky.\n\t */\n\tif (start_type == MIGRATE_MOVABLE) {\n\t\talike_pages = movable_pages;\n\t} else {\n\t\t/*\n\t\t * If we are falling back a RECLAIMABLE or UNMOVABLE allocation\n\t\t * to MOVABLE pageblock, consider all non-movable pages as\n\t\t * compatible. If it's UNMOVABLE falling back to RECLAIMABLE or\n\t\t * vice versa, be conservative since we can't distinguish the\n\t\t * exact migratetype of non-movable pages.\n\t\t */\n\t\tif (old_block_type == MIGRATE_MOVABLE)\n\t\t\talike_pages = pageblock_nr_pages\n\t\t\t\t\t\t- (free_pages + movable_pages);\n\t\telse\n\t\t\talike_pages = 0;\n\t}\n\n\t/* moving whole block can fail due to zone boundary conditions */\n\tif (!free_pages)\n\t\tgoto single_page;\n\n\t/*\n\t * If a sufficient number of pages in the block are either free or of\n\t * comparable migratability as our allocation, claim the whole block.\n\t */\n\tif (free_pages + alike_pages >= (1 << (pageblock_order-1)) ||\n\t\t\tpage_group_by_mobility_disabled)\n\t\tset_pageblock_migratetype(page, start_type);\n\n\treturn;\n\nsingle_page:\n\tarea = &zone->free_area[current_order];\n\tlist_move(&page->lru, &area->free_list[start_type]);\n}"
  },
  {
    "function_name": "can_steal_fallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "2111-2130",
    "snippet": "static bool can_steal_fallback(unsigned int order, int start_mt)\n{\n\t/*\n\t * Leaving this order check is intended, although there is\n\t * relaxed order check in next check. The reason is that\n\t * we can actually steal whole pageblock if this condition met,\n\t * but, below check doesn't guarantee it and that is just heuristic\n\t * so could be changed anytime.\n\t */\n\tif (order >= pageblock_order)\n\t\treturn true;\n\n\tif (order >= pageblock_order / 2 ||\n\t\tstart_mt == MIGRATE_RECLAIMABLE ||\n\t\tstart_mt == MIGRATE_UNMOVABLE ||\n\t\tpage_group_by_mobility_disabled)\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);",
      "int page_group_by_mobility_disabled"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nint page_group_by_mobility_disabled;\n\nstatic bool can_steal_fallback(unsigned int order, int start_mt)\n{\n\t/*\n\t * Leaving this order check is intended, although there is\n\t * relaxed order check in next check. The reason is that\n\t * we can actually steal whole pageblock if this condition met,\n\t * but, below check doesn't guarantee it and that is just heuristic\n\t * so could be changed anytime.\n\t */\n\tif (order >= pageblock_order)\n\t\treturn true;\n\n\tif (order >= pageblock_order / 2 ||\n\t\tstart_mt == MIGRATE_RECLAIMABLE ||\n\t\tstart_mt == MIGRATE_UNMOVABLE ||\n\t\tpage_group_by_mobility_disabled)\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "change_pageblock_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "2088-2097",
    "snippet": "static void change_pageblock_range(struct page *pageblock_page,\n\t\t\t\t\tint start_order, int migratetype)\n{\n\tint nr_pageblocks = 1 << (start_order - pageblock_order);\n\n\twhile (nr_pageblocks--) {\n\t\tset_pageblock_migratetype(pageblock_page, migratetype);\n\t\tpageblock_page += pageblock_nr_pages;\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_pageblock_migratetype",
          "args": [
            "pageblock_page",
            "migratetype"
          ],
          "line": 2094
        },
        "resolved": true,
        "details": {
          "function_name": "set_pageblock_migratetype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "450-458",
          "snippet": "void set_pageblock_migratetype(struct page *page, int migratetype)\n{\n\tif (unlikely(page_group_by_mobility_disabled &&\n\t\t     migratetype < MIGRATE_PCPTYPES))\n\t\tmigratetype = MIGRATE_UNMOVABLE;\n\n\tset_pageblock_flags_group(page, (unsigned long)migratetype,\n\t\t\t\t\tPB_migrate, PB_migrate_end);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int page_group_by_mobility_disabled",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nint page_group_by_mobility_disabled;\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid set_pageblock_migratetype(struct page *page, int migratetype)\n{\n\tif (unlikely(page_group_by_mobility_disabled &&\n\t\t     migratetype < MIGRATE_PCPTYPES))\n\t\tmigratetype = MIGRATE_UNMOVABLE;\n\n\tset_pageblock_flags_group(page, (unsigned long)migratetype,\n\t\t\t\t\tPB_migrate, PB_migrate_end);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic void change_pageblock_range(struct page *pageblock_page,\n\t\t\t\t\tint start_order, int migratetype)\n{\n\tint nr_pageblocks = 1 << (start_order - pageblock_order);\n\n\twhile (nr_pageblocks--) {\n\t\tset_pageblock_migratetype(pageblock_page, migratetype);\n\t\tpageblock_page += pageblock_nr_pages;\n\t}\n}"
  },
  {
    "function_name": "move_freepages_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "2063-2086",
    "snippet": "int move_freepages_block(struct zone *zone, struct page *page,\n\t\t\t\tint migratetype, int *num_movable)\n{\n\tunsigned long start_pfn, end_pfn;\n\tstruct page *start_page, *end_page;\n\n\tif (num_movable)\n\t\t*num_movable = 0;\n\n\tstart_pfn = page_to_pfn(page);\n\tstart_pfn = start_pfn & ~(pageblock_nr_pages-1);\n\tstart_page = pfn_to_page(start_pfn);\n\tend_page = start_page + pageblock_nr_pages - 1;\n\tend_pfn = start_pfn + pageblock_nr_pages - 1;\n\n\t/* Do not cross zone boundaries */\n\tif (!zone_spans_pfn(zone, start_pfn))\n\t\tstart_page = page;\n\tif (!zone_spans_pfn(zone, end_pfn))\n\t\treturn 0;\n\n\treturn move_freepages(zone, start_page, end_page, migratetype,\n\t\t\t\t\t\t\t\tnum_movable);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "move_freepages",
          "args": [
            "zone",
            "start_page",
            "end_page",
            "migratetype",
            "num_movable"
          ],
          "line": 2084
        },
        "resolved": true,
        "details": {
          "function_name": "move_freepages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "2010-2061",
          "snippet": "static int move_freepages(struct zone *zone,\n\t\t\t  struct page *start_page, struct page *end_page,\n\t\t\t  int migratetype, int *num_movable)\n{\n\tstruct page *page;\n\tunsigned int order;\n\tint pages_moved = 0;\n\n#ifndef CONFIG_HOLES_IN_ZONE\n\t/*\n\t * page_zone is not safe to call in this context when\n\t * CONFIG_HOLES_IN_ZONE is set. This bug check is probably redundant\n\t * anyway as we check zone boundaries in move_freepages_block().\n\t * Remove at a later date when no bug reports exist related to\n\t * grouping pages by mobility\n\t */\n\tVM_BUG_ON(pfn_valid(page_to_pfn(start_page)) &&\n\t          pfn_valid(page_to_pfn(end_page)) &&\n\t          page_zone(start_page) != page_zone(end_page));\n#endif\n\tfor (page = start_page; page <= end_page;) {\n\t\tif (!pfn_valid_within(page_to_pfn(page))) {\n\t\t\tpage++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Make sure we are not inadvertently changing nodes */\n\t\tVM_BUG_ON_PAGE(page_to_nid(page) != zone_to_nid(zone), page);\n\n\t\tif (!PageBuddy(page)) {\n\t\t\t/*\n\t\t\t * We assume that pages that could be isolated for\n\t\t\t * migration are movable. But we don't actually try\n\t\t\t * isolating, as that would be expensive.\n\t\t\t */\n\t\t\tif (num_movable &&\n\t\t\t\t\t(PageLRU(page) || __PageMovable(page)))\n\t\t\t\t(*num_movable)++;\n\n\t\t\tpage++;\n\t\t\tcontinue;\n\t\t}\n\n\t\torder = page_order(page);\n\t\tlist_move(&page->lru,\n\t\t\t  &zone->free_area[order].free_list[migratetype]);\n\t\tpage += 1 << order;\n\t\tpages_moved += 1 << order;\n\t}\n\n\treturn pages_moved;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic int move_freepages(struct zone *zone,\n\t\t\t  struct page *start_page, struct page *end_page,\n\t\t\t  int migratetype, int *num_movable)\n{\n\tstruct page *page;\n\tunsigned int order;\n\tint pages_moved = 0;\n\n#ifndef CONFIG_HOLES_IN_ZONE\n\t/*\n\t * page_zone is not safe to call in this context when\n\t * CONFIG_HOLES_IN_ZONE is set. This bug check is probably redundant\n\t * anyway as we check zone boundaries in move_freepages_block().\n\t * Remove at a later date when no bug reports exist related to\n\t * grouping pages by mobility\n\t */\n\tVM_BUG_ON(pfn_valid(page_to_pfn(start_page)) &&\n\t          pfn_valid(page_to_pfn(end_page)) &&\n\t          page_zone(start_page) != page_zone(end_page));\n#endif\n\tfor (page = start_page; page <= end_page;) {\n\t\tif (!pfn_valid_within(page_to_pfn(page))) {\n\t\t\tpage++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Make sure we are not inadvertently changing nodes */\n\t\tVM_BUG_ON_PAGE(page_to_nid(page) != zone_to_nid(zone), page);\n\n\t\tif (!PageBuddy(page)) {\n\t\t\t/*\n\t\t\t * We assume that pages that could be isolated for\n\t\t\t * migration are movable. But we don't actually try\n\t\t\t * isolating, as that would be expensive.\n\t\t\t */\n\t\t\tif (num_movable &&\n\t\t\t\t\t(PageLRU(page) || __PageMovable(page)))\n\t\t\t\t(*num_movable)++;\n\n\t\t\tpage++;\n\t\t\tcontinue;\n\t\t}\n\n\t\torder = page_order(page);\n\t\tlist_move(&page->lru,\n\t\t\t  &zone->free_area[order].free_list[migratetype]);\n\t\tpage += 1 << order;\n\t\tpages_moved += 1 << order;\n\t}\n\n\treturn pages_moved;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zone_spans_pfn",
          "args": [
            "zone",
            "end_pfn"
          ],
          "line": 2081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_spans_pfn",
          "args": [
            "zone",
            "start_pfn"
          ],
          "line": 2079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "start_pfn"
          ],
          "line": 2074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "page"
          ],
          "line": 2072
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nint move_freepages_block(struct zone *zone, struct page *page,\n\t\t\t\tint migratetype, int *num_movable)\n{\n\tunsigned long start_pfn, end_pfn;\n\tstruct page *start_page, *end_page;\n\n\tif (num_movable)\n\t\t*num_movable = 0;\n\n\tstart_pfn = page_to_pfn(page);\n\tstart_pfn = start_pfn & ~(pageblock_nr_pages-1);\n\tstart_page = pfn_to_page(start_pfn);\n\tend_page = start_page + pageblock_nr_pages - 1;\n\tend_pfn = start_pfn + pageblock_nr_pages - 1;\n\n\t/* Do not cross zone boundaries */\n\tif (!zone_spans_pfn(zone, start_pfn))\n\t\tstart_page = page;\n\tif (!zone_spans_pfn(zone, end_pfn))\n\t\treturn 0;\n\n\treturn move_freepages(zone, start_page, end_page, migratetype,\n\t\t\t\t\t\t\t\tnum_movable);\n}"
  },
  {
    "function_name": "move_freepages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "2010-2061",
    "snippet": "static int move_freepages(struct zone *zone,\n\t\t\t  struct page *start_page, struct page *end_page,\n\t\t\t  int migratetype, int *num_movable)\n{\n\tstruct page *page;\n\tunsigned int order;\n\tint pages_moved = 0;\n\n#ifndef CONFIG_HOLES_IN_ZONE\n\t/*\n\t * page_zone is not safe to call in this context when\n\t * CONFIG_HOLES_IN_ZONE is set. This bug check is probably redundant\n\t * anyway as we check zone boundaries in move_freepages_block().\n\t * Remove at a later date when no bug reports exist related to\n\t * grouping pages by mobility\n\t */\n\tVM_BUG_ON(pfn_valid(page_to_pfn(start_page)) &&\n\t          pfn_valid(page_to_pfn(end_page)) &&\n\t          page_zone(start_page) != page_zone(end_page));\n#endif\n\tfor (page = start_page; page <= end_page;) {\n\t\tif (!pfn_valid_within(page_to_pfn(page))) {\n\t\t\tpage++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Make sure we are not inadvertently changing nodes */\n\t\tVM_BUG_ON_PAGE(page_to_nid(page) != zone_to_nid(zone), page);\n\n\t\tif (!PageBuddy(page)) {\n\t\t\t/*\n\t\t\t * We assume that pages that could be isolated for\n\t\t\t * migration are movable. But we don't actually try\n\t\t\t * isolating, as that would be expensive.\n\t\t\t */\n\t\t\tif (num_movable &&\n\t\t\t\t\t(PageLRU(page) || __PageMovable(page)))\n\t\t\t\t(*num_movable)++;\n\n\t\t\tpage++;\n\t\t\tcontinue;\n\t\t}\n\n\t\torder = page_order(page);\n\t\tlist_move(&page->lru,\n\t\t\t  &zone->free_area[order].free_list[migratetype]);\n\t\tpage += 1 << order;\n\t\tpages_moved += 1 << order;\n\t}\n\n\treturn pages_moved;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);",
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&page->lru",
            "&zone->free_area[order].free_list[migratetype]"
          ],
          "line": 2054
        },
        "resolved": true,
        "details": {
          "function_name": "qlist_move_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/quarantine.c",
          "lines": "72-88",
          "snippet": "static void qlist_move_all(struct qlist_head *from, struct qlist_head *to)\n{\n\tif (unlikely(qlist_empty(from)))\n\t\treturn;\n\n\tif (qlist_empty(to)) {\n\t\t*to = *from;\n\t\tqlist_init(from);\n\t\treturn;\n\t}\n\n\tto->tail->next = from->head;\n\tto->tail = from->tail;\n\tto->bytes += from->bytes;\n\n\tqlist_init(from);\n}",
          "includes": [
            "#include \"kasan.h\"",
            "#include \"../slab.h\"",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/srcu.h>",
            "#include <linux/slab.h>",
            "#include <linux/shrinker.h>",
            "#include <linux/printk.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hash.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kasan.h\"\n#include \"../slab.h\"\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/srcu.h>\n#include <linux/slab.h>\n#include <linux/shrinker.h>\n#include <linux/printk.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/hash.h>\n#include <linux/gfp.h>\n\nstatic void qlist_move_all(struct qlist_head *from, struct qlist_head *to)\n{\n\tif (unlikely(qlist_empty(from)))\n\t\treturn;\n\n\tif (qlist_empty(to)) {\n\t\t*to = *from;\n\t\tqlist_init(from);\n\t\treturn;\n\t}\n\n\tto->tail->next = from->head;\n\tto->tail = from->tail;\n\tto->bytes += from->bytes;\n\n\tqlist_init(from);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_order",
          "args": [
            "page"
          ],
          "line": 2053
        },
        "resolved": true,
        "details": {
          "function_name": "rmv_page_order",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "707-711",
          "snippet": "static inline void rmv_page_order(struct page *page)\n{\n\t__ClearPageBuddy(page);\n\tset_page_private(page, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline void rmv_page_order(struct page *page)\n{\n\t__ClearPageBuddy(page);\n\tset_page_private(page, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__PageMovable",
          "args": [
            "page"
          ],
          "line": 2046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLRU",
          "args": [
            "page"
          ],
          "line": 2046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageBuddy",
          "args": [
            "page"
          ],
          "line": 2039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "page_to_nid(page) != zone_to_nid(zone)",
            "page"
          ],
          "line": 2037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_to_nid",
          "args": [
            "zone"
          ],
          "line": 2037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_nid",
          "args": [
            "page"
          ],
          "line": 2037
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "45-48",
          "snippet": "int page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfn_valid_within",
          "args": [
            "page_to_pfn(page)"
          ],
          "line": 2031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "page"
          ],
          "line": 2031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "pfn_valid(page_to_pfn(start_page)) &&\n\t          pfn_valid(page_to_pfn(end_page)) &&\n\t          page_zone(start_page) != page_zone(end_page)"
          ],
          "line": 2026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "end_page"
          ],
          "line": 2028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "start_page"
          ],
          "line": 2028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_valid",
          "args": [
            "page_to_pfn(end_page)"
          ],
          "line": 2027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "end_page"
          ],
          "line": 2027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_valid",
          "args": [
            "page_to_pfn(start_page)"
          ],
          "line": 2026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "start_page"
          ],
          "line": 2026
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic int move_freepages(struct zone *zone,\n\t\t\t  struct page *start_page, struct page *end_page,\n\t\t\t  int migratetype, int *num_movable)\n{\n\tstruct page *page;\n\tunsigned int order;\n\tint pages_moved = 0;\n\n#ifndef CONFIG_HOLES_IN_ZONE\n\t/*\n\t * page_zone is not safe to call in this context when\n\t * CONFIG_HOLES_IN_ZONE is set. This bug check is probably redundant\n\t * anyway as we check zone boundaries in move_freepages_block().\n\t * Remove at a later date when no bug reports exist related to\n\t * grouping pages by mobility\n\t */\n\tVM_BUG_ON(pfn_valid(page_to_pfn(start_page)) &&\n\t          pfn_valid(page_to_pfn(end_page)) &&\n\t          page_zone(start_page) != page_zone(end_page));\n#endif\n\tfor (page = start_page; page <= end_page;) {\n\t\tif (!pfn_valid_within(page_to_pfn(page))) {\n\t\t\tpage++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Make sure we are not inadvertently changing nodes */\n\t\tVM_BUG_ON_PAGE(page_to_nid(page) != zone_to_nid(zone), page);\n\n\t\tif (!PageBuddy(page)) {\n\t\t\t/*\n\t\t\t * We assume that pages that could be isolated for\n\t\t\t * migration are movable. But we don't actually try\n\t\t\t * isolating, as that would be expensive.\n\t\t\t */\n\t\t\tif (num_movable &&\n\t\t\t\t\t(PageLRU(page) || __PageMovable(page)))\n\t\t\t\t(*num_movable)++;\n\n\t\t\tpage++;\n\t\t\tcontinue;\n\t\t}\n\n\t\torder = page_order(page);\n\t\tlist_move(&page->lru,\n\t\t\t  &zone->free_area[order].free_list[migratetype]);\n\t\tpage += 1 << order;\n\t\tpages_moved += 1 << order;\n\t}\n\n\treturn pages_moved;\n}"
  },
  {
    "function_name": "__rmqueue_cma_fallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "2001-2002",
    "snippet": "static inline struct page *__rmqueue_cma_fallback(struct zone *zone,\n\t\t\t\t\tunsigned int order) { return NULL; }",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);",
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline struct page *__rmqueue_cma_fallback(struct zone *zone,\n\t\t\t\t\tunsigned int order) { return NULL; }"
  },
  {
    "function_name": "__rmqueue_cma_fallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "1995-1999",
    "snippet": "page *__rmqueue_cma_fallback(struct zone *zone,\n\t\t\t\t\tunsigned int order)\n{\n\treturn __rmqueue_smallest(zone, order, MIGRATE_CMA);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);",
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__rmqueue_smallest",
          "args": [
            "zone",
            "order",
            "MIGRATE_CMA"
          ],
          "line": 1998
        },
        "resolved": true,
        "details": {
          "function_name": "__rmqueue_smallest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1952-1975",
          "snippet": "page *__rmqueue_smallest(struct zone *zone, unsigned int order,\n\t\t\t\t\t\tint migratetype)\n{\n\tunsigned int current_order;\n\tstruct free_area *area;\n\tstruct page *page;\n\n\t/* Find a page of the appropriate size in the preferred list */\n\tfor (current_order = order; current_order < MAX_ORDER; ++current_order) {\n\t\tarea = &(zone->free_area[current_order]);\n\t\tpage = list_first_entry_or_null(&area->free_list[migratetype],\n\t\t\t\t\t\t\tstruct page, lru);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tlist_del(&page->lru);\n\t\trmv_page_order(page);\n\t\tarea->nr_free--;\n\t\texpand(zone, page, order, current_order, area, migratetype);\n\t\tset_pcppage_migratetype(page, migratetype);\n\t\treturn page;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\npage *__rmqueue_smallest(struct zone *zone, unsigned int order,\n\t\t\t\t\t\tint migratetype)\n{\n\tunsigned int current_order;\n\tstruct free_area *area;\n\tstruct page *page;\n\n\t/* Find a page of the appropriate size in the preferred list */\n\tfor (current_order = order; current_order < MAX_ORDER; ++current_order) {\n\t\tarea = &(zone->free_area[current_order]);\n\t\tpage = list_first_entry_or_null(&area->free_list[migratetype],\n\t\t\t\t\t\t\tstruct page, lru);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tlist_del(&page->lru);\n\t\trmv_page_order(page);\n\t\tarea->nr_free--;\n\t\texpand(zone, page, order, current_order, area, migratetype);\n\t\tset_pcppage_migratetype(page, migratetype);\n\t\treturn page;\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\npage *__rmqueue_cma_fallback(struct zone *zone,\n\t\t\t\t\tunsigned int order)\n{\n\treturn __rmqueue_smallest(zone, order, MIGRATE_CMA);\n}"
  },
  {
    "function_name": "__rmqueue_smallest",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "1952-1975",
    "snippet": "page *__rmqueue_smallest(struct zone *zone, unsigned int order,\n\t\t\t\t\t\tint migratetype)\n{\n\tunsigned int current_order;\n\tstruct free_area *area;\n\tstruct page *page;\n\n\t/* Find a page of the appropriate size in the preferred list */\n\tfor (current_order = order; current_order < MAX_ORDER; ++current_order) {\n\t\tarea = &(zone->free_area[current_order]);\n\t\tpage = list_first_entry_or_null(&area->free_list[migratetype],\n\t\t\t\t\t\t\tstruct page, lru);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tlist_del(&page->lru);\n\t\trmv_page_order(page);\n\t\tarea->nr_free--;\n\t\texpand(zone, page, order, current_order, area, migratetype);\n\t\tset_pcppage_migratetype(page, migratetype);\n\t\treturn page;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);",
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_pcppage_migratetype",
          "args": [
            "page",
            "migratetype"
          ],
          "line": 1970
        },
        "resolved": true,
        "details": {
          "function_name": "set_pcppage_migratetype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "147-150",
          "snippet": "static inline void set_pcppage_migratetype(struct page *page, int migratetype)\n{\n\tpage->index = migratetype;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline void set_pcppage_migratetype(struct page *page, int migratetype)\n{\n\tpage->index = migratetype;\n}"
        }
      },
      {
        "call_info": {
          "callee": "expand",
          "args": [
            "zone",
            "page",
            "order",
            "current_order",
            "area",
            "migratetype"
          ],
          "line": 1969
        },
        "resolved": true,
        "details": {
          "function_name": "expand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1799-1824",
          "snippet": "static inline void expand(struct zone *zone, struct page *page,\n\tint low, int high, struct free_area *area,\n\tint migratetype)\n{\n\tunsigned long size = 1 << high;\n\n\twhile (high > low) {\n\t\tarea--;\n\t\thigh--;\n\t\tsize >>= 1;\n\t\tVM_BUG_ON_PAGE(bad_range(zone, &page[size]), &page[size]);\n\n\t\t/*\n\t\t * Mark as guard pages (or page), that will allow to\n\t\t * merge back to allocator when buddy will be freed.\n\t\t * Corresponding page table entries will not be touched,\n\t\t * pages will stay not present in virtual address space\n\t\t */\n\t\tif (set_page_guard(zone, &page[size], high, migratetype))\n\t\t\tcontinue;\n\n\t\tlist_add(&page[size].lru, &area->free_list[migratetype]);\n\t\tarea->nr_free++;\n\t\tset_page_order(&page[size], high);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline void expand(struct zone *zone, struct page *page,\n\tint low, int high, struct free_area *area,\n\tint migratetype)\n{\n\tunsigned long size = 1 << high;\n\n\twhile (high > low) {\n\t\tarea--;\n\t\thigh--;\n\t\tsize >>= 1;\n\t\tVM_BUG_ON_PAGE(bad_range(zone, &page[size]), &page[size]);\n\n\t\t/*\n\t\t * Mark as guard pages (or page), that will allow to\n\t\t * merge back to allocator when buddy will be freed.\n\t\t * Corresponding page table entries will not be touched,\n\t\t * pages will stay not present in virtual address space\n\t\t */\n\t\tif (set_page_guard(zone, &page[size], high, migratetype))\n\t\t\tcontinue;\n\n\t\tlist_add(&page[size].lru, &area->free_list[migratetype]);\n\t\tarea->nr_free++;\n\t\tset_page_order(&page[size], high);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rmv_page_order",
          "args": [
            "page"
          ],
          "line": 1967
        },
        "resolved": true,
        "details": {
          "function_name": "rmv_page_order",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "707-711",
          "snippet": "static inline void rmv_page_order(struct page *page)\n{\n\t__ClearPageBuddy(page);\n\tset_page_private(page, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline void rmv_page_order(struct page *page)\n{\n\t__ClearPageBuddy(page);\n\tset_page_private(page, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&page->lru"
          ],
          "line": 1966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry_or_null",
          "args": [
            "&area->free_list[migratetype]",
            "structpage",
            "lru"
          ],
          "line": 1962
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\npage *__rmqueue_smallest(struct zone *zone, unsigned int order,\n\t\t\t\t\t\tint migratetype)\n{\n\tunsigned int current_order;\n\tstruct free_area *area;\n\tstruct page *page;\n\n\t/* Find a page of the appropriate size in the preferred list */\n\tfor (current_order = order; current_order < MAX_ORDER; ++current_order) {\n\t\tarea = &(zone->free_area[current_order]);\n\t\tpage = list_first_entry_or_null(&area->free_list[migratetype],\n\t\t\t\t\t\t\tstruct page, lru);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tlist_del(&page->lru);\n\t\trmv_page_order(page);\n\t\tarea->nr_free--;\n\t\texpand(zone, page, order, current_order, area, migratetype);\n\t\tset_pcppage_migratetype(page, migratetype);\n\t\treturn page;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "prep_new_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "1921-1945",
    "snippet": "static void prep_new_page(struct page *page, unsigned int order, gfp_t gfp_flags,\n\t\t\t\t\t\t\tunsigned int alloc_flags)\n{\n\tint i;\n\n\tpost_alloc_hook(page, order, gfp_flags);\n\n\tif (!free_pages_prezeroed() && (gfp_flags & __GFP_ZERO))\n\t\tfor (i = 0; i < (1 << order); i++)\n\t\t\tclear_highpage(page + i);\n\n\tif (order && (gfp_flags & __GFP_COMP))\n\t\tprep_compound_page(page, order);\n\n\t/*\n\t * page is set pfmemalloc when ALLOC_NO_WATERMARKS was necessary to\n\t * allocate the page. The expectation is that the caller is taking\n\t * steps that will free more memory. The caller should avoid the page\n\t * being used for !PFMEMALLOC purposes.\n\t */\n\tif (alloc_flags & ALLOC_NO_WATERMARKS)\n\t\tset_page_pfmemalloc(page);\n\telse\n\t\tclear_page_pfmemalloc(page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);",
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_page_pfmemalloc",
          "args": [
            "page"
          ],
          "line": 1944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_pfmemalloc",
          "args": [
            "page"
          ],
          "line": 1942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prep_compound_page",
          "args": [
            "page",
            "order"
          ],
          "line": 1933
        },
        "resolved": true,
        "details": {
          "function_name": "prep_compound_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "576-591",
          "snippet": "void prep_compound_page(struct page *page, unsigned int order)\n{\n\tint i;\n\tint nr_pages = 1 << order;\n\n\tset_compound_page_dtor(page, COMPOUND_PAGE_DTOR);\n\tset_compound_order(page, order);\n\t__SetPageHead(page);\n\tfor (i = 1; i < nr_pages; i++) {\n\t\tstruct page *p = page + i;\n\t\tset_page_count(p, 0);\n\t\tp->mapping = TAIL_MAPPING;\n\t\tset_compound_head(p, page);\n\t}\n\tatomic_set(compound_mapcount_ptr(page), -1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid prep_compound_page(struct page *page, unsigned int order)\n{\n\tint i;\n\tint nr_pages = 1 << order;\n\n\tset_compound_page_dtor(page, COMPOUND_PAGE_DTOR);\n\tset_compound_order(page, order);\n\t__SetPageHead(page);\n\tfor (i = 1; i < nr_pages; i++) {\n\t\tstruct page *p = page + i;\n\t\tset_page_count(p, 0);\n\t\tp->mapping = TAIL_MAPPING;\n\t\tset_compound_head(p, page);\n\t}\n\tatomic_set(compound_mapcount_ptr(page), -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_highpage",
          "args": [
            "page + i"
          ],
          "line": 1930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_pages_prezeroed",
          "args": [],
          "line": 1928
        },
        "resolved": true,
        "details": {
          "function_name": "free_pages_prezeroed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1868-1872",
          "snippet": "static inline bool free_pages_prezeroed(void)\n{\n\treturn IS_ENABLED(CONFIG_PAGE_POISONING_ZERO) &&\n\t\tpage_poisoning_enabled();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic inline bool free_pages_prezeroed(void)\n{\n\treturn IS_ENABLED(CONFIG_PAGE_POISONING_ZERO) &&\n\t\tpage_poisoning_enabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "post_alloc_hook",
          "args": [
            "page",
            "order",
            "gfp_flags"
          ],
          "line": 1926
        },
        "resolved": true,
        "details": {
          "function_name": "post_alloc_hook",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1908-1919",
          "snippet": "inline void post_alloc_hook(struct page *page, unsigned int order,\n\t\t\t\tgfp_t gfp_flags)\n{\n\tset_page_private(page, 0);\n\tset_page_refcounted(page);\n\n\tarch_alloc_page(page, order);\n\tkernel_map_pages(page, 1 << order, 1);\n\tkernel_poison_pages(page, 1 << order, 1);\n\tkasan_alloc_pages(page, order);\n\tset_page_owner(page, order, gfp_flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\ninline void post_alloc_hook(struct page *page, unsigned int order,\n\t\t\t\tgfp_t gfp_flags)\n{\n\tset_page_private(page, 0);\n\tset_page_refcounted(page);\n\n\tarch_alloc_page(page, order);\n\tkernel_map_pages(page, 1 << order, 1);\n\tkernel_poison_pages(page, 1 << order, 1);\n\tkasan_alloc_pages(page, order);\n\tset_page_owner(page, order, gfp_flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic void prep_new_page(struct page *page, unsigned int order, gfp_t gfp_flags,\n\t\t\t\t\t\t\tunsigned int alloc_flags)\n{\n\tint i;\n\n\tpost_alloc_hook(page, order, gfp_flags);\n\n\tif (!free_pages_prezeroed() && (gfp_flags & __GFP_ZERO))\n\t\tfor (i = 0; i < (1 << order); i++)\n\t\t\tclear_highpage(page + i);\n\n\tif (order && (gfp_flags & __GFP_COMP))\n\t\tprep_compound_page(page, order);\n\n\t/*\n\t * page is set pfmemalloc when ALLOC_NO_WATERMARKS was necessary to\n\t * allocate the page. The expectation is that the caller is taking\n\t * steps that will free more memory. The caller should avoid the page\n\t * being used for !PFMEMALLOC purposes.\n\t */\n\tif (alloc_flags & ALLOC_NO_WATERMARKS)\n\t\tset_page_pfmemalloc(page);\n\telse\n\t\tclear_page_pfmemalloc(page);\n}"
  },
  {
    "function_name": "post_alloc_hook",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "1908-1919",
    "snippet": "inline void post_alloc_hook(struct page *page, unsigned int order,\n\t\t\t\tgfp_t gfp_flags)\n{\n\tset_page_private(page, 0);\n\tset_page_refcounted(page);\n\n\tarch_alloc_page(page, order);\n\tkernel_map_pages(page, 1 << order, 1);\n\tkernel_poison_pages(page, 1 << order, 1);\n\tkasan_alloc_pages(page, order);\n\tset_page_owner(page, order, gfp_flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);",
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_page_owner",
          "args": [
            "page",
            "order",
            "gfp_flags"
          ],
          "line": 1918
        },
        "resolved": true,
        "details": {
          "function_name": "__set_page_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_owner.c",
          "lines": "186-197",
          "snippet": "noinline void __set_page_owner(struct page *page, unsigned int order,\n\t\t\t\t\tgfp_t gfp_mask)\n{\n\tstruct page_ext *page_ext = lookup_page_ext(page);\n\tdepot_stack_handle_t handle;\n\n\tif (unlikely(!page_ext))\n\t\treturn;\n\n\thandle = save_stack(gfp_mask);\n\t__set_page_owner_handle(page_ext, handle, order, gfp_mask);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/stackdepot.h>",
            "#include <linux/migrate.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline depot_stack_handle_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/stackdepot.h>\n#include <linux/migrate.h>\n#include <linux/jump_label.h>\n#include <linux/page_owner.h>\n#include <linux/stacktrace.h>\n#include <linux/memblock.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/debugfs.h>\n\nstatic __always_inline depot_stack_handle_t;\n\nnoinline void __set_page_owner(struct page *page, unsigned int order,\n\t\t\t\t\tgfp_t gfp_mask)\n{\n\tstruct page_ext *page_ext = lookup_page_ext(page);\n\tdepot_stack_handle_t handle;\n\n\tif (unlikely(!page_ext))\n\t\treturn;\n\n\thandle = save_stack(gfp_mask);\n\t__set_page_owner_handle(page_ext, handle, order, gfp_mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kasan_alloc_pages",
          "args": [
            "page",
            "order"
          ],
          "line": 1917
        },
        "resolved": true,
        "details": {
          "function_name": "kasan_alloc_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "308-312",
          "snippet": "void kasan_alloc_pages(struct page *page, unsigned int order)\n{\n\tif (likely(!PageHighMem(page)))\n\t\tkasan_unpoison_shadow(page_address(page), PAGE_SIZE << order);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\nvoid kasan_alloc_pages(struct page *page, unsigned int order)\n{\n\tif (likely(!PageHighMem(page)))\n\t\tkasan_unpoison_shadow(page_address(page), PAGE_SIZE << order);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernel_poison_pages",
          "args": [
            "page",
            "1 << order",
            "1"
          ],
          "line": 1916
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_poison_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_poison.c",
          "lines": "114-123",
          "snippet": "void kernel_poison_pages(struct page *page, int numpages, int enable)\n{\n\tif (!page_poisoning_enabled())\n\t\treturn;\n\n\tif (enable)\n\t\tunpoison_pages(page, numpages);\n\telse\n\t\tpoison_pages(page, numpages);\n}",
          "includes": [
            "#include <linux/ratelimit.h>",
            "#include <linux/poison.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ratelimit.h>\n#include <linux/poison.h>\n#include <linux/page_ext.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nvoid kernel_poison_pages(struct page *page, int numpages, int enable)\n{\n\tif (!page_poisoning_enabled())\n\t\treturn;\n\n\tif (enable)\n\t\tunpoison_pages(page, numpages);\n\telse\n\t\tpoison_pages(page, numpages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernel_map_pages",
          "args": [
            "page",
            "1 << order",
            "1"
          ],
          "line": 1915
        },
        "resolved": true,
        "details": {
          "function_name": "__kernel_map_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_poison.c",
          "lines": "126-129",
          "snippet": "void __kernel_map_pages(struct page *page, int numpages, int enable)\n{\n\t/* This function does nothing, all work is done via poison pages */\n}",
          "includes": [
            "#include <linux/ratelimit.h>",
            "#include <linux/poison.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ratelimit.h>\n#include <linux/poison.h>\n#include <linux/page_ext.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nvoid __kernel_map_pages(struct page *page, int numpages, int enable)\n{\n\t/* This function does nothing, all work is done via poison pages */\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_alloc_page",
          "args": [
            "page",
            "order"
          ],
          "line": 1914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_refcounted",
          "args": [
            "page"
          ],
          "line": 1912
        },
        "resolved": true,
        "details": {
          "function_name": "set_page_refcounted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "74-79",
          "snippet": "static inline void set_page_refcounted(struct page *page)\n{\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\tVM_BUG_ON_PAGE(page_ref_count(page), page);\n\tset_page_count(page, 1);\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void set_page_refcounted(struct page *page)\n{\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\tVM_BUG_ON_PAGE(page_ref_count(page), page);\n\tset_page_count(page, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "page",
            "0"
          ],
          "line": 1911
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\ninline void post_alloc_hook(struct page *page, unsigned int order,\n\t\t\t\tgfp_t gfp_flags)\n{\n\tset_page_private(page, 0);\n\tset_page_refcounted(page);\n\n\tarch_alloc_page(page, order);\n\tkernel_map_pages(page, 1 << order, 1);\n\tkernel_poison_pages(page, 1 << order, 1);\n\tkasan_alloc_pages(page, order);\n\tset_page_owner(page, order, gfp_flags);\n}"
  },
  {
    "function_name": "check_new_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "1895-1906",
    "snippet": "static bool check_new_pages(struct page *page, unsigned int order)\n{\n\tint i;\n\tfor (i = 0; i < (1 << order); i++) {\n\t\tstruct page *p = page + i;\n\n\t\tif (unlikely(check_new_page(p)))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);",
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "check_new_page(p)"
          ],
          "line": 1901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_new_page",
          "args": [
            "p"
          ],
          "line": 1901
        },
        "resolved": true,
        "details": {
          "function_name": "check_new_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1858-1866",
          "snippet": "static inline int check_new_page(struct page *page)\n{\n\tif (likely(page_expected_state(page,\n\t\t\t\tPAGE_FLAGS_CHECK_AT_PREP|__PG_HWPOISON)))\n\t\treturn 0;\n\n\tcheck_new_page_bad(page);\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline int check_new_page(struct page *page)\n{\n\tif (likely(page_expected_state(page,\n\t\t\t\tPAGE_FLAGS_CHECK_AT_PREP|__PG_HWPOISON)))\n\t\treturn 0;\n\n\tcheck_new_page_bad(page);\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool check_new_pages(struct page *page, unsigned int order)\n{\n\tint i;\n\tfor (i = 0; i < (1 << order); i++) {\n\t\tstruct page *p = page + i;\n\n\t\tif (unlikely(check_new_page(p)))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "check_new_pcp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "1889-1892",
    "snippet": "static bool check_new_pcp(struct page *page)\n{\n\treturn false;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool check_new_pcp(struct page *page)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "check_pcp_refill",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "1885-1888",
    "snippet": "static bool check_pcp_refill(struct page *page)\n{\n\treturn check_new_page(page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_new_page",
          "args": [
            "page"
          ],
          "line": 1887
        },
        "resolved": true,
        "details": {
          "function_name": "check_new_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1858-1866",
          "snippet": "static inline int check_new_page(struct page *page)\n{\n\tif (likely(page_expected_state(page,\n\t\t\t\tPAGE_FLAGS_CHECK_AT_PREP|__PG_HWPOISON)))\n\t\treturn 0;\n\n\tcheck_new_page_bad(page);\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline int check_new_page(struct page *page)\n{\n\tif (likely(page_expected_state(page,\n\t\t\t\tPAGE_FLAGS_CHECK_AT_PREP|__PG_HWPOISON)))\n\t\treturn 0;\n\n\tcheck_new_page_bad(page);\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool check_pcp_refill(struct page *page)\n{\n\treturn check_new_page(page);\n}"
  },
  {
    "function_name": "check_new_pcp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "1880-1883",
    "snippet": "static bool check_new_pcp(struct page *page)\n{\n\treturn check_new_page(page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_new_page",
          "args": [
            "page"
          ],
          "line": 1882
        },
        "resolved": true,
        "details": {
          "function_name": "check_new_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1858-1866",
          "snippet": "static inline int check_new_page(struct page *page)\n{\n\tif (likely(page_expected_state(page,\n\t\t\t\tPAGE_FLAGS_CHECK_AT_PREP|__PG_HWPOISON)))\n\t\treturn 0;\n\n\tcheck_new_page_bad(page);\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline int check_new_page(struct page *page)\n{\n\tif (likely(page_expected_state(page,\n\t\t\t\tPAGE_FLAGS_CHECK_AT_PREP|__PG_HWPOISON)))\n\t\treturn 0;\n\n\tcheck_new_page_bad(page);\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool check_new_pcp(struct page *page)\n{\n\treturn check_new_page(page);\n}"
  },
  {
    "function_name": "check_pcp_refill",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "1875-1878",
    "snippet": "static bool check_pcp_refill(struct page *page)\n{\n\treturn false;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool check_pcp_refill(struct page *page)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "free_pages_prezeroed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "1868-1872",
    "snippet": "static inline bool free_pages_prezeroed(void)\n{\n\treturn IS_ENABLED(CONFIG_PAGE_POISONING_ZERO) &&\n\t\tpage_poisoning_enabled();\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_poisoning_enabled",
          "args": [],
          "line": 1871
        },
        "resolved": true,
        "details": {
          "function_name": "page_poisoning_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_poison.c",
          "lines": "25-36",
          "snippet": "bool page_poisoning_enabled(void)\n{\n\t/*\n\t * Assumes that debug_pagealloc_enabled is set before\n\t * memblock_free_all.\n\t * Page poisoning is debug page alloc for some arches. If\n\t * either of those options are enabled, enable poisoning.\n\t */\n\treturn (want_page_poisoning ||\n\t\t(!IS_ENABLED(CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC) &&\n\t\tdebug_pagealloc_enabled()));\n}",
          "includes": [
            "#include <linux/ratelimit.h>",
            "#include <linux/poison.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool want_page_poisoning"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ratelimit.h>\n#include <linux/poison.h>\n#include <linux/page_ext.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic bool want_page_poisoning;\n\nbool page_poisoning_enabled(void)\n{\n\t/*\n\t * Assumes that debug_pagealloc_enabled is set before\n\t * memblock_free_all.\n\t * Page poisoning is debug page alloc for some arches. If\n\t * either of those options are enabled, enable poisoning.\n\t */\n\treturn (want_page_poisoning ||\n\t\t(!IS_ENABLED(CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC) &&\n\t\tdebug_pagealloc_enabled()));\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PAGE_POISONING_ZERO"
          ],
          "line": 1870
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic inline bool free_pages_prezeroed(void)\n{\n\treturn IS_ENABLED(CONFIG_PAGE_POISONING_ZERO) &&\n\t\tpage_poisoning_enabled();\n}"
  },
  {
    "function_name": "check_new_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "1858-1866",
    "snippet": "static inline int check_new_page(struct page *page)\n{\n\tif (likely(page_expected_state(page,\n\t\t\t\tPAGE_FLAGS_CHECK_AT_PREP|__PG_HWPOISON)))\n\t\treturn 0;\n\n\tcheck_new_page_bad(page);\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_new_page_bad",
          "args": [
            "page"
          ],
          "line": 1864
        },
        "resolved": true,
        "details": {
          "function_name": "check_new_page_bad",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1826-1853",
          "snippet": "static void check_new_page_bad(struct page *page)\n{\n\tconst char *bad_reason = NULL;\n\tunsigned long bad_flags = 0;\n\n\tif (unlikely(atomic_read(&page->_mapcount) != -1))\n\t\tbad_reason = \"nonzero mapcount\";\n\tif (unlikely(page->mapping != NULL))\n\t\tbad_reason = \"non-NULL mapping\";\n\tif (unlikely(page_ref_count(page) != 0))\n\t\tbad_reason = \"nonzero _count\";\n\tif (unlikely(page->flags & __PG_HWPOISON)) {\n\t\tbad_reason = \"HWPoisoned (hardware-corrupted)\";\n\t\tbad_flags = __PG_HWPOISON;\n\t\t/* Don't complain about hwpoisoned pages */\n\t\tpage_mapcount_reset(page); /* remove PageBuddy */\n\t\treturn;\n\t}\n\tif (unlikely(page->flags & PAGE_FLAGS_CHECK_AT_PREP)) {\n\t\tbad_reason = \"PAGE_FLAGS_CHECK_AT_PREP flag set\";\n\t\tbad_flags = PAGE_FLAGS_CHECK_AT_PREP;\n\t}\n#ifdef CONFIG_MEMCG\n\tif (unlikely(page->mem_cgroup))\n\t\tbad_reason = \"page still charged to cgroup\";\n#endif\n\tbad_page(page, bad_reason, bad_flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic void check_new_page_bad(struct page *page)\n{\n\tconst char *bad_reason = NULL;\n\tunsigned long bad_flags = 0;\n\n\tif (unlikely(atomic_read(&page->_mapcount) != -1))\n\t\tbad_reason = \"nonzero mapcount\";\n\tif (unlikely(page->mapping != NULL))\n\t\tbad_reason = \"non-NULL mapping\";\n\tif (unlikely(page_ref_count(page) != 0))\n\t\tbad_reason = \"nonzero _count\";\n\tif (unlikely(page->flags & __PG_HWPOISON)) {\n\t\tbad_reason = \"HWPoisoned (hardware-corrupted)\";\n\t\tbad_flags = __PG_HWPOISON;\n\t\t/* Don't complain about hwpoisoned pages */\n\t\tpage_mapcount_reset(page); /* remove PageBuddy */\n\t\treturn;\n\t}\n\tif (unlikely(page->flags & PAGE_FLAGS_CHECK_AT_PREP)) {\n\t\tbad_reason = \"PAGE_FLAGS_CHECK_AT_PREP flag set\";\n\t\tbad_flags = PAGE_FLAGS_CHECK_AT_PREP;\n\t}\n#ifdef CONFIG_MEMCG\n\tif (unlikely(page->mem_cgroup))\n\t\tbad_reason = \"page still charged to cgroup\";\n#endif\n\tbad_page(page, bad_reason, bad_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "page_expected_state(page,\n\t\t\t\tPAGE_FLAGS_CHECK_AT_PREP|__PG_HWPOISON)"
          ],
          "line": 1860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_expected_state",
          "args": [
            "page",
            "PAGE_FLAGS_CHECK_AT_PREP|__PG_HWPOISON"
          ],
          "line": 1860
        },
        "resolved": true,
        "details": {
          "function_name": "page_expected_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "885-900",
          "snippet": "static inline bool page_expected_state(struct page *page,\n\t\t\t\t\tunsigned long check_flags)\n{\n\tif (unlikely(atomic_read(&page->_mapcount) != -1))\n\t\treturn false;\n\n\tif (unlikely((unsigned long)page->mapping |\n\t\t\tpage_ref_count(page) |\n#ifdef CONFIG_MEMCG\n\t\t\t(unsigned long)page->mem_cgroup |\n#endif\n\t\t\t(page->flags & check_flags)))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline bool page_expected_state(struct page *page,\n\t\t\t\t\tunsigned long check_flags)\n{\n\tif (unlikely(atomic_read(&page->_mapcount) != -1))\n\t\treturn false;\n\n\tif (unlikely((unsigned long)page->mapping |\n\t\t\tpage_ref_count(page) |\n#ifdef CONFIG_MEMCG\n\t\t\t(unsigned long)page->mem_cgroup |\n#endif\n\t\t\t(page->flags & check_flags)))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline int check_new_page(struct page *page)\n{\n\tif (likely(page_expected_state(page,\n\t\t\t\tPAGE_FLAGS_CHECK_AT_PREP|__PG_HWPOISON)))\n\t\treturn 0;\n\n\tcheck_new_page_bad(page);\n\treturn 1;\n}"
  },
  {
    "function_name": "check_new_page_bad",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "1826-1853",
    "snippet": "static void check_new_page_bad(struct page *page)\n{\n\tconst char *bad_reason = NULL;\n\tunsigned long bad_flags = 0;\n\n\tif (unlikely(atomic_read(&page->_mapcount) != -1))\n\t\tbad_reason = \"nonzero mapcount\";\n\tif (unlikely(page->mapping != NULL))\n\t\tbad_reason = \"non-NULL mapping\";\n\tif (unlikely(page_ref_count(page) != 0))\n\t\tbad_reason = \"nonzero _count\";\n\tif (unlikely(page->flags & __PG_HWPOISON)) {\n\t\tbad_reason = \"HWPoisoned (hardware-corrupted)\";\n\t\tbad_flags = __PG_HWPOISON;\n\t\t/* Don't complain about hwpoisoned pages */\n\t\tpage_mapcount_reset(page); /* remove PageBuddy */\n\t\treturn;\n\t}\n\tif (unlikely(page->flags & PAGE_FLAGS_CHECK_AT_PREP)) {\n\t\tbad_reason = \"PAGE_FLAGS_CHECK_AT_PREP flag set\";\n\t\tbad_flags = PAGE_FLAGS_CHECK_AT_PREP;\n\t}\n#ifdef CONFIG_MEMCG\n\tif (unlikely(page->mem_cgroup))\n\t\tbad_reason = \"page still charged to cgroup\";\n#endif\n\tbad_page(page, bad_reason, bad_flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bad_page",
          "args": [
            "page",
            "bad_reason",
            "bad_flags"
          ],
          "line": 1852
        },
        "resolved": true,
        "details": {
          "function_name": "bad_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "512-554",
          "snippet": "static void bad_page(struct page *page, const char *reason,\n\t\tunsigned long bad_flags)\n{\n\tstatic unsigned long resume;\n\tstatic unsigned long nr_shown;\n\tstatic unsigned long nr_unshown;\n\n\t/*\n\t * Allow a burst of 60 reports, then keep quiet for that minute;\n\t * or allow a steady drip of one report per second.\n\t */\n\tif (nr_shown == 60) {\n\t\tif (time_before(jiffies, resume)) {\n\t\t\tnr_unshown++;\n\t\t\tgoto out;\n\t\t}\n\t\tif (nr_unshown) {\n\t\t\tpr_alert(\n\t\t\t      \"BUG: Bad page state: %lu messages suppressed\\n\",\n\t\t\t\tnr_unshown);\n\t\t\tnr_unshown = 0;\n\t\t}\n\t\tnr_shown = 0;\n\t}\n\tif (nr_shown++ == 0)\n\t\tresume = jiffies + 60 * HZ;\n\n\tpr_alert(\"BUG: Bad page state in process %s  pfn:%05lx\\n\",\n\t\tcurrent->comm, page_to_pfn(page));\n\t__dump_page(page, reason);\n\tbad_flags &= page->flags;\n\tif (bad_flags)\n\t\tpr_alert(\"bad because of flags: %#lx(%pGp)\\n\",\n\t\t\t\t\t\tbad_flags, &bad_flags);\n\tdump_page_owner(page);\n\n\tprint_modules();\n\tdump_stack();\nout:\n\t/* Leave bad fields for debug, except PageBuddy could make trouble */\n\tpage_mapcount_reset(page); /* remove PageBuddy */\n\tadd_taint(TAINT_BAD_PAGE, LOCKDEP_NOW_UNRELIABLE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic void bad_page(struct page *page, const char *reason,\n\t\tunsigned long bad_flags)\n{\n\tstatic unsigned long resume;\n\tstatic unsigned long nr_shown;\n\tstatic unsigned long nr_unshown;\n\n\t/*\n\t * Allow a burst of 60 reports, then keep quiet for that minute;\n\t * or allow a steady drip of one report per second.\n\t */\n\tif (nr_shown == 60) {\n\t\tif (time_before(jiffies, resume)) {\n\t\t\tnr_unshown++;\n\t\t\tgoto out;\n\t\t}\n\t\tif (nr_unshown) {\n\t\t\tpr_alert(\n\t\t\t      \"BUG: Bad page state: %lu messages suppressed\\n\",\n\t\t\t\tnr_unshown);\n\t\t\tnr_unshown = 0;\n\t\t}\n\t\tnr_shown = 0;\n\t}\n\tif (nr_shown++ == 0)\n\t\tresume = jiffies + 60 * HZ;\n\n\tpr_alert(\"BUG: Bad page state in process %s  pfn:%05lx\\n\",\n\t\tcurrent->comm, page_to_pfn(page));\n\t__dump_page(page, reason);\n\tbad_flags &= page->flags;\n\tif (bad_flags)\n\t\tpr_alert(\"bad because of flags: %#lx(%pGp)\\n\",\n\t\t\t\t\t\tbad_flags, &bad_flags);\n\tdump_page_owner(page);\n\n\tprint_modules();\n\tdump_stack();\nout:\n\t/* Leave bad fields for debug, except PageBuddy could make trouble */\n\tpage_mapcount_reset(page); /* remove PageBuddy */\n\tadd_taint(TAINT_BAD_PAGE, LOCKDEP_NOW_UNRELIABLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "page->mem_cgroup"
          ],
          "line": 1849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "page->flags & PAGE_FLAGS_CHECK_AT_PREP"
          ],
          "line": 1844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapcount_reset",
          "args": [
            "page"
          ],
          "line": 1841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "page->flags & __PG_HWPOISON"
          ],
          "line": 1837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "page_ref_count(page) != 0"
          ],
          "line": 1835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_ref_count",
          "args": [
            "page"
          ],
          "line": 1835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "page->mapping != NULL"
          ],
          "line": 1833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "atomic_read(&page->_mapcount) != -1"
          ],
          "line": 1831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&page->_mapcount"
          ],
          "line": 1831
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic void check_new_page_bad(struct page *page)\n{\n\tconst char *bad_reason = NULL;\n\tunsigned long bad_flags = 0;\n\n\tif (unlikely(atomic_read(&page->_mapcount) != -1))\n\t\tbad_reason = \"nonzero mapcount\";\n\tif (unlikely(page->mapping != NULL))\n\t\tbad_reason = \"non-NULL mapping\";\n\tif (unlikely(page_ref_count(page) != 0))\n\t\tbad_reason = \"nonzero _count\";\n\tif (unlikely(page->flags & __PG_HWPOISON)) {\n\t\tbad_reason = \"HWPoisoned (hardware-corrupted)\";\n\t\tbad_flags = __PG_HWPOISON;\n\t\t/* Don't complain about hwpoisoned pages */\n\t\tpage_mapcount_reset(page); /* remove PageBuddy */\n\t\treturn;\n\t}\n\tif (unlikely(page->flags & PAGE_FLAGS_CHECK_AT_PREP)) {\n\t\tbad_reason = \"PAGE_FLAGS_CHECK_AT_PREP flag set\";\n\t\tbad_flags = PAGE_FLAGS_CHECK_AT_PREP;\n\t}\n#ifdef CONFIG_MEMCG\n\tif (unlikely(page->mem_cgroup))\n\t\tbad_reason = \"page still charged to cgroup\";\n#endif\n\tbad_page(page, bad_reason, bad_flags);\n}"
  },
  {
    "function_name": "expand",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "1799-1824",
    "snippet": "static inline void expand(struct zone *zone, struct page *page,\n\tint low, int high, struct free_area *area,\n\tint migratetype)\n{\n\tunsigned long size = 1 << high;\n\n\twhile (high > low) {\n\t\tarea--;\n\t\thigh--;\n\t\tsize >>= 1;\n\t\tVM_BUG_ON_PAGE(bad_range(zone, &page[size]), &page[size]);\n\n\t\t/*\n\t\t * Mark as guard pages (or page), that will allow to\n\t\t * merge back to allocator when buddy will be freed.\n\t\t * Corresponding page table entries will not be touched,\n\t\t * pages will stay not present in virtual address space\n\t\t */\n\t\tif (set_page_guard(zone, &page[size], high, migratetype))\n\t\t\tcontinue;\n\n\t\tlist_add(&page[size].lru, &area->free_list[migratetype]);\n\t\tarea->nr_free++;\n\t\tset_page_order(&page[size], high);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_page_order",
          "args": [
            "&page[size]",
            "high"
          ],
          "line": 1822
        },
        "resolved": true,
        "details": {
          "function_name": "set_page_order",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "701-705",
          "snippet": "static inline void set_page_order(struct page *page, unsigned int order)\n{\n\tset_page_private(page, order);\n\t__SetPageBuddy(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline void set_page_order(struct page *page, unsigned int order)\n{\n\tset_page_private(page, order);\n\t__SetPageBuddy(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&page[size].lru",
            "&area->free_list[migratetype]"
          ],
          "line": 1820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_guard",
          "args": [
            "zone",
            "&page[size]",
            "high",
            "migratetype"
          ],
          "line": 1817
        },
        "resolved": true,
        "details": {
          "function_name": "set_page_guard",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "695-696",
          "snippet": "static inline bool set_page_guard(struct zone *zone, struct page *page,\n\t\t\tunsigned int order, int migratetype) { return false; }",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline bool set_page_guard(struct zone *zone, struct page *page,\n\t\t\tunsigned int order, int migratetype) { return false; }"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "bad_range(zone, &page[size])",
            "&page[size]"
          ],
          "line": 1809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bad_range",
          "args": [
            "zone",
            "&page[size]"
          ],
          "line": 1809
        },
        "resolved": true,
        "details": {
          "function_name": "bad_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "506-509",
          "snippet": "static inline int __maybe_unused bad_range(struct zone *zone, struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline int __maybe_unused bad_range(struct zone *zone, struct page *page)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline void expand(struct zone *zone, struct page *page,\n\tint low, int high, struct free_area *area,\n\tint migratetype)\n{\n\tunsigned long size = 1 << high;\n\n\twhile (high > low) {\n\t\tarea--;\n\t\thigh--;\n\t\tsize >>= 1;\n\t\tVM_BUG_ON_PAGE(bad_range(zone, &page[size]), &page[size]);\n\n\t\t/*\n\t\t * Mark as guard pages (or page), that will allow to\n\t\t * merge back to allocator when buddy will be freed.\n\t\t * Corresponding page table entries will not be touched,\n\t\t * pages will stay not present in virtual address space\n\t\t */\n\t\tif (set_page_guard(zone, &page[size], high, migratetype))\n\t\t\tcontinue;\n\n\t\tlist_add(&page[size].lru, &area->free_list[migratetype]);\n\t\tarea->nr_free++;\n\t\tset_page_order(&page[size], high);\n\t}\n}"
  },
  {
    "function_name": "init_cma_reserved_pageblock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "1756-1782",
    "snippet": "void __init init_cma_reserved_pageblock(struct page *page)\n{\n\tunsigned i = pageblock_nr_pages;\n\tstruct page *p = page;\n\n\tdo {\n\t\t__ClearPageReserved(p);\n\t\tset_page_count(p, 0);\n\t} while (++p, --i);\n\n\tset_pageblock_migratetype(page, MIGRATE_CMA);\n\n\tif (pageblock_order >= MAX_ORDER) {\n\t\ti = pageblock_nr_pages;\n\t\tp = page;\n\t\tdo {\n\t\t\tset_page_refcounted(p);\n\t\t\t__free_pages(p, MAX_ORDER - 1);\n\t\t\tp += MAX_ORDER_NR_PAGES;\n\t\t} while (i -= MAX_ORDER_NR_PAGES);\n\t} else {\n\t\tset_page_refcounted(page);\n\t\t__free_pages(page, pageblock_order);\n\t}\n\n\tadjust_managed_page_count(page, pageblock_nr_pages);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "adjust_managed_page_count",
          "args": [
            "page",
            "pageblock_nr_pages"
          ],
          "line": 1781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_pages",
          "args": [
            "page",
            "pageblock_order"
          ],
          "line": 1778
        },
        "resolved": true,
        "details": {
          "function_name": "__free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4430-4438",
          "snippet": "void __free_pages(struct page *page, unsigned int order)\n{\n\tif (put_page_testzero(page)) {\n\t\tif (order == 0)\n\t\t\tfree_unref_page(page);\n\t\telse\n\t\t\t__free_pages_ok(page, order);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid __free_pages(struct page *page, unsigned int order)\n{\n\tif (put_page_testzero(page)) {\n\t\tif (order == 0)\n\t\t\tfree_unref_page(page);\n\t\telse\n\t\t\t__free_pages_ok(page, order);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_refcounted",
          "args": [
            "page"
          ],
          "line": 1777
        },
        "resolved": true,
        "details": {
          "function_name": "set_page_refcounted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "74-79",
          "snippet": "static inline void set_page_refcounted(struct page *page)\n{\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\tVM_BUG_ON_PAGE(page_ref_count(page), page);\n\tset_page_count(page, 1);\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void set_page_refcounted(struct page *page)\n{\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\tVM_BUG_ON_PAGE(page_ref_count(page), page);\n\tset_page_count(page, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_pageblock_migratetype",
          "args": [
            "page",
            "MIGRATE_CMA"
          ],
          "line": 1766
        },
        "resolved": true,
        "details": {
          "function_name": "set_pageblock_migratetype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "450-458",
          "snippet": "void set_pageblock_migratetype(struct page *page, int migratetype)\n{\n\tif (unlikely(page_group_by_mobility_disabled &&\n\t\t     migratetype < MIGRATE_PCPTYPES))\n\t\tmigratetype = MIGRATE_UNMOVABLE;\n\n\tset_pageblock_flags_group(page, (unsigned long)migratetype,\n\t\t\t\t\tPB_migrate, PB_migrate_end);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int page_group_by_mobility_disabled",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nint page_group_by_mobility_disabled;\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid set_pageblock_migratetype(struct page *page, int migratetype)\n{\n\tif (unlikely(page_group_by_mobility_disabled &&\n\t\t     migratetype < MIGRATE_PCPTYPES))\n\t\tmigratetype = MIGRATE_UNMOVABLE;\n\n\tset_pageblock_flags_group(page, (unsigned long)migratetype,\n\t\t\t\t\tPB_migrate, PB_migrate_end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_count",
          "args": [
            "p",
            "0"
          ],
          "line": 1763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ClearPageReserved",
          "args": [
            "p"
          ],
          "line": 1762
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid __init init_cma_reserved_pageblock(struct page *page)\n{\n\tunsigned i = pageblock_nr_pages;\n\tstruct page *p = page;\n\n\tdo {\n\t\t__ClearPageReserved(p);\n\t\tset_page_count(p, 0);\n\t} while (++p, --i);\n\n\tset_pageblock_migratetype(page, MIGRATE_CMA);\n\n\tif (pageblock_order >= MAX_ORDER) {\n\t\ti = pageblock_nr_pages;\n\t\tp = page;\n\t\tdo {\n\t\t\tset_page_refcounted(p);\n\t\t\t__free_pages(p, MAX_ORDER - 1);\n\t\t\tp += MAX_ORDER_NR_PAGES;\n\t\t} while (i -= MAX_ORDER_NR_PAGES);\n\t} else {\n\t\tset_page_refcounted(page);\n\t\t__free_pages(page, pageblock_order);\n\t}\n\n\tadjust_managed_page_count(page, pageblock_nr_pages);\n}"
  },
  {
    "function_name": "page_alloc_init_late",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "1720-1752",
    "snippet": "void __init page_alloc_init_late(void)\n{\n\tstruct zone *zone;\n\n#ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT\n\tint nid;\n\n\t/* There will be num_node_state(N_MEMORY) threads */\n\tatomic_set(&pgdat_init_n_undone, num_node_state(N_MEMORY));\n\tfor_each_node_state(nid, N_MEMORY) {\n\t\tkthread_run(deferred_init_memmap, NODE_DATA(nid), \"pgdatinit%d\", nid);\n\t}\n\n\t/* Block until all are initialised */\n\twait_for_completion(&pgdat_init_all_done_comp);\n\n\t/*\n\t * We initialized the rest of the deferred pages.  Permanently disable\n\t * on-demand struct page initialization.\n\t */\n\tstatic_branch_disable(&deferred_pages);\n\n\t/* Reinit limits that are based on free pages after the kernel is up */\n\tfiles_maxfiles_init();\n#endif\n#ifdef CONFIG_ARCH_DISCARD_MEMBLOCK\n\t/* Discard memblock private memory */\n\tmemblock_discard();\n#endif\n\n\tfor_each_populated_zone(zone)\n\t\tset_zone_contiguous(zone);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_discard",
          "args": [],
          "line": 1747
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_discard",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "363-380",
          "snippet": "void __init memblock_discard(void)\n{\n\tphys_addr_t addr, size;\n\n\tif (memblock.reserved.regions != memblock_reserved_init_regions) {\n\t\taddr = __pa(memblock.reserved.regions);\n\t\tsize = PAGE_ALIGN(sizeof(struct memblock_region) *\n\t\t\t\t  memblock.reserved.max);\n\t\t__memblock_free_late(addr, size);\n\t}\n\n\tif (memblock.memory.regions != memblock_memory_init_regions) {\n\t\taddr = __pa(memblock.memory.regions);\n\t\tsize = PAGE_ALIGN(sizeof(struct memblock_region) *\n\t\t\t\t  memblock.memory.max);\n\t\t__memblock_free_late(addr, size);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct memblock_region memblock_memory_init_regions[INIT_MEMBLOCK_REGIONS]",
            "static struct memblock_region memblock_reserved_init_regions[INIT_MEMBLOCK_REGIONS]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct memblock_region memblock_memory_init_regions[INIT_MEMBLOCK_REGIONS];\nstatic struct memblock_region memblock_reserved_init_regions[INIT_MEMBLOCK_REGIONS];\n\nvoid __init memblock_discard(void)\n{\n\tphys_addr_t addr, size;\n\n\tif (memblock.reserved.regions != memblock_reserved_init_regions) {\n\t\taddr = __pa(memblock.reserved.regions);\n\t\tsize = PAGE_ALIGN(sizeof(struct memblock_region) *\n\t\t\t\t  memblock.reserved.max);\n\t\t__memblock_free_late(addr, size);\n\t}\n\n\tif (memblock.memory.regions != memblock_memory_init_regions) {\n\t\taddr = __pa(memblock.memory.regions);\n\t\tsize = PAGE_ALIGN(sizeof(struct memblock_region) *\n\t\t\t\t  memblock.memory.max);\n\t\t__memblock_free_late(addr, size);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "files_maxfiles_init",
          "args": [],
          "line": 1743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_disable",
          "args": [
            "&deferred_pages"
          ],
          "line": 1740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&pgdat_init_all_done_comp"
          ],
          "line": 1734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "deferred_init_memmap",
            "NODE_DATA(nid)",
            "\"pgdatinit%d\"",
            "nid"
          ],
          "line": 1730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "nid"
          ],
          "line": 1730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_node_state",
          "args": [
            "nid",
            "N_MEMORY"
          ],
          "line": 1729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&pgdat_init_n_undone",
            "num_node_state(N_MEMORY)"
          ],
          "line": 1728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_node_state",
          "args": [
            "N_MEMORY"
          ],
          "line": 1728
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid __init page_alloc_init_late(void)\n{\n\tstruct zone *zone;\n\n#ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT\n\tint nid;\n\n\t/* There will be num_node_state(N_MEMORY) threads */\n\tatomic_set(&pgdat_init_n_undone, num_node_state(N_MEMORY));\n\tfor_each_node_state(nid, N_MEMORY) {\n\t\tkthread_run(deferred_init_memmap, NODE_DATA(nid), \"pgdatinit%d\", nid);\n\t}\n\n\t/* Block until all are initialised */\n\twait_for_completion(&pgdat_init_all_done_comp);\n\n\t/*\n\t * We initialized the rest of the deferred pages.  Permanently disable\n\t * on-demand struct page initialization.\n\t */\n\tstatic_branch_disable(&deferred_pages);\n\n\t/* Reinit limits that are based on free pages after the kernel is up */\n\tfiles_maxfiles_init();\n#endif\n#ifdef CONFIG_ARCH_DISCARD_MEMBLOCK\n\t/* Discard memblock private memory */\n\tmemblock_discard();\n#endif\n\n\tfor_each_populated_zone(zone)\n\t\tset_zone_contiguous(zone);\n}"
  },
  {
    "function_name": "_deferred_grow_zone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "1712-1716",
    "snippet": "static bool __ref\n_deferred_grow_zone(struct zone *zone, unsigned int order)\n{\n\treturn deferred_grow_zone(zone, order);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);",
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "deferred_grow_zone",
          "args": [
            "zone",
            "order"
          ],
          "line": 1715
        },
        "resolved": true,
        "details": {
          "function_name": "_deferred_grow_zone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1712-1716",
          "snippet": "static bool __ref\n_deferred_grow_zone(struct zone *zone, unsigned int order)\n{\n\treturn deferred_grow_zone(zone, order);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool __ref\n_deferred_grow_zone(struct zone *zone, unsigned int order)\n{\n\treturn deferred_grow_zone(zone, order);\n}"
  },
  {
    "function_name": "deferred_grow_zone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "1630-1704",
    "snippet": "__init\ndeferred_grow_zone(struct zone *zone, unsigned int order)\n{\n\tint zid = zone_idx(zone);\n\tint nid = zone_to_nid(zone);\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\tunsigned long nr_pages_needed = ALIGN(1 << order, PAGES_PER_SECTION);\n\tunsigned long nr_pages = 0;\n\tunsigned long first_init_pfn, spfn, epfn, t, flags;\n\tunsigned long first_deferred_pfn = pgdat->first_deferred_pfn;\n\tphys_addr_t spa, epa;\n\tu64 i;\n\n\t/* Only the last zone may have deferred pages */\n\tif (zone_end_pfn(zone) != pgdat_end_pfn(pgdat))\n\t\treturn false;\n\n\tpgdat_resize_lock(pgdat, &flags);\n\n\t/*\n\t * If deferred pages have been initialized while we were waiting for\n\t * the lock, return true, as the zone was grown.  The caller will retry\n\t * this zone.  We won't return to this function since the caller also\n\t * has this static branch.\n\t */\n\tif (!static_branch_unlikely(&deferred_pages)) {\n\t\tpgdat_resize_unlock(pgdat, &flags);\n\t\treturn true;\n\t}\n\n\t/*\n\t * If someone grew this zone while we were waiting for spinlock, return\n\t * true, as there might be enough pages already.\n\t */\n\tif (first_deferred_pfn != pgdat->first_deferred_pfn) {\n\t\tpgdat_resize_unlock(pgdat, &flags);\n\t\treturn true;\n\t}\n\n\tfirst_init_pfn = max(zone->zone_start_pfn, first_deferred_pfn);\n\n\tif (first_init_pfn >= pgdat_end_pfn(pgdat)) {\n\t\tpgdat_resize_unlock(pgdat, &flags);\n\t\treturn false;\n\t}\n\n\tfor_each_free_mem_range(i, nid, MEMBLOCK_NONE, &spa, &epa, NULL) {\n\t\tspfn = max_t(unsigned long, first_init_pfn, PFN_UP(spa));\n\t\tepfn = min_t(unsigned long, zone_end_pfn(zone), PFN_DOWN(epa));\n\n\t\twhile (spfn < epfn && nr_pages < nr_pages_needed) {\n\t\t\tt = ALIGN(spfn + PAGES_PER_SECTION, PAGES_PER_SECTION);\n\t\t\tfirst_deferred_pfn = min(t, epfn);\n\t\t\tnr_pages += deferred_init_pages(nid, zid, spfn,\n\t\t\t\t\t\t\tfirst_deferred_pfn);\n\t\t\tspfn = first_deferred_pfn;\n\t\t}\n\n\t\tif (nr_pages >= nr_pages_needed)\n\t\t\tbreak;\n\t}\n\n\tfor_each_free_mem_range(i, nid, MEMBLOCK_NONE, &spa, &epa, NULL) {\n\t\tspfn = max_t(unsigned long, first_init_pfn, PFN_UP(spa));\n\t\tepfn = min_t(unsigned long, first_deferred_pfn, PFN_DOWN(epa));\n\t\tdeferred_free_pages(nid, zid, spfn, epfn);\n\n\t\tif (first_deferred_pfn == epfn)\n\t\t\tbreak;\n\t}\n\tpgdat->first_deferred_pfn = first_deferred_pfn;\n\tpgdat_resize_unlock(pgdat, &flags);\n\n\treturn nr_pages > 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);",
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pgdat_resize_unlock",
          "args": [
            "pgdat",
            "&flags"
          ],
          "line": 1701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deferred_free_pages",
          "args": [
            "nid",
            "zid",
            "spfn",
            "epfn"
          ],
          "line": 1695
        },
        "resolved": true,
        "details": {
          "function_name": "deferred_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1488-1509",
          "snippet": "static void __init deferred_free_pages(int nid, int zid, unsigned long pfn,\n\t\t\t\t       unsigned long end_pfn)\n{\n\tstruct mminit_pfnnid_cache nid_init_state = { };\n\tunsigned long nr_pgmask = pageblock_nr_pages - 1;\n\tunsigned long nr_free = 0;\n\n\tfor (; pfn < end_pfn; pfn++) {\n\t\tif (!deferred_pfn_valid(nid, pfn, &nid_init_state)) {\n\t\t\tdeferred_free_range(pfn - nr_free, nr_free);\n\t\t\tnr_free = 0;\n\t\t} else if (!(pfn & nr_pgmask)) {\n\t\t\tdeferred_free_range(pfn - nr_free, nr_free);\n\t\t\tnr_free = 1;\n\t\t\ttouch_nmi_watchdog();\n\t\t} else {\n\t\t\tnr_free++;\n\t\t}\n\t}\n\t/* Free the last block of pages to allocator */\n\tdeferred_free_range(pfn - nr_free, nr_free);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic void __init deferred_free_pages(int nid, int zid, unsigned long pfn,\n\t\t\t\t       unsigned long end_pfn)\n{\n\tstruct mminit_pfnnid_cache nid_init_state = { };\n\tunsigned long nr_pgmask = pageblock_nr_pages - 1;\n\tunsigned long nr_free = 0;\n\n\tfor (; pfn < end_pfn; pfn++) {\n\t\tif (!deferred_pfn_valid(nid, pfn, &nid_init_state)) {\n\t\t\tdeferred_free_range(pfn - nr_free, nr_free);\n\t\t\tnr_free = 0;\n\t\t} else if (!(pfn & nr_pgmask)) {\n\t\t\tdeferred_free_range(pfn - nr_free, nr_free);\n\t\t\tnr_free = 1;\n\t\t\ttouch_nmi_watchdog();\n\t\t} else {\n\t\t\tnr_free++;\n\t\t}\n\t}\n\t/* Free the last block of pages to allocator */\n\tdeferred_free_range(pfn - nr_free, nr_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedlong",
            "first_deferred_pfn",
            "PFN_DOWN(epa)"
          ],
          "line": 1694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_DOWN",
          "args": [
            "epa"
          ],
          "line": 1694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "unsignedlong",
            "first_init_pfn",
            "PFN_UP(spa)"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_UP",
          "args": [
            "spa"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_free_mem_range",
          "args": [
            "i",
            "nid",
            "MEMBLOCK_NONE",
            "&spa",
            "&epa",
            "NULL"
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deferred_init_pages",
          "args": [
            "nid",
            "zid",
            "spfn",
            "first_deferred_pfn"
          ],
          "line": 1683
        },
        "resolved": true,
        "details": {
          "function_name": "deferred_init_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1516-1539",
          "snippet": "static unsigned long  __init deferred_init_pages(int nid, int zid,\n\t\t\t\t\t\t unsigned long pfn,\n\t\t\t\t\t\t unsigned long end_pfn)\n{\n\tstruct mminit_pfnnid_cache nid_init_state = { };\n\tunsigned long nr_pgmask = pageblock_nr_pages - 1;\n\tunsigned long nr_pages = 0;\n\tstruct page *page = NULL;\n\n\tfor (; pfn < end_pfn; pfn++) {\n\t\tif (!deferred_pfn_valid(nid, pfn, &nid_init_state)) {\n\t\t\tpage = NULL;\n\t\t\tcontinue;\n\t\t} else if (!page || !(pfn & nr_pgmask)) {\n\t\t\tpage = pfn_to_page(pfn);\n\t\t\ttouch_nmi_watchdog();\n\t\t} else {\n\t\t\tpage++;\n\t\t}\n\t\t__init_single_page(page, pfn, zid, nid);\n\t\tnr_pages++;\n\t}\n\treturn (nr_pages);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic unsigned long  __init deferred_init_pages(int nid, int zid,\n\t\t\t\t\t\t unsigned long pfn,\n\t\t\t\t\t\t unsigned long end_pfn)\n{\n\tstruct mminit_pfnnid_cache nid_init_state = { };\n\tunsigned long nr_pgmask = pageblock_nr_pages - 1;\n\tunsigned long nr_pages = 0;\n\tstruct page *page = NULL;\n\n\tfor (; pfn < end_pfn; pfn++) {\n\t\tif (!deferred_pfn_valid(nid, pfn, &nid_init_state)) {\n\t\t\tpage = NULL;\n\t\t\tcontinue;\n\t\t} else if (!page || !(pfn & nr_pgmask)) {\n\t\t\tpage = pfn_to_page(pfn);\n\t\t\ttouch_nmi_watchdog();\n\t\t} else {\n\t\t\tpage++;\n\t\t}\n\t\t__init_single_page(page, pfn, zid, nid);\n\t\tnr_pages++;\n\t}\n\treturn (nr_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "t",
            "epfn"
          ],
          "line": 1682
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "spfn + PAGES_PER_SECTION",
            "PAGES_PER_SECTION"
          ],
          "line": 1681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedlong",
            "zone_end_pfn(zone)",
            "PFN_DOWN(epa)"
          ],
          "line": 1678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_DOWN",
          "args": [
            "epa"
          ],
          "line": 1678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_end_pfn",
          "args": [
            "zone"
          ],
          "line": 1678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "unsignedlong",
            "first_init_pfn",
            "PFN_UP(spa)"
          ],
          "line": 1677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_UP",
          "args": [
            "spa"
          ],
          "line": 1677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_free_mem_range",
          "args": [
            "i",
            "nid",
            "MEMBLOCK_NONE",
            "&spa",
            "&epa",
            "NULL"
          ],
          "line": 1676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgdat_resize_unlock",
          "args": [
            "pgdat",
            "&flags"
          ],
          "line": 1672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgdat_end_pfn",
          "args": [
            "pgdat"
          ],
          "line": 1671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "zone->zone_start_pfn",
            "first_deferred_pfn"
          ],
          "line": 1669
        },
        "resolved": true,
        "details": {
          "function_name": "wb_max_pause",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1418-1435",
          "snippet": "static unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_PAUSE\t\tmax(HZ/5, 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define MAX_PAUSE\t\tmax(HZ/5, 1)\n\nstatic unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pgdat_resize_unlock",
          "args": [
            "pgdat",
            "&flags"
          ],
          "line": 1665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgdat_resize_unlock",
          "args": [
            "pgdat",
            "&flags"
          ],
          "line": 1656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_unlikely",
          "args": [
            "&deferred_pages"
          ],
          "line": 1655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgdat_resize_lock",
          "args": [
            "pgdat",
            "&flags"
          ],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgdat_end_pfn",
          "args": [
            "pgdat"
          ],
          "line": 1644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_end_pfn",
          "args": [
            "zone"
          ],
          "line": 1644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "1 << order",
            "PAGES_PER_SECTION"
          ],
          "line": 1636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "nid"
          ],
          "line": 1635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_to_nid",
          "args": [
            "zone"
          ],
          "line": 1634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_idx",
          "args": [
            "zone"
          ],
          "line": 1633
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\n__init\ndeferred_grow_zone(struct zone *zone, unsigned int order)\n{\n\tint zid = zone_idx(zone);\n\tint nid = zone_to_nid(zone);\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\tunsigned long nr_pages_needed = ALIGN(1 << order, PAGES_PER_SECTION);\n\tunsigned long nr_pages = 0;\n\tunsigned long first_init_pfn, spfn, epfn, t, flags;\n\tunsigned long first_deferred_pfn = pgdat->first_deferred_pfn;\n\tphys_addr_t spa, epa;\n\tu64 i;\n\n\t/* Only the last zone may have deferred pages */\n\tif (zone_end_pfn(zone) != pgdat_end_pfn(pgdat))\n\t\treturn false;\n\n\tpgdat_resize_lock(pgdat, &flags);\n\n\t/*\n\t * If deferred pages have been initialized while we were waiting for\n\t * the lock, return true, as the zone was grown.  The caller will retry\n\t * this zone.  We won't return to this function since the caller also\n\t * has this static branch.\n\t */\n\tif (!static_branch_unlikely(&deferred_pages)) {\n\t\tpgdat_resize_unlock(pgdat, &flags);\n\t\treturn true;\n\t}\n\n\t/*\n\t * If someone grew this zone while we were waiting for spinlock, return\n\t * true, as there might be enough pages already.\n\t */\n\tif (first_deferred_pfn != pgdat->first_deferred_pfn) {\n\t\tpgdat_resize_unlock(pgdat, &flags);\n\t\treturn true;\n\t}\n\n\tfirst_init_pfn = max(zone->zone_start_pfn, first_deferred_pfn);\n\n\tif (first_init_pfn >= pgdat_end_pfn(pgdat)) {\n\t\tpgdat_resize_unlock(pgdat, &flags);\n\t\treturn false;\n\t}\n\n\tfor_each_free_mem_range(i, nid, MEMBLOCK_NONE, &spa, &epa, NULL) {\n\t\tspfn = max_t(unsigned long, first_init_pfn, PFN_UP(spa));\n\t\tepfn = min_t(unsigned long, zone_end_pfn(zone), PFN_DOWN(epa));\n\n\t\twhile (spfn < epfn && nr_pages < nr_pages_needed) {\n\t\t\tt = ALIGN(spfn + PAGES_PER_SECTION, PAGES_PER_SECTION);\n\t\t\tfirst_deferred_pfn = min(t, epfn);\n\t\t\tnr_pages += deferred_init_pages(nid, zid, spfn,\n\t\t\t\t\t\t\tfirst_deferred_pfn);\n\t\t\tspfn = first_deferred_pfn;\n\t\t}\n\n\t\tif (nr_pages >= nr_pages_needed)\n\t\t\tbreak;\n\t}\n\n\tfor_each_free_mem_range(i, nid, MEMBLOCK_NONE, &spa, &epa, NULL) {\n\t\tspfn = max_t(unsigned long, first_init_pfn, PFN_UP(spa));\n\t\tepfn = min_t(unsigned long, first_deferred_pfn, PFN_DOWN(epa));\n\t\tdeferred_free_pages(nid, zid, spfn, epfn);\n\n\t\tif (first_deferred_pfn == epfn)\n\t\t\tbreak;\n\t}\n\tpgdat->first_deferred_pfn = first_deferred_pfn;\n\tpgdat_resize_unlock(pgdat, &flags);\n\n\treturn nr_pages > 0;\n}"
  },
  {
    "function_name": "deferred_init_memmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "1542-1606",
    "snippet": "static int __init deferred_init_memmap(void *data)\n{\n\tpg_data_t *pgdat = data;\n\tint nid = pgdat->node_id;\n\tunsigned long start = jiffies;\n\tunsigned long nr_pages = 0;\n\tunsigned long spfn, epfn, first_init_pfn, flags;\n\tphys_addr_t spa, epa;\n\tint zid;\n\tstruct zone *zone;\n\tconst struct cpumask *cpumask = cpumask_of_node(pgdat->node_id);\n\tu64 i;\n\n\t/* Bind memory initialisation thread to a local node if possible */\n\tif (!cpumask_empty(cpumask))\n\t\tset_cpus_allowed_ptr(current, cpumask);\n\n\tpgdat_resize_lock(pgdat, &flags);\n\tfirst_init_pfn = pgdat->first_deferred_pfn;\n\tif (first_init_pfn == ULONG_MAX) {\n\t\tpgdat_resize_unlock(pgdat, &flags);\n\t\tpgdat_init_report_one_done();\n\t\treturn 0;\n\t}\n\n\t/* Sanity check boundaries */\n\tBUG_ON(pgdat->first_deferred_pfn < pgdat->node_start_pfn);\n\tBUG_ON(pgdat->first_deferred_pfn > pgdat_end_pfn(pgdat));\n\tpgdat->first_deferred_pfn = ULONG_MAX;\n\n\t/* Only the highest zone is deferred so find it */\n\tfor (zid = 0; zid < MAX_NR_ZONES; zid++) {\n\t\tzone = pgdat->node_zones + zid;\n\t\tif (first_init_pfn < zone_end_pfn(zone))\n\t\t\tbreak;\n\t}\n\tfirst_init_pfn = max(zone->zone_start_pfn, first_init_pfn);\n\n\t/*\n\t * Initialize and free pages. We do it in two loops: first we initialize\n\t * struct page, than free to buddy allocator, because while we are\n\t * freeing pages we can access pages that are ahead (computing buddy\n\t * page in __free_one_page()).\n\t */\n\tfor_each_free_mem_range(i, nid, MEMBLOCK_NONE, &spa, &epa, NULL) {\n\t\tspfn = max_t(unsigned long, first_init_pfn, PFN_UP(spa));\n\t\tepfn = min_t(unsigned long, zone_end_pfn(zone), PFN_DOWN(epa));\n\t\tnr_pages += deferred_init_pages(nid, zid, spfn, epfn);\n\t}\n\tfor_each_free_mem_range(i, nid, MEMBLOCK_NONE, &spa, &epa, NULL) {\n\t\tspfn = max_t(unsigned long, first_init_pfn, PFN_UP(spa));\n\t\tepfn = min_t(unsigned long, zone_end_pfn(zone), PFN_DOWN(epa));\n\t\tdeferred_free_pages(nid, zid, spfn, epfn);\n\t}\n\tpgdat_resize_unlock(pgdat, &flags);\n\n\t/* Sanity check that the next zone really is unpopulated */\n\tWARN_ON(++zid < MAX_NR_ZONES && populated_zone(++zone));\n\n\tpr_info(\"node %d initialised, %lu pages in %ums\\n\", nid, nr_pages,\n\t\t\t\t\tjiffies_to_msecs(jiffies - start));\n\n\tpgdat_init_report_one_done();\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pgdat_init_report_one_done",
          "args": [],
          "line": 1604
        },
        "resolved": true,
        "details": {
          "function_name": "pgdat_init_report_one_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1451-1455",
          "snippet": "static inline void __init pgdat_init_report_one_done(void)\n{\n\tif (atomic_dec_and_test(&pgdat_init_n_undone))\n\t\tcomplete(&pgdat_init_all_done_comp);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic inline void __init pgdat_init_report_one_done(void)\n{\n\tif (atomic_dec_and_test(&pgdat_init_n_undone))\n\t\tcomplete(&pgdat_init_all_done_comp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"node %d initialised, %lu pages in %ums\\n\"",
            "nid",
            "nr_pages",
            "jiffies_to_msecs(jiffies - start)"
          ],
          "line": 1601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jiffies_to_msecs",
          "args": [
            "jiffies - start"
          ],
          "line": 1602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "++zid < MAX_NR_ZONES && populated_zone(++zone)"
          ],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "populated_zone",
          "args": [
            "++zone"
          ],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgdat_resize_unlock",
          "args": [
            "pgdat",
            "&flags"
          ],
          "line": 1596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deferred_free_pages",
          "args": [
            "nid",
            "zid",
            "spfn",
            "epfn"
          ],
          "line": 1594
        },
        "resolved": true,
        "details": {
          "function_name": "deferred_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1488-1509",
          "snippet": "static void __init deferred_free_pages(int nid, int zid, unsigned long pfn,\n\t\t\t\t       unsigned long end_pfn)\n{\n\tstruct mminit_pfnnid_cache nid_init_state = { };\n\tunsigned long nr_pgmask = pageblock_nr_pages - 1;\n\tunsigned long nr_free = 0;\n\n\tfor (; pfn < end_pfn; pfn++) {\n\t\tif (!deferred_pfn_valid(nid, pfn, &nid_init_state)) {\n\t\t\tdeferred_free_range(pfn - nr_free, nr_free);\n\t\t\tnr_free = 0;\n\t\t} else if (!(pfn & nr_pgmask)) {\n\t\t\tdeferred_free_range(pfn - nr_free, nr_free);\n\t\t\tnr_free = 1;\n\t\t\ttouch_nmi_watchdog();\n\t\t} else {\n\t\t\tnr_free++;\n\t\t}\n\t}\n\t/* Free the last block of pages to allocator */\n\tdeferred_free_range(pfn - nr_free, nr_free);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic void __init deferred_free_pages(int nid, int zid, unsigned long pfn,\n\t\t\t\t       unsigned long end_pfn)\n{\n\tstruct mminit_pfnnid_cache nid_init_state = { };\n\tunsigned long nr_pgmask = pageblock_nr_pages - 1;\n\tunsigned long nr_free = 0;\n\n\tfor (; pfn < end_pfn; pfn++) {\n\t\tif (!deferred_pfn_valid(nid, pfn, &nid_init_state)) {\n\t\t\tdeferred_free_range(pfn - nr_free, nr_free);\n\t\t\tnr_free = 0;\n\t\t} else if (!(pfn & nr_pgmask)) {\n\t\t\tdeferred_free_range(pfn - nr_free, nr_free);\n\t\t\tnr_free = 1;\n\t\t\ttouch_nmi_watchdog();\n\t\t} else {\n\t\t\tnr_free++;\n\t\t}\n\t}\n\t/* Free the last block of pages to allocator */\n\tdeferred_free_range(pfn - nr_free, nr_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedlong",
            "zone_end_pfn(zone)",
            "PFN_DOWN(epa)"
          ],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_DOWN",
          "args": [
            "epa"
          ],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_end_pfn",
          "args": [
            "zone"
          ],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "unsignedlong",
            "first_init_pfn",
            "PFN_UP(spa)"
          ],
          "line": 1592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_UP",
          "args": [
            "spa"
          ],
          "line": 1592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_free_mem_range",
          "args": [
            "i",
            "nid",
            "MEMBLOCK_NONE",
            "&spa",
            "&epa",
            "NULL"
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deferred_init_pages",
          "args": [
            "nid",
            "zid",
            "spfn",
            "epfn"
          ],
          "line": 1589
        },
        "resolved": true,
        "details": {
          "function_name": "deferred_init_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1516-1539",
          "snippet": "static unsigned long  __init deferred_init_pages(int nid, int zid,\n\t\t\t\t\t\t unsigned long pfn,\n\t\t\t\t\t\t unsigned long end_pfn)\n{\n\tstruct mminit_pfnnid_cache nid_init_state = { };\n\tunsigned long nr_pgmask = pageblock_nr_pages - 1;\n\tunsigned long nr_pages = 0;\n\tstruct page *page = NULL;\n\n\tfor (; pfn < end_pfn; pfn++) {\n\t\tif (!deferred_pfn_valid(nid, pfn, &nid_init_state)) {\n\t\t\tpage = NULL;\n\t\t\tcontinue;\n\t\t} else if (!page || !(pfn & nr_pgmask)) {\n\t\t\tpage = pfn_to_page(pfn);\n\t\t\ttouch_nmi_watchdog();\n\t\t} else {\n\t\t\tpage++;\n\t\t}\n\t\t__init_single_page(page, pfn, zid, nid);\n\t\tnr_pages++;\n\t}\n\treturn (nr_pages);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic unsigned long  __init deferred_init_pages(int nid, int zid,\n\t\t\t\t\t\t unsigned long pfn,\n\t\t\t\t\t\t unsigned long end_pfn)\n{\n\tstruct mminit_pfnnid_cache nid_init_state = { };\n\tunsigned long nr_pgmask = pageblock_nr_pages - 1;\n\tunsigned long nr_pages = 0;\n\tstruct page *page = NULL;\n\n\tfor (; pfn < end_pfn; pfn++) {\n\t\tif (!deferred_pfn_valid(nid, pfn, &nid_init_state)) {\n\t\t\tpage = NULL;\n\t\t\tcontinue;\n\t\t} else if (!page || !(pfn & nr_pgmask)) {\n\t\t\tpage = pfn_to_page(pfn);\n\t\t\ttouch_nmi_watchdog();\n\t\t} else {\n\t\t\tpage++;\n\t\t}\n\t\t__init_single_page(page, pfn, zid, nid);\n\t\tnr_pages++;\n\t}\n\treturn (nr_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedlong",
            "zone_end_pfn(zone)",
            "PFN_DOWN(epa)"
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_DOWN",
          "args": [
            "epa"
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_end_pfn",
          "args": [
            "zone"
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "unsignedlong",
            "first_init_pfn",
            "PFN_UP(spa)"
          ],
          "line": 1587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_UP",
          "args": [
            "spa"
          ],
          "line": 1587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_free_mem_range",
          "args": [
            "i",
            "nid",
            "MEMBLOCK_NONE",
            "&spa",
            "&epa",
            "NULL"
          ],
          "line": 1586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "zone->zone_start_pfn",
            "first_init_pfn"
          ],
          "line": 1578
        },
        "resolved": true,
        "details": {
          "function_name": "wb_max_pause",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page-writeback.c",
          "lines": "1418-1435",
          "snippet": "static unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/timer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h> /* __set_page_dirty_buffers */",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/smp.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/init.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_PAUSE\t\tmax(HZ/5, 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/mm_inline.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/timer.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h> /* __set_page_dirty_buffers */\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/smp.h>\n#include <linux/percpu.h>\n#include <linux/rmap.h>\n#include <linux/mpage.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define MAX_PAUSE\t\tmax(HZ/5, 1)\n\nstatic unsigned long wb_max_pause(struct bdi_writeback *wb,\n\t\t\t\t  unsigned long wb_dirty)\n{\n\tunsigned long bw = wb->avg_write_bandwidth;\n\tunsigned long t;\n\n\t/*\n\t * Limit pause time for small memory systems. If sleeping for too long\n\t * time, a small pool of dirty/writeback pages may go empty and disk go\n\t * idle.\n\t *\n\t * 8 serves as the safety ratio.\n\t */\n\tt = wb_dirty / (1 + bw / roundup_pow_of_two(1 + HZ / 8));\n\tt++;\n\n\treturn min_t(unsigned long, t, MAX_PAUSE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "zone_end_pfn",
          "args": [
            "zone"
          ],
          "line": 1575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "pgdat->first_deferred_pfn > pgdat_end_pfn(pgdat)"
          ],
          "line": 1569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgdat_end_pfn",
          "args": [
            "pgdat"
          ],
          "line": 1569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "pgdat->first_deferred_pfn < pgdat->node_start_pfn"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgdat_resize_unlock",
          "args": [
            "pgdat",
            "&flags"
          ],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgdat_resize_lock",
          "args": [
            "pgdat",
            "&flags"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_cpus_allowed_ptr",
          "args": [
            "current",
            "cpumask"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "cpumask"
          ],
          "line": 1556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_of_node",
          "args": [
            "pgdat->node_id"
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic int __init deferred_init_memmap(void *data)\n{\n\tpg_data_t *pgdat = data;\n\tint nid = pgdat->node_id;\n\tunsigned long start = jiffies;\n\tunsigned long nr_pages = 0;\n\tunsigned long spfn, epfn, first_init_pfn, flags;\n\tphys_addr_t spa, epa;\n\tint zid;\n\tstruct zone *zone;\n\tconst struct cpumask *cpumask = cpumask_of_node(pgdat->node_id);\n\tu64 i;\n\n\t/* Bind memory initialisation thread to a local node if possible */\n\tif (!cpumask_empty(cpumask))\n\t\tset_cpus_allowed_ptr(current, cpumask);\n\n\tpgdat_resize_lock(pgdat, &flags);\n\tfirst_init_pfn = pgdat->first_deferred_pfn;\n\tif (first_init_pfn == ULONG_MAX) {\n\t\tpgdat_resize_unlock(pgdat, &flags);\n\t\tpgdat_init_report_one_done();\n\t\treturn 0;\n\t}\n\n\t/* Sanity check boundaries */\n\tBUG_ON(pgdat->first_deferred_pfn < pgdat->node_start_pfn);\n\tBUG_ON(pgdat->first_deferred_pfn > pgdat_end_pfn(pgdat));\n\tpgdat->first_deferred_pfn = ULONG_MAX;\n\n\t/* Only the highest zone is deferred so find it */\n\tfor (zid = 0; zid < MAX_NR_ZONES; zid++) {\n\t\tzone = pgdat->node_zones + zid;\n\t\tif (first_init_pfn < zone_end_pfn(zone))\n\t\t\tbreak;\n\t}\n\tfirst_init_pfn = max(zone->zone_start_pfn, first_init_pfn);\n\n\t/*\n\t * Initialize and free pages. We do it in two loops: first we initialize\n\t * struct page, than free to buddy allocator, because while we are\n\t * freeing pages we can access pages that are ahead (computing buddy\n\t * page in __free_one_page()).\n\t */\n\tfor_each_free_mem_range(i, nid, MEMBLOCK_NONE, &spa, &epa, NULL) {\n\t\tspfn = max_t(unsigned long, first_init_pfn, PFN_UP(spa));\n\t\tepfn = min_t(unsigned long, zone_end_pfn(zone), PFN_DOWN(epa));\n\t\tnr_pages += deferred_init_pages(nid, zid, spfn, epfn);\n\t}\n\tfor_each_free_mem_range(i, nid, MEMBLOCK_NONE, &spa, &epa, NULL) {\n\t\tspfn = max_t(unsigned long, first_init_pfn, PFN_UP(spa));\n\t\tepfn = min_t(unsigned long, zone_end_pfn(zone), PFN_DOWN(epa));\n\t\tdeferred_free_pages(nid, zid, spfn, epfn);\n\t}\n\tpgdat_resize_unlock(pgdat, &flags);\n\n\t/* Sanity check that the next zone really is unpopulated */\n\tWARN_ON(++zid < MAX_NR_ZONES && populated_zone(++zone));\n\n\tpr_info(\"node %d initialised, %lu pages in %ums\\n\", nid, nr_pages,\n\t\t\t\t\tjiffies_to_msecs(jiffies - start));\n\n\tpgdat_init_report_one_done();\n\treturn 0;\n}"
  },
  {
    "function_name": "deferred_init_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "1516-1539",
    "snippet": "static unsigned long  __init deferred_init_pages(int nid, int zid,\n\t\t\t\t\t\t unsigned long pfn,\n\t\t\t\t\t\t unsigned long end_pfn)\n{\n\tstruct mminit_pfnnid_cache nid_init_state = { };\n\tunsigned long nr_pgmask = pageblock_nr_pages - 1;\n\tunsigned long nr_pages = 0;\n\tstruct page *page = NULL;\n\n\tfor (; pfn < end_pfn; pfn++) {\n\t\tif (!deferred_pfn_valid(nid, pfn, &nid_init_state)) {\n\t\t\tpage = NULL;\n\t\t\tcontinue;\n\t\t} else if (!page || !(pfn & nr_pgmask)) {\n\t\t\tpage = pfn_to_page(pfn);\n\t\t\ttouch_nmi_watchdog();\n\t\t} else {\n\t\t\tpage++;\n\t\t}\n\t\t__init_single_page(page, pfn, zid, nid);\n\t\tnr_pages++;\n\t}\n\treturn (nr_pages);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__init_single_page",
          "args": [
            "page",
            "pfn",
            "zid",
            "nid"
          ],
          "line": 1535
        },
        "resolved": true,
        "details": {
          "function_name": "__init_single_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1178-1193",
          "snippet": "static void __meminit __init_single_page(struct page *page, unsigned long pfn,\n\t\t\t\tunsigned long zone, int nid)\n{\n\tmm_zero_struct_page(page);\n\tset_page_links(page, zone, nid, pfn);\n\tinit_page_count(page);\n\tpage_mapcount_reset(page);\n\tpage_cpupid_reset_last(page);\n\n\tINIT_LIST_HEAD(&page->lru);\n#ifdef WANT_PAGE_VIRTUAL\n\t/* The shift won't overflow because ZONE_NORMAL is below 4G. */\n\tif (!is_highmem_idx(zone))\n\t\tset_page_address(page, __va(pfn << PAGE_SHIFT));\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic void __meminit __init_single_page(struct page *page, unsigned long pfn,\n\t\t\t\tunsigned long zone, int nid)\n{\n\tmm_zero_struct_page(page);\n\tset_page_links(page, zone, nid, pfn);\n\tinit_page_count(page);\n\tpage_mapcount_reset(page);\n\tpage_cpupid_reset_last(page);\n\n\tINIT_LIST_HEAD(&page->lru);\n#ifdef WANT_PAGE_VIRTUAL\n\t/* The shift won't overflow because ZONE_NORMAL is below 4G. */\n\tif (!is_highmem_idx(zone))\n\t\tset_page_address(page, __va(pfn << PAGE_SHIFT));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "touch_nmi_watchdog",
          "args": [],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deferred_pfn_valid",
          "args": [
            "nid",
            "pfn",
            "&nid_init_state"
          ],
          "line": 1526
        },
        "resolved": true,
        "details": {
          "function_name": "deferred_pfn_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1471-1482",
          "snippet": "static inline bool __init\ndeferred_pfn_valid(int nid, unsigned long pfn,\n\t\t   struct mminit_pfnnid_cache *nid_init_state)\n{\n\tif (!pfn_valid_within(pfn))\n\t\treturn false;\n\tif (!(pfn & (pageblock_nr_pages - 1)) && !pfn_valid(pfn))\n\t\treturn false;\n\tif (!meminit_pfn_in_nid(pfn, nid, nid_init_state))\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline bool __init\ndeferred_pfn_valid(int nid, unsigned long pfn,\n\t\t   struct mminit_pfnnid_cache *nid_init_state)\n{\n\tif (!pfn_valid_within(pfn))\n\t\treturn false;\n\tif (!(pfn & (pageblock_nr_pages - 1)) && !pfn_valid(pfn))\n\t\treturn false;\n\tif (!meminit_pfn_in_nid(pfn, nid, nid_init_state))\n\t\treturn false;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic unsigned long  __init deferred_init_pages(int nid, int zid,\n\t\t\t\t\t\t unsigned long pfn,\n\t\t\t\t\t\t unsigned long end_pfn)\n{\n\tstruct mminit_pfnnid_cache nid_init_state = { };\n\tunsigned long nr_pgmask = pageblock_nr_pages - 1;\n\tunsigned long nr_pages = 0;\n\tstruct page *page = NULL;\n\n\tfor (; pfn < end_pfn; pfn++) {\n\t\tif (!deferred_pfn_valid(nid, pfn, &nid_init_state)) {\n\t\t\tpage = NULL;\n\t\t\tcontinue;\n\t\t} else if (!page || !(pfn & nr_pgmask)) {\n\t\t\tpage = pfn_to_page(pfn);\n\t\t\ttouch_nmi_watchdog();\n\t\t} else {\n\t\t\tpage++;\n\t\t}\n\t\t__init_single_page(page, pfn, zid, nid);\n\t\tnr_pages++;\n\t}\n\treturn (nr_pages);\n}"
  },
  {
    "function_name": "deferred_free_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "1488-1509",
    "snippet": "static void __init deferred_free_pages(int nid, int zid, unsigned long pfn,\n\t\t\t\t       unsigned long end_pfn)\n{\n\tstruct mminit_pfnnid_cache nid_init_state = { };\n\tunsigned long nr_pgmask = pageblock_nr_pages - 1;\n\tunsigned long nr_free = 0;\n\n\tfor (; pfn < end_pfn; pfn++) {\n\t\tif (!deferred_pfn_valid(nid, pfn, &nid_init_state)) {\n\t\t\tdeferred_free_range(pfn - nr_free, nr_free);\n\t\t\tnr_free = 0;\n\t\t} else if (!(pfn & nr_pgmask)) {\n\t\t\tdeferred_free_range(pfn - nr_free, nr_free);\n\t\t\tnr_free = 1;\n\t\t\ttouch_nmi_watchdog();\n\t\t} else {\n\t\t\tnr_free++;\n\t\t}\n\t}\n\t/* Free the last block of pages to allocator */\n\tdeferred_free_range(pfn - nr_free, nr_free);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "deferred_free_range",
          "args": [
            "pfn - nr_free",
            "nr_free"
          ],
          "line": 1508
        },
        "resolved": true,
        "details": {
          "function_name": "deferred_free_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1421-1445",
          "snippet": "static void __init deferred_free_range(unsigned long pfn,\n\t\t\t\t       unsigned long nr_pages)\n{\n\tstruct page *page;\n\tunsigned long i;\n\n\tif (!nr_pages)\n\t\treturn;\n\n\tpage = pfn_to_page(pfn);\n\n\t/* Free a large naturally-aligned chunk if possible */\n\tif (nr_pages == pageblock_nr_pages &&\n\t    (pfn & (pageblock_nr_pages - 1)) == 0) {\n\t\tset_pageblock_migratetype(page, MIGRATE_MOVABLE);\n\t\t__free_pages_boot_core(page, pageblock_order);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < nr_pages; i++, page++, pfn++) {\n\t\tif ((pfn & (pageblock_nr_pages - 1)) == 0)\n\t\t\tset_pageblock_migratetype(page, MIGRATE_MOVABLE);\n\t\t__free_pages_boot_core(page, 0);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic void __init deferred_free_range(unsigned long pfn,\n\t\t\t\t       unsigned long nr_pages)\n{\n\tstruct page *page;\n\tunsigned long i;\n\n\tif (!nr_pages)\n\t\treturn;\n\n\tpage = pfn_to_page(pfn);\n\n\t/* Free a large naturally-aligned chunk if possible */\n\tif (nr_pages == pageblock_nr_pages &&\n\t    (pfn & (pageblock_nr_pages - 1)) == 0) {\n\t\tset_pageblock_migratetype(page, MIGRATE_MOVABLE);\n\t\t__free_pages_boot_core(page, pageblock_order);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < nr_pages; i++, page++, pfn++) {\n\t\tif ((pfn & (pageblock_nr_pages - 1)) == 0)\n\t\t\tset_pageblock_migratetype(page, MIGRATE_MOVABLE);\n\t\t__free_pages_boot_core(page, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "touch_nmi_watchdog",
          "args": [],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deferred_pfn_valid",
          "args": [
            "nid",
            "pfn",
            "&nid_init_state"
          ],
          "line": 1496
        },
        "resolved": true,
        "details": {
          "function_name": "deferred_pfn_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1471-1482",
          "snippet": "static inline bool __init\ndeferred_pfn_valid(int nid, unsigned long pfn,\n\t\t   struct mminit_pfnnid_cache *nid_init_state)\n{\n\tif (!pfn_valid_within(pfn))\n\t\treturn false;\n\tif (!(pfn & (pageblock_nr_pages - 1)) && !pfn_valid(pfn))\n\t\treturn false;\n\tif (!meminit_pfn_in_nid(pfn, nid, nid_init_state))\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline bool __init\ndeferred_pfn_valid(int nid, unsigned long pfn,\n\t\t   struct mminit_pfnnid_cache *nid_init_state)\n{\n\tif (!pfn_valid_within(pfn))\n\t\treturn false;\n\tif (!(pfn & (pageblock_nr_pages - 1)) && !pfn_valid(pfn))\n\t\treturn false;\n\tif (!meminit_pfn_in_nid(pfn, nid, nid_init_state))\n\t\treturn false;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic void __init deferred_free_pages(int nid, int zid, unsigned long pfn,\n\t\t\t\t       unsigned long end_pfn)\n{\n\tstruct mminit_pfnnid_cache nid_init_state = { };\n\tunsigned long nr_pgmask = pageblock_nr_pages - 1;\n\tunsigned long nr_free = 0;\n\n\tfor (; pfn < end_pfn; pfn++) {\n\t\tif (!deferred_pfn_valid(nid, pfn, &nid_init_state)) {\n\t\t\tdeferred_free_range(pfn - nr_free, nr_free);\n\t\t\tnr_free = 0;\n\t\t} else if (!(pfn & nr_pgmask)) {\n\t\t\tdeferred_free_range(pfn - nr_free, nr_free);\n\t\t\tnr_free = 1;\n\t\t\ttouch_nmi_watchdog();\n\t\t} else {\n\t\t\tnr_free++;\n\t\t}\n\t}\n\t/* Free the last block of pages to allocator */\n\tdeferred_free_range(pfn - nr_free, nr_free);\n}"
  },
  {
    "function_name": "deferred_pfn_valid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "1471-1482",
    "snippet": "static inline bool __init\ndeferred_pfn_valid(int nid, unsigned long pfn,\n\t\t   struct mminit_pfnnid_cache *nid_init_state)\n{\n\tif (!pfn_valid_within(pfn))\n\t\treturn false;\n\tif (!(pfn & (pageblock_nr_pages - 1)) && !pfn_valid(pfn))\n\t\treturn false;\n\tif (!meminit_pfn_in_nid(pfn, nid, nid_init_state))\n\t\treturn false;\n\treturn true;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "meminit_pfn_in_nid",
          "args": [
            "pfn",
            "nid",
            "nid_init_state"
          ],
          "line": 1479
        },
        "resolved": true,
        "details": {
          "function_name": "meminit_pfn_in_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1332-1337",
          "snippet": "__maybe_unused\nmeminit_pfn_in_nid(unsigned long pfn, int node,\n\t\t   struct mminit_pfnnid_cache *state)\n{\n\treturn true;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\n__maybe_unused\nmeminit_pfn_in_nid(unsigned long pfn, int node,\n\t\t   struct mminit_pfnnid_cache *state)\n{\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfn_valid",
          "args": [
            "pfn"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_valid_within",
          "args": [
            "pfn"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline bool __init\ndeferred_pfn_valid(int nid, unsigned long pfn,\n\t\t   struct mminit_pfnnid_cache *nid_init_state)\n{\n\tif (!pfn_valid_within(pfn))\n\t\treturn false;\n\tif (!(pfn & (pageblock_nr_pages - 1)) && !pfn_valid(pfn))\n\t\treturn false;\n\tif (!meminit_pfn_in_nid(pfn, nid, nid_init_state))\n\t\treturn false;\n\treturn true;\n}"
  },
  {
    "function_name": "pgdat_init_report_one_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "1451-1455",
    "snippet": "static inline void __init pgdat_init_report_one_done(void)\n{\n\tif (atomic_dec_and_test(&pgdat_init_n_undone))\n\t\tcomplete(&pgdat_init_all_done_comp);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&pgdat_init_all_done_comp"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&pgdat_init_n_undone"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic inline void __init pgdat_init_report_one_done(void)\n{\n\tif (atomic_dec_and_test(&pgdat_init_n_undone))\n\t\tcomplete(&pgdat_init_all_done_comp);\n}"
  },
  {
    "function_name": "deferred_free_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "1421-1445",
    "snippet": "static void __init deferred_free_range(unsigned long pfn,\n\t\t\t\t       unsigned long nr_pages)\n{\n\tstruct page *page;\n\tunsigned long i;\n\n\tif (!nr_pages)\n\t\treturn;\n\n\tpage = pfn_to_page(pfn);\n\n\t/* Free a large naturally-aligned chunk if possible */\n\tif (nr_pages == pageblock_nr_pages &&\n\t    (pfn & (pageblock_nr_pages - 1)) == 0) {\n\t\tset_pageblock_migratetype(page, MIGRATE_MOVABLE);\n\t\t__free_pages_boot_core(page, pageblock_order);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < nr_pages; i++, page++, pfn++) {\n\t\tif ((pfn & (pageblock_nr_pages - 1)) == 0)\n\t\t\tset_pageblock_migratetype(page, MIGRATE_MOVABLE);\n\t\t__free_pages_boot_core(page, 0);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_pages_boot_core",
          "args": [
            "page",
            "0"
          ],
          "line": 1443
        },
        "resolved": true,
        "details": {
          "function_name": "__free_pages_boot_core",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1267-1285",
          "snippet": "static void __init __free_pages_boot_core(struct page *page, unsigned int order)\n{\n\tunsigned int nr_pages = 1 << order;\n\tstruct page *p = page;\n\tunsigned int loop;\n\n\tprefetchw(p);\n\tfor (loop = 0; loop < (nr_pages - 1); loop++, p++) {\n\t\tprefetchw(p + 1);\n\t\t__ClearPageReserved(p);\n\t\tset_page_count(p, 0);\n\t}\n\t__ClearPageReserved(p);\n\tset_page_count(p, 0);\n\n\tpage_zone(page)->managed_pages += nr_pages;\n\tset_page_refcounted(page);\n\t__free_pages(page, order);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic void __init __free_pages_boot_core(struct page *page, unsigned int order)\n{\n\tunsigned int nr_pages = 1 << order;\n\tstruct page *p = page;\n\tunsigned int loop;\n\n\tprefetchw(p);\n\tfor (loop = 0; loop < (nr_pages - 1); loop++, p++) {\n\t\tprefetchw(p + 1);\n\t\t__ClearPageReserved(p);\n\t\tset_page_count(p, 0);\n\t}\n\t__ClearPageReserved(p);\n\tset_page_count(p, 0);\n\n\tpage_zone(page)->managed_pages += nr_pages;\n\tset_page_refcounted(page);\n\t__free_pages(page, order);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_pageblock_migratetype",
          "args": [
            "page",
            "MIGRATE_MOVABLE"
          ],
          "line": 1442
        },
        "resolved": true,
        "details": {
          "function_name": "set_pageblock_migratetype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "450-458",
          "snippet": "void set_pageblock_migratetype(struct page *page, int migratetype)\n{\n\tif (unlikely(page_group_by_mobility_disabled &&\n\t\t     migratetype < MIGRATE_PCPTYPES))\n\t\tmigratetype = MIGRATE_UNMOVABLE;\n\n\tset_pageblock_flags_group(page, (unsigned long)migratetype,\n\t\t\t\t\tPB_migrate, PB_migrate_end);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int page_group_by_mobility_disabled",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nint page_group_by_mobility_disabled;\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid set_pageblock_migratetype(struct page *page, int migratetype)\n{\n\tif (unlikely(page_group_by_mobility_disabled &&\n\t\t     migratetype < MIGRATE_PCPTYPES))\n\t\tmigratetype = MIGRATE_UNMOVABLE;\n\n\tset_pageblock_flags_group(page, (unsigned long)migratetype,\n\t\t\t\t\tPB_migrate, PB_migrate_end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic void __init deferred_free_range(unsigned long pfn,\n\t\t\t\t       unsigned long nr_pages)\n{\n\tstruct page *page;\n\tunsigned long i;\n\n\tif (!nr_pages)\n\t\treturn;\n\n\tpage = pfn_to_page(pfn);\n\n\t/* Free a large naturally-aligned chunk if possible */\n\tif (nr_pages == pageblock_nr_pages &&\n\t    (pfn & (pageblock_nr_pages - 1)) == 0) {\n\t\tset_pageblock_migratetype(page, MIGRATE_MOVABLE);\n\t\t__free_pages_boot_core(page, pageblock_order);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < nr_pages; i++, page++, pfn++) {\n\t\tif ((pfn & (pageblock_nr_pages - 1)) == 0)\n\t\t\tset_pageblock_migratetype(page, MIGRATE_MOVABLE);\n\t\t__free_pages_boot_core(page, 0);\n\t}\n}"
  },
  {
    "function_name": "clear_zone_contiguous",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "1415-1418",
    "snippet": "void clear_zone_contiguous(struct zone *zone)\n{\n\tzone->contiguous = false;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid clear_zone_contiguous(struct zone *zone)\n{\n\tzone->contiguous = false;\n}"
  },
  {
    "function_name": "set_zone_contiguous",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "1394-1413",
    "snippet": "void set_zone_contiguous(struct zone *zone)\n{\n\tunsigned long block_start_pfn = zone->zone_start_pfn;\n\tunsigned long block_end_pfn;\n\n\tblock_end_pfn = ALIGN(block_start_pfn + 1, pageblock_nr_pages);\n\tfor (; block_start_pfn < zone_end_pfn(zone);\n\t\t\tblock_start_pfn = block_end_pfn,\n\t\t\t block_end_pfn += pageblock_nr_pages) {\n\n\t\tblock_end_pfn = min(block_end_pfn, zone_end_pfn(zone));\n\n\t\tif (!__pageblock_pfn_to_page(block_start_pfn,\n\t\t\t\t\t     block_end_pfn, zone))\n\t\t\treturn;\n\t}\n\n\t/* We confirm that there is no hole */\n\tzone->contiguous = true;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__pageblock_pfn_to_page",
          "args": [
            "block_start_pfn",
            "block_end_pfn",
            "zone"
          ],
          "line": 1406
        },
        "resolved": true,
        "details": {
          "function_name": "__pageblock_pfn_to_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1366-1392",
          "snippet": "struct page *__pageblock_pfn_to_page(unsigned long start_pfn,\n\t\t\t\t     unsigned long end_pfn, struct zone *zone)\n{\n\tstruct page *start_page;\n\tstruct page *end_page;\n\n\t/* end_pfn is one past the range we are checking */\n\tend_pfn--;\n\n\tif (!pfn_valid(start_pfn) || !pfn_valid(end_pfn))\n\t\treturn NULL;\n\n\tstart_page = pfn_to_online_page(start_pfn);\n\tif (!start_page)\n\t\treturn NULL;\n\n\tif (page_zone(start_page) != zone)\n\t\treturn NULL;\n\n\tend_page = pfn_to_page(end_pfn);\n\n\t/* This gives a shorter code than deriving page_zone(end_page) */\n\tif (page_zone_id(start_page) != page_zone_id(end_page))\n\t\treturn NULL;\n\n\treturn start_page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstruct page *__pageblock_pfn_to_page(unsigned long start_pfn,\n\t\t\t\t     unsigned long end_pfn, struct zone *zone)\n{\n\tstruct page *start_page;\n\tstruct page *end_page;\n\n\t/* end_pfn is one past the range we are checking */\n\tend_pfn--;\n\n\tif (!pfn_valid(start_pfn) || !pfn_valid(end_pfn))\n\t\treturn NULL;\n\n\tstart_page = pfn_to_online_page(start_pfn);\n\tif (!start_page)\n\t\treturn NULL;\n\n\tif (page_zone(start_page) != zone)\n\t\treturn NULL;\n\n\tend_page = pfn_to_page(end_pfn);\n\n\t/* This gives a shorter code than deriving page_zone(end_page) */\n\tif (page_zone_id(start_page) != page_zone_id(end_page))\n\t\treturn NULL;\n\n\treturn start_page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "block_end_pfn",
            "zone_end_pfn(zone)"
          ],
          "line": 1404
        },
        "resolved": true,
        "details": {
          "function_name": "si_meminfo_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4761-4790",
          "snippet": "void si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid si_meminfo_node(struct sysinfo *val, int nid)\n{\n\tint zone_type;\t\t/* needs to be signed */\n\tunsigned long managed_pages = 0;\n\tunsigned long managed_highpages = 0;\n\tunsigned long free_highpages = 0;\n\tpg_data_t *pgdat = NODE_DATA(nid);\n\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++)\n\t\tmanaged_pages += pgdat->node_zones[zone_type].managed_pages;\n\tval->totalram = managed_pages;\n\tval->sharedram = node_page_state(pgdat, NR_SHMEM);\n\tval->freeram = sum_zone_node_page_state(nid, NR_FREE_PAGES);\n#ifdef CONFIG_HIGHMEM\n\tfor (zone_type = 0; zone_type < MAX_NR_ZONES; zone_type++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zone_type];\n\n\t\tif (is_highmem(zone)) {\n\t\t\tmanaged_highpages += zone->managed_pages;\n\t\t\tfree_highpages += zone_page_state(zone, NR_FREE_PAGES);\n\t\t}\n\t}\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#else\n\tval->totalhigh = managed_highpages;\n\tval->freehigh = free_highpages;\n#endif\n\tval->mem_unit = PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zone_end_pfn",
          "args": [
            "zone"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_end_pfn",
          "args": [
            "zone"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "block_start_pfn + 1",
            "pageblock_nr_pages"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid set_zone_contiguous(struct zone *zone)\n{\n\tunsigned long block_start_pfn = zone->zone_start_pfn;\n\tunsigned long block_end_pfn;\n\n\tblock_end_pfn = ALIGN(block_start_pfn + 1, pageblock_nr_pages);\n\tfor (; block_start_pfn < zone_end_pfn(zone);\n\t\t\tblock_start_pfn = block_end_pfn,\n\t\t\t block_end_pfn += pageblock_nr_pages) {\n\n\t\tblock_end_pfn = min(block_end_pfn, zone_end_pfn(zone));\n\n\t\tif (!__pageblock_pfn_to_page(block_start_pfn,\n\t\t\t\t\t     block_end_pfn, zone))\n\t\t\treturn;\n\t}\n\n\t/* We confirm that there is no hole */\n\tzone->contiguous = true;\n}"
  },
  {
    "function_name": "__pageblock_pfn_to_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "1366-1392",
    "snippet": "struct page *__pageblock_pfn_to_page(unsigned long start_pfn,\n\t\t\t\t     unsigned long end_pfn, struct zone *zone)\n{\n\tstruct page *start_page;\n\tstruct page *end_page;\n\n\t/* end_pfn is one past the range we are checking */\n\tend_pfn--;\n\n\tif (!pfn_valid(start_pfn) || !pfn_valid(end_pfn))\n\t\treturn NULL;\n\n\tstart_page = pfn_to_online_page(start_pfn);\n\tif (!start_page)\n\t\treturn NULL;\n\n\tif (page_zone(start_page) != zone)\n\t\treturn NULL;\n\n\tend_page = pfn_to_page(end_pfn);\n\n\t/* This gives a shorter code than deriving page_zone(end_page) */\n\tif (page_zone_id(start_page) != page_zone_id(end_page))\n\t\treturn NULL;\n\n\treturn start_page;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_zone_id",
          "args": [
            "end_page"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_zone_id",
          "args": [
            "start_page"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "end_pfn"
          ],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "start_page"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_online_page",
          "args": [
            "start_pfn"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_valid",
          "args": [
            "end_pfn"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_valid",
          "args": [
            "start_pfn"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstruct page *__pageblock_pfn_to_page(unsigned long start_pfn,\n\t\t\t\t     unsigned long end_pfn, struct zone *zone)\n{\n\tstruct page *start_page;\n\tstruct page *end_page;\n\n\t/* end_pfn is one past the range we are checking */\n\tend_pfn--;\n\n\tif (!pfn_valid(start_pfn) || !pfn_valid(end_pfn))\n\t\treturn NULL;\n\n\tstart_page = pfn_to_online_page(start_pfn);\n\tif (!start_page)\n\t\treturn NULL;\n\n\tif (page_zone(start_page) != zone)\n\t\treturn NULL;\n\n\tend_page = pfn_to_page(end_pfn);\n\n\t/* This gives a shorter code than deriving page_zone(end_page) */\n\tif (page_zone_id(start_page) != page_zone_id(end_page))\n\t\treturn NULL;\n\n\treturn start_page;\n}"
  },
  {
    "function_name": "memblock_free_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "1341-1347",
    "snippet": "void __init memblock_free_pages(struct page *page, unsigned long pfn,\n\t\t\t\t\t\t\tunsigned int order)\n{\n\tif (early_page_uninitialised(pfn))\n\t\treturn;\n\treturn __free_pages_boot_core(page, order);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);",
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_pages_boot_core",
          "args": [
            "page",
            "order"
          ],
          "line": 1346
        },
        "resolved": true,
        "details": {
          "function_name": "__free_pages_boot_core",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1267-1285",
          "snippet": "static void __init __free_pages_boot_core(struct page *page, unsigned int order)\n{\n\tunsigned int nr_pages = 1 << order;\n\tstruct page *p = page;\n\tunsigned int loop;\n\n\tprefetchw(p);\n\tfor (loop = 0; loop < (nr_pages - 1); loop++, p++) {\n\t\tprefetchw(p + 1);\n\t\t__ClearPageReserved(p);\n\t\tset_page_count(p, 0);\n\t}\n\t__ClearPageReserved(p);\n\tset_page_count(p, 0);\n\n\tpage_zone(page)->managed_pages += nr_pages;\n\tset_page_refcounted(page);\n\t__free_pages(page, order);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic void __init __free_pages_boot_core(struct page *page, unsigned int order)\n{\n\tunsigned int nr_pages = 1 << order;\n\tstruct page *p = page;\n\tunsigned int loop;\n\n\tprefetchw(p);\n\tfor (loop = 0; loop < (nr_pages - 1); loop++, p++) {\n\t\tprefetchw(p + 1);\n\t\t__ClearPageReserved(p);\n\t\tset_page_count(p, 0);\n\t}\n\t__ClearPageReserved(p);\n\tset_page_count(p, 0);\n\n\tpage_zone(page)->managed_pages += nr_pages;\n\tset_page_refcounted(page);\n\t__free_pages(page, order);\n}"
        }
      },
      {
        "call_info": {
          "callee": "early_page_uninitialised",
          "args": [
            "pfn"
          ],
          "line": 1344
        },
        "resolved": true,
        "details": {
          "function_name": "early_page_uninitialised",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "338-341",
          "snippet": "static inline bool early_page_uninitialised(unsigned long pfn)\n{\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic inline bool early_page_uninitialised(unsigned long pfn)\n{\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid __init memblock_free_pages(struct page *page, unsigned long pfn,\n\t\t\t\t\t\t\tunsigned int order)\n{\n\tif (early_page_uninitialised(pfn))\n\t\treturn;\n\treturn __free_pages_boot_core(page, order);\n}"
  },
  {
    "function_name": "meminit_pfn_in_nid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "1332-1337",
    "snippet": "__maybe_unused\nmeminit_pfn_in_nid(unsigned long pfn, int node,\n\t\t   struct mminit_pfnnid_cache *state)\n{\n\treturn true;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\n__maybe_unused\nmeminit_pfn_in_nid(unsigned long pfn, int node,\n\t\t   struct mminit_pfnnid_cache *state)\n{\n\treturn true;\n}"
  },
  {
    "function_name": "early_pfn_in_nid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "1328-1331",
    "snippet": "static inline bool __meminit early_pfn_in_nid(unsigned long pfn, int node)\n{\n\treturn true;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic inline bool __meminit early_pfn_in_nid(unsigned long pfn, int node)\n{\n\treturn true;\n}"
  },
  {
    "function_name": "early_pfn_in_nid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "1321-1324",
    "snippet": "static inline bool __meminit early_pfn_in_nid(unsigned long pfn, int node)\n{\n\treturn meminit_pfn_in_nid(pfn, node, &early_pfnnid_cache);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "meminit_pfn_in_nid",
          "args": [
            "pfn",
            "node",
            "&early_pfnnid_cache"
          ],
          "line": 1323
        },
        "resolved": true,
        "details": {
          "function_name": "meminit_pfn_in_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1332-1337",
          "snippet": "__maybe_unused\nmeminit_pfn_in_nid(unsigned long pfn, int node,\n\t\t   struct mminit_pfnnid_cache *state)\n{\n\treturn true;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\n__maybe_unused\nmeminit_pfn_in_nid(unsigned long pfn, int node,\n\t\t   struct mminit_pfnnid_cache *state)\n{\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic inline bool __meminit early_pfn_in_nid(unsigned long pfn, int node)\n{\n\treturn meminit_pfn_in_nid(pfn, node, &early_pfnnid_cache);\n}"
  },
  {
    "function_name": "meminit_pfn_in_nid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "1308-1318",
    "snippet": "__maybe_unused\nmeminit_pfn_in_nid(unsigned long pfn, int node,\n\t\t   struct mminit_pfnnid_cache *state)\n{\n\tint nid;\n\n\tnid = __early_pfn_to_nid(pfn, state);\n\tif (nid >= 0 && nid != node)\n\t\treturn false;\n\treturn true;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__early_pfn_to_nid",
          "args": [
            "pfn",
            "state"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\n__maybe_unused\nmeminit_pfn_in_nid(unsigned long pfn, int node,\n\t\t   struct mminit_pfnnid_cache *state)\n{\n\tint nid;\n\n\tnid = __early_pfn_to_nid(pfn, state);\n\tif (nid >= 0 && nid != node)\n\t\treturn false;\n\treturn true;\n}"
  },
  {
    "function_name": "early_pfn_to_nid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "1292-1304",
    "snippet": "int __meminit early_pfn_to_nid(unsigned long pfn)\n{\n\tstatic DEFINE_SPINLOCK(early_pfn_lock);\n\tint nid;\n\n\tspin_lock(&early_pfn_lock);\n\tnid = __early_pfn_to_nid(pfn, &early_pfnnid_cache);\n\tif (nid < 0)\n\t\tnid = first_online_node;\n\tspin_unlock(&early_pfn_lock);\n\n\treturn nid;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&early_pfn_lock"
          ],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__early_pfn_to_nid",
          "args": [
            "pfn",
            "&early_pfnnid_cache"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&early_pfn_lock"
          ],
          "line": 1297
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nint __meminit early_pfn_to_nid(unsigned long pfn)\n{\n\tstatic DEFINE_SPINLOCK(early_pfn_lock);\n\tint nid;\n\n\tspin_lock(&early_pfn_lock);\n\tnid = __early_pfn_to_nid(pfn, &early_pfnnid_cache);\n\tif (nid < 0)\n\t\tnid = first_online_node;\n\tspin_unlock(&early_pfn_lock);\n\n\treturn nid;\n}"
  },
  {
    "function_name": "__free_pages_boot_core",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "1267-1285",
    "snippet": "static void __init __free_pages_boot_core(struct page *page, unsigned int order)\n{\n\tunsigned int nr_pages = 1 << order;\n\tstruct page *p = page;\n\tunsigned int loop;\n\n\tprefetchw(p);\n\tfor (loop = 0; loop < (nr_pages - 1); loop++, p++) {\n\t\tprefetchw(p + 1);\n\t\t__ClearPageReserved(p);\n\t\tset_page_count(p, 0);\n\t}\n\t__ClearPageReserved(p);\n\tset_page_count(p, 0);\n\n\tpage_zone(page)->managed_pages += nr_pages;\n\tset_page_refcounted(page);\n\t__free_pages(page, order);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);",
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_pages",
          "args": [
            "page",
            "order"
          ],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "__free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4430-4438",
          "snippet": "void __free_pages(struct page *page, unsigned int order)\n{\n\tif (put_page_testzero(page)) {\n\t\tif (order == 0)\n\t\t\tfree_unref_page(page);\n\t\telse\n\t\t\t__free_pages_ok(page, order);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid __free_pages(struct page *page, unsigned int order)\n{\n\tif (put_page_testzero(page)) {\n\t\tif (order == 0)\n\t\t\tfree_unref_page(page);\n\t\telse\n\t\t\t__free_pages_ok(page, order);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_refcounted",
          "args": [
            "page"
          ],
          "line": 1283
        },
        "resolved": true,
        "details": {
          "function_name": "set_page_refcounted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "74-79",
          "snippet": "static inline void set_page_refcounted(struct page *page)\n{\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\tVM_BUG_ON_PAGE(page_ref_count(page), page);\n\tset_page_count(page, 1);\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void set_page_refcounted(struct page *page)\n{\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\tVM_BUG_ON_PAGE(page_ref_count(page), page);\n\tset_page_count(page, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "page"
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_count",
          "args": [
            "p",
            "0"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ClearPageReserved",
          "args": [
            "p"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_count",
          "args": [
            "p",
            "0"
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ClearPageReserved",
          "args": [
            "p"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prefetchw",
          "args": [
            "p + 1"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prefetchw",
          "args": [
            "p"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic void __init __free_pages_boot_core(struct page *page, unsigned int order)\n{\n\tunsigned int nr_pages = 1 << order;\n\tstruct page *p = page;\n\tunsigned int loop;\n\n\tprefetchw(p);\n\tfor (loop = 0; loop < (nr_pages - 1); loop++, p++) {\n\t\tprefetchw(p + 1);\n\t\t__ClearPageReserved(p);\n\t\tset_page_count(p, 0);\n\t}\n\t__ClearPageReserved(p);\n\tset_page_count(p, 0);\n\n\tpage_zone(page)->managed_pages += nr_pages;\n\tset_page_refcounted(page);\n\t__free_pages(page, order);\n}"
  },
  {
    "function_name": "__free_pages_ok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "1251-1265",
    "snippet": "static void __free_pages_ok(struct page *page, unsigned int order)\n{\n\tunsigned long flags;\n\tint migratetype;\n\tunsigned long pfn = page_to_pfn(page);\n\n\tif (!free_pages_prepare(page, order, true))\n\t\treturn;\n\n\tmigratetype = get_pfnblock_migratetype(page, pfn);\n\tlocal_irq_save(flags);\n\t__count_vm_events(PGFREE, 1 << order);\n\tfree_one_page(page_zone(page), page, pfn, order, migratetype);\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);",
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_one_page",
          "args": [
            "page_zone(page)",
            "page",
            "pfn",
            "order",
            "migratetype"
          ],
          "line": 1263
        },
        "resolved": true,
        "details": {
          "function_name": "free_one_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1164-1176",
          "snippet": "static void free_one_page(struct zone *zone,\n\t\t\t\tstruct page *page, unsigned long pfn,\n\t\t\t\tunsigned int order,\n\t\t\t\tint migratetype)\n{\n\tspin_lock(&zone->lock);\n\tif (unlikely(has_isolate_pageblock(zone) ||\n\t\tis_migrate_isolate(migratetype))) {\n\t\tmigratetype = get_pfnblock_migratetype(page, pfn);\n\t}\n\t__free_one_page(page, pfn, zone, order, migratetype);\n\tspin_unlock(&zone->lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic void free_one_page(struct zone *zone,\n\t\t\t\tstruct page *page, unsigned long pfn,\n\t\t\t\tunsigned int order,\n\t\t\t\tint migratetype)\n{\n\tspin_lock(&zone->lock);\n\tif (unlikely(has_isolate_pageblock(zone) ||\n\t\tis_migrate_isolate(migratetype))) {\n\t\tmigratetype = get_pfnblock_migratetype(page, pfn);\n\t}\n\t__free_one_page(page, pfn, zone, order, migratetype);\n\tspin_unlock(&zone->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "page"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__count_vm_events",
          "args": [
            "PGFREE",
            "1 << order"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_pfnblock_migratetype",
          "args": [
            "page",
            "pfn"
          ],
          "line": 1260
        },
        "resolved": true,
        "details": {
          "function_name": "get_pfnblock_migratetype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "406-409",
          "snippet": "static __always_inline int get_pfnblock_migratetype(struct page *page, unsigned long pfn)\n{\n\treturn __get_pfnblock_flags_mask(page, pfn, PB_migrate_end, MIGRATETYPE_MASK);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic __always_inline int get_pfnblock_migratetype(struct page *page, unsigned long pfn)\n{\n\treturn __get_pfnblock_flags_mask(page, pfn, PB_migrate_end, MIGRATETYPE_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_pages_prepare",
          "args": [
            "page",
            "order",
            "true"
          ],
          "line": 1257
        },
        "resolved": true,
        "details": {
          "function_name": "free_pages_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "987-1043",
          "snippet": "static __always_inline bool free_pages_prepare(struct page *page,\n\t\t\t\t\tunsigned int order, bool check_free)\n{\n\tint bad = 0;\n\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\n\ttrace_mm_page_free(page, order);\n\n\t/*\n\t * Check tail pages before head page information is cleared to\n\t * avoid checking PageCompound for order-0 pages.\n\t */\n\tif (unlikely(order)) {\n\t\tbool compound = PageCompound(page);\n\t\tint i;\n\n\t\tVM_BUG_ON_PAGE(compound && compound_order(page) != order, page);\n\n\t\tif (compound)\n\t\t\tClearPageDoubleMap(page);\n\t\tfor (i = 1; i < (1 << order); i++) {\n\t\t\tif (compound)\n\t\t\t\tbad += free_tail_pages_check(page, page + i);\n\t\t\tif (unlikely(free_pages_check(page + i))) {\n\t\t\t\tbad++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t(page + i)->flags &= ~PAGE_FLAGS_CHECK_AT_PREP;\n\t\t}\n\t}\n\tif (PageMappingFlags(page))\n\t\tpage->mapping = NULL;\n\tif (memcg_kmem_enabled() && PageKmemcg(page))\n\t\tmemcg_kmem_uncharge(page, order);\n\tif (check_free)\n\t\tbad += free_pages_check(page);\n\tif (bad)\n\t\treturn false;\n\n\tpage_cpupid_reset_last(page);\n\tpage->flags &= ~PAGE_FLAGS_CHECK_AT_PREP;\n\treset_page_owner(page, order);\n\n\tif (!PageHighMem(page)) {\n\t\tdebug_check_no_locks_freed(page_address(page),\n\t\t\t\t\t   PAGE_SIZE << order);\n\t\tdebug_check_no_obj_freed(page_address(page),\n\t\t\t\t\t   PAGE_SIZE << order);\n\t}\n\tarch_free_page(page, order);\n\tkernel_poison_pages(page, 1 << order, 0);\n\tkernel_map_pages(page, 1 << order, 0);\n\tkasan_free_pages(page, order);\n\n\treturn true;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic __always_inline bool free_pages_prepare(struct page *page,\n\t\t\t\t\tunsigned int order, bool check_free)\n{\n\tint bad = 0;\n\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\n\ttrace_mm_page_free(page, order);\n\n\t/*\n\t * Check tail pages before head page information is cleared to\n\t * avoid checking PageCompound for order-0 pages.\n\t */\n\tif (unlikely(order)) {\n\t\tbool compound = PageCompound(page);\n\t\tint i;\n\n\t\tVM_BUG_ON_PAGE(compound && compound_order(page) != order, page);\n\n\t\tif (compound)\n\t\t\tClearPageDoubleMap(page);\n\t\tfor (i = 1; i < (1 << order); i++) {\n\t\t\tif (compound)\n\t\t\t\tbad += free_tail_pages_check(page, page + i);\n\t\t\tif (unlikely(free_pages_check(page + i))) {\n\t\t\t\tbad++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t(page + i)->flags &= ~PAGE_FLAGS_CHECK_AT_PREP;\n\t\t}\n\t}\n\tif (PageMappingFlags(page))\n\t\tpage->mapping = NULL;\n\tif (memcg_kmem_enabled() && PageKmemcg(page))\n\t\tmemcg_kmem_uncharge(page, order);\n\tif (check_free)\n\t\tbad += free_pages_check(page);\n\tif (bad)\n\t\treturn false;\n\n\tpage_cpupid_reset_last(page);\n\tpage->flags &= ~PAGE_FLAGS_CHECK_AT_PREP;\n\treset_page_owner(page, order);\n\n\tif (!PageHighMem(page)) {\n\t\tdebug_check_no_locks_freed(page_address(page),\n\t\t\t\t\t   PAGE_SIZE << order);\n\t\tdebug_check_no_obj_freed(page_address(page),\n\t\t\t\t\t   PAGE_SIZE << order);\n\t}\n\tarch_free_page(page, order);\n\tkernel_poison_pages(page, 1 << order, 0);\n\tkernel_map_pages(page, 1 << order, 0);\n\tkasan_free_pages(page, order);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "page"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic void __free_pages_ok(struct page *page, unsigned int order)\n{\n\tunsigned long flags;\n\tint migratetype;\n\tunsigned long pfn = page_to_pfn(page);\n\n\tif (!free_pages_prepare(page, order, true))\n\t\treturn;\n\n\tmigratetype = get_pfnblock_migratetype(page, pfn);\n\tlocal_irq_save(flags);\n\t__count_vm_events(PGFREE, 1 << order);\n\tfree_one_page(page_zone(page), page, pfn, order, migratetype);\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "reserve_bootmem_region",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "1227-1249",
    "snippet": "void __meminit reserve_bootmem_region(phys_addr_t start, phys_addr_t end)\n{\n\tunsigned long start_pfn = PFN_DOWN(start);\n\tunsigned long end_pfn = PFN_UP(end);\n\n\tfor (; start_pfn < end_pfn; start_pfn++) {\n\t\tif (pfn_valid(start_pfn)) {\n\t\t\tstruct page *page = pfn_to_page(start_pfn);\n\n\t\t\tinit_reserved_page(start_pfn);\n\n\t\t\t/* Avoid false-positive PageTail() */\n\t\t\tINIT_LIST_HEAD(&page->lru);\n\n\t\t\t/*\n\t\t\t * no need for atomic set_bit because the struct\n\t\t\t * page is not visible yet so nobody should\n\t\t\t * access it yet.\n\t\t\t */\n\t\t\t__SetPageReserved(page);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__SetPageReserved",
          "args": [
            "page"
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&page->lru"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_reserved_page",
          "args": [
            "start_pfn"
          ],
          "line": 1236
        },
        "resolved": true,
        "details": {
          "function_name": "init_reserved_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1216-1218",
          "snippet": "static inline void init_reserved_page(unsigned long pfn)\n{\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic inline void init_reserved_page(unsigned long pfn)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "start_pfn"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_valid",
          "args": [
            "start_pfn"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_UP",
          "args": [
            "end"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PFN_DOWN",
          "args": [
            "start"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid __meminit reserve_bootmem_region(phys_addr_t start, phys_addr_t end)\n{\n\tunsigned long start_pfn = PFN_DOWN(start);\n\tunsigned long end_pfn = PFN_UP(end);\n\n\tfor (; start_pfn < end_pfn; start_pfn++) {\n\t\tif (pfn_valid(start_pfn)) {\n\t\t\tstruct page *page = pfn_to_page(start_pfn);\n\n\t\t\tinit_reserved_page(start_pfn);\n\n\t\t\t/* Avoid false-positive PageTail() */\n\t\t\tINIT_LIST_HEAD(&page->lru);\n\n\t\t\t/*\n\t\t\t * no need for atomic set_bit because the struct\n\t\t\t * page is not visible yet so nobody should\n\t\t\t * access it yet.\n\t\t\t */\n\t\t\t__SetPageReserved(page);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "init_reserved_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "1216-1218",
    "snippet": "static inline void init_reserved_page(unsigned long pfn)\n{\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic inline void init_reserved_page(unsigned long pfn)\n{\n}"
  },
  {
    "function_name": "init_reserved_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "1196-1214",
    "snippet": "static void __meminit init_reserved_page(unsigned long pfn)\n{\n\tpg_data_t *pgdat;\n\tint nid, zid;\n\n\tif (!early_page_uninitialised(pfn))\n\t\treturn;\n\n\tnid = early_pfn_to_nid(pfn);\n\tpgdat = NODE_DATA(nid);\n\n\tfor (zid = 0; zid < MAX_NR_ZONES; zid++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zid];\n\n\t\tif (pfn >= zone->zone_start_pfn && pfn < zone_end_pfn(zone))\n\t\t\tbreak;\n\t}\n\t__init_single_page(pfn_to_page(pfn), pfn, zid, nid);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__init_single_page",
          "args": [
            "pfn_to_page(pfn)",
            "pfn",
            "zid",
            "nid"
          ],
          "line": 1213
        },
        "resolved": true,
        "details": {
          "function_name": "__init_single_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1178-1193",
          "snippet": "static void __meminit __init_single_page(struct page *page, unsigned long pfn,\n\t\t\t\tunsigned long zone, int nid)\n{\n\tmm_zero_struct_page(page);\n\tset_page_links(page, zone, nid, pfn);\n\tinit_page_count(page);\n\tpage_mapcount_reset(page);\n\tpage_cpupid_reset_last(page);\n\n\tINIT_LIST_HEAD(&page->lru);\n#ifdef WANT_PAGE_VIRTUAL\n\t/* The shift won't overflow because ZONE_NORMAL is below 4G. */\n\tif (!is_highmem_idx(zone))\n\t\tset_page_address(page, __va(pfn << PAGE_SHIFT));\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic void __meminit __init_single_page(struct page *page, unsigned long pfn,\n\t\t\t\tunsigned long zone, int nid)\n{\n\tmm_zero_struct_page(page);\n\tset_page_links(page, zone, nid, pfn);\n\tinit_page_count(page);\n\tpage_mapcount_reset(page);\n\tpage_cpupid_reset_last(page);\n\n\tINIT_LIST_HEAD(&page->lru);\n#ifdef WANT_PAGE_VIRTUAL\n\t/* The shift won't overflow because ZONE_NORMAL is below 4G. */\n\tif (!is_highmem_idx(zone))\n\t\tset_page_address(page, __va(pfn << PAGE_SHIFT));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_end_pfn",
          "args": [
            "zone"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "nid"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "early_pfn_to_nid",
          "args": [
            "pfn"
          ],
          "line": 1204
        },
        "resolved": true,
        "details": {
          "function_name": "early_pfn_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1292-1304",
          "snippet": "int __meminit early_pfn_to_nid(unsigned long pfn)\n{\n\tstatic DEFINE_SPINLOCK(early_pfn_lock);\n\tint nid;\n\n\tspin_lock(&early_pfn_lock);\n\tnid = __early_pfn_to_nid(pfn, &early_pfnnid_cache);\n\tif (nid < 0)\n\t\tnid = first_online_node;\n\tspin_unlock(&early_pfn_lock);\n\n\treturn nid;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nint __meminit early_pfn_to_nid(unsigned long pfn)\n{\n\tstatic DEFINE_SPINLOCK(early_pfn_lock);\n\tint nid;\n\n\tspin_lock(&early_pfn_lock);\n\tnid = __early_pfn_to_nid(pfn, &early_pfnnid_cache);\n\tif (nid < 0)\n\t\tnid = first_online_node;\n\tspin_unlock(&early_pfn_lock);\n\n\treturn nid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "early_page_uninitialised",
          "args": [
            "pfn"
          ],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "early_page_uninitialised",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "338-341",
          "snippet": "static inline bool early_page_uninitialised(unsigned long pfn)\n{\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic inline bool early_page_uninitialised(unsigned long pfn)\n{\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic void __meminit init_reserved_page(unsigned long pfn)\n{\n\tpg_data_t *pgdat;\n\tint nid, zid;\n\n\tif (!early_page_uninitialised(pfn))\n\t\treturn;\n\n\tnid = early_pfn_to_nid(pfn);\n\tpgdat = NODE_DATA(nid);\n\n\tfor (zid = 0; zid < MAX_NR_ZONES; zid++) {\n\t\tstruct zone *zone = &pgdat->node_zones[zid];\n\n\t\tif (pfn >= zone->zone_start_pfn && pfn < zone_end_pfn(zone))\n\t\t\tbreak;\n\t}\n\t__init_single_page(pfn_to_page(pfn), pfn, zid, nid);\n}"
  },
  {
    "function_name": "__init_single_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "1178-1193",
    "snippet": "static void __meminit __init_single_page(struct page *page, unsigned long pfn,\n\t\t\t\tunsigned long zone, int nid)\n{\n\tmm_zero_struct_page(page);\n\tset_page_links(page, zone, nid, pfn);\n\tinit_page_count(page);\n\tpage_mapcount_reset(page);\n\tpage_cpupid_reset_last(page);\n\n\tINIT_LIST_HEAD(&page->lru);\n#ifdef WANT_PAGE_VIRTUAL\n\t/* The shift won't overflow because ZONE_NORMAL is below 4G. */\n\tif (!is_highmem_idx(zone))\n\t\tset_page_address(page, __va(pfn << PAGE_SHIFT));\n#endif\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_page_address",
          "args": [
            "page",
            "__va(pfn << PAGE_SHIFT)"
          ],
          "line": 1191
        },
        "resolved": true,
        "details": {
          "function_name": "set_page_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
          "lines": "443-473",
          "snippet": "void set_page_address(struct page *page, void *virtual)\n{\n\tunsigned long flags;\n\tstruct page_address_slot *pas;\n\tstruct page_address_map *pam;\n\n\tBUG_ON(!PageHighMem(page));\n\n\tpas = page_slot(page);\n\tif (virtual) {\t\t/* Add */\n\t\tpam = &page_address_maps[PKMAP_NR((unsigned long)virtual)];\n\t\tpam->page = page;\n\t\tpam->virtual = virtual;\n\n\t\tspin_lock_irqsave(&pas->lock, flags);\n\t\tlist_add_tail(&pam->list, &pas->lh);\n\t\tspin_unlock_irqrestore(&pas->lock, flags);\n\t} else {\t\t/* Remove */\n\t\tspin_lock_irqsave(&pas->lock, flags);\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tlist_del(&pam->list);\n\t\t\t\tspin_unlock_irqrestore(&pas->lock, flags);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&pas->lock, flags);\n\t}\ndone:\n\treturn;\n}",
          "includes": [
            "#include <asm/tlbflush.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nvoid set_page_address(struct page *page, void *virtual)\n{\n\tunsigned long flags;\n\tstruct page_address_slot *pas;\n\tstruct page_address_map *pam;\n\n\tBUG_ON(!PageHighMem(page));\n\n\tpas = page_slot(page);\n\tif (virtual) {\t\t/* Add */\n\t\tpam = &page_address_maps[PKMAP_NR((unsigned long)virtual)];\n\t\tpam->page = page;\n\t\tpam->virtual = virtual;\n\n\t\tspin_lock_irqsave(&pas->lock, flags);\n\t\tlist_add_tail(&pam->list, &pas->lh);\n\t\tspin_unlock_irqrestore(&pas->lock, flags);\n\t} else {\t\t/* Remove */\n\t\tspin_lock_irqsave(&pas->lock, flags);\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tlist_del(&pam->list);\n\t\t\t\tspin_unlock_irqrestore(&pas->lock, flags);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&pas->lock, flags);\n\t}\ndone:\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__va",
          "args": [
            "pfn << PAGE_SHIFT"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_highmem_idx",
          "args": [
            "zone"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&page->lru"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cpupid_reset_last",
          "args": [
            "page"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapcount_reset",
          "args": [
            "page"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_page_count",
          "args": [
            "page"
          ],
          "line": 1183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_links",
          "args": [
            "page",
            "zone",
            "nid",
            "pfn"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_zero_struct_page",
          "args": [
            "page"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic void __meminit __init_single_page(struct page *page, unsigned long pfn,\n\t\t\t\tunsigned long zone, int nid)\n{\n\tmm_zero_struct_page(page);\n\tset_page_links(page, zone, nid, pfn);\n\tinit_page_count(page);\n\tpage_mapcount_reset(page);\n\tpage_cpupid_reset_last(page);\n\n\tINIT_LIST_HEAD(&page->lru);\n#ifdef WANT_PAGE_VIRTUAL\n\t/* The shift won't overflow because ZONE_NORMAL is below 4G. */\n\tif (!is_highmem_idx(zone))\n\t\tset_page_address(page, __va(pfn << PAGE_SHIFT));\n#endif\n}"
  },
  {
    "function_name": "free_one_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "1164-1176",
    "snippet": "static void free_one_page(struct zone *zone,\n\t\t\t\tstruct page *page, unsigned long pfn,\n\t\t\t\tunsigned int order,\n\t\t\t\tint migratetype)\n{\n\tspin_lock(&zone->lock);\n\tif (unlikely(has_isolate_pageblock(zone) ||\n\t\tis_migrate_isolate(migratetype))) {\n\t\tmigratetype = get_pfnblock_migratetype(page, pfn);\n\t}\n\t__free_one_page(page, pfn, zone, order, migratetype);\n\tspin_unlock(&zone->lock);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);",
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&zone->lock"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_one_page",
          "args": [
            "page",
            "pfn",
            "zone",
            "order",
            "migratetype"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "__free_one_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "778-878",
          "snippet": "static inline void __free_one_page(struct page *page,\n\t\tunsigned long pfn,\n\t\tstruct zone *zone, unsigned int order,\n\t\tint migratetype)\n{\n\tunsigned long combined_pfn;\n\tunsigned long uninitialized_var(buddy_pfn);\n\tstruct page *buddy;\n\tunsigned int max_order;\n\n\tmax_order = min_t(unsigned int, MAX_ORDER, pageblock_order + 1);\n\n\tVM_BUG_ON(!zone_is_initialized(zone));\n\tVM_BUG_ON_PAGE(page->flags & PAGE_FLAGS_CHECK_AT_PREP, page);\n\n\tVM_BUG_ON(migratetype == -1);\n\tif (likely(!is_migrate_isolate(migratetype)))\n\t\t__mod_zone_freepage_state(zone, 1 << order, migratetype);\n\n\tVM_BUG_ON_PAGE(pfn & ((1 << order) - 1), page);\n\tVM_BUG_ON_PAGE(bad_range(zone, page), page);\n\ncontinue_merging:\n\twhile (order < max_order - 1) {\n\t\tbuddy_pfn = __find_buddy_pfn(pfn, order);\n\t\tbuddy = page + (buddy_pfn - pfn);\n\n\t\tif (!pfn_valid_within(buddy_pfn))\n\t\t\tgoto done_merging;\n\t\tif (!page_is_buddy(page, buddy, order))\n\t\t\tgoto done_merging;\n\t\t/*\n\t\t * Our buddy is free or it is CONFIG_DEBUG_PAGEALLOC guard page,\n\t\t * merge with it and move up one order.\n\t\t */\n\t\tif (page_is_guard(buddy)) {\n\t\t\tclear_page_guard(zone, buddy, order, migratetype);\n\t\t} else {\n\t\t\tlist_del(&buddy->lru);\n\t\t\tzone->free_area[order].nr_free--;\n\t\t\trmv_page_order(buddy);\n\t\t}\n\t\tcombined_pfn = buddy_pfn & pfn;\n\t\tpage = page + (combined_pfn - pfn);\n\t\tpfn = combined_pfn;\n\t\torder++;\n\t}\n\tif (max_order < MAX_ORDER) {\n\t\t/* If we are here, it means order is >= pageblock_order.\n\t\t * We want to prevent merge between freepages on isolate\n\t\t * pageblock and normal pageblock. Without this, pageblock\n\t\t * isolation could cause incorrect freepage or CMA accounting.\n\t\t *\n\t\t * We don't want to hit this code for the more frequent\n\t\t * low-order merging.\n\t\t */\n\t\tif (unlikely(has_isolate_pageblock(zone))) {\n\t\t\tint buddy_mt;\n\n\t\t\tbuddy_pfn = __find_buddy_pfn(pfn, order);\n\t\t\tbuddy = page + (buddy_pfn - pfn);\n\t\t\tbuddy_mt = get_pageblock_migratetype(buddy);\n\n\t\t\tif (migratetype != buddy_mt\n\t\t\t\t\t&& (is_migrate_isolate(migratetype) ||\n\t\t\t\t\t\tis_migrate_isolate(buddy_mt)))\n\t\t\t\tgoto done_merging;\n\t\t}\n\t\tmax_order++;\n\t\tgoto continue_merging;\n\t}\n\ndone_merging:\n\tset_page_order(page, order);\n\n\t/*\n\t * If this is not the largest possible page, check if the buddy\n\t * of the next-highest order is free. If it is, it's possible\n\t * that pages are being freed that will coalesce soon. In case,\n\t * that is happening, add the free page to the tail of the list\n\t * so it's less likely to be used soon and more likely to be merged\n\t * as a higher order page\n\t */\n\tif ((order < MAX_ORDER-2) && pfn_valid_within(buddy_pfn)) {\n\t\tstruct page *higher_page, *higher_buddy;\n\t\tcombined_pfn = buddy_pfn & pfn;\n\t\thigher_page = page + (combined_pfn - pfn);\n\t\tbuddy_pfn = __find_buddy_pfn(combined_pfn, order + 1);\n\t\thigher_buddy = higher_page + (buddy_pfn - combined_pfn);\n\t\tif (pfn_valid_within(buddy_pfn) &&\n\t\t    page_is_buddy(higher_page, higher_buddy, order + 1)) {\n\t\t\tlist_add_tail(&page->lru,\n\t\t\t\t&zone->free_area[order].free_list[migratetype]);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tlist_add(&page->lru, &zone->free_area[order].free_list[migratetype]);\nout:\n\tzone->free_area[order].nr_free++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline void __free_one_page(struct page *page,\n\t\tunsigned long pfn,\n\t\tstruct zone *zone, unsigned int order,\n\t\tint migratetype)\n{\n\tunsigned long combined_pfn;\n\tunsigned long uninitialized_var(buddy_pfn);\n\tstruct page *buddy;\n\tunsigned int max_order;\n\n\tmax_order = min_t(unsigned int, MAX_ORDER, pageblock_order + 1);\n\n\tVM_BUG_ON(!zone_is_initialized(zone));\n\tVM_BUG_ON_PAGE(page->flags & PAGE_FLAGS_CHECK_AT_PREP, page);\n\n\tVM_BUG_ON(migratetype == -1);\n\tif (likely(!is_migrate_isolate(migratetype)))\n\t\t__mod_zone_freepage_state(zone, 1 << order, migratetype);\n\n\tVM_BUG_ON_PAGE(pfn & ((1 << order) - 1), page);\n\tVM_BUG_ON_PAGE(bad_range(zone, page), page);\n\ncontinue_merging:\n\twhile (order < max_order - 1) {\n\t\tbuddy_pfn = __find_buddy_pfn(pfn, order);\n\t\tbuddy = page + (buddy_pfn - pfn);\n\n\t\tif (!pfn_valid_within(buddy_pfn))\n\t\t\tgoto done_merging;\n\t\tif (!page_is_buddy(page, buddy, order))\n\t\t\tgoto done_merging;\n\t\t/*\n\t\t * Our buddy is free or it is CONFIG_DEBUG_PAGEALLOC guard page,\n\t\t * merge with it and move up one order.\n\t\t */\n\t\tif (page_is_guard(buddy)) {\n\t\t\tclear_page_guard(zone, buddy, order, migratetype);\n\t\t} else {\n\t\t\tlist_del(&buddy->lru);\n\t\t\tzone->free_area[order].nr_free--;\n\t\t\trmv_page_order(buddy);\n\t\t}\n\t\tcombined_pfn = buddy_pfn & pfn;\n\t\tpage = page + (combined_pfn - pfn);\n\t\tpfn = combined_pfn;\n\t\torder++;\n\t}\n\tif (max_order < MAX_ORDER) {\n\t\t/* If we are here, it means order is >= pageblock_order.\n\t\t * We want to prevent merge between freepages on isolate\n\t\t * pageblock and normal pageblock. Without this, pageblock\n\t\t * isolation could cause incorrect freepage or CMA accounting.\n\t\t *\n\t\t * We don't want to hit this code for the more frequent\n\t\t * low-order merging.\n\t\t */\n\t\tif (unlikely(has_isolate_pageblock(zone))) {\n\t\t\tint buddy_mt;\n\n\t\t\tbuddy_pfn = __find_buddy_pfn(pfn, order);\n\t\t\tbuddy = page + (buddy_pfn - pfn);\n\t\t\tbuddy_mt = get_pageblock_migratetype(buddy);\n\n\t\t\tif (migratetype != buddy_mt\n\t\t\t\t\t&& (is_migrate_isolate(migratetype) ||\n\t\t\t\t\t\tis_migrate_isolate(buddy_mt)))\n\t\t\t\tgoto done_merging;\n\t\t}\n\t\tmax_order++;\n\t\tgoto continue_merging;\n\t}\n\ndone_merging:\n\tset_page_order(page, order);\n\n\t/*\n\t * If this is not the largest possible page, check if the buddy\n\t * of the next-highest order is free. If it is, it's possible\n\t * that pages are being freed that will coalesce soon. In case,\n\t * that is happening, add the free page to the tail of the list\n\t * so it's less likely to be used soon and more likely to be merged\n\t * as a higher order page\n\t */\n\tif ((order < MAX_ORDER-2) && pfn_valid_within(buddy_pfn)) {\n\t\tstruct page *higher_page, *higher_buddy;\n\t\tcombined_pfn = buddy_pfn & pfn;\n\t\thigher_page = page + (combined_pfn - pfn);\n\t\tbuddy_pfn = __find_buddy_pfn(combined_pfn, order + 1);\n\t\thigher_buddy = higher_page + (buddy_pfn - combined_pfn);\n\t\tif (pfn_valid_within(buddy_pfn) &&\n\t\t    page_is_buddy(higher_page, higher_buddy, order + 1)) {\n\t\t\tlist_add_tail(&page->lru,\n\t\t\t\t&zone->free_area[order].free_list[migratetype]);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tlist_add(&page->lru, &zone->free_area[order].free_list[migratetype]);\nout:\n\tzone->free_area[order].nr_free++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pfnblock_migratetype",
          "args": [
            "page",
            "pfn"
          ],
          "line": 1172
        },
        "resolved": true,
        "details": {
          "function_name": "get_pfnblock_migratetype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "406-409",
          "snippet": "static __always_inline int get_pfnblock_migratetype(struct page *page, unsigned long pfn)\n{\n\treturn __get_pfnblock_flags_mask(page, pfn, PB_migrate_end, MIGRATETYPE_MASK);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic __always_inline int get_pfnblock_migratetype(struct page *page, unsigned long pfn)\n{\n\treturn __get_pfnblock_flags_mask(page, pfn, PB_migrate_end, MIGRATETYPE_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "has_isolate_pageblock(zone) ||\n\t\tis_migrate_isolate(migratetype)"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_migrate_isolate",
          "args": [
            "migratetype"
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_isolate_pageblock",
          "args": [
            "zone"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&zone->lock"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic void free_one_page(struct zone *zone,\n\t\t\t\tstruct page *page, unsigned long pfn,\n\t\t\t\tunsigned int order,\n\t\t\t\tint migratetype)\n{\n\tspin_lock(&zone->lock);\n\tif (unlikely(has_isolate_pageblock(zone) ||\n\t\tis_migrate_isolate(migratetype))) {\n\t\tmigratetype = get_pfnblock_migratetype(page, pfn);\n\t}\n\t__free_one_page(page, pfn, zone, order, migratetype);\n\tspin_unlock(&zone->lock);\n}"
  },
  {
    "function_name": "free_pcppages_bulk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "1087-1162",
    "snippet": "static void free_pcppages_bulk(struct zone *zone, int count,\n\t\t\t\t\tstruct per_cpu_pages *pcp)\n{\n\tint migratetype = 0;\n\tint batch_free = 0;\n\tint prefetch_nr = 0;\n\tbool isolated_pageblocks;\n\tstruct page *page, *tmp;\n\tLIST_HEAD(head);\n\n\twhile (count) {\n\t\tstruct list_head *list;\n\n\t\t/*\n\t\t * Remove pages from lists in a round-robin fashion. A\n\t\t * batch_free count is maintained that is incremented when an\n\t\t * empty list is encountered.  This is so more pages are freed\n\t\t * off fuller lists instead of spinning excessively around empty\n\t\t * lists\n\t\t */\n\t\tdo {\n\t\t\tbatch_free++;\n\t\t\tif (++migratetype == MIGRATE_PCPTYPES)\n\t\t\t\tmigratetype = 0;\n\t\t\tlist = &pcp->lists[migratetype];\n\t\t} while (list_empty(list));\n\n\t\t/* This is the only non-empty list. Free them all. */\n\t\tif (batch_free == MIGRATE_PCPTYPES)\n\t\t\tbatch_free = count;\n\n\t\tdo {\n\t\t\tpage = list_last_entry(list, struct page, lru);\n\t\t\t/* must delete to avoid corrupting pcp list */\n\t\t\tlist_del(&page->lru);\n\t\t\tpcp->count--;\n\n\t\t\tif (bulkfree_pcp_prepare(page))\n\t\t\t\tcontinue;\n\n\t\t\tlist_add_tail(&page->lru, &head);\n\n\t\t\t/*\n\t\t\t * We are going to put the page back to the global\n\t\t\t * pool, prefetch its buddy to speed up later access\n\t\t\t * under zone->lock. It is believed the overhead of\n\t\t\t * an additional test and calculating buddy_pfn here\n\t\t\t * can be offset by reduced memory latency later. To\n\t\t\t * avoid excessive prefetching due to large count, only\n\t\t\t * prefetch buddy for the first pcp->batch nr of pages.\n\t\t\t */\n\t\t\tif (prefetch_nr++ < pcp->batch)\n\t\t\t\tprefetch_buddy(page);\n\t\t} while (--count && --batch_free && !list_empty(list));\n\t}\n\n\tspin_lock(&zone->lock);\n\tisolated_pageblocks = has_isolate_pageblock(zone);\n\n\t/*\n\t * Use safe version since after __free_one_page(),\n\t * page->lru.next will not point to original list.\n\t */\n\tlist_for_each_entry_safe(page, tmp, &head, lru) {\n\t\tint mt = get_pcppage_migratetype(page);\n\t\t/* MIGRATE_ISOLATE page should not go to pcplists */\n\t\tVM_BUG_ON_PAGE(is_migrate_isolate(mt), page);\n\t\t/* Pageblock could have been isolated meanwhile */\n\t\tif (unlikely(isolated_pageblocks))\n\t\t\tmt = get_pageblock_migratetype(page);\n\n\t\t__free_one_page(page, page_to_pfn(page), zone, 0, mt);\n\t\ttrace_mm_page_pcpu_drain(page, 0, mt);\n\t}\n\tspin_unlock(&zone->lock);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&zone->lock"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_mm_page_pcpu_drain",
          "args": [
            "page",
            "0",
            "mt"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_one_page",
          "args": [
            "page",
            "page_to_pfn(page)",
            "zone",
            "0",
            "mt"
          ],
          "line": 1158
        },
        "resolved": true,
        "details": {
          "function_name": "__free_one_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "778-878",
          "snippet": "static inline void __free_one_page(struct page *page,\n\t\tunsigned long pfn,\n\t\tstruct zone *zone, unsigned int order,\n\t\tint migratetype)\n{\n\tunsigned long combined_pfn;\n\tunsigned long uninitialized_var(buddy_pfn);\n\tstruct page *buddy;\n\tunsigned int max_order;\n\n\tmax_order = min_t(unsigned int, MAX_ORDER, pageblock_order + 1);\n\n\tVM_BUG_ON(!zone_is_initialized(zone));\n\tVM_BUG_ON_PAGE(page->flags & PAGE_FLAGS_CHECK_AT_PREP, page);\n\n\tVM_BUG_ON(migratetype == -1);\n\tif (likely(!is_migrate_isolate(migratetype)))\n\t\t__mod_zone_freepage_state(zone, 1 << order, migratetype);\n\n\tVM_BUG_ON_PAGE(pfn & ((1 << order) - 1), page);\n\tVM_BUG_ON_PAGE(bad_range(zone, page), page);\n\ncontinue_merging:\n\twhile (order < max_order - 1) {\n\t\tbuddy_pfn = __find_buddy_pfn(pfn, order);\n\t\tbuddy = page + (buddy_pfn - pfn);\n\n\t\tif (!pfn_valid_within(buddy_pfn))\n\t\t\tgoto done_merging;\n\t\tif (!page_is_buddy(page, buddy, order))\n\t\t\tgoto done_merging;\n\t\t/*\n\t\t * Our buddy is free or it is CONFIG_DEBUG_PAGEALLOC guard page,\n\t\t * merge with it and move up one order.\n\t\t */\n\t\tif (page_is_guard(buddy)) {\n\t\t\tclear_page_guard(zone, buddy, order, migratetype);\n\t\t} else {\n\t\t\tlist_del(&buddy->lru);\n\t\t\tzone->free_area[order].nr_free--;\n\t\t\trmv_page_order(buddy);\n\t\t}\n\t\tcombined_pfn = buddy_pfn & pfn;\n\t\tpage = page + (combined_pfn - pfn);\n\t\tpfn = combined_pfn;\n\t\torder++;\n\t}\n\tif (max_order < MAX_ORDER) {\n\t\t/* If we are here, it means order is >= pageblock_order.\n\t\t * We want to prevent merge between freepages on isolate\n\t\t * pageblock and normal pageblock. Without this, pageblock\n\t\t * isolation could cause incorrect freepage or CMA accounting.\n\t\t *\n\t\t * We don't want to hit this code for the more frequent\n\t\t * low-order merging.\n\t\t */\n\t\tif (unlikely(has_isolate_pageblock(zone))) {\n\t\t\tint buddy_mt;\n\n\t\t\tbuddy_pfn = __find_buddy_pfn(pfn, order);\n\t\t\tbuddy = page + (buddy_pfn - pfn);\n\t\t\tbuddy_mt = get_pageblock_migratetype(buddy);\n\n\t\t\tif (migratetype != buddy_mt\n\t\t\t\t\t&& (is_migrate_isolate(migratetype) ||\n\t\t\t\t\t\tis_migrate_isolate(buddy_mt)))\n\t\t\t\tgoto done_merging;\n\t\t}\n\t\tmax_order++;\n\t\tgoto continue_merging;\n\t}\n\ndone_merging:\n\tset_page_order(page, order);\n\n\t/*\n\t * If this is not the largest possible page, check if the buddy\n\t * of the next-highest order is free. If it is, it's possible\n\t * that pages are being freed that will coalesce soon. In case,\n\t * that is happening, add the free page to the tail of the list\n\t * so it's less likely to be used soon and more likely to be merged\n\t * as a higher order page\n\t */\n\tif ((order < MAX_ORDER-2) && pfn_valid_within(buddy_pfn)) {\n\t\tstruct page *higher_page, *higher_buddy;\n\t\tcombined_pfn = buddy_pfn & pfn;\n\t\thigher_page = page + (combined_pfn - pfn);\n\t\tbuddy_pfn = __find_buddy_pfn(combined_pfn, order + 1);\n\t\thigher_buddy = higher_page + (buddy_pfn - combined_pfn);\n\t\tif (pfn_valid_within(buddy_pfn) &&\n\t\t    page_is_buddy(higher_page, higher_buddy, order + 1)) {\n\t\t\tlist_add_tail(&page->lru,\n\t\t\t\t&zone->free_area[order].free_list[migratetype]);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tlist_add(&page->lru, &zone->free_area[order].free_list[migratetype]);\nout:\n\tzone->free_area[order].nr_free++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline void __free_one_page(struct page *page,\n\t\tunsigned long pfn,\n\t\tstruct zone *zone, unsigned int order,\n\t\tint migratetype)\n{\n\tunsigned long combined_pfn;\n\tunsigned long uninitialized_var(buddy_pfn);\n\tstruct page *buddy;\n\tunsigned int max_order;\n\n\tmax_order = min_t(unsigned int, MAX_ORDER, pageblock_order + 1);\n\n\tVM_BUG_ON(!zone_is_initialized(zone));\n\tVM_BUG_ON_PAGE(page->flags & PAGE_FLAGS_CHECK_AT_PREP, page);\n\n\tVM_BUG_ON(migratetype == -1);\n\tif (likely(!is_migrate_isolate(migratetype)))\n\t\t__mod_zone_freepage_state(zone, 1 << order, migratetype);\n\n\tVM_BUG_ON_PAGE(pfn & ((1 << order) - 1), page);\n\tVM_BUG_ON_PAGE(bad_range(zone, page), page);\n\ncontinue_merging:\n\twhile (order < max_order - 1) {\n\t\tbuddy_pfn = __find_buddy_pfn(pfn, order);\n\t\tbuddy = page + (buddy_pfn - pfn);\n\n\t\tif (!pfn_valid_within(buddy_pfn))\n\t\t\tgoto done_merging;\n\t\tif (!page_is_buddy(page, buddy, order))\n\t\t\tgoto done_merging;\n\t\t/*\n\t\t * Our buddy is free or it is CONFIG_DEBUG_PAGEALLOC guard page,\n\t\t * merge with it and move up one order.\n\t\t */\n\t\tif (page_is_guard(buddy)) {\n\t\t\tclear_page_guard(zone, buddy, order, migratetype);\n\t\t} else {\n\t\t\tlist_del(&buddy->lru);\n\t\t\tzone->free_area[order].nr_free--;\n\t\t\trmv_page_order(buddy);\n\t\t}\n\t\tcombined_pfn = buddy_pfn & pfn;\n\t\tpage = page + (combined_pfn - pfn);\n\t\tpfn = combined_pfn;\n\t\torder++;\n\t}\n\tif (max_order < MAX_ORDER) {\n\t\t/* If we are here, it means order is >= pageblock_order.\n\t\t * We want to prevent merge between freepages on isolate\n\t\t * pageblock and normal pageblock. Without this, pageblock\n\t\t * isolation could cause incorrect freepage or CMA accounting.\n\t\t *\n\t\t * We don't want to hit this code for the more frequent\n\t\t * low-order merging.\n\t\t */\n\t\tif (unlikely(has_isolate_pageblock(zone))) {\n\t\t\tint buddy_mt;\n\n\t\t\tbuddy_pfn = __find_buddy_pfn(pfn, order);\n\t\t\tbuddy = page + (buddy_pfn - pfn);\n\t\t\tbuddy_mt = get_pageblock_migratetype(buddy);\n\n\t\t\tif (migratetype != buddy_mt\n\t\t\t\t\t&& (is_migrate_isolate(migratetype) ||\n\t\t\t\t\t\tis_migrate_isolate(buddy_mt)))\n\t\t\t\tgoto done_merging;\n\t\t}\n\t\tmax_order++;\n\t\tgoto continue_merging;\n\t}\n\ndone_merging:\n\tset_page_order(page, order);\n\n\t/*\n\t * If this is not the largest possible page, check if the buddy\n\t * of the next-highest order is free. If it is, it's possible\n\t * that pages are being freed that will coalesce soon. In case,\n\t * that is happening, add the free page to the tail of the list\n\t * so it's less likely to be used soon and more likely to be merged\n\t * as a higher order page\n\t */\n\tif ((order < MAX_ORDER-2) && pfn_valid_within(buddy_pfn)) {\n\t\tstruct page *higher_page, *higher_buddy;\n\t\tcombined_pfn = buddy_pfn & pfn;\n\t\thigher_page = page + (combined_pfn - pfn);\n\t\tbuddy_pfn = __find_buddy_pfn(combined_pfn, order + 1);\n\t\thigher_buddy = higher_page + (buddy_pfn - combined_pfn);\n\t\tif (pfn_valid_within(buddy_pfn) &&\n\t\t    page_is_buddy(higher_page, higher_buddy, order + 1)) {\n\t\t\tlist_add_tail(&page->lru,\n\t\t\t\t&zone->free_area[order].free_list[migratetype]);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tlist_add(&page->lru, &zone->free_area[order].free_list[migratetype]);\nout:\n\tzone->free_area[order].nr_free++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "page"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_pageblock_migratetype",
          "args": [
            "page"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "isolated_pageblocks"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "is_migrate_isolate(mt)",
            "page"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_migrate_isolate",
          "args": [
            "mt"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_pcppage_migratetype",
          "args": [
            "page"
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "get_pcppage_migratetype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "142-145",
          "snippet": "static inline int get_pcppage_migratetype(struct page *page)\n{\n\treturn page->index;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline int get_pcppage_migratetype(struct page *page)\n{\n\treturn page->index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "page",
            "tmp",
            "&head",
            "lru"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_isolate_pageblock",
          "args": [
            "zone"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&zone->lock"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "list"
          ],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/swapfile.c",
          "lines": "349-352",
          "snippet": "static inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}",
          "includes": [
            "#include <linux/swap_cgroup.h>",
            "#include <linux/swapops.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/sort.h>",
            "#include <linux/swap_slots.h>",
            "#include <linux/export.h>",
            "#include <linux/swapfile.h>",
            "#include <linux/frontswap.h>",
            "#include <linux/oom.h>",
            "#include <linux/poll.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/capability.h>",
            "#include <linux/mutex.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/security.h>",
            "#include <linux/rmap.h>",
            "#include <linux/ksm.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/swap.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/swap_cgroup.h>\n#include <linux/swapops.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <linux/sort.h>\n#include <linux/swap_slots.h>\n#include <linux/export.h>\n#include <linux/swapfile.h>\n#include <linux/frontswap.h>\n#include <linux/oom.h>\n#include <linux/poll.h>\n#include <linux/memcontrol.h>\n#include <linux/syscalls.h>\n#include <linux/capability.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/security.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/writeback.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/shmem_fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/swap.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n\nstatic inline bool cluster_list_empty(struct swap_cluster_list *list)\n{\n\treturn cluster_is_null(&list->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prefetch_buddy",
          "args": [
            "page"
          ],
          "line": 1139
        },
        "resolved": true,
        "details": {
          "function_name": "prefetch_buddy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1067-1074",
          "snippet": "static inline void prefetch_buddy(struct page *page)\n{\n\tunsigned long pfn = page_to_pfn(page);\n\tunsigned long buddy_pfn = __find_buddy_pfn(pfn, 0);\n\tstruct page *buddy = page + (buddy_pfn - pfn);\n\n\tprefetch(buddy);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline void prefetch_buddy(struct page *page)\n{\n\tunsigned long pfn = page_to_pfn(page);\n\tunsigned long buddy_pfn = __find_buddy_pfn(pfn, 0);\n\tstruct page *buddy = page + (buddy_pfn - pfn);\n\n\tprefetch(buddy);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&page->lru",
            "&head"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bulkfree_pcp_prepare",
          "args": [
            "page"
          ],
          "line": 1124
        },
        "resolved": true,
        "details": {
          "function_name": "bulkfree_pcp_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1061-1064",
          "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&page->lru"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_last_entry",
          "args": [
            "list",
            "structpage",
            "lru"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "head"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic void free_pcppages_bulk(struct zone *zone, int count,\n\t\t\t\t\tstruct per_cpu_pages *pcp)\n{\n\tint migratetype = 0;\n\tint batch_free = 0;\n\tint prefetch_nr = 0;\n\tbool isolated_pageblocks;\n\tstruct page *page, *tmp;\n\tLIST_HEAD(head);\n\n\twhile (count) {\n\t\tstruct list_head *list;\n\n\t\t/*\n\t\t * Remove pages from lists in a round-robin fashion. A\n\t\t * batch_free count is maintained that is incremented when an\n\t\t * empty list is encountered.  This is so more pages are freed\n\t\t * off fuller lists instead of spinning excessively around empty\n\t\t * lists\n\t\t */\n\t\tdo {\n\t\t\tbatch_free++;\n\t\t\tif (++migratetype == MIGRATE_PCPTYPES)\n\t\t\t\tmigratetype = 0;\n\t\t\tlist = &pcp->lists[migratetype];\n\t\t} while (list_empty(list));\n\n\t\t/* This is the only non-empty list. Free them all. */\n\t\tif (batch_free == MIGRATE_PCPTYPES)\n\t\t\tbatch_free = count;\n\n\t\tdo {\n\t\t\tpage = list_last_entry(list, struct page, lru);\n\t\t\t/* must delete to avoid corrupting pcp list */\n\t\t\tlist_del(&page->lru);\n\t\t\tpcp->count--;\n\n\t\t\tif (bulkfree_pcp_prepare(page))\n\t\t\t\tcontinue;\n\n\t\t\tlist_add_tail(&page->lru, &head);\n\n\t\t\t/*\n\t\t\t * We are going to put the page back to the global\n\t\t\t * pool, prefetch its buddy to speed up later access\n\t\t\t * under zone->lock. It is believed the overhead of\n\t\t\t * an additional test and calculating buddy_pfn here\n\t\t\t * can be offset by reduced memory latency later. To\n\t\t\t * avoid excessive prefetching due to large count, only\n\t\t\t * prefetch buddy for the first pcp->batch nr of pages.\n\t\t\t */\n\t\t\tif (prefetch_nr++ < pcp->batch)\n\t\t\t\tprefetch_buddy(page);\n\t\t} while (--count && --batch_free && !list_empty(list));\n\t}\n\n\tspin_lock(&zone->lock);\n\tisolated_pageblocks = has_isolate_pageblock(zone);\n\n\t/*\n\t * Use safe version since after __free_one_page(),\n\t * page->lru.next will not point to original list.\n\t */\n\tlist_for_each_entry_safe(page, tmp, &head, lru) {\n\t\tint mt = get_pcppage_migratetype(page);\n\t\t/* MIGRATE_ISOLATE page should not go to pcplists */\n\t\tVM_BUG_ON_PAGE(is_migrate_isolate(mt), page);\n\t\t/* Pageblock could have been isolated meanwhile */\n\t\tif (unlikely(isolated_pageblocks))\n\t\t\tmt = get_pageblock_migratetype(page);\n\n\t\t__free_one_page(page, page_to_pfn(page), zone, 0, mt);\n\t\ttrace_mm_page_pcpu_drain(page, 0, mt);\n\t}\n\tspin_unlock(&zone->lock);\n}"
  },
  {
    "function_name": "prefetch_buddy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "1067-1074",
    "snippet": "static inline void prefetch_buddy(struct page *page)\n{\n\tunsigned long pfn = page_to_pfn(page);\n\tunsigned long buddy_pfn = __find_buddy_pfn(pfn, 0);\n\tstruct page *buddy = page + (buddy_pfn - pfn);\n\n\tprefetch(buddy);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "prefetch",
          "args": [
            "buddy"
          ],
          "line": 1073
        },
        "resolved": true,
        "details": {
          "function_name": "prefetch_buddy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1067-1074",
          "snippet": "static inline void prefetch_buddy(struct page *page)\n{\n\tunsigned long pfn = page_to_pfn(page);\n\tunsigned long buddy_pfn = __find_buddy_pfn(pfn, 0);\n\tstruct page *buddy = page + (buddy_pfn - pfn);\n\n\tprefetch(buddy);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "__find_buddy_pfn",
          "args": [
            "pfn",
            "0"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "__find_buddy_pfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "145-149",
          "snippet": "static inline unsigned long\n__find_buddy_pfn(unsigned long page_pfn, unsigned int order)\n{\n\treturn page_pfn ^ (1 << order);\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline unsigned long\n__find_buddy_pfn(unsigned long page_pfn, unsigned int order)\n{\n\treturn page_pfn ^ (1 << order);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "page"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline void prefetch_buddy(struct page *page)\n{\n\tunsigned long pfn = page_to_pfn(page);\n\tunsigned long buddy_pfn = __find_buddy_pfn(pfn, 0);\n\tstruct page *buddy = page + (buddy_pfn - pfn);\n\n\tprefetch(buddy);\n}"
  },
  {
    "function_name": "bulkfree_pcp_prepare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "1061-1064",
    "snippet": "static bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_pages_check",
          "args": [
            "page"
          ],
          "line": 1063
        },
        "resolved": true,
        "details": {
          "function_name": "free_pages_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "927-935",
          "snippet": "static inline int free_pages_check(struct page *page)\n{\n\tif (likely(page_expected_state(page, PAGE_FLAGS_CHECK_AT_FREE)))\n\t\treturn 0;\n\n\t/* Something has gone sideways, find it */\n\tfree_pages_check_bad(page);\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline int free_pages_check(struct page *page)\n{\n\tif (likely(page_expected_state(page, PAGE_FLAGS_CHECK_AT_FREE)))\n\t\treturn 0;\n\n\t/* Something has gone sideways, find it */\n\tfree_pages_check_bad(page);\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn free_pages_check(page);\n}"
  },
  {
    "function_name": "free_pcp_prepare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "1056-1059",
    "snippet": "static bool free_pcp_prepare(struct page *page)\n{\n\treturn free_pages_prepare(page, 0, false);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_pages_prepare",
          "args": [
            "page",
            "0",
            "false"
          ],
          "line": 1058
        },
        "resolved": true,
        "details": {
          "function_name": "free_pages_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "987-1043",
          "snippet": "static __always_inline bool free_pages_prepare(struct page *page,\n\t\t\t\t\tunsigned int order, bool check_free)\n{\n\tint bad = 0;\n\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\n\ttrace_mm_page_free(page, order);\n\n\t/*\n\t * Check tail pages before head page information is cleared to\n\t * avoid checking PageCompound for order-0 pages.\n\t */\n\tif (unlikely(order)) {\n\t\tbool compound = PageCompound(page);\n\t\tint i;\n\n\t\tVM_BUG_ON_PAGE(compound && compound_order(page) != order, page);\n\n\t\tif (compound)\n\t\t\tClearPageDoubleMap(page);\n\t\tfor (i = 1; i < (1 << order); i++) {\n\t\t\tif (compound)\n\t\t\t\tbad += free_tail_pages_check(page, page + i);\n\t\t\tif (unlikely(free_pages_check(page + i))) {\n\t\t\t\tbad++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t(page + i)->flags &= ~PAGE_FLAGS_CHECK_AT_PREP;\n\t\t}\n\t}\n\tif (PageMappingFlags(page))\n\t\tpage->mapping = NULL;\n\tif (memcg_kmem_enabled() && PageKmemcg(page))\n\t\tmemcg_kmem_uncharge(page, order);\n\tif (check_free)\n\t\tbad += free_pages_check(page);\n\tif (bad)\n\t\treturn false;\n\n\tpage_cpupid_reset_last(page);\n\tpage->flags &= ~PAGE_FLAGS_CHECK_AT_PREP;\n\treset_page_owner(page, order);\n\n\tif (!PageHighMem(page)) {\n\t\tdebug_check_no_locks_freed(page_address(page),\n\t\t\t\t\t   PAGE_SIZE << order);\n\t\tdebug_check_no_obj_freed(page_address(page),\n\t\t\t\t\t   PAGE_SIZE << order);\n\t}\n\tarch_free_page(page, order);\n\tkernel_poison_pages(page, 1 << order, 0);\n\tkernel_map_pages(page, 1 << order, 0);\n\tkasan_free_pages(page, order);\n\n\treturn true;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic __always_inline bool free_pages_prepare(struct page *page,\n\t\t\t\t\tunsigned int order, bool check_free)\n{\n\tint bad = 0;\n\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\n\ttrace_mm_page_free(page, order);\n\n\t/*\n\t * Check tail pages before head page information is cleared to\n\t * avoid checking PageCompound for order-0 pages.\n\t */\n\tif (unlikely(order)) {\n\t\tbool compound = PageCompound(page);\n\t\tint i;\n\n\t\tVM_BUG_ON_PAGE(compound && compound_order(page) != order, page);\n\n\t\tif (compound)\n\t\t\tClearPageDoubleMap(page);\n\t\tfor (i = 1; i < (1 << order); i++) {\n\t\t\tif (compound)\n\t\t\t\tbad += free_tail_pages_check(page, page + i);\n\t\t\tif (unlikely(free_pages_check(page + i))) {\n\t\t\t\tbad++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t(page + i)->flags &= ~PAGE_FLAGS_CHECK_AT_PREP;\n\t\t}\n\t}\n\tif (PageMappingFlags(page))\n\t\tpage->mapping = NULL;\n\tif (memcg_kmem_enabled() && PageKmemcg(page))\n\t\tmemcg_kmem_uncharge(page, order);\n\tif (check_free)\n\t\tbad += free_pages_check(page);\n\tif (bad)\n\t\treturn false;\n\n\tpage_cpupid_reset_last(page);\n\tpage->flags &= ~PAGE_FLAGS_CHECK_AT_PREP;\n\treset_page_owner(page, order);\n\n\tif (!PageHighMem(page)) {\n\t\tdebug_check_no_locks_freed(page_address(page),\n\t\t\t\t\t   PAGE_SIZE << order);\n\t\tdebug_check_no_obj_freed(page_address(page),\n\t\t\t\t\t   PAGE_SIZE << order);\n\t}\n\tarch_free_page(page, order);\n\tkernel_poison_pages(page, 1 << order, 0);\n\tkernel_map_pages(page, 1 << order, 0);\n\tkasan_free_pages(page, order);\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic bool free_pcp_prepare(struct page *page)\n{\n\treturn free_pages_prepare(page, 0, false);\n}"
  },
  {
    "function_name": "bulkfree_pcp_prepare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "1051-1054",
    "snippet": "static inline bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn false;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline bool bulkfree_pcp_prepare(struct page *page)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "free_pcp_prepare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "1046-1049",
    "snippet": "static inline bool free_pcp_prepare(struct page *page)\n{\n\treturn free_pages_prepare(page, 0, true);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_pages_prepare",
          "args": [
            "page",
            "0",
            "true"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "free_pages_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "987-1043",
          "snippet": "static __always_inline bool free_pages_prepare(struct page *page,\n\t\t\t\t\tunsigned int order, bool check_free)\n{\n\tint bad = 0;\n\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\n\ttrace_mm_page_free(page, order);\n\n\t/*\n\t * Check tail pages before head page information is cleared to\n\t * avoid checking PageCompound for order-0 pages.\n\t */\n\tif (unlikely(order)) {\n\t\tbool compound = PageCompound(page);\n\t\tint i;\n\n\t\tVM_BUG_ON_PAGE(compound && compound_order(page) != order, page);\n\n\t\tif (compound)\n\t\t\tClearPageDoubleMap(page);\n\t\tfor (i = 1; i < (1 << order); i++) {\n\t\t\tif (compound)\n\t\t\t\tbad += free_tail_pages_check(page, page + i);\n\t\t\tif (unlikely(free_pages_check(page + i))) {\n\t\t\t\tbad++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t(page + i)->flags &= ~PAGE_FLAGS_CHECK_AT_PREP;\n\t\t}\n\t}\n\tif (PageMappingFlags(page))\n\t\tpage->mapping = NULL;\n\tif (memcg_kmem_enabled() && PageKmemcg(page))\n\t\tmemcg_kmem_uncharge(page, order);\n\tif (check_free)\n\t\tbad += free_pages_check(page);\n\tif (bad)\n\t\treturn false;\n\n\tpage_cpupid_reset_last(page);\n\tpage->flags &= ~PAGE_FLAGS_CHECK_AT_PREP;\n\treset_page_owner(page, order);\n\n\tif (!PageHighMem(page)) {\n\t\tdebug_check_no_locks_freed(page_address(page),\n\t\t\t\t\t   PAGE_SIZE << order);\n\t\tdebug_check_no_obj_freed(page_address(page),\n\t\t\t\t\t   PAGE_SIZE << order);\n\t}\n\tarch_free_page(page, order);\n\tkernel_poison_pages(page, 1 << order, 0);\n\tkernel_map_pages(page, 1 << order, 0);\n\tkasan_free_pages(page, order);\n\n\treturn true;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic __always_inline bool free_pages_prepare(struct page *page,\n\t\t\t\t\tunsigned int order, bool check_free)\n{\n\tint bad = 0;\n\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\n\ttrace_mm_page_free(page, order);\n\n\t/*\n\t * Check tail pages before head page information is cleared to\n\t * avoid checking PageCompound for order-0 pages.\n\t */\n\tif (unlikely(order)) {\n\t\tbool compound = PageCompound(page);\n\t\tint i;\n\n\t\tVM_BUG_ON_PAGE(compound && compound_order(page) != order, page);\n\n\t\tif (compound)\n\t\t\tClearPageDoubleMap(page);\n\t\tfor (i = 1; i < (1 << order); i++) {\n\t\t\tif (compound)\n\t\t\t\tbad += free_tail_pages_check(page, page + i);\n\t\t\tif (unlikely(free_pages_check(page + i))) {\n\t\t\t\tbad++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t(page + i)->flags &= ~PAGE_FLAGS_CHECK_AT_PREP;\n\t\t}\n\t}\n\tif (PageMappingFlags(page))\n\t\tpage->mapping = NULL;\n\tif (memcg_kmem_enabled() && PageKmemcg(page))\n\t\tmemcg_kmem_uncharge(page, order);\n\tif (check_free)\n\t\tbad += free_pages_check(page);\n\tif (bad)\n\t\treturn false;\n\n\tpage_cpupid_reset_last(page);\n\tpage->flags &= ~PAGE_FLAGS_CHECK_AT_PREP;\n\treset_page_owner(page, order);\n\n\tif (!PageHighMem(page)) {\n\t\tdebug_check_no_locks_freed(page_address(page),\n\t\t\t\t\t   PAGE_SIZE << order);\n\t\tdebug_check_no_obj_freed(page_address(page),\n\t\t\t\t\t   PAGE_SIZE << order);\n\t}\n\tarch_free_page(page, order);\n\tkernel_poison_pages(page, 1 << order, 0);\n\tkernel_map_pages(page, 1 << order, 0);\n\tkasan_free_pages(page, order);\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline bool free_pcp_prepare(struct page *page)\n{\n\treturn free_pages_prepare(page, 0, true);\n}"
  },
  {
    "function_name": "free_pages_prepare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "987-1043",
    "snippet": "static __always_inline bool free_pages_prepare(struct page *page,\n\t\t\t\t\tunsigned int order, bool check_free)\n{\n\tint bad = 0;\n\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\n\ttrace_mm_page_free(page, order);\n\n\t/*\n\t * Check tail pages before head page information is cleared to\n\t * avoid checking PageCompound for order-0 pages.\n\t */\n\tif (unlikely(order)) {\n\t\tbool compound = PageCompound(page);\n\t\tint i;\n\n\t\tVM_BUG_ON_PAGE(compound && compound_order(page) != order, page);\n\n\t\tif (compound)\n\t\t\tClearPageDoubleMap(page);\n\t\tfor (i = 1; i < (1 << order); i++) {\n\t\t\tif (compound)\n\t\t\t\tbad += free_tail_pages_check(page, page + i);\n\t\t\tif (unlikely(free_pages_check(page + i))) {\n\t\t\t\tbad++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t(page + i)->flags &= ~PAGE_FLAGS_CHECK_AT_PREP;\n\t\t}\n\t}\n\tif (PageMappingFlags(page))\n\t\tpage->mapping = NULL;\n\tif (memcg_kmem_enabled() && PageKmemcg(page))\n\t\tmemcg_kmem_uncharge(page, order);\n\tif (check_free)\n\t\tbad += free_pages_check(page);\n\tif (bad)\n\t\treturn false;\n\n\tpage_cpupid_reset_last(page);\n\tpage->flags &= ~PAGE_FLAGS_CHECK_AT_PREP;\n\treset_page_owner(page, order);\n\n\tif (!PageHighMem(page)) {\n\t\tdebug_check_no_locks_freed(page_address(page),\n\t\t\t\t\t   PAGE_SIZE << order);\n\t\tdebug_check_no_obj_freed(page_address(page),\n\t\t\t\t\t   PAGE_SIZE << order);\n\t}\n\tarch_free_page(page, order);\n\tkernel_poison_pages(page, 1 << order, 0);\n\tkernel_map_pages(page, 1 << order, 0);\n\tkasan_free_pages(page, order);\n\n\treturn true;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);",
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kasan_free_pages",
          "args": [
            "page",
            "order"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "kasan_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kasan/kasan.c",
          "lines": "314-320",
          "snippet": "void kasan_free_pages(struct page *page, unsigned int order)\n{\n\tif (likely(!PageHighMem(page)))\n\t\tkasan_poison_shadow(page_address(page),\n\t\t\t\tPAGE_SIZE << order,\n\t\t\t\tKASAN_FREE_PAGE);\n}",
          "includes": [
            "#include \"../slab.h\"",
            "#include \"kasan.h\"",
            "#include <linux/bug.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/types.h>",
            "#include <linux/string.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/memory.h>",
            "#include <linux/memblock.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kasan.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../slab.h\"\n#include \"kasan.h\"\n#include <linux/bug.h>\n#include <linux/vmalloc.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/memory.h>\n#include <linux/memblock.h>\n#include <linux/linkage.h>\n#include <linux/kmemleak.h>\n#include <linux/kernel.h>\n#include <linux/kasan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n\nvoid kasan_free_pages(struct page *page, unsigned int order)\n{\n\tif (likely(!PageHighMem(page)))\n\t\tkasan_poison_shadow(page_address(page),\n\t\t\t\tPAGE_SIZE << order,\n\t\t\t\tKASAN_FREE_PAGE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernel_map_pages",
          "args": [
            "page",
            "1 << order",
            "0"
          ],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "__kernel_map_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_poison.c",
          "lines": "126-129",
          "snippet": "void __kernel_map_pages(struct page *page, int numpages, int enable)\n{\n\t/* This function does nothing, all work is done via poison pages */\n}",
          "includes": [
            "#include <linux/ratelimit.h>",
            "#include <linux/poison.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ratelimit.h>\n#include <linux/poison.h>\n#include <linux/page_ext.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nvoid __kernel_map_pages(struct page *page, int numpages, int enable)\n{\n\t/* This function does nothing, all work is done via poison pages */\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernel_poison_pages",
          "args": [
            "page",
            "1 << order",
            "0"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_poison_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_poison.c",
          "lines": "114-123",
          "snippet": "void kernel_poison_pages(struct page *page, int numpages, int enable)\n{\n\tif (!page_poisoning_enabled())\n\t\treturn;\n\n\tif (enable)\n\t\tunpoison_pages(page, numpages);\n\telse\n\t\tpoison_pages(page, numpages);\n}",
          "includes": [
            "#include <linux/ratelimit.h>",
            "#include <linux/poison.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ratelimit.h>\n#include <linux/poison.h>\n#include <linux/page_ext.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nvoid kernel_poison_pages(struct page *page, int numpages, int enable)\n{\n\tif (!page_poisoning_enabled())\n\t\treturn;\n\n\tif (enable)\n\t\tunpoison_pages(page, numpages);\n\telse\n\t\tpoison_pages(page, numpages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_free_page",
          "args": [
            "page",
            "order"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_check_no_obj_freed",
          "args": [
            "page_address(page)",
            "PAGE_SIZE << order"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "page_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/highmem.c",
          "lines": "409-434",
          "snippet": "void *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/tlbflush.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/highmem.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mempool.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/bio.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tlbflush.h>\n#include <linux/kgdb.h>\n#include <linux/highmem.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/mempool.h>\n#include <linux/pagemap.h>\n#include <linux/bio.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nvoid *page_address(const struct page *page)\n{\n\tunsigned long flags;\n\tvoid *ret;\n\tstruct page_address_slot *pas;\n\n\tif (!PageHighMem(page))\n\t\treturn lowmem_page_address(page);\n\n\tpas = page_slot(page);\n\tret = NULL;\n\tspin_lock_irqsave(&pas->lock, flags);\n\tif (!list_empty(&pas->lh)) {\n\t\tstruct page_address_map *pam;\n\n\t\tlist_for_each_entry(pam, &pas->lh, list) {\n\t\t\tif (pam->page == page) {\n\t\t\t\tret = pam->virtual;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore(&pas->lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_check_no_locks_freed",
          "args": [
            "page_address(page)",
            "PAGE_SIZE << order"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageHighMem",
          "args": [
            "page"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reset_page_owner",
          "args": [
            "page",
            "order"
          ],
          "line": 1029
        },
        "resolved": true,
        "details": {
          "function_name": "__reset_page_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_owner.c",
          "lines": "110-121",
          "snippet": "void __reset_page_owner(struct page *page, unsigned int order)\n{\n\tint i;\n\tstruct page_ext *page_ext;\n\n\tfor (i = 0; i < (1 << order); i++) {\n\t\tpage_ext = lookup_page_ext(page + i);\n\t\tif (unlikely(!page_ext))\n\t\t\tcontinue;\n\t\t__clear_bit(PAGE_EXT_OWNER, &page_ext->flags);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/stackdepot.h>",
            "#include <linux/migrate.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/stackdepot.h>\n#include <linux/migrate.h>\n#include <linux/jump_label.h>\n#include <linux/page_owner.h>\n#include <linux/stacktrace.h>\n#include <linux/memblock.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/debugfs.h>\n\nvoid __reset_page_owner(struct page *page, unsigned int order)\n{\n\tint i;\n\tstruct page_ext *page_ext;\n\n\tfor (i = 0; i < (1 << order); i++) {\n\t\tpage_ext = lookup_page_ext(page + i);\n\t\tif (unlikely(!page_ext))\n\t\t\tcontinue;\n\t\t__clear_bit(PAGE_EXT_OWNER, &page_ext->flags);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cpupid_reset_last",
          "args": [
            "page"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_pages_check",
          "args": [
            "page"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "free_pages_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "927-935",
          "snippet": "static inline int free_pages_check(struct page *page)\n{\n\tif (likely(page_expected_state(page, PAGE_FLAGS_CHECK_AT_FREE)))\n\t\treturn 0;\n\n\t/* Something has gone sideways, find it */\n\tfree_pages_check_bad(page);\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline int free_pages_check(struct page *page)\n{\n\tif (likely(page_expected_state(page, PAGE_FLAGS_CHECK_AT_FREE)))\n\t\treturn 0;\n\n\t/* Something has gone sideways, find it */\n\tfree_pages_check_bad(page);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcg_kmem_uncharge",
          "args": [
            "page",
            "order"
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "memcg_kmem_uncharge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memcontrol.c",
          "lines": "2613-2637",
          "snippet": "void memcg_kmem_uncharge(struct page *page, int order)\n{\n\tstruct mem_cgroup *memcg = page->mem_cgroup;\n\tunsigned int nr_pages = 1 << order;\n\n\tif (!memcg)\n\t\treturn;\n\n\tVM_BUG_ON_PAGE(mem_cgroup_is_root(memcg), page);\n\n\tif (!cgroup_subsys_on_dfl(memory_cgrp_subsys))\n\t\tpage_counter_uncharge(&memcg->kmem, nr_pages);\n\n\tpage_counter_uncharge(&memcg->memory, nr_pages);\n\tif (do_memsw_account())\n\t\tpage_counter_uncharge(&memcg->memsw, nr_pages);\n\n\tpage->mem_cgroup = NULL;\n\n\t/* slab pages do not have PageKmemcg flag set */\n\tif (PageKmemcg(page))\n\t\t__ClearPageKmemcg(page);\n\n\tcss_put_many(&memcg->css, nr_pages);\n}",
          "includes": [
            "#include <trace/events/vmscan.h>",
            "#include <linux/uaccess.h>",
            "#include \"slab.h\"",
            "#include <net/ip.h>",
            "#include <net/sock.h>",
            "#include \"internal.h\"",
            "#include <linux/tracehook.h>",
            "#include <linux/file.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/swap_cgroup.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/vmpressure.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/poll.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/limits.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/smp.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/page_counter.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_subsys memory_cgrp_subsys",
            "static void mem_cgroup_threshold(struct mem_cgroup *memcg);",
            "static void mem_cgroup_oom_notify(struct mem_cgroup *memcg);",
            "static __always_inline struct",
            "struct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/vmscan.h>\n#include <linux/uaccess.h>\n#include \"slab.h\"\n#include <net/ip.h>\n#include <net/sock.h>\n#include \"internal.h\"\n#include <linux/tracehook.h>\n#include <linux/file.h>\n#include <linux/lockdep.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/swap_cgroup.h>\n#include <linux/mm_inline.h>\n#include <linux/vmpressure.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n#include <linux/spinlock.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/limits.h>\n#include <linux/rcupdate.h>\n#include <linux/bit_spinlock.h>\n#include <linux/backing-dev.h>\n#include <linux/page-flags.h>\n#include <linux/smp.h>\n#include <linux/pagemap.h>\n#include <linux/hugetlb.h>\n#include <linux/shmem_fs.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/cgroup.h>\n#include <linux/memcontrol.h>\n#include <linux/page_counter.h>\n\nstruct cgroup_subsys memory_cgrp_subsys;\nstatic void mem_cgroup_threshold(struct mem_cgroup *memcg);\nstatic void mem_cgroup_oom_notify(struct mem_cgroup *memcg);\nstatic __always_inline struct;\nstruct cgroup_subsys memory_cgrp_subsys = {\n\t.css_alloc = mem_cgroup_css_alloc,\n\t.css_online = mem_cgroup_css_online,\n\t.css_offline = mem_cgroup_css_offline,\n\t.css_released = mem_cgroup_css_released,\n\t.css_free = mem_cgroup_css_free,\n\t.css_reset = mem_cgroup_css_reset,\n\t.can_attach = mem_cgroup_can_attach,\n\t.cancel_attach = mem_cgroup_cancel_attach,\n\t.post_attach = mem_cgroup_move_task,\n\t.bind = mem_cgroup_bind,\n\t.dfl_cftypes = memory_files,\n\t.legacy_cftypes = mem_cgroup_legacy_files,\n\t.early_init = 0,\n};\n\nvoid memcg_kmem_uncharge(struct page *page, int order)\n{\n\tstruct mem_cgroup *memcg = page->mem_cgroup;\n\tunsigned int nr_pages = 1 << order;\n\n\tif (!memcg)\n\t\treturn;\n\n\tVM_BUG_ON_PAGE(mem_cgroup_is_root(memcg), page);\n\n\tif (!cgroup_subsys_on_dfl(memory_cgrp_subsys))\n\t\tpage_counter_uncharge(&memcg->kmem, nr_pages);\n\n\tpage_counter_uncharge(&memcg->memory, nr_pages);\n\tif (do_memsw_account())\n\t\tpage_counter_uncharge(&memcg->memsw, nr_pages);\n\n\tpage->mem_cgroup = NULL;\n\n\t/* slab pages do not have PageKmemcg flag set */\n\tif (PageKmemcg(page))\n\t\t__ClearPageKmemcg(page);\n\n\tcss_put_many(&memcg->css, nr_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageKmemcg",
          "args": [
            "page"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcg_kmem_enabled",
          "args": [],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageMappingFlags",
          "args": [
            "page"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "free_pages_check(page + i)"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_tail_pages_check",
          "args": [
            "page",
            "page + i"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "free_tail_pages_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "937-985",
          "snippet": "static int free_tail_pages_check(struct page *head_page, struct page *page)\n{\n\tint ret = 1;\n\n\t/*\n\t * We rely page->lru.next never has bit 0 set, unless the page\n\t * is PageTail(). Let's make sure that's true even for poisoned ->lru.\n\t */\n\tBUILD_BUG_ON((unsigned long)LIST_POISON1 & 1);\n\n\tif (!IS_ENABLED(CONFIG_DEBUG_VM)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tswitch (page - head_page) {\n\tcase 1:\n\t\t/* the first tail page: ->mapping may be compound_mapcount() */\n\t\tif (unlikely(compound_mapcount(page))) {\n\t\t\tbad_page(page, \"nonzero compound_mapcount\", 0);\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\t/*\n\t\t * the second tail page: ->mapping is\n\t\t * deferred_list.next -- ignore value.\n\t\t */\n\t\tbreak;\n\tdefault:\n\t\tif (page->mapping != TAIL_MAPPING) {\n\t\t\tbad_page(page, \"corrupted mapping in tail page\", 0);\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\t}\n\tif (unlikely(!PageTail(page))) {\n\t\tbad_page(page, \"PageTail not set\", 0);\n\t\tgoto out;\n\t}\n\tif (unlikely(compound_head(page) != head_page)) {\n\t\tbad_page(page, \"compound_head not consistent\", 0);\n\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\tpage->mapping = NULL;\n\tclear_compound_head(page);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic int free_tail_pages_check(struct page *head_page, struct page *page)\n{\n\tint ret = 1;\n\n\t/*\n\t * We rely page->lru.next never has bit 0 set, unless the page\n\t * is PageTail(). Let's make sure that's true even for poisoned ->lru.\n\t */\n\tBUILD_BUG_ON((unsigned long)LIST_POISON1 & 1);\n\n\tif (!IS_ENABLED(CONFIG_DEBUG_VM)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tswitch (page - head_page) {\n\tcase 1:\n\t\t/* the first tail page: ->mapping may be compound_mapcount() */\n\t\tif (unlikely(compound_mapcount(page))) {\n\t\t\tbad_page(page, \"nonzero compound_mapcount\", 0);\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\t/*\n\t\t * the second tail page: ->mapping is\n\t\t * deferred_list.next -- ignore value.\n\t\t */\n\t\tbreak;\n\tdefault:\n\t\tif (page->mapping != TAIL_MAPPING) {\n\t\t\tbad_page(page, \"corrupted mapping in tail page\", 0);\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\t}\n\tif (unlikely(!PageTail(page))) {\n\t\tbad_page(page, \"PageTail not set\", 0);\n\t\tgoto out;\n\t}\n\tif (unlikely(compound_head(page) != head_page)) {\n\t\tbad_page(page, \"compound_head not consistent\", 0);\n\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\tpage->mapping = NULL;\n\tclear_compound_head(page);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ClearPageDoubleMap",
          "args": [
            "page"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "compound && compound_order(page) != order",
            "page"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_order",
          "args": [
            "page"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageCompound",
          "args": [
            "page"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "order"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_mm_page_free",
          "args": [
            "page",
            "order"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "PageTail(page)",
            "page"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTail",
          "args": [
            "page"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic __always_inline bool free_pages_prepare(struct page *page,\n\t\t\t\t\tunsigned int order, bool check_free)\n{\n\tint bad = 0;\n\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\n\ttrace_mm_page_free(page, order);\n\n\t/*\n\t * Check tail pages before head page information is cleared to\n\t * avoid checking PageCompound for order-0 pages.\n\t */\n\tif (unlikely(order)) {\n\t\tbool compound = PageCompound(page);\n\t\tint i;\n\n\t\tVM_BUG_ON_PAGE(compound && compound_order(page) != order, page);\n\n\t\tif (compound)\n\t\t\tClearPageDoubleMap(page);\n\t\tfor (i = 1; i < (1 << order); i++) {\n\t\t\tif (compound)\n\t\t\t\tbad += free_tail_pages_check(page, page + i);\n\t\t\tif (unlikely(free_pages_check(page + i))) {\n\t\t\t\tbad++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t(page + i)->flags &= ~PAGE_FLAGS_CHECK_AT_PREP;\n\t\t}\n\t}\n\tif (PageMappingFlags(page))\n\t\tpage->mapping = NULL;\n\tif (memcg_kmem_enabled() && PageKmemcg(page))\n\t\tmemcg_kmem_uncharge(page, order);\n\tif (check_free)\n\t\tbad += free_pages_check(page);\n\tif (bad)\n\t\treturn false;\n\n\tpage_cpupid_reset_last(page);\n\tpage->flags &= ~PAGE_FLAGS_CHECK_AT_PREP;\n\treset_page_owner(page, order);\n\n\tif (!PageHighMem(page)) {\n\t\tdebug_check_no_locks_freed(page_address(page),\n\t\t\t\t\t   PAGE_SIZE << order);\n\t\tdebug_check_no_obj_freed(page_address(page),\n\t\t\t\t\t   PAGE_SIZE << order);\n\t}\n\tarch_free_page(page, order);\n\tkernel_poison_pages(page, 1 << order, 0);\n\tkernel_map_pages(page, 1 << order, 0);\n\tkasan_free_pages(page, order);\n\n\treturn true;\n}"
  },
  {
    "function_name": "free_tail_pages_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "937-985",
    "snippet": "static int free_tail_pages_check(struct page *head_page, struct page *page)\n{\n\tint ret = 1;\n\n\t/*\n\t * We rely page->lru.next never has bit 0 set, unless the page\n\t * is PageTail(). Let's make sure that's true even for poisoned ->lru.\n\t */\n\tBUILD_BUG_ON((unsigned long)LIST_POISON1 & 1);\n\n\tif (!IS_ENABLED(CONFIG_DEBUG_VM)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tswitch (page - head_page) {\n\tcase 1:\n\t\t/* the first tail page: ->mapping may be compound_mapcount() */\n\t\tif (unlikely(compound_mapcount(page))) {\n\t\t\tbad_page(page, \"nonzero compound_mapcount\", 0);\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\t/*\n\t\t * the second tail page: ->mapping is\n\t\t * deferred_list.next -- ignore value.\n\t\t */\n\t\tbreak;\n\tdefault:\n\t\tif (page->mapping != TAIL_MAPPING) {\n\t\t\tbad_page(page, \"corrupted mapping in tail page\", 0);\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\t}\n\tif (unlikely(!PageTail(page))) {\n\t\tbad_page(page, \"PageTail not set\", 0);\n\t\tgoto out;\n\t}\n\tif (unlikely(compound_head(page) != head_page)) {\n\t\tbad_page(page, \"compound_head not consistent\", 0);\n\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\tpage->mapping = NULL;\n\tclear_compound_head(page);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_compound_head",
          "args": [
            "page"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bad_page",
          "args": [
            "page",
            "\"compound_head not consistent\"",
            "0"
          ],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "bad_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "512-554",
          "snippet": "static void bad_page(struct page *page, const char *reason,\n\t\tunsigned long bad_flags)\n{\n\tstatic unsigned long resume;\n\tstatic unsigned long nr_shown;\n\tstatic unsigned long nr_unshown;\n\n\t/*\n\t * Allow a burst of 60 reports, then keep quiet for that minute;\n\t * or allow a steady drip of one report per second.\n\t */\n\tif (nr_shown == 60) {\n\t\tif (time_before(jiffies, resume)) {\n\t\t\tnr_unshown++;\n\t\t\tgoto out;\n\t\t}\n\t\tif (nr_unshown) {\n\t\t\tpr_alert(\n\t\t\t      \"BUG: Bad page state: %lu messages suppressed\\n\",\n\t\t\t\tnr_unshown);\n\t\t\tnr_unshown = 0;\n\t\t}\n\t\tnr_shown = 0;\n\t}\n\tif (nr_shown++ == 0)\n\t\tresume = jiffies + 60 * HZ;\n\n\tpr_alert(\"BUG: Bad page state in process %s  pfn:%05lx\\n\",\n\t\tcurrent->comm, page_to_pfn(page));\n\t__dump_page(page, reason);\n\tbad_flags &= page->flags;\n\tif (bad_flags)\n\t\tpr_alert(\"bad because of flags: %#lx(%pGp)\\n\",\n\t\t\t\t\t\tbad_flags, &bad_flags);\n\tdump_page_owner(page);\n\n\tprint_modules();\n\tdump_stack();\nout:\n\t/* Leave bad fields for debug, except PageBuddy could make trouble */\n\tpage_mapcount_reset(page); /* remove PageBuddy */\n\tadd_taint(TAINT_BAD_PAGE, LOCKDEP_NOW_UNRELIABLE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic void bad_page(struct page *page, const char *reason,\n\t\tunsigned long bad_flags)\n{\n\tstatic unsigned long resume;\n\tstatic unsigned long nr_shown;\n\tstatic unsigned long nr_unshown;\n\n\t/*\n\t * Allow a burst of 60 reports, then keep quiet for that minute;\n\t * or allow a steady drip of one report per second.\n\t */\n\tif (nr_shown == 60) {\n\t\tif (time_before(jiffies, resume)) {\n\t\t\tnr_unshown++;\n\t\t\tgoto out;\n\t\t}\n\t\tif (nr_unshown) {\n\t\t\tpr_alert(\n\t\t\t      \"BUG: Bad page state: %lu messages suppressed\\n\",\n\t\t\t\tnr_unshown);\n\t\t\tnr_unshown = 0;\n\t\t}\n\t\tnr_shown = 0;\n\t}\n\tif (nr_shown++ == 0)\n\t\tresume = jiffies + 60 * HZ;\n\n\tpr_alert(\"BUG: Bad page state in process %s  pfn:%05lx\\n\",\n\t\tcurrent->comm, page_to_pfn(page));\n\t__dump_page(page, reason);\n\tbad_flags &= page->flags;\n\tif (bad_flags)\n\t\tpr_alert(\"bad because of flags: %#lx(%pGp)\\n\",\n\t\t\t\t\t\tbad_flags, &bad_flags);\n\tdump_page_owner(page);\n\n\tprint_modules();\n\tdump_stack();\nout:\n\t/* Leave bad fields for debug, except PageBuddy could make trouble */\n\tpage_mapcount_reset(page); /* remove PageBuddy */\n\tadd_taint(TAINT_BAD_PAGE, LOCKDEP_NOW_UNRELIABLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "compound_head(page) != head_page"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_head",
          "args": [
            "page"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!PageTail(page)"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageTail",
          "args": [
            "page"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "compound_mapcount(page)"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_mapcount",
          "args": [
            "page"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_DEBUG_VM"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "(unsigned long)LIST_POISON1 & 1"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic int free_tail_pages_check(struct page *head_page, struct page *page)\n{\n\tint ret = 1;\n\n\t/*\n\t * We rely page->lru.next never has bit 0 set, unless the page\n\t * is PageTail(). Let's make sure that's true even for poisoned ->lru.\n\t */\n\tBUILD_BUG_ON((unsigned long)LIST_POISON1 & 1);\n\n\tif (!IS_ENABLED(CONFIG_DEBUG_VM)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tswitch (page - head_page) {\n\tcase 1:\n\t\t/* the first tail page: ->mapping may be compound_mapcount() */\n\t\tif (unlikely(compound_mapcount(page))) {\n\t\t\tbad_page(page, \"nonzero compound_mapcount\", 0);\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\t/*\n\t\t * the second tail page: ->mapping is\n\t\t * deferred_list.next -- ignore value.\n\t\t */\n\t\tbreak;\n\tdefault:\n\t\tif (page->mapping != TAIL_MAPPING) {\n\t\t\tbad_page(page, \"corrupted mapping in tail page\", 0);\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\t}\n\tif (unlikely(!PageTail(page))) {\n\t\tbad_page(page, \"PageTail not set\", 0);\n\t\tgoto out;\n\t}\n\tif (unlikely(compound_head(page) != head_page)) {\n\t\tbad_page(page, \"compound_head not consistent\", 0);\n\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\tpage->mapping = NULL;\n\tclear_compound_head(page);\n\treturn ret;\n}"
  },
  {
    "function_name": "free_pages_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "927-935",
    "snippet": "static inline int free_pages_check(struct page *page)\n{\n\tif (likely(page_expected_state(page, PAGE_FLAGS_CHECK_AT_FREE)))\n\t\treturn 0;\n\n\t/* Something has gone sideways, find it */\n\tfree_pages_check_bad(page);\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_pages_check_bad",
          "args": [
            "page"
          ],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "free_pages_check_bad",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "902-925",
          "snippet": "static void free_pages_check_bad(struct page *page)\n{\n\tconst char *bad_reason;\n\tunsigned long bad_flags;\n\n\tbad_reason = NULL;\n\tbad_flags = 0;\n\n\tif (unlikely(atomic_read(&page->_mapcount) != -1))\n\t\tbad_reason = \"nonzero mapcount\";\n\tif (unlikely(page->mapping != NULL))\n\t\tbad_reason = \"non-NULL mapping\";\n\tif (unlikely(page_ref_count(page) != 0))\n\t\tbad_reason = \"nonzero _refcount\";\n\tif (unlikely(page->flags & PAGE_FLAGS_CHECK_AT_FREE)) {\n\t\tbad_reason = \"PAGE_FLAGS_CHECK_AT_FREE flag(s) set\";\n\t\tbad_flags = PAGE_FLAGS_CHECK_AT_FREE;\n\t}\n#ifdef CONFIG_MEMCG\n\tif (unlikely(page->mem_cgroup))\n\t\tbad_reason = \"page still charged to cgroup\";\n#endif\n\tbad_page(page, bad_reason, bad_flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic void free_pages_check_bad(struct page *page)\n{\n\tconst char *bad_reason;\n\tunsigned long bad_flags;\n\n\tbad_reason = NULL;\n\tbad_flags = 0;\n\n\tif (unlikely(atomic_read(&page->_mapcount) != -1))\n\t\tbad_reason = \"nonzero mapcount\";\n\tif (unlikely(page->mapping != NULL))\n\t\tbad_reason = \"non-NULL mapping\";\n\tif (unlikely(page_ref_count(page) != 0))\n\t\tbad_reason = \"nonzero _refcount\";\n\tif (unlikely(page->flags & PAGE_FLAGS_CHECK_AT_FREE)) {\n\t\tbad_reason = \"PAGE_FLAGS_CHECK_AT_FREE flag(s) set\";\n\t\tbad_flags = PAGE_FLAGS_CHECK_AT_FREE;\n\t}\n#ifdef CONFIG_MEMCG\n\tif (unlikely(page->mem_cgroup))\n\t\tbad_reason = \"page still charged to cgroup\";\n#endif\n\tbad_page(page, bad_reason, bad_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "page_expected_state(page, PAGE_FLAGS_CHECK_AT_FREE)"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_expected_state",
          "args": [
            "page",
            "PAGE_FLAGS_CHECK_AT_FREE"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "page_expected_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "885-900",
          "snippet": "static inline bool page_expected_state(struct page *page,\n\t\t\t\t\tunsigned long check_flags)\n{\n\tif (unlikely(atomic_read(&page->_mapcount) != -1))\n\t\treturn false;\n\n\tif (unlikely((unsigned long)page->mapping |\n\t\t\tpage_ref_count(page) |\n#ifdef CONFIG_MEMCG\n\t\t\t(unsigned long)page->mem_cgroup |\n#endif\n\t\t\t(page->flags & check_flags)))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline bool page_expected_state(struct page *page,\n\t\t\t\t\tunsigned long check_flags)\n{\n\tif (unlikely(atomic_read(&page->_mapcount) != -1))\n\t\treturn false;\n\n\tif (unlikely((unsigned long)page->mapping |\n\t\t\tpage_ref_count(page) |\n#ifdef CONFIG_MEMCG\n\t\t\t(unsigned long)page->mem_cgroup |\n#endif\n\t\t\t(page->flags & check_flags)))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline int free_pages_check(struct page *page)\n{\n\tif (likely(page_expected_state(page, PAGE_FLAGS_CHECK_AT_FREE)))\n\t\treturn 0;\n\n\t/* Something has gone sideways, find it */\n\tfree_pages_check_bad(page);\n\treturn 1;\n}"
  },
  {
    "function_name": "free_pages_check_bad",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "902-925",
    "snippet": "static void free_pages_check_bad(struct page *page)\n{\n\tconst char *bad_reason;\n\tunsigned long bad_flags;\n\n\tbad_reason = NULL;\n\tbad_flags = 0;\n\n\tif (unlikely(atomic_read(&page->_mapcount) != -1))\n\t\tbad_reason = \"nonzero mapcount\";\n\tif (unlikely(page->mapping != NULL))\n\t\tbad_reason = \"non-NULL mapping\";\n\tif (unlikely(page_ref_count(page) != 0))\n\t\tbad_reason = \"nonzero _refcount\";\n\tif (unlikely(page->flags & PAGE_FLAGS_CHECK_AT_FREE)) {\n\t\tbad_reason = \"PAGE_FLAGS_CHECK_AT_FREE flag(s) set\";\n\t\tbad_flags = PAGE_FLAGS_CHECK_AT_FREE;\n\t}\n#ifdef CONFIG_MEMCG\n\tif (unlikely(page->mem_cgroup))\n\t\tbad_reason = \"page still charged to cgroup\";\n#endif\n\tbad_page(page, bad_reason, bad_flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bad_page",
          "args": [
            "page",
            "bad_reason",
            "bad_flags"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "bad_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "512-554",
          "snippet": "static void bad_page(struct page *page, const char *reason,\n\t\tunsigned long bad_flags)\n{\n\tstatic unsigned long resume;\n\tstatic unsigned long nr_shown;\n\tstatic unsigned long nr_unshown;\n\n\t/*\n\t * Allow a burst of 60 reports, then keep quiet for that minute;\n\t * or allow a steady drip of one report per second.\n\t */\n\tif (nr_shown == 60) {\n\t\tif (time_before(jiffies, resume)) {\n\t\t\tnr_unshown++;\n\t\t\tgoto out;\n\t\t}\n\t\tif (nr_unshown) {\n\t\t\tpr_alert(\n\t\t\t      \"BUG: Bad page state: %lu messages suppressed\\n\",\n\t\t\t\tnr_unshown);\n\t\t\tnr_unshown = 0;\n\t\t}\n\t\tnr_shown = 0;\n\t}\n\tif (nr_shown++ == 0)\n\t\tresume = jiffies + 60 * HZ;\n\n\tpr_alert(\"BUG: Bad page state in process %s  pfn:%05lx\\n\",\n\t\tcurrent->comm, page_to_pfn(page));\n\t__dump_page(page, reason);\n\tbad_flags &= page->flags;\n\tif (bad_flags)\n\t\tpr_alert(\"bad because of flags: %#lx(%pGp)\\n\",\n\t\t\t\t\t\tbad_flags, &bad_flags);\n\tdump_page_owner(page);\n\n\tprint_modules();\n\tdump_stack();\nout:\n\t/* Leave bad fields for debug, except PageBuddy could make trouble */\n\tpage_mapcount_reset(page); /* remove PageBuddy */\n\tadd_taint(TAINT_BAD_PAGE, LOCKDEP_NOW_UNRELIABLE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic void bad_page(struct page *page, const char *reason,\n\t\tunsigned long bad_flags)\n{\n\tstatic unsigned long resume;\n\tstatic unsigned long nr_shown;\n\tstatic unsigned long nr_unshown;\n\n\t/*\n\t * Allow a burst of 60 reports, then keep quiet for that minute;\n\t * or allow a steady drip of one report per second.\n\t */\n\tif (nr_shown == 60) {\n\t\tif (time_before(jiffies, resume)) {\n\t\t\tnr_unshown++;\n\t\t\tgoto out;\n\t\t}\n\t\tif (nr_unshown) {\n\t\t\tpr_alert(\n\t\t\t      \"BUG: Bad page state: %lu messages suppressed\\n\",\n\t\t\t\tnr_unshown);\n\t\t\tnr_unshown = 0;\n\t\t}\n\t\tnr_shown = 0;\n\t}\n\tif (nr_shown++ == 0)\n\t\tresume = jiffies + 60 * HZ;\n\n\tpr_alert(\"BUG: Bad page state in process %s  pfn:%05lx\\n\",\n\t\tcurrent->comm, page_to_pfn(page));\n\t__dump_page(page, reason);\n\tbad_flags &= page->flags;\n\tif (bad_flags)\n\t\tpr_alert(\"bad because of flags: %#lx(%pGp)\\n\",\n\t\t\t\t\t\tbad_flags, &bad_flags);\n\tdump_page_owner(page);\n\n\tprint_modules();\n\tdump_stack();\nout:\n\t/* Leave bad fields for debug, except PageBuddy could make trouble */\n\tpage_mapcount_reset(page); /* remove PageBuddy */\n\tadd_taint(TAINT_BAD_PAGE, LOCKDEP_NOW_UNRELIABLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "page->mem_cgroup"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "page->flags & PAGE_FLAGS_CHECK_AT_FREE"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "page_ref_count(page) != 0"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_ref_count",
          "args": [
            "page"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "page->mapping != NULL"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "atomic_read(&page->_mapcount) != -1"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&page->_mapcount"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic void free_pages_check_bad(struct page *page)\n{\n\tconst char *bad_reason;\n\tunsigned long bad_flags;\n\n\tbad_reason = NULL;\n\tbad_flags = 0;\n\n\tif (unlikely(atomic_read(&page->_mapcount) != -1))\n\t\tbad_reason = \"nonzero mapcount\";\n\tif (unlikely(page->mapping != NULL))\n\t\tbad_reason = \"non-NULL mapping\";\n\tif (unlikely(page_ref_count(page) != 0))\n\t\tbad_reason = \"nonzero _refcount\";\n\tif (unlikely(page->flags & PAGE_FLAGS_CHECK_AT_FREE)) {\n\t\tbad_reason = \"PAGE_FLAGS_CHECK_AT_FREE flag(s) set\";\n\t\tbad_flags = PAGE_FLAGS_CHECK_AT_FREE;\n\t}\n#ifdef CONFIG_MEMCG\n\tif (unlikely(page->mem_cgroup))\n\t\tbad_reason = \"page still charged to cgroup\";\n#endif\n\tbad_page(page, bad_reason, bad_flags);\n}"
  },
  {
    "function_name": "page_expected_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "885-900",
    "snippet": "static inline bool page_expected_state(struct page *page,\n\t\t\t\t\tunsigned long check_flags)\n{\n\tif (unlikely(atomic_read(&page->_mapcount) != -1))\n\t\treturn false;\n\n\tif (unlikely((unsigned long)page->mapping |\n\t\t\tpage_ref_count(page) |\n#ifdef CONFIG_MEMCG\n\t\t\t(unsigned long)page->mem_cgroup |\n#endif\n\t\t\t(page->flags & check_flags)))\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(unsigned long)page->mapping |\n\t\t\tpage_ref_count(page) |\n#ifdef CONFIG_MEMCG\n\t\t\t(unsigned long)page->mem_cgroup |\n#endif\n\t\t\t(page->flags & check_flags)"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CONFIG_MEMCG",
          "args": [
            "unsignedlong"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_ref_count",
          "args": [
            "page"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "atomic_read(&page->_mapcount) != -1"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&page->_mapcount"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline bool page_expected_state(struct page *page,\n\t\t\t\t\tunsigned long check_flags)\n{\n\tif (unlikely(atomic_read(&page->_mapcount) != -1))\n\t\treturn false;\n\n\tif (unlikely((unsigned long)page->mapping |\n\t\t\tpage_ref_count(page) |\n#ifdef CONFIG_MEMCG\n\t\t\t(unsigned long)page->mem_cgroup |\n#endif\n\t\t\t(page->flags & check_flags)))\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "__free_one_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "778-878",
    "snippet": "static inline void __free_one_page(struct page *page,\n\t\tunsigned long pfn,\n\t\tstruct zone *zone, unsigned int order,\n\t\tint migratetype)\n{\n\tunsigned long combined_pfn;\n\tunsigned long uninitialized_var(buddy_pfn);\n\tstruct page *buddy;\n\tunsigned int max_order;\n\n\tmax_order = min_t(unsigned int, MAX_ORDER, pageblock_order + 1);\n\n\tVM_BUG_ON(!zone_is_initialized(zone));\n\tVM_BUG_ON_PAGE(page->flags & PAGE_FLAGS_CHECK_AT_PREP, page);\n\n\tVM_BUG_ON(migratetype == -1);\n\tif (likely(!is_migrate_isolate(migratetype)))\n\t\t__mod_zone_freepage_state(zone, 1 << order, migratetype);\n\n\tVM_BUG_ON_PAGE(pfn & ((1 << order) - 1), page);\n\tVM_BUG_ON_PAGE(bad_range(zone, page), page);\n\ncontinue_merging:\n\twhile (order < max_order - 1) {\n\t\tbuddy_pfn = __find_buddy_pfn(pfn, order);\n\t\tbuddy = page + (buddy_pfn - pfn);\n\n\t\tif (!pfn_valid_within(buddy_pfn))\n\t\t\tgoto done_merging;\n\t\tif (!page_is_buddy(page, buddy, order))\n\t\t\tgoto done_merging;\n\t\t/*\n\t\t * Our buddy is free or it is CONFIG_DEBUG_PAGEALLOC guard page,\n\t\t * merge with it and move up one order.\n\t\t */\n\t\tif (page_is_guard(buddy)) {\n\t\t\tclear_page_guard(zone, buddy, order, migratetype);\n\t\t} else {\n\t\t\tlist_del(&buddy->lru);\n\t\t\tzone->free_area[order].nr_free--;\n\t\t\trmv_page_order(buddy);\n\t\t}\n\t\tcombined_pfn = buddy_pfn & pfn;\n\t\tpage = page + (combined_pfn - pfn);\n\t\tpfn = combined_pfn;\n\t\torder++;\n\t}\n\tif (max_order < MAX_ORDER) {\n\t\t/* If we are here, it means order is >= pageblock_order.\n\t\t * We want to prevent merge between freepages on isolate\n\t\t * pageblock and normal pageblock. Without this, pageblock\n\t\t * isolation could cause incorrect freepage or CMA accounting.\n\t\t *\n\t\t * We don't want to hit this code for the more frequent\n\t\t * low-order merging.\n\t\t */\n\t\tif (unlikely(has_isolate_pageblock(zone))) {\n\t\t\tint buddy_mt;\n\n\t\t\tbuddy_pfn = __find_buddy_pfn(pfn, order);\n\t\t\tbuddy = page + (buddy_pfn - pfn);\n\t\t\tbuddy_mt = get_pageblock_migratetype(buddy);\n\n\t\t\tif (migratetype != buddy_mt\n\t\t\t\t\t&& (is_migrate_isolate(migratetype) ||\n\t\t\t\t\t\tis_migrate_isolate(buddy_mt)))\n\t\t\t\tgoto done_merging;\n\t\t}\n\t\tmax_order++;\n\t\tgoto continue_merging;\n\t}\n\ndone_merging:\n\tset_page_order(page, order);\n\n\t/*\n\t * If this is not the largest possible page, check if the buddy\n\t * of the next-highest order is free. If it is, it's possible\n\t * that pages are being freed that will coalesce soon. In case,\n\t * that is happening, add the free page to the tail of the list\n\t * so it's less likely to be used soon and more likely to be merged\n\t * as a higher order page\n\t */\n\tif ((order < MAX_ORDER-2) && pfn_valid_within(buddy_pfn)) {\n\t\tstruct page *higher_page, *higher_buddy;\n\t\tcombined_pfn = buddy_pfn & pfn;\n\t\thigher_page = page + (combined_pfn - pfn);\n\t\tbuddy_pfn = __find_buddy_pfn(combined_pfn, order + 1);\n\t\thigher_buddy = higher_page + (buddy_pfn - combined_pfn);\n\t\tif (pfn_valid_within(buddy_pfn) &&\n\t\t    page_is_buddy(higher_page, higher_buddy, order + 1)) {\n\t\t\tlist_add_tail(&page->lru,\n\t\t\t\t&zone->free_area[order].free_list[migratetype]);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tlist_add(&page->lru, &zone->free_area[order].free_list[migratetype]);\nout:\n\tzone->free_area[order].nr_free++;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);",
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&page->lru",
            "&zone->free_area[order].free_list[migratetype]"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&page->lru",
            "&zone->free_area[order].free_list[migratetype]"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_is_buddy",
          "args": [
            "higher_page",
            "higher_buddy",
            "order + 1"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "page_is_buddy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "726-752",
          "snippet": "static inline int page_is_buddy(struct page *page, struct page *buddy,\n\t\t\t\t\t\t\tunsigned int order)\n{\n\tif (page_is_guard(buddy) && page_order(buddy) == order) {\n\t\tif (page_zone_id(page) != page_zone_id(buddy))\n\t\t\treturn 0;\n\n\t\tVM_BUG_ON_PAGE(page_count(buddy) != 0, buddy);\n\n\t\treturn 1;\n\t}\n\n\tif (PageBuddy(buddy) && page_order(buddy) == order) {\n\t\t/*\n\t\t * zone check is done late to avoid uselessly\n\t\t * calculating zone/node ids for pages that could\n\t\t * never merge.\n\t\t */\n\t\tif (page_zone_id(page) != page_zone_id(buddy))\n\t\t\treturn 0;\n\n\t\tVM_BUG_ON_PAGE(page_count(buddy) != 0, buddy);\n\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline int page_is_buddy(struct page *page, struct page *buddy,\n\t\t\t\t\t\t\tunsigned int order)\n{\n\tif (page_is_guard(buddy) && page_order(buddy) == order) {\n\t\tif (page_zone_id(page) != page_zone_id(buddy))\n\t\t\treturn 0;\n\n\t\tVM_BUG_ON_PAGE(page_count(buddy) != 0, buddy);\n\n\t\treturn 1;\n\t}\n\n\tif (PageBuddy(buddy) && page_order(buddy) == order) {\n\t\t/*\n\t\t * zone check is done late to avoid uselessly\n\t\t * calculating zone/node ids for pages that could\n\t\t * never merge.\n\t\t */\n\t\tif (page_zone_id(page) != page_zone_id(buddy))\n\t\t\treturn 0;\n\n\t\tVM_BUG_ON_PAGE(page_count(buddy) != 0, buddy);\n\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfn_valid_within",
          "args": [
            "buddy_pfn"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__find_buddy_pfn",
          "args": [
            "combined_pfn",
            "order + 1"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "__find_buddy_pfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/internal.h",
          "lines": "145-149",
          "snippet": "static inline unsigned long\n__find_buddy_pfn(unsigned long page_pfn, unsigned int order)\n{\n\treturn page_pfn ^ (1 << order);\n}",
          "includes": [
            "#include <linux/tracepoint-defs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracepoint-defs.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline unsigned long\n__find_buddy_pfn(unsigned long page_pfn, unsigned int order)\n{\n\treturn page_pfn ^ (1 << order);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfn_valid_within",
          "args": [
            "buddy_pfn"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_order",
          "args": [
            "page",
            "order"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "set_page_order",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "701-705",
          "snippet": "static inline void set_page_order(struct page *page, unsigned int order)\n{\n\tset_page_private(page, order);\n\t__SetPageBuddy(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline void set_page_order(struct page *page, unsigned int order)\n{\n\tset_page_private(page, order);\n\t__SetPageBuddy(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_migrate_isolate",
          "args": [
            "buddy_mt"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_migrate_isolate",
          "args": [
            "migratetype"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_pageblock_migratetype",
          "args": [
            "buddy"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "has_isolate_pageblock(zone)"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_isolate_pageblock",
          "args": [
            "zone"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rmv_page_order",
          "args": [
            "buddy"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "rmv_page_order",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "707-711",
          "snippet": "static inline void rmv_page_order(struct page *page)\n{\n\t__ClearPageBuddy(page);\n\tset_page_private(page, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline void rmv_page_order(struct page *page)\n{\n\t__ClearPageBuddy(page);\n\tset_page_private(page, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&buddy->lru"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_page_guard",
          "args": [
            "zone",
            "buddy",
            "order",
            "migratetype"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "clear_page_guard",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "697-698",
          "snippet": "static inline void clear_page_guard(struct zone *zone, struct page *page,\n\t\t\t\tunsigned int order, int migratetype) {}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline void clear_page_guard(struct zone *zone, struct page *page,\n\t\t\t\tunsigned int order, int migratetype) {}"
        }
      },
      {
        "call_info": {
          "callee": "page_is_guard",
          "args": [
            "buddy"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_valid_within",
          "args": [
            "buddy_pfn"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "bad_range(zone, page)",
            "page"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bad_range",
          "args": [
            "zone",
            "page"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "bad_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "506-509",
          "snippet": "static inline int __maybe_unused bad_range(struct zone *zone, struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline int __maybe_unused bad_range(struct zone *zone, struct page *page)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "pfn & ((1 << order) - 1)",
            "page"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mod_zone_freepage_state",
          "args": [
            "zone",
            "1 << order",
            "migratetype"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!is_migrate_isolate(migratetype)"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_migrate_isolate",
          "args": [
            "migratetype"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "migratetype == -1"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "page->flags & PAGE_FLAGS_CHECK_AT_PREP",
            "page"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!zone_is_initialized(zone)"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_is_initialized",
          "args": [
            "zone"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedint",
            "MAX_ORDER",
            "pageblock_order + 1"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline void __free_one_page(struct page *page,\n\t\tunsigned long pfn,\n\t\tstruct zone *zone, unsigned int order,\n\t\tint migratetype)\n{\n\tunsigned long combined_pfn;\n\tunsigned long uninitialized_var(buddy_pfn);\n\tstruct page *buddy;\n\tunsigned int max_order;\n\n\tmax_order = min_t(unsigned int, MAX_ORDER, pageblock_order + 1);\n\n\tVM_BUG_ON(!zone_is_initialized(zone));\n\tVM_BUG_ON_PAGE(page->flags & PAGE_FLAGS_CHECK_AT_PREP, page);\n\n\tVM_BUG_ON(migratetype == -1);\n\tif (likely(!is_migrate_isolate(migratetype)))\n\t\t__mod_zone_freepage_state(zone, 1 << order, migratetype);\n\n\tVM_BUG_ON_PAGE(pfn & ((1 << order) - 1), page);\n\tVM_BUG_ON_PAGE(bad_range(zone, page), page);\n\ncontinue_merging:\n\twhile (order < max_order - 1) {\n\t\tbuddy_pfn = __find_buddy_pfn(pfn, order);\n\t\tbuddy = page + (buddy_pfn - pfn);\n\n\t\tif (!pfn_valid_within(buddy_pfn))\n\t\t\tgoto done_merging;\n\t\tif (!page_is_buddy(page, buddy, order))\n\t\t\tgoto done_merging;\n\t\t/*\n\t\t * Our buddy is free or it is CONFIG_DEBUG_PAGEALLOC guard page,\n\t\t * merge with it and move up one order.\n\t\t */\n\t\tif (page_is_guard(buddy)) {\n\t\t\tclear_page_guard(zone, buddy, order, migratetype);\n\t\t} else {\n\t\t\tlist_del(&buddy->lru);\n\t\t\tzone->free_area[order].nr_free--;\n\t\t\trmv_page_order(buddy);\n\t\t}\n\t\tcombined_pfn = buddy_pfn & pfn;\n\t\tpage = page + (combined_pfn - pfn);\n\t\tpfn = combined_pfn;\n\t\torder++;\n\t}\n\tif (max_order < MAX_ORDER) {\n\t\t/* If we are here, it means order is >= pageblock_order.\n\t\t * We want to prevent merge between freepages on isolate\n\t\t * pageblock and normal pageblock. Without this, pageblock\n\t\t * isolation could cause incorrect freepage or CMA accounting.\n\t\t *\n\t\t * We don't want to hit this code for the more frequent\n\t\t * low-order merging.\n\t\t */\n\t\tif (unlikely(has_isolate_pageblock(zone))) {\n\t\t\tint buddy_mt;\n\n\t\t\tbuddy_pfn = __find_buddy_pfn(pfn, order);\n\t\t\tbuddy = page + (buddy_pfn - pfn);\n\t\t\tbuddy_mt = get_pageblock_migratetype(buddy);\n\n\t\t\tif (migratetype != buddy_mt\n\t\t\t\t\t&& (is_migrate_isolate(migratetype) ||\n\t\t\t\t\t\tis_migrate_isolate(buddy_mt)))\n\t\t\t\tgoto done_merging;\n\t\t}\n\t\tmax_order++;\n\t\tgoto continue_merging;\n\t}\n\ndone_merging:\n\tset_page_order(page, order);\n\n\t/*\n\t * If this is not the largest possible page, check if the buddy\n\t * of the next-highest order is free. If it is, it's possible\n\t * that pages are being freed that will coalesce soon. In case,\n\t * that is happening, add the free page to the tail of the list\n\t * so it's less likely to be used soon and more likely to be merged\n\t * as a higher order page\n\t */\n\tif ((order < MAX_ORDER-2) && pfn_valid_within(buddy_pfn)) {\n\t\tstruct page *higher_page, *higher_buddy;\n\t\tcombined_pfn = buddy_pfn & pfn;\n\t\thigher_page = page + (combined_pfn - pfn);\n\t\tbuddy_pfn = __find_buddy_pfn(combined_pfn, order + 1);\n\t\thigher_buddy = higher_page + (buddy_pfn - combined_pfn);\n\t\tif (pfn_valid_within(buddy_pfn) &&\n\t\t    page_is_buddy(higher_page, higher_buddy, order + 1)) {\n\t\t\tlist_add_tail(&page->lru,\n\t\t\t\t&zone->free_area[order].free_list[migratetype]);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tlist_add(&page->lru, &zone->free_area[order].free_list[migratetype]);\nout:\n\tzone->free_area[order].nr_free++;\n}"
  },
  {
    "function_name": "page_is_buddy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "726-752",
    "snippet": "static inline int page_is_buddy(struct page *page, struct page *buddy,\n\t\t\t\t\t\t\tunsigned int order)\n{\n\tif (page_is_guard(buddy) && page_order(buddy) == order) {\n\t\tif (page_zone_id(page) != page_zone_id(buddy))\n\t\t\treturn 0;\n\n\t\tVM_BUG_ON_PAGE(page_count(buddy) != 0, buddy);\n\n\t\treturn 1;\n\t}\n\n\tif (PageBuddy(buddy) && page_order(buddy) == order) {\n\t\t/*\n\t\t * zone check is done late to avoid uselessly\n\t\t * calculating zone/node ids for pages that could\n\t\t * never merge.\n\t\t */\n\t\tif (page_zone_id(page) != page_zone_id(buddy))\n\t\t\treturn 0;\n\n\t\tVM_BUG_ON_PAGE(page_count(buddy) != 0, buddy);\n\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);",
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "page_count(buddy) != 0",
            "buddy"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "buddy"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_zone_id",
          "args": [
            "buddy"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_zone_id",
          "args": [
            "page"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_order",
          "args": [
            "buddy"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "rmv_page_order",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "707-711",
          "snippet": "static inline void rmv_page_order(struct page *page)\n{\n\t__ClearPageBuddy(page);\n\tset_page_private(page, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline void rmv_page_order(struct page *page)\n{\n\t__ClearPageBuddy(page);\n\tset_page_private(page, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageBuddy",
          "args": [
            "buddy"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "page_count(buddy) != 0",
            "buddy"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "buddy"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_zone_id",
          "args": [
            "buddy"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_zone_id",
          "args": [
            "page"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_is_guard",
          "args": [
            "buddy"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline int page_is_buddy(struct page *page, struct page *buddy,\n\t\t\t\t\t\t\tunsigned int order)\n{\n\tif (page_is_guard(buddy) && page_order(buddy) == order) {\n\t\tif (page_zone_id(page) != page_zone_id(buddy))\n\t\t\treturn 0;\n\n\t\tVM_BUG_ON_PAGE(page_count(buddy) != 0, buddy);\n\n\t\treturn 1;\n\t}\n\n\tif (PageBuddy(buddy) && page_order(buddy) == order) {\n\t\t/*\n\t\t * zone check is done late to avoid uselessly\n\t\t * calculating zone/node ids for pages that could\n\t\t * never merge.\n\t\t */\n\t\tif (page_zone_id(page) != page_zone_id(buddy))\n\t\t\treturn 0;\n\n\t\tVM_BUG_ON_PAGE(page_count(buddy) != 0, buddy);\n\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "rmv_page_order",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "707-711",
    "snippet": "static inline void rmv_page_order(struct page *page)\n{\n\t__ClearPageBuddy(page);\n\tset_page_private(page, 0);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "page",
            "0"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ClearPageBuddy",
          "args": [
            "page"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline void rmv_page_order(struct page *page)\n{\n\t__ClearPageBuddy(page);\n\tset_page_private(page, 0);\n}"
  },
  {
    "function_name": "set_page_order",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "701-705",
    "snippet": "static inline void set_page_order(struct page *page, unsigned int order)\n{\n\tset_page_private(page, order);\n\t__SetPageBuddy(page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);",
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__SetPageBuddy",
          "args": [
            "page"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "page",
            "order"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline void set_page_order(struct page *page, unsigned int order)\n{\n\tset_page_private(page, order);\n\t__SetPageBuddy(page);\n}"
  },
  {
    "function_name": "clear_page_guard",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "697-698",
    "snippet": "static inline void clear_page_guard(struct zone *zone, struct page *page,\n\t\t\t\tunsigned int order, int migratetype) {}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);",
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline void clear_page_guard(struct zone *zone, struct page *page,\n\t\t\t\tunsigned int order, int migratetype) {}"
  },
  {
    "function_name": "set_page_guard",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "695-696",
    "snippet": "static inline bool set_page_guard(struct zone *zone, struct page *page,\n\t\t\tunsigned int order, int migratetype) { return false; }",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);",
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline bool set_page_guard(struct zone *zone, struct page *page,\n\t\t\tunsigned int order, int migratetype) { return false; }"
  },
  {
    "function_name": "clear_page_guard",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "675-692",
    "snippet": "static inline void clear_page_guard(struct zone *zone, struct page *page,\n\t\t\t\tunsigned int order, int migratetype)\n{\n\tstruct page_ext *page_ext;\n\n\tif (!debug_guardpage_enabled())\n\t\treturn;\n\n\tpage_ext = lookup_page_ext(page);\n\tif (unlikely(!page_ext))\n\t\treturn;\n\n\t__clear_bit(PAGE_EXT_DEBUG_GUARD, &page_ext->flags);\n\n\tset_page_private(page, 0);\n\tif (!is_migrate_isolate(migratetype))\n\t\t__mod_zone_freepage_state(zone, (1 << order), migratetype);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);",
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__mod_zone_freepage_state",
          "args": [
            "zone",
            "(1 << order)",
            "migratetype"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_migrate_isolate",
          "args": [
            "migratetype"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "page",
            "0"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__clear_bit",
          "args": [
            "PAGE_EXT_DEBUG_GUARD",
            "&page_ext->flags"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!page_ext"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_page_ext",
          "args": [
            "page"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_page_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
          "lines": "198-211",
          "snippet": "struct page_ext *lookup_page_ext(const struct page *page)\n{\n\tunsigned long pfn = page_to_pfn(page);\n\tstruct mem_section *section = __pfn_to_section(pfn);\n\t/*\n\t * The sanity checks the page allocator does upon freeing a\n\t * page can reach here before the page_ext arrays are\n\t * allocated when feeding a range of pages to the allocator\n\t * for the first time during bootup or memory hotplug.\n\t */\n\tif (!section->page_ext)\n\t\treturn NULL;\n\treturn get_entry(section->page_ext, pfn);\n}",
          "includes": [
            "#include <linux/page_idle.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/memory.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nstruct page_ext *lookup_page_ext(const struct page *page)\n{\n\tunsigned long pfn = page_to_pfn(page);\n\tstruct mem_section *section = __pfn_to_section(pfn);\n\t/*\n\t * The sanity checks the page allocator does upon freeing a\n\t * page can reach here before the page_ext arrays are\n\t * allocated when feeding a range of pages to the allocator\n\t * for the first time during bootup or memory hotplug.\n\t */\n\tif (!section->page_ext)\n\t\treturn NULL;\n\treturn get_entry(section->page_ext, pfn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_guardpage_enabled",
          "args": [],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline void clear_page_guard(struct zone *zone, struct page *page,\n\t\t\t\tunsigned int order, int migratetype)\n{\n\tstruct page_ext *page_ext;\n\n\tif (!debug_guardpage_enabled())\n\t\treturn;\n\n\tpage_ext = lookup_page_ext(page);\n\tif (unlikely(!page_ext))\n\t\treturn;\n\n\t__clear_bit(PAGE_EXT_DEBUG_GUARD, &page_ext->flags);\n\n\tset_page_private(page, 0);\n\tif (!is_migrate_isolate(migratetype))\n\t\t__mod_zone_freepage_state(zone, (1 << order), migratetype);\n}"
  },
  {
    "function_name": "set_page_guard",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "650-673",
    "snippet": "static inline bool set_page_guard(struct zone *zone, struct page *page,\n\t\t\t\tunsigned int order, int migratetype)\n{\n\tstruct page_ext *page_ext;\n\n\tif (!debug_guardpage_enabled())\n\t\treturn false;\n\n\tif (order >= debug_guardpage_minorder())\n\t\treturn false;\n\n\tpage_ext = lookup_page_ext(page);\n\tif (unlikely(!page_ext))\n\t\treturn false;\n\n\t__set_bit(PAGE_EXT_DEBUG_GUARD, &page_ext->flags);\n\n\tINIT_LIST_HEAD(&page->lru);\n\tset_page_private(page, order);\n\t/* Guard pages are not available for any usage */\n\t__mod_zone_freepage_state(zone, -(1 << order), migratetype);\n\n\treturn true;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);",
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__mod_zone_freepage_state",
          "args": [
            "zone",
            "-(1 << order)",
            "migratetype"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "page",
            "order"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&page->lru"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "PAGE_EXT_DEBUG_GUARD",
            "&page_ext->flags"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!page_ext"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_page_ext",
          "args": [
            "page"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_page_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
          "lines": "198-211",
          "snippet": "struct page_ext *lookup_page_ext(const struct page *page)\n{\n\tunsigned long pfn = page_to_pfn(page);\n\tstruct mem_section *section = __pfn_to_section(pfn);\n\t/*\n\t * The sanity checks the page allocator does upon freeing a\n\t * page can reach here before the page_ext arrays are\n\t * allocated when feeding a range of pages to the allocator\n\t * for the first time during bootup or memory hotplug.\n\t */\n\tif (!section->page_ext)\n\t\treturn NULL;\n\treturn get_entry(section->page_ext, pfn);\n}",
          "includes": [
            "#include <linux/page_idle.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/memory.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nstruct page_ext *lookup_page_ext(const struct page *page)\n{\n\tunsigned long pfn = page_to_pfn(page);\n\tstruct mem_section *section = __pfn_to_section(pfn);\n\t/*\n\t * The sanity checks the page allocator does upon freeing a\n\t * page can reach here before the page_ext arrays are\n\t * allocated when feeding a range of pages to the allocator\n\t * for the first time during bootup or memory hotplug.\n\t */\n\tif (!section->page_ext)\n\t\treturn NULL;\n\treturn get_entry(section->page_ext, pfn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_guardpage_minorder",
          "args": [],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_guardpage_enabled",
          "args": [],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline bool set_page_guard(struct zone *zone, struct page *page,\n\t\t\t\tunsigned int order, int migratetype)\n{\n\tstruct page_ext *page_ext;\n\n\tif (!debug_guardpage_enabled())\n\t\treturn false;\n\n\tif (order >= debug_guardpage_minorder())\n\t\treturn false;\n\n\tpage_ext = lookup_page_ext(page);\n\tif (unlikely(!page_ext))\n\t\treturn false;\n\n\t__set_bit(PAGE_EXT_DEBUG_GUARD, &page_ext->flags);\n\n\tINIT_LIST_HEAD(&page->lru);\n\tset_page_private(page, order);\n\t/* Guard pages are not available for any usage */\n\t__mod_zone_freepage_state(zone, -(1 << order), migratetype);\n\n\treturn true;\n}"
  },
  {
    "function_name": "debug_guardpage_minorder_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "636-647",
    "snippet": "static int __init debug_guardpage_minorder_setup(char *buf)\n{\n\tunsigned long res;\n\n\tif (kstrtoul(buf, 10, &res) < 0 ||  res > MAX_ORDER / 2) {\n\t\tpr_err(\"Bad debug_guardpage_minorder value\\n\");\n\t\treturn 0;\n\t}\n\t_debug_guardpage_minorder = res;\n\tpr_info(\"Setting debug_guardpage_minorder to %lu\\n\", res);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Setting debug_guardpage_minorder to %lu\\n\"",
            "res"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Bad debug_guardpage_minorder value\\n\""
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "buf",
            "10",
            "&res"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic int __init debug_guardpage_minorder_setup(char *buf)\n{\n\tunsigned long res;\n\n\tif (kstrtoul(buf, 10, &res) < 0 ||  res > MAX_ORDER / 2) {\n\t\tpr_err(\"Bad debug_guardpage_minorder value\\n\");\n\t\treturn 0;\n\t}\n\t_debug_guardpage_minorder = res;\n\tpr_info(\"Setting debug_guardpage_minorder to %lu\\n\", res);\n\treturn 0;\n}"
  },
  {
    "function_name": "init_debug_guardpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "620-629",
    "snippet": "static void init_debug_guardpage(void)\n{\n\tif (!debug_pagealloc_enabled())\n\t\treturn;\n\n\tif (!debug_guardpage_minorder())\n\t\treturn;\n\n\t_debug_guardpage_enabled = true;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_guardpage_minorder",
          "args": [],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_pagealloc_enabled",
          "args": [],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void init_debug_guardpage(void)\n{\n\tif (!debug_pagealloc_enabled())\n\t\treturn;\n\n\tif (!debug_guardpage_minorder())\n\t\treturn;\n\n\t_debug_guardpage_enabled = true;\n}"
  },
  {
    "function_name": "need_debug_guardpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "608-618",
    "snippet": "static bool need_debug_guardpage(void)\n{\n\t/* If we don't use debug_pagealloc, we don't need guard page */\n\tif (!debug_pagealloc_enabled())\n\t\treturn false;\n\n\tif (!debug_guardpage_minorder())\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_guardpage_minorder",
          "args": [],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_pagealloc_enabled",
          "args": [],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic bool need_debug_guardpage(void)\n{\n\t/* If we don't use debug_pagealloc, we don't need guard page */\n\tif (!debug_pagealloc_enabled())\n\t\treturn false;\n\n\tif (!debug_guardpage_minorder())\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "early_debug_pagealloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "600-605",
    "snippet": "static int __init early_debug_pagealloc(char *buf)\n{\n\tif (!buf)\n\t\treturn -EINVAL;\n\treturn kstrtobool(buf, &_debug_pagealloc_enabled);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrtobool",
          "args": [
            "buf",
            "&_debug_pagealloc_enabled"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic int __init early_debug_pagealloc(char *buf)\n{\n\tif (!buf)\n\t\treturn -EINVAL;\n\treturn kstrtobool(buf, &_debug_pagealloc_enabled);\n}"
  },
  {
    "function_name": "prep_compound_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "576-591",
    "snippet": "void prep_compound_page(struct page *page, unsigned int order)\n{\n\tint i;\n\tint nr_pages = 1 << order;\n\n\tset_compound_page_dtor(page, COMPOUND_PAGE_DTOR);\n\tset_compound_order(page, order);\n\t__SetPageHead(page);\n\tfor (i = 1; i < nr_pages; i++) {\n\t\tstruct page *p = page + i;\n\t\tset_page_count(p, 0);\n\t\tp->mapping = TAIL_MAPPING;\n\t\tset_compound_head(p, page);\n\t}\n\tatomic_set(compound_mapcount_ptr(page), -1);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __free_pages_ok(struct page *page, unsigned int order);",
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "compound_mapcount_ptr(page)",
            "-1"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compound_mapcount_ptr",
          "args": [
            "page"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_compound_head",
          "args": [
            "p",
            "page"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_count",
          "args": [
            "p",
            "0"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__SetPageHead",
          "args": [
            "page"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_compound_order",
          "args": [
            "page",
            "order"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_compound_page_dtor",
          "args": [
            "page",
            "COMPOUND_PAGE_DTOR"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid prep_compound_page(struct page *page, unsigned int order)\n{\n\tint i;\n\tint nr_pages = 1 << order;\n\n\tset_compound_page_dtor(page, COMPOUND_PAGE_DTOR);\n\tset_compound_order(page, order);\n\t__SetPageHead(page);\n\tfor (i = 1; i < nr_pages; i++) {\n\t\tstruct page *p = page + i;\n\t\tset_page_count(p, 0);\n\t\tp->mapping = TAIL_MAPPING;\n\t\tset_compound_head(p, page);\n\t}\n\tatomic_set(compound_mapcount_ptr(page), -1);\n}"
  },
  {
    "function_name": "free_compound_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "571-574",
    "snippet": "void free_compound_page(struct page *page)\n{\n\t__free_pages_ok(page, compound_order(page));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_pages_ok",
          "args": [
            "page",
            "compound_order(page)"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "__free_pages_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1251-1265",
          "snippet": "static void __free_pages_ok(struct page *page, unsigned int order)\n{\n\tunsigned long flags;\n\tint migratetype;\n\tunsigned long pfn = page_to_pfn(page);\n\n\tif (!free_pages_prepare(page, order, true))\n\t\treturn;\n\n\tmigratetype = get_pfnblock_migratetype(page, pfn);\n\tlocal_irq_save(flags);\n\t__count_vm_events(PGFREE, 1 << order);\n\tfree_one_page(page_zone(page), page, pfn, order, migratetype);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic void __free_pages_ok(struct page *page, unsigned int order)\n{\n\tunsigned long flags;\n\tint migratetype;\n\tunsigned long pfn = page_to_pfn(page);\n\n\tif (!free_pages_prepare(page, order, true))\n\t\treturn;\n\n\tmigratetype = get_pfnblock_migratetype(page, pfn);\n\tlocal_irq_save(flags);\n\t__count_vm_events(PGFREE, 1 << order);\n\tfree_one_page(page_zone(page), page, pfn, order, migratetype);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "compound_order",
          "args": [
            "page"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid free_compound_page(struct page *page)\n{\n\t__free_pages_ok(page, compound_order(page));\n}"
  },
  {
    "function_name": "bad_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "512-554",
    "snippet": "static void bad_page(struct page *page, const char *reason,\n\t\tunsigned long bad_flags)\n{\n\tstatic unsigned long resume;\n\tstatic unsigned long nr_shown;\n\tstatic unsigned long nr_unshown;\n\n\t/*\n\t * Allow a burst of 60 reports, then keep quiet for that minute;\n\t * or allow a steady drip of one report per second.\n\t */\n\tif (nr_shown == 60) {\n\t\tif (time_before(jiffies, resume)) {\n\t\t\tnr_unshown++;\n\t\t\tgoto out;\n\t\t}\n\t\tif (nr_unshown) {\n\t\t\tpr_alert(\n\t\t\t      \"BUG: Bad page state: %lu messages suppressed\\n\",\n\t\t\t\tnr_unshown);\n\t\t\tnr_unshown = 0;\n\t\t}\n\t\tnr_shown = 0;\n\t}\n\tif (nr_shown++ == 0)\n\t\tresume = jiffies + 60 * HZ;\n\n\tpr_alert(\"BUG: Bad page state in process %s  pfn:%05lx\\n\",\n\t\tcurrent->comm, page_to_pfn(page));\n\t__dump_page(page, reason);\n\tbad_flags &= page->flags;\n\tif (bad_flags)\n\t\tpr_alert(\"bad because of flags: %#lx(%pGp)\\n\",\n\t\t\t\t\t\tbad_flags, &bad_flags);\n\tdump_page_owner(page);\n\n\tprint_modules();\n\tdump_stack();\nout:\n\t/* Leave bad fields for debug, except PageBuddy could make trouble */\n\tpage_mapcount_reset(page); /* remove PageBuddy */\n\tadd_taint(TAINT_BAD_PAGE, LOCKDEP_NOW_UNRELIABLE);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_taint",
          "args": [
            "TAINT_BAD_PAGE",
            "LOCKDEP_NOW_UNRELIABLE"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapcount_reset",
          "args": [
            "page"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_modules",
          "args": [],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_page_owner",
          "args": [
            "page"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "__dump_page_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_owner.c",
          "lines": "408-451",
          "snippet": "void __dump_page_owner(struct page *page)\n{\n\tstruct page_ext *page_ext = lookup_page_ext(page);\n\tstruct page_owner *page_owner;\n\tunsigned long entries[PAGE_OWNER_STACK_DEPTH];\n\tstruct stack_trace trace = {\n\t\t.nr_entries = 0,\n\t\t.entries = entries,\n\t\t.max_entries = PAGE_OWNER_STACK_DEPTH,\n\t\t.skip = 0\n\t};\n\tdepot_stack_handle_t handle;\n\tgfp_t gfp_mask;\n\tint mt;\n\n\tif (unlikely(!page_ext)) {\n\t\tpr_alert(\"There is not page extension available.\\n\");\n\t\treturn;\n\t}\n\n\tpage_owner = get_page_owner(page_ext);\n\tgfp_mask = page_owner->gfp_mask;\n\tmt = gfpflags_to_migratetype(gfp_mask);\n\n\tif (!test_bit(PAGE_EXT_OWNER, &page_ext->flags)) {\n\t\tpr_alert(\"page_owner info is not active (free page?)\\n\");\n\t\treturn;\n\t}\n\n\thandle = READ_ONCE(page_owner->handle);\n\tif (!handle) {\n\t\tpr_alert(\"page_owner info is not active (free page?)\\n\");\n\t\treturn;\n\t}\n\n\tdepot_fetch_stack(handle, &trace);\n\tpr_alert(\"page allocated via order %u, migratetype %s, gfp_mask %#x(%pGg)\\n\",\n\t\t page_owner->order, migratetype_names[mt], gfp_mask, &gfp_mask);\n\tprint_stack_trace(&trace, 0);\n\n\tif (page_owner->last_migrate_reason != -1)\n\t\tpr_alert(\"page has been migrated, last migrate reason: %s\\n\",\n\t\t\tmigrate_reason_names[page_owner->last_migrate_reason]);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/stackdepot.h>",
            "#include <linux/migrate.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [
            "#define PAGE_OWNER_STACK_DEPTH (16)"
          ],
          "globals_used": [
            "static __always_inline depot_stack_handle_t"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/stackdepot.h>\n#include <linux/migrate.h>\n#include <linux/jump_label.h>\n#include <linux/page_owner.h>\n#include <linux/stacktrace.h>\n#include <linux/memblock.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/debugfs.h>\n\n#define PAGE_OWNER_STACK_DEPTH (16)\n\nstatic __always_inline depot_stack_handle_t;\n\nvoid __dump_page_owner(struct page *page)\n{\n\tstruct page_ext *page_ext = lookup_page_ext(page);\n\tstruct page_owner *page_owner;\n\tunsigned long entries[PAGE_OWNER_STACK_DEPTH];\n\tstruct stack_trace trace = {\n\t\t.nr_entries = 0,\n\t\t.entries = entries,\n\t\t.max_entries = PAGE_OWNER_STACK_DEPTH,\n\t\t.skip = 0\n\t};\n\tdepot_stack_handle_t handle;\n\tgfp_t gfp_mask;\n\tint mt;\n\n\tif (unlikely(!page_ext)) {\n\t\tpr_alert(\"There is not page extension available.\\n\");\n\t\treturn;\n\t}\n\n\tpage_owner = get_page_owner(page_ext);\n\tgfp_mask = page_owner->gfp_mask;\n\tmt = gfpflags_to_migratetype(gfp_mask);\n\n\tif (!test_bit(PAGE_EXT_OWNER, &page_ext->flags)) {\n\t\tpr_alert(\"page_owner info is not active (free page?)\\n\");\n\t\treturn;\n\t}\n\n\thandle = READ_ONCE(page_owner->handle);\n\tif (!handle) {\n\t\tpr_alert(\"page_owner info is not active (free page?)\\n\");\n\t\treturn;\n\t}\n\n\tdepot_fetch_stack(handle, &trace);\n\tpr_alert(\"page allocated via order %u, migratetype %s, gfp_mask %#x(%pGg)\\n\",\n\t\t page_owner->order, migratetype_names[mt], gfp_mask, &gfp_mask);\n\tprint_stack_trace(&trace, 0);\n\n\tif (page_owner->last_migrate_reason != -1)\n\t\tpr_alert(\"page has been migrated, last migrate reason: %s\\n\",\n\t\t\tmigrate_reason_names[page_owner->last_migrate_reason]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"bad because of flags: %#lx(%pGp)\\n\"",
            "bad_flags",
            "&bad_flags"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__dump_page",
          "args": [
            "page",
            "reason"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "__dump_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/debug.c",
          "lines": "45-89",
          "snippet": "void __dump_page(struct page *page, const char *reason)\n{\n\tbool page_poisoned = PagePoisoned(page);\n\tint mapcount;\n\n\t/*\n\t * If struct page is poisoned don't access Page*() functions as that\n\t * leads to recursive loop. Page*() check for poisoned pages, and calls\n\t * dump_page() when detected.\n\t */\n\tif (page_poisoned) {\n\t\tpr_emerg(\"page:%px is uninitialized and poisoned\", page);\n\t\tgoto hex_only;\n\t}\n\n\t/*\n\t * Avoid VM_BUG_ON() in page_mapcount().\n\t * page->_mapcount space in struct page is used by sl[aou]b pages to\n\t * encode own info.\n\t */\n\tmapcount = PageSlab(page) ? 0 : page_mapcount(page);\n\n\tpr_emerg(\"page:%px count:%d mapcount:%d mapping:%px index:%#lx\",\n\t\t  page, page_ref_count(page), mapcount,\n\t\t  page->mapping, page_to_pgoff(page));\n\tif (PageCompound(page))\n\t\tpr_cont(\" compound_mapcount: %d\", compound_mapcount(page));\n\tpr_cont(\"\\n\");\n\tBUILD_BUG_ON(ARRAY_SIZE(pageflag_names) != __NR_PAGEFLAGS + 1);\n\n\tpr_emerg(\"flags: %#lx(%pGp)\\n\", page->flags, &page->flags);\n\nhex_only:\n\tprint_hex_dump(KERN_ALERT, \"raw: \", DUMP_PREFIX_NONE, 32,\n\t\t\tsizeof(unsigned long), page,\n\t\t\tsizeof(struct page), false);\n\n\tif (reason)\n\t\tpr_alert(\"page dumped because: %s\\n\", reason);\n\n#ifdef CONFIG_MEMCG\n\tif (!page_poisoned && page->mem_cgroup)\n\t\tpr_alert(\"page->mem_cgroup:%px\\n\", page->mem_cgroup);\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/migrate.h>",
            "#include <trace/events/mmflags.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct trace_print_flags pageflag_names[] = {\n\t__def_pageflag_names,\n\t{0, NULL}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/ctype.h>\n#include <linux/page_owner.h>\n#include <linux/migrate.h>\n#include <trace/events/mmflags.h>\n#include <linux/memcontrol.h>\n#include <linux/trace_events.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nconst struct trace_print_flags pageflag_names[] = {\n\t__def_pageflag_names,\n\t{0, NULL}\n};\n\nvoid __dump_page(struct page *page, const char *reason)\n{\n\tbool page_poisoned = PagePoisoned(page);\n\tint mapcount;\n\n\t/*\n\t * If struct page is poisoned don't access Page*() functions as that\n\t * leads to recursive loop. Page*() check for poisoned pages, and calls\n\t * dump_page() when detected.\n\t */\n\tif (page_poisoned) {\n\t\tpr_emerg(\"page:%px is uninitialized and poisoned\", page);\n\t\tgoto hex_only;\n\t}\n\n\t/*\n\t * Avoid VM_BUG_ON() in page_mapcount().\n\t * page->_mapcount space in struct page is used by sl[aou]b pages to\n\t * encode own info.\n\t */\n\tmapcount = PageSlab(page) ? 0 : page_mapcount(page);\n\n\tpr_emerg(\"page:%px count:%d mapcount:%d mapping:%px index:%#lx\",\n\t\t  page, page_ref_count(page), mapcount,\n\t\t  page->mapping, page_to_pgoff(page));\n\tif (PageCompound(page))\n\t\tpr_cont(\" compound_mapcount: %d\", compound_mapcount(page));\n\tpr_cont(\"\\n\");\n\tBUILD_BUG_ON(ARRAY_SIZE(pageflag_names) != __NR_PAGEFLAGS + 1);\n\n\tpr_emerg(\"flags: %#lx(%pGp)\\n\", page->flags, &page->flags);\n\nhex_only:\n\tprint_hex_dump(KERN_ALERT, \"raw: \", DUMP_PREFIX_NONE, 32,\n\t\t\tsizeof(unsigned long), page,\n\t\t\tsizeof(struct page), false);\n\n\tif (reason)\n\t\tpr_alert(\"page dumped because: %s\\n\", reason);\n\n#ifdef CONFIG_MEMCG\n\tif (!page_poisoned && page->mem_cgroup)\n\t\tpr_alert(\"page->mem_cgroup:%px\\n\", page->mem_cgroup);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"BUG: Bad page state in process %s  pfn:%05lx\\n\"",
            "current->comm",
            "page_to_pfn(page)"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "page"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"BUG: Bad page state: %lu messages suppressed\\n\"",
            "nr_unshown"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "jiffies",
            "resume"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic void bad_page(struct page *page, const char *reason,\n\t\tunsigned long bad_flags)\n{\n\tstatic unsigned long resume;\n\tstatic unsigned long nr_shown;\n\tstatic unsigned long nr_unshown;\n\n\t/*\n\t * Allow a burst of 60 reports, then keep quiet for that minute;\n\t * or allow a steady drip of one report per second.\n\t */\n\tif (nr_shown == 60) {\n\t\tif (time_before(jiffies, resume)) {\n\t\t\tnr_unshown++;\n\t\t\tgoto out;\n\t\t}\n\t\tif (nr_unshown) {\n\t\t\tpr_alert(\n\t\t\t      \"BUG: Bad page state: %lu messages suppressed\\n\",\n\t\t\t\tnr_unshown);\n\t\t\tnr_unshown = 0;\n\t\t}\n\t\tnr_shown = 0;\n\t}\n\tif (nr_shown++ == 0)\n\t\tresume = jiffies + 60 * HZ;\n\n\tpr_alert(\"BUG: Bad page state in process %s  pfn:%05lx\\n\",\n\t\tcurrent->comm, page_to_pfn(page));\n\t__dump_page(page, reason);\n\tbad_flags &= page->flags;\n\tif (bad_flags)\n\t\tpr_alert(\"bad because of flags: %#lx(%pGp)\\n\",\n\t\t\t\t\t\tbad_flags, &bad_flags);\n\tdump_page_owner(page);\n\n\tprint_modules();\n\tdump_stack();\nout:\n\t/* Leave bad fields for debug, except PageBuddy could make trouble */\n\tpage_mapcount_reset(page); /* remove PageBuddy */\n\tadd_taint(TAINT_BAD_PAGE, LOCKDEP_NOW_UNRELIABLE);\n}"
  },
  {
    "function_name": "bad_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "506-509",
    "snippet": "static inline int __maybe_unused bad_range(struct zone *zone, struct page *page)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline int __maybe_unused bad_range(struct zone *zone, struct page *page)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "bad_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "496-504",
    "snippet": "static int __maybe_unused bad_range(struct zone *zone, struct page *page)\n{\n\tif (page_outside_zone_boundaries(zone, page))\n\t\treturn 1;\n\tif (!page_is_consistent(zone, page))\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_is_consistent",
          "args": [
            "zone",
            "page"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "page_is_consistent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "484-492",
          "snippet": "static int page_is_consistent(struct zone *zone, struct page *page)\n{\n\tif (!pfn_valid_within(page_to_pfn(page)))\n\t\treturn 0;\n\tif (zone != page_zone(page))\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic int page_is_consistent(struct zone *zone, struct page *page)\n{\n\tif (!pfn_valid_within(page_to_pfn(page)))\n\t\treturn 0;\n\tif (zone != page_zone(page))\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_outside_zone_boundaries",
          "args": [
            "zone",
            "page"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "page_outside_zone_boundaries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "461-482",
          "snippet": "static int page_outside_zone_boundaries(struct zone *zone, struct page *page)\n{\n\tint ret = 0;\n\tunsigned seq;\n\tunsigned long pfn = page_to_pfn(page);\n\tunsigned long sp, start_pfn;\n\n\tdo {\n\t\tseq = zone_span_seqbegin(zone);\n\t\tstart_pfn = zone->zone_start_pfn;\n\t\tsp = zone->spanned_pages;\n\t\tif (!zone_spans_pfn(zone, pfn))\n\t\t\tret = 1;\n\t} while (zone_span_seqretry(zone, seq));\n\n\tif (ret)\n\t\tpr_err(\"page 0x%lx outside node %d zone %s [ 0x%lx - 0x%lx ]\\n\",\n\t\t\tpfn, zone_to_nid(zone), zone->name,\n\t\t\tstart_pfn, start_pfn + sp);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic int page_outside_zone_boundaries(struct zone *zone, struct page *page)\n{\n\tint ret = 0;\n\tunsigned seq;\n\tunsigned long pfn = page_to_pfn(page);\n\tunsigned long sp, start_pfn;\n\n\tdo {\n\t\tseq = zone_span_seqbegin(zone);\n\t\tstart_pfn = zone->zone_start_pfn;\n\t\tsp = zone->spanned_pages;\n\t\tif (!zone_spans_pfn(zone, pfn))\n\t\t\tret = 1;\n\t} while (zone_span_seqretry(zone, seq));\n\n\tif (ret)\n\t\tpr_err(\"page 0x%lx outside node %d zone %s [ 0x%lx - 0x%lx ]\\n\",\n\t\t\tpfn, zone_to_nid(zone), zone->name,\n\t\t\tstart_pfn, start_pfn + sp);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic int __maybe_unused bad_range(struct zone *zone, struct page *page)\n{\n\tif (page_outside_zone_boundaries(zone, page))\n\t\treturn 1;\n\tif (!page_is_consistent(zone, page))\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "page_is_consistent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "484-492",
    "snippet": "static int page_is_consistent(struct zone *zone, struct page *page)\n{\n\tif (!pfn_valid_within(page_to_pfn(page)))\n\t\treturn 0;\n\tif (zone != page_zone(page))\n\t\treturn 0;\n\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "page"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_valid_within",
          "args": [
            "page_to_pfn(page)"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "page"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic int page_is_consistent(struct zone *zone, struct page *page)\n{\n\tif (!pfn_valid_within(page_to_pfn(page)))\n\t\treturn 0;\n\tif (zone != page_zone(page))\n\t\treturn 0;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "page_outside_zone_boundaries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "461-482",
    "snippet": "static int page_outside_zone_boundaries(struct zone *zone, struct page *page)\n{\n\tint ret = 0;\n\tunsigned seq;\n\tunsigned long pfn = page_to_pfn(page);\n\tunsigned long sp, start_pfn;\n\n\tdo {\n\t\tseq = zone_span_seqbegin(zone);\n\t\tstart_pfn = zone->zone_start_pfn;\n\t\tsp = zone->spanned_pages;\n\t\tif (!zone_spans_pfn(zone, pfn))\n\t\t\tret = 1;\n\t} while (zone_span_seqretry(zone, seq));\n\n\tif (ret)\n\t\tpr_err(\"page 0x%lx outside node %d zone %s [ 0x%lx - 0x%lx ]\\n\",\n\t\t\tpfn, zone_to_nid(zone), zone->name,\n\t\t\tstart_pfn, start_pfn + sp);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"page 0x%lx outside node %d zone %s [ 0x%lx - 0x%lx ]\\n\"",
            "pfn",
            "zone_to_nid(zone)",
            "zone->name",
            "start_pfn",
            "start_pfn + sp"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_to_nid",
          "args": [
            "zone"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_span_seqretry",
          "args": [
            "zone",
            "seq"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_spans_pfn",
          "args": [
            "zone",
            "pfn"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_span_seqbegin",
          "args": [
            "zone"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "page"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic int page_outside_zone_boundaries(struct zone *zone, struct page *page)\n{\n\tint ret = 0;\n\tunsigned seq;\n\tunsigned long pfn = page_to_pfn(page);\n\tunsigned long sp, start_pfn;\n\n\tdo {\n\t\tseq = zone_span_seqbegin(zone);\n\t\tstart_pfn = zone->zone_start_pfn;\n\t\tsp = zone->spanned_pages;\n\t\tif (!zone_spans_pfn(zone, pfn))\n\t\t\tret = 1;\n\t} while (zone_span_seqretry(zone, seq));\n\n\tif (ret)\n\t\tpr_err(\"page 0x%lx outside node %d zone %s [ 0x%lx - 0x%lx ]\\n\",\n\t\t\tpfn, zone_to_nid(zone), zone->name,\n\t\t\tstart_pfn, start_pfn + sp);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "set_pageblock_migratetype",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "450-458",
    "snippet": "void set_pageblock_migratetype(struct page *page, int migratetype)\n{\n\tif (unlikely(page_group_by_mobility_disabled &&\n\t\t     migratetype < MIGRATE_PCPTYPES))\n\t\tmigratetype = MIGRATE_UNMOVABLE;\n\n\tset_pageblock_flags_group(page, (unsigned long)migratetype,\n\t\t\t\t\tPB_migrate, PB_migrate_end);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int page_group_by_mobility_disabled",
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_pageblock_flags_group",
          "args": [
            "page",
            "(unsigned long)migratetype",
            "PB_migrate",
            "PB_migrate_end"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "page_group_by_mobility_disabled &&\n\t\t     migratetype < MIGRATE_PCPTYPES"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nint page_group_by_mobility_disabled;\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid set_pageblock_migratetype(struct page *page, int migratetype)\n{\n\tif (unlikely(page_group_by_mobility_disabled &&\n\t\t     migratetype < MIGRATE_PCPTYPES))\n\t\tmigratetype = MIGRATE_UNMOVABLE;\n\n\tset_pageblock_flags_group(page, (unsigned long)migratetype,\n\t\t\t\t\tPB_migrate, PB_migrate_end);\n}"
  },
  {
    "function_name": "set_pfnblock_flags_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "419-448",
    "snippet": "void set_pfnblock_flags_mask(struct page *page, unsigned long flags,\n\t\t\t\t\tunsigned long pfn,\n\t\t\t\t\tunsigned long end_bitidx,\n\t\t\t\t\tunsigned long mask)\n{\n\tunsigned long *bitmap;\n\tunsigned long bitidx, word_bitidx;\n\tunsigned long old_word, word;\n\n\tBUILD_BUG_ON(NR_PAGEBLOCK_BITS != 4);\n\n\tbitmap = get_pageblock_bitmap(page, pfn);\n\tbitidx = pfn_to_bitidx(page, pfn);\n\tword_bitidx = bitidx / BITS_PER_LONG;\n\tbitidx &= (BITS_PER_LONG-1);\n\n\tVM_BUG_ON_PAGE(!zone_spans_pfn(page_zone(page), pfn), page);\n\n\tbitidx += end_bitidx;\n\tmask <<= (BITS_PER_LONG - bitidx - 1);\n\tflags <<= (BITS_PER_LONG - bitidx - 1);\n\n\tword = READ_ONCE(bitmap[word_bitidx]);\n\tfor (;;) {\n\t\told_word = cmpxchg(&bitmap[word_bitidx], word, (word & ~mask) | flags);\n\t\tif (word == old_word)\n\t\t\tbreak;\n\t\tword = old_word;\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cmpxchg",
          "args": [
            "&bitmap[word_bitidx]",
            "word",
            "(word & ~mask) | flags"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "note_cmpxchg_failure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/slub.c",
          "lines": "1992-2014",
          "snippet": "static inline void note_cmpxchg_failure(const char *n,\n\t\tconst struct kmem_cache *s, unsigned long tid)\n{\n#ifdef SLUB_DEBUG_CMPXCHG\n\tunsigned long actual_tid = __this_cpu_read(s->cpu_slab->tid);\n\n\tpr_info(\"%s %s: cmpxchg redo \", n, s->name);\n\n#ifdef CONFIG_PREEMPT\n\tif (tid_to_cpu(tid) != tid_to_cpu(actual_tid))\n\t\tpr_warn(\"due to cpu change %d -> %d\\n\",\n\t\t\ttid_to_cpu(tid), tid_to_cpu(actual_tid));\n\telse\n#endif\n\tif (tid_to_event(tid) != tid_to_event(actual_tid))\n\t\tpr_warn(\"due to cpu running other code. Event %ld->%ld\\n\",\n\t\t\ttid_to_event(tid), tid_to_event(actual_tid));\n\telse\n\t\tpr_warn(\"for unknown reason: actual=%lx was=%lx target=%lx\\n\",\n\t\t\tactual_tid, tid, next_tid(tid));\n#endif\n\tstat(s, CMPXCHG_DOUBLE_CPU_FAIL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/kmem.h>",
            "#include <linux/random.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/math64.h>",
            "#include <linux/memory.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/kasan.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include \"slab.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/swap.h> /* struct reclaim_state */",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/kmem.h>\n#include <linux/random.h>\n#include <linux/memcontrol.h>\n#include <linux/prefetch.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n#include <linux/math64.h>\n#include <linux/memory.h>\n#include <linux/kallsyms.h>\n#include <linux/debugobjects.h>\n#include <linux/ctype.h>\n#include <linux/mempolicy.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/kasan.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include \"slab.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/bit_spinlock.h>\n#include <linux/module.h>\n#include <linux/swap.h> /* struct reclaim_state */\n#include <linux/mm.h>\n\nstatic inline void note_cmpxchg_failure(const char *n,\n\t\tconst struct kmem_cache *s, unsigned long tid)\n{\n#ifdef SLUB_DEBUG_CMPXCHG\n\tunsigned long actual_tid = __this_cpu_read(s->cpu_slab->tid);\n\n\tpr_info(\"%s %s: cmpxchg redo \", n, s->name);\n\n#ifdef CONFIG_PREEMPT\n\tif (tid_to_cpu(tid) != tid_to_cpu(actual_tid))\n\t\tpr_warn(\"due to cpu change %d -> %d\\n\",\n\t\t\ttid_to_cpu(tid), tid_to_cpu(actual_tid));\n\telse\n#endif\n\tif (tid_to_event(tid) != tid_to_event(actual_tid))\n\t\tpr_warn(\"due to cpu running other code. Event %ld->%ld\\n\",\n\t\t\ttid_to_event(tid), tid_to_event(actual_tid));\n\telse\n\t\tpr_warn(\"for unknown reason: actual=%lx was=%lx target=%lx\\n\",\n\t\t\tactual_tid, tid, next_tid(tid));\n#endif\n\tstat(s, CMPXCHG_DOUBLE_CPU_FAIL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "bitmap[word_bitidx]"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON_PAGE",
          "args": [
            "!zone_spans_pfn(page_zone(page), pfn)",
            "page"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zone_spans_pfn",
          "args": [
            "page_zone(page)",
            "pfn"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "page"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_bitidx",
          "args": [
            "page",
            "pfn"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "pfn_to_bitidx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "360-369",
          "snippet": "static inline int pfn_to_bitidx(struct page *page, unsigned long pfn)\n{\n#ifdef CONFIG_SPARSEMEM\n\tpfn &= (PAGES_PER_SECTION-1);\n\treturn (pfn >> pageblock_order) * NR_PAGEBLOCK_BITS;\n#else\n\tpfn = pfn - round_down(page_zone(page)->zone_start_pfn, pageblock_nr_pages);\n\treturn (pfn >> pageblock_order) * NR_PAGEBLOCK_BITS;\n#endif /* CONFIG_SPARSEMEM */\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline int pfn_to_bitidx(struct page *page, unsigned long pfn)\n{\n#ifdef CONFIG_SPARSEMEM\n\tpfn &= (PAGES_PER_SECTION-1);\n\treturn (pfn >> pageblock_order) * NR_PAGEBLOCK_BITS;\n#else\n\tpfn = pfn - round_down(page_zone(page)->zone_start_pfn, pageblock_nr_pages);\n\treturn (pfn >> pageblock_order) * NR_PAGEBLOCK_BITS;\n#endif /* CONFIG_SPARSEMEM */\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pageblock_bitmap",
          "args": [
            "page",
            "pfn"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "get_pageblock_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "350-358",
          "snippet": "static inline unsigned long *get_pageblock_bitmap(struct page *page,\n\t\t\t\t\t\t\tunsigned long pfn)\n{\n#ifdef CONFIG_SPARSEMEM\n\treturn __pfn_to_section(pfn)->pageblock_flags;\n#else\n\treturn page_zone(page)->pageblock_flags;\n#endif /* CONFIG_SPARSEMEM */\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline unsigned long *get_pageblock_bitmap(struct page *page,\n\t\t\t\t\t\t\tunsigned long pfn)\n{\n#ifdef CONFIG_SPARSEMEM\n\treturn __pfn_to_section(pfn)->pageblock_flags;\n#else\n\treturn page_zone(page)->pageblock_flags;\n#endif /* CONFIG_SPARSEMEM */\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "NR_PAGEBLOCK_BITS != 4"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid set_pfnblock_flags_mask(struct page *page, unsigned long flags,\n\t\t\t\t\tunsigned long pfn,\n\t\t\t\t\tunsigned long end_bitidx,\n\t\t\t\t\tunsigned long mask)\n{\n\tunsigned long *bitmap;\n\tunsigned long bitidx, word_bitidx;\n\tunsigned long old_word, word;\n\n\tBUILD_BUG_ON(NR_PAGEBLOCK_BITS != 4);\n\n\tbitmap = get_pageblock_bitmap(page, pfn);\n\tbitidx = pfn_to_bitidx(page, pfn);\n\tword_bitidx = bitidx / BITS_PER_LONG;\n\tbitidx &= (BITS_PER_LONG-1);\n\n\tVM_BUG_ON_PAGE(!zone_spans_pfn(page_zone(page), pfn), page);\n\n\tbitidx += end_bitidx;\n\tmask <<= (BITS_PER_LONG - bitidx - 1);\n\tflags <<= (BITS_PER_LONG - bitidx - 1);\n\n\tword = READ_ONCE(bitmap[word_bitidx]);\n\tfor (;;) {\n\t\told_word = cmpxchg(&bitmap[word_bitidx], word, (word & ~mask) | flags);\n\t\tif (word == old_word)\n\t\t\tbreak;\n\t\tword = old_word;\n\t}\n}"
  },
  {
    "function_name": "get_pfnblock_migratetype",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "406-409",
    "snippet": "static __always_inline int get_pfnblock_migratetype(struct page *page, unsigned long pfn)\n{\n\treturn __get_pfnblock_flags_mask(page, pfn, PB_migrate_end, MIGRATETYPE_MASK);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__get_pfnblock_flags_mask",
          "args": [
            "page",
            "pfn",
            "PB_migrate_end",
            "MIGRATETYPE_MASK"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "__get_pfnblock_flags_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "380-397",
          "snippet": "static __always_inline unsigned long __get_pfnblock_flags_mask(struct page *page,\n\t\t\t\t\tunsigned long pfn,\n\t\t\t\t\tunsigned long end_bitidx,\n\t\t\t\t\tunsigned long mask)\n{\n\tunsigned long *bitmap;\n\tunsigned long bitidx, word_bitidx;\n\tunsigned long word;\n\n\tbitmap = get_pageblock_bitmap(page, pfn);\n\tbitidx = pfn_to_bitidx(page, pfn);\n\tword_bitidx = bitidx / BITS_PER_LONG;\n\tbitidx &= (BITS_PER_LONG-1);\n\n\tword = bitmap[word_bitidx];\n\tbitidx += end_bitidx;\n\treturn (word >> (BITS_PER_LONG - bitidx - 1)) & mask;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic __always_inline unsigned long __get_pfnblock_flags_mask(struct page *page,\n\t\t\t\t\tunsigned long pfn,\n\t\t\t\t\tunsigned long end_bitidx,\n\t\t\t\t\tunsigned long mask)\n{\n\tunsigned long *bitmap;\n\tunsigned long bitidx, word_bitidx;\n\tunsigned long word;\n\n\tbitmap = get_pageblock_bitmap(page, pfn);\n\tbitidx = pfn_to_bitidx(page, pfn);\n\tword_bitidx = bitidx / BITS_PER_LONG;\n\tbitidx &= (BITS_PER_LONG-1);\n\n\tword = bitmap[word_bitidx];\n\tbitidx += end_bitidx;\n\treturn (word >> (BITS_PER_LONG - bitidx - 1)) & mask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic __always_inline int get_pfnblock_migratetype(struct page *page, unsigned long pfn)\n{\n\treturn __get_pfnblock_flags_mask(page, pfn, PB_migrate_end, MIGRATETYPE_MASK);\n}"
  },
  {
    "function_name": "get_pfnblock_flags_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "399-404",
    "snippet": "unsigned long get_pfnblock_flags_mask(struct page *page, unsigned long pfn,\n\t\t\t\t\tunsigned long end_bitidx,\n\t\t\t\t\tunsigned long mask)\n{\n\treturn __get_pfnblock_flags_mask(page, pfn, end_bitidx, mask);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__get_pfnblock_flags_mask",
          "args": [
            "page",
            "pfn",
            "end_bitidx",
            "mask"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "__get_pfnblock_flags_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "380-397",
          "snippet": "static __always_inline unsigned long __get_pfnblock_flags_mask(struct page *page,\n\t\t\t\t\tunsigned long pfn,\n\t\t\t\t\tunsigned long end_bitidx,\n\t\t\t\t\tunsigned long mask)\n{\n\tunsigned long *bitmap;\n\tunsigned long bitidx, word_bitidx;\n\tunsigned long word;\n\n\tbitmap = get_pageblock_bitmap(page, pfn);\n\tbitidx = pfn_to_bitidx(page, pfn);\n\tword_bitidx = bitidx / BITS_PER_LONG;\n\tbitidx &= (BITS_PER_LONG-1);\n\n\tword = bitmap[word_bitidx];\n\tbitidx += end_bitidx;\n\treturn (word >> (BITS_PER_LONG - bitidx - 1)) & mask;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic __always_inline unsigned long __get_pfnblock_flags_mask(struct page *page,\n\t\t\t\t\tunsigned long pfn,\n\t\t\t\t\tunsigned long end_bitidx,\n\t\t\t\t\tunsigned long mask)\n{\n\tunsigned long *bitmap;\n\tunsigned long bitidx, word_bitidx;\n\tunsigned long word;\n\n\tbitmap = get_pageblock_bitmap(page, pfn);\n\tbitidx = pfn_to_bitidx(page, pfn);\n\tword_bitidx = bitidx / BITS_PER_LONG;\n\tbitidx &= (BITS_PER_LONG-1);\n\n\tword = bitmap[word_bitidx];\n\tbitidx += end_bitidx;\n\treturn (word >> (BITS_PER_LONG - bitidx - 1)) & mask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nunsigned long get_pfnblock_flags_mask(struct page *page, unsigned long pfn,\n\t\t\t\t\tunsigned long end_bitidx,\n\t\t\t\t\tunsigned long mask)\n{\n\treturn __get_pfnblock_flags_mask(page, pfn, end_bitidx, mask);\n}"
  },
  {
    "function_name": "__get_pfnblock_flags_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "380-397",
    "snippet": "static __always_inline unsigned long __get_pfnblock_flags_mask(struct page *page,\n\t\t\t\t\tunsigned long pfn,\n\t\t\t\t\tunsigned long end_bitidx,\n\t\t\t\t\tunsigned long mask)\n{\n\tunsigned long *bitmap;\n\tunsigned long bitidx, word_bitidx;\n\tunsigned long word;\n\n\tbitmap = get_pageblock_bitmap(page, pfn);\n\tbitidx = pfn_to_bitidx(page, pfn);\n\tword_bitidx = bitidx / BITS_PER_LONG;\n\tbitidx &= (BITS_PER_LONG-1);\n\n\tword = bitmap[word_bitidx];\n\tbitidx += end_bitidx;\n\treturn (word >> (BITS_PER_LONG - bitidx - 1)) & mask;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfn_to_bitidx",
          "args": [
            "page",
            "pfn"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "pfn_to_bitidx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "360-369",
          "snippet": "static inline int pfn_to_bitidx(struct page *page, unsigned long pfn)\n{\n#ifdef CONFIG_SPARSEMEM\n\tpfn &= (PAGES_PER_SECTION-1);\n\treturn (pfn >> pageblock_order) * NR_PAGEBLOCK_BITS;\n#else\n\tpfn = pfn - round_down(page_zone(page)->zone_start_pfn, pageblock_nr_pages);\n\treturn (pfn >> pageblock_order) * NR_PAGEBLOCK_BITS;\n#endif /* CONFIG_SPARSEMEM */\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline int pfn_to_bitidx(struct page *page, unsigned long pfn)\n{\n#ifdef CONFIG_SPARSEMEM\n\tpfn &= (PAGES_PER_SECTION-1);\n\treturn (pfn >> pageblock_order) * NR_PAGEBLOCK_BITS;\n#else\n\tpfn = pfn - round_down(page_zone(page)->zone_start_pfn, pageblock_nr_pages);\n\treturn (pfn >> pageblock_order) * NR_PAGEBLOCK_BITS;\n#endif /* CONFIG_SPARSEMEM */\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pageblock_bitmap",
          "args": [
            "page",
            "pfn"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "get_pageblock_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "350-358",
          "snippet": "static inline unsigned long *get_pageblock_bitmap(struct page *page,\n\t\t\t\t\t\t\tunsigned long pfn)\n{\n#ifdef CONFIG_SPARSEMEM\n\treturn __pfn_to_section(pfn)->pageblock_flags;\n#else\n\treturn page_zone(page)->pageblock_flags;\n#endif /* CONFIG_SPARSEMEM */\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline unsigned long *get_pageblock_bitmap(struct page *page,\n\t\t\t\t\t\t\tunsigned long pfn)\n{\n#ifdef CONFIG_SPARSEMEM\n\treturn __pfn_to_section(pfn)->pageblock_flags;\n#else\n\treturn page_zone(page)->pageblock_flags;\n#endif /* CONFIG_SPARSEMEM */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic __always_inline unsigned long __get_pfnblock_flags_mask(struct page *page,\n\t\t\t\t\tunsigned long pfn,\n\t\t\t\t\tunsigned long end_bitidx,\n\t\t\t\t\tunsigned long mask)\n{\n\tunsigned long *bitmap;\n\tunsigned long bitidx, word_bitidx;\n\tunsigned long word;\n\n\tbitmap = get_pageblock_bitmap(page, pfn);\n\tbitidx = pfn_to_bitidx(page, pfn);\n\tword_bitidx = bitidx / BITS_PER_LONG;\n\tbitidx &= (BITS_PER_LONG-1);\n\n\tword = bitmap[word_bitidx];\n\tbitidx += end_bitidx;\n\treturn (word >> (BITS_PER_LONG - bitidx - 1)) & mask;\n}"
  },
  {
    "function_name": "pfn_to_bitidx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "360-369",
    "snippet": "static inline int pfn_to_bitidx(struct page *page, unsigned long pfn)\n{\n#ifdef CONFIG_SPARSEMEM\n\tpfn &= (PAGES_PER_SECTION-1);\n\treturn (pfn >> pageblock_order) * NR_PAGEBLOCK_BITS;\n#else\n\tpfn = pfn - round_down(page_zone(page)->zone_start_pfn, pageblock_nr_pages);\n\treturn (pfn >> pageblock_order) * NR_PAGEBLOCK_BITS;\n#endif /* CONFIG_SPARSEMEM */\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "round_down",
          "args": [
            "page_zone(page)->zone_start_pfn",
            "pageblock_nr_pages"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "page"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline int pfn_to_bitidx(struct page *page, unsigned long pfn)\n{\n#ifdef CONFIG_SPARSEMEM\n\tpfn &= (PAGES_PER_SECTION-1);\n\treturn (pfn >> pageblock_order) * NR_PAGEBLOCK_BITS;\n#else\n\tpfn = pfn - round_down(page_zone(page)->zone_start_pfn, pageblock_nr_pages);\n\treturn (pfn >> pageblock_order) * NR_PAGEBLOCK_BITS;\n#endif /* CONFIG_SPARSEMEM */\n}"
  },
  {
    "function_name": "get_pageblock_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "350-358",
    "snippet": "static inline unsigned long *get_pageblock_bitmap(struct page *page,\n\t\t\t\t\t\t\tunsigned long pfn)\n{\n#ifdef CONFIG_SPARSEMEM\n\treturn __pfn_to_section(pfn)->pageblock_flags;\n#else\n\treturn page_zone(page)->pageblock_flags;\n#endif /* CONFIG_SPARSEMEM */\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_zone",
          "args": [
            "page"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pfn_to_section",
          "args": [
            "pfn"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline unsigned long *get_pageblock_bitmap(struct page *page,\n\t\t\t\t\t\t\tunsigned long pfn)\n{\n#ifdef CONFIG_SPARSEMEM\n\treturn __pfn_to_section(pfn)->pageblock_flags;\n#else\n\treturn page_zone(page)->pageblock_flags;\n#endif /* CONFIG_SPARSEMEM */\n}"
  },
  {
    "function_name": "defer_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "343-346",
    "snippet": "static inline bool defer_init(int nid, unsigned long pfn, unsigned long end_pfn)\n{\n\treturn false;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic inline bool defer_init(int nid, unsigned long pfn, unsigned long end_pfn)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "early_page_uninitialised",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "338-341",
    "snippet": "static inline bool early_page_uninitialised(unsigned long pfn)\n{\n\treturn false;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic inline bool early_page_uninitialised(unsigned long pfn)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "defer_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "312-336",
    "snippet": "static bool __meminit\ndefer_init(int nid, unsigned long pfn, unsigned long end_pfn)\n{\n\tstatic unsigned long prev_end_pfn, nr_initialised;\n\n\t/*\n\t * prev_end_pfn static that contains the end of previous zone\n\t * No need to protect because called very early in boot before smp_init.\n\t */\n\tif (prev_end_pfn != end_pfn) {\n\t\tprev_end_pfn = end_pfn;\n\t\tnr_initialised = 0;\n\t}\n\n\t/* Always populate low zones for address-constrained allocations */\n\tif (end_pfn < pgdat_end_pfn(NODE_DATA(nid)))\n\t\treturn false;\n\tnr_initialised++;\n\tif ((nr_initialised > NODE_DATA(nid)->static_init_pgcnt) &&\n\t    (pfn & (PAGES_PER_SECTION - 1)) == 0) {\n\t\tNODE_DATA(nid)->first_deferred_pfn = pfn;\n\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "nid"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "nid"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgdat_end_pfn",
          "args": [
            "NODE_DATA(nid)"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "nid"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic bool __meminit\ndefer_init(int nid, unsigned long pfn, unsigned long end_pfn)\n{\n\tstatic unsigned long prev_end_pfn, nr_initialised;\n\n\t/*\n\t * prev_end_pfn static that contains the end of previous zone\n\t * No need to protect because called very early in boot before smp_init.\n\t */\n\tif (prev_end_pfn != end_pfn) {\n\t\tprev_end_pfn = end_pfn;\n\t\tnr_initialised = 0;\n\t}\n\n\t/* Always populate low zones for address-constrained allocations */\n\tif (end_pfn < pgdat_end_pfn(NODE_DATA(nid)))\n\t\treturn false;\n\tnr_initialised++;\n\tif ((nr_initialised > NODE_DATA(nid)->static_init_pgcnt) &&\n\t    (pfn & (PAGES_PER_SECTION - 1)) == 0) {\n\t\tNODE_DATA(nid)->first_deferred_pfn = pfn;\n\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "early_page_uninitialised",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "298-306",
    "snippet": "static inline bool __meminit early_page_uninitialised(unsigned long pfn)\n{\n\tint nid = early_pfn_to_nid(pfn);\n\n\tif (node_online(nid) && pfn >= NODE_DATA(nid)->first_deferred_pfn)\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "nid"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_online",
          "args": [
            "nid"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "early_pfn_to_nid",
          "args": [
            "pfn"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "early_pfn_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1292-1304",
          "snippet": "int __meminit early_pfn_to_nid(unsigned long pfn)\n{\n\tstatic DEFINE_SPINLOCK(early_pfn_lock);\n\tint nid;\n\n\tspin_lock(&early_pfn_lock);\n\tnid = __early_pfn_to_nid(pfn, &early_pfnnid_cache);\n\tif (nid < 0)\n\t\tnid = first_online_node;\n\tspin_unlock(&early_pfn_lock);\n\n\treturn nid;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nint __meminit early_pfn_to_nid(unsigned long pfn)\n{\n\tstatic DEFINE_SPINLOCK(early_pfn_lock);\n\tint nid;\n\n\tspin_lock(&early_pfn_lock);\n\tnid = __early_pfn_to_nid(pfn, &early_pfnnid_cache);\n\tif (nid < 0)\n\t\tnid = first_online_node;\n\tspin_unlock(&early_pfn_lock);\n\n\treturn nid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic inline bool __meminit early_page_uninitialised(unsigned long pfn)\n{\n\tint nid = early_pfn_to_nid(pfn);\n\n\tif (node_online(nid) && pfn >= NODE_DATA(nid)->first_deferred_pfn)\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "pm_suspended_storage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "182-187",
    "snippet": "bool pm_suspended_storage(void)\n{\n\tif ((gfp_allowed_mask & (__GFP_IO | __GFP_FS)) == (__GFP_IO | __GFP_FS))\n\t\treturn false;\n\treturn true;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "gfp_t gfp_allowed_mask"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\ngfp_t gfp_allowed_mask;\n\nbool pm_suspended_storage(void)\n{\n\tif ((gfp_allowed_mask & (__GFP_IO | __GFP_FS)) == (__GFP_IO | __GFP_FS))\n\t\treturn false;\n\treturn true;\n}"
  },
  {
    "function_name": "pm_restrict_gfp_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "174-180",
    "snippet": "void pm_restrict_gfp_mask(void)\n{\n\tWARN_ON(!mutex_is_locked(&system_transition_mutex));\n\tWARN_ON(saved_gfp_mask);\n\tsaved_gfp_mask = gfp_allowed_mask;\n\tgfp_allowed_mask &= ~(__GFP_IO | __GFP_FS);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "gfp_t gfp_allowed_mask"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "saved_gfp_mask"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!mutex_is_locked(&system_transition_mutex)"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&system_transition_mutex"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\ngfp_t gfp_allowed_mask;\n\nvoid pm_restrict_gfp_mask(void)\n{\n\tWARN_ON(!mutex_is_locked(&system_transition_mutex));\n\tWARN_ON(saved_gfp_mask);\n\tsaved_gfp_mask = gfp_allowed_mask;\n\tgfp_allowed_mask &= ~(__GFP_IO | __GFP_FS);\n}"
  },
  {
    "function_name": "pm_restore_gfp_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "165-172",
    "snippet": "void pm_restore_gfp_mask(void)\n{\n\tWARN_ON(!mutex_is_locked(&system_transition_mutex));\n\tif (saved_gfp_mask) {\n\t\tgfp_allowed_mask = saved_gfp_mask;\n\t\tsaved_gfp_mask = 0;\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "gfp_t gfp_allowed_mask"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!mutex_is_locked(&system_transition_mutex)"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&system_transition_mutex"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\ngfp_t gfp_allowed_mask;\n\nvoid pm_restore_gfp_mask(void)\n{\n\tWARN_ON(!mutex_is_locked(&system_transition_mutex));\n\tif (saved_gfp_mask) {\n\t\tgfp_allowed_mask = saved_gfp_mask;\n\t\tsaved_gfp_mask = 0;\n\t}\n}"
  },
  {
    "function_name": "set_pcppage_migratetype",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "147-150",
    "snippet": "static inline void set_pcppage_migratetype(struct page *page, int migratetype)\n{\n\tpage->index = migratetype;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline void set_pcppage_migratetype(struct page *page, int migratetype)\n{\n\tpage->index = migratetype;\n}"
  },
  {
    "function_name": "get_pcppage_migratetype",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
    "lines": "142-145",
    "snippet": "static inline int get_pcppage_migratetype(struct page *page)\n{\n\treturn page->index;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/div64.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/psi.h>",
      "#include <linux/nmi.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/kthread.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/migrate.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/prefetch.h>",
      "#include <trace/events/oom.h>",
      "#include <trace/events/kmem.h>",
      "#include <linux/compaction.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/debugobjects.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/page-isolation.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/pfn.h>",
      "#include <linux/sort.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/memremap.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/vmstat.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/memory_hotplug.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/topology.h>",
      "#include <linux/oom.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/suspend.h>",
      "#include <linux/module.h>",
      "#include <linux/kasan.h>",
      "#include <linux/kernel.h>",
      "#include <linux/compiler.h>",
      "#include <linux/memblock.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline\nstruct",
      "static __always_inline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nstatic inline int get_pcppage_migratetype(struct page *page)\n{\n\treturn page->index;\n}"
  }
]