[
  {
    "function_name": "pgdat_page_ext_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
    "lines": "420-422",
    "snippet": "void __meminit pgdat_page_ext_init(struct pglist_data *pgdat)\n{\n}",
    "includes": [
      "#include <linux/page_idle.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/memory.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nvoid __meminit pgdat_page_ext_init(struct pglist_data *pgdat)\n{\n}"
  },
  {
    "function_name": "page_ext_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
    "lines": "373-418",
    "snippet": "void __init page_ext_init(void)\n{\n\tunsigned long pfn;\n\tint nid;\n\n\tif (!invoke_need_callbacks())\n\t\treturn;\n\n\tfor_each_node_state(nid, N_MEMORY) {\n\t\tunsigned long start_pfn, end_pfn;\n\n\t\tstart_pfn = node_start_pfn(nid);\n\t\tend_pfn = node_end_pfn(nid);\n\t\t/*\n\t\t * start_pfn and end_pfn may not be aligned to SECTION and the\n\t\t * page->flags of out of node pages are not initialized.  So we\n\t\t * scan [start_pfn, the biggest section's pfn < end_pfn) here.\n\t\t */\n\t\tfor (pfn = start_pfn; pfn < end_pfn;\n\t\t\tpfn = ALIGN(pfn + 1, PAGES_PER_SECTION)) {\n\n\t\t\tif (!pfn_valid(pfn))\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Nodes's pfns can be overlapping.\n\t\t\t * We know some arch can have a nodes layout such as\n\t\t\t * -------------pfn-------------->\n\t\t\t * N0 | N1 | N2 | N0 | N1 | N2|....\n\t\t\t *\n\t\t\t * Take into account DEFERRED_STRUCT_PAGE_INIT.\n\t\t\t */\n\t\t\tif (early_pfn_to_nid(pfn) != nid)\n\t\t\t\tcontinue;\n\t\t\tif (init_section_page_ext(pfn, nid))\n\t\t\t\tgoto oom;\n\t\t\tcond_resched();\n\t\t}\n\t}\n\thotplug_memory_notifier(page_ext_callback, 0);\n\tpr_info(\"allocated %ld bytes of page_ext\\n\", total_usage);\n\tinvoke_init_callbacks();\n\treturn;\n\noom:\n\tpanic(\"Out of memory\");\n}",
    "includes": [
      "#include <linux/page_idle.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/memory.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long total_usage;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"Out of memory\""
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invoke_init_callbacks",
          "args": [],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "invoke_init_callbacks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
          "lines": "94-103",
          "snippet": "static void __init invoke_init_callbacks(void)\n{\n\tint i;\n\tint entries = ARRAY_SIZE(page_ext_ops);\n\n\tfor (i = 0; i < entries; i++) {\n\t\tif (page_ext_ops[i]->init)\n\t\t\tpage_ext_ops[i]->init();\n\t}\n}",
          "includes": [
            "#include <linux/page_idle.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/memory.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct page_ext_operations *page_ext_ops[] = {\n#ifdef CONFIG_DEBUG_PAGEALLOC\n\t&debug_guardpage_ops,\n#endif\n#ifdef CONFIG_PAGE_OWNER\n\t&page_owner_ops,\n#endif\n#if defined(CONFIG_IDLE_PAGE_TRACKING) && !defined(CONFIG_64BIT)\n\t&page_idle_ops,\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nstatic struct page_ext_operations *page_ext_ops[] = {\n#ifdef CONFIG_DEBUG_PAGEALLOC\n\t&debug_guardpage_ops,\n#endif\n#ifdef CONFIG_PAGE_OWNER\n\t&page_owner_ops,\n#endif\n#if defined(CONFIG_IDLE_PAGE_TRACKING) && !defined(CONFIG_64BIT)\n\t&page_idle_ops,\n#endif\n};\n\nstatic void __init invoke_init_callbacks(void)\n{\n\tint i;\n\tint entries = ARRAY_SIZE(page_ext_ops);\n\n\tfor (i = 0; i < entries; i++) {\n\t\tif (page_ext_ops[i]->init)\n\t\t\tpage_ext_ops[i]->init();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"allocated %ld bytes of page_ext\\n\"",
            "total_usage"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hotplug_memory_notifier",
          "args": [
            "page_ext_callback",
            "0"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_section_page_ext",
          "args": [
            "pfn",
            "nid"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "init_section_page_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
          "lines": "229-263",
          "snippet": "static int __meminit init_section_page_ext(unsigned long pfn, int nid)\n{\n\tstruct mem_section *section;\n\tstruct page_ext *base;\n\tunsigned long table_size;\n\n\tsection = __pfn_to_section(pfn);\n\n\tif (section->page_ext)\n\t\treturn 0;\n\n\ttable_size = get_entry_size() * PAGES_PER_SECTION;\n\tbase = alloc_page_ext(table_size, nid);\n\n\t/*\n\t * The value stored in section->page_ext is (base - pfn)\n\t * and it does not point to the memory block allocated above,\n\t * causing kmemleak false positives.\n\t */\n\tkmemleak_not_leak(base);\n\n\tif (!base) {\n\t\tpr_err(\"page ext allocation failure\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/*\n\t * The passed \"pfn\" may not be aligned to SECTION.  For the calculation\n\t * we need to apply a mask.\n\t */\n\tpfn &= PAGE_SECTION_MASK;\n\tsection->page_ext = (void *)base - get_entry_size() * pfn;\n\ttotal_usage += table_size;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/page_idle.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/memory.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long total_usage;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nstatic unsigned long total_usage;\n\nstatic int __meminit init_section_page_ext(unsigned long pfn, int nid)\n{\n\tstruct mem_section *section;\n\tstruct page_ext *base;\n\tunsigned long table_size;\n\n\tsection = __pfn_to_section(pfn);\n\n\tif (section->page_ext)\n\t\treturn 0;\n\n\ttable_size = get_entry_size() * PAGES_PER_SECTION;\n\tbase = alloc_page_ext(table_size, nid);\n\n\t/*\n\t * The value stored in section->page_ext is (base - pfn)\n\t * and it does not point to the memory block allocated above,\n\t * causing kmemleak false positives.\n\t */\n\tkmemleak_not_leak(base);\n\n\tif (!base) {\n\t\tpr_err(\"page ext allocation failure\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/*\n\t * The passed \"pfn\" may not be aligned to SECTION.  For the calculation\n\t * we need to apply a mask.\n\t */\n\tpfn &= PAGE_SECTION_MASK;\n\tsection->page_ext = (void *)base - get_entry_size() * pfn;\n\ttotal_usage += table_size;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "early_pfn_to_nid",
          "args": [
            "pfn"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "early_pfn_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1292-1304",
          "snippet": "int __meminit early_pfn_to_nid(unsigned long pfn)\n{\n\tstatic DEFINE_SPINLOCK(early_pfn_lock);\n\tint nid;\n\n\tspin_lock(&early_pfn_lock);\n\tnid = __early_pfn_to_nid(pfn, &early_pfnnid_cache);\n\tif (nid < 0)\n\t\tnid = first_online_node;\n\tspin_unlock(&early_pfn_lock);\n\n\treturn nid;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nint __meminit early_pfn_to_nid(unsigned long pfn)\n{\n\tstatic DEFINE_SPINLOCK(early_pfn_lock);\n\tint nid;\n\n\tspin_lock(&early_pfn_lock);\n\tnid = __early_pfn_to_nid(pfn, &early_pfnnid_cache);\n\tif (nid < 0)\n\t\tnid = first_online_node;\n\tspin_unlock(&early_pfn_lock);\n\n\treturn nid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfn_valid",
          "args": [
            "pfn"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "pfn + 1",
            "PAGES_PER_SECTION"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_end_pfn",
          "args": [
            "nid"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_start_pfn",
          "args": [
            "nid"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_node_state",
          "args": [
            "nid",
            "N_MEMORY"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invoke_need_callbacks",
          "args": [],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "invoke_need_callbacks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
          "lines": "76-92",
          "snippet": "static bool __init invoke_need_callbacks(void)\n{\n\tint i;\n\tint entries = ARRAY_SIZE(page_ext_ops);\n\tbool need = false;\n\n\tfor (i = 0; i < entries; i++) {\n\t\tif (page_ext_ops[i]->need && page_ext_ops[i]->need()) {\n\t\t\tpage_ext_ops[i]->offset = sizeof(struct page_ext) +\n\t\t\t\t\t\textra_mem;\n\t\t\textra_mem += page_ext_ops[i]->size;\n\t\t\tneed = true;\n\t\t}\n\t}\n\n\treturn need;\n}",
          "includes": [
            "#include <linux/page_idle.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/memory.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct page_ext_operations *page_ext_ops[] = {\n#ifdef CONFIG_DEBUG_PAGEALLOC\n\t&debug_guardpage_ops,\n#endif\n#ifdef CONFIG_PAGE_OWNER\n\t&page_owner_ops,\n#endif\n#if defined(CONFIG_IDLE_PAGE_TRACKING) && !defined(CONFIG_64BIT)\n\t&page_idle_ops,\n#endif\n};",
            "static unsigned long extra_mem;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nstatic struct page_ext_operations *page_ext_ops[] = {\n#ifdef CONFIG_DEBUG_PAGEALLOC\n\t&debug_guardpage_ops,\n#endif\n#ifdef CONFIG_PAGE_OWNER\n\t&page_owner_ops,\n#endif\n#if defined(CONFIG_IDLE_PAGE_TRACKING) && !defined(CONFIG_64BIT)\n\t&page_idle_ops,\n#endif\n};\nstatic unsigned long extra_mem;\n\nstatic bool __init invoke_need_callbacks(void)\n{\n\tint i;\n\tint entries = ARRAY_SIZE(page_ext_ops);\n\tbool need = false;\n\n\tfor (i = 0; i < entries; i++) {\n\t\tif (page_ext_ops[i]->need && page_ext_ops[i]->need()) {\n\t\t\tpage_ext_ops[i]->offset = sizeof(struct page_ext) +\n\t\t\t\t\t\textra_mem;\n\t\t\textra_mem += page_ext_ops[i]->size;\n\t\t\tneed = true;\n\t\t}\n\t}\n\n\treturn need;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nstatic unsigned long total_usage;\n\nvoid __init page_ext_init(void)\n{\n\tunsigned long pfn;\n\tint nid;\n\n\tif (!invoke_need_callbacks())\n\t\treturn;\n\n\tfor_each_node_state(nid, N_MEMORY) {\n\t\tunsigned long start_pfn, end_pfn;\n\n\t\tstart_pfn = node_start_pfn(nid);\n\t\tend_pfn = node_end_pfn(nid);\n\t\t/*\n\t\t * start_pfn and end_pfn may not be aligned to SECTION and the\n\t\t * page->flags of out of node pages are not initialized.  So we\n\t\t * scan [start_pfn, the biggest section's pfn < end_pfn) here.\n\t\t */\n\t\tfor (pfn = start_pfn; pfn < end_pfn;\n\t\t\tpfn = ALIGN(pfn + 1, PAGES_PER_SECTION)) {\n\n\t\t\tif (!pfn_valid(pfn))\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Nodes's pfns can be overlapping.\n\t\t\t * We know some arch can have a nodes layout such as\n\t\t\t * -------------pfn-------------->\n\t\t\t * N0 | N1 | N2 | N0 | N1 | N2|....\n\t\t\t *\n\t\t\t * Take into account DEFERRED_STRUCT_PAGE_INIT.\n\t\t\t */\n\t\t\tif (early_pfn_to_nid(pfn) != nid)\n\t\t\t\tcontinue;\n\t\t\tif (init_section_page_ext(pfn, nid))\n\t\t\t\tgoto oom;\n\t\t\tcond_resched();\n\t\t}\n\t}\n\thotplug_memory_notifier(page_ext_callback, 0);\n\tpr_info(\"allocated %ld bytes of page_ext\\n\", total_usage);\n\tinvoke_init_callbacks();\n\treturn;\n\noom:\n\tpanic(\"Out of memory\");\n}"
  },
  {
    "function_name": "page_ext_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
    "lines": "342-369",
    "snippet": "static int __meminit page_ext_callback(struct notifier_block *self,\n\t\t\t       unsigned long action, void *arg)\n{\n\tstruct memory_notify *mn = arg;\n\tint ret = 0;\n\n\tswitch (action) {\n\tcase MEM_GOING_ONLINE:\n\t\tret = online_page_ext(mn->start_pfn,\n\t\t\t\t   mn->nr_pages, mn->status_change_nid);\n\t\tbreak;\n\tcase MEM_OFFLINE:\n\t\toffline_page_ext(mn->start_pfn,\n\t\t\t\tmn->nr_pages, mn->status_change_nid);\n\t\tbreak;\n\tcase MEM_CANCEL_ONLINE:\n\t\toffline_page_ext(mn->start_pfn,\n\t\t\t\tmn->nr_pages, mn->status_change_nid);\n\t\tbreak;\n\tcase MEM_GOING_OFFLINE:\n\t\tbreak;\n\tcase MEM_ONLINE:\n\tcase MEM_CANCEL_OFFLINE:\n\t\tbreak;\n\t}\n\n\treturn notifier_from_errno(ret);\n}",
    "includes": [
      "#include <linux/page_idle.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/memory.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "notifier_from_errno",
          "args": [
            "ret"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offline_page_ext",
          "args": [
            "mn->start_pfn",
            "mn->nr_pages",
            "mn->status_change_nid"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "offline_page_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
          "lines": "328-340",
          "snippet": "static int __meminit offline_page_ext(unsigned long start_pfn,\n\t\t\t\tunsigned long nr_pages, int nid)\n{\n\tunsigned long start, end, pfn;\n\n\tstart = SECTION_ALIGN_DOWN(start_pfn);\n\tend = SECTION_ALIGN_UP(start_pfn + nr_pages);\n\n\tfor (pfn = start; pfn < end; pfn += PAGES_PER_SECTION)\n\t\t__free_page_ext(pfn);\n\treturn 0;\n\n}",
          "includes": [
            "#include <linux/page_idle.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/memory.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nstatic int __meminit offline_page_ext(unsigned long start_pfn,\n\t\t\t\tunsigned long nr_pages, int nid)\n{\n\tunsigned long start, end, pfn;\n\n\tstart = SECTION_ALIGN_DOWN(start_pfn);\n\tend = SECTION_ALIGN_UP(start_pfn + nr_pages);\n\n\tfor (pfn = start; pfn < end; pfn += PAGES_PER_SECTION)\n\t\t__free_page_ext(pfn);\n\treturn 0;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "online_page_ext",
          "args": [
            "mn->start_pfn",
            "mn->nr_pages",
            "mn->status_change_nid"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "online_page_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
          "lines": "293-326",
          "snippet": "static int __meminit online_page_ext(unsigned long start_pfn,\n\t\t\t\tunsigned long nr_pages,\n\t\t\t\tint nid)\n{\n\tunsigned long start, end, pfn;\n\tint fail = 0;\n\n\tstart = SECTION_ALIGN_DOWN(start_pfn);\n\tend = SECTION_ALIGN_UP(start_pfn + nr_pages);\n\n\tif (nid == -1) {\n\t\t/*\n\t\t * In this case, \"nid\" already exists and contains valid memory.\n\t\t * \"start_pfn\" passed to us is a pfn which is an arg for\n\t\t * online__pages(), and start_pfn should exist.\n\t\t */\n\t\tnid = pfn_to_nid(start_pfn);\n\t\tVM_BUG_ON(!node_state(nid, N_ONLINE));\n\t}\n\n\tfor (pfn = start; !fail && pfn < end; pfn += PAGES_PER_SECTION) {\n\t\tif (!pfn_present(pfn))\n\t\t\tcontinue;\n\t\tfail = init_section_page_ext(pfn, nid);\n\t}\n\tif (!fail)\n\t\treturn 0;\n\n\t/* rollback */\n\tfor (pfn = start; pfn < end; pfn += PAGES_PER_SECTION)\n\t\t__free_page_ext(pfn);\n\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include <linux/page_idle.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/memory.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nstatic int __meminit online_page_ext(unsigned long start_pfn,\n\t\t\t\tunsigned long nr_pages,\n\t\t\t\tint nid)\n{\n\tunsigned long start, end, pfn;\n\tint fail = 0;\n\n\tstart = SECTION_ALIGN_DOWN(start_pfn);\n\tend = SECTION_ALIGN_UP(start_pfn + nr_pages);\n\n\tif (nid == -1) {\n\t\t/*\n\t\t * In this case, \"nid\" already exists and contains valid memory.\n\t\t * \"start_pfn\" passed to us is a pfn which is an arg for\n\t\t * online__pages(), and start_pfn should exist.\n\t\t */\n\t\tnid = pfn_to_nid(start_pfn);\n\t\tVM_BUG_ON(!node_state(nid, N_ONLINE));\n\t}\n\n\tfor (pfn = start; !fail && pfn < end; pfn += PAGES_PER_SECTION) {\n\t\tif (!pfn_present(pfn))\n\t\t\tcontinue;\n\t\tfail = init_section_page_ext(pfn, nid);\n\t}\n\tif (!fail)\n\t\treturn 0;\n\n\t/* rollback */\n\tfor (pfn = start; pfn < end; pfn += PAGES_PER_SECTION)\n\t\t__free_page_ext(pfn);\n\n\treturn -ENOMEM;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nstatic int __meminit page_ext_callback(struct notifier_block *self,\n\t\t\t       unsigned long action, void *arg)\n{\n\tstruct memory_notify *mn = arg;\n\tint ret = 0;\n\n\tswitch (action) {\n\tcase MEM_GOING_ONLINE:\n\t\tret = online_page_ext(mn->start_pfn,\n\t\t\t\t   mn->nr_pages, mn->status_change_nid);\n\t\tbreak;\n\tcase MEM_OFFLINE:\n\t\toffline_page_ext(mn->start_pfn,\n\t\t\t\tmn->nr_pages, mn->status_change_nid);\n\t\tbreak;\n\tcase MEM_CANCEL_ONLINE:\n\t\toffline_page_ext(mn->start_pfn,\n\t\t\t\tmn->nr_pages, mn->status_change_nid);\n\t\tbreak;\n\tcase MEM_GOING_OFFLINE:\n\t\tbreak;\n\tcase MEM_ONLINE:\n\tcase MEM_CANCEL_OFFLINE:\n\t\tbreak;\n\t}\n\n\treturn notifier_from_errno(ret);\n}"
  },
  {
    "function_name": "offline_page_ext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
    "lines": "328-340",
    "snippet": "static int __meminit offline_page_ext(unsigned long start_pfn,\n\t\t\t\tunsigned long nr_pages, int nid)\n{\n\tunsigned long start, end, pfn;\n\n\tstart = SECTION_ALIGN_DOWN(start_pfn);\n\tend = SECTION_ALIGN_UP(start_pfn + nr_pages);\n\n\tfor (pfn = start; pfn < end; pfn += PAGES_PER_SECTION)\n\t\t__free_page_ext(pfn);\n\treturn 0;\n\n}",
    "includes": [
      "#include <linux/page_idle.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/memory.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_page_ext",
          "args": [
            "pfn"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "__free_page_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
          "lines": "280-291",
          "snippet": "static void __free_page_ext(unsigned long pfn)\n{\n\tstruct mem_section *ms;\n\tstruct page_ext *base;\n\n\tms = __pfn_to_section(pfn);\n\tif (!ms || !ms->page_ext)\n\t\treturn;\n\tbase = get_entry(ms->page_ext, pfn);\n\tfree_page_ext(base);\n\tms->page_ext = NULL;\n}",
          "includes": [
            "#include <linux/page_idle.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/memory.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nstatic void __free_page_ext(unsigned long pfn)\n{\n\tstruct mem_section *ms;\n\tstruct page_ext *base;\n\n\tms = __pfn_to_section(pfn);\n\tif (!ms || !ms->page_ext)\n\t\treturn;\n\tbase = get_entry(ms->page_ext, pfn);\n\tfree_page_ext(base);\n\tms->page_ext = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SECTION_ALIGN_UP",
          "args": [
            "start_pfn + nr_pages"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SECTION_ALIGN_DOWN",
          "args": [
            "start_pfn"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nstatic int __meminit offline_page_ext(unsigned long start_pfn,\n\t\t\t\tunsigned long nr_pages, int nid)\n{\n\tunsigned long start, end, pfn;\n\n\tstart = SECTION_ALIGN_DOWN(start_pfn);\n\tend = SECTION_ALIGN_UP(start_pfn + nr_pages);\n\n\tfor (pfn = start; pfn < end; pfn += PAGES_PER_SECTION)\n\t\t__free_page_ext(pfn);\n\treturn 0;\n\n}"
  },
  {
    "function_name": "online_page_ext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
    "lines": "293-326",
    "snippet": "static int __meminit online_page_ext(unsigned long start_pfn,\n\t\t\t\tunsigned long nr_pages,\n\t\t\t\tint nid)\n{\n\tunsigned long start, end, pfn;\n\tint fail = 0;\n\n\tstart = SECTION_ALIGN_DOWN(start_pfn);\n\tend = SECTION_ALIGN_UP(start_pfn + nr_pages);\n\n\tif (nid == -1) {\n\t\t/*\n\t\t * In this case, \"nid\" already exists and contains valid memory.\n\t\t * \"start_pfn\" passed to us is a pfn which is an arg for\n\t\t * online__pages(), and start_pfn should exist.\n\t\t */\n\t\tnid = pfn_to_nid(start_pfn);\n\t\tVM_BUG_ON(!node_state(nid, N_ONLINE));\n\t}\n\n\tfor (pfn = start; !fail && pfn < end; pfn += PAGES_PER_SECTION) {\n\t\tif (!pfn_present(pfn))\n\t\t\tcontinue;\n\t\tfail = init_section_page_ext(pfn, nid);\n\t}\n\tif (!fail)\n\t\treturn 0;\n\n\t/* rollback */\n\tfor (pfn = start; pfn < end; pfn += PAGES_PER_SECTION)\n\t\t__free_page_ext(pfn);\n\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include <linux/page_idle.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/memory.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_page_ext",
          "args": [
            "pfn"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "__free_page_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
          "lines": "280-291",
          "snippet": "static void __free_page_ext(unsigned long pfn)\n{\n\tstruct mem_section *ms;\n\tstruct page_ext *base;\n\n\tms = __pfn_to_section(pfn);\n\tif (!ms || !ms->page_ext)\n\t\treturn;\n\tbase = get_entry(ms->page_ext, pfn);\n\tfree_page_ext(base);\n\tms->page_ext = NULL;\n}",
          "includes": [
            "#include <linux/page_idle.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/memory.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nstatic void __free_page_ext(unsigned long pfn)\n{\n\tstruct mem_section *ms;\n\tstruct page_ext *base;\n\n\tms = __pfn_to_section(pfn);\n\tif (!ms || !ms->page_ext)\n\t\treturn;\n\tbase = get_entry(ms->page_ext, pfn);\n\tfree_page_ext(base);\n\tms->page_ext = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_section_page_ext",
          "args": [
            "pfn",
            "nid"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "init_section_page_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
          "lines": "229-263",
          "snippet": "static int __meminit init_section_page_ext(unsigned long pfn, int nid)\n{\n\tstruct mem_section *section;\n\tstruct page_ext *base;\n\tunsigned long table_size;\n\n\tsection = __pfn_to_section(pfn);\n\n\tif (section->page_ext)\n\t\treturn 0;\n\n\ttable_size = get_entry_size() * PAGES_PER_SECTION;\n\tbase = alloc_page_ext(table_size, nid);\n\n\t/*\n\t * The value stored in section->page_ext is (base - pfn)\n\t * and it does not point to the memory block allocated above,\n\t * causing kmemleak false positives.\n\t */\n\tkmemleak_not_leak(base);\n\n\tif (!base) {\n\t\tpr_err(\"page ext allocation failure\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/*\n\t * The passed \"pfn\" may not be aligned to SECTION.  For the calculation\n\t * we need to apply a mask.\n\t */\n\tpfn &= PAGE_SECTION_MASK;\n\tsection->page_ext = (void *)base - get_entry_size() * pfn;\n\ttotal_usage += table_size;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/page_idle.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/memory.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long total_usage;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nstatic unsigned long total_usage;\n\nstatic int __meminit init_section_page_ext(unsigned long pfn, int nid)\n{\n\tstruct mem_section *section;\n\tstruct page_ext *base;\n\tunsigned long table_size;\n\n\tsection = __pfn_to_section(pfn);\n\n\tif (section->page_ext)\n\t\treturn 0;\n\n\ttable_size = get_entry_size() * PAGES_PER_SECTION;\n\tbase = alloc_page_ext(table_size, nid);\n\n\t/*\n\t * The value stored in section->page_ext is (base - pfn)\n\t * and it does not point to the memory block allocated above,\n\t * causing kmemleak false positives.\n\t */\n\tkmemleak_not_leak(base);\n\n\tif (!base) {\n\t\tpr_err(\"page ext allocation failure\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/*\n\t * The passed \"pfn\" may not be aligned to SECTION.  For the calculation\n\t * we need to apply a mask.\n\t */\n\tpfn &= PAGE_SECTION_MASK;\n\tsection->page_ext = (void *)base - get_entry_size() * pfn;\n\ttotal_usage += table_size;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfn_present",
          "args": [
            "pfn"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "!node_state(nid, N_ONLINE)"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_state",
          "args": [
            "nid",
            "N_ONLINE"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "inc_node_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/vmstat.c",
          "lines": "634-641",
          "snippet": "void inc_node_state(struct pglist_data *pgdat, enum node_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__inc_node_state(pgdat, item);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/page_owner.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/compaction.h>",
            "#include <linux/writeback.h>",
            "#include <linux/math64.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/err.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/page_owner.h>\n#include <linux/page_ext.h>\n#include <linux/mm_inline.h>\n#include <linux/compaction.h>\n#include <linux/writeback.h>\n#include <linux/math64.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/vmstat.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid inc_node_state(struct pglist_data *pgdat, enum node_stat_item item)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__inc_node_state(pgdat, item);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfn_to_nid",
          "args": [
            "start_pfn"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "early_pfn_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "1292-1304",
          "snippet": "int __meminit early_pfn_to_nid(unsigned long pfn)\n{\n\tstatic DEFINE_SPINLOCK(early_pfn_lock);\n\tint nid;\n\n\tspin_lock(&early_pfn_lock);\n\tnid = __early_pfn_to_nid(pfn, &early_pfnnid_cache);\n\tif (nid < 0)\n\t\tnid = first_online_node;\n\tspin_unlock(&early_pfn_lock);\n\n\treturn nid;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nint __meminit early_pfn_to_nid(unsigned long pfn)\n{\n\tstatic DEFINE_SPINLOCK(early_pfn_lock);\n\tint nid;\n\n\tspin_lock(&early_pfn_lock);\n\tnid = __early_pfn_to_nid(pfn, &early_pfnnid_cache);\n\tif (nid < 0)\n\t\tnid = first_online_node;\n\tspin_unlock(&early_pfn_lock);\n\n\treturn nid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SECTION_ALIGN_UP",
          "args": [
            "start_pfn + nr_pages"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SECTION_ALIGN_DOWN",
          "args": [
            "start_pfn"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nstatic int __meminit online_page_ext(unsigned long start_pfn,\n\t\t\t\tunsigned long nr_pages,\n\t\t\t\tint nid)\n{\n\tunsigned long start, end, pfn;\n\tint fail = 0;\n\n\tstart = SECTION_ALIGN_DOWN(start_pfn);\n\tend = SECTION_ALIGN_UP(start_pfn + nr_pages);\n\n\tif (nid == -1) {\n\t\t/*\n\t\t * In this case, \"nid\" already exists and contains valid memory.\n\t\t * \"start_pfn\" passed to us is a pfn which is an arg for\n\t\t * online__pages(), and start_pfn should exist.\n\t\t */\n\t\tnid = pfn_to_nid(start_pfn);\n\t\tVM_BUG_ON(!node_state(nid, N_ONLINE));\n\t}\n\n\tfor (pfn = start; !fail && pfn < end; pfn += PAGES_PER_SECTION) {\n\t\tif (!pfn_present(pfn))\n\t\t\tcontinue;\n\t\tfail = init_section_page_ext(pfn, nid);\n\t}\n\tif (!fail)\n\t\treturn 0;\n\n\t/* rollback */\n\tfor (pfn = start; pfn < end; pfn += PAGES_PER_SECTION)\n\t\t__free_page_ext(pfn);\n\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "__free_page_ext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
    "lines": "280-291",
    "snippet": "static void __free_page_ext(unsigned long pfn)\n{\n\tstruct mem_section *ms;\n\tstruct page_ext *base;\n\n\tms = __pfn_to_section(pfn);\n\tif (!ms || !ms->page_ext)\n\t\treturn;\n\tbase = get_entry(ms->page_ext, pfn);\n\tfree_page_ext(base);\n\tms->page_ext = NULL;\n}",
    "includes": [
      "#include <linux/page_idle.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/memory.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_page_ext",
          "args": [
            "base"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "__free_page_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
          "lines": "280-291",
          "snippet": "static void __free_page_ext(unsigned long pfn)\n{\n\tstruct mem_section *ms;\n\tstruct page_ext *base;\n\n\tms = __pfn_to_section(pfn);\n\tif (!ms || !ms->page_ext)\n\t\treturn;\n\tbase = get_entry(ms->page_ext, pfn);\n\tfree_page_ext(base);\n\tms->page_ext = NULL;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "get_entry",
          "args": [
            "ms->page_ext",
            "pfn"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "get_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
          "lines": "110-113",
          "snippet": "static inline struct page_ext *get_entry(void *base, unsigned long index)\n{\n\treturn base + get_entry_size() * index;\n}",
          "includes": [
            "#include <linux/page_idle.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/memory.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nstatic inline struct page_ext *get_entry(void *base, unsigned long index)\n{\n\treturn base + get_entry_size() * index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pfn_to_section",
          "args": [
            "pfn"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nstatic void __free_page_ext(unsigned long pfn)\n{\n\tstruct mem_section *ms;\n\tstruct page_ext *base;\n\n\tms = __pfn_to_section(pfn);\n\tif (!ms || !ms->page_ext)\n\t\treturn;\n\tbase = get_entry(ms->page_ext, pfn);\n\tfree_page_ext(base);\n\tms->page_ext = NULL;\n}"
  },
  {
    "function_name": "free_page_ext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
    "lines": "265-278",
    "snippet": "static void free_page_ext(void *addr)\n{\n\tif (is_vmalloc_addr(addr)) {\n\t\tvfree(addr);\n\t} else {\n\t\tstruct page *page = virt_to_page(addr);\n\t\tsize_t table_size;\n\n\t\ttable_size = get_entry_size() * PAGES_PER_SECTION;\n\n\t\tBUG_ON(PageReserved(page));\n\t\tfree_pages_exact(addr, table_size);\n\t}\n}",
    "includes": [
      "#include <linux/page_idle.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/memory.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_pages_exact",
          "args": [
            "addr",
            "table_size"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "free_pages_exact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4630-4639",
          "snippet": "void free_pages_exact(void *virt, size_t size)\n{\n\tunsigned long addr = (unsigned long)virt;\n\tunsigned long end = addr + PAGE_ALIGN(size);\n\n\twhile (addr < end) {\n\t\tfree_page(addr);\n\t\taddr += PAGE_SIZE;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nvoid free_pages_exact(void *virt, size_t size)\n{\n\tunsigned long addr = (unsigned long)virt;\n\tunsigned long end = addr + PAGE_ALIGN(size);\n\n\twhile (addr < end) {\n\t\tfree_page(addr);\n\t\taddr += PAGE_SIZE;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "PageReserved(page)"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageReserved",
          "args": [
            "page"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_entry_size",
          "args": [],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "get_entry_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
          "lines": "105-108",
          "snippet": "static unsigned long get_entry_size(void)\n{\n\treturn sizeof(struct page_ext) + extra_mem;\n}",
          "includes": [
            "#include <linux/page_idle.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/memory.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long extra_mem;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nstatic unsigned long extra_mem;\n\nstatic unsigned long get_entry_size(void)\n{\n\treturn sizeof(struct page_ext) + extra_mem;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "addr"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "addr"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "vfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "224-227",
          "snippet": "void vfree(const void *addr)\n{\n\tkfree(addr);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nvoid vfree(const void *addr)\n{\n\tkfree(addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_vmalloc_addr",
          "args": [
            "addr"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nstatic void free_page_ext(void *addr)\n{\n\tif (is_vmalloc_addr(addr)) {\n\t\tvfree(addr);\n\t} else {\n\t\tstruct page *page = virt_to_page(addr);\n\t\tsize_t table_size;\n\n\t\ttable_size = get_entry_size() * PAGES_PER_SECTION;\n\n\t\tBUG_ON(PageReserved(page));\n\t\tfree_pages_exact(addr, table_size);\n\t}\n}"
  },
  {
    "function_name": "init_section_page_ext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
    "lines": "229-263",
    "snippet": "static int __meminit init_section_page_ext(unsigned long pfn, int nid)\n{\n\tstruct mem_section *section;\n\tstruct page_ext *base;\n\tunsigned long table_size;\n\n\tsection = __pfn_to_section(pfn);\n\n\tif (section->page_ext)\n\t\treturn 0;\n\n\ttable_size = get_entry_size() * PAGES_PER_SECTION;\n\tbase = alloc_page_ext(table_size, nid);\n\n\t/*\n\t * The value stored in section->page_ext is (base - pfn)\n\t * and it does not point to the memory block allocated above,\n\t * causing kmemleak false positives.\n\t */\n\tkmemleak_not_leak(base);\n\n\tif (!base) {\n\t\tpr_err(\"page ext allocation failure\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/*\n\t * The passed \"pfn\" may not be aligned to SECTION.  For the calculation\n\t * we need to apply a mask.\n\t */\n\tpfn &= PAGE_SECTION_MASK;\n\tsection->page_ext = (void *)base - get_entry_size() * pfn;\n\ttotal_usage += table_size;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/page_idle.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/memory.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long total_usage;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_entry_size",
          "args": [],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "get_entry_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
          "lines": "105-108",
          "snippet": "static unsigned long get_entry_size(void)\n{\n\treturn sizeof(struct page_ext) + extra_mem;\n}",
          "includes": [
            "#include <linux/page_idle.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/memory.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long extra_mem;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nstatic unsigned long extra_mem;\n\nstatic unsigned long get_entry_size(void)\n{\n\treturn sizeof(struct page_ext) + extra_mem;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"page ext allocation failure\\n\""
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmemleak_not_leak",
          "args": [
            "base"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "kmemleak_not_leak_phys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1247-1251",
          "snippet": "void __ref kmemleak_not_leak_phys(phys_addr_t phys)\n{\n\tif (!IS_ENABLED(CONFIG_HIGHMEM) || PHYS_PFN(phys) < max_low_pfn)\n\t\tkmemleak_not_leak(__va(phys));\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nvoid __ref kmemleak_not_leak_phys(phys_addr_t phys)\n{\n\tif (!IS_ENABLED(CONFIG_HIGHMEM) || PHYS_PFN(phys) < max_low_pfn)\n\t\tkmemleak_not_leak(__va(phys));\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_page_ext",
          "args": [
            "table_size",
            "nid"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_page_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
          "lines": "213-227",
          "snippet": "static void *__meminit alloc_page_ext(size_t size, int nid)\n{\n\tgfp_t flags = GFP_KERNEL | __GFP_ZERO | __GFP_NOWARN;\n\tvoid *addr = NULL;\n\n\taddr = alloc_pages_exact_nid(nid, size, flags);\n\tif (addr) {\n\t\tkmemleak_alloc(addr, size, 1, flags);\n\t\treturn addr;\n\t}\n\n\taddr = vzalloc_node(size, nid);\n\n\treturn addr;\n}",
          "includes": [
            "#include <linux/page_idle.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/memory.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nstatic void *__meminit alloc_page_ext(size_t size, int nid)\n{\n\tgfp_t flags = GFP_KERNEL | __GFP_ZERO | __GFP_NOWARN;\n\tvoid *addr = NULL;\n\n\taddr = alloc_pages_exact_nid(nid, size, flags);\n\tif (addr) {\n\t\tkmemleak_alloc(addr, size, 1, flags);\n\t\treturn addr;\n\t}\n\n\taddr = vzalloc_node(size, nid);\n\n\treturn addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pfn_to_section",
          "args": [
            "pfn"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nstatic unsigned long total_usage;\n\nstatic int __meminit init_section_page_ext(unsigned long pfn, int nid)\n{\n\tstruct mem_section *section;\n\tstruct page_ext *base;\n\tunsigned long table_size;\n\n\tsection = __pfn_to_section(pfn);\n\n\tif (section->page_ext)\n\t\treturn 0;\n\n\ttable_size = get_entry_size() * PAGES_PER_SECTION;\n\tbase = alloc_page_ext(table_size, nid);\n\n\t/*\n\t * The value stored in section->page_ext is (base - pfn)\n\t * and it does not point to the memory block allocated above,\n\t * causing kmemleak false positives.\n\t */\n\tkmemleak_not_leak(base);\n\n\tif (!base) {\n\t\tpr_err(\"page ext allocation failure\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/*\n\t * The passed \"pfn\" may not be aligned to SECTION.  For the calculation\n\t * we need to apply a mask.\n\t */\n\tpfn &= PAGE_SECTION_MASK;\n\tsection->page_ext = (void *)base - get_entry_size() * pfn;\n\ttotal_usage += table_size;\n\treturn 0;\n}"
  },
  {
    "function_name": "alloc_page_ext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
    "lines": "213-227",
    "snippet": "static void *__meminit alloc_page_ext(size_t size, int nid)\n{\n\tgfp_t flags = GFP_KERNEL | __GFP_ZERO | __GFP_NOWARN;\n\tvoid *addr = NULL;\n\n\taddr = alloc_pages_exact_nid(nid, size, flags);\n\tif (addr) {\n\t\tkmemleak_alloc(addr, size, 1, flags);\n\t\treturn addr;\n\t}\n\n\taddr = vzalloc_node(size, nid);\n\n\treturn addr;\n}",
    "includes": [
      "#include <linux/page_idle.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/memory.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vzalloc_node",
          "args": [
            "size",
            "nid"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "vzalloc_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/nommu.c",
          "lines": "361-364",
          "snippet": "void *vzalloc_node(unsigned long size, int node)\n{\n\treturn vzalloc(size);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/tlb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/printk.h>",
            "#include <linux/audit.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/compiler.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/file.h>",
            "#include <linux/swap.h>",
            "#include <linux/mman.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/mmu_context.h>\n#include <asm/tlbflush.h>\n#include <asm/tlb.h>\n#include <linux/uaccess.h>\n#include <linux/printk.h>\n#include <linux/audit.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/compiler.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/file.h>\n#include <linux/swap.h>\n#include <linux/mman.h>\n#include <linux/vmacache.h>\n#include <linux/sched/mm.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nvoid *vzalloc_node(unsigned long size, int node)\n{\n\treturn vzalloc(size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmemleak_alloc",
          "args": [
            "addr",
            "size",
            "1",
            "flags"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "kmemleak_alloc_phys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/kmemleak.c",
          "lines": "1220-1225",
          "snippet": "void __ref kmemleak_alloc_phys(phys_addr_t phys, size_t size, int min_count,\n\t\t\t       gfp_t gfp)\n{\n\tif (!IS_ENABLED(CONFIG_HIGHMEM) || PHYS_PFN(phys) < max_low_pfn)\n\t\tkmemleak_alloc(__va(phys), size, min_count, gfp);\n}",
          "includes": [
            "#include <linux/memory_hotplug.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/kasan.h>",
            "#include <linux/atomic.h>",
            "#include <asm/processor.h>",
            "#include <asm/sections.h>",
            "#include <linux/crc32.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/mm.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/err.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/slab.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/pfn.h>",
            "#include <linux/memblock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cache.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/kthread.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memory_hotplug.h>\n#include <linux/kmemleak.h>\n#include <linux/kasan.h>\n#include <linux/atomic.h>\n#include <asm/processor.h>\n#include <asm/sections.h>\n#include <linux/crc32.h>\n#include <linux/workqueue.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/err.h>\n#include <linux/thread_info.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/pfn.h>\n#include <linux/memblock.h>\n#include <linux/percpu.h>\n#include <linux/cache.h>\n#include <linux/stacktrace.h>\n#include <linux/rcupdate.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nvoid __ref kmemleak_alloc_phys(phys_addr_t phys, size_t size, int min_count,\n\t\t\t       gfp_t gfp)\n{\n\tif (!IS_ENABLED(CONFIG_HIGHMEM) || PHYS_PFN(phys) < max_low_pfn)\n\t\tkmemleak_alloc(__va(phys), size, min_count, gfp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_pages_exact_nid",
          "args": [
            "nid",
            "size",
            "flags"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_pages_exact_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_alloc.c",
          "lines": "4614-4621",
          "snippet": "void * __meminit alloc_pages_exact_nid(int nid, size_t size, gfp_t gfp_mask)\n{\n\tunsigned int order = get_order(size);\n\tstruct page *p = alloc_pages_node(nid, gfp_mask, order);\n\tif (!p)\n\t\treturn NULL;\n\treturn make_alloc_exact((unsigned long)page_address(p), order, size);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/div64.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/psi.h>",
            "#include <linux/nmi.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/kthread.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/migrate.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/prefetch.h>",
            "#include <trace/events/oom.h>",
            "#include <trace/events/kmem.h>",
            "#include <linux/compaction.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/page-isolation.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/pfn.h>",
            "#include <linux/sort.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/memremap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/memory_hotplug.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/topology.h>",
            "#include <linux/oom.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/suspend.h>",
            "#include <linux/module.h>",
            "#include <linux/kasan.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __free_pages_ok(struct page *page, unsigned int order);",
            "static __always_inline\nstruct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/div64.h>\n#include <asm/tlbflush.h>\n#include <asm/sections.h>\n#include <linux/psi.h>\n#include <linux/nmi.h>\n#include <linux/lockdep.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/kthread.h>\n#include <linux/page_owner.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/migrate.h>\n#include <linux/mm_inline.h>\n#include <linux/prefetch.h>\n#include <trace/events/oom.h>\n#include <trace/events/kmem.h>\n#include <linux/compaction.h>\n#include <linux/kmemleak.h>\n#include <linux/debugobjects.h>\n#include <linux/page_ext.h>\n#include <linux/page-isolation.h>\n#include <linux/fault-inject.h>\n#include <linux/backing-dev.h>\n#include <linux/pfn.h>\n#include <linux/sort.h>\n#include <linux/stop_machine.h>\n#include <linux/memremap.h>\n#include <linux/mempolicy.h>\n#include <linux/vmstat.h>\n#include <linux/vmalloc.h>\n#include <linux/nodemask.h>\n#include <linux/memory_hotplug.h>\n#include <linux/cpuset.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/topology.h>\n#include <linux/oom.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/pagevec.h>\n#include <linux/suspend.h>\n#include <linux/module.h>\n#include <linux/kasan.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/interrupt.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/stddef.h>\n\nstatic void __free_pages_ok(struct page *page, unsigned int order);\nstatic __always_inline\nstruct;\nstatic __always_inline struct;\n\nvoid * __meminit alloc_pages_exact_nid(int nid, size_t size, gfp_t gfp_mask)\n{\n\tunsigned int order = get_order(size);\n\tstruct page *p = alloc_pages_node(nid, gfp_mask, order);\n\tif (!p)\n\t\treturn NULL;\n\treturn make_alloc_exact((unsigned long)page_address(p), order, size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nstatic void *__meminit alloc_page_ext(size_t size, int nid)\n{\n\tgfp_t flags = GFP_KERNEL | __GFP_ZERO | __GFP_NOWARN;\n\tvoid *addr = NULL;\n\n\taddr = alloc_pages_exact_nid(nid, size, flags);\n\tif (addr) {\n\t\tkmemleak_alloc(addr, size, 1, flags);\n\t\treturn addr;\n\t}\n\n\taddr = vzalloc_node(size, nid);\n\n\treturn addr;\n}"
  },
  {
    "function_name": "lookup_page_ext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
    "lines": "198-211",
    "snippet": "struct page_ext *lookup_page_ext(const struct page *page)\n{\n\tunsigned long pfn = page_to_pfn(page);\n\tstruct mem_section *section = __pfn_to_section(pfn);\n\t/*\n\t * The sanity checks the page allocator does upon freeing a\n\t * page can reach here before the page_ext arrays are\n\t * allocated when feeding a range of pages to the allocator\n\t * for the first time during bootup or memory hotplug.\n\t */\n\tif (!section->page_ext)\n\t\treturn NULL;\n\treturn get_entry(section->page_ext, pfn);\n}",
    "includes": [
      "#include <linux/page_idle.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/memory.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_entry",
          "args": [
            "section->page_ext",
            "pfn"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "get_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
          "lines": "110-113",
          "snippet": "static inline struct page_ext *get_entry(void *base, unsigned long index)\n{\n\treturn base + get_entry_size() * index;\n}",
          "includes": [
            "#include <linux/page_idle.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/memory.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nstatic inline struct page_ext *get_entry(void *base, unsigned long index)\n{\n\treturn base + get_entry_size() * index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pfn_to_section",
          "args": [
            "pfn"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "page"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nstruct page_ext *lookup_page_ext(const struct page *page)\n{\n\tunsigned long pfn = page_to_pfn(page);\n\tstruct mem_section *section = __pfn_to_section(pfn);\n\t/*\n\t * The sanity checks the page allocator does upon freeing a\n\t * page can reach here before the page_ext arrays are\n\t * allocated when feeding a range of pages to the allocator\n\t * for the first time during bootup or memory hotplug.\n\t */\n\tif (!section->page_ext)\n\t\treturn NULL;\n\treturn get_entry(section->page_ext, pfn);\n}"
  },
  {
    "function_name": "page_ext_init_flatmem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
    "lines": "174-194",
    "snippet": "void __init page_ext_init_flatmem(void)\n{\n\n\tint nid, fail;\n\n\tif (!invoke_need_callbacks())\n\t\treturn;\n\n\tfor_each_online_node(nid)  {\n\t\tfail = alloc_node_page_ext(nid);\n\t\tif (fail)\n\t\t\tgoto fail;\n\t}\n\tpr_info(\"allocated %ld bytes of page_ext\\n\", total_usage);\n\tinvoke_init_callbacks();\n\treturn;\n\nfail:\n\tpr_crit(\"allocation of page_ext failed.\\n\");\n\tpanic(\"Out of memory\");\n}",
    "includes": [
      "#include <linux/page_idle.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/memory.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long total_usage;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"Out of memory\""
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_crit",
          "args": [
            "\"allocation of page_ext failed.\\n\""
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invoke_init_callbacks",
          "args": [],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "invoke_init_callbacks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
          "lines": "94-103",
          "snippet": "static void __init invoke_init_callbacks(void)\n{\n\tint i;\n\tint entries = ARRAY_SIZE(page_ext_ops);\n\n\tfor (i = 0; i < entries; i++) {\n\t\tif (page_ext_ops[i]->init)\n\t\t\tpage_ext_ops[i]->init();\n\t}\n}",
          "includes": [
            "#include <linux/page_idle.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/memory.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct page_ext_operations *page_ext_ops[] = {\n#ifdef CONFIG_DEBUG_PAGEALLOC\n\t&debug_guardpage_ops,\n#endif\n#ifdef CONFIG_PAGE_OWNER\n\t&page_owner_ops,\n#endif\n#if defined(CONFIG_IDLE_PAGE_TRACKING) && !defined(CONFIG_64BIT)\n\t&page_idle_ops,\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nstatic struct page_ext_operations *page_ext_ops[] = {\n#ifdef CONFIG_DEBUG_PAGEALLOC\n\t&debug_guardpage_ops,\n#endif\n#ifdef CONFIG_PAGE_OWNER\n\t&page_owner_ops,\n#endif\n#if defined(CONFIG_IDLE_PAGE_TRACKING) && !defined(CONFIG_64BIT)\n\t&page_idle_ops,\n#endif\n};\n\nstatic void __init invoke_init_callbacks(void)\n{\n\tint i;\n\tint entries = ARRAY_SIZE(page_ext_ops);\n\n\tfor (i = 0; i < entries; i++) {\n\t\tif (page_ext_ops[i]->init)\n\t\t\tpage_ext_ops[i]->init();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"allocated %ld bytes of page_ext\\n\"",
            "total_usage"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_node_page_ext",
          "args": [
            "nid"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_node_page_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
          "lines": "143-172",
          "snippet": "static int __init alloc_node_page_ext(int nid)\n{\n\tstruct page_ext *base;\n\tunsigned long table_size;\n\tunsigned long nr_pages;\n\n\tnr_pages = NODE_DATA(nid)->node_spanned_pages;\n\tif (!nr_pages)\n\t\treturn 0;\n\n\t/*\n\t * Need extra space if node range is not aligned with\n\t * MAX_ORDER_NR_PAGES. When page allocator's buddy algorithm\n\t * checks buddy's status, range could be out of exact node range.\n\t */\n\tif (!IS_ALIGNED(node_start_pfn(nid), MAX_ORDER_NR_PAGES) ||\n\t\t!IS_ALIGNED(node_end_pfn(nid), MAX_ORDER_NR_PAGES))\n\t\tnr_pages += MAX_ORDER_NR_PAGES;\n\n\ttable_size = get_entry_size() * nr_pages;\n\n\tbase = memblock_alloc_try_nid_nopanic(\n\t\t\ttable_size, PAGE_SIZE, __pa(MAX_DMA_ADDRESS),\n\t\t\tMEMBLOCK_ALLOC_ACCESSIBLE, nid);\n\tif (!base)\n\t\treturn -ENOMEM;\n\tNODE_DATA(nid)->node_page_ext = base;\n\ttotal_usage += table_size;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/page_idle.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/memory.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long total_usage;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nstatic unsigned long total_usage;\n\nstatic int __init alloc_node_page_ext(int nid)\n{\n\tstruct page_ext *base;\n\tunsigned long table_size;\n\tunsigned long nr_pages;\n\n\tnr_pages = NODE_DATA(nid)->node_spanned_pages;\n\tif (!nr_pages)\n\t\treturn 0;\n\n\t/*\n\t * Need extra space if node range is not aligned with\n\t * MAX_ORDER_NR_PAGES. When page allocator's buddy algorithm\n\t * checks buddy's status, range could be out of exact node range.\n\t */\n\tif (!IS_ALIGNED(node_start_pfn(nid), MAX_ORDER_NR_PAGES) ||\n\t\t!IS_ALIGNED(node_end_pfn(nid), MAX_ORDER_NR_PAGES))\n\t\tnr_pages += MAX_ORDER_NR_PAGES;\n\n\ttable_size = get_entry_size() * nr_pages;\n\n\tbase = memblock_alloc_try_nid_nopanic(\n\t\t\ttable_size, PAGE_SIZE, __pa(MAX_DMA_ADDRESS),\n\t\t\tMEMBLOCK_ALLOC_ACCESSIBLE, nid);\n\tif (!base)\n\t\treturn -ENOMEM;\n\tNODE_DATA(nid)->node_page_ext = base;\n\ttotal_usage += table_size;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "invoke_need_callbacks",
          "args": [],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "invoke_need_callbacks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
          "lines": "76-92",
          "snippet": "static bool __init invoke_need_callbacks(void)\n{\n\tint i;\n\tint entries = ARRAY_SIZE(page_ext_ops);\n\tbool need = false;\n\n\tfor (i = 0; i < entries; i++) {\n\t\tif (page_ext_ops[i]->need && page_ext_ops[i]->need()) {\n\t\t\tpage_ext_ops[i]->offset = sizeof(struct page_ext) +\n\t\t\t\t\t\textra_mem;\n\t\t\textra_mem += page_ext_ops[i]->size;\n\t\t\tneed = true;\n\t\t}\n\t}\n\n\treturn need;\n}",
          "includes": [
            "#include <linux/page_idle.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/memory.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct page_ext_operations *page_ext_ops[] = {\n#ifdef CONFIG_DEBUG_PAGEALLOC\n\t&debug_guardpage_ops,\n#endif\n#ifdef CONFIG_PAGE_OWNER\n\t&page_owner_ops,\n#endif\n#if defined(CONFIG_IDLE_PAGE_TRACKING) && !defined(CONFIG_64BIT)\n\t&page_idle_ops,\n#endif\n};",
            "static unsigned long extra_mem;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nstatic struct page_ext_operations *page_ext_ops[] = {\n#ifdef CONFIG_DEBUG_PAGEALLOC\n\t&debug_guardpage_ops,\n#endif\n#ifdef CONFIG_PAGE_OWNER\n\t&page_owner_ops,\n#endif\n#if defined(CONFIG_IDLE_PAGE_TRACKING) && !defined(CONFIG_64BIT)\n\t&page_idle_ops,\n#endif\n};\nstatic unsigned long extra_mem;\n\nstatic bool __init invoke_need_callbacks(void)\n{\n\tint i;\n\tint entries = ARRAY_SIZE(page_ext_ops);\n\tbool need = false;\n\n\tfor (i = 0; i < entries; i++) {\n\t\tif (page_ext_ops[i]->need && page_ext_ops[i]->need()) {\n\t\t\tpage_ext_ops[i]->offset = sizeof(struct page_ext) +\n\t\t\t\t\t\textra_mem;\n\t\t\textra_mem += page_ext_ops[i]->size;\n\t\t\tneed = true;\n\t\t}\n\t}\n\n\treturn need;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nstatic unsigned long total_usage;\n\nvoid __init page_ext_init_flatmem(void)\n{\n\n\tint nid, fail;\n\n\tif (!invoke_need_callbacks())\n\t\treturn;\n\n\tfor_each_online_node(nid)  {\n\t\tfail = alloc_node_page_ext(nid);\n\t\tif (fail)\n\t\t\tgoto fail;\n\t}\n\tpr_info(\"allocated %ld bytes of page_ext\\n\", total_usage);\n\tinvoke_init_callbacks();\n\treturn;\n\nfail:\n\tpr_crit(\"allocation of page_ext failed.\\n\");\n\tpanic(\"Out of memory\");\n}"
  },
  {
    "function_name": "alloc_node_page_ext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
    "lines": "143-172",
    "snippet": "static int __init alloc_node_page_ext(int nid)\n{\n\tstruct page_ext *base;\n\tunsigned long table_size;\n\tunsigned long nr_pages;\n\n\tnr_pages = NODE_DATA(nid)->node_spanned_pages;\n\tif (!nr_pages)\n\t\treturn 0;\n\n\t/*\n\t * Need extra space if node range is not aligned with\n\t * MAX_ORDER_NR_PAGES. When page allocator's buddy algorithm\n\t * checks buddy's status, range could be out of exact node range.\n\t */\n\tif (!IS_ALIGNED(node_start_pfn(nid), MAX_ORDER_NR_PAGES) ||\n\t\t!IS_ALIGNED(node_end_pfn(nid), MAX_ORDER_NR_PAGES))\n\t\tnr_pages += MAX_ORDER_NR_PAGES;\n\n\ttable_size = get_entry_size() * nr_pages;\n\n\tbase = memblock_alloc_try_nid_nopanic(\n\t\t\ttable_size, PAGE_SIZE, __pa(MAX_DMA_ADDRESS),\n\t\t\tMEMBLOCK_ALLOC_ACCESSIBLE, nid);\n\tif (!base)\n\t\treturn -ENOMEM;\n\tNODE_DATA(nid)->node_page_ext = base;\n\ttotal_usage += table_size;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/page_idle.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/memory.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long total_usage;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "nid"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_alloc_try_nid_nopanic",
          "args": [
            "table_size",
            "PAGE_SIZE",
            "__pa(MAX_DMA_ADDRESS)",
            "MEMBLOCK_ALLOC_ACCESSIBLE",
            "nid"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "memblock_alloc_try_nid_nopanic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/memblock.c",
          "lines": "1481-1497",
          "snippet": "void * __init memblock_alloc_try_nid_nopanic(\n\t\t\t\tphys_addr_t size, phys_addr_t align,\n\t\t\t\tphys_addr_t min_addr, phys_addr_t max_addr,\n\t\t\t\tint nid)\n{\n\tvoid *ptr;\n\n\tmemblock_dbg(\"%s: %llu bytes align=0x%llx nid=%d from=%pa max_addr=%pa %pF\\n\",\n\t\t     __func__, (u64)size, (u64)align, nid, &min_addr,\n\t\t     &max_addr, (void *)_RET_IP_);\n\n\tptr = memblock_alloc_internal(size, align,\n\t\t\t\t\t   min_addr, max_addr, nid);\n\tif (ptr)\n\t\tmemset(ptr, 0, size);\n\treturn ptr;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/io.h>",
            "#include <asm/sections.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pfn.h>",
            "#include <linux/poison.h>",
            "#include <linux/bitops.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/io.h>\n#include <asm/sections.h>\n#include <linux/memblock.h>\n#include <linux/seq_file.h>\n#include <linux/kmemleak.h>\n#include <linux/debugfs.h>\n#include <linux/pfn.h>\n#include <linux/poison.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid * __init memblock_alloc_try_nid_nopanic(\n\t\t\t\tphys_addr_t size, phys_addr_t align,\n\t\t\t\tphys_addr_t min_addr, phys_addr_t max_addr,\n\t\t\t\tint nid)\n{\n\tvoid *ptr;\n\n\tmemblock_dbg(\"%s: %llu bytes align=0x%llx nid=%d from=%pa max_addr=%pa %pF\\n\",\n\t\t     __func__, (u64)size, (u64)align, nid, &min_addr,\n\t\t     &max_addr, (void *)_RET_IP_);\n\n\tptr = memblock_alloc_internal(size, align,\n\t\t\t\t\t   min_addr, max_addr, nid);\n\tif (ptr)\n\t\tmemset(ptr, 0, size);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "MAX_DMA_ADDRESS"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "__page_mapcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/util.c",
          "lines": "536-552",
          "snippet": "int __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mman.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/security.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/vmalloc.h>\n#include <linux/hugetlb.h>\n#include <linux/mman.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint __page_mapcount(struct page *page)\n{\n\tint ret;\n\n\tret = atomic_read(&page->_mapcount) + 1;\n\t/*\n\t * For file THP page->_mapcount contains total number of mapping\n\t * of the page: no need to look into compound_mapcount.\n\t */\n\tif (!PageAnon(page) && !PageHuge(page))\n\t\treturn ret;\n\tpage = compound_head(page);\n\tret += atomic_read(compound_mapcount_ptr(page)) + 1;\n\tif (PageDoubleMap(page))\n\t\tret--;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_entry_size",
          "args": [],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "get_entry_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
          "lines": "105-108",
          "snippet": "static unsigned long get_entry_size(void)\n{\n\treturn sizeof(struct page_ext) + extra_mem;\n}",
          "includes": [
            "#include <linux/page_idle.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/memory.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long extra_mem;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nstatic unsigned long extra_mem;\n\nstatic unsigned long get_entry_size(void)\n{\n\treturn sizeof(struct page_ext) + extra_mem;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "node_end_pfn(nid)",
            "MAX_ORDER_NR_PAGES"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_end_pfn",
          "args": [
            "nid"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "node_start_pfn(nid)",
            "MAX_ORDER_NR_PAGES"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_start_pfn",
          "args": [
            "nid"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "nid"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nstatic unsigned long total_usage;\n\nstatic int __init alloc_node_page_ext(int nid)\n{\n\tstruct page_ext *base;\n\tunsigned long table_size;\n\tunsigned long nr_pages;\n\n\tnr_pages = NODE_DATA(nid)->node_spanned_pages;\n\tif (!nr_pages)\n\t\treturn 0;\n\n\t/*\n\t * Need extra space if node range is not aligned with\n\t * MAX_ORDER_NR_PAGES. When page allocator's buddy algorithm\n\t * checks buddy's status, range could be out of exact node range.\n\t */\n\tif (!IS_ALIGNED(node_start_pfn(nid), MAX_ORDER_NR_PAGES) ||\n\t\t!IS_ALIGNED(node_end_pfn(nid), MAX_ORDER_NR_PAGES))\n\t\tnr_pages += MAX_ORDER_NR_PAGES;\n\n\ttable_size = get_entry_size() * nr_pages;\n\n\tbase = memblock_alloc_try_nid_nopanic(\n\t\t\ttable_size, PAGE_SIZE, __pa(MAX_DMA_ADDRESS),\n\t\t\tMEMBLOCK_ALLOC_ACCESSIBLE, nid);\n\tif (!base)\n\t\treturn -ENOMEM;\n\tNODE_DATA(nid)->node_page_ext = base;\n\ttotal_usage += table_size;\n\treturn 0;\n}"
  },
  {
    "function_name": "lookup_page_ext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
    "lines": "123-141",
    "snippet": "struct page_ext *lookup_page_ext(const struct page *page)\n{\n\tunsigned long pfn = page_to_pfn(page);\n\tunsigned long index;\n\tstruct page_ext *base;\n\n\tbase = NODE_DATA(page_to_nid(page))->node_page_ext;\n\t/*\n\t * The sanity checks the page allocator does upon freeing a\n\t * page can reach here before the page_ext arrays are\n\t * allocated when feeding a range of pages to the allocator\n\t * for the first time during bootup or memory hotplug.\n\t */\n\tif (unlikely(!base))\n\t\treturn NULL;\n\tindex = pfn - round_down(node_start_pfn(page_to_nid(page)),\n\t\t\t\t\tMAX_ORDER_NR_PAGES);\n\treturn get_entry(base, index);\n}",
    "includes": [
      "#include <linux/page_idle.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/memory.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_entry",
          "args": [
            "base",
            "index"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "get_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
          "lines": "110-113",
          "snippet": "static inline struct page_ext *get_entry(void *base, unsigned long index)\n{\n\treturn base + get_entry_size() * index;\n}",
          "includes": [
            "#include <linux/page_idle.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/memory.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nstatic inline struct page_ext *get_entry(void *base, unsigned long index)\n{\n\treturn base + get_entry_size() * index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "round_down",
          "args": [
            "node_start_pfn(page_to_nid(page))",
            "MAX_ORDER_NR_PAGES"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_start_pfn",
          "args": [
            "page_to_nid(page)"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_nid",
          "args": [
            "page"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_nid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/sparse.c",
          "lines": "45-48",
          "snippet": "int page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}",
          "includes": [
            "#include <asm/pgtable.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/dma.h>",
            "#include \"internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/dma.h>\n#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint page_to_nid(const struct page *page)\n{\n\treturn section_to_node_table[page_to_section(page)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!base"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NODE_DATA",
          "args": [
            "page_to_nid(page)"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "page"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nstruct page_ext *lookup_page_ext(const struct page *page)\n{\n\tunsigned long pfn = page_to_pfn(page);\n\tunsigned long index;\n\tstruct page_ext *base;\n\n\tbase = NODE_DATA(page_to_nid(page))->node_page_ext;\n\t/*\n\t * The sanity checks the page allocator does upon freeing a\n\t * page can reach here before the page_ext arrays are\n\t * allocated when feeding a range of pages to the allocator\n\t * for the first time during bootup or memory hotplug.\n\t */\n\tif (unlikely(!base))\n\t\treturn NULL;\n\tindex = pfn - round_down(node_start_pfn(page_to_nid(page)),\n\t\t\t\t\tMAX_ORDER_NR_PAGES);\n\treturn get_entry(base, index);\n}"
  },
  {
    "function_name": "pgdat_page_ext_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
    "lines": "118-121",
    "snippet": "void __meminit pgdat_page_ext_init(struct pglist_data *pgdat)\n{\n\tpgdat->node_page_ext = NULL;\n}",
    "includes": [
      "#include <linux/page_idle.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/memory.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nvoid __meminit pgdat_page_ext_init(struct pglist_data *pgdat)\n{\n\tpgdat->node_page_ext = NULL;\n}"
  },
  {
    "function_name": "get_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
    "lines": "110-113",
    "snippet": "static inline struct page_ext *get_entry(void *base, unsigned long index)\n{\n\treturn base + get_entry_size() * index;\n}",
    "includes": [
      "#include <linux/page_idle.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/memory.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_entry_size",
          "args": [],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "get_entry_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
          "lines": "105-108",
          "snippet": "static unsigned long get_entry_size(void)\n{\n\treturn sizeof(struct page_ext) + extra_mem;\n}",
          "includes": [
            "#include <linux/page_idle.h>",
            "#include <linux/page_owner.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/memory.h>",
            "#include <linux/page_ext.h>",
            "#include <linux/memblock.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long extra_mem;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nstatic unsigned long extra_mem;\n\nstatic unsigned long get_entry_size(void)\n{\n\treturn sizeof(struct page_ext) + extra_mem;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nstatic inline struct page_ext *get_entry(void *base, unsigned long index)\n{\n\treturn base + get_entry_size() * index;\n}"
  },
  {
    "function_name": "get_entry_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
    "lines": "105-108",
    "snippet": "static unsigned long get_entry_size(void)\n{\n\treturn sizeof(struct page_ext) + extra_mem;\n}",
    "includes": [
      "#include <linux/page_idle.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/memory.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long extra_mem;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nstatic unsigned long extra_mem;\n\nstatic unsigned long get_entry_size(void)\n{\n\treturn sizeof(struct page_ext) + extra_mem;\n}"
  },
  {
    "function_name": "invoke_init_callbacks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
    "lines": "94-103",
    "snippet": "static void __init invoke_init_callbacks(void)\n{\n\tint i;\n\tint entries = ARRAY_SIZE(page_ext_ops);\n\n\tfor (i = 0; i < entries; i++) {\n\t\tif (page_ext_ops[i]->init)\n\t\t\tpage_ext_ops[i]->init();\n\t}\n}",
    "includes": [
      "#include <linux/page_idle.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/memory.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct page_ext_operations *page_ext_ops[] = {\n#ifdef CONFIG_DEBUG_PAGEALLOC\n\t&debug_guardpage_ops,\n#endif\n#ifdef CONFIG_PAGE_OWNER\n\t&page_owner_ops,\n#endif\n#if defined(CONFIG_IDLE_PAGE_TRACKING) && !defined(CONFIG_64BIT)\n\t&page_idle_ops,\n#endif\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_ext_ops[i]->init",
          "args": [],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "page_ext_ops"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nstatic struct page_ext_operations *page_ext_ops[] = {\n#ifdef CONFIG_DEBUG_PAGEALLOC\n\t&debug_guardpage_ops,\n#endif\n#ifdef CONFIG_PAGE_OWNER\n\t&page_owner_ops,\n#endif\n#if defined(CONFIG_IDLE_PAGE_TRACKING) && !defined(CONFIG_64BIT)\n\t&page_idle_ops,\n#endif\n};\n\nstatic void __init invoke_init_callbacks(void)\n{\n\tint i;\n\tint entries = ARRAY_SIZE(page_ext_ops);\n\n\tfor (i = 0; i < entries; i++) {\n\t\tif (page_ext_ops[i]->init)\n\t\t\tpage_ext_ops[i]->init();\n\t}\n}"
  },
  {
    "function_name": "invoke_need_callbacks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/mm/page_ext.c",
    "lines": "76-92",
    "snippet": "static bool __init invoke_need_callbacks(void)\n{\n\tint i;\n\tint entries = ARRAY_SIZE(page_ext_ops);\n\tbool need = false;\n\n\tfor (i = 0; i < entries; i++) {\n\t\tif (page_ext_ops[i]->need && page_ext_ops[i]->need()) {\n\t\t\tpage_ext_ops[i]->offset = sizeof(struct page_ext) +\n\t\t\t\t\t\textra_mem;\n\t\t\textra_mem += page_ext_ops[i]->size;\n\t\t\tneed = true;\n\t\t}\n\t}\n\n\treturn need;\n}",
    "includes": [
      "#include <linux/page_idle.h>",
      "#include <linux/page_owner.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/memory.h>",
      "#include <linux/page_ext.h>",
      "#include <linux/memblock.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct page_ext_operations *page_ext_ops[] = {\n#ifdef CONFIG_DEBUG_PAGEALLOC\n\t&debug_guardpage_ops,\n#endif\n#ifdef CONFIG_PAGE_OWNER\n\t&page_owner_ops,\n#endif\n#if defined(CONFIG_IDLE_PAGE_TRACKING) && !defined(CONFIG_64BIT)\n\t&page_idle_ops,\n#endif\n};",
      "static unsigned long extra_mem;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_ext_ops[i]->need",
          "args": [],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "page_ext_ops"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/page_idle.h>\n#include <linux/page_owner.h>\n#include <linux/kmemleak.h>\n#include <linux/vmalloc.h>\n#include <linux/memory.h>\n#include <linux/page_ext.h>\n#include <linux/memblock.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n\nstatic struct page_ext_operations *page_ext_ops[] = {\n#ifdef CONFIG_DEBUG_PAGEALLOC\n\t&debug_guardpage_ops,\n#endif\n#ifdef CONFIG_PAGE_OWNER\n\t&page_owner_ops,\n#endif\n#if defined(CONFIG_IDLE_PAGE_TRACKING) && !defined(CONFIG_64BIT)\n\t&page_idle_ops,\n#endif\n};\nstatic unsigned long extra_mem;\n\nstatic bool __init invoke_need_callbacks(void)\n{\n\tint i;\n\tint entries = ARRAY_SIZE(page_ext_ops);\n\tbool need = false;\n\n\tfor (i = 0; i < entries; i++) {\n\t\tif (page_ext_ops[i]->need && page_ext_ops[i]->need()) {\n\t\t\tpage_ext_ops[i]->offset = sizeof(struct page_ext) +\n\t\t\t\t\t\textra_mem;\n\t\t\textra_mem += page_ext_ops[i]->size;\n\t\t\tneed = true;\n\t\t}\n\t}\n\n\treturn need;\n}"
  }
]